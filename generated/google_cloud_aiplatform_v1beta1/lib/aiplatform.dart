// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Vertex AI API.
///
/// Train high-quality custom machine learning models with minimal machine
/// learning expertise and effort.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_api/api.dart';
import 'package:google_cloud_iam_v1/iam.dart';
import 'package:google_cloud_location/location.dart';
import 'package:google_cloud_longrunning/longrunning.dart';
import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/protobuf.dart' as protobuf;
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/rpc.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:google_cloud_type/type.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// The service that manages Vertex AI Dataset and its child resources.
final class DatasetService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `DatasetService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `DatasetService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  DatasetService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `DatasetService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory DatasetService.fromApiKey([String? apiKey]) =>
      DatasetService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Dataset, CreateDatasetOperationMetadata>> createDataset(
    CreateDatasetRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/datasets');
    final response = await _client.post(url, body: request.dataset);
    return Operation.fromJson(
      response,
      OperationHelper(
        Dataset.fromJson,
        CreateDatasetOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Dataset> getDataset(GetDatasetRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return Dataset.fromJson(response);
  }

  /// Updates a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Dataset> updateDataset(UpdateDatasetRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.dataset!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.dataset);
    return Dataset.fromJson(response);
  }

  /// Lists Datasets in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDatasetsResponse> listDatasets(ListDatasetsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/datasets', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListDatasetsResponse.fromJson(response);
  }

  /// Deletes a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteDataset(
    DeleteDatasetRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Imports data into a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ImportDataResponse, ImportDataOperationMetadata>> importData(
    ImportDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:import');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ImportDataResponse.fromJson,
        ImportDataOperationMetadata.fromJson,
      ),
    );
  }

  /// Exports data from a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ExportDataResponse, ExportDataOperationMetadata>> exportData(
    ExportDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:export');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExportDataResponse.fromJson,
        ExportDataOperationMetadata.fromJson,
      ),
    );
  }

  /// Create a version from a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DatasetVersion, CreateDatasetVersionOperationMetadata>>
  createDatasetVersion(CreateDatasetVersionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/datasetVersions');
    final response = await _client.post(url, body: request.datasetVersion);
    return Operation.fromJson(
      response,
      OperationHelper(
        DatasetVersion.fromJson,
        CreateDatasetVersionOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a DatasetVersion.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DatasetVersion> updateDatasetVersion(
    UpdateDatasetVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.datasetVersion!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.datasetVersion);
    return DatasetVersion.fromJson(response);
  }

  /// Deletes a Dataset version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteDatasetVersion(DeleteDatasetVersionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Dataset version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DatasetVersion> getDatasetVersion(
    GetDatasetVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return DatasetVersion.fromJson(response);
  }

  /// Lists DatasetVersions in a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDatasetVersionsResponse> listDatasetVersions(
    ListDatasetVersionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/datasetVersions', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListDatasetVersionsResponse.fromJson(response);
  }

  /// Restores a dataset version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DatasetVersion, RestoreDatasetVersionOperationMetadata>>
  restoreDatasetVersion(RestoreDatasetVersionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:restore');
    final response = await _client.get(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        DatasetVersion.fromJson,
        RestoreDatasetVersionOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists DataItems in a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDataItemsResponse> listDataItems(
    ListDataItemsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/dataItems', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListDataItemsResponse.fromJson(response);
  }

  /// Searches DataItems in a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchDataItemsResponse> searchDataItems(
    SearchDataItemsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.dataset}:searchDataItems', {
          if (request.orderByDataItem case final $1?) 'orderByDataItem': $1,
          if (request.orderByAnnotation!.savedQuery case final $1
              when $1.isNotDefault)
            'orderByAnnotation.savedQuery': $1,
          if (request.orderByAnnotation!.orderBy case final $1
              when $1.isNotDefault)
            'orderByAnnotation.orderBy': $1,
          if (request.savedQuery case final $1 when $1.isNotDefault)
            'savedQuery': $1,
          if (request.dataLabelingJob case final $1 when $1.isNotDefault)
            'dataLabelingJob': $1,
          if (request.dataItemFilter case final $1 when $1.isNotDefault)
            'dataItemFilter': $1,
          if (request.annotationsFilter case final $1 when $1.isNotDefault)
            'annotationsFilter': $1,
          if (request.annotationFilters case final $1 when $1.isNotDefault)
            'annotationFilters': $1,
          if (request.fieldMask case final $1?) 'fieldMask': $1.toJson(),
          if (request.annotationsLimit case final $1 when $1.isNotDefault)
            'annotationsLimit': '${$1}',
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
        });
    final response = await _client.get(url);
    return SearchDataItemsResponse.fromJson(response);
  }

  /// Lists SavedQueries in a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSavedQueriesResponse> listSavedQueries(
    ListSavedQueriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/savedQueries', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListSavedQueriesResponse.fromJson(response);
  }

  /// Deletes a SavedQuery.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteSavedQuery(
    DeleteSavedQueryRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets an AnnotationSpec.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnnotationSpec> getAnnotationSpec(
    GetAnnotationSpecRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return AnnotationSpec.fromJson(response);
  }

  /// Lists Annotations belongs to a dataitem.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListAnnotationsResponse> listAnnotations(
    ListAnnotationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/annotations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListAnnotationsResponse.fromJson(response);
  }

  /// Assesses the state or validity of the dataset with respect to a given use
  /// case.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<AssessDataResponse, AssessDataOperationMetadata>> assessData(
    AssessDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:assess');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        AssessDataResponse.fromJson,
        AssessDataOperationMetadata.fromJson,
      ),
    );
  }

  /// Assembles each row of a multimodal dataset and writes the result into a
  /// BigQuery table.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<AssembleDataResponse, AssembleDataOperationMetadata>>
  assembleData(AssembleDataRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:assemble');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        AssembleDataResponse.fromJson,
        AssembleDataOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service that manages the DeploymentResourcePool resource.
final class DeploymentResourcePoolService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `DeploymentResourcePoolService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `DeploymentResourcePoolService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  DeploymentResourcePoolService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `DeploymentResourcePoolService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory DeploymentResourcePoolService.fromApiKey([String? apiKey]) =>
      DeploymentResourcePoolService(
        client: httpClientFromApiKey(apiKey, _apiKeys),
      );

  /// Create a DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      DeploymentResourcePool,
      CreateDeploymentResourcePoolOperationMetadata
    >
  >
  createDeploymentResourcePool(
    CreateDeploymentResourcePoolRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/deploymentResourcePools',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeploymentResourcePool.fromJson,
        CreateDeploymentResourcePoolOperationMetadata.fromJson,
      ),
    );
  }

  /// Get a DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DeploymentResourcePool> getDeploymentResourcePool(
    GetDeploymentResourcePoolRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return DeploymentResourcePool.fromJson(response);
  }

  /// List DeploymentResourcePools in a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDeploymentResourcePoolsResponse> listDeploymentResourcePools(
    ListDeploymentResourcePoolsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/deploymentResourcePools', {
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
        });
    final response = await _client.get(url);
    return ListDeploymentResourcePoolsResponse.fromJson(response);
  }

  /// Update a DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      DeploymentResourcePool,
      UpdateDeploymentResourcePoolOperationMetadata
    >
  >
  updateDeploymentResourcePool(
    UpdateDeploymentResourcePoolRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.deploymentResourcePool!.name}',
      {if (request.updateMask case final $1?) 'updateMask': $1.toJson()},
    );
    final response = await _client.patch(
      url,
      body: request.deploymentResourcePool,
    );
    return Operation.fromJson(
      response,
      OperationHelper(
        DeploymentResourcePool.fromJson,
        UpdateDeploymentResourcePoolOperationMetadata.fromJson,
      ),
    );
  }

  /// Delete a DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteDeploymentResourcePool(
    DeleteDeploymentResourcePoolRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// List DeployedModels that have been deployed on this DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<QueryDeployedModelsResponse> queryDeployedModels(
    QueryDeployedModelsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.deploymentResourcePool}:queryDeployedModels',
      {
        if (request.pageSize case final $1 when $1.isNotDefault)
          'pageSize': '${$1}',
        if (request.pageToken case final $1 when $1.isNotDefault)
          'pageToken': $1,
      },
    );
    final response = await _client.get(url);
    return QueryDeployedModelsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's Endpoints.
final class EndpointService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `EndpointService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `EndpointService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  EndpointService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `EndpointService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory EndpointService.fromApiKey([String? apiKey]) =>
      EndpointService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates an Endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Endpoint, CreateEndpointOperationMetadata>> createEndpoint(
    CreateEndpointRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/endpoints', {
      if (request.endpointId case final $1 when $1.isNotDefault)
        'endpointId': $1,
    });
    final response = await _client.post(url, body: request.endpoint);
    return Operation.fromJson(
      response,
      OperationHelper(
        Endpoint.fromJson,
        CreateEndpointOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets an Endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Endpoint> getEndpoint(GetEndpointRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Endpoint.fromJson(response);
  }

  /// Lists Endpoints in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListEndpointsResponse> listEndpoints(
    ListEndpointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/endpoints', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListEndpointsResponse.fromJson(response);
  }

  /// Updates an Endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Endpoint> updateEndpoint(UpdateEndpointRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.endpoint);
    return Endpoint.fromJson(response);
  }

  /// Updates an Endpoint with a long running operation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Endpoint, UpdateEndpointOperationMetadata>>
  updateEndpointLongRunning(UpdateEndpointLongRunningRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint!.name}:update');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        Endpoint.fromJson,
        UpdateEndpointOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes an Endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteEndpoint(
    DeleteEndpointRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Deploys a Model into this Endpoint, creating a DeployedModel within it.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DeployModelResponse, DeployModelOperationMetadata>>
  deployModel(DeployModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:deployModel');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeployModelResponse.fromJson,
        DeployModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Undeploys a Model from an Endpoint, removing a DeployedModel from it, and
  /// freeing all resources it's using.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<UndeployModelResponse, UndeployModelOperationMetadata>>
  undeployModel(UndeployModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:undeployModel');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UndeployModelResponse.fromJson,
        UndeployModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates an existing deployed model. Updatable fields include
  /// `min_replica_count`, `max_replica_count`, `required_replica_count`,
  /// `autoscaling_metric_specs`, `disable_container_logging` (v1 only), and
  /// `enable_container_logging` (v1beta1 only).
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<MutateDeployedModelResponse, MutateDeployedModelOperationMetadata>
  >
  mutateDeployedModel(MutateDeployedModelRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}:mutateDeployedModel',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        MutateDeployedModelResponse.fromJson,
        MutateDeployedModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Sets (creates or updates) configs of publisher models. For example, sets
  /// the request/response logging config.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<PublisherModelConfig, SetPublisherModelConfigOperationMetadata>
  >
  setPublisherModelConfig(SetPublisherModelConfigRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.name}:setPublisherModelConfig',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PublisherModelConfig.fromJson,
        SetPublisherModelConfigOperationMetadata.fromJson,
      ),
    );
  }

  /// Fetches the configs of publisher models.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PublisherModelConfig> fetchPublisherModelConfig(
    FetchPublisherModelConfigRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.name}:fetchPublisherModelConfig',
    );
    final response = await _client.get(url);
    return PublisherModelConfig.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Vertex AI Online Evaluation Service.
final class EvaluationService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `EvaluationService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `EvaluationService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  EvaluationService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `EvaluationService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory EvaluationService.fromApiKey([String? apiKey]) =>
      EvaluationService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Evaluates instances based on a given metric.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EvaluateInstancesResponse> evaluateInstances(
    EvaluateInstancesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.location}:evaluateInstances',
    );
    final response = await _client.post(url, body: request);
    return EvaluateInstancesResponse.fromJson(response);
  }

  /// Evaluates a dataset based on a set of given metrics.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<EvaluateDatasetResponse, EvaluateDatasetOperationMetadata>>
  evaluateDataset(EvaluateDatasetRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.location}:evaluateDataset',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        EvaluateDatasetResponse.fromJson,
        EvaluateDatasetOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing and retrieving few-shot examples.
final class ExampleStoreService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ExampleStoreService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ExampleStoreService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ExampleStoreService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ExampleStoreService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ExampleStoreService.fromApiKey([String? apiKey]) =>
      ExampleStoreService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Create an ExampleStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ExampleStore, CreateExampleStoreOperationMetadata>>
  createExampleStore(CreateExampleStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/exampleStores');
    final response = await _client.post(url, body: request.exampleStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExampleStore.fromJson,
        CreateExampleStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Get an ExampleStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ExampleStore> getExampleStore(GetExampleStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ExampleStore.fromJson(response);
  }

  /// Update an ExampleStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ExampleStore, UpdateExampleStoreOperationMetadata>>
  updateExampleStore(UpdateExampleStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.exampleStore!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.exampleStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExampleStore.fromJson,
        UpdateExampleStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Delete an ExampleStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteExampleStoreOperationMetadata>>
  deleteExampleStore(DeleteExampleStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteExampleStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// List ExampleStores in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListExampleStoresResponse> listExampleStores(
    ListExampleStoresRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/exampleStores', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListExampleStoresResponse.fromJson(response);
  }

  /// Create or update Examples in the Example Store.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<UpsertExamplesResponse> upsertExamples(
    UpsertExamplesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.exampleStore}:upsertExamples',
    );
    final response = await _client.post(url, body: request);
    return UpsertExamplesResponse.fromJson(response);
  }

  /// Remove Examples from the Example Store.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RemoveExamplesResponse> removeExamples(
    RemoveExamplesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.exampleStore}:removeExamples',
    );
    final response = await _client.post(url, body: request);
    return RemoveExamplesResponse.fromJson(response);
  }

  /// Search for similar Examples for given selection criteria.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchExamplesResponse> searchExamples(
    SearchExamplesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.exampleStore}:searchExamples',
    );
    final response = await _client.post(url, body: request);
    return SearchExamplesResponse.fromJson(response);
  }

  /// Get Examples from the Example Store.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FetchExamplesResponse> fetchExamples(
    FetchExamplesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.exampleStore}:fetchExamples',
    );
    final response = await _client.post(url, body: request);
    return FetchExamplesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for Extension execution.
final class ExtensionExecutionService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ExtensionExecutionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ExtensionExecutionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ExtensionExecutionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ExtensionExecutionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ExtensionExecutionService.fromApiKey([String? apiKey]) =>
      ExtensionExecutionService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Executes the request against a given extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ExecuteExtensionResponse> executeExtension(
    ExecuteExtensionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:execute');
    final response = await _client.post(url, body: request);
    return ExecuteExtensionResponse.fromJson(response);
  }

  /// Queries an extension with a default controller.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<QueryExtensionResponse> queryExtension(
    QueryExtensionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:query');
    final response = await _client.post(url, body: request);
    return QueryExtensionResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's Extension registry.
final class ExtensionRegistryService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ExtensionRegistryService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ExtensionRegistryService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ExtensionRegistryService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ExtensionRegistryService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ExtensionRegistryService.fromApiKey([String? apiKey]) =>
      ExtensionRegistryService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Imports an Extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Extension, ImportExtensionOperationMetadata>>
  importExtension(ImportExtensionRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/extensions:import',
    );
    final response = await _client.post(url, body: request.extension);
    return Operation.fromJson(
      response,
      OperationHelper(
        Extension.fromJson,
        ImportExtensionOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets an Extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Extension> getExtension(GetExtensionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Extension.fromJson(response);
  }

  /// Lists Extensions in a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListExtensionsResponse> listExtensions(
    ListExtensionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/extensions', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListExtensionsResponse.fromJson(response);
  }

  /// Updates an Extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Extension> updateExtension(UpdateExtensionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.extension!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.extension);
    return Extension.fromJson(response);
  }

  /// Deletes an Extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteExtension(
    DeleteExtensionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The service that handles CRUD and List for resources for
/// FeatureOnlineStore.
final class FeatureOnlineStoreAdminService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeatureOnlineStoreAdminService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeatureOnlineStoreAdminService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeatureOnlineStoreAdminService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeatureOnlineStoreAdminService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeatureOnlineStoreAdminService.fromApiKey([String? apiKey]) =>
      FeatureOnlineStoreAdminService(
        client: httpClientFromApiKey(apiKey, _apiKeys),
      );

  /// Creates a new FeatureOnlineStore in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<FeatureOnlineStore, CreateFeatureOnlineStoreOperationMetadata>
  >
  createFeatureOnlineStore(CreateFeatureOnlineStoreRequest request) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureOnlineStores', {
          if (request.featureOnlineStoreId case final $1 when $1.isNotDefault)
            'featureOnlineStoreId': $1,
        });
    final response = await _client.post(url, body: request.featureOnlineStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureOnlineStore.fromJson,
        CreateFeatureOnlineStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single FeatureOnlineStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureOnlineStore> getFeatureOnlineStore(
    GetFeatureOnlineStoreRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureOnlineStore.fromJson(response);
  }

  /// Lists FeatureOnlineStores in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureOnlineStoresResponse> listFeatureOnlineStores(
    ListFeatureOnlineStoresRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureOnlineStores', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
        });
    final response = await _client.get(url);
    return ListFeatureOnlineStoresResponse.fromJson(response);
  }

  /// Updates the parameters of a single FeatureOnlineStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<FeatureOnlineStore, UpdateFeatureOnlineStoreOperationMetadata>
  >
  updateFeatureOnlineStore(UpdateFeatureOnlineStoreRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featureOnlineStore!.name}',
      {if (request.updateMask case final $1?) 'updateMask': $1.toJson()},
    );
    final response = await _client.patch(url, body: request.featureOnlineStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureOnlineStore.fromJson,
        UpdateFeatureOnlineStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single FeatureOnlineStore. The FeatureOnlineStore must not
  /// contain any FeatureViews.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteFeatureOnlineStore(DeleteFeatureOnlineStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new FeatureView in a given FeatureOnlineStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureView, CreateFeatureViewOperationMetadata>>
  createFeatureView(CreateFeatureViewRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureViews', {
      if (request.featureViewId case final $1 when $1.isNotDefault)
        'featureViewId': $1,
      if (request.runSyncImmediately case final $1 when $1.isNotDefault)
        'runSyncImmediately': '${$1}',
    });
    final response = await _client.post(url, body: request.featureView);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureView.fromJson,
        CreateFeatureViewOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureView> getFeatureView(GetFeatureViewRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureView.fromJson(response);
  }

  /// Lists FeatureViews in a given FeatureOnlineStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureViewsResponse> listFeatureViews(
    ListFeatureViewsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureViews', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListFeatureViewsResponse.fromJson(response);
  }

  /// Updates the parameters of a single FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureView, UpdateFeatureViewOperationMetadata>>
  updateFeatureView(UpdateFeatureViewRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.featureView!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.featureView);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureView.fromJson,
        UpdateFeatureViewOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeatureView(
    DeleteFeatureViewRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Triggers on-demand sync for the FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SyncFeatureViewResponse> syncFeatureView(
    SyncFeatureViewRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.featureView}:sync');
    final response = await _client.post(url, body: request);
    return SyncFeatureViewResponse.fromJson(response);
  }

  /// Gets details of a single FeatureViewSync.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureViewSync> getFeatureViewSync(
    GetFeatureViewSyncRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureViewSync.fromJson(response);
  }

  /// Lists FeatureViewSyncs in a given FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureViewSyncsResponse> listFeatureViewSyncs(
    ListFeatureViewSyncsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureViewSyncs', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
        });
    final response = await _client.get(url);
    return ListFeatureViewSyncsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for fetching feature values from the online store.
final class FeatureOnlineStoreService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeatureOnlineStoreService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeatureOnlineStoreService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeatureOnlineStoreService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeatureOnlineStoreService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeatureOnlineStoreService.fromApiKey([String? apiKey]) =>
      FeatureOnlineStoreService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Fetch feature values under a FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FetchFeatureValuesResponse> fetchFeatureValues(
    FetchFeatureValuesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featureView}:fetchFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return FetchFeatureValuesResponse.fromJson(response);
  }

  /// Search the nearest entities under a FeatureView.
  /// Search only works for indexable feature view; if a feature view isn't
  /// indexable, returns Invalid argument response.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchNearestEntitiesResponse> searchNearestEntities(
    SearchNearestEntitiesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featureView}:searchNearestEntities',
    );
    final response = await _client.post(url, body: request);
    return SearchNearestEntitiesResponse.fromJson(response);
  }

  /// RPC to generate an access token for the given feature view. FeatureViews
  /// under the same FeatureOnlineStore share the same access token.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GenerateFetchAccessTokenResponse> generateFetchAccessToken(
    GenerateFetchAccessTokenRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featureView}:generateFetchAccessToken',
    );
    final response = await _client.post(url, body: request);
    return GenerateFetchAccessTokenResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The service that handles CRUD and List for resources for
/// FeatureRegistry.
final class FeatureRegistryService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeatureRegistryService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeatureRegistryService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeatureRegistryService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeatureRegistryService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeatureRegistryService.fromApiKey([String? apiKey]) =>
      FeatureRegistryService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a new FeatureGroup in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureGroup, CreateFeatureGroupOperationMetadata>>
  createFeatureGroup(CreateFeatureGroupRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureGroups', {
      if (request.featureGroupId case final $1 when $1.isNotDefault)
        'featureGroupId': $1,
    });
    final response = await _client.post(url, body: request.featureGroup);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureGroup.fromJson,
        CreateFeatureGroupOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureGroup> getFeatureGroup(GetFeatureGroupRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureGroup.fromJson(response);
  }

  /// Lists FeatureGroups in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureGroupsResponse> listFeatureGroups(
    ListFeatureGroupsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureGroups', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListFeatureGroupsResponse.fromJson(response);
  }

  /// Updates the parameters of a single FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureGroup, UpdateFeatureGroupOperationMetadata>>
  updateFeatureGroup(UpdateFeatureGroupRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.featureGroup!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.featureGroup);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureGroup.fromJson,
        UpdateFeatureGroupOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeatureGroup(
    DeleteFeatureGroupRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new Feature in a given FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Feature, CreateFeatureOperationMetadata>> createFeature(
    CreateFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/features', {
      if (request.featureId case final $1 when $1.isNotDefault) 'featureId': $1,
    });
    final response = await _client.post(url, body: request.feature);
    return Operation.fromJson(
      response,
      OperationHelper(
        Feature.fromJson,
        CreateFeatureOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a batch of Features in a given FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<BatchCreateFeaturesResponse, BatchCreateFeaturesOperationMetadata>
  >
  batchCreateFeatures(BatchCreateFeaturesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/features:batchCreate',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchCreateFeaturesResponse.fromJson,
        BatchCreateFeaturesOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Feature> getFeature(GetFeatureRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.featureStatsAndAnomalySpec!.latestStatsCount case final $1?)
        'featureStatsAndAnomalySpec.latestStatsCount': '${$1}',
      if (request.featureStatsAndAnomalySpec!.statsTimeRange!.startTime
          case final $1?)
        'featureStatsAndAnomalySpec.statsTimeRange.startTime': $1.toJson(),
      if (request.featureStatsAndAnomalySpec!.statsTimeRange!.endTime
          case final $1?)
        'featureStatsAndAnomalySpec.statsTimeRange.endTime': $1.toJson(),
    });
    final response = await _client.get(url);
    return Feature.fromJson(response);
  }

  /// Lists Features in a given FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeaturesResponse> listFeatures(ListFeaturesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/features', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
      if (request.latestStatsCount case final $1 when $1.isNotDefault)
        'latestStatsCount': '${$1}',
    });
    final response = await _client.get(url);
    return ListFeaturesResponse.fromJson(response);
  }

  /// Updates the parameters of a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Feature, UpdateFeatureOperationMetadata>> updateFeature(
    UpdateFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.feature!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.feature);
    return Operation.fromJson(
      response,
      OperationHelper(
        Feature.fromJson,
        UpdateFeatureOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeature(
    DeleteFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new FeatureMonitor in a given project, location and FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureMonitor, CreateFeatureMonitorOperationMetadata>>
  createFeatureMonitor(CreateFeatureMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureMonitors', {
      if (request.featureMonitorId case final $1 when $1.isNotDefault)
        'featureMonitorId': $1,
    });
    final response = await _client.post(url, body: request.featureMonitor);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureMonitor.fromJson,
        CreateFeatureMonitorOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single FeatureMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureMonitor> getFeatureMonitor(
    GetFeatureMonitorRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureMonitor.fromJson(response);
  }

  /// Lists FeatureGroups in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureMonitorsResponse> listFeatureMonitors(
    ListFeatureMonitorsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureMonitors', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListFeatureMonitorsResponse.fromJson(response);
  }

  /// Updates the parameters of a single FeatureMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureMonitor, UpdateFeatureMonitorOperationMetadata>>
  updateFeatureMonitor(UpdateFeatureMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.featureMonitor!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.featureMonitor);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureMonitor.fromJson,
        UpdateFeatureMonitorOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single FeatureMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteFeatureMonitor(DeleteFeatureMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new feature monitor job.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureMonitorJob> createFeatureMonitorJob(
    CreateFeatureMonitorJobRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureMonitorJobs', {
          if (request.featureMonitorJobId case final $1 when $1.isNotDefault)
            'featureMonitorJobId': '${$1}',
        });
    final response = await _client.post(url, body: request.featureMonitorJob);
    return FeatureMonitorJob.fromJson(response);
  }

  /// Get a feature monitor job.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureMonitorJob> getFeatureMonitorJob(
    GetFeatureMonitorJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureMonitorJob.fromJson(response);
  }

  /// List feature monitor jobs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureMonitorJobsResponse> listFeatureMonitorJobs(
    ListFeatureMonitorJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureMonitorJobs', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
        });
    final response = await _client.get(url);
    return ListFeatureMonitorJobsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for serving online feature values.
final class FeaturestoreOnlineServingService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeaturestoreOnlineServingService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeaturestoreOnlineServingService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeaturestoreOnlineServingService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeaturestoreOnlineServingService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeaturestoreOnlineServingService.fromApiKey([String? apiKey]) =>
      FeaturestoreOnlineServingService(
        client: httpClientFromApiKey(apiKey, _apiKeys),
      );

  /// Reads Feature values of a specific entity of an EntityType. For reading
  /// feature values of multiple entities of an EntityType, please use
  /// StreamingReadFeatureValues.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadFeatureValuesResponse> readFeatureValues(
    ReadFeatureValuesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:readFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return ReadFeatureValuesResponse.fromJson(response);
  }

  /// Reads Feature values for multiple entities. Depending on their size, data
  /// for different entities may be broken
  /// up across multiple responses.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<ReadFeatureValuesResponse> streamingReadFeatureValues(
    StreamingReadFeatureValuesRequest request,
  ) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:streamingReadFeatureValues',
    );
    return _client
        .postStreaming(url, body: request)
        .map(ReadFeatureValuesResponse.fromJson);
  }

  /// Writes Feature values of one or more entities of an EntityType.
  ///
  /// The Feature values are merged into existing entities if any. The Feature
  /// values to be written must have timestamp within the online storage
  /// retention.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<WriteFeatureValuesResponse> writeFeatureValues(
    WriteFeatureValuesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:writeFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return WriteFeatureValuesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The service that handles CRUD and List for resources for Featurestore.
final class FeaturestoreService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeaturestoreService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeaturestoreService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeaturestoreService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeaturestoreService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeaturestoreService.fromApiKey([String? apiKey]) =>
      FeaturestoreService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a new Featurestore in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Featurestore, CreateFeaturestoreOperationMetadata>>
  createFeaturestore(CreateFeaturestoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featurestores', {
      if (request.featurestoreId case final $1 when $1.isNotDefault)
        'featurestoreId': $1,
    });
    final response = await _client.post(url, body: request.featurestore);
    return Operation.fromJson(
      response,
      OperationHelper(
        Featurestore.fromJson,
        CreateFeaturestoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single Featurestore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Featurestore> getFeaturestore(GetFeaturestoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Featurestore.fromJson(response);
  }

  /// Lists Featurestores in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeaturestoresResponse> listFeaturestores(
    ListFeaturestoresRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featurestores', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListFeaturestoresResponse.fromJson(response);
  }

  /// Updates the parameters of a single Featurestore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Featurestore, UpdateFeaturestoreOperationMetadata>>
  updateFeaturestore(UpdateFeaturestoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.featurestore!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.featurestore);
    return Operation.fromJson(
      response,
      OperationHelper(
        Featurestore.fromJson,
        UpdateFeaturestoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single Featurestore. The Featurestore must not contain any
  /// EntityTypes or `force` must be set to true for the request to succeed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeaturestore(
    DeleteFeaturestoreRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new EntityType in a given Featurestore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<EntityType, CreateEntityTypeOperationMetadata>>
  createEntityType(CreateEntityTypeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/entityTypes', {
      if (request.entityTypeId case final $1 when $1.isNotDefault)
        'entityTypeId': $1,
    });
    final response = await _client.post(url, body: request.entityType);
    return Operation.fromJson(
      response,
      OperationHelper(
        EntityType.fromJson,
        CreateEntityTypeOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EntityType> getEntityType(GetEntityTypeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return EntityType.fromJson(response);
  }

  /// Lists EntityTypes in a given Featurestore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListEntityTypesResponse> listEntityTypes(
    ListEntityTypesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/entityTypes', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListEntityTypesResponse.fromJson(response);
  }

  /// Updates the parameters of a single EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EntityType> updateEntityType(UpdateEntityTypeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.entityType!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.entityType);
    return EntityType.fromJson(response);
  }

  /// Deletes a single EntityType. The EntityType must not have any Features
  /// or `force` must be set to true for the request to succeed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteEntityType(
    DeleteEntityTypeRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new Feature in a given EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Feature, CreateFeatureOperationMetadata>> createFeature(
    CreateFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/features', {
      if (request.featureId case final $1 when $1.isNotDefault) 'featureId': $1,
    });
    final response = await _client.post(url, body: request.feature);
    return Operation.fromJson(
      response,
      OperationHelper(
        Feature.fromJson,
        CreateFeatureOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a batch of Features in a given EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<BatchCreateFeaturesResponse, BatchCreateFeaturesOperationMetadata>
  >
  batchCreateFeatures(BatchCreateFeaturesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/features:batchCreate',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchCreateFeaturesResponse.fromJson,
        BatchCreateFeaturesOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Feature> getFeature(GetFeatureRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.featureStatsAndAnomalySpec!.latestStatsCount case final $1?)
        'featureStatsAndAnomalySpec.latestStatsCount': '${$1}',
      if (request.featureStatsAndAnomalySpec!.statsTimeRange!.startTime
          case final $1?)
        'featureStatsAndAnomalySpec.statsTimeRange.startTime': $1.toJson(),
      if (request.featureStatsAndAnomalySpec!.statsTimeRange!.endTime
          case final $1?)
        'featureStatsAndAnomalySpec.statsTimeRange.endTime': $1.toJson(),
    });
    final response = await _client.get(url);
    return Feature.fromJson(response);
  }

  /// Lists Features in a given EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeaturesResponse> listFeatures(ListFeaturesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/features', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
      if (request.latestStatsCount case final $1 when $1.isNotDefault)
        'latestStatsCount': '${$1}',
    });
    final response = await _client.get(url);
    return ListFeaturesResponse.fromJson(response);
  }

  /// Updates the parameters of a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Feature> updateFeature(UpdateFeatureRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.feature!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.feature);
    return Feature.fromJson(response);
  }

  /// Deletes a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeature(
    DeleteFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Imports Feature values into the Featurestore from a source storage.
  ///
  /// The progress of the import is tracked by the returned operation. The
  /// imported features are guaranteed to be visible to subsequent read
  /// operations after the operation is marked as successfully done.
  ///
  /// If an import operation fails, the Feature values returned from
  /// reads and exports may be inconsistent. If consistency is
  /// required, the caller must retry the same import request again and wait till
  /// the new operation returned is marked as successfully done.
  ///
  /// There are also scenarios where the caller can cause inconsistency.
  ///
  ///  - Source data for import contains multiple distinct Feature values for
  ///    the same entity ID and timestamp.
  ///  - Source is modified during an import. This includes adding, updating, or
  ///  removing source data and/or metadata. Examples of updating metadata
  ///  include but are not limited to changing storage location, storage class,
  ///  or retention policy.
  ///  - Online serving cluster is under-provisioned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<ImportFeatureValuesResponse, ImportFeatureValuesOperationMetadata>
  >
  importFeatureValues(ImportFeatureValuesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:importFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ImportFeatureValuesResponse.fromJson,
        ImportFeatureValuesOperationMetadata.fromJson,
      ),
    );
  }

  /// Batch reads Feature values from a Featurestore.
  ///
  /// This API enables batch reading Feature values, where each read
  /// instance in the batch may read Feature values of entities from one or
  /// more EntityTypes. Point-in-time correctness is guaranteed for Feature
  /// values of each read instance as of each instance's read timestamp.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      BatchReadFeatureValuesResponse,
      BatchReadFeatureValuesOperationMetadata
    >
  >
  batchReadFeatureValues(BatchReadFeatureValuesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featurestore}:batchReadFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchReadFeatureValuesResponse.fromJson,
        BatchReadFeatureValuesOperationMetadata.fromJson,
      ),
    );
  }

  /// Exports Feature values from all the entities of a target EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<ExportFeatureValuesResponse, ExportFeatureValuesOperationMetadata>
  >
  exportFeatureValues(ExportFeatureValuesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:exportFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExportFeatureValuesResponse.fromJson,
        ExportFeatureValuesOperationMetadata.fromJson,
      ),
    );
  }

  /// Delete Feature values from Featurestore.
  ///
  /// The progress of the deletion is tracked by the returned operation. The
  /// deleted feature values are guaranteed to be invisible to subsequent read
  /// operations after the operation is marked as successfully done.
  ///
  /// If a delete feature values operation fails, the feature values
  /// returned from reads and exports may be inconsistent. If consistency is
  /// required, the caller must retry the same delete request again and wait till
  /// the new operation returned is marked as successfully done.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<DeleteFeatureValuesResponse, DeleteFeatureValuesOperationMetadata>
  >
  deleteFeatureValues(DeleteFeatureValuesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:deleteFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeleteFeatureValuesResponse.fromJson,
        DeleteFeatureValuesOperationMetadata.fromJson,
      ),
    );
  }

  /// Searches Features matching a query in a given project.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchFeaturesResponse> searchFeatures(
    SearchFeaturesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.location}/featurestores:searchFeatures',
      {
        if (request.query case final $1 when $1.isNotDefault) 'query': $1,
        if (request.pageSize case final $1 when $1.isNotDefault)
          'pageSize': '${$1}',
        if (request.pageToken case final $1 when $1.isNotDefault)
          'pageToken': $1,
      },
    );
    final response = await _client.get(url);
    return SearchFeaturesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for managing Vertex AI's CachedContent resource.
final class GenAiCacheService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `GenAiCacheService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `GenAiCacheService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  GenAiCacheService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `GenAiCacheService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory GenAiCacheService.fromApiKey([String? apiKey]) =>
      GenAiCacheService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates cached content, this call will initialize the cached content in the
  /// data storage, and users need to pay for the cache data storage.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CachedContent> createCachedContent(
    CreateCachedContentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/cachedContents');
    final response = await _client.post(url, body: request.cachedContent);
    return CachedContent.fromJson(response);
  }

  /// Gets cached content configurations
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CachedContent> getCachedContent(
    GetCachedContentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return CachedContent.fromJson(response);
  }

  /// Updates cached content configurations
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CachedContent> updateCachedContent(
    UpdateCachedContentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.cachedContent!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.cachedContent);
    return CachedContent.fromJson(response);
  }

  /// Deletes cached content
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteCachedContent(DeleteCachedContentRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Lists cached contents in a project
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListCachedContentsResponse> listCachedContents(
    ListCachedContentsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/cachedContents', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListCachedContentsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing GenAI Tuning Jobs.
final class GenAiTuningService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `GenAiTuningService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `GenAiTuningService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  GenAiTuningService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `GenAiTuningService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory GenAiTuningService.fromApiKey([String? apiKey]) =>
      GenAiTuningService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a TuningJob. A created TuningJob right away will be attempted to
  /// be run.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TuningJob> createTuningJob(CreateTuningJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tuningJobs');
    final response = await _client.post(url, body: request.tuningJob);
    return TuningJob.fromJson(response);
  }

  /// Gets a TuningJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TuningJob> getTuningJob(GetTuningJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TuningJob.fromJson(response);
  }

  /// Lists TuningJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTuningJobsResponse> listTuningJobs(
    ListTuningJobsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tuningJobs', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListTuningJobsResponse.fromJson(response);
  }

  /// Cancels a TuningJob.
  /// Starts asynchronous cancellation on the TuningJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// `GenAiTuningService.GetTuningJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On successful cancellation, the
  /// TuningJob is not deleted; instead it becomes a job with a
  /// `TuningJob.error` value
  /// with a `google.rpc.Status.code` of 1, corresponding
  /// to `Code.CANCELLED`, and
  /// `TuningJob.state` is set
  /// to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelTuningJob(CancelTuningJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Rebase a TunedModel.
  /// Creates a LongRunningOperation that takes a legacy Tuned GenAI model
  /// Reference and creates a TuningJob based on newly available model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<TuningJob, RebaseTunedModelOperationMetadata>>
  rebaseTunedModel(RebaseTunedModelRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/tuningJobs:rebaseTunedModel',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        TuningJob.fromJson,
        RebaseTunedModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's IndexEndpoints.
final class IndexEndpointService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `IndexEndpointService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `IndexEndpointService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  IndexEndpointService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `IndexEndpointService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory IndexEndpointService.fromApiKey([String? apiKey]) =>
      IndexEndpointService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<IndexEndpoint, CreateIndexEndpointOperationMetadata>>
  createIndexEndpoint(CreateIndexEndpointRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/indexEndpoints');
    final response = await _client.post(url, body: request.indexEndpoint);
    return Operation.fromJson(
      response,
      OperationHelper(
        IndexEndpoint.fromJson,
        CreateIndexEndpointOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<IndexEndpoint> getIndexEndpoint(
    GetIndexEndpointRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return IndexEndpoint.fromJson(response);
  }

  /// Lists IndexEndpoints in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListIndexEndpointsResponse> listIndexEndpoints(
    ListIndexEndpointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/indexEndpoints', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListIndexEndpointsResponse.fromJson(response);
  }

  /// Updates an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<IndexEndpoint> updateIndexEndpoint(
    UpdateIndexEndpointRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.indexEndpoint!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.indexEndpoint);
    return IndexEndpoint.fromJson(response);
  }

  /// Deletes an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteIndexEndpoint(DeleteIndexEndpointRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Deploys an Index into this IndexEndpoint, creating a DeployedIndex within
  /// it.
  /// Only non-empty Indexes can be deployed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DeployIndexResponse, DeployIndexOperationMetadata>>
  deployIndex(DeployIndexRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:deployIndex',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeployIndexResponse.fromJson,
        DeployIndexOperationMetadata.fromJson,
      ),
    );
  }

  /// Undeploys an Index from an IndexEndpoint, removing a DeployedIndex from it,
  /// and freeing all resources it's using.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<UndeployIndexResponse, UndeployIndexOperationMetadata>>
  undeployIndex(UndeployIndexRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:undeployIndex',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UndeployIndexResponse.fromJson,
        UndeployIndexOperationMetadata.fromJson,
      ),
    );
  }

  /// Update an existing DeployedIndex under an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<MutateDeployedIndexResponse, MutateDeployedIndexOperationMetadata>
  >
  mutateDeployedIndex(MutateDeployedIndexRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:mutateDeployedIndex',
    );
    final response = await _client.post(url, body: request.deployedIndex);
    return Operation.fromJson(
      response,
      OperationHelper(
        MutateDeployedIndexResponse.fromJson,
        MutateDeployedIndexOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI's Index resources.
final class IndexService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `IndexService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `IndexService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  IndexService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `IndexService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory IndexService.fromApiKey([String? apiKey]) =>
      IndexService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Index, CreateIndexOperationMetadata>> createIndex(
    CreateIndexRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/indexes');
    final response = await _client.post(url, body: request.index);
    return Operation.fromJson(
      response,
      OperationHelper(Index.fromJson, CreateIndexOperationMetadata.fromJson),
    );
  }

  /// Gets an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Index> getIndex(GetIndexRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Index.fromJson(response);
  }

  /// Imports an Index from an external source (e.g., BigQuery).
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Index, ImportIndexOperationMetadata>> importIndex(
    ImportIndexRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:import');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(Index.fromJson, ImportIndexOperationMetadata.fromJson),
    );
  }

  /// Lists Indexes in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListIndexesResponse> listIndexes(ListIndexesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/indexes', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListIndexesResponse.fromJson(response);
  }

  /// Updates an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Index, UpdateIndexOperationMetadata>> updateIndex(
    UpdateIndexRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.index!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.index);
    return Operation.fromJson(
      response,
      OperationHelper(Index.fromJson, UpdateIndexOperationMetadata.fromJson),
    );
  }

  /// Deletes an Index.
  /// An Index can only be deleted when all its
  /// `DeployedIndexes`
  /// had been undeployed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteIndex(
    DeleteIndexRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Add/update Datapoints into an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<UpsertDatapointsResponse> upsertDatapoints(
    UpsertDatapointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.index}:upsertDatapoints');
    final response = await _client.post(url, body: request);
    return UpsertDatapointsResponse.fromJson(response);
  }

  /// Remove Datapoints from an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RemoveDatapointsResponse> removeDatapoints(
    RemoveDatapointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.index}:removeDatapoints');
    final response = await _client.post(url, body: request);
    return RemoveDatapointsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI's jobs.
final class JobService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `JobService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `JobService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  JobService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `JobService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory JobService.fromApiKey([String? apiKey]) =>
      JobService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a CustomJob. A created CustomJob right away
  /// will be attempted to be run.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CustomJob> createCustomJob(CreateCustomJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/customJobs');
    final response = await _client.post(url, body: request.customJob);
    return CustomJob.fromJson(response);
  }

  /// Gets a CustomJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CustomJob> getCustomJob(GetCustomJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return CustomJob.fromJson(response);
  }

  /// Lists CustomJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListCustomJobsResponse> listCustomJobs(
    ListCustomJobsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/customJobs', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListCustomJobsResponse.fromJson(response);
  }

  /// Deletes a CustomJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteCustomJob(
    DeleteCustomJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a CustomJob.
  /// Starts asynchronous cancellation on the CustomJob. The server
  /// makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use
  /// `JobService.GetCustomJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On successful cancellation,
  /// the CustomJob is not deleted; instead it becomes a job with
  /// a `CustomJob.error` value
  /// with a `google.rpc.Status.code` of 1, corresponding
  /// to `Code.CANCELLED`, and
  /// `CustomJob.state` is set
  /// to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelCustomJob(CancelCustomJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a DataLabelingJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DataLabelingJob> createDataLabelingJob(
    CreateDataLabelingJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/dataLabelingJobs');
    final response = await _client.post(url, body: request.dataLabelingJob);
    return DataLabelingJob.fromJson(response);
  }

  /// Gets a DataLabelingJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DataLabelingJob> getDataLabelingJob(
    GetDataLabelingJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return DataLabelingJob.fromJson(response);
  }

  /// Lists DataLabelingJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDataLabelingJobsResponse> listDataLabelingJobs(
    ListDataLabelingJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/dataLabelingJobs', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.readMask case final $1?) 'readMask': $1.toJson(),
          if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
        });
    final response = await _client.get(url);
    return ListDataLabelingJobsResponse.fromJson(response);
  }

  /// Deletes a DataLabelingJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteDataLabelingJob(DeleteDataLabelingJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a DataLabelingJob. Success of cancellation is not guaranteed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelDataLabelingJob(
    CancelDataLabelingJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a HyperparameterTuningJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HyperparameterTuningJob> createHyperparameterTuningJob(
    CreateHyperparameterTuningJobRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/hyperparameterTuningJobs',
    );
    final response = await _client.post(
      url,
      body: request.hyperparameterTuningJob,
    );
    return HyperparameterTuningJob.fromJson(response);
  }

  /// Gets a HyperparameterTuningJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HyperparameterTuningJob> getHyperparameterTuningJob(
    GetHyperparameterTuningJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return HyperparameterTuningJob.fromJson(response);
  }

  /// Lists HyperparameterTuningJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListHyperparameterTuningJobsResponse> listHyperparameterTuningJobs(
    ListHyperparameterTuningJobsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/hyperparameterTuningJobs',
      {
        if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
        if (request.pageSize case final $1 when $1.isNotDefault)
          'pageSize': '${$1}',
        if (request.pageToken case final $1 when $1.isNotDefault)
          'pageToken': $1,
        if (request.readMask case final $1?) 'readMask': $1.toJson(),
      },
    );
    final response = await _client.get(url);
    return ListHyperparameterTuningJobsResponse.fromJson(response);
  }

  /// Deletes a HyperparameterTuningJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteHyperparameterTuningJob(
    DeleteHyperparameterTuningJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a HyperparameterTuningJob.
  /// Starts asynchronous cancellation on the HyperparameterTuningJob. The server
  /// makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use
  /// `JobService.GetHyperparameterTuningJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On successful cancellation,
  /// the HyperparameterTuningJob is not deleted; instead it becomes a job with
  /// a
  /// `HyperparameterTuningJob.error`
  /// value with a `google.rpc.Status.code` of 1,
  /// corresponding to `Code.CANCELLED`, and
  /// `HyperparameterTuningJob.state`
  /// is set to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelHyperparameterTuningJob(
    CancelHyperparameterTuningJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a NasJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NasJob> createNasJob(CreateNasJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/nasJobs');
    final response = await _client.post(url, body: request.nasJob);
    return NasJob.fromJson(response);
  }

  /// Gets a NasJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NasJob> getNasJob(GetNasJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return NasJob.fromJson(response);
  }

  /// Lists NasJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNasJobsResponse> listNasJobs(ListNasJobsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/nasJobs', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListNasJobsResponse.fromJson(response);
  }

  /// Deletes a NasJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteNasJob(
    DeleteNasJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a NasJob.
  /// Starts asynchronous cancellation on the NasJob. The server
  /// makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use
  /// `JobService.GetNasJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On successful cancellation,
  /// the NasJob is not deleted; instead it becomes a job with
  /// a `NasJob.error` value with a
  /// `google.rpc.Status.code` of 1, corresponding to
  /// `Code.CANCELLED`, and
  /// `NasJob.state` is set to
  /// `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelNasJob(CancelNasJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Gets a NasTrialDetail.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NasTrialDetail> getNasTrialDetail(
    GetNasTrialDetailRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return NasTrialDetail.fromJson(response);
  }

  /// List top NasTrialDetails of a NasJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNasTrialDetailsResponse> listNasTrialDetails(
    ListNasTrialDetailsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/nasTrialDetails', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListNasTrialDetailsResponse.fromJson(response);
  }

  /// Creates a BatchPredictionJob. A BatchPredictionJob once created will
  /// right away be attempted to start.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchPredictionJob> createBatchPredictionJob(
    CreateBatchPredictionJobRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/batchPredictionJobs',
    );
    final response = await _client.post(url, body: request.batchPredictionJob);
    return BatchPredictionJob.fromJson(response);
  }

  /// Gets a BatchPredictionJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchPredictionJob> getBatchPredictionJob(
    GetBatchPredictionJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return BatchPredictionJob.fromJson(response);
  }

  /// Lists BatchPredictionJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListBatchPredictionJobsResponse> listBatchPredictionJobs(
    ListBatchPredictionJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/batchPredictionJobs', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.readMask case final $1?) 'readMask': $1.toJson(),
        });
    final response = await _client.get(url);
    return ListBatchPredictionJobsResponse.fromJson(response);
  }

  /// Deletes a BatchPredictionJob. Can only be called on jobs that already
  /// finished.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteBatchPredictionJob(DeleteBatchPredictionJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a BatchPredictionJob.
  ///
  /// Starts asynchronous cancellation on the BatchPredictionJob. The server
  /// makes the best effort to cancel the job, but success is not
  /// guaranteed. Clients can use
  /// `JobService.GetBatchPredictionJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On a successful cancellation,
  /// the BatchPredictionJob is not deleted;instead its
  /// `BatchPredictionJob.state`
  /// is set to `CANCELLED`. Any files already outputted by the job are not
  /// deleted.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelBatchPredictionJob(
    CancelBatchPredictionJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a ModelDeploymentMonitoringJob. It will run periodically on a
  /// configured interval.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelDeploymentMonitoringJob> createModelDeploymentMonitoringJob(
    CreateModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/modelDeploymentMonitoringJobs',
    );
    final response = await _client.post(
      url,
      body: request.modelDeploymentMonitoringJob,
    );
    return ModelDeploymentMonitoringJob.fromJson(response);
  }

  /// Searches Model Monitoring Statistics generated within a given time window.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchModelDeploymentMonitoringStatsAnomaliesResponse>
  searchModelDeploymentMonitoringStatsAnomalies(
    SearchModelDeploymentMonitoringStatsAnomaliesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.modelDeploymentMonitoringJob}:searchModelDeploymentMonitoringStatsAnomalies',
    );
    final response = await _client.post(url, body: request);
    return SearchModelDeploymentMonitoringStatsAnomaliesResponse.fromJson(
      response,
    );
  }

  /// Gets a ModelDeploymentMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelDeploymentMonitoringJob> getModelDeploymentMonitoringJob(
    GetModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelDeploymentMonitoringJob.fromJson(response);
  }

  /// Lists ModelDeploymentMonitoringJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelDeploymentMonitoringJobsResponse>
  listModelDeploymentMonitoringJobs(
    ListModelDeploymentMonitoringJobsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/modelDeploymentMonitoringJobs',
      {
        if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
        if (request.pageSize case final $1 when $1.isNotDefault)
          'pageSize': '${$1}',
        if (request.pageToken case final $1 when $1.isNotDefault)
          'pageToken': $1,
        if (request.readMask case final $1?) 'readMask': $1.toJson(),
      },
    );
    final response = await _client.get(url);
    return ListModelDeploymentMonitoringJobsResponse.fromJson(response);
  }

  /// Updates a ModelDeploymentMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      ModelDeploymentMonitoringJob,
      UpdateModelDeploymentMonitoringJobOperationMetadata
    >
  >
  updateModelDeploymentMonitoringJob(
    UpdateModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.modelDeploymentMonitoringJob!.name}',
      {if (request.updateMask case final $1?) 'updateMask': $1.toJson()},
    );
    final response = await _client.patch(
      url,
      body: request.modelDeploymentMonitoringJob,
    );
    return Operation.fromJson(
      response,
      OperationHelper(
        ModelDeploymentMonitoringJob.fromJson,
        UpdateModelDeploymentMonitoringJobOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a ModelDeploymentMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteModelDeploymentMonitoringJob(
    DeleteModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Pauses a ModelDeploymentMonitoringJob. If the job is running, the server
  /// makes a best effort to cancel the job. Will mark
  /// `ModelDeploymentMonitoringJob.state`
  /// to 'PAUSED'.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> pauseModelDeploymentMonitoringJob(
    PauseModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:pause');
    await _client.post(url, body: request);
  }

  /// Resumes a paused ModelDeploymentMonitoringJob. It will start to run from
  /// next scheduled time. A deleted ModelDeploymentMonitoringJob can't be
  /// resumed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> resumeModelDeploymentMonitoringJob(
    ResumeModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:resume');
    await _client.post(url, body: request);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for LLM related utility functions.
final class LlmUtilityService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `LlmUtilityService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `LlmUtilityService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  LlmUtilityService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `LlmUtilityService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory LlmUtilityService.fromApiKey([String? apiKey]) =>
      LlmUtilityService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Return a list of tokens based on the input text.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ComputeTokensResponse> computeTokens(
    ComputeTokensRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:computeTokens');
    final response = await _client.post(url, body: request);
    return ComputeTokensResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// MatchService is a Google managed service for efficient vector similarity
/// search at scale.
final class MatchService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `MatchService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `MatchService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  MatchService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `MatchService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory MatchService.fromApiKey([String? apiKey]) =>
      MatchService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Finds the nearest neighbors of each vector within the request.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FindNeighborsResponse> findNeighbors(
    FindNeighborsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:findNeighbors',
    );
    final response = await _client.post(url, body: request);
    return FindNeighborsResponse.fromJson(response);
  }

  /// Reads the datapoints/vectors of the given IDs.
  /// A maximum of 1000 datapoints can be retrieved in a batch.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadIndexDatapointsResponse> readIndexDatapoints(
    ReadIndexDatapointsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:readIndexDatapoints',
    );
    final response = await _client.post(url, body: request);
    return ReadIndexDatapointsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing memories for LLM applications.
final class MemoryBankService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `MemoryBankService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `MemoryBankService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  MemoryBankService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `MemoryBankService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory MemoryBankService.fromApiKey([String? apiKey]) =>
      MemoryBankService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Create a Memory.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Memory, CreateMemoryOperationMetadata>> createMemory(
    CreateMemoryRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/memories');
    final response = await _client.post(url, body: request.memory);
    return Operation.fromJson(
      response,
      OperationHelper(Memory.fromJson, CreateMemoryOperationMetadata.fromJson),
    );
  }

  /// Get a Memory.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Memory> getMemory(GetMemoryRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Memory.fromJson(response);
  }

  /// Update a Memory.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Memory, UpdateMemoryOperationMetadata>> updateMemory(
    UpdateMemoryRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.memory!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.memory);
    return Operation.fromJson(
      response,
      OperationHelper(Memory.fromJson, UpdateMemoryOperationMetadata.fromJson),
    );
  }

  /// List Memories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListMemoriesResponse> listMemories(ListMemoriesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/memories', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListMemoriesResponse.fromJson(response);
  }

  /// Delete a Memory.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteMemoryOperationMetadata>> deleteMemory(
    DeleteMemoryRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteMemoryOperationMetadata.fromJson,
      ),
    );
  }

  /// Generate memories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<GenerateMemoriesResponse, GenerateMemoriesOperationMetadata>>
  generateMemories(GenerateMemoriesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/memories:generate',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        GenerateMemoriesResponse.fromJson,
        GenerateMemoriesOperationMetadata.fromJson,
      ),
    );
  }

  /// Retrieve memories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RetrieveMemoriesResponse> retrieveMemories(
    RetrieveMemoriesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/memories:retrieve',
    );
    final response = await _client.post(url, body: request);
    return RetrieveMemoriesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for reading and writing metadata entries.
final class MetadataService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `MetadataService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `MetadataService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  MetadataService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `MetadataService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory MetadataService.fromApiKey([String? apiKey]) =>
      MetadataService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Initializes a MetadataStore, including allocation of resources.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<MetadataStore, CreateMetadataStoreOperationMetadata>>
  createMetadataStore(CreateMetadataStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/metadataStores', {
      if (request.metadataStoreId case final $1 when $1.isNotDefault)
        'metadataStoreId': $1,
    });
    final response = await _client.post(url, body: request.metadataStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        MetadataStore.fromJson,
        CreateMetadataStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Retrieves a specific MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<MetadataStore> getMetadataStore(
    GetMetadataStoreRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return MetadataStore.fromJson(response);
  }

  /// Lists MetadataStores for a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListMetadataStoresResponse> listMetadataStores(
    ListMetadataStoresRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/metadataStores', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListMetadataStoresResponse.fromJson(response);
  }

  /// Deletes a single MetadataStore and all its child resources (Artifacts,
  /// Executions, and Contexts).
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteMetadataStoreOperationMetadata>>
  deleteMetadataStore(DeleteMetadataStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteMetadataStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates an Artifact associated with a MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Artifact> createArtifact(CreateArtifactRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/artifacts', {
      if (request.artifactId case final $1 when $1.isNotDefault)
        'artifactId': $1,
    });
    final response = await _client.post(url, body: request.artifact);
    return Artifact.fromJson(response);
  }

  /// Retrieves a specific Artifact.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Artifact> getArtifact(GetArtifactRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Artifact.fromJson(response);
  }

  /// Lists Artifacts in the MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListArtifactsResponse> listArtifacts(
    ListArtifactsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/artifacts', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListArtifactsResponse.fromJson(response);
  }

  /// Updates a stored Artifact.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Artifact> updateArtifact(UpdateArtifactRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.artifact!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
      if (request.allowMissing case final $1 when $1.isNotDefault)
        'allowMissing': '${$1}',
    });
    final response = await _client.patch(url, body: request.artifact);
    return Artifact.fromJson(response);
  }

  /// Deletes an Artifact.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteArtifact(
    DeleteArtifactRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.etag case final $1 when $1.isNotDefault) 'etag': $1,
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Purges Artifacts.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<PurgeArtifactsResponse, PurgeArtifactsMetadata>>
  purgeArtifacts(PurgeArtifactsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/artifacts:purge');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PurgeArtifactsResponse.fromJson,
        PurgeArtifactsMetadata.fromJson,
      ),
    );
  }

  /// Creates a Context associated with a MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Context> createContext(CreateContextRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/contexts', {
      if (request.contextId case final $1 when $1.isNotDefault) 'contextId': $1,
    });
    final response = await _client.post(url, body: request.context);
    return Context.fromJson(response);
  }

  /// Retrieves a specific Context.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Context> getContext(GetContextRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Context.fromJson(response);
  }

  /// Lists Contexts on the MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListContextsResponse> listContexts(ListContextsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/contexts', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListContextsResponse.fromJson(response);
  }

  /// Updates a stored Context.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Context> updateContext(UpdateContextRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.context!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
      if (request.allowMissing case final $1 when $1.isNotDefault)
        'allowMissing': '${$1}',
    });
    final response = await _client.patch(url, body: request.context);
    return Context.fromJson(response);
  }

  /// Deletes a stored Context.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteContext(
    DeleteContextRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
      if (request.etag case final $1 when $1.isNotDefault) 'etag': $1,
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Purges Contexts.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<PurgeContextsResponse, PurgeContextsMetadata>> purgeContexts(
    PurgeContextsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/contexts:purge');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PurgeContextsResponse.fromJson,
        PurgeContextsMetadata.fromJson,
      ),
    );
  }

  /// Adds a set of Artifacts and Executions to a Context. If any of the
  /// Artifacts or Executions have already been added to a Context, they are
  /// simply skipped.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AddContextArtifactsAndExecutionsResponse>
  addContextArtifactsAndExecutions(
    AddContextArtifactsAndExecutionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.context}:addContextArtifactsAndExecutions',
    );
    final response = await _client.post(url, body: request);
    return AddContextArtifactsAndExecutionsResponse.fromJson(response);
  }

  /// Adds a set of Contexts as children to a parent Context. If any of the
  /// child Contexts have already been added to the parent Context, they are
  /// simply skipped. If this call would create a cycle or cause any Context to
  /// have more than 10 parents, the request will fail with an INVALID_ARGUMENT
  /// error.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AddContextChildrenResponse> addContextChildren(
    AddContextChildrenRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.context}:addContextChildren',
    );
    final response = await _client.post(url, body: request);
    return AddContextChildrenResponse.fromJson(response);
  }

  /// Remove a set of children contexts from a parent Context. If any of the
  /// child Contexts were NOT added to the parent Context, they are
  /// simply skipped.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RemoveContextChildrenResponse> removeContextChildren(
    RemoveContextChildrenRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.context}:removeContextChildren',
    );
    final response = await _client.post(url, body: request);
    return RemoveContextChildrenResponse.fromJson(response);
  }

  /// Retrieves Artifacts and Executions within the specified Context, connected
  /// by Event edges and returned as a LineageSubgraph.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<LineageSubgraph> queryContextLineageSubgraph(
    QueryContextLineageSubgraphRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.context}:queryContextLineageSubgraph',
    );
    final response = await _client.get(url);
    return LineageSubgraph.fromJson(response);
  }

  /// Creates an Execution associated with a MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Execution> createExecution(CreateExecutionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/executions', {
      if (request.executionId case final $1 when $1.isNotDefault)
        'executionId': $1,
    });
    final response = await _client.post(url, body: request.execution);
    return Execution.fromJson(response);
  }

  /// Retrieves a specific Execution.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Execution> getExecution(GetExecutionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Execution.fromJson(response);
  }

  /// Lists Executions in the MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListExecutionsResponse> listExecutions(
    ListExecutionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/executions', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListExecutionsResponse.fromJson(response);
  }

  /// Updates a stored Execution.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Execution> updateExecution(UpdateExecutionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.execution!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
      if (request.allowMissing case final $1 when $1.isNotDefault)
        'allowMissing': '${$1}',
    });
    final response = await _client.patch(url, body: request.execution);
    return Execution.fromJson(response);
  }

  /// Deletes an Execution.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteExecution(
    DeleteExecutionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.etag case final $1 when $1.isNotDefault) 'etag': $1,
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Purges Executions.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<PurgeExecutionsResponse, PurgeExecutionsMetadata>>
  purgeExecutions(PurgeExecutionsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/executions:purge');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PurgeExecutionsResponse.fromJson,
        PurgeExecutionsMetadata.fromJson,
      ),
    );
  }

  /// Adds Events to the specified Execution. An Event indicates whether an
  /// Artifact was used as an input or output for an Execution. If an Event
  /// already exists between the Execution and the Artifact, the Event is
  /// skipped.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AddExecutionEventsResponse> addExecutionEvents(
    AddExecutionEventsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.execution}:addExecutionEvents',
    );
    final response = await _client.post(url, body: request);
    return AddExecutionEventsResponse.fromJson(response);
  }

  /// Obtains the set of input and output Artifacts for this Execution, in the
  /// form of LineageSubgraph that also contains the Execution and connecting
  /// Events.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<LineageSubgraph> queryExecutionInputsAndOutputs(
    QueryExecutionInputsAndOutputsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.execution}:queryExecutionInputsAndOutputs',
    );
    final response = await _client.get(url);
    return LineageSubgraph.fromJson(response);
  }

  /// Creates a MetadataSchema.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<MetadataSchema> createMetadataSchema(
    CreateMetadataSchemaRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/metadataSchemas', {
      if (request.metadataSchemaId case final $1 when $1.isNotDefault)
        'metadataSchemaId': $1,
    });
    final response = await _client.post(url, body: request.metadataSchema);
    return MetadataSchema.fromJson(response);
  }

  /// Retrieves a specific MetadataSchema.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<MetadataSchema> getMetadataSchema(
    GetMetadataSchemaRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return MetadataSchema.fromJson(response);
  }

  /// Lists MetadataSchemas.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListMetadataSchemasResponse> listMetadataSchemas(
    ListMetadataSchemasRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/metadataSchemas', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
    });
    final response = await _client.get(url);
    return ListMetadataSchemasResponse.fromJson(response);
  }

  /// Retrieves lineage of an Artifact represented through Artifacts and
  /// Executions connected by Event edges and returned as a LineageSubgraph.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<LineageSubgraph> queryArtifactLineageSubgraph(
    QueryArtifactLineageSubgraphRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.artifact}:queryArtifactLineageSubgraph',
      {
        if (request.maxHops case final $1 when $1.isNotDefault)
          'maxHops': '${$1}',
        if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      },
    );
    final response = await _client.get(url);
    return LineageSubgraph.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service that migrates resources from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
final class MigrationService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `MigrationService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `MigrationService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  MigrationService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `MigrationService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory MigrationService.fromApiKey([String? apiKey]) =>
      MigrationService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Searches all of the resources in automl.googleapis.com,
  /// datalabeling.googleapis.com and ml.googleapis.com that can be migrated to
  /// Vertex AI's given location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchMigratableResourcesResponse> searchMigratableResources(
    SearchMigratableResourcesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/migratableResources:search',
    );
    final response = await _client.post(url, body: request);
    return SearchMigratableResourcesResponse.fromJson(response);
  }

  /// Batch migrates resources from ml.googleapis.com, automl.googleapis.com,
  /// and datalabeling.googleapis.com to Vertex AI.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      BatchMigrateResourcesResponse,
      BatchMigrateResourcesOperationMetadata
    >
  >
  batchMigrateResources(BatchMigrateResourcesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/migratableResources:batchMigrate',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchMigrateResourcesResponse.fromJson,
        BatchMigrateResourcesOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The interface of Model Garden Service.
final class ModelGardenService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ModelGardenService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ModelGardenService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ModelGardenService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ModelGardenService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ModelGardenService.fromApiKey([String? apiKey]) =>
      ModelGardenService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Gets a Model Garden publisher model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PublisherModel> getPublisherModel(
    GetPublisherModelRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.languageCode case final $1 when $1.isNotDefault)
        'languageCode': $1,
      if (request.view case final $1 when $1.isNotDefault) 'view': $1.value,
      if (request.isHuggingFaceModel case final $1 when $1.isNotDefault)
        'isHuggingFaceModel': '${$1}',
      if (request.huggingFaceToken case final $1 when $1.isNotDefault)
        'huggingFaceToken': $1,
      if (request.includeEquivalentModelGardenModelDeploymentConfigs
          case final $1 when $1.isNotDefault)
        'includeEquivalentModelGardenModelDeploymentConfigs': '${$1}',
    });
    final response = await _client.get(url);
    return PublisherModel.fromJson(response);
  }

  /// Lists publisher models in Model Garden.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListPublisherModelsResponse> listPublisherModels(
    ListPublisherModelsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/models', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.view case final $1 when $1.isNotDefault) 'view': $1.value,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.languageCode case final $1 when $1.isNotDefault)
        'languageCode': $1,
      if (request.listAllVersions case final $1 when $1.isNotDefault)
        'listAllVersions': '${$1}',
    });
    final response = await _client.get(url);
    return ListPublisherModelsResponse.fromJson(response);
  }

  /// Deploys a model to a new endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DeployResponse, DeployOperationMetadata>> deploy(
    DeployRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.destination}:deploy');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeployResponse.fromJson,
        DeployOperationMetadata.fromJson,
      ),
    );
  }

  /// Deploys publisher models.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      DeployPublisherModelResponse,
      DeployPublisherModelOperationMetadata
    >
  >
  deployPublisherModel(DeployPublisherModelRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.destination}:deployPublisherModel',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeployPublisherModelResponse.fromJson,
        DeployPublisherModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Exports a publisher model to a user provided Google Cloud Storage bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      ExportPublisherModelResponse,
      ExportPublisherModelOperationMetadata
    >
  >
  exportPublisherModel(ExportPublisherModelRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/${request.name}:export',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExportPublisherModelResponse.fromJson,
        ExportPublisherModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Checks the EULA acceptance status of a publisher model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PublisherModelEulaAcceptance> checkPublisherModelEulaAcceptance(
    CheckPublisherModelEulaAcceptanceRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/modelGardenEula:check',
    );
    final response = await _client.post(url, body: request);
    return PublisherModelEulaAcceptance.fromJson(response);
  }

  /// Accepts the EULA acceptance status of a publisher model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PublisherModelEulaAcceptance> acceptPublisherModelEula(
    AcceptPublisherModelEulaRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/modelGardenEula:accept',
    );
    final response = await _client.post(url, body: request);
    return PublisherModelEulaAcceptance.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI Model moitoring. This includes
/// `ModelMonitor` resources, `ModelMonitoringJob` resources.
final class ModelMonitoringService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ModelMonitoringService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ModelMonitoringService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ModelMonitoringService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ModelMonitoringService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ModelMonitoringService.fromApiKey([String? apiKey]) =>
      ModelMonitoringService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a ModelMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ModelMonitor, CreateModelMonitorOperationMetadata>>
  createModelMonitor(CreateModelMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/modelMonitors', {
      if (request.modelMonitorId case final $1 when $1.isNotDefault)
        'modelMonitorId': $1,
    });
    final response = await _client.post(url, body: request.modelMonitor);
    return Operation.fromJson(
      response,
      OperationHelper(
        ModelMonitor.fromJson,
        CreateModelMonitorOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a ModelMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ModelMonitor, UpdateModelMonitorOperationMetadata>>
  updateModelMonitor(UpdateModelMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.modelMonitor!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.modelMonitor);
    return Operation.fromJson(
      response,
      OperationHelper(
        ModelMonitor.fromJson,
        UpdateModelMonitorOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a ModelMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelMonitor> getModelMonitor(GetModelMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelMonitor.fromJson(response);
  }

  /// Lists ModelMonitors in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelMonitorsResponse> listModelMonitors(
    ListModelMonitorsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/modelMonitors', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListModelMonitorsResponse.fromJson(response);
  }

  /// Deletes a ModelMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteModelMonitor(
    DeleteModelMonitorRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a ModelMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelMonitoringJob> createModelMonitoringJob(
    CreateModelMonitoringJobRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/modelMonitoringJobs', {
          if (request.modelMonitoringJobId case final $1 when $1.isNotDefault)
            'modelMonitoringJobId': $1,
        });
    final response = await _client.post(url, body: request.modelMonitoringJob);
    return ModelMonitoringJob.fromJson(response);
  }

  /// Gets a ModelMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelMonitoringJob> getModelMonitoringJob(
    GetModelMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelMonitoringJob.fromJson(response);
  }

  /// Lists ModelMonitoringJobs.
  /// Callers may choose to read across multiple Monitors as per
  /// [AIP-159](https://google.aip.dev/159) by using '-' (the hyphen or dash
  /// character) as a wildcard character instead of modelMonitor id in the
  /// parent. Format
  /// `projects/{project_id}/locations/{location}/moodelMonitors/-/modelMonitoringJobs`
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelMonitoringJobsResponse> listModelMonitoringJobs(
    ListModelMonitoringJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/modelMonitoringJobs', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.readMask case final $1?) 'readMask': $1.toJson(),
        });
    final response = await _client.get(url);
    return ListModelMonitoringJobsResponse.fromJson(response);
  }

  /// Deletes a ModelMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteModelMonitoringJob(DeleteModelMonitoringJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Searches Model Monitoring Stats generated within a given time window.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchModelMonitoringStatsResponse> searchModelMonitoringStats(
    SearchModelMonitoringStatsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.modelMonitor}:searchModelMonitoringStats',
    );
    final response = await _client.post(url, body: request);
    return SearchModelMonitoringStatsResponse.fromJson(response);
  }

  /// Returns the Model Monitoring alerts.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchModelMonitoringAlertsResponse> searchModelMonitoringAlerts(
    SearchModelMonitoringAlertsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.modelMonitor}:searchModelMonitoringAlerts',
    );
    final response = await _client.post(url, body: request);
    return SearchModelMonitoringAlertsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's machine learning Models.
final class ModelService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ModelService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ModelService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ModelService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ModelService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ModelService.fromApiKey([String? apiKey]) =>
      ModelService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Uploads a Model artifact into Vertex AI.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<UploadModelResponse, UploadModelOperationMetadata>>
  uploadModel(UploadModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/models:upload');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UploadModelResponse.fromJson,
        UploadModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Model> getModel(GetModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Model.fromJson(response);
  }

  /// Lists Models in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelsResponse> listModels(ListModelsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/models', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListModelsResponse.fromJson(response);
  }

  /// Lists versions of the specified model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelVersionsResponse> listModelVersions(
    ListModelVersionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:listVersions', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListModelVersionsResponse.fromJson(response);
  }

  /// Lists checkpoints of the specified model version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelVersionCheckpointsResponse> listModelVersionCheckpoints(
    ListModelVersionCheckpointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:listCheckpoints', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListModelVersionCheckpointsResponse.fromJson(response);
  }

  /// Updates a Model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Model> updateModel(UpdateModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.model!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.model);
    return Model.fromJson(response);
  }

  /// Incrementally update the dataset used for an examples model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      UpdateExplanationDatasetResponse,
      UpdateExplanationDatasetOperationMetadata
    >
  >
  updateExplanationDataset(UpdateExplanationDatasetRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.model}:updateExplanationDataset',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UpdateExplanationDatasetResponse.fromJson,
        UpdateExplanationDatasetOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a Model.
  ///
  /// A model cannot be deleted if any
  /// `Endpoint` resource has a
  /// `DeployedModel` based on the
  /// model in its
  /// `deployed_models`
  /// field.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteModel(
    DeleteModelRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a Model version.
  ///
  /// Model version can only be deleted if there are no
  /// `DeployedModels` created
  /// from it. Deleting the only version in the Model is not allowed. Use
  /// `DeleteModel` for
  /// deleting the Model instead.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteModelVersion(
    DeleteModelVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:deleteVersion');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Merges a set of aliases for a Model version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Model> mergeVersionAliases(MergeVersionAliasesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.name}:mergeVersionAliases',
    );
    final response = await _client.post(url, body: request);
    return Model.fromJson(response);
  }

  /// Exports a trained, exportable Model to a location specified by the
  /// user. A Model is considered to be exportable if it has at least one
  /// [supported export
  /// format][google.cloud.aiplatform.v1beta1.Model.supported_export_formats].
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ExportModelResponse, ExportModelOperationMetadata>>
  exportModel(ExportModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:export');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExportModelResponse.fromJson,
        ExportModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Copies an already existing Vertex AI Model into the specified Location.
  /// The source Model must exist in the same Project.
  /// When copying custom Models, the users themselves are responsible for
  /// `Model.metadata` content to
  /// be region-agnostic, as well as making sure that any resources (e.g. files)
  /// it depends on remain accessible.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<CopyModelResponse, CopyModelOperationMetadata>> copyModel(
    CopyModelRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/models:copy');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        CopyModelResponse.fromJson,
        CopyModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Imports an externally generated ModelEvaluation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelEvaluation> importModelEvaluation(
    ImportModelEvaluationRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/evaluations:import',
    );
    final response = await _client.post(url, body: request);
    return ModelEvaluation.fromJson(response);
  }

  /// Imports a list of externally generated ModelEvaluationSlice.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchImportModelEvaluationSlicesResponse>
  batchImportModelEvaluationSlices(
    BatchImportModelEvaluationSlicesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/slices:batchImport',
    );
    final response = await _client.post(url, body: request);
    return BatchImportModelEvaluationSlicesResponse.fromJson(response);
  }

  /// Imports a list of externally generated EvaluatedAnnotations.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchImportEvaluatedAnnotationsResponse>
  batchImportEvaluatedAnnotations(
    BatchImportEvaluatedAnnotationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:batchImport');
    final response = await _client.post(url, body: request);
    return BatchImportEvaluatedAnnotationsResponse.fromJson(response);
  }

  /// Gets a ModelEvaluation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelEvaluation> getModelEvaluation(
    GetModelEvaluationRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelEvaluation.fromJson(response);
  }

  /// Lists ModelEvaluations in a Model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelEvaluationsResponse> listModelEvaluations(
    ListModelEvaluationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/evaluations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListModelEvaluationsResponse.fromJson(response);
  }

  /// Gets a ModelEvaluationSlice.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelEvaluationSlice> getModelEvaluationSlice(
    GetModelEvaluationSliceRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelEvaluationSlice.fromJson(response);
  }

  /// Lists ModelEvaluationSlices in a ModelEvaluation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelEvaluationSlicesResponse> listModelEvaluationSlices(
    ListModelEvaluationSlicesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/slices', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListModelEvaluationSlicesResponse.fromJson(response);
  }

  /// Gets a Model's spec recommendations.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RecommendSpecResponse> recommendSpec(
    RecommendSpecRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:recommendSpec');
    final response = await _client.post(url, body: request);
    return RecommendSpecResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The interface for Vertex Notebook service (a.k.a. Colab on Workbench).
final class NotebookService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `NotebookService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `NotebookService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  NotebookService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `NotebookService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory NotebookService.fromApiKey([String? apiKey]) =>
      NotebookService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a NotebookRuntimeTemplate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      NotebookRuntimeTemplate,
      CreateNotebookRuntimeTemplateOperationMetadata
    >
  >
  createNotebookRuntimeTemplate(
    CreateNotebookRuntimeTemplateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/notebookRuntimeTemplates',
      {
        if (request.notebookRuntimeTemplateId case final $1
            when $1.isNotDefault)
          'notebookRuntimeTemplateId': $1,
      },
    );
    final response = await _client.post(
      url,
      body: request.notebookRuntimeTemplate,
    );
    return Operation.fromJson(
      response,
      OperationHelper(
        NotebookRuntimeTemplate.fromJson,
        CreateNotebookRuntimeTemplateOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a NotebookRuntimeTemplate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NotebookRuntimeTemplate> getNotebookRuntimeTemplate(
    GetNotebookRuntimeTemplateRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return NotebookRuntimeTemplate.fromJson(response);
  }

  /// Lists NotebookRuntimeTemplates in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNotebookRuntimeTemplatesResponse> listNotebookRuntimeTemplates(
    ListNotebookRuntimeTemplatesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/notebookRuntimeTemplates',
      {
        if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
        if (request.pageSize case final $1 when $1.isNotDefault)
          'pageSize': '${$1}',
        if (request.pageToken case final $1 when $1.isNotDefault)
          'pageToken': $1,
        if (request.readMask case final $1?) 'readMask': $1.toJson(),
        if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      },
    );
    final response = await _client.get(url);
    return ListNotebookRuntimeTemplatesResponse.fromJson(response);
  }

  /// Deletes a NotebookRuntimeTemplate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteNotebookRuntimeTemplate(
    DeleteNotebookRuntimeTemplateRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a NotebookRuntimeTemplate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NotebookRuntimeTemplate> updateNotebookRuntimeTemplate(
    UpdateNotebookRuntimeTemplateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.notebookRuntimeTemplate!.name}',
      {if (request.updateMask case final $1?) 'updateMask': $1.toJson()},
    );
    final response = await _client.patch(
      url,
      body: request.notebookRuntimeTemplate,
    );
    return NotebookRuntimeTemplate.fromJson(response);
  }

  /// Assigns a NotebookRuntime to a user for a particular Notebook file. This
  /// method will either returns an existing assignment or generates a new one.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<NotebookRuntime, AssignNotebookRuntimeOperationMetadata>>
  assignNotebookRuntime(AssignNotebookRuntimeRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/notebookRuntimes:assign',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        NotebookRuntime.fromJson,
        AssignNotebookRuntimeOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NotebookRuntime> getNotebookRuntime(
    GetNotebookRuntimeRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return NotebookRuntime.fromJson(response);
  }

  /// Lists NotebookRuntimes in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNotebookRuntimesResponse> listNotebookRuntimes(
    ListNotebookRuntimesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/notebookRuntimes', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.readMask case final $1?) 'readMask': $1.toJson(),
          if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
        });
    final response = await _client.get(url);
    return ListNotebookRuntimesResponse.fromJson(response);
  }

  /// Deletes a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteNotebookRuntime(DeleteNotebookRuntimeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Upgrades a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      UpgradeNotebookRuntimeResponse,
      UpgradeNotebookRuntimeOperationMetadata
    >
  >
  upgradeNotebookRuntime(UpgradeNotebookRuntimeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:upgrade');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UpgradeNotebookRuntimeResponse.fromJson,
        UpgradeNotebookRuntimeOperationMetadata.fromJson,
      ),
    );
  }

  /// Starts a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      StartNotebookRuntimeResponse,
      StartNotebookRuntimeOperationMetadata
    >
  >
  startNotebookRuntime(StartNotebookRuntimeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:start');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        StartNotebookRuntimeResponse.fromJson,
        StartNotebookRuntimeOperationMetadata.fromJson,
      ),
    );
  }

  /// Stops a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<StopNotebookRuntimeResponse, StopNotebookRuntimeOperationMetadata>
  >
  stopNotebookRuntime(StopNotebookRuntimeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:stop');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        StopNotebookRuntimeResponse.fromJson,
        StopNotebookRuntimeOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a NotebookExecutionJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<NotebookExecutionJob, CreateNotebookExecutionJobOperationMetadata>
  >
  createNotebookExecutionJob(CreateNotebookExecutionJobRequest request) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/notebookExecutionJobs', {
          if (request.notebookExecutionJobId case final $1 when $1.isNotDefault)
            'notebookExecutionJobId': $1,
        });
    final response = await _client.post(
      url,
      body: request.notebookExecutionJob,
    );
    return Operation.fromJson(
      response,
      OperationHelper(
        NotebookExecutionJob.fromJson,
        CreateNotebookExecutionJobOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a NotebookExecutionJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NotebookExecutionJob> getNotebookExecutionJob(
    GetNotebookExecutionJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.view case final $1 when $1.isNotDefault) 'view': $1.value,
    });
    final response = await _client.get(url);
    return NotebookExecutionJob.fromJson(response);
  }

  /// Lists NotebookExecutionJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNotebookExecutionJobsResponse> listNotebookExecutionJobs(
    ListNotebookExecutionJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/notebookExecutionJobs', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
          if (request.view case final $1 when $1.isNotDefault) 'view': $1.value,
        });
    final response = await _client.get(url);
    return ListNotebookExecutionJobsResponse.fromJson(response);
  }

  /// Deletes a NotebookExecutionJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteNotebookExecutionJob(DeleteNotebookExecutionJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's machine learning PersistentResource.
final class PersistentResourceService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `PersistentResourceService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `PersistentResourceService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  PersistentResourceService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `PersistentResourceService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory PersistentResourceService.fromApiKey([String? apiKey]) =>
      PersistentResourceService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<PersistentResource, CreatePersistentResourceOperationMetadata>
  >
  createPersistentResource(CreatePersistentResourceRequest request) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/persistentResources', {
          if (request.persistentResourceId case final $1 when $1.isNotDefault)
            'persistentResourceId': $1,
        });
    final response = await _client.post(url, body: request.persistentResource);
    return Operation.fromJson(
      response,
      OperationHelper(
        PersistentResource.fromJson,
        CreatePersistentResourceOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PersistentResource> getPersistentResource(
    GetPersistentResourceRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return PersistentResource.fromJson(response);
  }

  /// Lists PersistentResources in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListPersistentResourcesResponse> listPersistentResources(
    ListPersistentResourcesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/persistentResources', {
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
        });
    final response = await _client.get(url);
    return ListPersistentResourcesResponse.fromJson(response);
  }

  /// Deletes a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deletePersistentResource(DeletePersistentResourceRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<PersistentResource, UpdatePersistentResourceOperationMetadata>
  >
  updatePersistentResource(UpdatePersistentResourceRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.persistentResource!.name}',
      {if (request.updateMask case final $1?) 'updateMask': $1.toJson()},
    );
    final response = await _client.patch(url, body: request.persistentResource);
    return Operation.fromJson(
      response,
      OperationHelper(
        PersistentResource.fromJson,
        UpdatePersistentResourceOperationMetadata.fromJson,
      ),
    );
  }

  /// Reboots a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<PersistentResource, RebootPersistentResourceOperationMetadata>
  >
  rebootPersistentResource(RebootPersistentResourceRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:reboot');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PersistentResource.fromJson,
        RebootPersistentResourceOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI's pipelines. This includes both
/// `TrainingPipeline` resources (used for AutoML and custom training) and
/// `PipelineJob` resources (used for Vertex AI Pipelines).
final class PipelineService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `PipelineService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `PipelineService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  PipelineService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `PipelineService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory PipelineService.fromApiKey([String? apiKey]) =>
      PipelineService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a TrainingPipeline. A created TrainingPipeline right away will be
  /// attempted to be run.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TrainingPipeline> createTrainingPipeline(
    CreateTrainingPipelineRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/trainingPipelines',
    );
    final response = await _client.post(url, body: request.trainingPipeline);
    return TrainingPipeline.fromJson(response);
  }

  /// Gets a TrainingPipeline.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TrainingPipeline> getTrainingPipeline(
    GetTrainingPipelineRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TrainingPipeline.fromJson(response);
  }

  /// Lists TrainingPipelines in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTrainingPipelinesResponse> listTrainingPipelines(
    ListTrainingPipelinesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/trainingPipelines', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
          if (request.readMask case final $1?) 'readMask': $1.toJson(),
        });
    final response = await _client.get(url);
    return ListTrainingPipelinesResponse.fromJson(response);
  }

  /// Deletes a TrainingPipeline.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteTrainingPipeline(DeleteTrainingPipelineRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a TrainingPipeline.
  /// Starts asynchronous cancellation on the TrainingPipeline. The server
  /// makes a best effort to cancel the pipeline, but success is not
  /// guaranteed. Clients can use
  /// `PipelineService.GetTrainingPipeline`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// pipeline completed despite cancellation. On successful cancellation,
  /// the TrainingPipeline is not deleted; instead it becomes a pipeline with
  /// a
  /// `TrainingPipeline.error`
  /// value with a `google.rpc.Status.code` of 1,
  /// corresponding to `Code.CANCELLED`, and
  /// `TrainingPipeline.state`
  /// is set to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelTrainingPipeline(
    CancelTrainingPipelineRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a PipelineJob. A PipelineJob will run immediately when created.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PipelineJob> createPipelineJob(
    CreatePipelineJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/pipelineJobs', {
      if (request.pipelineJobId case final $1 when $1.isNotDefault)
        'pipelineJobId': $1,
    });
    final response = await _client.post(url, body: request.pipelineJob);
    return PipelineJob.fromJson(response);
  }

  /// Gets a PipelineJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PipelineJob> getPipelineJob(GetPipelineJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return PipelineJob.fromJson(response);
  }

  /// Lists PipelineJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListPipelineJobsResponse> listPipelineJobs(
    ListPipelineJobsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/pipelineJobs', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListPipelineJobsResponse.fromJson(response);
  }

  /// Deletes a PipelineJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deletePipelineJob(
    DeletePipelineJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Batch deletes PipelineJobs
  /// The Operation is atomic. If it fails, none of the PipelineJobs are deleted.
  /// If it succeeds, all of the PipelineJobs are deleted.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<BatchDeletePipelineJobsResponse, DeleteOperationMetadata>>
  batchDeletePipelineJobs(BatchDeletePipelineJobsRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/pipelineJobs:batchDelete',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchDeletePipelineJobsResponse.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a PipelineJob.
  /// Starts asynchronous cancellation on the PipelineJob. The server
  /// makes a best effort to cancel the pipeline, but success is not
  /// guaranteed. Clients can use
  /// `PipelineService.GetPipelineJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// pipeline completed despite cancellation. On successful cancellation,
  /// the PipelineJob is not deleted; instead it becomes a pipeline with
  /// a `PipelineJob.error`
  /// value with a `google.rpc.Status.code` of 1,
  /// corresponding to `Code.CANCELLED`, and
  /// `PipelineJob.state` is
  /// set to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelPipelineJob(CancelPipelineJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Batch cancel PipelineJobs.
  /// Firstly the server will check if all the jobs are in non-terminal states,
  /// and skip the jobs that are already terminated.
  /// If the operation failed, none of the pipeline jobs are cancelled.
  /// The server will poll the states of all the pipeline jobs periodically
  /// to check the cancellation status.
  /// This operation will return an LRO.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      BatchCancelPipelineJobsResponse,
      BatchCancelPipelineJobsOperationMetadata
    >
  >
  batchCancelPipelineJobs(BatchCancelPipelineJobsRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/pipelineJobs:batchCancel',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchCancelPipelineJobsResponse.fromJson,
        BatchCancelPipelineJobsOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for online predictions and explanations.
final class PredictionService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `PredictionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `PredictionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  PredictionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `PredictionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory PredictionService.fromApiKey([String? apiKey]) =>
      PredictionService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Perform an online prediction.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PredictResponse> predict(PredictRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:predict');
    final response = await _client.post(url, body: request);
    return PredictResponse.fromJson(response);
  }

  /// Perform an online prediction with an arbitrary HTTP payload.
  ///
  /// The response includes the following HTTP headers:
  ///
  /// * `X-Vertex-AI-Endpoint-Id`: ID of the
  /// `Endpoint` that served this
  /// prediction.
  ///
  /// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's
  /// `DeployedModel` that served
  /// this prediction.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HttpBody> rawPredict(RawPredictRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:rawPredict');
    final response = await _client.post(url, body: request);
    return HttpBody.fromJson(response);
  }

  /// Perform a streaming online prediction with an arbitrary HTTP payload.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<HttpBody> streamRawPredict(StreamRawPredictRequest request) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}:streamRawPredict',
    );
    return _client.postStreaming(url, body: request).map(HttpBody.fromJson);
  }

  /// Perform an unary online prediction request to a gRPC model server for
  /// Vertex first-party products and frameworks.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DirectPredictResponse> directPredict(
    DirectPredictRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:directPredict');
    final response = await _client.post(url, body: request);
    return DirectPredictResponse.fromJson(response);
  }

  /// Perform an unary online prediction request to a gRPC model server for
  /// custom containers.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DirectRawPredictResponse> directRawPredict(
    DirectRawPredictRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}:directRawPredict',
    );
    final response = await _client.post(url, body: request);
    return DirectRawPredictResponse.fromJson(response);
  }

  /// Perform a server-side streaming online prediction request for Vertex
  /// LLM streaming.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<StreamingPredictResponse> serverStreamingPredict(
    StreamingPredictRequest request,
  ) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}:serverStreamingPredict',
    );
    return _client
        .postStreaming(url, body: request)
        .map(StreamingPredictResponse.fromJson);
  }

  /// Perform an online explanation.
  ///
  /// If
  /// `deployed_model_id`
  /// is specified, the corresponding DeployModel must have
  /// `explanation_spec`
  /// populated. If
  /// `deployed_model_id`
  /// is not specified, all DeployedModels must have
  /// `explanation_spec`
  /// populated.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ExplainResponse> explain(ExplainRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:explain');
    final response = await _client.post(url, body: request);
    return ExplainResponse.fromJson(response);
  }

  /// Perform a token counting.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CountTokensResponse> countTokens(CountTokensRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:countTokens');
    final response = await _client.post(url, body: request);
    return CountTokensResponse.fromJson(response);
  }

  /// Generate content with multimodal inputs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GenerateContentResponse> generateContent(
    GenerateContentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.model}:generateContent');
    final response = await _client.post(url, body: request);
    return GenerateContentResponse.fromJson(response);
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<GenerateContentResponse> streamGenerateContent(
    GenerateContentRequest request,
  ) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.model}:streamGenerateContent',
    );
    return _client
        .postStreaming(url, body: request)
        .map(GenerateContentResponse.fromJson);
  }

  /// Exposes an OpenAI-compatible endpoint for chat completions.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<HttpBody> chatCompletions(ChatCompletionsRequest request) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}/chat/completions',
    );
    return _client
        .postStreaming(url, body: request.httpBody)
        .map(HttpBody.fromJson);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for executing queries on Reasoning Engine.
final class ReasoningEngineExecutionService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ReasoningEngineExecutionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ReasoningEngineExecutionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ReasoningEngineExecutionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ReasoningEngineExecutionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ReasoningEngineExecutionService.fromApiKey([String? apiKey]) =>
      ReasoningEngineExecutionService(
        client: httpClientFromApiKey(apiKey, _apiKeys),
      );

  /// Queries using a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<QueryReasoningEngineResponse> queryReasoningEngine(
    QueryReasoningEngineRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:query');
    final response = await _client.post(url, body: request);
    return QueryReasoningEngineResponse.fromJson(response);
  }

  /// Streams queries using a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<HttpBody> streamQueryReasoningEngine(
    StreamQueryReasoningEngineRequest request,
  ) {
    final url = Uri.https(_host, '/v1beta1/${request.name}:streamQuery');
    return _client.postStreaming(url, body: request).map(HttpBody.fromJson);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's Reasoning Engines.
final class ReasoningEngineService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ReasoningEngineService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ReasoningEngineService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ReasoningEngineService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ReasoningEngineService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ReasoningEngineService.fromApiKey([String? apiKey]) =>
      ReasoningEngineService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ReasoningEngine, CreateReasoningEngineOperationMetadata>>
  createReasoningEngine(CreateReasoningEngineRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/reasoningEngines');
    final response = await _client.post(url, body: request.reasoningEngine);
    return Operation.fromJson(
      response,
      OperationHelper(
        ReasoningEngine.fromJson,
        CreateReasoningEngineOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReasoningEngine> getReasoningEngine(
    GetReasoningEngineRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ReasoningEngine.fromJson(response);
  }

  /// Lists reasoning engines in a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListReasoningEnginesResponse> listReasoningEngines(
    ListReasoningEnginesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/reasoningEngines', {
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
          if (request.pageSize case final $1 when $1.isNotDefault)
            'pageSize': '${$1}',
          if (request.pageToken case final $1 when $1.isNotDefault)
            'pageToken': $1,
        });
    final response = await _client.get(url);
    return ListReasoningEnginesResponse.fromJson(response);
  }

  /// Updates a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ReasoningEngine, UpdateReasoningEngineOperationMetadata>>
  updateReasoningEngine(UpdateReasoningEngineRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.reasoningEngine!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.reasoningEngine);
    return Operation.fromJson(
      response,
      OperationHelper(
        ReasoningEngine.fromJson,
        UpdateReasoningEngineOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteReasoningEngine(DeleteReasoningEngineRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI's Schedule resources to
/// periodically launch shceudled runs to make API calls.
final class ScheduleService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ScheduleService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ScheduleService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ScheduleService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ScheduleService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ScheduleService.fromApiKey([String? apiKey]) =>
      ScheduleService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a Schedule.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Schedule> createSchedule(CreateScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/schedules');
    final response = await _client.post(url, body: request.schedule);
    return Schedule.fromJson(response);
  }

  /// Deletes a Schedule.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteSchedule(
    DeleteScheduleRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Schedule.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Schedule> getSchedule(GetScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Schedule.fromJson(response);
  }

  /// Lists Schedules in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSchedulesResponse> listSchedules(
    ListSchedulesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/schedules', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListSchedulesResponse.fromJson(response);
  }

  /// Pauses a Schedule. Will mark
  /// `Schedule.state` to
  /// 'PAUSED'. If the schedule is paused, no new runs will be created. Already
  /// created runs will NOT be paused or canceled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> pauseSchedule(PauseScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:pause');
    await _client.post(url, body: request);
  }

  /// Resumes a paused Schedule to start scheduling new runs. Will mark
  /// `Schedule.state` to
  /// 'ACTIVE'. Only paused Schedule can be resumed.
  ///
  /// When the Schedule is resumed, new runs will be scheduled starting from the
  /// next execution time after the current time based on the time_specification
  /// in the Schedule. If `Schedule.catchUp` is set up true, all
  /// missed runs will be scheduled for backfill first.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> resumeSchedule(ResumeScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:resume');
    await _client.post(url, body: request);
  }

  /// Updates an active or paused Schedule.
  ///
  /// When the Schedule is updated, new runs will be scheduled starting from the
  /// updated next execution time after the update time based on the
  /// time_specification in the updated Schedule. All unstarted runs before the
  /// update time will be skipped while already created runs will NOT be paused
  /// or canceled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Schedule> updateSchedule(UpdateScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.schedule!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.schedule);
    return Schedule.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The service that manages Vertex Session related resources.
final class SessionService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `SessionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `SessionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  SessionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `SessionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory SessionService.fromApiKey([String? apiKey]) =>
      SessionService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a new `Session`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Session, CreateSessionOperationMetadata>> createSession(
    CreateSessionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/sessions');
    final response = await _client.post(url, body: request.session);
    return Operation.fromJson(
      response,
      OperationHelper(
        Session.fromJson,
        CreateSessionOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of the specific
  /// `Session`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Session> getSession(GetSessionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Session.fromJson(response);
  }

  /// Lists `Sessions` in a given
  /// reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSessionsResponse> listSessions(ListSessionsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/sessions', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListSessionsResponse.fromJson(response);
  }

  /// Updates the specific `Session`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Session> updateSession(UpdateSessionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.session!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.session);
    return Session.fromJson(response);
  }

  /// Deletes details of the specific
  /// `Session`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteSession(
    DeleteSessionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists `Events` in a given session.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListEventsResponse> listEvents(ListEventsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/events', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
    });
    final response = await _client.get(url);
    return ListEventsResponse.fromJson(response);
  }

  /// Appends an event to a given session.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AppendEventResponse> appendEvent(AppendEventRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:appendEvent');
    final response = await _client.post(url, body: request.event);
    return AppendEventResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Customer SpecialistPools.
/// When customers start Data Labeling jobs, they can reuse/create Specialist
/// Pools to bring their own Specialists to label the data.
/// Customers can add/remove Managers for the Specialist Pool on Cloud console,
/// then Managers will get email notifications to manage Specialists and tasks on
/// CrowdCompute console.
final class SpecialistPoolService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `SpecialistPoolService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `SpecialistPoolService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  SpecialistPoolService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `SpecialistPoolService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory SpecialistPoolService.fromApiKey([String? apiKey]) =>
      SpecialistPoolService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a SpecialistPool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<SpecialistPool, CreateSpecialistPoolOperationMetadata>>
  createSpecialistPool(CreateSpecialistPoolRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/specialistPools');
    final response = await _client.post(url, body: request.specialistPool);
    return Operation.fromJson(
      response,
      OperationHelper(
        SpecialistPool.fromJson,
        CreateSpecialistPoolOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a SpecialistPool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SpecialistPool> getSpecialistPool(
    GetSpecialistPoolRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return SpecialistPool.fromJson(response);
  }

  /// Lists SpecialistPools in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSpecialistPoolsResponse> listSpecialistPools(
    ListSpecialistPoolsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/specialistPools', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListSpecialistPoolsResponse.fromJson(response);
  }

  /// Deletes a SpecialistPool as well as all Specialists in the pool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteSpecialistPool(DeleteSpecialistPoolRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a SpecialistPool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<SpecialistPool, UpdateSpecialistPoolOperationMetadata>>
  updateSpecialistPool(UpdateSpecialistPoolRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.specialistPool!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.specialistPool);
    return Operation.fromJson(
      response,
      OperationHelper(
        SpecialistPool.fromJson,
        UpdateSpecialistPoolOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// TensorboardService
final class TensorboardService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `TensorboardService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `TensorboardService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  TensorboardService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `TensorboardService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory TensorboardService.fromApiKey([String? apiKey]) =>
      TensorboardService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a Tensorboard.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Tensorboard, CreateTensorboardOperationMetadata>>
  createTensorboard(CreateTensorboardRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tensorboards');
    final response = await _client.post(url, body: request.tensorboard);
    return Operation.fromJson(
      response,
      OperationHelper(
        Tensorboard.fromJson,
        CreateTensorboardOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Tensorboard.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Tensorboard> getTensorboard(GetTensorboardRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Tensorboard.fromJson(response);
  }

  /// Updates a Tensorboard.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Tensorboard, UpdateTensorboardOperationMetadata>>
  updateTensorboard(UpdateTensorboardRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboard!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.tensorboard);
    return Operation.fromJson(
      response,
      OperationHelper(
        Tensorboard.fromJson,
        UpdateTensorboardOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists Tensorboards in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTensorboardsResponse> listTensorboards(
    ListTensorboardsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tensorboards', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListTensorboardsResponse.fromJson(response);
  }

  /// Deletes a Tensorboard.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteTensorboard(
    DeleteTensorboardRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Returns a list of monthly active users for a given TensorBoard instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadTensorboardUsageResponse> readTensorboardUsage(
    ReadTensorboardUsageRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboard}:readUsage');
    final response = await _client.get(url);
    return ReadTensorboardUsageResponse.fromJson(response);
  }

  /// Returns the storage size for a given TensorBoard instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadTensorboardSizeResponse> readTensorboardSize(
    ReadTensorboardSizeRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboard}:readSize');
    final response = await _client.get(url);
    return ReadTensorboardSizeResponse.fromJson(response);
  }

  /// Creates a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardExperiment> createTensorboardExperiment(
    CreateTensorboardExperimentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/experiments', {
      if (request.tensorboardExperimentId case final $1 when $1.isNotDefault)
        'tensorboardExperimentId': $1,
    });
    final response = await _client.post(
      url,
      body: request.tensorboardExperiment,
    );
    return TensorboardExperiment.fromJson(response);
  }

  /// Gets a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardExperiment> getTensorboardExperiment(
    GetTensorboardExperimentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TensorboardExperiment.fromJson(response);
  }

  /// Updates a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardExperiment> updateTensorboardExperiment(
    UpdateTensorboardExperimentRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.tensorboardExperiment!.name}',
      {if (request.updateMask case final $1?) 'updateMask': $1.toJson()},
    );
    final response = await _client.patch(
      url,
      body: request.tensorboardExperiment,
    );
    return TensorboardExperiment.fromJson(response);
  }

  /// Lists TensorboardExperiments in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTensorboardExperimentsResponse> listTensorboardExperiments(
    ListTensorboardExperimentsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/experiments', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListTensorboardExperimentsResponse.fromJson(response);
  }

  /// Deletes a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteTensorboardExperiment(
    DeleteTensorboardExperimentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a TensorboardRun.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardRun> createTensorboardRun(
    CreateTensorboardRunRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/runs', {
      if (request.tensorboardRunId case final $1 when $1.isNotDefault)
        'tensorboardRunId': $1,
    });
    final response = await _client.post(url, body: request.tensorboardRun);
    return TensorboardRun.fromJson(response);
  }

  /// Batch create TensorboardRuns.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchCreateTensorboardRunsResponse> batchCreateTensorboardRuns(
    BatchCreateTensorboardRunsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/runs:batchCreate');
    final response = await _client.post(url, body: request);
    return BatchCreateTensorboardRunsResponse.fromJson(response);
  }

  /// Gets a TensorboardRun.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardRun> getTensorboardRun(
    GetTensorboardRunRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TensorboardRun.fromJson(response);
  }

  /// Updates a TensorboardRun.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardRun> updateTensorboardRun(
    UpdateTensorboardRunRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboardRun!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.tensorboardRun);
    return TensorboardRun.fromJson(response);
  }

  /// Lists TensorboardRuns in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTensorboardRunsResponse> listTensorboardRuns(
    ListTensorboardRunsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/runs', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListTensorboardRunsResponse.fromJson(response);
  }

  /// Deletes a TensorboardRun.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteTensorboardRun(DeleteTensorboardRunRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Batch create TensorboardTimeSeries that belong to a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchCreateTensorboardTimeSeriesResponse>
  batchCreateTensorboardTimeSeries(
    BatchCreateTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:batchCreate');
    final response = await _client.post(url, body: request);
    return BatchCreateTensorboardTimeSeriesResponse.fromJson(response);
  }

  /// Creates a TensorboardTimeSeries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardTimeSeries> createTensorboardTimeSeries(
    CreateTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/timeSeries', {
      if (request.tensorboardTimeSeriesId case final $1 when $1.isNotDefault)
        'tensorboardTimeSeriesId': $1,
    });
    final response = await _client.post(
      url,
      body: request.tensorboardTimeSeries,
    );
    return TensorboardTimeSeries.fromJson(response);
  }

  /// Gets a TensorboardTimeSeries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardTimeSeries> getTensorboardTimeSeries(
    GetTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TensorboardTimeSeries.fromJson(response);
  }

  /// Updates a TensorboardTimeSeries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardTimeSeries> updateTensorboardTimeSeries(
    UpdateTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.tensorboardTimeSeries!.name}',
      {if (request.updateMask case final $1?) 'updateMask': $1.toJson()},
    );
    final response = await _client.patch(
      url,
      body: request.tensorboardTimeSeries,
    );
    return TensorboardTimeSeries.fromJson(response);
  }

  /// Lists TensorboardTimeSeries in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTensorboardTimeSeriesResponse> listTensorboardTimeSeries(
    ListTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/timeSeries', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
      if (request.readMask case final $1?) 'readMask': $1.toJson(),
    });
    final response = await _client.get(url);
    return ListTensorboardTimeSeriesResponse.fromJson(response);
  }

  /// Deletes a TensorboardTimeSeries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteTensorboardTimeSeries(
    DeleteTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Reads multiple TensorboardTimeSeries' data. The data point number limit is
  /// 1000 for scalars, 100 for tensors and blob references. If the number of
  /// data points stored is less than the limit, all data is returned.
  /// Otherwise, the number limit of data points is randomly selected from
  /// this time series and returned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchReadTensorboardTimeSeriesDataResponse>
  batchReadTensorboardTimeSeriesData(
    BatchReadTensorboardTimeSeriesDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboard}:batchRead', {
      if (request.timeSeries case final $1 when $1.isNotDefault)
        'timeSeries': $1,
    });
    final response = await _client.get(url);
    return BatchReadTensorboardTimeSeriesDataResponse.fromJson(response);
  }

  /// Reads a TensorboardTimeSeries' data. By default, if the number of data
  /// points stored is less than 1000, all data is returned. Otherwise, 1000
  /// data points is randomly selected from this time series and returned.
  /// This value can be changed by changing max_data_points, which can't be
  /// greater than 10k.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadTensorboardTimeSeriesDataResponse> readTensorboardTimeSeriesData(
    ReadTensorboardTimeSeriesDataRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.tensorboardTimeSeries}:read', {
          if (request.maxDataPoints case final $1 when $1.isNotDefault)
            'maxDataPoints': '${$1}',
          if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
        });
    final response = await _client.get(url);
    return ReadTensorboardTimeSeriesDataResponse.fromJson(response);
  }

  /// Gets bytes of TensorboardBlobs.
  /// This is to allow reading blob data stored in consumer project's Cloud
  /// Storage bucket without users having to obtain Cloud Storage access
  /// permission.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<ReadTensorboardBlobDataResponse> readTensorboardBlobData(
    ReadTensorboardBlobDataRequest request,
  ) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.timeSeries}:readBlobData',
      {if (request.blobIds case final $1 when $1.isNotDefault) 'blobIds': $1},
    );
    return _client
        .getStreaming(url)
        .map(ReadTensorboardBlobDataResponse.fromJson);
  }

  /// Write time series data points of multiple TensorboardTimeSeries in multiple
  /// TensorboardRun's. If any data fail to be ingested, an error is returned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<WriteTensorboardExperimentDataResponse> writeTensorboardExperimentData(
    WriteTensorboardExperimentDataRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.tensorboardExperiment}:write',
    );
    final response = await _client.post(url, body: request);
    return WriteTensorboardExperimentDataResponse.fromJson(response);
  }

  /// Write time series data points into multiple TensorboardTimeSeries under
  /// a TensorboardRun. If any data fail to be ingested, an error is returned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<WriteTensorboardRunDataResponse> writeTensorboardRunData(
    WriteTensorboardRunDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboardRun}:write');
    final response = await _client.post(url, body: request);
    return WriteTensorboardRunDataResponse.fromJson(response);
  }

  /// Exports a TensorboardTimeSeries' data. Data is returned in paginated
  /// responses.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ExportTensorboardTimeSeriesDataResponse>
  exportTensorboardTimeSeriesData(
    ExportTensorboardTimeSeriesDataRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.tensorboardTimeSeries}:exportTensorboardTimeSeries',
    );
    final response = await _client.post(url, body: request);
    return ExportTensorboardTimeSeriesDataResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing user data for RAG.
final class VertexRagDataService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `VertexRagDataService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `VertexRagDataService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  VertexRagDataService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `VertexRagDataService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory VertexRagDataService.fromApiKey([String? apiKey]) =>
      VertexRagDataService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<RagCorpus, CreateRagCorpusOperationMetadata>>
  createRagCorpus(CreateRagCorpusRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragCorpora');
    final response = await _client.post(url, body: request.ragCorpus);
    return Operation.fromJson(
      response,
      OperationHelper(
        RagCorpus.fromJson,
        CreateRagCorpusOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<RagCorpus, UpdateRagCorpusOperationMetadata>>
  updateRagCorpus(UpdateRagCorpusRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.ragCorpus!.name}');
    final response = await _client.patch(url, body: request.ragCorpus);
    return Operation.fromJson(
      response,
      OperationHelper(
        RagCorpus.fromJson,
        UpdateRagCorpusOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RagCorpus> getRagCorpus(GetRagCorpusRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return RagCorpus.fromJson(response);
  }

  /// Lists RagCorpora in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListRagCorporaResponse> listRagCorpora(
    ListRagCorporaRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragCorpora', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListRagCorporaResponse.fromJson(response);
  }

  /// Deletes a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteRagCorpus(
    DeleteRagCorpusRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force case final $1 when $1.isNotDefault) 'force': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Upload a file into a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<UploadRagFileResponse> uploadRagFile(
    UploadRagFileRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragFiles:upload');
    final response = await _client.post(url, body: request);
    return UploadRagFileResponse.fromJson(response);
  }

  /// Import files from Google Cloud Storage or Google Drive into a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ImportRagFilesResponse, ImportRagFilesOperationMetadata>>
  importRagFiles(ImportRagFilesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragFiles:import');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ImportRagFilesResponse.fromJson,
        ImportRagFilesOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a RagFile.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RagFile> getRagFile(GetRagFileRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return RagFile.fromJson(response);
  }

  /// Lists RagFiles in a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListRagFilesResponse> listRagFiles(ListRagFilesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragFiles', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListRagFilesResponse.fromJson(response);
  }

  /// Deletes a RagFile.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteRagFile(
    DeleteRagFileRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.forceDelete case final $1 when $1.isNotDefault)
        'forceDelete': '${$1}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a RagEngineConfig.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<RagEngineConfig, UpdateRagEngineConfigOperationMetadata>>
  updateRagEngineConfig(UpdateRagEngineConfigRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.ragEngineConfig!.name}');
    final response = await _client.patch(url, body: request.ragEngineConfig);
    return Operation.fromJson(
      response,
      OperationHelper(
        RagEngineConfig.fromJson,
        UpdateRagEngineConfigOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a RagEngineConfig.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RagEngineConfig> getRagEngineConfig(
    GetRagEngineConfigRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return RagEngineConfig.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for retrieving relevant contexts.
final class VertexRagService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `VertexRagService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `VertexRagService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  VertexRagService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `VertexRagService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory VertexRagService.fromApiKey([String? apiKey]) =>
      VertexRagService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Retrieves relevant contexts for a query.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RetrieveContextsResponse> retrieveContexts(
    RetrieveContextsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:retrieveContexts');
    final response = await _client.post(url, body: request);
    return RetrieveContextsResponse.fromJson(response);
  }

  /// Given an input prompt, it returns augmented prompt from vertex rag store
  ///  to guide LLM towards generating grounded responses.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AugmentPromptResponse> augmentPrompt(
    AugmentPromptRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:augmentPrompt');
    final response = await _client.post(url, body: request);
    return AugmentPromptResponse.fromJson(response);
  }

  /// Given an input text, it returns a score that evaluates the factuality of
  /// the text. It also extracts and returns claims from the text and provides
  /// supporting facts.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CorroborateContentResponse> corroborateContent(
    CorroborateContentRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}:corroborateContent',
    );
    final response = await _client.post(url, body: request);
    return CorroborateContentResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Vertex AI Vizier API.
///
/// Vertex AI Vizier is a service to solve blackbox optimization problems,
/// such as tuning machine learning hyperparameters and searching over deep
/// learning architectures.
final class VizierService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `VizierService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `VizierService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  VizierService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `VizierService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory VizierService.fromApiKey([String? apiKey]) =>
      VizierService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a Study. A resource name will be generated after creation of the
  /// Study.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Study> createStudy(CreateStudyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/studies');
    final response = await _client.post(url, body: request.study);
    return Study.fromJson(response);
  }

  /// Gets a Study by name.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Study> getStudy(GetStudyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Study.fromJson(response);
  }

  /// Lists all the studies in a region for an associated project.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListStudiesResponse> listStudies(ListStudiesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/studies', {
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
    });
    final response = await _client.get(url);
    return ListStudiesResponse.fromJson(response);
  }

  /// Deletes a Study.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteStudy(DeleteStudyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Looks a study up using the user-defined display_name field instead of the
  /// fully qualified resource name.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Study> lookupStudy(LookupStudyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/studies:lookup');
    final response = await _client.post(url, body: request);
    return Study.fromJson(response);
  }

  /// Adds one or more Trials to a Study, with parameter values
  /// suggested by Vertex AI Vizier. Returns a long-running
  /// operation associated with the generation of Trial suggestions.
  /// When this long-running operation succeeds, it will contain
  /// a
  /// `SuggestTrialsResponse`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<SuggestTrialsResponse, SuggestTrialsMetadata>> suggestTrials(
    SuggestTrialsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/trials:suggest');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        SuggestTrialsResponse.fromJson,
        SuggestTrialsMetadata.fromJson,
      ),
    );
  }

  /// Adds a user provided Trial to a Study.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> createTrial(CreateTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/trials');
    final response = await _client.post(url, body: request.trial);
    return Trial.fromJson(response);
  }

  /// Gets a Trial.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> getTrial(GetTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Trial.fromJson(response);
  }

  /// Lists the Trials associated with a Study.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTrialsResponse> listTrials(ListTrialsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/trials', {
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
    });
    final response = await _client.get(url);
    return ListTrialsResponse.fromJson(response);
  }

  /// Adds a measurement of the objective metrics to a Trial. This measurement
  /// is assumed to have been taken before the Trial is complete.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> addTrialMeasurement(AddTrialMeasurementRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.trialName}:addTrialMeasurement',
    );
    final response = await _client.post(url, body: request);
    return Trial.fromJson(response);
  }

  /// Marks a Trial as complete.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> completeTrial(CompleteTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:complete');
    final response = await _client.post(url, body: request);
    return Trial.fromJson(response);
  }

  /// Deletes a Trial.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteTrial(DeleteTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Checks  whether a Trial should stop or not. Returns a
  /// long-running operation. When the operation is successful,
  /// it will contain a
  /// `CheckTrialEarlyStoppingStateResponse`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      CheckTrialEarlyStoppingStateResponse,
      CheckTrialEarlyStoppingStateMetatdata
    >
  >
  checkTrialEarlyStoppingState(
    CheckTrialEarlyStoppingStateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.trialName}:checkTrialEarlyStoppingState',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        CheckTrialEarlyStoppingStateResponse.fromJson,
        CheckTrialEarlyStoppingStateMetatdata.fromJson,
      ),
    );
  }

  /// Stops a Trial.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> stopTrial(StopTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:stop');
    final response = await _client.post(url, body: request);
    return Trial.fromJson(response);
  }

  /// Lists the pareto-optimal Trials for multi-objective Study or the
  /// optimal Trials for single-objective Study. The definition of
  /// pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOptimalTrialsResponse> listOptimalTrials(
    ListOptimalTrialsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/trials:listOptimalTrials',
    );
    final response = await _client.post(url, body: request);
    return ListOptimalTrialsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout case final $1?) 'timeout': $1.toJson(),
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Used to assign specific AnnotationSpec to a particular area of a DataItem or
/// the whole part of the DataItem.
final class Annotation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Annotation';

  /// Output only. Resource name of the Annotation.
  final String name;

  /// Required. Google Cloud Storage URI points to a YAML file describing
  /// `payload`. The schema
  /// is defined as an [OpenAPI 3.0.2 Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
  /// chosen schema must be consistent with the parent Dataset's
  /// `metadata`.
  final String payloadSchemaUri;

  /// Required. The schema of the payload can be found in
  /// `payload_schema`.
  final protobuf.Value? payload;

  /// Output only. Timestamp when this Annotation was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Annotation was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Output only. The source of the Annotation.
  final UserActionReference? annotationSource;

  /// Optional. The labels with user-defined metadata to organize your
  /// Annotations.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Annotation(System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable. Following system labels exist for each Annotation:
  ///
  /// * "aiplatform.googleapis.com/annotation_set_name":
  ///   optional, name of the UI's annotation set this Annotation belongs to.
  ///   If not set, the Annotation is not visible in the UI.
  ///
  /// * "aiplatform.googleapis.com/payload_schema":
  ///   output only, its value is the
  ///   [payload_schema's][google.cloud.aiplatform.v1beta1.Annotation.payload_schema_uri]
  ///   title.
  final Map<String, String> labels;

  Annotation({
    this.name = '',
    required this.payloadSchemaUri,
    required this.payload,
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.annotationSource,
    this.labels = const {},
  }) : super(fullyQualifiedName);

  factory Annotation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Annotation(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      payloadSchemaUri: switch (json['payloadSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      payload: switch (json['payload']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      annotationSource: switch (json['annotationSource']) {
        null => null,
        Object $1 => UserActionReference.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'payloadSchemaUri': payloadSchemaUri,
    if (payload != null) 'payload': payload!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (annotationSource != null)
      'annotationSource': annotationSource!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'payloadSchemaUri=$payloadSchemaUri',
      'etag=$etag',
    ].join(',');
    return 'Annotation($contents)';
  }
}

/// Identifies a concept with which DataItems may be annotated with.
final class AnnotationSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AnnotationSpec';

  /// Output only. Resource name of the AnnotationSpec.
  final String name;

  /// Required. The user-defined name of the AnnotationSpec.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Output only. Timestamp when this AnnotationSpec was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when AnnotationSpec was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  AnnotationSpec({
    this.name = '',
    required this.displayName,
    this.createTime,
    this.updateTime,
    this.etag = '',
  }) : super(fullyQualifiedName);

  factory AnnotationSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnnotationSpec(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'etag=$etag',
    ].join(',');
    return 'AnnotationSpec($contents)';
  }
}

/// The generic reusable api auth config.
final class ApiAuth extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ApiAuth';

  /// The API secret.
  final ApiAuth_ApiKeyConfig? apiKeyConfig;

  ApiAuth({this.apiKeyConfig}) : super(fullyQualifiedName);

  factory ApiAuth.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ApiAuth(
      apiKeyConfig: switch (json['apiKeyConfig']) {
        null => null,
        Object $1 => ApiAuth_ApiKeyConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!.toJson(),
  };

  @override
  String toString() => 'ApiAuth()';
}

/// The API secret.
final class ApiAuth_ApiKeyConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ApiAuth.ApiKeyConfig';

  /// Required. The SecretManager secret version resource name storing API key.
  /// e.g. projects/{project}/secrets/{secret}/versions/{version}
  final String apiKeySecretVersion;

  ApiAuth_ApiKeyConfig({required this.apiKeySecretVersion})
    : super(fullyQualifiedName);

  factory ApiAuth_ApiKeyConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ApiAuth_ApiKeyConfig(
      apiKeySecretVersion: switch (json['apiKeySecretVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'apiKeySecretVersion': apiKeySecretVersion};

  @override
  String toString() {
    final contents = ['apiKeySecretVersion=$apiKeySecretVersion'].join(',');
    return 'ApiKeyConfig($contents)';
  }
}

/// Instance of a general artifact.
final class Artifact extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Artifact';

  /// Output only. The resource name of the Artifact.
  final String name;

  /// User provided display name of the Artifact.
  /// May be up to 128 Unicode characters.
  final String displayName;

  /// The uniform resource identifier of the artifact file.
  /// May be empty if there is no actual artifact file.
  final String uri;

  /// An eTag used to perform consistent read-modify-write updates. If not set, a
  /// blind "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize your Artifacts.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Artifact (System
  /// labels are excluded).
  final Map<String, String> labels;

  /// Output only. Timestamp when this Artifact was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Artifact was last updated.
  final protobuf.Timestamp? updateTime;

  /// The state of this Artifact. This is a property of the Artifact, and does
  /// not imply or capture any ongoing process. This property is managed by
  /// clients (such as Vertex AI Pipelines), and the system does not prescribe
  /// or check the validity of state transitions.
  final Artifact_State state;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String schemaVersion;

  /// Properties of the Artifact.
  /// Top level metadata keys' heading and trailing spaces will be trimmed.
  /// The size of this field should not exceed 200KB.
  final protobuf.Struct? metadata;

  /// Description of the Artifact
  final String description;

  Artifact({
    this.name = '',
    this.displayName = '',
    this.uri = '',
    this.etag = '',
    this.labels = const {},
    this.createTime,
    this.updateTime,
    this.state = Artifact_State.$default,
    this.schemaTitle = '',
    this.schemaVersion = '',
    this.metadata,
    this.description = '',
  }) : super(fullyQualifiedName);

  factory Artifact.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Artifact(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      uri: switch (json['uri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      state: switch (json['state']) {
        null => Artifact_State.$default,
        Object $1 => Artifact_State.fromJson($1),
      },
      schemaTitle: switch (json['schemaTitle']) {
        null => '',
        Object $1 => decodeString($1),
      },
      schemaVersion: switch (json['schemaVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (uri.isNotDefault) 'uri': uri,
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (schemaTitle.isNotDefault) 'schemaTitle': schemaTitle,
    if (schemaVersion.isNotDefault) 'schemaVersion': schemaVersion,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'uri=$uri',
      'etag=$etag',
      'state=$state',
      'schemaTitle=$schemaTitle',
      'schemaVersion=$schemaVersion',
      'description=$description',
    ].join(',');
    return 'Artifact($contents)';
  }
}

/// Describes the state of the Artifact.
final class Artifact_State extends ProtoEnum {
  /// Unspecified state for the Artifact.
  static const stateUnspecified = Artifact_State('STATE_UNSPECIFIED');

  /// A state used by systems like Vertex AI Pipelines to indicate that the
  /// underlying data item represented by this Artifact is being created.
  static const pending = Artifact_State('PENDING');

  /// A state indicating that the Artifact should exist, unless something
  /// external to the system deletes it.
  static const live = Artifact_State('LIVE');

  /// The default value for [Artifact_State].
  static const $default = stateUnspecified;

  const Artifact_State(super.value);

  factory Artifact_State.fromJson(Object? json) =>
      Artifact_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// A job that uses a
/// `Model` to produce
/// predictions on multiple [input
/// instances][google.cloud.aiplatform.v1beta1.BatchPredictionJob.input_config].
/// If predictions for significant portion of the instances fail, the job may
/// finish without attempting predictions for all remaining instances.
final class BatchPredictionJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob';

  /// Output only. Resource name of the BatchPredictionJob.
  final String name;

  /// Required. The user-defined name of this BatchPredictionJob.
  final String displayName;

  /// The name of the Model resource that produces the predictions via this job,
  /// must share the same ancestor Location.
  /// Starting this job has no impact on any existing deployments of the Model
  /// and their resources.
  /// Exactly one of model and unmanaged_container_model must be set.
  ///
  /// The model resource name may contain version id or version alias to specify
  /// the version.
  ///  Example: `projects/{project}/locations/{location}/models/{model}@2`
  ///              or
  ///            `projects/{project}/locations/{location}/models/{model}@golden`
  /// if no version is specified, the default version will be deployed.
  ///
  /// The model resource could also be a publisher model.
  ///  Example: `publishers/{publisher}/models/{model}`
  ///              or
  ///           `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  final String model;

  /// Output only. The version ID of the Model that produces the predictions via
  /// this job.
  final String modelVersionId;

  /// Contains model information necessary to perform batch prediction without
  /// requiring uploading to model registry.
  /// Exactly one of model and unmanaged_container_model must be set.
  final UnmanagedContainerModel? unmanagedContainerModel;

  /// Required. Input configuration of the instances on which predictions are
  /// performed. The schema of any single instance may be specified via the
  /// [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`.
  final BatchPredictionJob_InputConfig? inputConfig;

  /// Configuration for how to convert batch prediction input instances to the
  /// prediction instances that are sent to the Model.
  final BatchPredictionJob_InstanceConfig? instanceConfig;

  /// The parameters that govern the predictions. The schema of the parameters
  /// may be specified via the
  /// [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `parameters_schema_uri`.
  final protobuf.Value? modelParameters;

  /// Required. The Configuration specifying where output predictions should
  /// be written.
  /// The schema of any single prediction may be specified as a concatenation
  /// of [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`
  /// and
  /// `prediction_schema_uri`.
  final BatchPredictionJob_OutputConfig? outputConfig;

  /// The config of resources used by the Model during the batch prediction. If
  /// the Model
  /// `supports`
  /// DEDICATED_RESOURCES this config may be provided (and the job will use these
  /// resources), if the Model doesn't support AUTOMATIC_RESOURCES, this config
  /// must be provided.
  final BatchDedicatedResources? dedicatedResources;

  /// The service account that the DeployedModel's container runs as. If not
  /// specified, a system generated one will be used, which
  /// has minimal permissions and the custom container, if used, may not have
  /// enough permission to access other Google Cloud resources.
  ///
  /// Users deploying the Model must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  final String serviceAccount;

  /// Immutable. Parameters configuring the batch behavior. Currently only
  /// applicable when
  /// `dedicated_resources`
  /// are used (in other cases Vertex AI does the tuning itself).
  final ManualBatchTuningParameters? manualBatchTuningParameters;

  /// Generate explanation with the batch prediction results.
  ///
  /// When set to `true`, the batch prediction output changes based on the
  /// `predictions_format` field of the
  /// `BatchPredictionJob.output_config`
  /// object:
  ///
  ///  * `bigquery`: output includes a column named `explanation`. The value
  ///    is a struct that conforms to the
  ///    `Explanation` object.
  ///  * `jsonl`: The JSON objects on each line include an additional entry
  ///    keyed `explanation`. The value of the entry is a JSON object that
  ///    conforms to the
  ///    `Explanation` object.
  ///  * `csv`: Generating explanations for CSV format is not supported.
  ///
  /// If this field is set to true, either the
  /// `Model.explanation_spec`
  /// or
  /// `explanation_spec`
  /// must be populated.
  final bool generateExplanation;

  /// Explanation configuration for this BatchPredictionJob. Can be
  /// specified only if
  /// `generate_explanation`
  /// is set to `true`.
  ///
  /// This value overrides the value of
  /// `Model.explanation_spec`.
  /// All fields of
  /// `explanation_spec`
  /// are optional in the request. If a field of the
  /// `explanation_spec`
  /// object is not populated, the corresponding field of the
  /// `Model.explanation_spec`
  /// object is inherited.
  final ExplanationSpec? explanationSpec;

  /// Output only. Information further describing the output of this job.
  final BatchPredictionJob_OutputInfo? outputInfo;

  /// Output only. The detailed state of the job.
  final JobState state;

  /// Output only. Only populated when the job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  final Status? error;

  /// Output only. Partial failures encountered.
  /// For example, single files that can't be read.
  /// This field never exceeds 20 entries.
  /// Status details fields contain standard Google Cloud error details.
  final List<Status> partialFailures;

  /// Output only. Information about resources that had been consumed by this
  /// job. Provided in real time at best effort basis, as well as a final value
  /// once the job completes.
  ///
  /// Note: This field currently may be not populated for batch predictions that
  /// use AutoML Models.
  final ResourcesConsumed? resourcesConsumed;

  /// Output only. Statistics on completed and failed prediction instances.
  final CompletionStats? completionStats;

  /// Output only. Time when the BatchPredictionJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the BatchPredictionJob for the first time entered
  /// the `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the BatchPredictionJob entered any of the following
  /// states: `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the BatchPredictionJob was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize BatchPredictionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Customer-managed encryption key options for a BatchPredictionJob. If this
  /// is set, then all resources created by the BatchPredictionJob will be
  /// encrypted with the provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// Model monitoring config will be used for analysis model behaviors, based on
  /// the input and output to the batch prediction job, as well as the provided
  /// training dataset.
  final ModelMonitoringConfig? modelMonitoringConfig;

  /// Get batch prediction job monitoring statistics.
  final List<ModelMonitoringStatsAnomalies> modelMonitoringStatsAnomalies;

  /// Output only. The running status of the model monitoring pipeline.
  final Status? modelMonitoringStatus;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to
  /// Cloud Logging by default. Please note that the logs incur cost,
  /// which are subject to [Cloud Logging
  /// pricing](https://cloud.google.com/logging/pricing).
  ///
  /// User can disable container logging by setting this flag to true.
  final bool disableContainerLogging;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  BatchPredictionJob({
    this.name = '',
    required this.displayName,
    this.model = '',
    this.modelVersionId = '',
    this.unmanagedContainerModel,
    required this.inputConfig,
    this.instanceConfig,
    this.modelParameters,
    required this.outputConfig,
    this.dedicatedResources,
    this.serviceAccount = '',
    this.manualBatchTuningParameters,
    this.generateExplanation = false,
    this.explanationSpec,
    this.outputInfo,
    this.state = JobState.$default,
    this.error,
    this.partialFailures = const [],
    this.resourcesConsumed,
    this.completionStats,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.labels = const {},
    this.encryptionSpec,
    this.modelMonitoringConfig,
    this.modelMonitoringStatsAnomalies = const [],
    this.modelMonitoringStatus,
    this.disableContainerLogging = false,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchPredictionJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersionId: switch (json['modelVersionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      unmanagedContainerModel: switch (json['unmanagedContainerModel']) {
        null => null,
        Object $1 => UnmanagedContainerModel.fromJson($1),
      },
      inputConfig: switch (json['inputConfig']) {
        null => null,
        Object $1 => BatchPredictionJob_InputConfig.fromJson($1),
      },
      instanceConfig: switch (json['instanceConfig']) {
        null => null,
        Object $1 => BatchPredictionJob_InstanceConfig.fromJson($1),
      },
      modelParameters: switch (json['modelParameters']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      outputConfig: switch (json['outputConfig']) {
        null => null,
        Object $1 => BatchPredictionJob_OutputConfig.fromJson($1),
      },
      dedicatedResources: switch (json['dedicatedResources']) {
        null => null,
        Object $1 => BatchDedicatedResources.fromJson($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
      manualBatchTuningParameters:
          switch (json['manualBatchTuningParameters']) {
            null => null,
            Object $1 => ManualBatchTuningParameters.fromJson($1),
          },
      generateExplanation: switch (json['generateExplanation']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      explanationSpec: switch (json['explanationSpec']) {
        null => null,
        Object $1 => ExplanationSpec.fromJson($1),
      },
      outputInfo: switch (json['outputInfo']) {
        null => null,
        Object $1 => BatchPredictionJob_OutputInfo.fromJson($1),
      },
      state: switch (json['state']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      partialFailures: switch (json['partialFailures']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Status.fromJson(i)],
        _ => throw const FormatException('"partialFailures" is not a list'),
      },
      resourcesConsumed: switch (json['resourcesConsumed']) {
        null => null,
        Object $1 => ResourcesConsumed.fromJson($1),
      },
      completionStats: switch (json['completionStats']) {
        null => null,
        Object $1 => CompletionStats.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      modelMonitoringConfig: switch (json['modelMonitoringConfig']) {
        null => null,
        Object $1 => ModelMonitoringConfig.fromJson($1),
      },
      modelMonitoringStatsAnomalies:
          switch (json['modelMonitoringStatsAnomalies']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) ModelMonitoringStatsAnomalies.fromJson(i),
            ],
            _ => throw const FormatException(
              '"modelMonitoringStatsAnomalies" is not a list',
            ),
          },
      modelMonitoringStatus: switch (json['modelMonitoringStatus']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      disableContainerLogging: switch (json['disableContainerLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (model.isNotDefault) 'model': model,
    if (modelVersionId.isNotDefault) 'modelVersionId': modelVersionId,
    if (unmanagedContainerModel != null)
      'unmanagedContainerModel': unmanagedContainerModel!.toJson(),
    if (inputConfig != null) 'inputConfig': inputConfig!.toJson(),
    if (instanceConfig != null) 'instanceConfig': instanceConfig!.toJson(),
    if (modelParameters != null) 'modelParameters': modelParameters!.toJson(),
    if (outputConfig != null) 'outputConfig': outputConfig!.toJson(),
    if (dedicatedResources != null)
      'dedicatedResources': dedicatedResources!.toJson(),
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
    if (manualBatchTuningParameters != null)
      'manualBatchTuningParameters': manualBatchTuningParameters!.toJson(),
    if (generateExplanation.isNotDefault)
      'generateExplanation': generateExplanation,
    if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
    if (outputInfo != null) 'outputInfo': outputInfo!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (partialFailures.isNotDefault)
      'partialFailures': encodeList(partialFailures),
    if (resourcesConsumed != null)
      'resourcesConsumed': resourcesConsumed!.toJson(),
    if (completionStats != null) 'completionStats': completionStats!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (modelMonitoringConfig != null)
      'modelMonitoringConfig': modelMonitoringConfig!.toJson(),
    if (modelMonitoringStatsAnomalies.isNotDefault)
      'modelMonitoringStatsAnomalies': encodeList(
        modelMonitoringStatsAnomalies,
      ),
    if (modelMonitoringStatus != null)
      'modelMonitoringStatus': modelMonitoringStatus!.toJson(),
    if (disableContainerLogging.isNotDefault)
      'disableContainerLogging': disableContainerLogging,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'model=$model',
      'modelVersionId=$modelVersionId',
      'serviceAccount=$serviceAccount',
      'generateExplanation=$generateExplanation',
      'state=$state',
      'disableContainerLogging=$disableContainerLogging',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'BatchPredictionJob($contents)';
  }
}

/// Configures the input to
/// `BatchPredictionJob`.
/// See
/// `Model.supported_input_storage_formats`
/// for Model's supported input formats, and how instances should be expressed
/// via any of them.
final class BatchPredictionJob_InputConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob.InputConfig';

  /// The Cloud Storage location for the input instances.
  final GcsSource? gcsSource;

  /// The BigQuery location of the input table.
  /// The schema of the table should be in the format described by the given
  /// context OpenAPI Schema, if one is provided. The table may contain
  /// additional columns that are not described by the schema, and they will
  /// be ignored.
  final BigQuerySource? bigquerySource;

  /// Required. The format in which instances are given, must be one of the
  /// [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// `supported_input_storage_formats`.
  final String instancesFormat;

  BatchPredictionJob_InputConfig({
    this.gcsSource,
    this.bigquerySource,
    required this.instancesFormat,
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob_InputConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchPredictionJob_InputConfig(
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      bigquerySource: switch (json['bigquerySource']) {
        null => null,
        Object $1 => BigQuerySource.fromJson($1),
      },
      instancesFormat: switch (json['instancesFormat']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
    'instancesFormat': instancesFormat,
  };

  @override
  String toString() {
    final contents = ['instancesFormat=$instancesFormat'].join(',');
    return 'InputConfig($contents)';
  }
}

/// Configuration defining how to transform batch prediction input instances to
/// the instances that the Model accepts.
final class BatchPredictionJob_InstanceConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob.InstanceConfig';

  /// The format of the instance that the Model accepts. Vertex AI will
  /// convert compatible
  /// [batch prediction input instance
  /// formats][google.cloud.aiplatform.v1beta1.BatchPredictionJob.InputConfig.instances_format]
  /// to the specified format.
  ///
  /// Supported values are:
  ///
  /// * `object`: Each input is converted to JSON object format.
  ///     * For `bigquery`, each row is converted to an object.
  ///     * For `jsonl`, each line of the JSONL input must be an object.
  ///     * Does not apply to `csv`, `file-list`, `tf-record`, or
  ///       `tf-record-gzip`.
  ///
  /// * `array`: Each input is converted to JSON array format.
  ///     * For `bigquery`, each row is converted to an array. The order
  ///       of columns is determined by the BigQuery column order, unless
  ///       `included_fields`
  ///       is populated.
  ///       `included_fields`
  ///       must be populated for specifying field orders.
  ///     * For `jsonl`, if each line of the JSONL input is an object,
  ///       `included_fields`
  ///       must be populated for specifying field orders.
  ///     * Does not apply to `csv`, `file-list`, `tf-record`, or
  ///       `tf-record-gzip`.
  ///
  /// If not specified, Vertex AI converts the batch prediction input as
  /// follows:
  ///
  ///  * For `bigquery` and `csv`, the behavior is the same as `array`. The
  ///    order of columns is the same as defined in the file or table, unless
  ///    `included_fields`
  ///    is populated.
  ///  * For `jsonl`, the prediction instance format is determined by
  ///    each line of the input.
  ///  * For `tf-record`/`tf-record-gzip`, each record will be converted to
  ///    an object in the format of `{"b64": <value>}`, where `<value>` is
  ///    the Base64-encoded string of the content of the record.
  ///  * For `file-list`, each file in the list will be converted to an
  ///    object in the format of `{"b64": <value>}`, where `<value>` is
  ///    the Base64-encoded string of the content of the file.
  final String instanceType;

  /// The name of the field that is considered as a key.
  ///
  /// The values identified by the key field is not included in the transformed
  /// instances that is sent to the Model. This is similar to
  /// specifying this name of the field in
  /// `excluded_fields`.
  /// In addition, the batch prediction output will not include the instances.
  /// Instead the output will only include the value of the key field, in a
  /// field named `key` in the output:
  ///
  ///  * For `jsonl` output format, the output will have a `key` field
  ///    instead of the `instance` field.
  ///  * For `csv`/`bigquery` output format, the output will have have a `key`
  ///    column instead of the instance feature columns.
  ///
  /// The input must be JSONL with objects at each line, CSV, BigQuery
  /// or TfRecord.
  final String keyField;

  /// Fields that will be included in the prediction instance that is
  /// sent to the Model.
  ///
  /// If
  /// `instance_type`
  /// is `array`, the order of field names in included_fields also determines
  /// the order of the values in the array.
  ///
  /// When included_fields is populated,
  /// `excluded_fields`
  /// must be empty.
  ///
  /// The input must be JSONL with objects at each line, BigQuery
  /// or TfRecord.
  final List<String> includedFields;

  /// Fields that will be excluded in the prediction instance that is
  /// sent to the Model.
  ///
  /// Excluded will be attached to the batch prediction output if
  /// `key_field`
  /// is not specified.
  ///
  /// When excluded_fields is populated,
  /// `included_fields`
  /// must be empty.
  ///
  /// The input must be JSONL with objects at each line, BigQuery
  /// or TfRecord.
  final List<String> excludedFields;

  BatchPredictionJob_InstanceConfig({
    this.instanceType = '',
    this.keyField = '',
    this.includedFields = const [],
    this.excludedFields = const [],
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob_InstanceConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchPredictionJob_InstanceConfig(
      instanceType: switch (json['instanceType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      keyField: switch (json['keyField']) {
        null => '',
        Object $1 => decodeString($1),
      },
      includedFields: switch (json['includedFields']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"includedFields" is not a list'),
      },
      excludedFields: switch (json['excludedFields']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"excludedFields" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (instanceType.isNotDefault) 'instanceType': instanceType,
    if (keyField.isNotDefault) 'keyField': keyField,
    if (includedFields.isNotDefault) 'includedFields': includedFields,
    if (excludedFields.isNotDefault) 'excludedFields': excludedFields,
  };

  @override
  String toString() {
    final contents = [
      'instanceType=$instanceType',
      'keyField=$keyField',
    ].join(',');
    return 'InstanceConfig($contents)';
  }
}

/// Configures the output of
/// `BatchPredictionJob`.
/// See
/// `Model.supported_output_storage_formats`
/// for supported output formats, and how predictions are expressed via any of
/// them.
final class BatchPredictionJob_OutputConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob.OutputConfig';

  /// The Cloud Storage location of the directory where the output is
  /// to be written to. In the given directory a new directory is created.
  /// Its name is `prediction-<model-display-name>-<job-create-time>`,
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format.
  /// Inside of it files `predictions_0001.<extension>`,
  /// `predictions_0002.<extension>`, ..., `predictions_N.<extension>`
  /// are created where `<extension>` depends on chosen
  /// `predictions_format`,
  /// and N may equal 0001 and depends on the total number of successfully
  /// predicted instances. If the Model has both
  /// `instance`
  /// and
  /// `prediction`
  /// schemata defined then each such file contains predictions as per the
  /// `predictions_format`.
  /// If prediction for any instance failed (partially or completely), then
  /// an additional `errors_0001.<extension>`, `errors_0002.<extension>`,...,
  /// `errors_N.<extension>` files are created (N depends on total number
  /// of failed predictions). These files contain the failed instances,
  /// as per their schema, followed by an additional `error` field which as
  /// value has `google.rpc.Status`
  /// containing only `code` and `message` fields.
  final GcsDestination? gcsDestination;

  /// The BigQuery project or dataset location where the output is to be
  /// written to. If project is provided, a new dataset is created with name
  /// `prediction_<model-display-name>_<job-create-time>`
  /// where <model-display-name> is made
  /// BigQuery-dataset-name compatible (for example, most special characters
  /// become underscores), and timestamp is in
  /// YYYY_MM_DDThh_mm_ss_sssZ "based on ISO-8601" format. In the dataset
  /// two tables will be created, `predictions`, and `errors`.
  /// If the Model has both
  /// `instance`
  /// and
  /// `prediction`
  /// schemata defined then the tables have columns as follows: The
  /// `predictions` table contains instances for which the prediction
  /// succeeded, it has columns as per a concatenation of the Model's
  /// instance and prediction schemata. The `errors` table contains rows for
  /// which the prediction has failed, it has instance columns, as per the
  /// instance schema, followed by a single "errors" column, which as values
  /// has `google.rpc.Status`
  /// represented as a STRUCT, and containing only `code` and `message`.
  final BigQueryDestination? bigqueryDestination;

  /// Required. The format in which Vertex AI gives the predictions, must be
  /// one of the
  /// [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// `supported_output_storage_formats`.
  final String predictionsFormat;

  BatchPredictionJob_OutputConfig({
    this.gcsDestination,
    this.bigqueryDestination,
    required this.predictionsFormat,
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob_OutputConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchPredictionJob_OutputConfig(
      gcsDestination: switch (json['gcsDestination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      bigqueryDestination: switch (json['bigqueryDestination']) {
        null => null,
        Object $1 => BigQueryDestination.fromJson($1),
      },
      predictionsFormat: switch (json['predictionsFormat']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!.toJson(),
    'predictionsFormat': predictionsFormat,
  };

  @override
  String toString() {
    final contents = ['predictionsFormat=$predictionsFormat'].join(',');
    return 'OutputConfig($contents)';
  }
}

/// Further describes this job's output.
/// Supplements
/// `output_config`.
final class BatchPredictionJob_OutputInfo extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob.OutputInfo';

  /// Output only. The full path of the Cloud Storage directory created, into
  /// which the prediction output is written.
  final String? gcsOutputDirectory;

  /// Output only. The path of the BigQuery dataset created, in
  /// `bq://projectId.bqDatasetId`
  /// format, into which the prediction output is written.
  final String? bigqueryOutputDataset;

  /// Output only. The name of the BigQuery table created, in
  /// `predictions_<timestamp>`
  /// format, into which the prediction output is written.
  /// Can be used by UI to generate the BigQuery output path, for example.
  final String bigqueryOutputTable;

  BatchPredictionJob_OutputInfo({
    this.gcsOutputDirectory,
    this.bigqueryOutputDataset,
    this.bigqueryOutputTable = '',
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob_OutputInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchPredictionJob_OutputInfo(
      gcsOutputDirectory: switch (json['gcsOutputDirectory']) {
        null => null,
        Object $1 => decodeString($1),
      },
      bigqueryOutputDataset: switch (json['bigqueryOutputDataset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      bigqueryOutputTable: switch (json['bigqueryOutputTable']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsOutputDirectory != null) 'gcsOutputDirectory': gcsOutputDirectory,
    if (bigqueryOutputDataset != null)
      'bigqueryOutputDataset': bigqueryOutputDataset,
    if (bigqueryOutputTable.isNotDefault)
      'bigqueryOutputTable': bigqueryOutputTable,
  };

  @override
  String toString() {
    final contents = [
      if (gcsOutputDirectory != null) 'gcsOutputDirectory=$gcsOutputDirectory',
      if (bigqueryOutputDataset != null)
        'bigqueryOutputDataset=$bigqueryOutputDataset',
      'bigqueryOutputTable=$bigqueryOutputTable',
    ].join(',');
    return 'OutputInfo($contents)';
  }
}

/// A resource used in LLM queries for users to explicitly specify what to cache
/// and how to cache.
final class CachedContent extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CachedContent';

  /// Timestamp of when this resource is considered expired.
  /// This is *always* provided on output, regardless of what was sent
  /// on input.
  final protobuf.Timestamp? expireTime;

  /// Input only. The TTL for this resource. The expiration time is computed:
  /// now + TTL.
  final protobuf.Duration? ttl;

  /// Immutable. Identifier. The server-generated resource name of the cached
  /// content Format:
  /// projects/{project}/locations/{location}/cachedContents/{cached_content}
  final String name;

  /// Optional. Immutable. The user-generated meaningful display name of the
  /// cached content.
  final String displayName;

  /// Immutable. The name of the `Model` to use for cached content. Currently,
  /// only the published Gemini base models are supported, in form of
  /// projects/{PROJECT}/locations/{LOCATION}/publishers/google/models/{MODEL}
  final String model;

  /// Optional. Input only. Immutable. Developer set system instruction.
  /// Currently, text only
  final Content? systemInstruction;

  /// Optional. Input only. Immutable. The content to cache
  final List<Content> contents;

  /// Optional. Input only. Immutable. A list of `Tools` the model may use to
  /// generate the next response
  final List<Tool> tools;

  /// Optional. Input only. Immutable. Tool config. This config is shared for all
  /// tools
  final ToolConfig? toolConfig;

  /// Output only. Creation time of the cache entry.
  final protobuf.Timestamp? createTime;

  /// Output only. When the cache entry was last updated in UTC time.
  final protobuf.Timestamp? updateTime;

  /// Output only. Metadata on the usage of the cached content.
  final CachedContent_UsageMetadata? usageMetadata;

  /// Input only. Immutable. Customer-managed encryption key spec for a
  /// `CachedContent`. If set, this `CachedContent` and all its sub-resources
  /// will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  CachedContent({
    this.expireTime,
    this.ttl,
    this.name = '',
    this.displayName = '',
    this.model = '',
    this.systemInstruction,
    this.contents = const [],
    this.tools = const [],
    this.toolConfig,
    this.createTime,
    this.updateTime,
    this.usageMetadata,
    this.encryptionSpec,
  }) : super(fullyQualifiedName);

  factory CachedContent.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CachedContent(
      expireTime: switch (json['expireTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      ttl: switch (json['ttl']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      systemInstruction: switch (json['systemInstruction']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
      tools: switch (json['tools']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tool.fromJson(i)],
        _ => throw const FormatException('"tools" is not a list'),
      },
      toolConfig: switch (json['toolConfig']) {
        null => null,
        Object $1 => ToolConfig.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      usageMetadata: switch (json['usageMetadata']) {
        null => null,
        Object $1 => CachedContent_UsageMetadata.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (expireTime != null) 'expireTime': expireTime!.toJson(),
    if (ttl != null) 'ttl': ttl!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (model.isNotDefault) 'model': model,
    if (systemInstruction != null)
      'systemInstruction': systemInstruction!.toJson(),
    if (contents.isNotDefault) 'contents': encodeList(contents),
    if (tools.isNotDefault) 'tools': encodeList(tools),
    if (toolConfig != null) 'toolConfig': toolConfig!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (usageMetadata != null) 'usageMetadata': usageMetadata!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'model=$model',
    ].join(',');
    return 'CachedContent($contents)';
  }
}

/// Metadata on the usage of the cached content.
final class CachedContent_UsageMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CachedContent.UsageMetadata';

  /// Total number of tokens that the cached content consumes.
  final int totalTokenCount;

  /// Number of text characters.
  final int textCount;

  /// Number of images.
  final int imageCount;

  /// Duration of video in seconds.
  final int videoDurationSeconds;

  /// Duration of audio in seconds.
  final int audioDurationSeconds;

  CachedContent_UsageMetadata({
    this.totalTokenCount = 0,
    this.textCount = 0,
    this.imageCount = 0,
    this.videoDurationSeconds = 0,
    this.audioDurationSeconds = 0,
  }) : super(fullyQualifiedName);

  factory CachedContent_UsageMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CachedContent_UsageMetadata(
      totalTokenCount: switch (json['totalTokenCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      textCount: switch (json['textCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      imageCount: switch (json['imageCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      videoDurationSeconds: switch (json['videoDurationSeconds']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      audioDurationSeconds: switch (json['audioDurationSeconds']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (totalTokenCount.isNotDefault) 'totalTokenCount': totalTokenCount,
    if (textCount.isNotDefault) 'textCount': textCount,
    if (imageCount.isNotDefault) 'imageCount': imageCount,
    if (videoDurationSeconds.isNotDefault)
      'videoDurationSeconds': videoDurationSeconds,
    if (audioDurationSeconds.isNotDefault)
      'audioDurationSeconds': audioDurationSeconds,
  };

  @override
  String toString() {
    final contents = [
      'totalTokenCount=$totalTokenCount',
      'textCount=$textCount',
      'imageCount=$imageCount',
      'videoDurationSeconds=$videoDurationSeconds',
      'audioDurationSeconds=$audioDurationSeconds',
    ].join(',');
    return 'UsageMetadata($contents)';
  }
}

/// Success and error statistics of processing multiple entities
/// (for example, DataItems or structured data rows) in batch.
final class CompletionStats extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CompletionStats';

  /// Output only. The number of entities that had been processed successfully.
  final int successfulCount;

  /// Output only. The number of entities for which any error was encountered.
  final int failedCount;

  /// Output only. In cases when enough errors are encountered a job, pipeline,
  /// or operation may be failed as a whole. Below is the number of entities for
  /// which the processing had not been finished (either in successful or failed
  /// state). Set to -1 if the number is unknown (for example, the operation
  /// failed before the total entity number could be collected).
  final int incompleteCount;

  /// Output only. The number of the successful forecast points that are
  /// generated by the forecasting model. This is ONLY used by the forecasting
  /// batch prediction.
  final int successfulForecastPointCount;

  CompletionStats({
    this.successfulCount = 0,
    this.failedCount = 0,
    this.incompleteCount = 0,
    this.successfulForecastPointCount = 0,
  }) : super(fullyQualifiedName);

  factory CompletionStats.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CompletionStats(
      successfulCount: switch (json['successfulCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      failedCount: switch (json['failedCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      incompleteCount: switch (json['incompleteCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      successfulForecastPointCount:
          switch (json['successfulForecastPointCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (successfulCount.isNotDefault)
      'successfulCount': encodeInt64(successfulCount),
    if (failedCount.isNotDefault) 'failedCount': encodeInt64(failedCount),
    if (incompleteCount.isNotDefault)
      'incompleteCount': encodeInt64(incompleteCount),
    if (successfulForecastPointCount.isNotDefault)
      'successfulForecastPointCount': encodeInt64(successfulForecastPointCount),
  };

  @override
  String toString() {
    final contents = [
      'successfulCount=$successfulCount',
      'failedCount=$failedCount',
      'incompleteCount=$incompleteCount',
      'successfulForecastPointCount=$successfulForecastPointCount',
    ].join(',');
    return 'CompletionStats($contents)';
  }
}

/// The base structured datatype containing multi-part content of a message.
///
/// A `Content` includes a `role` field designating the producer of the `Content`
/// and a `parts` field containing multi-part data that contains the content of
/// the message turn.
final class Content extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Content';

  /// Optional. The producer of the content. Must be either 'user' or 'model'.
  ///
  /// Useful to set for multi-turn conversations, otherwise can be left blank
  /// or unset.
  final String role;

  /// Required. Ordered `Parts` that constitute a single message. Parts may have
  /// different IANA MIME types.
  final List<Part> parts;

  Content({this.role = '', required this.parts}) : super(fullyQualifiedName);

  factory Content.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Content(
      role: switch (json['role']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parts: switch (json['parts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Part.fromJson(i)],
        _ => throw const FormatException('"parts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (role.isNotDefault) 'role': role,
    'parts': encodeList(parts),
  };

  @override
  String toString() {
    final contents = ['role=$role'].join(',');
    return 'Content($contents)';
  }
}

/// A datatype containing media that is part of a multi-part `Content` message.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can only
/// contain one of the accepted types in `Part.data`.
///
/// A `Part` must have a fixed IANA MIME type identifying the type and subtype
/// of the media if `inline_data` or `file_data` field is filled with raw bytes.
final class Part extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Part';

  /// Optional. Text part (can be code).
  final String? text;

  /// Optional. Inlined bytes data.
  final Blob? inlineData;

  /// Optional. URI based data.
  final FileData? fileData;

  /// Optional. A predicted [FunctionCall] returned from the model that
  /// contains a string representing the [FunctionDeclaration.name] with the
  /// parameters and their values.
  final FunctionCall? functionCall;

  /// Optional. The result output of a [FunctionCall] that contains a string
  /// representing the [FunctionDeclaration.name] and a structured JSON object
  /// containing any output from the function call. It is used as context to
  /// the model.
  final FunctionResponse? functionResponse;

  /// Optional. Code generated by the model that is meant to be executed.
  final ExecutableCode? executableCode;

  /// Optional. Result of executing the [ExecutableCode].
  final CodeExecutionResult? codeExecutionResult;

  /// Optional. Video metadata. The metadata should only be specified while the
  /// video data is presented in inline_data or file_data.
  final VideoMetadata? videoMetadata;

  /// Indicates if the part is thought from the model.
  final bool thought;

  /// An opaque signature for the thought so it can be reused in subsequent
  /// requests.
  final Uint8List thoughtSignature;

  Part({
    this.text,
    this.inlineData,
    this.fileData,
    this.functionCall,
    this.functionResponse,
    this.executableCode,
    this.codeExecutionResult,
    this.videoMetadata,
    this.thought = false,
    Uint8List? thoughtSignature,
  }) : thoughtSignature = thoughtSignature ?? Uint8List(0),
       super(fullyQualifiedName);

  factory Part.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Part(
      text: switch (json['text']) {
        null => null,
        Object $1 => decodeString($1),
      },
      inlineData: switch (json['inlineData']) {
        null => null,
        Object $1 => Blob.fromJson($1),
      },
      fileData: switch (json['fileData']) {
        null => null,
        Object $1 => FileData.fromJson($1),
      },
      functionCall: switch (json['functionCall']) {
        null => null,
        Object $1 => FunctionCall.fromJson($1),
      },
      functionResponse: switch (json['functionResponse']) {
        null => null,
        Object $1 => FunctionResponse.fromJson($1),
      },
      executableCode: switch (json['executableCode']) {
        null => null,
        Object $1 => ExecutableCode.fromJson($1),
      },
      codeExecutionResult: switch (json['codeExecutionResult']) {
        null => null,
        Object $1 => CodeExecutionResult.fromJson($1),
      },
      videoMetadata: switch (json['videoMetadata']) {
        null => null,
        Object $1 => VideoMetadata.fromJson($1),
      },
      thought: switch (json['thought']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      thoughtSignature: switch (json['thoughtSignature']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (text != null) 'text': text,
    if (inlineData != null) 'inlineData': inlineData!.toJson(),
    if (fileData != null) 'fileData': fileData!.toJson(),
    if (functionCall != null) 'functionCall': functionCall!.toJson(),
    if (functionResponse != null)
      'functionResponse': functionResponse!.toJson(),
    if (executableCode != null) 'executableCode': executableCode!.toJson(),
    if (codeExecutionResult != null)
      'codeExecutionResult': codeExecutionResult!.toJson(),
    if (videoMetadata != null) 'videoMetadata': videoMetadata!.toJson(),
    if (thought.isNotDefault) 'thought': thought,
    if (thoughtSignature.isNotDefault)
      'thoughtSignature': encodeBytes(thoughtSignature),
  };

  @override
  String toString() {
    final contents = [
      if (text != null) 'text=$text',
      'thought=$thought',
      'thoughtSignature=$thoughtSignature',
    ].join(',');
    return 'Part($contents)';
  }
}

/// Content blob.
///
/// It's preferred to send as `text`
/// directly rather than raw bytes.
final class Blob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Blob';

  /// Required. The IANA standard MIME type of the source data.
  final String mimeType;

  /// Required. Raw bytes.
  final Uint8List data;

  Blob({required this.mimeType, required this.data})
    : super(fullyQualifiedName);

  factory Blob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Blob(
      mimeType: switch (json['mimeType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      data: switch (json['data']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {'mimeType': mimeType, 'data': encodeBytes(data)};

  @override
  String toString() {
    final contents = ['mimeType=$mimeType', 'data=$data'].join(',');
    return 'Blob($contents)';
  }
}

/// URI based data.
final class FileData extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FileData';

  /// Required. The IANA standard MIME type of the source data.
  final String mimeType;

  /// Required. URI.
  final String fileUri;

  FileData({required this.mimeType, required this.fileUri})
    : super(fullyQualifiedName);

  factory FileData.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FileData(
      mimeType: switch (json['mimeType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      fileUri: switch (json['fileUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'mimeType': mimeType, 'fileUri': fileUri};

  @override
  String toString() {
    final contents = ['mimeType=$mimeType', 'fileUri=$fileUri'].join(',');
    return 'FileData($contents)';
  }
}

/// Metadata describes the input video content.
final class VideoMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VideoMetadata';

  /// Optional. The start offset of the video.
  final protobuf.Duration? startOffset;

  /// Optional. The end offset of the video.
  final protobuf.Duration? endOffset;

  VideoMetadata({this.startOffset, this.endOffset}) : super(fullyQualifiedName);

  factory VideoMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VideoMetadata(
      startOffset: switch (json['startOffset']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      endOffset: switch (json['endOffset']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (startOffset != null) 'startOffset': startOffset!.toJson(),
    if (endOffset != null) 'endOffset': endOffset!.toJson(),
  };

  @override
  String toString() => 'VideoMetadata()';
}

/// The configuration for the prebuilt speaker to use.
final class PrebuiltVoiceConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PrebuiltVoiceConfig';

  /// The name of the preset voice to use.
  final String? voiceName;

  PrebuiltVoiceConfig({this.voiceName}) : super(fullyQualifiedName);

  factory PrebuiltVoiceConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PrebuiltVoiceConfig(
      voiceName: switch (json['voiceName']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (voiceName != null) 'voiceName': voiceName};

  @override
  String toString() {
    final contents = [if (voiceName != null) 'voiceName=$voiceName'].join(',');
    return 'PrebuiltVoiceConfig($contents)';
  }
}

/// The configuration for the voice to use.
final class VoiceConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VoiceConfig';

  /// The configuration for the prebuilt voice to use.
  final PrebuiltVoiceConfig? prebuiltVoiceConfig;

  VoiceConfig({this.prebuiltVoiceConfig}) : super(fullyQualifiedName);

  factory VoiceConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VoiceConfig(
      prebuiltVoiceConfig: switch (json['prebuiltVoiceConfig']) {
        null => null,
        Object $1 => PrebuiltVoiceConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prebuiltVoiceConfig != null)
      'prebuiltVoiceConfig': prebuiltVoiceConfig!.toJson(),
  };

  @override
  String toString() => 'VoiceConfig()';
}

/// The speech generation config.
final class SpeechConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpeechConfig';

  /// The configuration for the speaker to use.
  final VoiceConfig? voiceConfig;

  SpeechConfig({this.voiceConfig}) : super(fullyQualifiedName);

  factory SpeechConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SpeechConfig(
      voiceConfig: switch (json['voiceConfig']) {
        null => null,
        Object $1 => VoiceConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (voiceConfig != null) 'voiceConfig': voiceConfig!.toJson(),
  };

  @override
  String toString() => 'SpeechConfig()';
}

/// Config for image generation features.
final class ImageConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImageConfig';

  /// Optional. The desired aspect ratio for the generated images. The following
  /// aspect ratios are supported:
  ///
  /// "1:1"
  /// "2:3", "3:2"
  /// "3:4", "4:3"
  /// "4:5", "5:4"
  /// "9:16", "16:9"
  /// "21:9"
  final String? aspectRatio;

  ImageConfig({this.aspectRatio}) : super(fullyQualifiedName);

  factory ImageConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImageConfig(
      aspectRatio: switch (json['aspectRatio']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (aspectRatio != null) 'aspectRatio': aspectRatio};

  @override
  String toString() {
    final contents = [
      if (aspectRatio != null) 'aspectRatio=$aspectRatio',
    ].join(',');
    return 'ImageConfig($contents)';
  }
}

/// Generation config.
final class GenerationConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig';

  /// Optional. Controls the randomness of predictions.
  final double? temperature;

  /// Optional. If specified, nucleus sampling will be used.
  final double? topP;

  /// Optional. If specified, top-k sampling will be used.
  final double? topK;

  /// Optional. Number of candidates to generate.
  final int? candidateCount;

  /// Optional. The maximum number of output tokens to generate per message.
  final int? maxOutputTokens;

  /// Optional. Stop sequences.
  final List<String> stopSequences;

  /// Optional. If true, export the logprobs results in response.
  final bool? responseLogprobs;

  /// Optional. Logit probabilities.
  final int? logprobs;

  /// Optional. Positive penalties.
  final double? presencePenalty;

  /// Optional. Frequency penalties.
  final double? frequencyPenalty;

  /// Optional. Seed.
  final int? seed;

  /// Optional. Output response mimetype of the generated candidate text.
  /// Supported mimetype:
  /// - `text/plain`: (default) Text output.
  /// - `application/json`: JSON response in the candidates.
  /// The model needs to be prompted to output the appropriate response type,
  /// otherwise the behavior is undefined.
  /// This is a preview feature.
  final String responseMimeType;

  /// Optional. The `Schema` object allows the definition of input and output
  /// data types. These types can be objects, but also primitives and arrays.
  /// Represents a select subset of an [OpenAPI 3.0 schema
  /// object](https://spec.openapis.org/oas/v3.0.3#schema).
  /// If set, a compatible response_mime_type must also be set.
  /// Compatible mimetypes:
  /// `application/json`: Schema for JSON response.
  final Schema? responseSchema;

  /// Optional. Output schema of the generated response. This is an alternative
  /// to `response_schema` that accepts [JSON Schema](https://json-schema.org/).
  ///
  /// If set, `response_schema` must be omitted, but `response_mime_type` is
  /// required.
  ///
  /// While the full JSON Schema may be sent, not all features are supported.
  /// Specifically, only the following properties are supported:
  ///
  /// - `$id`
  /// - `$defs`
  /// - `$ref`
  /// - `$anchor`
  /// - `type`
  /// - `format`
  /// - `title`
  /// - `description`
  /// - `enum` (for strings and numbers)
  /// - `items`
  /// - `prefixItems`
  /// - `minItems`
  /// - `maxItems`
  /// - `minimum`
  /// - `maximum`
  /// - `anyOf`
  /// - `oneOf` (interpreted the same as `anyOf`)
  /// - `properties`
  /// - `additionalProperties`
  /// - `required`
  ///
  /// The non-standard `propertyOrdering` property may also be set.
  ///
  /// Cyclic references are unrolled to a limited degree and, as such, may only
  /// be used within non-required properties. (Nullable properties are not
  /// sufficient.) If `$ref` is set on a sub-schema, no other properties, except
  /// for than those starting as a `$`, may be set.
  final protobuf.Value? responseJsonSchema;

  /// Optional. Routing configuration.
  final GenerationConfig_RoutingConfig? routingConfig;

  /// Optional. If enabled, audio timestamp will be included in the request to
  /// the model.
  final bool? audioTimestamp;

  /// Optional. The modalities of the response.
  final List<GenerationConfig_Modality> responseModalities;

  /// Optional. If specified, the media resolution specified will be used.
  final GenerationConfig_MediaResolution? mediaResolution;

  /// Optional. The speech generation config.
  final SpeechConfig? speechConfig;

  /// Optional. Config for thinking features.
  /// An error will be returned if this field is set for models that don't
  /// support thinking.
  final GenerationConfig_ThinkingConfig? thinkingConfig;

  /// Optional. Config for model selection.
  final GenerationConfig_ModelConfig? modelConfig;

  /// Optional. Config for image generation features.
  final ImageConfig? imageConfig;

  GenerationConfig({
    this.temperature,
    this.topP,
    this.topK,
    this.candidateCount,
    this.maxOutputTokens,
    this.stopSequences = const [],
    this.responseLogprobs,
    this.logprobs,
    this.presencePenalty,
    this.frequencyPenalty,
    this.seed,
    this.responseMimeType = '',
    this.responseSchema,
    this.responseJsonSchema,
    this.routingConfig,
    this.audioTimestamp,
    this.responseModalities = const [],
    this.mediaResolution,
    this.speechConfig,
    this.thinkingConfig,
    this.modelConfig,
    this.imageConfig,
  }) : super(fullyQualifiedName);

  factory GenerationConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerationConfig(
      temperature: switch (json['temperature']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      topP: switch (json['topP']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      topK: switch (json['topK']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      candidateCount: switch (json['candidateCount']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      maxOutputTokens: switch (json['maxOutputTokens']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      stopSequences: switch (json['stopSequences']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"stopSequences" is not a list'),
      },
      responseLogprobs: switch (json['responseLogprobs']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      logprobs: switch (json['logprobs']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      presencePenalty: switch (json['presencePenalty']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      frequencyPenalty: switch (json['frequencyPenalty']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      seed: switch (json['seed']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      responseMimeType: switch (json['responseMimeType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      responseSchema: switch (json['responseSchema']) {
        null => null,
        Object $1 => Schema.fromJson($1),
      },
      responseJsonSchema: switch (json['responseJsonSchema']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      routingConfig: switch (json['routingConfig']) {
        null => null,
        Object $1 => GenerationConfig_RoutingConfig.fromJson($1),
      },
      audioTimestamp: switch (json['audioTimestamp']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      responseModalities: switch (json['responseModalities']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) GenerationConfig_Modality.fromJson(i),
        ],
        _ => throw const FormatException('"responseModalities" is not a list'),
      },
      mediaResolution: switch (json['mediaResolution']) {
        null => null,
        Object $1 => GenerationConfig_MediaResolution.fromJson($1),
      },
      speechConfig: switch (json['speechConfig']) {
        null => null,
        Object $1 => SpeechConfig.fromJson($1),
      },
      thinkingConfig: switch (json['thinkingConfig']) {
        null => null,
        Object $1 => GenerationConfig_ThinkingConfig.fromJson($1),
      },
      modelConfig: switch (json['modelConfig']) {
        null => null,
        Object $1 => GenerationConfig_ModelConfig.fromJson($1),
      },
      imageConfig: switch (json['imageConfig']) {
        null => null,
        Object $1 => ImageConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (temperature != null) 'temperature': encodeDouble(temperature),
    if (topP != null) 'topP': encodeDouble(topP),
    if (topK != null) 'topK': encodeDouble(topK),
    if (candidateCount != null) 'candidateCount': candidateCount,
    if (maxOutputTokens != null) 'maxOutputTokens': maxOutputTokens,
    if (stopSequences.isNotDefault) 'stopSequences': stopSequences,
    if (responseLogprobs != null) 'responseLogprobs': responseLogprobs,
    if (logprobs != null) 'logprobs': logprobs,
    if (presencePenalty != null)
      'presencePenalty': encodeDouble(presencePenalty),
    if (frequencyPenalty != null)
      'frequencyPenalty': encodeDouble(frequencyPenalty),
    if (seed != null) 'seed': seed,
    if (responseMimeType.isNotDefault) 'responseMimeType': responseMimeType,
    if (responseSchema != null) 'responseSchema': responseSchema!.toJson(),
    if (responseJsonSchema != null)
      'responseJsonSchema': responseJsonSchema!.toJson(),
    if (routingConfig != null) 'routingConfig': routingConfig!.toJson(),
    if (audioTimestamp != null) 'audioTimestamp': audioTimestamp,
    if (responseModalities.isNotDefault)
      'responseModalities': encodeList(responseModalities),
    if (mediaResolution != null) 'mediaResolution': mediaResolution!.toJson(),
    if (speechConfig != null) 'speechConfig': speechConfig!.toJson(),
    if (thinkingConfig != null) 'thinkingConfig': thinkingConfig!.toJson(),
    if (modelConfig != null) 'modelConfig': modelConfig!.toJson(),
    if (imageConfig != null) 'imageConfig': imageConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (temperature != null) 'temperature=$temperature',
      if (topP != null) 'topP=$topP',
      if (topK != null) 'topK=$topK',
      if (candidateCount != null) 'candidateCount=$candidateCount',
      if (maxOutputTokens != null) 'maxOutputTokens=$maxOutputTokens',
      if (responseLogprobs != null) 'responseLogprobs=$responseLogprobs',
      if (logprobs != null) 'logprobs=$logprobs',
      if (presencePenalty != null) 'presencePenalty=$presencePenalty',
      if (frequencyPenalty != null) 'frequencyPenalty=$frequencyPenalty',
      if (seed != null) 'seed=$seed',
      'responseMimeType=$responseMimeType',
      if (audioTimestamp != null) 'audioTimestamp=$audioTimestamp',
      if (mediaResolution != null) 'mediaResolution=$mediaResolution',
    ].join(',');
    return 'GenerationConfig($contents)';
  }
}

/// The configuration for routing the request to a specific model.
final class GenerationConfig_RoutingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.RoutingConfig';

  /// Automated routing.
  final GenerationConfig_RoutingConfig_AutoRoutingMode? autoMode;

  /// Manual routing.
  final GenerationConfig_RoutingConfig_ManualRoutingMode? manualMode;

  GenerationConfig_RoutingConfig({this.autoMode, this.manualMode})
    : super(fullyQualifiedName);

  factory GenerationConfig_RoutingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerationConfig_RoutingConfig(
      autoMode: switch (json['autoMode']) {
        null => null,
        Object $1 => GenerationConfig_RoutingConfig_AutoRoutingMode.fromJson(
          $1,
        ),
      },
      manualMode: switch (json['manualMode']) {
        null => null,
        Object $1 => GenerationConfig_RoutingConfig_ManualRoutingMode.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (autoMode != null) 'autoMode': autoMode!.toJson(),
    if (manualMode != null) 'manualMode': manualMode!.toJson(),
  };

  @override
  String toString() => 'RoutingConfig()';
}

/// When automated routing is specified, the routing will be determined by
/// the pretrained routing model and customer provided model routing
/// preference.
final class GenerationConfig_RoutingConfig_AutoRoutingMode
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.RoutingConfig.AutoRoutingMode';

  /// The model routing preference.
  final GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference?
  modelRoutingPreference;

  GenerationConfig_RoutingConfig_AutoRoutingMode({this.modelRoutingPreference})
    : super(fullyQualifiedName);

  factory GenerationConfig_RoutingConfig_AutoRoutingMode.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerationConfig_RoutingConfig_AutoRoutingMode(
      modelRoutingPreference: switch (json['modelRoutingPreference']) {
        null => null,
        Object $1 =>
          GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelRoutingPreference != null)
      'modelRoutingPreference': modelRoutingPreference!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (modelRoutingPreference != null)
        'modelRoutingPreference=$modelRoutingPreference',
    ].join(',');
    return 'AutoRoutingMode($contents)';
  }
}

/// The model routing preference.
final class GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference
    extends ProtoEnum {
  /// Unspecified model routing preference.
  static const unknown =
      GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
        'UNKNOWN',
      );

  /// Prefer higher quality over low cost.
  static const prioritizeQuality =
      GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
        'PRIORITIZE_QUALITY',
      );

  /// Balanced model routing preference.
  static const balanced =
      GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
        'BALANCED',
      );

  /// Prefer lower cost over higher quality.
  static const prioritizeCost =
      GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
        'PRIORITIZE_COST',
      );

  /// The default value for [GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference].
  static const $default = unknown;

  const GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
    super.value,
  );

  factory GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.fromJson(
    Object? json,
  ) => GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
    json as String,
  );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ModelRoutingPreference.$value';
}

/// When manual routing is set, the specified model will be used directly.
final class GenerationConfig_RoutingConfig_ManualRoutingMode
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.RoutingConfig.ManualRoutingMode';

  /// The model name to use. Only the public LLM models are accepted. e.g.
  /// 'gemini-1.5-pro-001'.
  final String? modelName;

  GenerationConfig_RoutingConfig_ManualRoutingMode({this.modelName})
    : super(fullyQualifiedName);

  factory GenerationConfig_RoutingConfig_ManualRoutingMode.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerationConfig_RoutingConfig_ManualRoutingMode(
      modelName: switch (json['modelName']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (modelName != null) 'modelName': modelName};

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'ManualRoutingMode($contents)';
  }
}

/// Config for thinking features.
final class GenerationConfig_ThinkingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.ThinkingConfig';

  /// Indicates whether to include thoughts in the response.
  /// If true, thoughts are returned only when available.
  final bool? includeThoughts;

  /// Optional. Indicates the thinking budget in tokens.
  /// This is only applied when enable_thinking is true.
  final int? thinkingBudget;

  GenerationConfig_ThinkingConfig({this.includeThoughts, this.thinkingBudget})
    : super(fullyQualifiedName);

  factory GenerationConfig_ThinkingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerationConfig_ThinkingConfig(
      includeThoughts: switch (json['includeThoughts']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      thinkingBudget: switch (json['thinkingBudget']) {
        null => null,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (includeThoughts != null) 'includeThoughts': includeThoughts,
    if (thinkingBudget != null) 'thinkingBudget': thinkingBudget,
  };

  @override
  String toString() {
    final contents = [
      if (includeThoughts != null) 'includeThoughts=$includeThoughts',
      if (thinkingBudget != null) 'thinkingBudget=$thinkingBudget',
    ].join(',');
    return 'ThinkingConfig($contents)';
  }
}

/// Config for model selection.
final class GenerationConfig_ModelConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.ModelConfig';

  /// Required. Feature selection preference.
  final GenerationConfig_ModelConfig_FeatureSelectionPreference
  featureSelectionPreference;

  GenerationConfig_ModelConfig({required this.featureSelectionPreference})
    : super(fullyQualifiedName);

  factory GenerationConfig_ModelConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerationConfig_ModelConfig(
      featureSelectionPreference: switch (json['featureSelectionPreference']) {
        null =>
          GenerationConfig_ModelConfig_FeatureSelectionPreference.$default,
        Object $1 =>
          GenerationConfig_ModelConfig_FeatureSelectionPreference.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'featureSelectionPreference': featureSelectionPreference.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'featureSelectionPreference=$featureSelectionPreference',
    ].join(',');
    return 'ModelConfig($contents)';
  }
}

/// Options for feature selection preference.
final class GenerationConfig_ModelConfig_FeatureSelectionPreference
    extends ProtoEnum {
  /// Unspecified feature selection preference.
  static const featureSelectionPreferenceUnspecified =
      GenerationConfig_ModelConfig_FeatureSelectionPreference(
        'FEATURE_SELECTION_PREFERENCE_UNSPECIFIED',
      );

  /// Prefer higher quality over lower cost.
  static const prioritizeQuality =
      GenerationConfig_ModelConfig_FeatureSelectionPreference(
        'PRIORITIZE_QUALITY',
      );

  /// Balanced feature selection preference.
  static const balanced =
      GenerationConfig_ModelConfig_FeatureSelectionPreference('BALANCED');

  /// Prefer lower cost over higher quality.
  static const prioritizeCost =
      GenerationConfig_ModelConfig_FeatureSelectionPreference(
        'PRIORITIZE_COST',
      );

  /// The default value for [GenerationConfig_ModelConfig_FeatureSelectionPreference].
  static const $default = featureSelectionPreferenceUnspecified;

  const GenerationConfig_ModelConfig_FeatureSelectionPreference(super.value);

  factory GenerationConfig_ModelConfig_FeatureSelectionPreference.fromJson(
    Object? json,
  ) => GenerationConfig_ModelConfig_FeatureSelectionPreference(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'FeatureSelectionPreference.$value';
}

/// The modalities of the response.
final class GenerationConfig_Modality extends ProtoEnum {
  /// Unspecified modality. Will be processed as text.
  static const modalityUnspecified = GenerationConfig_Modality(
    'MODALITY_UNSPECIFIED',
  );

  /// Text modality.
  static const text = GenerationConfig_Modality('TEXT');

  /// Image modality.
  static const image = GenerationConfig_Modality('IMAGE');

  /// Audio modality.
  static const audio = GenerationConfig_Modality('AUDIO');

  /// The default value for [GenerationConfig_Modality].
  static const $default = modalityUnspecified;

  const GenerationConfig_Modality(super.value);

  factory GenerationConfig_Modality.fromJson(Object? json) =>
      GenerationConfig_Modality(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Modality.$value';
}

/// Media resolution for the input media.
final class GenerationConfig_MediaResolution extends ProtoEnum {
  /// Media resolution has not been set.
  static const mediaResolutionUnspecified = GenerationConfig_MediaResolution(
    'MEDIA_RESOLUTION_UNSPECIFIED',
  );

  /// Media resolution set to low (64 tokens).
  static const mediaResolutionLow = GenerationConfig_MediaResolution(
    'MEDIA_RESOLUTION_LOW',
  );

  /// Media resolution set to medium (256 tokens).
  static const mediaResolutionMedium = GenerationConfig_MediaResolution(
    'MEDIA_RESOLUTION_MEDIUM',
  );

  /// Media resolution set to high (zoomed reframing with 256 tokens).
  static const mediaResolutionHigh = GenerationConfig_MediaResolution(
    'MEDIA_RESOLUTION_HIGH',
  );

  /// The default value for [GenerationConfig_MediaResolution].
  static const $default = mediaResolutionUnspecified;

  const GenerationConfig_MediaResolution(super.value);

  factory GenerationConfig_MediaResolution.fromJson(Object? json) =>
      GenerationConfig_MediaResolution(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'MediaResolution.$value';
}

/// Safety settings.
final class SafetySetting extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetySetting';

  /// Required. Harm category.
  final HarmCategory category;

  /// Required. The harm block threshold.
  final SafetySetting_HarmBlockThreshold threshold;

  /// Optional. Specify if the threshold is used for probability or severity
  /// score. If not specified, the threshold is used for probability score.
  final SafetySetting_HarmBlockMethod method;

  SafetySetting({
    required this.category,
    required this.threshold,
    this.method = SafetySetting_HarmBlockMethod.$default,
  }) : super(fullyQualifiedName);

  factory SafetySetting.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SafetySetting(
      category: switch (json['category']) {
        null => HarmCategory.$default,
        Object $1 => HarmCategory.fromJson($1),
      },
      threshold: switch (json['threshold']) {
        null => SafetySetting_HarmBlockThreshold.$default,
        Object $1 => SafetySetting_HarmBlockThreshold.fromJson($1),
      },
      method: switch (json['method']) {
        null => SafetySetting_HarmBlockMethod.$default,
        Object $1 => SafetySetting_HarmBlockMethod.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'category': category.toJson(),
    'threshold': threshold.toJson(),
    if (method.isNotDefault) 'method': method.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'category=$category',
      'threshold=$threshold',
      'method=$method',
    ].join(',');
    return 'SafetySetting($contents)';
  }
}

/// Probability based thresholds levels for blocking.
final class SafetySetting_HarmBlockThreshold extends ProtoEnum {
  /// Unspecified harm block threshold.
  static const harmBlockThresholdUnspecified = SafetySetting_HarmBlockThreshold(
    'HARM_BLOCK_THRESHOLD_UNSPECIFIED',
  );

  /// Block low threshold and above (i.e. block more).
  static const blockLowAndAbove = SafetySetting_HarmBlockThreshold(
    'BLOCK_LOW_AND_ABOVE',
  );

  /// Block medium threshold and above.
  static const blockMediumAndAbove = SafetySetting_HarmBlockThreshold(
    'BLOCK_MEDIUM_AND_ABOVE',
  );

  /// Block only high threshold (i.e. block less).
  static const blockOnlyHigh = SafetySetting_HarmBlockThreshold(
    'BLOCK_ONLY_HIGH',
  );

  /// Block none.
  static const blockNone = SafetySetting_HarmBlockThreshold('BLOCK_NONE');

  /// Turn off the safety filter.
  static const off = SafetySetting_HarmBlockThreshold('OFF');

  /// The default value for [SafetySetting_HarmBlockThreshold].
  static const $default = harmBlockThresholdUnspecified;

  const SafetySetting_HarmBlockThreshold(super.value);

  factory SafetySetting_HarmBlockThreshold.fromJson(Object? json) =>
      SafetySetting_HarmBlockThreshold(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'HarmBlockThreshold.$value';
}

/// Probability vs severity.
final class SafetySetting_HarmBlockMethod extends ProtoEnum {
  /// The harm block method is unspecified.
  static const harmBlockMethodUnspecified = SafetySetting_HarmBlockMethod(
    'HARM_BLOCK_METHOD_UNSPECIFIED',
  );

  /// The harm block method uses both probability and severity scores.
  static const severity = SafetySetting_HarmBlockMethod('SEVERITY');

  /// The harm block method uses the probability score.
  static const probability = SafetySetting_HarmBlockMethod('PROBABILITY');

  /// The default value for [SafetySetting_HarmBlockMethod].
  static const $default = harmBlockMethodUnspecified;

  const SafetySetting_HarmBlockMethod(super.value);

  factory SafetySetting_HarmBlockMethod.fromJson(Object? json) =>
      SafetySetting_HarmBlockMethod(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'HarmBlockMethod.$value';
}

/// Safety rating corresponding to the generated content.
final class SafetyRating extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetyRating';

  /// Output only. Harm category.
  final HarmCategory category;

  /// Output only. Harm probability levels in the content.
  final SafetyRating_HarmProbability probability;

  /// Output only. Harm probability score.
  final double probabilityScore;

  /// Output only. Harm severity levels in the content.
  final SafetyRating_HarmSeverity severity;

  /// Output only. Harm severity score.
  final double severityScore;

  /// Output only. Indicates whether the content was filtered out because of this
  /// rating.
  final bool blocked;

  SafetyRating({
    this.category = HarmCategory.$default,
    this.probability = SafetyRating_HarmProbability.$default,
    this.probabilityScore = 0,
    this.severity = SafetyRating_HarmSeverity.$default,
    this.severityScore = 0,
    this.blocked = false,
  }) : super(fullyQualifiedName);

  factory SafetyRating.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SafetyRating(
      category: switch (json['category']) {
        null => HarmCategory.$default,
        Object $1 => HarmCategory.fromJson($1),
      },
      probability: switch (json['probability']) {
        null => SafetyRating_HarmProbability.$default,
        Object $1 => SafetyRating_HarmProbability.fromJson($1),
      },
      probabilityScore: switch (json['probabilityScore']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      severity: switch (json['severity']) {
        null => SafetyRating_HarmSeverity.$default,
        Object $1 => SafetyRating_HarmSeverity.fromJson($1),
      },
      severityScore: switch (json['severityScore']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      blocked: switch (json['blocked']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (category.isNotDefault) 'category': category.toJson(),
    if (probability.isNotDefault) 'probability': probability.toJson(),
    if (probabilityScore.isNotDefault)
      'probabilityScore': encodeDouble(probabilityScore),
    if (severity.isNotDefault) 'severity': severity.toJson(),
    if (severityScore.isNotDefault)
      'severityScore': encodeDouble(severityScore),
    if (blocked.isNotDefault) 'blocked': blocked,
  };

  @override
  String toString() {
    final contents = [
      'category=$category',
      'probability=$probability',
      'probabilityScore=$probabilityScore',
      'severity=$severity',
      'severityScore=$severityScore',
      'blocked=$blocked',
    ].join(',');
    return 'SafetyRating($contents)';
  }
}

/// Harm probability levels in the content.
final class SafetyRating_HarmProbability extends ProtoEnum {
  /// Harm probability unspecified.
  static const harmProbabilityUnspecified = SafetyRating_HarmProbability(
    'HARM_PROBABILITY_UNSPECIFIED',
  );

  /// Negligible level of harm.
  static const negligible = SafetyRating_HarmProbability('NEGLIGIBLE');

  /// Low level of harm.
  static const low = SafetyRating_HarmProbability('LOW');

  /// Medium level of harm.
  static const medium = SafetyRating_HarmProbability('MEDIUM');

  /// High level of harm.
  static const high = SafetyRating_HarmProbability('HIGH');

  /// The default value for [SafetyRating_HarmProbability].
  static const $default = harmProbabilityUnspecified;

  const SafetyRating_HarmProbability(super.value);

  factory SafetyRating_HarmProbability.fromJson(Object? json) =>
      SafetyRating_HarmProbability(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'HarmProbability.$value';
}

/// Harm severity levels.
final class SafetyRating_HarmSeverity extends ProtoEnum {
  /// Harm severity unspecified.
  static const harmSeverityUnspecified = SafetyRating_HarmSeverity(
    'HARM_SEVERITY_UNSPECIFIED',
  );

  /// Negligible level of harm severity.
  static const harmSeverityNegligible = SafetyRating_HarmSeverity(
    'HARM_SEVERITY_NEGLIGIBLE',
  );

  /// Low level of harm severity.
  static const harmSeverityLow = SafetyRating_HarmSeverity('HARM_SEVERITY_LOW');

  /// Medium level of harm severity.
  static const harmSeverityMedium = SafetyRating_HarmSeverity(
    'HARM_SEVERITY_MEDIUM',
  );

  /// High level of harm severity.
  static const harmSeverityHigh = SafetyRating_HarmSeverity(
    'HARM_SEVERITY_HIGH',
  );

  /// The default value for [SafetyRating_HarmSeverity].
  static const $default = harmSeverityUnspecified;

  const SafetyRating_HarmSeverity(super.value);

  factory SafetyRating_HarmSeverity.fromJson(Object? json) =>
      SafetyRating_HarmSeverity(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'HarmSeverity.$value';
}

/// A collection of source attributions for a piece of content.
final class CitationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CitationMetadata';

  /// Output only. List of citations.
  final List<Citation> citations;

  CitationMetadata({this.citations = const []}) : super(fullyQualifiedName);

  factory CitationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CitationMetadata(
      citations: switch (json['citations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Citation.fromJson(i)],
        _ => throw const FormatException('"citations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (citations.isNotDefault) 'citations': encodeList(citations),
  };

  @override
  String toString() => 'CitationMetadata()';
}

/// Source attributions for content.
final class Citation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Citation';

  /// Output only. Start index into the content.
  final int startIndex;

  /// Output only. End index into the content.
  final int endIndex;

  /// Output only. Url reference of the attribution.
  final String uri;

  /// Output only. Title of the attribution.
  final String title;

  /// Output only. License of the attribution.
  final String license;

  /// Output only. Publication date of the attribution.
  final Date? publicationDate;

  Citation({
    this.startIndex = 0,
    this.endIndex = 0,
    this.uri = '',
    this.title = '',
    this.license = '',
    this.publicationDate,
  }) : super(fullyQualifiedName);

  factory Citation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Citation(
      startIndex: switch (json['startIndex']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      endIndex: switch (json['endIndex']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      uri: switch (json['uri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
      license: switch (json['license']) {
        null => '',
        Object $1 => decodeString($1),
      },
      publicationDate: switch (json['publicationDate']) {
        null => null,
        Object $1 => Date.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (startIndex.isNotDefault) 'startIndex': startIndex,
    if (endIndex.isNotDefault) 'endIndex': endIndex,
    if (uri.isNotDefault) 'uri': uri,
    if (title.isNotDefault) 'title': title,
    if (license.isNotDefault) 'license': license,
    if (publicationDate != null) 'publicationDate': publicationDate!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'startIndex=$startIndex',
      'endIndex=$endIndex',
      'uri=$uri',
      'title=$title',
      'license=$license',
    ].join(',');
    return 'Citation($contents)';
  }
}

/// A response candidate generated from the model.
final class Candidate extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Candidate';

  /// Output only. Index of the candidate.
  final int index;

  /// Output only. Content parts of the candidate.
  final Content? content;

  /// Output only. Average log probability score of the candidate.
  final double avgLogprobs;

  /// Output only. Log-likelihood scores for the response tokens and top tokens
  final LogprobsResult? logprobsResult;

  /// Output only. The reason why the model stopped generating tokens.
  /// If empty, the model has not stopped generating the tokens.
  final Candidate_FinishReason finishReason;

  /// Output only. List of ratings for the safety of a response candidate.
  ///
  /// There is at most one rating per category.
  final List<SafetyRating> safetyRatings;

  /// Output only. Describes the reason the mode stopped generating tokens in
  /// more detail. This is only filled when `finish_reason` is set.
  final String? finishMessage;

  /// Output only. Source attribution of the generated content.
  final CitationMetadata? citationMetadata;

  /// Output only. Metadata specifies sources used to ground generated content.
  final GroundingMetadata? groundingMetadata;

  /// Output only. Metadata related to url context retrieval tool.
  final UrlContextMetadata? urlContextMetadata;

  Candidate({
    this.index = 0,
    this.content,
    this.avgLogprobs = 0,
    this.logprobsResult,
    this.finishReason = Candidate_FinishReason.$default,
    this.safetyRatings = const [],
    this.finishMessage,
    this.citationMetadata,
    this.groundingMetadata,
    this.urlContextMetadata,
  }) : super(fullyQualifiedName);

  factory Candidate.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Candidate(
      index: switch (json['index']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      content: switch (json['content']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
      avgLogprobs: switch (json['avgLogprobs']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      logprobsResult: switch (json['logprobsResult']) {
        null => null,
        Object $1 => LogprobsResult.fromJson($1),
      },
      finishReason: switch (json['finishReason']) {
        null => Candidate_FinishReason.$default,
        Object $1 => Candidate_FinishReason.fromJson($1),
      },
      safetyRatings: switch (json['safetyRatings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SafetyRating.fromJson(i)],
        _ => throw const FormatException('"safetyRatings" is not a list'),
      },
      finishMessage: switch (json['finishMessage']) {
        null => null,
        Object $1 => decodeString($1),
      },
      citationMetadata: switch (json['citationMetadata']) {
        null => null,
        Object $1 => CitationMetadata.fromJson($1),
      },
      groundingMetadata: switch (json['groundingMetadata']) {
        null => null,
        Object $1 => GroundingMetadata.fromJson($1),
      },
      urlContextMetadata: switch (json['urlContextMetadata']) {
        null => null,
        Object $1 => UrlContextMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (index.isNotDefault) 'index': index,
    if (content != null) 'content': content!.toJson(),
    if (avgLogprobs.isNotDefault) 'avgLogprobs': encodeDouble(avgLogprobs),
    if (logprobsResult != null) 'logprobsResult': logprobsResult!.toJson(),
    if (finishReason.isNotDefault) 'finishReason': finishReason.toJson(),
    if (safetyRatings.isNotDefault) 'safetyRatings': encodeList(safetyRatings),
    if (finishMessage != null) 'finishMessage': finishMessage,
    if (citationMetadata != null)
      'citationMetadata': citationMetadata!.toJson(),
    if (groundingMetadata != null)
      'groundingMetadata': groundingMetadata!.toJson(),
    if (urlContextMetadata != null)
      'urlContextMetadata': urlContextMetadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'index=$index',
      'avgLogprobs=$avgLogprobs',
      'finishReason=$finishReason',
      if (finishMessage != null) 'finishMessage=$finishMessage',
    ].join(',');
    return 'Candidate($contents)';
  }
}

/// The reason why the model stopped generating tokens.
/// If empty, the model has not stopped generating the tokens.
final class Candidate_FinishReason extends ProtoEnum {
  /// The finish reason is unspecified.
  static const finishReasonUnspecified = Candidate_FinishReason(
    'FINISH_REASON_UNSPECIFIED',
  );

  /// Token generation reached a natural stopping point or a configured stop
  /// sequence.
  static const stop = Candidate_FinishReason('STOP');

  /// Token generation reached the configured maximum output tokens.
  static const maxTokens = Candidate_FinishReason('MAX_TOKENS');

  /// Token generation stopped because the content potentially contains safety
  /// violations. NOTE: When streaming,
  /// `content` is empty if
  /// content filters blocks the output.
  static const safety = Candidate_FinishReason('SAFETY');

  /// Token generation stopped because the content potentially contains
  /// copyright violations.
  static const recitation = Candidate_FinishReason('RECITATION');

  /// All other reasons that stopped the token generation.
  static const other = Candidate_FinishReason('OTHER');

  /// Token generation stopped because the content contains forbidden terms.
  static const blocklist = Candidate_FinishReason('BLOCKLIST');

  /// Token generation stopped for potentially containing prohibited content.
  static const prohibitedContent = Candidate_FinishReason('PROHIBITED_CONTENT');

  /// Token generation stopped because the content potentially contains
  /// Sensitive Personally Identifiable Information (SPII).
  static const spii = Candidate_FinishReason('SPII');

  /// The function call generated by the model is invalid.
  static const malformedFunctionCall = Candidate_FinishReason(
    'MALFORMED_FUNCTION_CALL',
  );

  /// The model response was blocked by Model Armor.
  static const modelArmor = Candidate_FinishReason('MODEL_ARMOR');

  /// The default value for [Candidate_FinishReason].
  static const $default = finishReasonUnspecified;

  const Candidate_FinishReason(super.value);

  factory Candidate_FinishReason.fromJson(Object? json) =>
      Candidate_FinishReason(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'FinishReason.$value';
}

/// Metadata related to url context retrieval tool.
final class UrlContextMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UrlContextMetadata';

  /// Output only. List of url context.
  final List<UrlMetadata> urlMetadata;

  UrlContextMetadata({this.urlMetadata = const []}) : super(fullyQualifiedName);

  factory UrlContextMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UrlContextMetadata(
      urlMetadata: switch (json['urlMetadata']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) UrlMetadata.fromJson(i)],
        _ => throw const FormatException('"urlMetadata" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (urlMetadata.isNotDefault) 'urlMetadata': encodeList(urlMetadata),
  };

  @override
  String toString() => 'UrlContextMetadata()';
}

/// Context of the a single url retrieval.
final class UrlMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UrlMetadata';

  /// Retrieved url by the tool.
  final String retrievedUrl;

  /// Status of the url retrieval.
  final UrlMetadata_UrlRetrievalStatus urlRetrievalStatus;

  UrlMetadata({
    this.retrievedUrl = '',
    this.urlRetrievalStatus = UrlMetadata_UrlRetrievalStatus.$default,
  }) : super(fullyQualifiedName);

  factory UrlMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UrlMetadata(
      retrievedUrl: switch (json['retrievedUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
      urlRetrievalStatus: switch (json['urlRetrievalStatus']) {
        null => UrlMetadata_UrlRetrievalStatus.$default,
        Object $1 => UrlMetadata_UrlRetrievalStatus.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (retrievedUrl.isNotDefault) 'retrievedUrl': retrievedUrl,
    if (urlRetrievalStatus.isNotDefault)
      'urlRetrievalStatus': urlRetrievalStatus.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'retrievedUrl=$retrievedUrl',
      'urlRetrievalStatus=$urlRetrievalStatus',
    ].join(',');
    return 'UrlMetadata($contents)';
  }
}

/// Status of the url retrieval.
final class UrlMetadata_UrlRetrievalStatus extends ProtoEnum {
  /// Default value. This value is unused.
  static const urlRetrievalStatusUnspecified = UrlMetadata_UrlRetrievalStatus(
    'URL_RETRIEVAL_STATUS_UNSPECIFIED',
  );

  /// Url retrieval is successful.
  static const urlRetrievalStatusSuccess = UrlMetadata_UrlRetrievalStatus(
    'URL_RETRIEVAL_STATUS_SUCCESS',
  );

  /// Url retrieval is failed due to error.
  static const urlRetrievalStatusError = UrlMetadata_UrlRetrievalStatus(
    'URL_RETRIEVAL_STATUS_ERROR',
  );

  /// The default value for [UrlMetadata_UrlRetrievalStatus].
  static const $default = urlRetrievalStatusUnspecified;

  const UrlMetadata_UrlRetrievalStatus(super.value);

  factory UrlMetadata_UrlRetrievalStatus.fromJson(Object? json) =>
      UrlMetadata_UrlRetrievalStatus(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'UrlRetrievalStatus.$value';
}

/// Logprobs Result
final class LogprobsResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LogprobsResult';

  /// Length = total number of decoding steps.
  final List<LogprobsResult_TopCandidates> topCandidates;

  /// Length = total number of decoding steps.
  /// The chosen candidates may or may not be in top_candidates.
  final List<LogprobsResult_Candidate> chosenCandidates;

  LogprobsResult({
    this.topCandidates = const [],
    this.chosenCandidates = const [],
  }) : super(fullyQualifiedName);

  factory LogprobsResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LogprobsResult(
      topCandidates: switch (json['topCandidates']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) LogprobsResult_TopCandidates.fromJson(i),
        ],
        _ => throw const FormatException('"topCandidates" is not a list'),
      },
      chosenCandidates: switch (json['chosenCandidates']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) LogprobsResult_Candidate.fromJson(i),
        ],
        _ => throw const FormatException('"chosenCandidates" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (topCandidates.isNotDefault) 'topCandidates': encodeList(topCandidates),
    if (chosenCandidates.isNotDefault)
      'chosenCandidates': encodeList(chosenCandidates),
  };

  @override
  String toString() => 'LogprobsResult()';
}

/// Candidate for the logprobs token and score.
final class LogprobsResult_Candidate extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LogprobsResult.Candidate';

  /// The candidates token string value.
  final String? token;

  /// The candidates token id value.
  final int? tokenId;

  /// The candidate's log probability.
  final double? logProbability;

  LogprobsResult_Candidate({this.token, this.tokenId, this.logProbability})
    : super(fullyQualifiedName);

  factory LogprobsResult_Candidate.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LogprobsResult_Candidate(
      token: switch (json['token']) {
        null => null,
        Object $1 => decodeString($1),
      },
      tokenId: switch (json['tokenId']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      logProbability: switch (json['logProbability']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (token != null) 'token': token,
    if (tokenId != null) 'tokenId': tokenId,
    if (logProbability != null) 'logProbability': encodeDouble(logProbability),
  };

  @override
  String toString() {
    final contents = [
      if (token != null) 'token=$token',
      if (tokenId != null) 'tokenId=$tokenId',
      if (logProbability != null) 'logProbability=$logProbability',
    ].join(',');
    return 'Candidate($contents)';
  }
}

/// Candidates with top log probabilities at each decoding step.
final class LogprobsResult_TopCandidates extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LogprobsResult.TopCandidates';

  /// Sorted by log probability in descending order.
  final List<LogprobsResult_Candidate> candidates;

  LogprobsResult_TopCandidates({this.candidates = const []})
    : super(fullyQualifiedName);

  factory LogprobsResult_TopCandidates.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LogprobsResult_TopCandidates(
      candidates: switch (json['candidates']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) LogprobsResult_Candidate.fromJson(i),
        ],
        _ => throw const FormatException('"candidates" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (candidates.isNotDefault) 'candidates': encodeList(candidates),
  };

  @override
  String toString() => 'TopCandidates()';
}

/// Segment of the content.
final class Segment extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Segment';

  /// Output only. The index of a Part object within its parent Content object.
  final int partIndex;

  /// Output only. Start index in the given Part, measured in bytes. Offset from
  /// the start of the Part, inclusive, starting at zero.
  final int startIndex;

  /// Output only. End index in the given Part, measured in bytes. Offset from
  /// the start of the Part, exclusive, starting at zero.
  final int endIndex;

  /// Output only. The text corresponding to the segment from the response.
  final String text;

  Segment({
    this.partIndex = 0,
    this.startIndex = 0,
    this.endIndex = 0,
    this.text = '',
  }) : super(fullyQualifiedName);

  factory Segment.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Segment(
      partIndex: switch (json['partIndex']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      startIndex: switch (json['startIndex']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      endIndex: switch (json['endIndex']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      text: switch (json['text']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (partIndex.isNotDefault) 'partIndex': partIndex,
    if (startIndex.isNotDefault) 'startIndex': startIndex,
    if (endIndex.isNotDefault) 'endIndex': endIndex,
    if (text.isNotDefault) 'text': text,
  };

  @override
  String toString() {
    final contents = [
      'partIndex=$partIndex',
      'startIndex=$startIndex',
      'endIndex=$endIndex',
      'text=$text',
    ].join(',');
    return 'Segment($contents)';
  }
}

/// Grounding chunk.
final class GroundingChunk extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk';

  /// Grounding chunk from the web.
  final GroundingChunk_Web? web;

  /// Grounding chunk from context retrieved by the retrieval tools.
  final GroundingChunk_RetrievedContext? retrievedContext;

  /// Grounding chunk from Google Maps.
  final GroundingChunk_Maps? maps;

  GroundingChunk({this.web, this.retrievedContext, this.maps})
    : super(fullyQualifiedName);

  factory GroundingChunk.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundingChunk(
      web: switch (json['web']) {
        null => null,
        Object $1 => GroundingChunk_Web.fromJson($1),
      },
      retrievedContext: switch (json['retrievedContext']) {
        null => null,
        Object $1 => GroundingChunk_RetrievedContext.fromJson($1),
      },
      maps: switch (json['maps']) {
        null => null,
        Object $1 => GroundingChunk_Maps.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (web != null) 'web': web!.toJson(),
    if (retrievedContext != null)
      'retrievedContext': retrievedContext!.toJson(),
    if (maps != null) 'maps': maps!.toJson(),
  };

  @override
  String toString() => 'GroundingChunk()';
}

/// Chunk from the web.
final class GroundingChunk_Web extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.Web';

  /// URI reference of the chunk.
  final String? uri;

  /// Title of the chunk.
  final String? title;

  GroundingChunk_Web({this.uri, this.title}) : super(fullyQualifiedName);

  factory GroundingChunk_Web.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundingChunk_Web(
      uri: switch (json['uri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (uri != null) 'uri': uri,
    if (title != null) 'title': title,
  };

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (title != null) 'title=$title',
    ].join(',');
    return 'Web($contents)';
  }
}

/// Chunk from context retrieved by the retrieval tools.
final class GroundingChunk_RetrievedContext extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.RetrievedContext';

  /// Additional context for the RAG retrieval result. This is only populated
  /// when using the RAG retrieval tool.
  final RagChunk? ragChunk;

  /// URI reference of the attribution.
  final String? uri;

  /// Title of the attribution.
  final String? title;

  /// Text of the attribution.
  final String? text;

  /// Output only. The full document name for the referenced Vertex AI Search
  /// document.
  final String? documentName;

  GroundingChunk_RetrievedContext({
    this.ragChunk,
    this.uri,
    this.title,
    this.text,
    this.documentName,
  }) : super(fullyQualifiedName);

  factory GroundingChunk_RetrievedContext.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundingChunk_RetrievedContext(
      ragChunk: switch (json['ragChunk']) {
        null => null,
        Object $1 => RagChunk.fromJson($1),
      },
      uri: switch (json['uri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => null,
        Object $1 => decodeString($1),
      },
      text: switch (json['text']) {
        null => null,
        Object $1 => decodeString($1),
      },
      documentName: switch (json['documentName']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragChunk != null) 'ragChunk': ragChunk!.toJson(),
    if (uri != null) 'uri': uri,
    if (title != null) 'title': title,
    if (text != null) 'text': text,
    if (documentName != null) 'documentName': documentName,
  };

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (title != null) 'title=$title',
      if (text != null) 'text=$text',
      if (documentName != null) 'documentName=$documentName',
    ].join(',');
    return 'RetrievedContext($contents)';
  }
}

/// Chunk from Google Maps.
final class GroundingChunk_Maps extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.Maps';

  /// URI reference of the chunk.
  final String? uri;

  /// Title of the chunk.
  final String? title;

  /// Text of the chunk.
  final String? text;

  /// This Place's resource name, in `places/{place_id}` format.  Can be used
  /// to look up the Place.
  final String? placeId;

  /// Sources used to generate the place answer.
  /// This includes review snippets and photos that were used to generate the
  /// answer, as well as uris to flag content.
  final GroundingChunk_Maps_PlaceAnswerSources? placeAnswerSources;

  GroundingChunk_Maps({
    this.uri,
    this.title,
    this.text,
    this.placeId,
    this.placeAnswerSources,
  }) : super(fullyQualifiedName);

  factory GroundingChunk_Maps.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundingChunk_Maps(
      uri: switch (json['uri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => null,
        Object $1 => decodeString($1),
      },
      text: switch (json['text']) {
        null => null,
        Object $1 => decodeString($1),
      },
      placeId: switch (json['placeId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      placeAnswerSources: switch (json['placeAnswerSources']) {
        null => null,
        Object $1 => GroundingChunk_Maps_PlaceAnswerSources.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (uri != null) 'uri': uri,
    if (title != null) 'title': title,
    if (text != null) 'text': text,
    if (placeId != null) 'placeId': placeId,
    if (placeAnswerSources != null)
      'placeAnswerSources': placeAnswerSources!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (title != null) 'title=$title',
      if (text != null) 'text=$text',
      if (placeId != null) 'placeId=$placeId',
    ].join(',');
    return 'Maps($contents)';
  }
}

final class GroundingChunk_Maps_PlaceAnswerSources extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.Maps.PlaceAnswerSources';

  /// Snippets of reviews that are used to generate the answer.
  final List<GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet>
  reviewSnippets;

  GroundingChunk_Maps_PlaceAnswerSources({this.reviewSnippets = const []})
    : super(fullyQualifiedName);

  factory GroundingChunk_Maps_PlaceAnswerSources.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundingChunk_Maps_PlaceAnswerSources(
      reviewSnippets: switch (json['reviewSnippets']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet.fromJson(i),
        ],
        _ => throw const FormatException('"reviewSnippets" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (reviewSnippets.isNotDefault)
      'reviewSnippets': encodeList(reviewSnippets),
  };

  @override
  String toString() => 'PlaceAnswerSources()';
}

/// Encapsulates a review snippet.
final class GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.Maps.PlaceAnswerSources.ReviewSnippet';

  /// Id of the review referencing the place.
  final String reviewId;

  /// A link to show the review on Google Maps.
  final String googleMapsUri;

  /// Title of the review.
  final String title;

  GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet({
    this.reviewId = '',
    this.googleMapsUri = '',
    this.title = '',
  }) : super(fullyQualifiedName);

  factory GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet(
      reviewId: switch (json['reviewId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      googleMapsUri: switch (json['googleMapsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (reviewId.isNotDefault) 'reviewId': reviewId,
    if (googleMapsUri.isNotDefault) 'googleMapsUri': googleMapsUri,
    if (title.isNotDefault) 'title': title,
  };

  @override
  String toString() {
    final contents = [
      'reviewId=$reviewId',
      'googleMapsUri=$googleMapsUri',
      'title=$title',
    ].join(',');
    return 'ReviewSnippet($contents)';
  }
}

/// Grounding support.
final class GroundingSupport extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingSupport';

  /// Segment of the content this support belongs to.
  final Segment? segment;

  /// A list of indices (into 'grounding_chunk') specifying the
  /// citations associated with the claim. For instance [1,3,4] means
  /// that grounding_chunk[1], grounding_chunk[3],
  /// grounding_chunk[4] are the retrieved content attributed to the claim.
  final List<int> groundingChunkIndices;

  /// Confidence score of the support references. Ranges from 0 to 1. 1 is the
  /// most confident. This list must have the same size as the
  /// grounding_chunk_indices.
  final List<double> confidenceScores;

  GroundingSupport({
    this.segment,
    this.groundingChunkIndices = const [],
    this.confidenceScores = const [],
  }) : super(fullyQualifiedName);

  factory GroundingSupport.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundingSupport(
      segment: switch (json['segment']) {
        null => null,
        Object $1 => Segment.fromJson($1),
      },
      groundingChunkIndices: switch (json['groundingChunkIndices']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt(i)],
        _ => throw const FormatException(
          '"groundingChunkIndices" is not a list',
        ),
      },
      confidenceScores: switch (json['confidenceScores']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"confidenceScores" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (segment != null) 'segment': segment!.toJson(),
    if (groundingChunkIndices.isNotDefault)
      'groundingChunkIndices': groundingChunkIndices,
    if (confidenceScores.isNotDefault) 'confidenceScores': confidenceScores,
  };

  @override
  String toString() => 'GroundingSupport()';
}

/// Metadata returned to client when grounding is enabled.
final class GroundingMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingMetadata';

  /// Optional. Web search queries for the following-up web search.
  final List<String> webSearchQueries;

  /// Optional. Google search entry for the following-up web searches.
  final SearchEntryPoint? searchEntryPoint;

  /// Optional. Queries executed by the retrieval tools.
  final List<String> retrievalQueries;

  /// List of supporting references retrieved from specified grounding source.
  final List<GroundingChunk> groundingChunks;

  /// Optional. List of grounding support.
  final List<GroundingSupport> groundingSupports;

  /// Optional. Output only. Retrieval metadata.
  final RetrievalMetadata? retrievalMetadata;

  /// Optional. Output only. Resource name of the Google Maps widget context
  /// token to be used with the PlacesContextElement widget to render contextual
  /// data. This is populated only for Google Maps grounding.
  final String? googleMapsWidgetContextToken;

  /// List of source flagging uris. This is currently populated only for Google
  /// Maps grounding.
  final List<GroundingMetadata_SourceFlaggingUri> sourceFlaggingUris;

  GroundingMetadata({
    this.webSearchQueries = const [],
    this.searchEntryPoint,
    this.retrievalQueries = const [],
    this.groundingChunks = const [],
    this.groundingSupports = const [],
    this.retrievalMetadata,
    this.googleMapsWidgetContextToken,
    this.sourceFlaggingUris = const [],
  }) : super(fullyQualifiedName);

  factory GroundingMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundingMetadata(
      webSearchQueries: switch (json['webSearchQueries']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"webSearchQueries" is not a list'),
      },
      searchEntryPoint: switch (json['searchEntryPoint']) {
        null => null,
        Object $1 => SearchEntryPoint.fromJson($1),
      },
      retrievalQueries: switch (json['retrievalQueries']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"retrievalQueries" is not a list'),
      },
      groundingChunks: switch (json['groundingChunks']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) GroundingChunk.fromJson(i)],
        _ => throw const FormatException('"groundingChunks" is not a list'),
      },
      groundingSupports: switch (json['groundingSupports']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) GroundingSupport.fromJson(i)],
        _ => throw const FormatException('"groundingSupports" is not a list'),
      },
      retrievalMetadata: switch (json['retrievalMetadata']) {
        null => null,
        Object $1 => RetrievalMetadata.fromJson($1),
      },
      googleMapsWidgetContextToken:
          switch (json['googleMapsWidgetContextToken']) {
            null => null,
            Object $1 => decodeString($1),
          },
      sourceFlaggingUris: switch (json['sourceFlaggingUris']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) GroundingMetadata_SourceFlaggingUri.fromJson(i),
        ],
        _ => throw const FormatException('"sourceFlaggingUris" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (webSearchQueries.isNotDefault) 'webSearchQueries': webSearchQueries,
    if (searchEntryPoint != null)
      'searchEntryPoint': searchEntryPoint!.toJson(),
    if (retrievalQueries.isNotDefault) 'retrievalQueries': retrievalQueries,
    if (groundingChunks.isNotDefault)
      'groundingChunks': encodeList(groundingChunks),
    if (groundingSupports.isNotDefault)
      'groundingSupports': encodeList(groundingSupports),
    if (retrievalMetadata != null)
      'retrievalMetadata': retrievalMetadata!.toJson(),
    if (googleMapsWidgetContextToken != null)
      'googleMapsWidgetContextToken': googleMapsWidgetContextToken,
    if (sourceFlaggingUris.isNotDefault)
      'sourceFlaggingUris': encodeList(sourceFlaggingUris),
  };

  @override
  String toString() {
    final contents = [
      if (googleMapsWidgetContextToken != null)
        'googleMapsWidgetContextToken=$googleMapsWidgetContextToken',
    ].join(',');
    return 'GroundingMetadata($contents)';
  }
}

/// Source content flagging uri for a place or review. This is currently
/// populated only for Google Maps grounding.
final class GroundingMetadata_SourceFlaggingUri extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingMetadata.SourceFlaggingUri';

  /// Id of the place or review.
  final String sourceId;

  /// A link where users can flag a problem with the source (place or review).
  /// (-- The link is generated by Google and it does not contain
  /// information from the user query. It may contain information of the
  /// content it is flagging, which can be used to identify places. --)
  final String flagContentUri;

  GroundingMetadata_SourceFlaggingUri({
    this.sourceId = '',
    this.flagContentUri = '',
  }) : super(fullyQualifiedName);

  factory GroundingMetadata_SourceFlaggingUri.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundingMetadata_SourceFlaggingUri(
      sourceId: switch (json['sourceId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      flagContentUri: switch (json['flagContentUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sourceId.isNotDefault) 'sourceId': sourceId,
    if (flagContentUri.isNotDefault) 'flagContentUri': flagContentUri,
  };

  @override
  String toString() {
    final contents = [
      'sourceId=$sourceId',
      'flagContentUri=$flagContentUri',
    ].join(',');
    return 'SourceFlaggingUri($contents)';
  }
}

/// Google search entry point.
final class SearchEntryPoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchEntryPoint';

  /// Optional. Web content snippet that can be embedded in a web page or an app
  /// webview.
  final String renderedContent;

  /// Optional. Base64 encoded JSON representing array of <search term, search
  /// url> tuple.
  final Uint8List sdkBlob;

  SearchEntryPoint({this.renderedContent = '', Uint8List? sdkBlob})
    : sdkBlob = sdkBlob ?? Uint8List(0),
      super(fullyQualifiedName);

  factory SearchEntryPoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchEntryPoint(
      renderedContent: switch (json['renderedContent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sdkBlob: switch (json['sdkBlob']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (renderedContent.isNotDefault) 'renderedContent': renderedContent,
    if (sdkBlob.isNotDefault) 'sdkBlob': encodeBytes(sdkBlob),
  };

  @override
  String toString() {
    final contents = [
      'renderedContent=$renderedContent',
      'sdkBlob=$sdkBlob',
    ].join(',');
    return 'SearchEntryPoint($contents)';
  }
}

/// Metadata related to retrieval in the grounding flow.
final class RetrievalMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrievalMetadata';

  /// Optional. Score indicating how likely information from Google Search could
  /// help answer the prompt. The score is in the range `[0, 1]`, where 0 is the
  /// least likely and 1 is the most likely. This score is only populated when
  /// Google Search grounding and dynamic retrieval is enabled. It will be
  /// compared to the threshold to determine whether to trigger Google Search.
  final double googleSearchDynamicRetrievalScore;

  RetrievalMetadata({this.googleSearchDynamicRetrievalScore = 0})
    : super(fullyQualifiedName);

  factory RetrievalMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrievalMetadata(
      googleSearchDynamicRetrievalScore:
          switch (json['googleSearchDynamicRetrievalScore']) {
            null => 0,
            Object $1 => decodeDouble($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (googleSearchDynamicRetrievalScore.isNotDefault)
      'googleSearchDynamicRetrievalScore': encodeDouble(
        googleSearchDynamicRetrievalScore,
      ),
  };

  @override
  String toString() {
    final contents = [
      'googleSearchDynamicRetrievalScore=$googleSearchDynamicRetrievalScore',
    ].join(',');
    return 'RetrievalMetadata($contents)';
  }
}

/// Configuration for Model Armor integrations of prompt and responses.
final class ModelArmorConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelArmorConfig';

  /// Optional. The name of the Model Armor template to use for prompt
  /// sanitization.
  final String promptTemplateName;

  /// Optional. The name of the Model Armor template to use for response
  /// sanitization.
  final String responseTemplateName;

  ModelArmorConfig({
    this.promptTemplateName = '',
    this.responseTemplateName = '',
  }) : super(fullyQualifiedName);

  factory ModelArmorConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelArmorConfig(
      promptTemplateName: switch (json['promptTemplateName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      responseTemplateName: switch (json['responseTemplateName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (promptTemplateName.isNotDefault)
      'promptTemplateName': promptTemplateName,
    if (responseTemplateName.isNotDefault)
      'responseTemplateName': responseTemplateName,
  };

  @override
  String toString() {
    final contents = [
      'promptTemplateName=$promptTemplateName',
      'responseTemplateName=$responseTemplateName',
    ].join(',');
    return 'ModelArmorConfig($contents)';
  }
}

/// Represents token counting info for a single modality.
final class ModalityTokenCount extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModalityTokenCount';

  /// The modality associated with this token count.
  final Modality modality;

  /// Number of tokens.
  final int tokenCount;

  ModalityTokenCount({this.modality = Modality.$default, this.tokenCount = 0})
    : super(fullyQualifiedName);

  factory ModalityTokenCount.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModalityTokenCount(
      modality: switch (json['modality']) {
        null => Modality.$default,
        Object $1 => Modality.fromJson($1),
      },
      tokenCount: switch (json['tokenCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modality.isNotDefault) 'modality': modality.toJson(),
    if (tokenCount.isNotDefault) 'tokenCount': tokenCount,
  };

  @override
  String toString() {
    final contents = ['modality=$modality', 'tokenCount=$tokenCount'].join(',');
    return 'ModalityTokenCount($contents)';
  }
}

/// Instance of a general context.
final class Context extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Context';

  /// Immutable. The resource name of the Context.
  final String name;

  /// User provided display name of the Context.
  /// May be up to 128 Unicode characters.
  final String displayName;

  /// An eTag used to perform consistent read-modify-write updates. If not set, a
  /// blind "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize your Contexts.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Context (System
  /// labels are excluded).
  final Map<String, String> labels;

  /// Output only. Timestamp when this Context was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Context was last updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. A list of resource names of Contexts that are parents of this
  /// Context. A Context may have at most 10 parent_contexts.
  final List<String> parentContexts;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String schemaVersion;

  /// Properties of the Context.
  /// Top level metadata keys' heading and trailing spaces will be trimmed.
  /// The size of this field should not exceed 200KB.
  final protobuf.Struct? metadata;

  /// Description of the Context
  final String description;

  Context({
    this.name = '',
    this.displayName = '',
    this.etag = '',
    this.labels = const {},
    this.createTime,
    this.updateTime,
    this.parentContexts = const [],
    this.schemaTitle = '',
    this.schemaVersion = '',
    this.metadata,
    this.description = '',
  }) : super(fullyQualifiedName);

  factory Context.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Context(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      parentContexts: switch (json['parentContexts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"parentContexts" is not a list'),
      },
      schemaTitle: switch (json['schemaTitle']) {
        null => '',
        Object $1 => decodeString($1),
      },
      schemaVersion: switch (json['schemaVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (parentContexts.isNotDefault) 'parentContexts': parentContexts,
    if (schemaTitle.isNotDefault) 'schemaTitle': schemaTitle,
    if (schemaVersion.isNotDefault) 'schemaVersion': schemaVersion,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'etag=$etag',
      'schemaTitle=$schemaTitle',
      'schemaVersion=$schemaVersion',
      'description=$description',
    ].join(',');
    return 'Context($contents)';
  }
}

/// Represents a job that runs custom workloads such as a Docker container or a
/// Python package. A CustomJob can have multiple worker pools and each worker
/// pool can have its own machine and input spec. A CustomJob will be cleaned up
/// once the job enters terminal state (failed or succeeded).
final class CustomJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CustomJob';

  /// Output only. Resource name of a CustomJob.
  final String name;

  /// Required. The display name of the CustomJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Required. Job spec.
  final CustomJobSpec? jobSpec;

  /// Output only. The detailed state of the job.
  final JobState state;

  /// Output only. Time when the CustomJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the CustomJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the CustomJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the CustomJob was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  final Status? error;

  /// The labels with user-defined metadata to organize CustomJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Customer-managed encryption key options for a CustomJob. If this is set,
  /// then all resources created by the CustomJob will be encrypted with the
  /// provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. URIs for accessing [interactive
  /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node). Only available if
  /// `job_spec.enable_web_access`
  /// is `true`.
  ///
  /// The keys are names of each node in the training job; for example,
  /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
  /// the second worker pool, and `workerpool1-1` for the second node in the
  /// second worker pool.
  ///
  /// The values are the URIs for each node's interactive shell.
  final Map<String, String> webAccessUris;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  CustomJob({
    this.name = '',
    required this.displayName,
    required this.jobSpec,
    this.state = JobState.$default,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.error,
    this.labels = const {},
    this.encryptionSpec,
    this.webAccessUris = const {},
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory CustomJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CustomJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      jobSpec: switch (json['jobSpec']) {
        null => null,
        Object $1 => CustomJobSpec.fromJson($1),
      },
      state: switch (json['state']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      webAccessUris: switch (json['webAccessUris']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"webAccessUris" is not an object'),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (jobSpec != null) 'jobSpec': jobSpec!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (webAccessUris.isNotDefault) 'webAccessUris': webAccessUris,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'state=$state',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'CustomJob($contents)';
  }
}

/// Represents the spec of a CustomJob.
final class CustomJobSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CustomJobSpec';

  /// Optional. The ID of the PersistentResource in the same Project and Location
  /// which to run
  ///
  /// If this is specified, the job will be run on existing machines held by the
  /// PersistentResource instead of on-demand short-live machines.
  /// The network and CMEK configs on the job should be consistent with those on
  /// the PersistentResource, otherwise, the job will be rejected.
  final String persistentResourceId;

  /// Required. The spec of the worker pools including machine type and Docker
  /// image. All worker pools except the first one are optional and can be
  /// skipped by providing an empty value.
  final List<WorkerPoolSpec> workerPoolSpecs;

  /// Scheduling options for a CustomJob.
  final Scheduling? scheduling;

  /// Specifies the service account for workload run-as account.
  /// Users submitting jobs must have act-as permission on this run-as account.
  /// If unspecified, the [Vertex AI Custom Code Service
  /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// for the CustomJob's project is used.
  final String serviceAccount;

  /// Optional. The full name of the Compute Engine
  /// [network](/compute/docs/networks-and-firewalls#networks) to which the Job
  /// should be peered. For example, `projects/12345/global/networks/myVPC`.
  /// [Format](/compute/docs/reference/rest/v1/networks/insert)
  /// is of the form `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in `12345`, and {network} is a
  /// network name.
  ///
  /// To specify this field, you must have already [configured VPC Network
  /// Peering for Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  ///
  /// If this field is left unspecified, the job is not peered with any network.
  final String network;

  /// Optional. A list of names for the reserved ip ranges under the VPC network
  /// that can be used for this job.
  ///
  /// If set, we will deploy the job within the provided ip ranges. Otherwise,
  /// the job will be deployed to any ip ranges under the provided VPC
  /// network.
  ///
  /// Example: ['vertex-ai-ip-range'].
  final List<String> reservedIpRanges;

  /// Optional. Configuration for PSC-I for CustomJob.
  final PscInterfaceConfig? pscInterfaceConfig;

  /// The Cloud Storage location to store the output of this CustomJob or
  /// HyperparameterTuningJob. For HyperparameterTuningJob,
  /// the baseOutputDirectory of
  /// each child CustomJob backing a Trial is set to a subdirectory of name
  /// `id` under its parent
  /// HyperparameterTuningJob's baseOutputDirectory.
  ///
  /// The following Vertex AI environment variables will be passed to
  /// containers or python modules when this field is set:
  ///
  ///   For CustomJob:
  ///
  ///   * AIP_MODEL_DIR = `<base_output_directory>/model/`
  ///   * AIP_CHECKPOINT_DIR = `<base_output_directory>/checkpoints/`
  ///   * AIP_TENSORBOARD_LOG_DIR = `<base_output_directory>/logs/`
  ///
  ///   For CustomJob backing a Trial of HyperparameterTuningJob:
  ///
  ///   * AIP_MODEL_DIR = `<base_output_directory>/<trial_id>/model/`
  ///   * AIP_CHECKPOINT_DIR = `<base_output_directory>/<trial_id>/checkpoints/`
  ///   * AIP_TENSORBOARD_LOG_DIR = `<base_output_directory>/<trial_id>/logs/`
  final GcsDestination? baseOutputDirectory;

  /// The ID of the location to store protected artifacts. e.g. us-central1.
  /// Populate only when the location is different than CustomJob location.
  /// List of supported locations:
  /// https://cloud.google.com/vertex-ai/docs/general/locations
  final String protectedArtifactLocationId;

  /// Optional. The name of a Vertex AI
  /// `Tensorboard` resource to
  /// which this CustomJob will upload Tensorboard logs. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String tensorboard;

  /// Optional. Whether you want Vertex AI to enable [interactive shell
  /// access](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// to training containers.
  ///
  /// If set to `true`, you can access interactive shells at the URIs given
  /// by
  /// `CustomJob.web_access_uris`
  /// or
  /// `Trial.web_access_uris`
  /// (within
  /// `HyperparameterTuningJob.trials`).
  final bool enableWebAccess;

  /// Optional. Whether you want Vertex AI to enable access to the customized
  /// dashboard in training chief container.
  ///
  /// If set to `true`, you can access the dashboard at the URIs given
  /// by
  /// `CustomJob.web_access_uris`
  /// or
  /// `Trial.web_access_uris`
  /// (within
  /// `HyperparameterTuningJob.trials`).
  final bool enableDashboardAccess;

  /// Optional. The Experiment associated with this job.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}`
  final String experiment;

  /// Optional. The Experiment Run associated with this job.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}-{experiment-run-name}`
  final String experimentRun;

  /// Optional. The name of the Model resources for which to generate a mapping
  /// to artifact URIs. Applicable only to some of the Google-provided custom
  /// jobs. Format: `projects/{project}/locations/{location}/models/{model}`
  ///
  /// In order to retrieve a specific version of the model, also provide
  /// the version ID or version alias.
  ///   Example: `projects/{project}/locations/{location}/models/{model}@2`
  ///              or
  ///            `projects/{project}/locations/{location}/models/{model}@golden`
  /// If no version ID or alias is specified, the "default" version will be
  /// returned. The "default" version alias is created for the first version of
  /// the model, and can be moved to other versions later on. There will be
  /// exactly one default version.
  final List<String> models;

  CustomJobSpec({
    this.persistentResourceId = '',
    required this.workerPoolSpecs,
    this.scheduling,
    this.serviceAccount = '',
    this.network = '',
    this.reservedIpRanges = const [],
    this.pscInterfaceConfig,
    this.baseOutputDirectory,
    this.protectedArtifactLocationId = '',
    this.tensorboard = '',
    this.enableWebAccess = false,
    this.enableDashboardAccess = false,
    this.experiment = '',
    this.experimentRun = '',
    this.models = const [],
  }) : super(fullyQualifiedName);

  factory CustomJobSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CustomJobSpec(
      persistentResourceId: switch (json['persistentResourceId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      workerPoolSpecs: switch (json['workerPoolSpecs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) WorkerPoolSpec.fromJson(i)],
        _ => throw const FormatException('"workerPoolSpecs" is not a list'),
      },
      scheduling: switch (json['scheduling']) {
        null => null,
        Object $1 => Scheduling.fromJson($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
      network: switch (json['network']) {
        null => '',
        Object $1 => decodeString($1),
      },
      reservedIpRanges: switch (json['reservedIpRanges']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"reservedIpRanges" is not a list'),
      },
      pscInterfaceConfig: switch (json['pscInterfaceConfig']) {
        null => null,
        Object $1 => PscInterfaceConfig.fromJson($1),
      },
      baseOutputDirectory: switch (json['baseOutputDirectory']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      protectedArtifactLocationId:
          switch (json['protectedArtifactLocationId']) {
            null => '',
            Object $1 => decodeString($1),
          },
      tensorboard: switch (json['tensorboard']) {
        null => '',
        Object $1 => decodeString($1),
      },
      enableWebAccess: switch (json['enableWebAccess']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      enableDashboardAccess: switch (json['enableDashboardAccess']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      experiment: switch (json['experiment']) {
        null => '',
        Object $1 => decodeString($1),
      },
      experimentRun: switch (json['experimentRun']) {
        null => '',
        Object $1 => decodeString($1),
      },
      models: switch (json['models']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"models" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (persistentResourceId.isNotDefault)
      'persistentResourceId': persistentResourceId,
    'workerPoolSpecs': encodeList(workerPoolSpecs),
    if (scheduling != null) 'scheduling': scheduling!.toJson(),
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
    if (network.isNotDefault) 'network': network,
    if (reservedIpRanges.isNotDefault) 'reservedIpRanges': reservedIpRanges,
    if (pscInterfaceConfig != null)
      'pscInterfaceConfig': pscInterfaceConfig!.toJson(),
    if (baseOutputDirectory != null)
      'baseOutputDirectory': baseOutputDirectory!.toJson(),
    if (protectedArtifactLocationId.isNotDefault)
      'protectedArtifactLocationId': protectedArtifactLocationId,
    if (tensorboard.isNotDefault) 'tensorboard': tensorboard,
    if (enableWebAccess.isNotDefault) 'enableWebAccess': enableWebAccess,
    if (enableDashboardAccess.isNotDefault)
      'enableDashboardAccess': enableDashboardAccess,
    if (experiment.isNotDefault) 'experiment': experiment,
    if (experimentRun.isNotDefault) 'experimentRun': experimentRun,
    if (models.isNotDefault) 'models': models,
  };

  @override
  String toString() {
    final contents = [
      'persistentResourceId=$persistentResourceId',
      'serviceAccount=$serviceAccount',
      'network=$network',
      'protectedArtifactLocationId=$protectedArtifactLocationId',
      'tensorboard=$tensorboard',
      'enableWebAccess=$enableWebAccess',
      'enableDashboardAccess=$enableDashboardAccess',
      'experiment=$experiment',
      'experimentRun=$experimentRun',
    ].join(',');
    return 'CustomJobSpec($contents)';
  }
}

/// Represents the spec of a worker pool in a job.
final class WorkerPoolSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WorkerPoolSpec';

  /// The custom container task.
  final ContainerSpec? containerSpec;

  /// The Python packaged task.
  final PythonPackageSpec? pythonPackageSpec;

  /// Optional. Immutable. The specification of a single machine.
  final MachineSpec? machineSpec;

  /// Optional. The number of worker replicas to use for this worker pool.
  final int replicaCount;

  /// Optional. List of NFS mount spec.
  final List<NfsMount> nfsMounts;

  /// Disk spec.
  final DiskSpec? diskSpec;

  WorkerPoolSpec({
    this.containerSpec,
    this.pythonPackageSpec,
    this.machineSpec,
    this.replicaCount = 0,
    this.nfsMounts = const [],
    this.diskSpec,
  }) : super(fullyQualifiedName);

  factory WorkerPoolSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return WorkerPoolSpec(
      containerSpec: switch (json['containerSpec']) {
        null => null,
        Object $1 => ContainerSpec.fromJson($1),
      },
      pythonPackageSpec: switch (json['pythonPackageSpec']) {
        null => null,
        Object $1 => PythonPackageSpec.fromJson($1),
      },
      machineSpec: switch (json['machineSpec']) {
        null => null,
        Object $1 => MachineSpec.fromJson($1),
      },
      replicaCount: switch (json['replicaCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      nfsMounts: switch (json['nfsMounts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) NfsMount.fromJson(i)],
        _ => throw const FormatException('"nfsMounts" is not a list'),
      },
      diskSpec: switch (json['diskSpec']) {
        null => null,
        Object $1 => DiskSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
    if (pythonPackageSpec != null)
      'pythonPackageSpec': pythonPackageSpec!.toJson(),
    if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
    if (replicaCount.isNotDefault) 'replicaCount': encodeInt64(replicaCount),
    if (nfsMounts.isNotDefault) 'nfsMounts': encodeList(nfsMounts),
    if (diskSpec != null) 'diskSpec': diskSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = ['replicaCount=$replicaCount'].join(',');
    return 'WorkerPoolSpec($contents)';
  }
}

/// The spec of a Container.
final class ContainerSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContainerSpec';

  /// Required. The URI of a container image in the Container Registry that is to
  /// be run on each worker replica.
  final String imageUri;

  /// The command to be invoked when the container is started.
  /// It overrides the entrypoint instruction in Dockerfile when provided.
  final List<String> command;

  /// The arguments to be passed when starting the container.
  final List<String> args;

  /// Environment variables to be passed to the container.
  /// Maximum limit is 100.
  final List<EnvVar> env;

  ContainerSpec({
    required this.imageUri,
    this.command = const [],
    this.args = const [],
    this.env = const [],
  }) : super(fullyQualifiedName);

  factory ContainerSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ContainerSpec(
      imageUri: switch (json['imageUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      command: switch (json['command']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"command" is not a list'),
      },
      args: switch (json['args']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"args" is not a list'),
      },
      env: switch (json['env']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) EnvVar.fromJson(i)],
        _ => throw const FormatException('"env" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'imageUri': imageUri,
    if (command.isNotDefault) 'command': command,
    if (args.isNotDefault) 'args': args,
    if (env.isNotDefault) 'env': encodeList(env),
  };

  @override
  String toString() {
    final contents = ['imageUri=$imageUri'].join(',');
    return 'ContainerSpec($contents)';
  }
}

/// The spec of a Python packaged code.
final class PythonPackageSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PythonPackageSpec';

  /// Required. The URI of a container image in Artifact Registry that will run
  /// the provided Python package. Vertex AI provides a wide range of executor
  /// images with pre-installed packages to meet users' various use cases. See
  /// the list of [pre-built containers for
  /// training](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  /// You must use an image from this list.
  final String executorImageUri;

  /// Required. The Google Cloud Storage location of the Python package files
  /// which are the training program and its dependent packages. The maximum
  /// number of package URIs is 100.
  final List<String> packageUris;

  /// Required. The Python module name to run after installing the packages.
  final String pythonModule;

  /// Command line arguments to be passed to the Python task.
  final List<String> args;

  /// Environment variables to be passed to the python module.
  /// Maximum limit is 100.
  final List<EnvVar> env;

  PythonPackageSpec({
    required this.executorImageUri,
    required this.packageUris,
    required this.pythonModule,
    this.args = const [],
    this.env = const [],
  }) : super(fullyQualifiedName);

  factory PythonPackageSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PythonPackageSpec(
      executorImageUri: switch (json['executorImageUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      packageUris: switch (json['packageUris']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"packageUris" is not a list'),
      },
      pythonModule: switch (json['pythonModule']) {
        null => '',
        Object $1 => decodeString($1),
      },
      args: switch (json['args']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"args" is not a list'),
      },
      env: switch (json['env']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) EnvVar.fromJson(i)],
        _ => throw const FormatException('"env" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'executorImageUri': executorImageUri,
    'packageUris': packageUris,
    'pythonModule': pythonModule,
    if (args.isNotDefault) 'args': args,
    if (env.isNotDefault) 'env': encodeList(env),
  };

  @override
  String toString() {
    final contents = [
      'executorImageUri=$executorImageUri',
      'pythonModule=$pythonModule',
    ].join(',');
    return 'PythonPackageSpec($contents)';
  }
}

/// All parameters related to queuing and scheduling of custom jobs.
final class Scheduling extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Scheduling';

  /// The maximum job running time. The default is 7 days.
  final protobuf.Duration? timeout;

  /// Restarts the entire CustomJob if a worker gets restarted.
  /// This feature can be used by distributed training jobs that are not
  /// resilient to workers leaving and joining a job.
  final bool restartJobOnWorkerRestart;

  /// Optional. This determines which type of scheduling strategy to use.
  final Scheduling_Strategy strategy;

  /// Optional. Indicates if the job should retry for internal errors after the
  /// job starts running. If true, overrides
  /// `Scheduling.restart_job_on_worker_restart` to false.
  final bool disableRetries;

  /// Optional. This is the maximum duration that a job will wait for the
  /// requested resources to be provisioned if the scheduling strategy is set to
  /// [Strategy.DWS_FLEX_START].
  /// If set to 0, the job will wait indefinitely. The default is 24 hours.
  final protobuf.Duration? maxWaitDuration;

  Scheduling({
    this.timeout,
    this.restartJobOnWorkerRestart = false,
    this.strategy = Scheduling_Strategy.$default,
    this.disableRetries = false,
    this.maxWaitDuration,
  }) : super(fullyQualifiedName);

  factory Scheduling.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Scheduling(
      timeout: switch (json['timeout']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      restartJobOnWorkerRestart: switch (json['restartJobOnWorkerRestart']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      strategy: switch (json['strategy']) {
        null => Scheduling_Strategy.$default,
        Object $1 => Scheduling_Strategy.fromJson($1),
      },
      disableRetries: switch (json['disableRetries']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      maxWaitDuration: switch (json['maxWaitDuration']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (timeout != null) 'timeout': timeout!.toJson(),
    if (restartJobOnWorkerRestart.isNotDefault)
      'restartJobOnWorkerRestart': restartJobOnWorkerRestart,
    if (strategy.isNotDefault) 'strategy': strategy.toJson(),
    if (disableRetries.isNotDefault) 'disableRetries': disableRetries,
    if (maxWaitDuration != null) 'maxWaitDuration': maxWaitDuration!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'restartJobOnWorkerRestart=$restartJobOnWorkerRestart',
      'strategy=$strategy',
      'disableRetries=$disableRetries',
    ].join(',');
    return 'Scheduling($contents)';
  }
}

/// Optional. This determines which type of scheduling strategy to use. Right
/// now users have two options such as STANDARD which will use regular on
/// demand resources to schedule the job, the other is SPOT which would
/// leverage spot resources alongwith regular resources to schedule
/// the job.
final class Scheduling_Strategy extends ProtoEnum {
  /// Strategy will default to STANDARD.
  static const strategyUnspecified = Scheduling_Strategy(
    'STRATEGY_UNSPECIFIED',
  );

  /// Deprecated. Regular on-demand provisioning strategy.
  static const onDemand = Scheduling_Strategy('ON_DEMAND');

  /// Deprecated. Low cost by making potential use of spot resources.
  static const lowCost = Scheduling_Strategy('LOW_COST');

  /// Standard provisioning strategy uses regular on-demand resources.
  static const standard = Scheduling_Strategy('STANDARD');

  /// Spot provisioning strategy uses spot resources.
  static const spot = Scheduling_Strategy('SPOT');

  /// Flex Start strategy uses DWS to queue for resources.
  static const flexStart = Scheduling_Strategy('FLEX_START');

  /// The default value for [Scheduling_Strategy].
  static const $default = strategyUnspecified;

  const Scheduling_Strategy(super.value);

  factory Scheduling_Strategy.fromJson(Object? json) =>
      Scheduling_Strategy(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Strategy.$value';
}

/// A piece of data in a Dataset. Could be an image, a video, a document or plain
/// text.
final class DataItem extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DataItem';

  /// Output only. The resource name of the DataItem.
  final String name;

  /// Output only. Timestamp when this DataItem was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this DataItem was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The labels with user-defined metadata to organize your DataItems.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one DataItem(System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> labels;

  /// Required. The data that the DataItem represents (for example, an image or a
  /// text snippet). The schema of the payload is stored in the parent Dataset's
  /// [metadata
  /// schema's][google.cloud.aiplatform.v1beta1.Dataset.metadata_schema_uri]
  /// dataItemSchemaUri field.
  final protobuf.Value? payload;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  DataItem({
    this.name = '',
    this.createTime,
    this.updateTime,
    this.labels = const {},
    required this.payload,
    this.etag = '',
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory DataItem.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DataItem(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      payload: switch (json['payload']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (payload != null) 'payload': payload!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'etag=$etag',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'DataItem($contents)';
  }
}

/// DataLabelingJob is used to trigger a human labeling job on unlabeled data
/// from the following Dataset:
final class DataLabelingJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DataLabelingJob';

  /// Output only. Resource name of the DataLabelingJob.
  final String name;

  /// Required. The user-defined name of the DataLabelingJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  /// Display name of a DataLabelingJob.
  final String displayName;

  /// Required. Dataset resource names. Right now we only support labeling from a
  /// single Dataset. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final List<String> datasets;

  /// Labels to assign to annotations generated by this DataLabelingJob.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> annotationLabels;

  /// Required. Number of labelers to work on each DataItem.
  final int labelerCount;

  /// Required. The Google Cloud Storage location of the instruction pdf. This
  /// pdf is shared with labelers, and provides detailed description on how to
  /// label DataItems in Datasets.
  final String instructionUri;

  /// Required. Points to a YAML file stored on Google Cloud Storage describing
  /// the config for a specific type of DataLabelingJob. The schema files that
  /// can be used here are found in the
  /// https://storage.googleapis.com/google-cloud-aiplatform bucket in the
  /// /schema/datalabelingjob/inputs/ folder.
  final String inputsSchemaUri;

  /// Required. Input config parameters for the DataLabelingJob.
  final protobuf.Value? inputs;

  /// Output only. The detailed state of the job.
  final JobState state;

  /// Output only. Current labeling job progress percentage scaled in interval
  /// [0, 100], indicating the percentage of DataItems that has been finished.
  final int labelingProgress;

  /// Output only. Estimated cost(in US dollars) that the DataLabelingJob has
  /// incurred to date.
  final Money? currentSpend;

  /// Output only. Timestamp when this DataLabelingJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this DataLabelingJob was updated most recently.
  final protobuf.Timestamp? updateTime;

  /// Output only. DataLabelingJob errors. It is only populated when job's state
  /// is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
  final Status? error;

  /// The labels with user-defined metadata to organize your DataLabelingJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable. Following system labels exist for each DataLabelingJob:
  ///
  /// * "aiplatform.googleapis.com/schema": output only, its value is the
  ///   `inputs_schema`'s
  ///   title.
  final Map<String, String> labels;

  /// The SpecialistPools' resource names associated with this job.
  final List<String> specialistPools;

  /// Customer-managed encryption key spec for a DataLabelingJob. If set, this
  /// DataLabelingJob will be secured by this key.
  ///
  /// Note: Annotations created in the DataLabelingJob are associated with
  /// the EncryptionSpec of the Dataset they are exported to.
  final EncryptionSpec? encryptionSpec;

  /// Parameters that configure the active learning pipeline. Active learning
  /// will label the data incrementally via several iterations. For every
  /// iteration, it will select a batch of data based on the sampling strategy.
  final ActiveLearningConfig? activeLearningConfig;

  DataLabelingJob({
    this.name = '',
    required this.displayName,
    required this.datasets,
    this.annotationLabels = const {},
    required this.labelerCount,
    required this.instructionUri,
    required this.inputsSchemaUri,
    required this.inputs,
    this.state = JobState.$default,
    this.labelingProgress = 0,
    this.currentSpend,
    this.createTime,
    this.updateTime,
    this.error,
    this.labels = const {},
    this.specialistPools = const [],
    this.encryptionSpec,
    this.activeLearningConfig,
  }) : super(fullyQualifiedName);

  factory DataLabelingJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DataLabelingJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datasets: switch (json['datasets']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"datasets" is not a list'),
      },
      annotationLabels: switch (json['annotationLabels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"annotationLabels" is not an object'),
      },
      labelerCount: switch (json['labelerCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      instructionUri: switch (json['instructionUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      inputsSchemaUri: switch (json['inputsSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      inputs: switch (json['inputs']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      state: switch (json['state']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      labelingProgress: switch (json['labelingProgress']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      currentSpend: switch (json['currentSpend']) {
        null => null,
        Object $1 => Money.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      specialistPools: switch (json['specialistPools']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"specialistPools" is not a list'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      activeLearningConfig: switch (json['activeLearningConfig']) {
        null => null,
        Object $1 => ActiveLearningConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    'datasets': datasets,
    if (annotationLabels.isNotDefault) 'annotationLabels': annotationLabels,
    'labelerCount': labelerCount,
    'instructionUri': instructionUri,
    'inputsSchemaUri': inputsSchemaUri,
    if (inputs != null) 'inputs': inputs!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (labelingProgress.isNotDefault) 'labelingProgress': labelingProgress,
    if (currentSpend != null) 'currentSpend': currentSpend!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (specialistPools.isNotDefault) 'specialistPools': specialistPools,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (activeLearningConfig != null)
      'activeLearningConfig': activeLearningConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'labelerCount=$labelerCount',
      'instructionUri=$instructionUri',
      'inputsSchemaUri=$inputsSchemaUri',
      'state=$state',
      'labelingProgress=$labelingProgress',
    ].join(',');
    return 'DataLabelingJob($contents)';
  }
}

/// Parameters that configure the active learning pipeline. Active learning will
///  label the data incrementally by several iterations. For every iteration, it
///  will select a batch of data based on the sampling strategy.
final class ActiveLearningConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ActiveLearningConfig';

  /// Max number of human labeled DataItems.
  final int? maxDataItemCount;

  /// Max percent of total DataItems for human labeling.
  final int? maxDataItemPercentage;

  /// Active learning data sampling config. For every active learning labeling
  /// iteration, it will select a batch of data based on the sampling strategy.
  final SampleConfig? sampleConfig;

  /// CMLE training config. For every active learning labeling iteration, system
  /// will train a machine learning model on CMLE. The trained model will be used
  /// by data sampling algorithm to select DataItems.
  final TrainingConfig? trainingConfig;

  ActiveLearningConfig({
    this.maxDataItemCount,
    this.maxDataItemPercentage,
    this.sampleConfig,
    this.trainingConfig,
  }) : super(fullyQualifiedName);

  factory ActiveLearningConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ActiveLearningConfig(
      maxDataItemCount: switch (json['maxDataItemCount']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      maxDataItemPercentage: switch (json['maxDataItemPercentage']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      sampleConfig: switch (json['sampleConfig']) {
        null => null,
        Object $1 => SampleConfig.fromJson($1),
      },
      trainingConfig: switch (json['trainingConfig']) {
        null => null,
        Object $1 => TrainingConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxDataItemCount != null)
      'maxDataItemCount': encodeInt64(maxDataItemCount),
    if (maxDataItemPercentage != null)
      'maxDataItemPercentage': maxDataItemPercentage,
    if (sampleConfig != null) 'sampleConfig': sampleConfig!.toJson(),
    if (trainingConfig != null) 'trainingConfig': trainingConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (maxDataItemCount != null) 'maxDataItemCount=$maxDataItemCount',
      if (maxDataItemPercentage != null)
        'maxDataItemPercentage=$maxDataItemPercentage',
    ].join(',');
    return 'ActiveLearningConfig($contents)';
  }
}

/// Active learning data sampling config. For every active learning labeling
/// iteration, it will select a batch of data based on the sampling strategy.
final class SampleConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SampleConfig';

  /// The percentage of data needed to be labeled in the first batch.
  final int? initialBatchSamplePercentage;

  /// The percentage of data needed to be labeled in each following batch
  /// (except the first batch).
  final int? followingBatchSamplePercentage;

  /// Field to choose sampling strategy. Sampling strategy will decide which data
  /// should be selected for human labeling in every batch.
  final SampleConfig_SampleStrategy sampleStrategy;

  SampleConfig({
    this.initialBatchSamplePercentage,
    this.followingBatchSamplePercentage,
    this.sampleStrategy = SampleConfig_SampleStrategy.$default,
  }) : super(fullyQualifiedName);

  factory SampleConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SampleConfig(
      initialBatchSamplePercentage:
          switch (json['initialBatchSamplePercentage']) {
            null => null,
            Object $1 => decodeInt($1),
          },
      followingBatchSamplePercentage:
          switch (json['followingBatchSamplePercentage']) {
            null => null,
            Object $1 => decodeInt($1),
          },
      sampleStrategy: switch (json['sampleStrategy']) {
        null => SampleConfig_SampleStrategy.$default,
        Object $1 => SampleConfig_SampleStrategy.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (initialBatchSamplePercentage != null)
      'initialBatchSamplePercentage': initialBatchSamplePercentage,
    if (followingBatchSamplePercentage != null)
      'followingBatchSamplePercentage': followingBatchSamplePercentage,
    if (sampleStrategy.isNotDefault) 'sampleStrategy': sampleStrategy.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (initialBatchSamplePercentage != null)
        'initialBatchSamplePercentage=$initialBatchSamplePercentage',
      if (followingBatchSamplePercentage != null)
        'followingBatchSamplePercentage=$followingBatchSamplePercentage',
      'sampleStrategy=$sampleStrategy',
    ].join(',');
    return 'SampleConfig($contents)';
  }
}

/// Sample strategy decides which subset of DataItems should be selected for
/// human labeling in every batch.
final class SampleConfig_SampleStrategy extends ProtoEnum {
  /// Default will be treated as UNCERTAINTY.
  static const sampleStrategyUnspecified = SampleConfig_SampleStrategy(
    'SAMPLE_STRATEGY_UNSPECIFIED',
  );

  /// Sample the most uncertain data to label.
  static const uncertainty = SampleConfig_SampleStrategy('UNCERTAINTY');

  /// The default value for [SampleConfig_SampleStrategy].
  static const $default = sampleStrategyUnspecified;

  const SampleConfig_SampleStrategy(super.value);

  factory SampleConfig_SampleStrategy.fromJson(Object? json) =>
      SampleConfig_SampleStrategy(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'SampleStrategy.$value';
}

/// CMLE training config. For every active learning labeling iteration, system
/// will train a machine learning model on CMLE. The trained model will be used
/// by data sampling algorithm to select DataItems.
final class TrainingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrainingConfig';

  /// The timeout hours for the CMLE training job, expressed in milli hours
  /// i.e. 1,000 value in this field means 1 hour.
  final int timeoutTrainingMilliHours;

  TrainingConfig({this.timeoutTrainingMilliHours = 0})
    : super(fullyQualifiedName);

  factory TrainingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrainingConfig(
      timeoutTrainingMilliHours: switch (json['timeoutTrainingMilliHours']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (timeoutTrainingMilliHours.isNotDefault)
      'timeoutTrainingMilliHours': encodeInt64(timeoutTrainingMilliHours),
  };

  @override
  String toString() {
    final contents = [
      'timeoutTrainingMilliHours=$timeoutTrainingMilliHours',
    ].join(',');
    return 'TrainingConfig($contents)';
  }
}

/// A collection of DataItems and Annotations on them.
final class Dataset extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Dataset';

  /// Output only. Identifier. The resource name of the Dataset.
  final String name;

  /// Required. The user-defined name of the Dataset.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// The description of the Dataset.
  final String description;

  /// Required. Points to a YAML file stored on Google Cloud Storage describing
  /// additional information about the Dataset. The schema is defined as an
  /// OpenAPI 3.0.2 Schema Object. The schema files that can be used here are
  /// found in gs://google-cloud-aiplatform/schema/dataset/metadata/.
  final String metadataSchemaUri;

  /// Required. Additional information about the Dataset.
  final protobuf.Value? metadata;

  /// Output only. The number of DataItems in this Dataset. Only apply for
  /// non-structured Dataset.
  final int dataItemCount;

  /// Output only. Timestamp when this Dataset was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Dataset was last updated.
  final protobuf.Timestamp? updateTime;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize your Datasets.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Dataset (System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable. Following system labels exist for each Dataset:
  ///
  /// * "aiplatform.googleapis.com/dataset_metadata_schema": output only, its
  ///   value is the
  ///   [metadata_schema's][google.cloud.aiplatform.v1beta1.Dataset.metadata_schema_uri]
  ///   title.
  final Map<String, String> labels;

  /// All SavedQueries belong to the Dataset will be returned in List/Get
  /// Dataset response. The annotation_specs field
  /// will not be populated except for UI cases which will only use
  /// `annotation_spec_count`.
  /// In CreateDataset request, a SavedQuery is created together if
  /// this field is set, up to one SavedQuery can be set in CreateDatasetRequest.
  /// The SavedQuery should not contain any AnnotationSpec.
  final List<SavedQuery> savedQueries;

  /// Customer-managed encryption key spec for a Dataset. If set, this Dataset
  /// and all sub-resources of this Dataset will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. The resource name of the Artifact that was created in
  /// MetadataStore when creating the Dataset. The Artifact resource name pattern
  /// is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  final String metadataArtifact;

  /// Optional. Reference to the public base model last used by the dataset. Only
  /// set for prompt datasets.
  final String modelReference;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  Dataset({
    this.name = '',
    required this.displayName,
    this.description = '',
    required this.metadataSchemaUri,
    required this.metadata,
    this.dataItemCount = 0,
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.labels = const {},
    this.savedQueries = const [],
    this.encryptionSpec,
    this.metadataArtifact = '',
    this.modelReference = '',
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory Dataset.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Dataset(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadataSchemaUri: switch (json['metadataSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      dataItemCount: switch (json['dataItemCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      savedQueries: switch (json['savedQueries']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SavedQuery.fromJson(i)],
        _ => throw const FormatException('"savedQueries" is not a list'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      metadataArtifact: switch (json['metadataArtifact']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelReference: switch (json['modelReference']) {
        null => '',
        Object $1 => decodeString($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    'metadataSchemaUri': metadataSchemaUri,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (dataItemCount.isNotDefault) 'dataItemCount': encodeInt64(dataItemCount),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (savedQueries.isNotDefault) 'savedQueries': encodeList(savedQueries),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (metadataArtifact.isNotDefault) 'metadataArtifact': metadataArtifact,
    if (modelReference.isNotDefault) 'modelReference': modelReference,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'metadataSchemaUri=$metadataSchemaUri',
      'dataItemCount=$dataItemCount',
      'etag=$etag',
      'metadataArtifact=$metadataArtifact',
      'modelReference=$modelReference',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Dataset($contents)';
  }
}

/// Describes the location from where we import data into a Dataset, together
/// with the labels that will be applied to the DataItems and the Annotations.
final class ImportDataConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportDataConfig';

  /// The Google Cloud Storage location for the input content.
  final GcsSource? gcsSource;

  /// Labels that will be applied to newly imported DataItems. If an identical
  /// DataItem as one being imported already exists in the Dataset, then these
  /// labels will be appended to these of the already existing one, and if labels
  /// with identical key is imported before, the old label value will be
  /// overwritten. If two DataItems are identical in the same import data
  /// operation, the labels will be combined and if key collision happens in this
  /// case, one of the values will be picked randomly. Two DataItems are
  /// considered identical if their content bytes are identical (e.g. image bytes
  /// or pdf bytes).
  /// These labels will be overridden by Annotation labels specified inside index
  /// file referenced by
  /// `import_schema_uri`,
  /// e.g. jsonl file.
  final Map<String, String> dataItemLabels;

  /// Labels that will be applied to newly imported Annotations. If two
  /// Annotations are identical, one of them will be deduped. Two Annotations are
  /// considered identical if their
  /// `payload`,
  /// `payload_schema_uri`
  /// and all of their
  /// `labels` are the same.
  /// These labels will be overridden by Annotation labels specified inside index
  /// file referenced by
  /// `import_schema_uri`,
  /// e.g. jsonl file.
  final Map<String, String> annotationLabels;

  /// Required. Points to a YAML file stored on Google Cloud Storage describing
  /// the import format. Validation will be done against the schema. The schema
  /// is defined as an [OpenAPI 3.0.2 Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  final String importSchemaUri;

  ImportDataConfig({
    this.gcsSource,
    this.dataItemLabels = const {},
    this.annotationLabels = const {},
    required this.importSchemaUri,
  }) : super(fullyQualifiedName);

  factory ImportDataConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportDataConfig(
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      dataItemLabels: switch (json['dataItemLabels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"dataItemLabels" is not an object'),
      },
      annotationLabels: switch (json['annotationLabels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"annotationLabels" is not an object'),
      },
      importSchemaUri: switch (json['importSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    if (dataItemLabels.isNotDefault) 'dataItemLabels': dataItemLabels,
    if (annotationLabels.isNotDefault) 'annotationLabels': annotationLabels,
    'importSchemaUri': importSchemaUri,
  };

  @override
  String toString() {
    final contents = ['importSchemaUri=$importSchemaUri'].join(',');
    return 'ImportDataConfig($contents)';
  }
}

/// Describes what part of the Dataset is to be exported, the destination of
/// the export and how to export.
final class ExportDataConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportDataConfig';

  /// The Google Cloud Storage location where the output is to be written to.
  /// In the given directory a new directory will be created with name:
  /// `export-data-<dataset-display-name>-<timestamp-of-export-call>` where
  /// timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All export
  /// output will be written into that directory. Inside that directory,
  /// annotations with the same schema will be grouped into sub directories
  /// which are named with the corresponding annotations' schema title. Inside
  /// these sub directories, a schema.yaml will be created to describe the
  /// output format.
  final GcsDestination? gcsDestination;

  /// Split based on fractions defining the size of each set.
  final ExportFractionSplit? fractionSplit;

  /// An expression for filtering what part of the Dataset is to be exported.
  /// Only Annotations that match this filter will be exported. The filter syntax
  /// is the same as in
  /// `ListAnnotations`.
  final String annotationsFilter;

  ExportDataConfig({
    this.gcsDestination,
    this.fractionSplit,
    this.annotationsFilter = '',
  }) : super(fullyQualifiedName);

  factory ExportDataConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportDataConfig(
      gcsDestination: switch (json['gcsDestination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      fractionSplit: switch (json['fractionSplit']) {
        null => null,
        Object $1 => ExportFractionSplit.fromJson($1),
      },
      annotationsFilter: switch (json['annotationsFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
    if (fractionSplit != null) 'fractionSplit': fractionSplit!.toJson(),
    if (annotationsFilter.isNotDefault) 'annotationsFilter': annotationsFilter,
  };

  @override
  String toString() {
    final contents = ['annotationsFilter=$annotationsFilter'].join(',');
    return 'ExportDataConfig($contents)';
  }
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions. Any of `training_fraction`, `validation_fraction` and
/// `test_fraction` may optionally be provided, they must sum to up to 1. If the
/// provided ones sum to less than 1, the remainder is assigned to sets as
/// decided by Vertex AI. If none of the fractions are set, by default roughly
/// 80% of data is used for training, 10% for validation, and 10% for test.
final class ExportFractionSplit extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFractionSplit';

  /// The fraction of the input data that is to be used to train the Model.
  final double trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  final double validationFraction;

  /// The fraction of the input data that is to be used to evaluate the Model.
  final double testFraction;

  ExportFractionSplit({
    this.trainingFraction = 0,
    this.validationFraction = 0,
    this.testFraction = 0,
  }) : super(fullyQualifiedName);

  factory ExportFractionSplit.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportFractionSplit(
      trainingFraction: switch (json['trainingFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      validationFraction: switch (json['validationFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      testFraction: switch (json['testFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trainingFraction.isNotDefault)
      'trainingFraction': encodeDouble(trainingFraction),
    if (validationFraction.isNotDefault)
      'validationFraction': encodeDouble(validationFraction),
    if (testFraction.isNotDefault) 'testFraction': encodeDouble(testFraction),
  };

  @override
  String toString() {
    final contents = [
      'trainingFraction=$trainingFraction',
      'validationFraction=$validationFraction',
      'testFraction=$testFraction',
    ].join(',');
    return 'ExportFractionSplit($contents)';
  }
}

/// Request message for
/// `DatasetService.CreateDataset`.
final class CreateDatasetRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDatasetRequest';

  /// Required. The resource name of the Location to create the Dataset in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Dataset to create.
  final Dataset? dataset;

  CreateDatasetRequest({required this.parent, required this.dataset})
    : super(fullyQualifiedName);

  factory CreateDatasetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateDatasetRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataset: switch (json['dataset']) {
        null => null,
        Object $1 => Dataset.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (dataset != null) 'dataset': dataset!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateDatasetRequest($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.CreateDataset`.
final class CreateDatasetOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDatasetOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateDatasetOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateDatasetOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateDatasetOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateDatasetOperationMetadata()';
}

/// Request message for
/// `DatasetService.GetDataset`.
final class GetDatasetRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetDatasetRequest';

  /// Required. The name of the Dataset resource.
  final String name;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  GetDatasetRequest({required this.name, this.readMask})
    : super(fullyQualifiedName);

  factory GetDatasetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetDatasetRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetDatasetRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.UpdateDataset`.
final class UpdateDatasetRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateDatasetRequest';

  /// Required. The Dataset which replaces the resource on the server.
  final Dataset? dataset;

  /// Required. The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`. Updatable fields:
  ///
  ///   * `display_name`
  ///   * `description`
  ///   * `labels`
  final protobuf.FieldMask? updateMask;

  UpdateDatasetRequest({required this.dataset, required this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateDatasetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateDatasetRequest(
      dataset: switch (json['dataset']) {
        null => null,
        Object $1 => Dataset.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataset != null) 'dataset': dataset!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateDatasetRequest()';
}

/// Request message for
/// `DatasetService.UpdateDatasetVersion`.
final class UpdateDatasetVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateDatasetVersionRequest';

  /// Required. The DatasetVersion which replaces the resource on the server.
  final DatasetVersion? datasetVersion;

  /// Required. The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`. Updatable fields:
  ///
  ///   * `display_name`
  final protobuf.FieldMask? updateMask;

  UpdateDatasetVersionRequest({
    required this.datasetVersion,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateDatasetVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateDatasetVersionRequest(
      datasetVersion: switch (json['datasetVersion']) {
        null => null,
        Object $1 => DatasetVersion.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (datasetVersion != null) 'datasetVersion': datasetVersion!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateDatasetVersionRequest()';
}

/// Request message for
/// `DatasetService.ListDatasets`.
final class ListDatasetsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDatasetsRequest';

  /// Required. The name of the Dataset's parent resource.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// An expression for filtering the results of the request. For field names
  /// both snake_case and camelCase are supported.
  ///
  ///   * `display_name`: supports = and !=
  ///   * `metadata_schema_uri`: supports = and !=
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:* or labels:key - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///
  /// Some examples:
  ///
  ///   * `displayName="myDisplayName"`
  ///   * `labels.myKey="myValue"`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported fields:
  ///
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  final String orderBy;

  ListDatasetsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListDatasetsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDatasetsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListDatasetsRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListDatasets`.
final class ListDatasetsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDatasetsResponse';

  /// A list of Datasets that matches the specified filter in the request.
  final List<Dataset> datasets;

  /// The standard List next-page token.
  final String nextPageToken;

  ListDatasetsResponse({this.datasets = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListDatasetsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDatasetsResponse(
      datasets: switch (json['datasets']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Dataset.fromJson(i)],
        _ => throw const FormatException('"datasets" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (datasets.isNotDefault) 'datasets': encodeList(datasets),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListDatasetsResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.DeleteDataset`.
final class DeleteDatasetRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteDatasetRequest';

  /// Required. The resource name of the Dataset to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  DeleteDatasetRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteDatasetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteDatasetRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteDatasetRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.ImportData`.
final class ImportDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportDataRequest';

  /// Required. The name of the Dataset resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  /// Required. The desired input locations. The contents of all input locations
  /// will be imported in one batch.
  final List<ImportDataConfig> importConfigs;

  ImportDataRequest({required this.name, required this.importConfigs})
    : super(fullyQualifiedName);

  factory ImportDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportDataRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      importConfigs: switch (json['importConfigs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ImportDataConfig.fromJson(i)],
        _ => throw const FormatException('"importConfigs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'name': name, 'importConfigs': encodeList(importConfigs)};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ImportDataRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ImportData`.
final class ImportDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportDataResponse';

  ImportDataResponse() : super(fullyQualifiedName);

  factory ImportDataResponse.fromJson(Object? j) => ImportDataResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'ImportDataResponse()';
}

/// Runtime operation information for
/// `DatasetService.ImportData`.
final class ImportDataOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportDataOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  ImportDataOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ImportDataOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportDataOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'ImportDataOperationMetadata()';
}

/// Request message for
/// `DatasetService.ExportData`.
final class ExportDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportDataRequest';

  /// Required. The name of the Dataset resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  /// Required. The desired output location.
  final ExportDataConfig? exportConfig;

  ExportDataRequest({required this.name, required this.exportConfig})
    : super(fullyQualifiedName);

  factory ExportDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportDataRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      exportConfig: switch (json['exportConfig']) {
        null => null,
        Object $1 => ExportDataConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (exportConfig != null) 'exportConfig': exportConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ExportDataRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ExportData`.
final class ExportDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportDataResponse';

  /// All of the files that are exported in this export operation. For custom
  /// code training export, only three (training, validation and test)
  /// Cloud Storage paths in wildcard format are populated
  /// (for example, gs://.../training-*).
  final List<String> exportedFiles;

  ExportDataResponse({this.exportedFiles = const []})
    : super(fullyQualifiedName);

  factory ExportDataResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportDataResponse(
      exportedFiles: switch (json['exportedFiles']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"exportedFiles" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (exportedFiles.isNotDefault) 'exportedFiles': exportedFiles,
  };

  @override
  String toString() => 'ExportDataResponse()';
}

/// Runtime operation information for
/// `DatasetService.ExportData`.
final class ExportDataOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportDataOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  /// A Google Cloud Storage directory which path ends with '/'. The exported
  /// data is stored in the directory.
  final String gcsOutputDirectory;

  ExportDataOperationMetadata({
    this.genericMetadata,
    this.gcsOutputDirectory = '',
  }) : super(fullyQualifiedName);

  factory ExportDataOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportDataOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      gcsOutputDirectory: switch (json['gcsOutputDirectory']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (gcsOutputDirectory.isNotDefault)
      'gcsOutputDirectory': gcsOutputDirectory,
  };

  @override
  String toString() {
    final contents = ['gcsOutputDirectory=$gcsOutputDirectory'].join(',');
    return 'ExportDataOperationMetadata($contents)';
  }
}

/// Request message for
/// `DatasetService.CreateDatasetVersion`.
final class CreateDatasetVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDatasetVersionRequest';

  /// Required. The name of the Dataset resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String parent;

  /// Required. The version to be created. The same CMEK policies with the
  /// original Dataset will be applied the dataset version. So here we don't need
  /// to specify the EncryptionSpecType here.
  final DatasetVersion? datasetVersion;

  CreateDatasetVersionRequest({
    required this.parent,
    required this.datasetVersion,
  }) : super(fullyQualifiedName);

  factory CreateDatasetVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateDatasetVersionRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datasetVersion: switch (json['datasetVersion']) {
        null => null,
        Object $1 => DatasetVersion.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (datasetVersion != null) 'datasetVersion': datasetVersion!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateDatasetVersionRequest($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.CreateDatasetVersion`.
final class CreateDatasetVersionOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDatasetVersionOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateDatasetVersionOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateDatasetVersionOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateDatasetVersionOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateDatasetVersionOperationMetadata()';
}

/// Request message for
/// `DatasetService.DeleteDatasetVersion`.
final class DeleteDatasetVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteDatasetVersionRequest';

  /// Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  final String name;

  DeleteDatasetVersionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteDatasetVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteDatasetVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteDatasetVersionRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.GetDatasetVersion`.
final class GetDatasetVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetDatasetVersionRequest';

  /// Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  final String name;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  GetDatasetVersionRequest({required this.name, this.readMask})
    : super(fullyQualifiedName);

  factory GetDatasetVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetDatasetVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetDatasetVersionRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.ListDatasetVersions`.
final class ListDatasetVersionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDatasetVersionsRequest';

  /// Required. The resource name of the Dataset to list DatasetVersions from.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String parent;

  /// Optional. The standard list filter.
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  final String pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending.
  final String orderBy;

  ListDatasetVersionsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListDatasetVersionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDatasetVersionsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListDatasetVersionsRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListDatasetVersions`.
final class ListDatasetVersionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDatasetVersionsResponse';

  /// A list of DatasetVersions that matches the specified filter in the request.
  final List<DatasetVersion> datasetVersions;

  /// The standard List next-page token.
  final String nextPageToken;

  ListDatasetVersionsResponse({
    this.datasetVersions = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListDatasetVersionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDatasetVersionsResponse(
      datasetVersions: switch (json['datasetVersions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DatasetVersion.fromJson(i)],
        _ => throw const FormatException('"datasetVersions" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (datasetVersions.isNotDefault)
      'datasetVersions': encodeList(datasetVersions),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListDatasetVersionsResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.RestoreDatasetVersion`.
final class RestoreDatasetVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RestoreDatasetVersionRequest';

  /// Required. The name of the DatasetVersion resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  final String name;

  RestoreDatasetVersionRequest({required this.name})
    : super(fullyQualifiedName);

  factory RestoreDatasetVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RestoreDatasetVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'RestoreDatasetVersionRequest($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.RestoreDatasetVersion`.
final class RestoreDatasetVersionOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RestoreDatasetVersionOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  RestoreDatasetVersionOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory RestoreDatasetVersionOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RestoreDatasetVersionOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'RestoreDatasetVersionOperationMetadata()';
}

/// Request message for
/// `DatasetService.ListDataItems`.
final class ListDataItemsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDataItemsRequest';

  /// Required. The resource name of the Dataset to list DataItems from.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String parent;

  /// The standard list filter.
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  final String orderBy;

  ListDataItemsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListDataItemsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDataItemsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListDataItemsRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListDataItems`.
final class ListDataItemsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDataItemsResponse';

  /// A list of DataItems that matches the specified filter in the request.
  final List<DataItem> dataItems;

  /// The standard List next-page token.
  final String nextPageToken;

  ListDataItemsResponse({this.dataItems = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListDataItemsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDataItemsResponse(
      dataItems: switch (json['dataItems']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DataItem.fromJson(i)],
        _ => throw const FormatException('"dataItems" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataItems.isNotDefault) 'dataItems': encodeList(dataItems),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListDataItemsResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.SearchDataItems`.
final class SearchDataItemsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchDataItemsRequest';

  /// A comma-separated list of data item fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  final String? orderByDataItem;

  /// Expression that allows ranking results based on annotation's property.
  final SearchDataItemsRequest_OrderByAnnotation? orderByAnnotation;

  /// Required. The resource name of the Dataset from which to search DataItems.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String dataset;

  /// The resource name of a SavedQuery(annotation set in UI).
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  /// All of the search will be done in the context of this SavedQuery.
  final String savedQuery;

  /// The resource name of a DataLabelingJob.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// If this field is set, all of the search will be done in the context of
  /// this DataLabelingJob.
  final String dataLabelingJob;

  /// An expression for filtering the DataItem that will be returned.
  ///
  ///   * `data_item_id` - for = or !=.
  ///   * `labeled` - for = or !=.
  ///   * `has_annotation(ANNOTATION_SPEC_ID)` - true only for DataItem that
  ///     have at least one annotation with annotation_spec_id =
  ///     `ANNOTATION_SPEC_ID` in the context of SavedQuery or DataLabelingJob.
  ///
  /// For example:
  ///
  /// * `data_item=1`
  /// * `has_annotation(5)`
  final String dataItemFilter;

  /// An expression for filtering the Annotations that will be returned per
  /// DataItem.
  ///   * `annotation_spec_id` - for = or !=.
  final String annotationsFilter;

  /// An expression that specifies what Annotations will be returned per
  /// DataItem. Annotations satisfied either of the conditions will be returned.
  ///   * `annotation_spec_id` - for = or !=.
  /// Must specify `saved_query_id=` - saved query id that annotations should
  /// belong to.
  final List<String> annotationFilters;

  /// Mask specifying which fields of
  /// `DataItemView` to read.
  final protobuf.FieldMask? fieldMask;

  /// If set, only up to this many of Annotations will be returned per
  /// DataItemView. The maximum value is 1000. If not set, the maximum value will
  /// be used.
  final int annotationsLimit;

  /// Requested page size. Server may return fewer results than requested.
  /// Default and maximum page size is 100.
  final int pageSize;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  final String orderBy;

  /// A token identifying a page of results for the server to return
  /// Typically obtained via
  /// `SearchDataItemsResponse.next_page_token`
  /// of the previous
  /// `DatasetService.SearchDataItems`
  /// call.
  final String pageToken;

  SearchDataItemsRequest({
    this.orderByDataItem,
    this.orderByAnnotation,
    required this.dataset,
    this.savedQuery = '',
    this.dataLabelingJob = '',
    this.dataItemFilter = '',
    this.annotationsFilter = '',
    this.annotationFilters = const [],
    this.fieldMask,
    this.annotationsLimit = 0,
    this.pageSize = 0,
    this.orderBy = '',
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchDataItemsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchDataItemsRequest(
      orderByDataItem: switch (json['orderByDataItem']) {
        null => null,
        Object $1 => decodeString($1),
      },
      orderByAnnotation: switch (json['orderByAnnotation']) {
        null => null,
        Object $1 => SearchDataItemsRequest_OrderByAnnotation.fromJson($1),
      },
      dataset: switch (json['dataset']) {
        null => '',
        Object $1 => decodeString($1),
      },
      savedQuery: switch (json['savedQuery']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataLabelingJob: switch (json['dataLabelingJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataItemFilter: switch (json['dataItemFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      annotationsFilter: switch (json['annotationsFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      annotationFilters: switch (json['annotationFilters']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"annotationFilters" is not a list'),
      },
      fieldMask: switch (json['fieldMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      annotationsLimit: switch (json['annotationsLimit']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (orderByDataItem != null) 'orderByDataItem': orderByDataItem,
    if (orderByAnnotation != null)
      'orderByAnnotation': orderByAnnotation!.toJson(),
    'dataset': dataset,
    if (savedQuery.isNotDefault) 'savedQuery': savedQuery,
    if (dataLabelingJob.isNotDefault) 'dataLabelingJob': dataLabelingJob,
    if (dataItemFilter.isNotDefault) 'dataItemFilter': dataItemFilter,
    if (annotationsFilter.isNotDefault) 'annotationsFilter': annotationsFilter,
    if (annotationFilters.isNotDefault) 'annotationFilters': annotationFilters,
    if (fieldMask != null) 'fieldMask': fieldMask!.toJson(),
    if (annotationsLimit.isNotDefault) 'annotationsLimit': annotationsLimit,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      if (orderByDataItem != null) 'orderByDataItem=$orderByDataItem',
      'dataset=$dataset',
      'savedQuery=$savedQuery',
      'dataLabelingJob=$dataLabelingJob',
      'dataItemFilter=$dataItemFilter',
      'annotationsFilter=$annotationsFilter',
      'annotationsLimit=$annotationsLimit',
      'pageSize=$pageSize',
      'orderBy=$orderBy',
      'pageToken=$pageToken',
    ].join(',');
    return 'SearchDataItemsRequest($contents)';
  }
}

/// Expression that allows ranking results based on annotation's property.
final class SearchDataItemsRequest_OrderByAnnotation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchDataItemsRequest.OrderByAnnotation';

  /// Required. Saved query of the Annotation. Only Annotations belong to this
  /// saved query will be considered for ordering.
  final String savedQuery;

  /// A comma-separated list of annotation fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Must also
  /// specify saved_query.
  final String orderBy;

  SearchDataItemsRequest_OrderByAnnotation({
    required this.savedQuery,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory SearchDataItemsRequest_OrderByAnnotation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchDataItemsRequest_OrderByAnnotation(
      savedQuery: switch (json['savedQuery']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'savedQuery': savedQuery,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = ['savedQuery=$savedQuery', 'orderBy=$orderBy'].join(',');
    return 'OrderByAnnotation($contents)';
  }
}

/// Response message for
/// `DatasetService.SearchDataItems`.
final class SearchDataItemsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchDataItemsResponse';

  /// The DataItemViews read.
  final List<DataItemView> dataItemViews;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `SearchDataItemsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  SearchDataItemsResponse({
    this.dataItemViews = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchDataItemsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchDataItemsResponse(
      dataItemViews: switch (json['dataItemViews']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DataItemView.fromJson(i)],
        _ => throw const FormatException('"dataItemViews" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataItemViews.isNotDefault) 'dataItemViews': encodeList(dataItemViews),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'SearchDataItemsResponse($contents)';
  }
}

/// A container for a single DataItem and Annotations on it.
final class DataItemView extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DataItemView';

  /// The DataItem.
  final DataItem? dataItem;

  /// The Annotations on the DataItem. If too many Annotations should be returned
  /// for the DataItem, this field will be truncated per annotations_limit in
  /// request. If it was, then the has_truncated_annotations will be set to true.
  final List<Annotation> annotations;

  /// True if and only if the Annotations field has been truncated. It happens if
  /// more Annotations for this DataItem met the request's annotation_filter than
  /// are allowed to be returned by annotations_limit.
  /// Note that if Annotations field is not being returned due to field mask,
  /// then this field will not be set to true no matter how many Annotations are
  /// there.
  final bool hasTruncatedAnnotations;

  DataItemView({
    this.dataItem,
    this.annotations = const [],
    this.hasTruncatedAnnotations = false,
  }) : super(fullyQualifiedName);

  factory DataItemView.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DataItemView(
      dataItem: switch (json['dataItem']) {
        null => null,
        Object $1 => DataItem.fromJson($1),
      },
      annotations: switch (json['annotations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Annotation.fromJson(i)],
        _ => throw const FormatException('"annotations" is not a list'),
      },
      hasTruncatedAnnotations: switch (json['hasTruncatedAnnotations']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataItem != null) 'dataItem': dataItem!.toJson(),
    if (annotations.isNotDefault) 'annotations': encodeList(annotations),
    if (hasTruncatedAnnotations.isNotDefault)
      'hasTruncatedAnnotations': hasTruncatedAnnotations,
  };

  @override
  String toString() {
    final contents = [
      'hasTruncatedAnnotations=$hasTruncatedAnnotations',
    ].join(',');
    return 'DataItemView($contents)';
  }
}

/// Request message for
/// `DatasetService.ListSavedQueries`.
final class ListSavedQueriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSavedQueriesRequest';

  /// Required. The resource name of the Dataset to list SavedQueries from.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String parent;

  /// The standard list filter.
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  final String orderBy;

  ListSavedQueriesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListSavedQueriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSavedQueriesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListSavedQueriesRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListSavedQueries`.
final class ListSavedQueriesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSavedQueriesResponse';

  /// A list of SavedQueries that match the specified filter in the request.
  final List<SavedQuery> savedQueries;

  /// The standard List next-page token.
  final String nextPageToken;

  ListSavedQueriesResponse({
    this.savedQueries = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListSavedQueriesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSavedQueriesResponse(
      savedQueries: switch (json['savedQueries']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SavedQuery.fromJson(i)],
        _ => throw const FormatException('"savedQueries" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (savedQueries.isNotDefault) 'savedQueries': encodeList(savedQueries),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListSavedQueriesResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.DeleteSavedQuery`.
final class DeleteSavedQueryRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteSavedQueryRequest';

  /// Required. The resource name of the SavedQuery to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  final String name;

  DeleteSavedQueryRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteSavedQueryRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteSavedQueryRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteSavedQueryRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.GetAnnotationSpec`.
final class GetAnnotationSpecRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetAnnotationSpecRequest';

  /// Required. The name of the AnnotationSpec resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`
  final String name;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  GetAnnotationSpecRequest({required this.name, this.readMask})
    : super(fullyQualifiedName);

  factory GetAnnotationSpecRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetAnnotationSpecRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetAnnotationSpecRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.ListAnnotations`.
final class ListAnnotationsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListAnnotationsRequest';

  /// Required. The resource name of the DataItem to list Annotations from.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}`
  final String parent;

  /// The standard list filter.
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  final String orderBy;

  ListAnnotationsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListAnnotationsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListAnnotationsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListAnnotationsRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListAnnotations`.
final class ListAnnotationsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListAnnotationsResponse';

  /// A list of Annotations that matches the specified filter in the request.
  final List<Annotation> annotations;

  /// The standard List next-page token.
  final String nextPageToken;

  ListAnnotationsResponse({
    this.annotations = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListAnnotationsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListAnnotationsResponse(
      annotations: switch (json['annotations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Annotation.fromJson(i)],
        _ => throw const FormatException('"annotations" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (annotations.isNotDefault) 'annotations': encodeList(annotations),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListAnnotationsResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.AssessData`.
/// Used only for MULTIMODAL datasets.
final class AssessDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest';

  /// Optional. Configuration for the tuning validation assessment.
  final AssessDataRequest_TuningValidationAssessmentConfig?
  tuningValidationAssessmentConfig;

  /// Optional. Configuration for the tuning resource usage assessment.
  final AssessDataRequest_TuningResourceUsageAssessmentConfig?
  tuningResourceUsageAssessmentConfig;

  /// Optional. Configuration for the batch prediction validation assessment.
  final AssessDataRequest_BatchPredictionValidationAssessmentConfig?
  batchPredictionValidationAssessmentConfig;

  /// Optional. Configuration for the batch prediction resource usage
  /// assessment.
  final AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig?
  batchPredictionResourceUsageAssessmentConfig;

  /// Required. The name of the Dataset resource. Used only for MULTIMODAL
  /// datasets. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  /// Optional. The Gemini request read config for the dataset.
  final GeminiRequestReadConfig? geminiRequestReadConfig;

  AssessDataRequest({
    this.tuningValidationAssessmentConfig,
    this.tuningResourceUsageAssessmentConfig,
    this.batchPredictionValidationAssessmentConfig,
    this.batchPredictionResourceUsageAssessmentConfig,
    required this.name,
    this.geminiRequestReadConfig,
  }) : super(fullyQualifiedName);

  factory AssessDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AssessDataRequest(
      tuningValidationAssessmentConfig:
          switch (json['tuningValidationAssessmentConfig']) {
            null => null,
            Object $1 =>
              AssessDataRequest_TuningValidationAssessmentConfig.fromJson($1),
          },
      tuningResourceUsageAssessmentConfig:
          switch (json['tuningResourceUsageAssessmentConfig']) {
            null => null,
            Object $1 =>
              AssessDataRequest_TuningResourceUsageAssessmentConfig.fromJson(
                $1,
              ),
          },
      batchPredictionValidationAssessmentConfig:
          switch (json['batchPredictionValidationAssessmentConfig']) {
            null => null,
            Object $1 =>
              AssessDataRequest_BatchPredictionValidationAssessmentConfig.fromJson(
                $1,
              ),
          },
      batchPredictionResourceUsageAssessmentConfig:
          switch (json['batchPredictionResourceUsageAssessmentConfig']) {
            null => null,
            Object $1 =>
              AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig.fromJson(
                $1,
              ),
          },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      geminiRequestReadConfig: switch (json['geminiRequestReadConfig']) {
        null => null,
        Object $1 => GeminiRequestReadConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tuningValidationAssessmentConfig != null)
      'tuningValidationAssessmentConfig': tuningValidationAssessmentConfig!
          .toJson(),
    if (tuningResourceUsageAssessmentConfig != null)
      'tuningResourceUsageAssessmentConfig':
          tuningResourceUsageAssessmentConfig!.toJson(),
    if (batchPredictionValidationAssessmentConfig != null)
      'batchPredictionValidationAssessmentConfig':
          batchPredictionValidationAssessmentConfig!.toJson(),
    if (batchPredictionResourceUsageAssessmentConfig != null)
      'batchPredictionResourceUsageAssessmentConfig':
          batchPredictionResourceUsageAssessmentConfig!.toJson(),
    'name': name,
    if (geminiRequestReadConfig != null)
      'geminiRequestReadConfig': geminiRequestReadConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AssessDataRequest($contents)';
  }
}

/// Configuration for the tuning validation assessment.
final class AssessDataRequest_TuningValidationAssessmentConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest.TuningValidationAssessmentConfig';

  /// Required. The name of the model used for tuning.
  final String modelName;

  /// Required. The dataset usage (e.g. training/validation).
  final AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage
  datasetUsage;

  AssessDataRequest_TuningValidationAssessmentConfig({
    required this.modelName,
    required this.datasetUsage,
  }) : super(fullyQualifiedName);

  factory AssessDataRequest_TuningValidationAssessmentConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return AssessDataRequest_TuningValidationAssessmentConfig(
      modelName: switch (json['modelName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datasetUsage: switch (json['datasetUsage']) {
        null =>
          AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage
              .$default,
        Object $1 =>
          AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    'modelName': modelName,
    'datasetUsage': datasetUsage.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'modelName=$modelName',
      'datasetUsage=$datasetUsage',
    ].join(',');
    return 'TuningValidationAssessmentConfig($contents)';
  }
}

/// The dataset usage (e.g. training/validation).
final class AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage
    extends ProtoEnum {
  /// Default value. Should not be used.
  static const datasetUsageUnspecified =
      AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
        'DATASET_USAGE_UNSPECIFIED',
      );

  /// Supervised fine-tuning training dataset.
  static const sftTraining =
      AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
        'SFT_TRAINING',
      );

  /// Supervised fine-tuning validation dataset.
  static const sftValidation =
      AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
        'SFT_VALIDATION',
      );

  /// The default value for [AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage].
  static const $default = datasetUsageUnspecified;

  const AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
    super.value,
  );

  factory AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage.fromJson(
    Object? json,
  ) => AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
    json as String,
  );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DatasetUsage.$value';
}

/// Configuration for the tuning resource usage assessment.
final class AssessDataRequest_TuningResourceUsageAssessmentConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest.TuningResourceUsageAssessmentConfig';

  /// Required. The name of the model used for tuning.
  final String modelName;

  AssessDataRequest_TuningResourceUsageAssessmentConfig({
    required this.modelName,
  }) : super(fullyQualifiedName);

  factory AssessDataRequest_TuningResourceUsageAssessmentConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return AssessDataRequest_TuningResourceUsageAssessmentConfig(
      modelName: switch (json['modelName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'modelName': modelName};

  @override
  String toString() {
    final contents = ['modelName=$modelName'].join(',');
    return 'TuningResourceUsageAssessmentConfig($contents)';
  }
}

/// Configuration for the batch prediction validation assessment.
final class AssessDataRequest_BatchPredictionValidationAssessmentConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest.BatchPredictionValidationAssessmentConfig';

  /// Required. The name of the model used for batch prediction.
  final String modelName;

  AssessDataRequest_BatchPredictionValidationAssessmentConfig({
    required this.modelName,
  }) : super(fullyQualifiedName);

  factory AssessDataRequest_BatchPredictionValidationAssessmentConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return AssessDataRequest_BatchPredictionValidationAssessmentConfig(
      modelName: switch (json['modelName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'modelName': modelName};

  @override
  String toString() {
    final contents = ['modelName=$modelName'].join(',');
    return 'BatchPredictionValidationAssessmentConfig($contents)';
  }
}

/// Configuration for the batch prediction resource usage assessment.
final class AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest.BatchPredictionResourceUsageAssessmentConfig';

  /// Required. The name of the model used for batch prediction.
  final String modelName;

  AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig({
    required this.modelName,
  }) : super(fullyQualifiedName);

  factory AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig(
      modelName: switch (json['modelName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'modelName': modelName};

  @override
  String toString() {
    final contents = ['modelName=$modelName'].join(',');
    return 'BatchPredictionResourceUsageAssessmentConfig($contents)';
  }
}

/// Response message for
/// `DatasetService.AssessData`.
final class AssessDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse';

  /// Optional. The result of the tuning validation assessment.
  final AssessDataResponse_TuningValidationAssessmentResult?
  tuningValidationAssessmentResult;

  /// Optional. The result of the tuning resource usage assessment.
  final AssessDataResponse_TuningResourceUsageAssessmentResult?
  tuningResourceUsageAssessmentResult;

  /// Optional. The result of the batch prediction validation assessment.
  final AssessDataResponse_BatchPredictionValidationAssessmentResult?
  batchPredictionValidationAssessmentResult;

  /// Optional. The result of the batch prediction resource usage assessment.
  final AssessDataResponse_BatchPredictionResourceUsageAssessmentResult?
  batchPredictionResourceUsageAssessmentResult;

  AssessDataResponse({
    this.tuningValidationAssessmentResult,
    this.tuningResourceUsageAssessmentResult,
    this.batchPredictionValidationAssessmentResult,
    this.batchPredictionResourceUsageAssessmentResult,
  }) : super(fullyQualifiedName);

  factory AssessDataResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AssessDataResponse(
      tuningValidationAssessmentResult:
          switch (json['tuningValidationAssessmentResult']) {
            null => null,
            Object $1 =>
              AssessDataResponse_TuningValidationAssessmentResult.fromJson($1),
          },
      tuningResourceUsageAssessmentResult:
          switch (json['tuningResourceUsageAssessmentResult']) {
            null => null,
            Object $1 =>
              AssessDataResponse_TuningResourceUsageAssessmentResult.fromJson(
                $1,
              ),
          },
      batchPredictionValidationAssessmentResult:
          switch (json['batchPredictionValidationAssessmentResult']) {
            null => null,
            Object $1 =>
              AssessDataResponse_BatchPredictionValidationAssessmentResult.fromJson(
                $1,
              ),
          },
      batchPredictionResourceUsageAssessmentResult:
          switch (json['batchPredictionResourceUsageAssessmentResult']) {
            null => null,
            Object $1 =>
              AssessDataResponse_BatchPredictionResourceUsageAssessmentResult.fromJson(
                $1,
              ),
          },
    );
  }

  @override
  Object toJson() => {
    if (tuningValidationAssessmentResult != null)
      'tuningValidationAssessmentResult': tuningValidationAssessmentResult!
          .toJson(),
    if (tuningResourceUsageAssessmentResult != null)
      'tuningResourceUsageAssessmentResult':
          tuningResourceUsageAssessmentResult!.toJson(),
    if (batchPredictionValidationAssessmentResult != null)
      'batchPredictionValidationAssessmentResult':
          batchPredictionValidationAssessmentResult!.toJson(),
    if (batchPredictionResourceUsageAssessmentResult != null)
      'batchPredictionResourceUsageAssessmentResult':
          batchPredictionResourceUsageAssessmentResult!.toJson(),
  };

  @override
  String toString() => 'AssessDataResponse()';
}

/// The result of the tuning validation assessment.
final class AssessDataResponse_TuningValidationAssessmentResult
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse.TuningValidationAssessmentResult';

  /// Optional. A list containing the first validation errors.
  final List<String> errors;

  AssessDataResponse_TuningValidationAssessmentResult({this.errors = const []})
    : super(fullyQualifiedName);

  factory AssessDataResponse_TuningValidationAssessmentResult.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return AssessDataResponse_TuningValidationAssessmentResult(
      errors: switch (json['errors']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"errors" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (errors.isNotDefault) 'errors': errors};

  @override
  String toString() => 'TuningValidationAssessmentResult()';
}

/// The result of the tuning resource usage assessment.
final class AssessDataResponse_TuningResourceUsageAssessmentResult
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse.TuningResourceUsageAssessmentResult';

  /// Number of tokens in the tuning dataset.
  final int tokenCount;

  /// Number of billable tokens in the tuning dataset.
  final int billableCharacterCount;

  AssessDataResponse_TuningResourceUsageAssessmentResult({
    this.tokenCount = 0,
    this.billableCharacterCount = 0,
  }) : super(fullyQualifiedName);

  factory AssessDataResponse_TuningResourceUsageAssessmentResult.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return AssessDataResponse_TuningResourceUsageAssessmentResult(
      tokenCount: switch (json['tokenCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      billableCharacterCount: switch (json['billableCharacterCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tokenCount.isNotDefault) 'tokenCount': encodeInt64(tokenCount),
    if (billableCharacterCount.isNotDefault)
      'billableCharacterCount': encodeInt64(billableCharacterCount),
  };

  @override
  String toString() {
    final contents = [
      'tokenCount=$tokenCount',
      'billableCharacterCount=$billableCharacterCount',
    ].join(',');
    return 'TuningResourceUsageAssessmentResult($contents)';
  }
}

/// The result of the batch prediction validation assessment.
final class AssessDataResponse_BatchPredictionValidationAssessmentResult
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse.BatchPredictionValidationAssessmentResult';

  AssessDataResponse_BatchPredictionValidationAssessmentResult()
    : super(fullyQualifiedName);

  factory AssessDataResponse_BatchPredictionValidationAssessmentResult.fromJson(
    Object? j,
  ) => AssessDataResponse_BatchPredictionValidationAssessmentResult();

  @override
  Object toJson() => {};

  @override
  String toString() => 'BatchPredictionValidationAssessmentResult()';
}

/// The result of the batch prediction resource usage assessment.
final class AssessDataResponse_BatchPredictionResourceUsageAssessmentResult
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse.BatchPredictionResourceUsageAssessmentResult';

  /// Number of tokens in the batch prediction dataset.
  final int tokenCount;

  /// Number of audio tokens in the batch prediction dataset.
  final int audioTokenCount;

  AssessDataResponse_BatchPredictionResourceUsageAssessmentResult({
    this.tokenCount = 0,
    this.audioTokenCount = 0,
  }) : super(fullyQualifiedName);

  factory AssessDataResponse_BatchPredictionResourceUsageAssessmentResult.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return AssessDataResponse_BatchPredictionResourceUsageAssessmentResult(
      tokenCount: switch (json['tokenCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      audioTokenCount: switch (json['audioTokenCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tokenCount.isNotDefault) 'tokenCount': encodeInt64(tokenCount),
    if (audioTokenCount.isNotDefault)
      'audioTokenCount': encodeInt64(audioTokenCount),
  };

  @override
  String toString() {
    final contents = [
      'tokenCount=$tokenCount',
      'audioTokenCount=$audioTokenCount',
    ].join(',');
    return 'BatchPredictionResourceUsageAssessmentResult($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.AssessData`.
final class AssessDataOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  AssessDataOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory AssessDataOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AssessDataOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'AssessDataOperationMetadata()';
}

/// Template configuration to create Gemini examples from a multimodal dataset.
final class GeminiTemplateConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GeminiTemplateConfig';

  /// Required. The template that will be used for assembling the request to use
  /// for downstream applications.
  final GeminiExample? geminiExample;

  /// Required. Map of template parameters to the columns in the dataset table.
  final Map<String, String> fieldMapping;

  GeminiTemplateConfig({
    required this.geminiExample,
    required this.fieldMapping,
  }) : super(fullyQualifiedName);

  factory GeminiTemplateConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GeminiTemplateConfig(
      geminiExample: switch (json['geminiExample']) {
        null => null,
        Object $1 => GeminiExample.fromJson($1),
      },
      fieldMapping: switch (json['fieldMapping']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"fieldMapping" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (geminiExample != null) 'geminiExample': geminiExample!.toJson(),
    'fieldMapping': fieldMapping,
  };

  @override
  String toString() => 'GeminiTemplateConfig()';
}

/// Configuration for how to read Gemini requests from a multimodal dataset.
final class GeminiRequestReadConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GeminiRequestReadConfig';

  /// Gemini request template with placeholders.
  final GeminiTemplateConfig? templateConfig;

  /// Optional. Column name in the dataset table that contains already fully
  /// assembled Gemini requests.
  final String? assembledRequestColumnName;

  GeminiRequestReadConfig({
    this.templateConfig,
    this.assembledRequestColumnName,
  }) : super(fullyQualifiedName);

  factory GeminiRequestReadConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GeminiRequestReadConfig(
      templateConfig: switch (json['templateConfig']) {
        null => null,
        Object $1 => GeminiTemplateConfig.fromJson($1),
      },
      assembledRequestColumnName: switch (json['assembledRequestColumnName']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (templateConfig != null) 'templateConfig': templateConfig!.toJson(),
    if (assembledRequestColumnName != null)
      'assembledRequestColumnName': assembledRequestColumnName,
  };

  @override
  String toString() {
    final contents = [
      if (assembledRequestColumnName != null)
        'assembledRequestColumnName=$assembledRequestColumnName',
    ].join(',');
    return 'GeminiRequestReadConfig($contents)';
  }
}

/// Format for Gemini examples used for Vertex Multimodal datasets.
final class GeminiExample extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GeminiExample';

  /// Optional. The fully qualified name of the publisher model or tuned model
  /// endpoint to use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers/*/models/*`
  ///
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String model;

  /// Required. The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn
  /// queries, this is a repeated field that contains conversation history +
  /// latest request.
  final List<Content> contents;

  /// Optional. The user provided system instructions for the model.
  /// Note: only text should be used in parts and content in each part will be
  /// in a separate paragraph.
  final Content? systemInstruction;

  /// Optional. The name of the cached content used as context to serve the
  /// prediction. Note: only used in explicit caching, where users can have
  /// control over caching (e.g. what content to cache) and enjoy guaranteed cost
  /// savings. Format:
  /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
  final String cachedContent;

  /// Optional. A list of `Tools` the model may use to generate the next
  /// response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  final List<Tool> tools;

  /// Optional. Tool config. This config is shared for all tools provided in the
  /// request.
  final ToolConfig? toolConfig;

  /// Optional. The labels with user-defined metadata for the request. It is used
  /// for billing and reporting only.
  ///
  /// Label keys and values can be no longer than 63 characters
  /// (Unicode codepoints) and can only contain lowercase letters, numeric
  /// characters, underscores, and dashes. International characters are
  /// allowed. Label values are optional. Label keys must start with a letter.
  final Map<String, String> labels;

  /// Optional. Per request settings for blocking unsafe content.
  /// Enforced on GenerateContentResponse.candidates.
  final List<SafetySetting> safetySettings;

  /// Optional. Generation config.
  final GenerationConfig? generationConfig;

  GeminiExample({
    this.model = '',
    required this.contents,
    this.systemInstruction,
    this.cachedContent = '',
    this.tools = const [],
    this.toolConfig,
    this.labels = const {},
    this.safetySettings = const [],
    this.generationConfig,
  }) : super(fullyQualifiedName);

  factory GeminiExample.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GeminiExample(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
      systemInstruction: switch (json['systemInstruction']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
      cachedContent: switch (json['cachedContent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tools: switch (json['tools']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tool.fromJson(i)],
        _ => throw const FormatException('"tools" is not a list'),
      },
      toolConfig: switch (json['toolConfig']) {
        null => null,
        Object $1 => ToolConfig.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      safetySettings: switch (json['safetySettings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SafetySetting.fromJson(i)],
        _ => throw const FormatException('"safetySettings" is not a list'),
      },
      generationConfig: switch (json['generationConfig']) {
        null => null,
        Object $1 => GenerationConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (model.isNotDefault) 'model': model,
    'contents': encodeList(contents),
    if (systemInstruction != null)
      'systemInstruction': systemInstruction!.toJson(),
    if (cachedContent.isNotDefault) 'cachedContent': cachedContent,
    if (tools.isNotDefault) 'tools': encodeList(tools),
    if (toolConfig != null) 'toolConfig': toolConfig!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (safetySettings.isNotDefault)
      'safetySettings': encodeList(safetySettings),
    if (generationConfig != null)
      'generationConfig': generationConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['model=$model', 'cachedContent=$cachedContent'].join(',');
    return 'GeminiExample($contents)';
  }
}

/// Request message for
/// `DatasetService.AssembleData`.
/// Used only for MULTIMODAL datasets.
final class AssembleDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssembleDataRequest';

  /// Required. The name of the Dataset resource (used only for MULTIMODAL
  /// datasets). Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  /// Optional. The read config for the dataset.
  final GeminiRequestReadConfig? geminiRequestReadConfig;

  AssembleDataRequest({required this.name, this.geminiRequestReadConfig})
    : super(fullyQualifiedName);

  factory AssembleDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AssembleDataRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      geminiRequestReadConfig: switch (json['geminiRequestReadConfig']) {
        null => null,
        Object $1 => GeminiRequestReadConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (geminiRequestReadConfig != null)
      'geminiRequestReadConfig': geminiRequestReadConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AssembleDataRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.AssembleData`.
final class AssembleDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssembleDataResponse';

  /// Destination BigQuery table path containing the assembled data as a single
  /// column.
  final String bigqueryDestination;

  AssembleDataResponse({this.bigqueryDestination = ''})
    : super(fullyQualifiedName);

  factory AssembleDataResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AssembleDataResponse(
      bigqueryDestination: switch (json['bigqueryDestination']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bigqueryDestination.isNotDefault)
      'bigqueryDestination': bigqueryDestination,
  };

  @override
  String toString() {
    final contents = ['bigqueryDestination=$bigqueryDestination'].join(',');
    return 'AssembleDataResponse($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.AssembleData`.
final class AssembleDataOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssembleDataOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  AssembleDataOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory AssembleDataOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AssembleDataOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'AssembleDataOperationMetadata()';
}

/// Describes the dataset version.
final class DatasetVersion extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DatasetVersion';

  /// Output only. Identifier. The resource name of the DatasetVersion.
  final String name;

  /// Output only. Timestamp when this DatasetVersion was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this DatasetVersion was last updated.
  final protobuf.Timestamp? updateTime;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// Output only. Name of the associated BigQuery dataset.
  final String bigQueryDatasetName;

  /// The user-defined name of the DatasetVersion.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Required. Output only. Additional information about the DatasetVersion.
  final protobuf.Value? metadata;

  /// Output only. Reference to the public base model last used by the dataset
  /// version. Only set for prompt dataset versions.
  final String modelReference;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  DatasetVersion({
    this.name = '',
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.bigQueryDatasetName = '',
    this.displayName = '',
    required this.metadata,
    this.modelReference = '',
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory DatasetVersion.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DatasetVersion(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      bigQueryDatasetName: switch (json['bigQueryDatasetName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      modelReference: switch (json['modelReference']) {
        null => '',
        Object $1 => decodeString($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (bigQueryDatasetName.isNotDefault)
      'bigQueryDatasetName': bigQueryDatasetName,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (modelReference.isNotDefault) 'modelReference': modelReference,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'etag=$etag',
      'bigQueryDatasetName=$bigQueryDatasetName',
      'displayName=$displayName',
      'modelReference=$modelReference',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'DatasetVersion($contents)';
  }
}

/// Points to a DeployedIndex.
final class DeployedIndexRef extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedIndexRef';

  /// Immutable. A resource name of the IndexEndpoint.
  final String indexEndpoint;

  /// Immutable. The ID of the DeployedIndex in the above IndexEndpoint.
  final String deployedIndexId;

  /// Output only. The display name of the DeployedIndex.
  final String displayName;

  DeployedIndexRef({
    this.indexEndpoint = '',
    this.deployedIndexId = '',
    this.displayName = '',
  }) : super(fullyQualifiedName);

  factory DeployedIndexRef.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployedIndexRef(
      indexEndpoint: switch (json['indexEndpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedIndexId: switch (json['deployedIndexId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (indexEndpoint.isNotDefault) 'indexEndpoint': indexEndpoint,
    if (deployedIndexId.isNotDefault) 'deployedIndexId': deployedIndexId,
    if (displayName.isNotDefault) 'displayName': displayName,
  };

  @override
  String toString() {
    final contents = [
      'indexEndpoint=$indexEndpoint',
      'deployedIndexId=$deployedIndexId',
      'displayName=$displayName',
    ].join(',');
    return 'DeployedIndexRef($contents)';
  }
}

/// Points to a DeployedModel.
final class DeployedModelRef extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedModelRef';

  /// Immutable. A resource name of an Endpoint.
  final String endpoint;

  /// Immutable. An ID of a DeployedModel in the above Endpoint.
  final String deployedModelId;

  DeployedModelRef({this.endpoint = '', this.deployedModelId = ''})
    : super(fullyQualifiedName);

  factory DeployedModelRef.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployedModelRef(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedModelId: switch (json['deployedModelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (endpoint.isNotDefault) 'endpoint': endpoint,
    if (deployedModelId.isNotDefault) 'deployedModelId': deployedModelId,
  };

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      'deployedModelId=$deployedModelId',
    ].join(',');
    return 'DeployedModelRef($contents)';
  }
}

/// A description of resources that can be shared by multiple DeployedModels,
/// whose underlying specification consists of a DedicatedResources.
final class DeploymentResourcePool extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeploymentResourcePool';

  /// Immutable. The resource name of the DeploymentResourcePool.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String name;

  /// Required. The underlying DedicatedResources that the DeploymentResourcePool
  /// uses.
  final DedicatedResources? dedicatedResources;

  /// Customer-managed encryption key spec for a DeploymentResourcePool. If set,
  /// this DeploymentResourcePool will be secured by this key. Endpoints and the
  /// DeploymentResourcePool they deploy in need to have the same EncryptionSpec.
  final EncryptionSpec? encryptionSpec;

  /// The service account that the DeploymentResourcePool's container(s) run as.
  /// Specify the email address of the service account. If this service account
  /// is not specified, the container(s) run as a service account that doesn't
  /// have access to the resource project.
  ///
  /// Users deploying the Models to this DeploymentResourcePool must have the
  /// `iam.serviceAccounts.actAs` permission on this service account.
  final String serviceAccount;

  /// If the DeploymentResourcePool is deployed with custom-trained Models or
  /// AutoML Tabular Models, the container(s) of the DeploymentResourcePool will
  /// send `stderr` and `stdout` streams to Cloud Logging by default.
  /// Please note that the logs incur cost, which are subject to [Cloud Logging
  /// pricing](https://cloud.google.com/logging/pricing).
  ///
  /// User can disable container logging by setting this flag to true.
  final bool disableContainerLogging;

  /// Output only. Timestamp when this DeploymentResourcePool was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  DeploymentResourcePool({
    this.name = '',
    required this.dedicatedResources,
    this.encryptionSpec,
    this.serviceAccount = '',
    this.disableContainerLogging = false,
    this.createTime,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory DeploymentResourcePool.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeploymentResourcePool(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dedicatedResources: switch (json['dedicatedResources']) {
        null => null,
        Object $1 => DedicatedResources.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
      disableContainerLogging: switch (json['disableContainerLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (dedicatedResources != null)
      'dedicatedResources': dedicatedResources!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
    if (disableContainerLogging.isNotDefault)
      'disableContainerLogging': disableContainerLogging,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'serviceAccount=$serviceAccount',
      'disableContainerLogging=$disableContainerLogging',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'DeploymentResourcePool($contents)';
  }
}

/// Request message for CreateDeploymentResourcePool method.
final class CreateDeploymentResourcePoolRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDeploymentResourcePoolRequest';

  /// Required. The parent location resource where this DeploymentResourcePool
  /// will be created. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The DeploymentResourcePool to create.
  final DeploymentResourcePool? deploymentResourcePool;

  /// Required. The ID to use for the DeploymentResourcePool, which
  /// will become the final component of the DeploymentResourcePool's resource
  /// name.
  ///
  /// The maximum length is 63 characters, and valid characters
  /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  final String deploymentResourcePoolId;

  CreateDeploymentResourcePoolRequest({
    required this.parent,
    required this.deploymentResourcePool,
    required this.deploymentResourcePoolId,
  }) : super(fullyQualifiedName);

  factory CreateDeploymentResourcePoolRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateDeploymentResourcePoolRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deploymentResourcePool: switch (json['deploymentResourcePool']) {
        null => null,
        Object $1 => DeploymentResourcePool.fromJson($1),
      },
      deploymentResourcePoolId: switch (json['deploymentResourcePoolId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (deploymentResourcePool != null)
      'deploymentResourcePool': deploymentResourcePool!.toJson(),
    'deploymentResourcePoolId': deploymentResourcePoolId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'deploymentResourcePoolId=$deploymentResourcePoolId',
    ].join(',');
    return 'CreateDeploymentResourcePoolRequest($contents)';
  }
}

/// Runtime operation information for CreateDeploymentResourcePool method.
final class CreateDeploymentResourcePoolOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDeploymentResourcePoolOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateDeploymentResourcePoolOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateDeploymentResourcePoolOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateDeploymentResourcePoolOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateDeploymentResourcePoolOperationMetadata()';
}

/// Request message for GetDeploymentResourcePool method.
final class GetDeploymentResourcePoolRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetDeploymentResourcePoolRequest';

  /// Required. The name of the DeploymentResourcePool to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String name;

  GetDeploymentResourcePoolRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetDeploymentResourcePoolRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetDeploymentResourcePoolRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetDeploymentResourcePoolRequest($contents)';
  }
}

/// Request message for ListDeploymentResourcePools method.
final class ListDeploymentResourcePoolsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDeploymentResourcePoolsRequest';

  /// Required. The parent Location which owns this collection of
  /// DeploymentResourcePools. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The maximum number of DeploymentResourcePools to return. The service may
  /// return fewer than this value.
  final int pageSize;

  /// A page token, received from a previous `ListDeploymentResourcePools` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `ListDeploymentResourcePools` must match the call that provided the page
  /// token.
  final String pageToken;

  ListDeploymentResourcePoolsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListDeploymentResourcePoolsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDeploymentResourcePoolsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListDeploymentResourcePoolsRequest($contents)';
  }
}

/// Response message for ListDeploymentResourcePools method.
final class ListDeploymentResourcePoolsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDeploymentResourcePoolsResponse';

  /// The DeploymentResourcePools from the specified location.
  final List<DeploymentResourcePool> deploymentResourcePools;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  final String nextPageToken;

  ListDeploymentResourcePoolsResponse({
    this.deploymentResourcePools = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListDeploymentResourcePoolsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDeploymentResourcePoolsResponse(
      deploymentResourcePools: switch (json['deploymentResourcePools']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) DeploymentResourcePool.fromJson(i),
        ],
        _ => throw const FormatException(
          '"deploymentResourcePools" is not a list',
        ),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (deploymentResourcePools.isNotDefault)
      'deploymentResourcePools': encodeList(deploymentResourcePools),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListDeploymentResourcePoolsResponse($contents)';
  }
}

/// Request message for UpdateDeploymentResourcePool method.
final class UpdateDeploymentResourcePoolRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateDeploymentResourcePoolRequest';

  /// Required. The DeploymentResourcePool to update.
  ///
  /// The DeploymentResourcePool's `name` field is used to identify the
  /// DeploymentResourcePool to update.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final DeploymentResourcePool? deploymentResourcePool;

  /// Required. The list of fields to update.
  final protobuf.FieldMask? updateMask;

  UpdateDeploymentResourcePoolRequest({
    required this.deploymentResourcePool,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateDeploymentResourcePoolRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateDeploymentResourcePoolRequest(
      deploymentResourcePool: switch (json['deploymentResourcePool']) {
        null => null,
        Object $1 => DeploymentResourcePool.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (deploymentResourcePool != null)
      'deploymentResourcePool': deploymentResourcePool!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateDeploymentResourcePoolRequest()';
}

/// Runtime operation information for UpdateDeploymentResourcePool method.
final class UpdateDeploymentResourcePoolOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateDeploymentResourcePoolOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateDeploymentResourcePoolOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateDeploymentResourcePoolOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateDeploymentResourcePoolOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateDeploymentResourcePoolOperationMetadata()';
}

/// Request message for DeleteDeploymentResourcePool method.
final class DeleteDeploymentResourcePoolRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteDeploymentResourcePoolRequest';

  /// Required. The name of the DeploymentResourcePool to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String name;

  DeleteDeploymentResourcePoolRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteDeploymentResourcePoolRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteDeploymentResourcePoolRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteDeploymentResourcePoolRequest($contents)';
  }
}

/// Request message for QueryDeployedModels method.
final class QueryDeployedModelsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryDeployedModelsRequest';

  /// Required. The name of the target DeploymentResourcePool to query.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String deploymentResourcePool;

  /// The maximum number of DeployedModels to return. The service may return
  /// fewer than this value.
  final int pageSize;

  /// A page token, received from a previous `QueryDeployedModels` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `QueryDeployedModels` must match the call that provided the page
  /// token.
  final String pageToken;

  QueryDeployedModelsRequest({
    required this.deploymentResourcePool,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory QueryDeployedModelsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryDeployedModelsRequest(
      deploymentResourcePool: switch (json['deploymentResourcePool']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'deploymentResourcePool': deploymentResourcePool,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'deploymentResourcePool=$deploymentResourcePool',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'QueryDeployedModelsRequest($contents)';
  }
}

/// Response message for QueryDeployedModels method.
final class QueryDeployedModelsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryDeployedModelsResponse';

  /// DEPRECATED Use deployed_model_refs instead.
  final List<DeployedModel> deployedModels;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  final String nextPageToken;

  /// References to the DeployedModels that share the specified
  /// deploymentResourcePool.
  final List<DeployedModelRef> deployedModelRefs;

  /// The total number of DeployedModels on this DeploymentResourcePool.
  final int totalDeployedModelCount;

  /// The total number of Endpoints that have DeployedModels on this
  /// DeploymentResourcePool.
  final int totalEndpointCount;

  QueryDeployedModelsResponse({
    this.deployedModels = const [],
    this.nextPageToken = '',
    this.deployedModelRefs = const [],
    this.totalDeployedModelCount = 0,
    this.totalEndpointCount = 0,
  }) : super(fullyQualifiedName);

  factory QueryDeployedModelsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryDeployedModelsResponse(
      deployedModels: switch (json['deployedModels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DeployedModel.fromJson(i)],
        _ => throw const FormatException('"deployedModels" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedModelRefs: switch (json['deployedModelRefs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DeployedModelRef.fromJson(i)],
        _ => throw const FormatException('"deployedModelRefs" is not a list'),
      },
      totalDeployedModelCount: switch (json['totalDeployedModelCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      totalEndpointCount: switch (json['totalEndpointCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (deployedModels.isNotDefault)
      'deployedModels': encodeList(deployedModels),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
    if (deployedModelRefs.isNotDefault)
      'deployedModelRefs': encodeList(deployedModelRefs),
    if (totalDeployedModelCount.isNotDefault)
      'totalDeployedModelCount': totalDeployedModelCount,
    if (totalEndpointCount.isNotDefault)
      'totalEndpointCount': totalEndpointCount,
  };

  @override
  String toString() {
    final contents = [
      'nextPageToken=$nextPageToken',
      'totalDeployedModelCount=$totalDeployedModelCount',
      'totalEndpointCount=$totalEndpointCount',
    ].join(',');
    return 'QueryDeployedModelsResponse($contents)';
  }
}

/// Represents a customer-managed encryption key spec that can be applied to
/// a top-level resource.
final class EncryptionSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EncryptionSpec';

  /// Required. The Cloud KMS resource identifier of the customer managed
  /// encryption key used to protect a resource. Has the form:
  /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
  /// The key needs to be in the same region as where the compute resource is
  /// created.
  final String kmsKeyName;

  EncryptionSpec({required this.kmsKeyName}) : super(fullyQualifiedName);

  factory EncryptionSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EncryptionSpec(
      kmsKeyName: switch (json['kmsKeyName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'kmsKeyName': kmsKeyName};

  @override
  String toString() {
    final contents = ['kmsKeyName=$kmsKeyName'].join(',');
    return 'EncryptionSpec($contents)';
  }
}

/// Models are deployed into it, and afterwards Endpoint is called to obtain
/// predictions and explanations.
final class Endpoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Endpoint';

  /// Output only. The resource name of the Endpoint.
  final String name;

  /// Required. The display name of the Endpoint.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// The description of the Endpoint.
  final String description;

  /// Output only. The models deployed in this Endpoint.
  /// To add or remove DeployedModels use
  /// `EndpointService.DeployModel`
  /// and
  /// `EndpointService.UndeployModel`
  /// respectively.
  final List<DeployedModel> deployedModels;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If a DeployedModel's ID is not listed in this map, then it receives no
  /// traffic.
  ///
  /// The traffic percentage values must add up to 100, or map must be empty if
  /// the Endpoint is to not accept any traffic at a moment.
  final Map<String, int> trafficSplit;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize your Endpoints.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Output only. Timestamp when this Endpoint was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Endpoint was last updated.
  final protobuf.Timestamp? updateTime;

  /// Customer-managed encryption key spec for an Endpoint. If set, this
  /// Endpoint and all sub-resources of this Endpoint will be secured by
  /// this key.
  final EncryptionSpec? encryptionSpec;

  /// Optional. The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  /// to which the Endpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If left
  /// unspecified, the Endpoint is not peered with any network.
  ///
  /// Only one of the fields,
  /// `network` or
  /// `enable_private_service_connect`,
  /// can be set.
  ///
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`.
  /// Where `{project}` is a project number, as in `12345`, and `{network}` is
  /// network name.
  final String network;

  /// Deprecated: If true, expose the Endpoint via private service connect.
  ///
  /// Only one of the fields,
  /// `network` or
  /// `enable_private_service_connect`,
  /// can be set.
  final bool enablePrivateServiceConnect;

  /// Optional. Configuration for private service connect.
  ///
  /// `network` and
  /// `private_service_connect_config`
  /// are mutually exclusive.
  final PrivateServiceConnectConfig? privateServiceConnectConfig;

  /// Output only. Resource name of the Model Monitoring job associated with this
  /// Endpoint if monitoring is enabled by
  /// `JobService.CreateModelDeploymentMonitoringJob`.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String modelDeploymentMonitoringJob;

  /// Configures the request-response logging for online prediction.
  final PredictRequestResponseLoggingConfig?
  predictRequestResponseLoggingConfig;

  /// If true, the endpoint will be exposed through a dedicated
  /// DNS [Endpoint.dedicated_endpoint_dns]. Your request to the dedicated DNS
  /// will be isolated from other users' traffic and will have better performance
  /// and reliability.
  /// Note: Once you enabled dedicated endpoint, you won't be able to send
  /// request to the shared DNS {region}-aiplatform.googleapis.com. The
  /// limitation will be removed soon.
  final bool dedicatedEndpointEnabled;

  /// Output only. DNS of the dedicated endpoint. Will only be populated if
  /// dedicated_endpoint_enabled is true. Depending on the features enabled, uid
  /// might be a random number or a string. For example, if fast_tryout is
  /// enabled, uid will be fasttryout. Format:
  /// `https://{endpoint_id}.{region}-{uid}.prediction.vertexai.goog`.
  final String dedicatedEndpointDns;

  /// Configurations that are applied to the endpoint for online prediction.
  final ClientConnectionConfig? clientConnectionConfig;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  /// Optional. Configuration for GenAiAdvancedFeatures. If the endpoint is
  /// serving GenAI models, advanced features like native RAG integration can be
  /// configured. Currently, only Model Garden models are supported.
  final GenAiAdvancedFeaturesConfig? genAiAdvancedFeaturesConfig;

  /// If true, the model server will be isolated from the external internet.
  final bool privateModelServerEnabled;

  Endpoint({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.deployedModels = const [],
    this.trafficSplit = const {},
    this.etag = '',
    this.labels = const {},
    this.createTime,
    this.updateTime,
    this.encryptionSpec,
    this.network = '',
    this.enablePrivateServiceConnect = false,
    this.privateServiceConnectConfig,
    this.modelDeploymentMonitoringJob = '',
    this.predictRequestResponseLoggingConfig,
    this.dedicatedEndpointEnabled = false,
    this.dedicatedEndpointDns = '',
    this.clientConnectionConfig,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
    this.genAiAdvancedFeaturesConfig,
    this.privateModelServerEnabled = false,
  }) : super(fullyQualifiedName);

  factory Endpoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Endpoint(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedModels: switch (json['deployedModels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DeployedModel.fromJson(i)],
        _ => throw const FormatException('"deployedModels" is not a list'),
      },
      trafficSplit: switch (json['trafficSplit']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries) decodeString(e.key): decodeInt(e.value),
        },
        _ => throw const FormatException('"trafficSplit" is not an object'),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      network: switch (json['network']) {
        null => '',
        Object $1 => decodeString($1),
      },
      enablePrivateServiceConnect:
          switch (json['enablePrivateServiceConnect']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      privateServiceConnectConfig:
          switch (json['privateServiceConnectConfig']) {
            null => null,
            Object $1 => PrivateServiceConnectConfig.fromJson($1),
          },
      modelDeploymentMonitoringJob:
          switch (json['modelDeploymentMonitoringJob']) {
            null => '',
            Object $1 => decodeString($1),
          },
      predictRequestResponseLoggingConfig:
          switch (json['predictRequestResponseLoggingConfig']) {
            null => null,
            Object $1 => PredictRequestResponseLoggingConfig.fromJson($1),
          },
      dedicatedEndpointEnabled: switch (json['dedicatedEndpointEnabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      dedicatedEndpointDns: switch (json['dedicatedEndpointDns']) {
        null => '',
        Object $1 => decodeString($1),
      },
      clientConnectionConfig: switch (json['clientConnectionConfig']) {
        null => null,
        Object $1 => ClientConnectionConfig.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      genAiAdvancedFeaturesConfig:
          switch (json['genAiAdvancedFeaturesConfig']) {
            null => null,
            Object $1 => GenAiAdvancedFeaturesConfig.fromJson($1),
          },
      privateModelServerEnabled: switch (json['privateModelServerEnabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (deployedModels.isNotDefault)
      'deployedModels': encodeList(deployedModels),
    if (trafficSplit.isNotDefault) 'trafficSplit': trafficSplit,
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (network.isNotDefault) 'network': network,
    if (enablePrivateServiceConnect.isNotDefault)
      'enablePrivateServiceConnect': enablePrivateServiceConnect,
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
    if (modelDeploymentMonitoringJob.isNotDefault)
      'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob,
    if (predictRequestResponseLoggingConfig != null)
      'predictRequestResponseLoggingConfig':
          predictRequestResponseLoggingConfig!.toJson(),
    if (dedicatedEndpointEnabled.isNotDefault)
      'dedicatedEndpointEnabled': dedicatedEndpointEnabled,
    if (dedicatedEndpointDns.isNotDefault)
      'dedicatedEndpointDns': dedicatedEndpointDns,
    if (clientConnectionConfig != null)
      'clientConnectionConfig': clientConnectionConfig!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
    if (genAiAdvancedFeaturesConfig != null)
      'genAiAdvancedFeaturesConfig': genAiAdvancedFeaturesConfig!.toJson(),
    if (privateModelServerEnabled.isNotDefault)
      'privateModelServerEnabled': privateModelServerEnabled,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'etag=$etag',
      'network=$network',
      'enablePrivateServiceConnect=$enablePrivateServiceConnect',
      'modelDeploymentMonitoringJob=$modelDeploymentMonitoringJob',
      'dedicatedEndpointEnabled=$dedicatedEndpointEnabled',
      'dedicatedEndpointDns=$dedicatedEndpointDns',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
      'privateModelServerEnabled=$privateModelServerEnabled',
    ].join(',');
    return 'Endpoint($contents)';
  }
}

/// A deployment of a Model. Endpoints contain one or more DeployedModels.
final class DeployedModel extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedModel';

  /// A description of resources that are dedicated to the DeployedModel, and
  /// that need a higher degree of manual configuration.
  final DedicatedResources? dedicatedResources;

  /// A description of resources that to large degree are decided by Vertex
  /// AI, and require only a modest additional configuration.
  final AutomaticResources? automaticResources;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String? sharedResources;

  /// Immutable. The ID of the DeployedModel. If not provided upon deployment,
  /// Vertex AI will generate a value for this ID.
  ///
  /// This value should be 1-10 characters, and valid characters are `/[0-9]/`.
  final String id;

  /// The resource name of the Model that this is the deployment of. Note that
  /// the Model may be in a different location than the DeployedModel's Endpoint.
  ///
  /// The resource name may contain version id or version alias to specify the
  /// version.
  ///  Example: `projects/{project}/locations/{location}/models/{model}@2`
  ///              or
  ///            `projects/{project}/locations/{location}/models/{model}@golden`
  /// if no version is specified, the default version will be deployed.
  final String model;

  /// Output only. The version ID of the model that is deployed.
  final String modelVersionId;

  /// The display name of the DeployedModel. If not provided upon creation,
  /// the Model's display_name is used.
  final String displayName;

  /// Output only. Timestamp when the DeployedModel was created.
  final protobuf.Timestamp? createTime;

  /// Explanation configuration for this DeployedModel.
  ///
  /// When deploying a Model using
  /// `EndpointService.DeployModel`,
  /// this value overrides the value of
  /// `Model.explanation_spec`.
  /// All fields of
  /// `explanation_spec`
  /// are optional in the request. If a field of
  /// `explanation_spec`
  /// is not populated, the value of the same field of
  /// `Model.explanation_spec`
  /// is inherited. If the corresponding
  /// `Model.explanation_spec`
  /// is not populated, all fields of the
  /// `explanation_spec`
  /// will be used for the explanation configuration.
  final ExplanationSpec? explanationSpec;

  /// If true, deploy the model without explainable feature, regardless the
  /// existence of
  /// `Model.explanation_spec`
  /// or
  /// `explanation_spec`.
  final bool disableExplanations;

  /// The service account that the DeployedModel's container runs as. Specify the
  /// email address of the service account. If this service account is not
  /// specified, the container runs as a service account that doesn't have access
  /// to the resource project.
  ///
  /// Users deploying the Model must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  final String serviceAccount;

  /// If true, the container of the DeployedModel instances will send `stderr`
  /// and `stdout` streams to Cloud Logging.
  ///
  /// Only supported for custom-trained Models and AutoML Tabular Models.
  final bool enableContainerLogging;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to
  /// Cloud Logging by default. Please note that the logs incur cost,
  /// which are subject to [Cloud Logging
  /// pricing](https://cloud.google.com/logging/pricing).
  ///
  /// User can disable container logging by setting this flag to true.
  final bool disableContainerLogging;

  /// If true, online prediction access logs are sent to Cloud
  /// Logging.
  /// These logs are like standard server access logs, containing
  /// information like timestamp and latency for each prediction request.
  ///
  /// Note that logs may incur a cost, especially if your project
  /// receives prediction requests at a high queries per second rate (QPS).
  /// Estimate your costs before enabling this option.
  final bool enableAccessLogging;

  /// Output only. Provide paths for users to send predict/explain/health
  /// requests directly to the deployed model services running on Cloud via
  /// private services access. This field is populated if
  /// `network` is configured.
  final PrivateEndpoints? privateEndpoints;

  /// Configuration for faster model deployment.
  final FasterDeploymentConfig? fasterDeploymentConfig;

  /// Options for configuring rolling deployments.
  final RolloutOptions? rolloutOptions;

  /// Output only. Runtime status of the deployed model.
  final DeployedModel_Status? status;

  /// System labels to apply to Model Garden deployments.
  /// System labels are managed by Google for internal use only.
  final Map<String, String> systemLabels;

  /// The checkpoint id of the model.
  final String checkpointId;

  /// Optional. Spec for configuring speculative decoding.
  final SpeculativeDecodingSpec? speculativeDecodingSpec;

  DeployedModel({
    this.dedicatedResources,
    this.automaticResources,
    this.sharedResources,
    this.id = '',
    this.model = '',
    this.modelVersionId = '',
    this.displayName = '',
    this.createTime,
    this.explanationSpec,
    this.disableExplanations = false,
    this.serviceAccount = '',
    this.enableContainerLogging = false,
    this.disableContainerLogging = false,
    this.enableAccessLogging = false,
    this.privateEndpoints,
    this.fasterDeploymentConfig,
    this.rolloutOptions,
    this.status,
    this.systemLabels = const {},
    this.checkpointId = '',
    this.speculativeDecodingSpec,
  }) : super(fullyQualifiedName);

  factory DeployedModel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployedModel(
      dedicatedResources: switch (json['dedicatedResources']) {
        null => null,
        Object $1 => DedicatedResources.fromJson($1),
      },
      automaticResources: switch (json['automaticResources']) {
        null => null,
        Object $1 => AutomaticResources.fromJson($1),
      },
      sharedResources: switch (json['sharedResources']) {
        null => null,
        Object $1 => decodeString($1),
      },
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersionId: switch (json['modelVersionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      explanationSpec: switch (json['explanationSpec']) {
        null => null,
        Object $1 => ExplanationSpec.fromJson($1),
      },
      disableExplanations: switch (json['disableExplanations']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
      enableContainerLogging: switch (json['enableContainerLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      disableContainerLogging: switch (json['disableContainerLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      enableAccessLogging: switch (json['enableAccessLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      privateEndpoints: switch (json['privateEndpoints']) {
        null => null,
        Object $1 => PrivateEndpoints.fromJson($1),
      },
      fasterDeploymentConfig: switch (json['fasterDeploymentConfig']) {
        null => null,
        Object $1 => FasterDeploymentConfig.fromJson($1),
      },
      rolloutOptions: switch (json['rolloutOptions']) {
        null => null,
        Object $1 => RolloutOptions.fromJson($1),
      },
      status: switch (json['status']) {
        null => null,
        Object $1 => DeployedModel_Status.fromJson($1),
      },
      systemLabels: switch (json['systemLabels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"systemLabels" is not an object'),
      },
      checkpointId: switch (json['checkpointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      speculativeDecodingSpec: switch (json['speculativeDecodingSpec']) {
        null => null,
        Object $1 => SpeculativeDecodingSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dedicatedResources != null)
      'dedicatedResources': dedicatedResources!.toJson(),
    if (automaticResources != null)
      'automaticResources': automaticResources!.toJson(),
    if (sharedResources != null) 'sharedResources': sharedResources,
    if (id.isNotDefault) 'id': id,
    if (model.isNotDefault) 'model': model,
    if (modelVersionId.isNotDefault) 'modelVersionId': modelVersionId,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
    if (disableExplanations.isNotDefault)
      'disableExplanations': disableExplanations,
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
    if (enableContainerLogging.isNotDefault)
      'enableContainerLogging': enableContainerLogging,
    if (disableContainerLogging.isNotDefault)
      'disableContainerLogging': disableContainerLogging,
    if (enableAccessLogging.isNotDefault)
      'enableAccessLogging': enableAccessLogging,
    if (privateEndpoints != null)
      'privateEndpoints': privateEndpoints!.toJson(),
    if (fasterDeploymentConfig != null)
      'fasterDeploymentConfig': fasterDeploymentConfig!.toJson(),
    if (rolloutOptions != null) 'rolloutOptions': rolloutOptions!.toJson(),
    if (status != null) 'status': status!.toJson(),
    if (systemLabels.isNotDefault) 'systemLabels': systemLabels,
    if (checkpointId.isNotDefault) 'checkpointId': checkpointId,
    if (speculativeDecodingSpec != null)
      'speculativeDecodingSpec': speculativeDecodingSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (sharedResources != null) 'sharedResources=$sharedResources',
      'id=$id',
      'model=$model',
      'modelVersionId=$modelVersionId',
      'displayName=$displayName',
      'disableExplanations=$disableExplanations',
      'serviceAccount=$serviceAccount',
      'enableContainerLogging=$enableContainerLogging',
      'disableContainerLogging=$disableContainerLogging',
      'enableAccessLogging=$enableAccessLogging',
      'checkpointId=$checkpointId',
    ].join(',');
    return 'DeployedModel($contents)';
  }
}

/// Runtime status of the deployed model.
final class DeployedModel_Status extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedModel.Status';

  /// Output only. The latest deployed model's status message (if any).
  final String message;

  /// Output only. The time at which the status was last updated.
  final protobuf.Timestamp? lastUpdateTime;

  /// Output only. The number of available replicas of the deployed model.
  final int availableReplicaCount;

  DeployedModel_Status({
    this.message = '',
    this.lastUpdateTime,
    this.availableReplicaCount = 0,
  }) : super(fullyQualifiedName);

  factory DeployedModel_Status.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployedModel_Status(
      message: switch (json['message']) {
        null => '',
        Object $1 => decodeString($1),
      },
      lastUpdateTime: switch (json['lastUpdateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      availableReplicaCount: switch (json['availableReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (message.isNotDefault) 'message': message,
    if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!.toJson(),
    if (availableReplicaCount.isNotDefault)
      'availableReplicaCount': availableReplicaCount,
  };

  @override
  String toString() {
    final contents = [
      'message=$message',
      'availableReplicaCount=$availableReplicaCount',
    ].join(',');
    return 'Status($contents)';
  }
}

/// PrivateEndpoints proto is used to provide paths for users to send
/// requests privately.
/// To send request via private service access, use predict_http_uri,
/// explain_http_uri or health_http_uri. To send request via private service
/// connect, use service_attachment.
final class PrivateEndpoints extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PrivateEndpoints';

  /// Output only. Http(s) path to send prediction requests.
  final String predictHttpUri;

  /// Output only. Http(s) path to send explain requests.
  final String explainHttpUri;

  /// Output only. Http(s) path to send health check requests.
  final String healthHttpUri;

  /// Output only. The name of the service attachment resource. Populated if
  /// private service connect is enabled.
  final String serviceAttachment;

  PrivateEndpoints({
    this.predictHttpUri = '',
    this.explainHttpUri = '',
    this.healthHttpUri = '',
    this.serviceAttachment = '',
  }) : super(fullyQualifiedName);

  factory PrivateEndpoints.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PrivateEndpoints(
      predictHttpUri: switch (json['predictHttpUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      explainHttpUri: switch (json['explainHttpUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      healthHttpUri: switch (json['healthHttpUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAttachment: switch (json['serviceAttachment']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (predictHttpUri.isNotDefault) 'predictHttpUri': predictHttpUri,
    if (explainHttpUri.isNotDefault) 'explainHttpUri': explainHttpUri,
    if (healthHttpUri.isNotDefault) 'healthHttpUri': healthHttpUri,
    if (serviceAttachment.isNotDefault) 'serviceAttachment': serviceAttachment,
  };

  @override
  String toString() {
    final contents = [
      'predictHttpUri=$predictHttpUri',
      'explainHttpUri=$explainHttpUri',
      'healthHttpUri=$healthHttpUri',
      'serviceAttachment=$serviceAttachment',
    ].join(',');
    return 'PrivateEndpoints($contents)';
  }
}

/// Configuration for logging request-response to a BigQuery table.
final class PredictRequestResponseLoggingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictRequestResponseLoggingConfig';

  /// If logging is enabled or not.
  final bool enabled;

  /// Percentage of requests to be logged, expressed as a fraction in
  /// range(0,1].
  final double samplingRate;

  /// BigQuery table for logging.
  /// If only given a project, a new dataset will be created with name
  /// `logging_<endpoint-display-name>_<endpoint-id>` where
  /// <endpoint-display-name> will be made BigQuery-dataset-name compatible (e.g.
  /// most special characters will become underscores). If no table name is
  /// given, a new table will be created with name `request_response_logging`
  final BigQueryDestination? bigqueryDestination;

  /// Output only. The schema version used in creating the BigQuery table for the
  /// request response logging. The versions are "v1" and "v2". The current
  /// default version is "v1".
  final String requestResponseLoggingSchemaVersion;

  /// This field is used for large models. If true, in addition to the
  /// original large model logs, logs will be converted in OTel schema format,
  /// and saved in otel_log column. Default value is false.
  final bool enableOtelLogging;

  PredictRequestResponseLoggingConfig({
    this.enabled = false,
    this.samplingRate = 0,
    this.bigqueryDestination,
    this.requestResponseLoggingSchemaVersion = '',
    this.enableOtelLogging = false,
  }) : super(fullyQualifiedName);

  factory PredictRequestResponseLoggingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PredictRequestResponseLoggingConfig(
      enabled: switch (json['enabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      samplingRate: switch (json['samplingRate']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      bigqueryDestination: switch (json['bigqueryDestination']) {
        null => null,
        Object $1 => BigQueryDestination.fromJson($1),
      },
      requestResponseLoggingSchemaVersion:
          switch (json['requestResponseLoggingSchemaVersion']) {
            null => '',
            Object $1 => decodeString($1),
          },
      enableOtelLogging: switch (json['enableOtelLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enabled.isNotDefault) 'enabled': enabled,
    if (samplingRate.isNotDefault) 'samplingRate': encodeDouble(samplingRate),
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!.toJson(),
    if (requestResponseLoggingSchemaVersion.isNotDefault)
      'requestResponseLoggingSchemaVersion':
          requestResponseLoggingSchemaVersion,
    if (enableOtelLogging.isNotDefault) 'enableOtelLogging': enableOtelLogging,
  };

  @override
  String toString() {
    final contents = [
      'enabled=$enabled',
      'samplingRate=$samplingRate',
      'requestResponseLoggingSchemaVersion=$requestResponseLoggingSchemaVersion',
      'enableOtelLogging=$enableOtelLogging',
    ].join(',');
    return 'PredictRequestResponseLoggingConfig($contents)';
  }
}

/// This message contains configs of a publisher model.
final class PublisherModelConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModelConfig';

  /// The prediction request/response logging config.
  final PredictRequestResponseLoggingConfig? loggingConfig;

  PublisherModelConfig({this.loggingConfig}) : super(fullyQualifiedName);

  factory PublisherModelConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModelConfig(
      loggingConfig: switch (json['loggingConfig']) {
        null => null,
        Object $1 => PredictRequestResponseLoggingConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (loggingConfig != null) 'loggingConfig': loggingConfig!.toJson(),
  };

  @override
  String toString() => 'PublisherModelConfig()';
}

/// Configurations (e.g. inference timeout) that are applied on your endpoints.
final class ClientConnectionConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ClientConnectionConfig';

  /// Customizable online prediction request timeout.
  final protobuf.Duration? inferenceTimeout;

  ClientConnectionConfig({this.inferenceTimeout}) : super(fullyQualifiedName);

  factory ClientConnectionConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ClientConnectionConfig(
      inferenceTimeout: switch (json['inferenceTimeout']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (inferenceTimeout != null)
      'inferenceTimeout': inferenceTimeout!.toJson(),
  };

  @override
  String toString() => 'ClientConnectionConfig()';
}

/// Configuration for faster model deployment.
final class FasterDeploymentConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FasterDeploymentConfig';

  /// If true, enable fast tryout feature for this deployed model.
  final bool fastTryoutEnabled;

  FasterDeploymentConfig({this.fastTryoutEnabled = false})
    : super(fullyQualifiedName);

  factory FasterDeploymentConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FasterDeploymentConfig(
      fastTryoutEnabled: switch (json['fastTryoutEnabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (fastTryoutEnabled.isNotDefault) 'fastTryoutEnabled': fastTryoutEnabled,
  };

  @override
  String toString() {
    final contents = ['fastTryoutEnabled=$fastTryoutEnabled'].join(',');
    return 'FasterDeploymentConfig($contents)';
  }
}

/// Configuration for rolling deployments.
final class RolloutOptions extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RolloutOptions';

  /// Absolute count of replicas allowed to be unavailable.
  final int? maxUnavailableReplicas;

  /// Percentage of replicas allowed to be unavailable.
  /// For autoscaling deployments, this refers to the target replica count.
  final int? maxUnavailablePercentage;

  /// Absolute count of allowed additional replicas.
  final int? maxSurgeReplicas;

  /// Percentage of allowed additional replicas.
  /// For autoscaling deployments, this refers to the target replica count.
  final int? maxSurgePercentage;

  /// ID of the DeployedModel that this deployment should replace.
  final String previousDeployedModel;

  /// Output only. Read-only. Revision number determines the relative priority of
  /// DeployedModels in the same rollout. The DeployedModel with the largest
  /// revision number specifies the intended state of the deployment.
  final int revisionNumber;

  RolloutOptions({
    this.maxUnavailableReplicas,
    this.maxUnavailablePercentage,
    this.maxSurgeReplicas,
    this.maxSurgePercentage,
    this.previousDeployedModel = '',
    this.revisionNumber = 0,
  }) : super(fullyQualifiedName);

  factory RolloutOptions.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RolloutOptions(
      maxUnavailableReplicas: switch (json['maxUnavailableReplicas']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      maxUnavailablePercentage: switch (json['maxUnavailablePercentage']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      maxSurgeReplicas: switch (json['maxSurgeReplicas']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      maxSurgePercentage: switch (json['maxSurgePercentage']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      previousDeployedModel: switch (json['previousDeployedModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      revisionNumber: switch (json['revisionNumber']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxUnavailableReplicas != null)
      'maxUnavailableReplicas': maxUnavailableReplicas,
    if (maxUnavailablePercentage != null)
      'maxUnavailablePercentage': maxUnavailablePercentage,
    if (maxSurgeReplicas != null) 'maxSurgeReplicas': maxSurgeReplicas,
    if (maxSurgePercentage != null) 'maxSurgePercentage': maxSurgePercentage,
    if (previousDeployedModel.isNotDefault)
      'previousDeployedModel': previousDeployedModel,
    if (revisionNumber.isNotDefault) 'revisionNumber': revisionNumber,
  };

  @override
  String toString() {
    final contents = [
      if (maxUnavailableReplicas != null)
        'maxUnavailableReplicas=$maxUnavailableReplicas',
      if (maxUnavailablePercentage != null)
        'maxUnavailablePercentage=$maxUnavailablePercentage',
      if (maxSurgeReplicas != null) 'maxSurgeReplicas=$maxSurgeReplicas',
      if (maxSurgePercentage != null) 'maxSurgePercentage=$maxSurgePercentage',
      'previousDeployedModel=$previousDeployedModel',
      'revisionNumber=$revisionNumber',
    ].join(',');
    return 'RolloutOptions($contents)';
  }
}

/// Configuration for GenAiAdvancedFeatures.
final class GenAiAdvancedFeaturesConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenAiAdvancedFeaturesConfig';

  /// Configuration for Retrieval Augmented Generation feature.
  final GenAiAdvancedFeaturesConfig_RagConfig? ragConfig;

  GenAiAdvancedFeaturesConfig({this.ragConfig}) : super(fullyQualifiedName);

  factory GenAiAdvancedFeaturesConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenAiAdvancedFeaturesConfig(
      ragConfig: switch (json['ragConfig']) {
        null => null,
        Object $1 => GenAiAdvancedFeaturesConfig_RagConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (ragConfig != null) 'ragConfig': ragConfig!.toJson()};

  @override
  String toString() => 'GenAiAdvancedFeaturesConfig()';
}

/// Configuration for Retrieval Augmented Generation feature.
final class GenAiAdvancedFeaturesConfig_RagConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenAiAdvancedFeaturesConfig.RagConfig';

  /// If true, enable Retrieval Augmented Generation in ChatCompletion request.
  /// Once enabled, the endpoint will be identified as GenAI endpoint and
  /// Arthedain router will be used.
  final bool enableRag;

  GenAiAdvancedFeaturesConfig_RagConfig({this.enableRag = false})
    : super(fullyQualifiedName);

  factory GenAiAdvancedFeaturesConfig_RagConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenAiAdvancedFeaturesConfig_RagConfig(
      enableRag: switch (json['enableRag']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {if (enableRag.isNotDefault) 'enableRag': enableRag};

  @override
  String toString() {
    final contents = ['enableRag=$enableRag'].join(',');
    return 'RagConfig($contents)';
  }
}

/// Configuration for Speculative Decoding.
final class SpeculativeDecodingSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpeculativeDecodingSpec';

  /// draft model speculation.
  final SpeculativeDecodingSpec_DraftModelSpeculation? draftModelSpeculation;

  /// N-Gram speculation.
  final SpeculativeDecodingSpec_NgramSpeculation? ngramSpeculation;

  /// The number of speculative tokens to generate at each step.
  final int speculativeTokenCount;

  SpeculativeDecodingSpec({
    this.draftModelSpeculation,
    this.ngramSpeculation,
    this.speculativeTokenCount = 0,
  }) : super(fullyQualifiedName);

  factory SpeculativeDecodingSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SpeculativeDecodingSpec(
      draftModelSpeculation: switch (json['draftModelSpeculation']) {
        null => null,
        Object $1 => SpeculativeDecodingSpec_DraftModelSpeculation.fromJson($1),
      },
      ngramSpeculation: switch (json['ngramSpeculation']) {
        null => null,
        Object $1 => SpeculativeDecodingSpec_NgramSpeculation.fromJson($1),
      },
      speculativeTokenCount: switch (json['speculativeTokenCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (draftModelSpeculation != null)
      'draftModelSpeculation': draftModelSpeculation!.toJson(),
    if (ngramSpeculation != null)
      'ngramSpeculation': ngramSpeculation!.toJson(),
    if (speculativeTokenCount.isNotDefault)
      'speculativeTokenCount': speculativeTokenCount,
  };

  @override
  String toString() {
    final contents = ['speculativeTokenCount=$speculativeTokenCount'].join(',');
    return 'SpeculativeDecodingSpec($contents)';
  }
}

/// Draft model speculation works by using the smaller model to generate
/// candidate tokens for speculative decoding.
final class SpeculativeDecodingSpec_DraftModelSpeculation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpeculativeDecodingSpec.DraftModelSpeculation';

  /// Required. The resource name of the draft model.
  final String draftModel;

  SpeculativeDecodingSpec_DraftModelSpeculation({required this.draftModel})
    : super(fullyQualifiedName);

  factory SpeculativeDecodingSpec_DraftModelSpeculation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SpeculativeDecodingSpec_DraftModelSpeculation(
      draftModel: switch (json['draftModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'draftModel': draftModel};

  @override
  String toString() {
    final contents = ['draftModel=$draftModel'].join(',');
    return 'DraftModelSpeculation($contents)';
  }
}

/// N-Gram speculation works by trying to find matching tokens in the
/// previous prompt sequence and use those as speculation for generating
/// new tokens.
final class SpeculativeDecodingSpec_NgramSpeculation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpeculativeDecodingSpec.NgramSpeculation';

  /// The number of last N input tokens used as ngram to search/match
  /// against the previous prompt sequence.
  /// This is equal to the N in N-Gram.
  /// The default value is 3 if not specified.
  final int ngramSize;

  SpeculativeDecodingSpec_NgramSpeculation({this.ngramSize = 0})
    : super(fullyQualifiedName);

  factory SpeculativeDecodingSpec_NgramSpeculation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SpeculativeDecodingSpec_NgramSpeculation(
      ngramSize: switch (json['ngramSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {if (ngramSize.isNotDefault) 'ngramSize': ngramSize};

  @override
  String toString() {
    final contents = ['ngramSize=$ngramSize'].join(',');
    return 'NgramSpeculation($contents)';
  }
}

/// Request message for
/// `EndpointService.CreateEndpoint`.
final class CreateEndpointRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateEndpointRequest';

  /// Required. The resource name of the Location to create the Endpoint in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Endpoint to create.
  final Endpoint? endpoint;

  /// Immutable. The ID to use for endpoint, which will become the final
  /// component of the endpoint resource name.
  /// If not provided, Vertex AI will generate a value for this ID.
  ///
  /// If the first character is a letter, this value may be up to 63 characters,
  /// and valid characters are `[a-z0-9-]`. The last character must be a letter
  /// or number.
  ///
  /// If the first character is a number, this value may be up to 9 characters,
  /// and valid characters are `[0-9]` with no leading zeros.
  ///
  /// When using HTTP/JSON, this field is populated
  /// based on a query string argument, such as `?endpoint_id=12345`. This is the
  /// fallback for fields that are not included in either the URI or the body.
  final String endpointId;

  CreateEndpointRequest({
    required this.parent,
    required this.endpoint,
    this.endpointId = '',
  }) : super(fullyQualifiedName);

  factory CreateEndpointRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateEndpointRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      endpoint: switch (json['endpoint']) {
        null => null,
        Object $1 => Endpoint.fromJson($1),
      },
      endpointId: switch (json['endpointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (endpoint != null) 'endpoint': endpoint!.toJson(),
    if (endpointId.isNotDefault) 'endpointId': endpointId,
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'endpointId=$endpointId'].join(',');
    return 'CreateEndpointRequest($contents)';
  }
}

/// Runtime operation information for
/// `EndpointService.CreateEndpoint`.
final class CreateEndpointOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateEndpointOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. The deployment stage of the model. Only populated if this
  /// CreateEndpoint request deploys a model at the same time.
  final DeploymentStage deploymentStage;

  CreateEndpointOperationMetadata({
    this.genericMetadata,
    this.deploymentStage = DeploymentStage.$default,
  }) : super(fullyQualifiedName);

  factory CreateEndpointOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateEndpointOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      deploymentStage: switch (json['deploymentStage']) {
        null => DeploymentStage.$default,
        Object $1 => DeploymentStage.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (deploymentStage.isNotDefault)
      'deploymentStage': deploymentStage.toJson(),
  };

  @override
  String toString() {
    final contents = ['deploymentStage=$deploymentStage'].join(',');
    return 'CreateEndpointOperationMetadata($contents)';
  }
}

/// Request message for
/// `EndpointService.GetEndpoint`
final class GetEndpointRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetEndpointRequest';

  /// Required. The name of the Endpoint resource.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String name;

  GetEndpointRequest({required this.name}) : super(fullyQualifiedName);

  factory GetEndpointRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetEndpointRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetEndpointRequest($contents)';
  }
}

/// Request message for
/// `EndpointService.ListEndpoints`.
final class ListEndpointsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEndpointsRequest';

  /// Required. The resource name of the Location from which to list the
  /// Endpoints. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `endpoint` supports `=` and `!=`. `endpoint` represents the Endpoint
  ///     ID, i.e. the last segment of the Endpoint's
  ///     [resource name][google.cloud.aiplatform.v1beta1.Endpoint.name].
  ///   * `display_name` supports `=` and `!=`.
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:*` or `labels:key` - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///   * `base_model_name` only supports `=`.
  ///
  /// Some examples:
  ///
  ///   * `endpoint=1`
  ///   * `displayName="myDisplayName"`
  ///   * `labels.myKey="myValue"`
  ///   * `baseModelName="text-bison"`
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListEndpointsResponse.next_page_token`
  /// of the previous
  /// `EndpointService.ListEndpoints`
  /// call.
  final String pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListEndpointsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListEndpointsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListEndpointsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListEndpointsRequest($contents)';
  }
}

/// Response message for
/// `EndpointService.ListEndpoints`.
final class ListEndpointsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEndpointsResponse';

  /// List of Endpoints in the requested page.
  final List<Endpoint> endpoints;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListEndpointsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListEndpointsResponse({this.endpoints = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListEndpointsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListEndpointsResponse(
      endpoints: switch (json['endpoints']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Endpoint.fromJson(i)],
        _ => throw const FormatException('"endpoints" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (endpoints.isNotDefault) 'endpoints': encodeList(endpoints),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListEndpointsResponse($contents)';
  }
}

/// Request message for
/// `EndpointService.UpdateEndpoint`.
final class UpdateEndpointRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateEndpointRequest';

  /// Required. The Endpoint which replaces the resource on the server.
  final Endpoint? endpoint;

  /// Required. The update mask applies to the resource. See
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateEndpointRequest({required this.endpoint, required this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateEndpointRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateEndpointRequest(
      endpoint: switch (json['endpoint']) {
        null => null,
        Object $1 => Endpoint.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (endpoint != null) 'endpoint': endpoint!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateEndpointRequest()';
}

/// Request message for
/// `EndpointService.UpdateEndpointLongRunning`.
final class UpdateEndpointLongRunningRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateEndpointLongRunningRequest';

  /// Required. The Endpoint which replaces the resource on the server. Currently
  /// we only support updating the `client_connection_config` field, all the
  /// other fields' update will be blocked.
  final Endpoint? endpoint;

  UpdateEndpointLongRunningRequest({required this.endpoint})
    : super(fullyQualifiedName);

  factory UpdateEndpointLongRunningRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateEndpointLongRunningRequest(
      endpoint: switch (json['endpoint']) {
        null => null,
        Object $1 => Endpoint.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (endpoint != null) 'endpoint': endpoint!.toJson()};

  @override
  String toString() => 'UpdateEndpointLongRunningRequest()';
}

/// Runtime operation information for
/// `EndpointService.UpdateEndpointLongRunning`.
final class UpdateEndpointOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateEndpointOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateEndpointOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateEndpointOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateEndpointOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateEndpointOperationMetadata()';
}

/// Request message for
/// `EndpointService.DeleteEndpoint`.
final class DeleteEndpointRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteEndpointRequest';

  /// Required. The name of the Endpoint resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String name;

  DeleteEndpointRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteEndpointRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteEndpointRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteEndpointRequest($contents)';
  }
}

/// Request message for
/// `EndpointService.DeployModel`.
final class DeployModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployModelRequest';

  /// Required. The name of the Endpoint resource into which to deploy a Model.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The DeployedModel to be created within the Endpoint. Note that
  /// `Endpoint.traffic_split`
  /// must be updated for the DeployedModel to start receiving traffic, either as
  /// part of this call, or via
  /// `EndpointService.UpdateEndpoint`.
  final DeployedModel? deployedModel;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If this field is non-empty, then the Endpoint's
  /// `traffic_split`
  /// will be overwritten with it. To refer to the ID of the just being deployed
  /// Model, a "0" should be used, and the actual ID of the new DeployedModel
  /// will be filled in its place by this method. The traffic percentage values
  /// must add up to 100.
  ///
  /// If this field is empty, then the Endpoint's
  /// `traffic_split` is
  /// not updated.
  final Map<String, int> trafficSplit;

  DeployModelRequest({
    required this.endpoint,
    required this.deployedModel,
    this.trafficSplit = const {},
  }) : super(fullyQualifiedName);

  factory DeployModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployModelRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedModel: switch (json['deployedModel']) {
        null => null,
        Object $1 => DeployedModel.fromJson($1),
      },
      trafficSplit: switch (json['trafficSplit']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries) decodeString(e.key): decodeInt(e.value),
        },
        _ => throw const FormatException('"trafficSplit" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (deployedModel != null) 'deployedModel': deployedModel!.toJson(),
    if (trafficSplit.isNotDefault) 'trafficSplit': trafficSplit,
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'DeployModelRequest($contents)';
  }
}

/// Response message for
/// `EndpointService.DeployModel`.
final class DeployModelResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployModelResponse';

  /// The DeployedModel that had been deployed in the Endpoint.
  final DeployedModel? deployedModel;

  DeployModelResponse({this.deployedModel}) : super(fullyQualifiedName);

  factory DeployModelResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployModelResponse(
      deployedModel: switch (json['deployedModel']) {
        null => null,
        Object $1 => DeployedModel.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (deployedModel != null) 'deployedModel': deployedModel!.toJson(),
  };

  @override
  String toString() => 'DeployModelResponse()';
}

/// Runtime operation information for
/// `EndpointService.DeployModel`.
final class DeployModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. The deployment stage of the model.
  final DeploymentStage deploymentStage;

  DeployModelOperationMetadata({
    this.genericMetadata,
    this.deploymentStage = DeploymentStage.$default,
  }) : super(fullyQualifiedName);

  factory DeployModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      deploymentStage: switch (json['deploymentStage']) {
        null => DeploymentStage.$default,
        Object $1 => DeploymentStage.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (deploymentStage.isNotDefault)
      'deploymentStage': deploymentStage.toJson(),
  };

  @override
  String toString() {
    final contents = ['deploymentStage=$deploymentStage'].join(',');
    return 'DeployModelOperationMetadata($contents)';
  }
}

/// Request message for
/// `EndpointService.UndeployModel`.
final class UndeployModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployModelRequest';

  /// Required. The name of the Endpoint resource from which to undeploy a Model.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The ID of the DeployedModel to be undeployed from the Endpoint.
  final String deployedModelId;

  /// If this field is provided, then the Endpoint's
  /// `traffic_split`
  /// will be overwritten with it. If last DeployedModel is being undeployed from
  /// the Endpoint, the [Endpoint.traffic_split] will always end up empty when
  /// this call returns. A DeployedModel will be successfully undeployed only if
  /// it doesn't have any traffic assigned to it when this method executes, or if
  /// this field unassigns any traffic to it.
  final Map<String, int> trafficSplit;

  UndeployModelRequest({
    required this.endpoint,
    required this.deployedModelId,
    this.trafficSplit = const {},
  }) : super(fullyQualifiedName);

  factory UndeployModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UndeployModelRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedModelId: switch (json['deployedModelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      trafficSplit: switch (json['trafficSplit']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries) decodeString(e.key): decodeInt(e.value),
        },
        _ => throw const FormatException('"trafficSplit" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    'deployedModelId': deployedModelId,
    if (trafficSplit.isNotDefault) 'trafficSplit': trafficSplit,
  };

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      'deployedModelId=$deployedModelId',
    ].join(',');
    return 'UndeployModelRequest($contents)';
  }
}

/// Response message for
/// `EndpointService.UndeployModel`.
final class UndeployModelResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployModelResponse';

  UndeployModelResponse() : super(fullyQualifiedName);

  factory UndeployModelResponse.fromJson(Object? j) => UndeployModelResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'UndeployModelResponse()';
}

/// Request message for
/// `EndpointService.SetPublisherModelConfig`.
final class SetPublisherModelConfigRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SetPublisherModelConfigRequest';

  /// Required. The name of the publisher model, in the format of
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`.
  final String name;

  /// Required. The publisher model config.
  final PublisherModelConfig? publisherModelConfig;

  SetPublisherModelConfigRequest({
    required this.name,
    required this.publisherModelConfig,
  }) : super(fullyQualifiedName);

  factory SetPublisherModelConfigRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SetPublisherModelConfigRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      publisherModelConfig: switch (json['publisherModelConfig']) {
        null => null,
        Object $1 => PublisherModelConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (publisherModelConfig != null)
      'publisherModelConfig': publisherModelConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'SetPublisherModelConfigRequest($contents)';
  }
}

/// Runtime operation information for
/// `EndpointService.SetPublisherModelConfig`.
final class SetPublisherModelConfigOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SetPublisherModelConfigOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  SetPublisherModelConfigOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory SetPublisherModelConfigOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SetPublisherModelConfigOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'SetPublisherModelConfigOperationMetadata()';
}

/// Request message for
/// `EndpointService.FetchPublisherModelConfig`.
final class FetchPublisherModelConfigRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchPublisherModelConfigRequest';

  /// Required. The name of the publisher model, in the format of
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`.
  final String name;

  FetchPublisherModelConfigRequest({required this.name})
    : super(fullyQualifiedName);

  factory FetchPublisherModelConfigRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FetchPublisherModelConfigRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'FetchPublisherModelConfigRequest($contents)';
  }
}

/// Runtime operation information for
/// `EndpointService.UndeployModel`.
final class UndeployModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UndeployModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UndeployModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UndeployModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UndeployModelOperationMetadata()';
}

/// Request message for
/// `EndpointService.MutateDeployedModel`.
final class MutateDeployedModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedModelRequest';

  /// Required. The name of the Endpoint resource into which to mutate a
  /// DeployedModel. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The DeployedModel to be mutated within the Endpoint. Only the
  /// following fields can be mutated:
  ///
  /// * `min_replica_count` in either
  /// `DedicatedResources` or
  /// `AutomaticResources`
  /// * `max_replica_count` in either
  /// `DedicatedResources` or
  /// `AutomaticResources`
  /// * `required_replica_count` in
  /// `DedicatedResources`
  /// * `autoscaling_metric_specs`
  /// * `disable_container_logging` (v1 only)
  /// * `enable_container_logging` (v1beta1 only)
  final DeployedModel? deployedModel;

  /// Required. The update mask applies to the resource. See
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  MutateDeployedModelRequest({
    required this.endpoint,
    required this.deployedModel,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory MutateDeployedModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MutateDeployedModelRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedModel: switch (json['deployedModel']) {
        null => null,
        Object $1 => DeployedModel.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (deployedModel != null) 'deployedModel': deployedModel!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'MutateDeployedModelRequest($contents)';
  }
}

/// Response message for
/// `EndpointService.MutateDeployedModel`.
final class MutateDeployedModelResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedModelResponse';

  /// The DeployedModel that's being mutated.
  final DeployedModel? deployedModel;

  MutateDeployedModelResponse({this.deployedModel}) : super(fullyQualifiedName);

  factory MutateDeployedModelResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MutateDeployedModelResponse(
      deployedModel: switch (json['deployedModel']) {
        null => null,
        Object $1 => DeployedModel.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (deployedModel != null) 'deployedModel': deployedModel!.toJson(),
  };

  @override
  String toString() => 'MutateDeployedModelResponse()';
}

/// Runtime operation information for
/// `EndpointService.MutateDeployedModel`.
final class MutateDeployedModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  MutateDeployedModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory MutateDeployedModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MutateDeployedModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'MutateDeployedModelOperationMetadata()';
}

/// An entity type is a type of object in a system that needs to be modeled and
/// have stored information about. For example, driver is an entity type, and
/// driver0 is an instance of an entity type driver.
final class EntityType extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EntityType';

  /// Immutable. Name of the EntityType.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  ///
  /// The last part entity_type is assigned by the client. The entity_type can be
  /// up to 64 characters long and can consist only of ASCII Latin letters A-Z
  /// and a-z and underscore(_), and ASCII digits 0-9 starting with a letter. The
  /// value will be unique given a featurestore.
  final String name;

  /// Optional. Description of the EntityType.
  final String description;

  /// Output only. Timestamp when this EntityType was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this EntityType was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The labels with user-defined metadata to organize your
  /// EntityTypes.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one EntityType (System
  /// labels are excluded)."
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> labels;

  /// Optional. Used to perform a consistent read-modify-write updates. If not
  /// set, a blind "overwrite" update happens.
  final String etag;

  /// Optional. The default monitoring configuration for all Features with value
  /// type
  /// (`Feature.ValueType`)
  /// BOOL, STRING, DOUBLE or INT64 under this EntityType.
  ///
  /// If this is populated with
  /// [FeaturestoreMonitoringConfig.monitoring_interval] specified, snapshot
  /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is
  /// disabled.
  final FeaturestoreMonitoringConfig? monitoringConfig;

  /// Optional. Config for data retention policy in offline storage.
  /// TTL in days for feature values that will be stored in offline storage.
  /// The Feature Store offline storage periodically removes obsolete feature
  /// values older than `offline_storage_ttl_days` since the feature generation
  /// time. If unset (or explicitly set to 0), default to 4000 days TTL.
  final int offlineStorageTtlDays;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  EntityType({
    this.name = '',
    this.description = '',
    this.createTime,
    this.updateTime,
    this.labels = const {},
    this.etag = '',
    this.monitoringConfig,
    this.offlineStorageTtlDays = 0,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory EntityType.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EntityType(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      monitoringConfig: switch (json['monitoringConfig']) {
        null => null,
        Object $1 => FeaturestoreMonitoringConfig.fromJson($1),
      },
      offlineStorageTtlDays: switch (json['offlineStorageTtlDays']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (description.isNotDefault) 'description': description,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (etag.isNotDefault) 'etag': etag,
    if (monitoringConfig != null)
      'monitoringConfig': monitoringConfig!.toJson(),
    if (offlineStorageTtlDays.isNotDefault)
      'offlineStorageTtlDays': offlineStorageTtlDays,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'description=$description',
      'etag=$etag',
      'offlineStorageTtlDays=$offlineStorageTtlDays',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'EntityType($contents)';
  }
}

/// Represents an environment variable present in a Container or Python Module.
final class EnvVar extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EnvVar';

  /// Required. Name of the environment variable. Must be a valid C identifier.
  final String name;

  /// Required. Variables that reference a $(VAR_NAME) are expanded
  /// using the previous defined environment variables in the container and
  /// any service environment variables. If a variable cannot be resolved,
  /// the reference in the input string will be unchanged. The $(VAR_NAME)
  /// syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  /// references will never be expanded, regardless of whether the variable
  /// exists or not.
  final String value;

  EnvVar({required this.name, required this.value}) : super(fullyQualifiedName);

  factory EnvVar.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EnvVar(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      value: switch (json['value']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, 'value': value};

  @override
  String toString() {
    final contents = ['name=$name', 'value=$value'].join(',');
    return 'EnvVar($contents)';
  }
}

/// Reference to a secret stored in the Cloud Secret Manager that will
/// provide the value for this environment variable.
final class SecretRef extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SecretRef';

  /// Required. The name of the secret in Cloud Secret Manager.
  /// Format: {secret_name}.
  final String secret;

  /// The Cloud Secret Manager secret version.
  /// Can be 'latest' for the latest version, an integer for a specific
  /// version, or a version alias.
  final String version;

  SecretRef({required this.secret, this.version = ''})
    : super(fullyQualifiedName);

  factory SecretRef.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SecretRef(
      secret: switch (json['secret']) {
        null => '',
        Object $1 => decodeString($1),
      },
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'secret': secret,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = ['secret=$secret', 'version=$version'].join(',');
    return 'SecretRef($contents)';
  }
}

/// Represents an environment variable where the value is a secret in Cloud
/// Secret Manager.
final class SecretEnvVar extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SecretEnvVar';

  /// Required. Name of the secret environment variable.
  final String name;

  /// Required. Reference to a secret stored in the Cloud Secret Manager that
  /// will provide the value for this environment variable.
  final SecretRef? secretRef;

  SecretEnvVar({required this.name, required this.secretRef})
    : super(fullyQualifiedName);

  factory SecretEnvVar.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SecretEnvVar(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      secretRef: switch (json['secretRef']) {
        null => null,
        Object $1 => SecretRef.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (secretRef != null) 'secretRef': secretRef!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'SecretEnvVar($contents)';
  }
}

/// True positive, false positive, or false negative.
///
/// EvaluatedAnnotation is only available under ModelEvaluationSlice with slice
/// of `annotationSpec` dimension.
final class EvaluatedAnnotation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluatedAnnotation';

  /// Output only. Type of the EvaluatedAnnotation.
  final EvaluatedAnnotation_EvaluatedAnnotationType type;

  /// Output only. The model predicted annotations.
  ///
  /// For true positive, there is one and only one prediction, which matches the
  /// only one ground truth annotation in
  /// `ground_truths`.
  ///
  /// For false positive, there is one and only one prediction, which doesn't
  /// match any ground truth annotation of the corresponding
  /// `data_item_view_id`.
  ///
  /// For false negative, there are zero or more predictions which are similar to
  /// the only ground truth annotation in
  /// `ground_truths`
  /// but not enough for a match.
  ///
  /// The schema of the prediction is stored in
  /// `ModelEvaluation.annotation_schema_uri`
  final List<protobuf.Value> predictions;

  /// Output only. The ground truth Annotations, i.e. the Annotations that exist
  /// in the test data the Model is evaluated on.
  ///
  /// For true positive, there is one and only one ground truth annotation, which
  /// matches the only prediction in
  /// `predictions`.
  ///
  /// For false positive, there are zero or more ground truth annotations that
  /// are similar to the only prediction in
  /// `predictions`,
  /// but not enough for a match.
  ///
  /// For false negative, there is one and only one ground truth annotation,
  /// which doesn't match any predictions created by the model.
  ///
  /// The schema of the ground truth is stored in
  /// `ModelEvaluation.annotation_schema_uri`
  final List<protobuf.Value> groundTruths;

  /// Output only. The data item payload that the Model predicted this
  /// EvaluatedAnnotation on.
  final protobuf.Value? dataItemPayload;

  /// Output only. ID of the EvaluatedDataItemView under the same ancestor
  /// ModelEvaluation. The EvaluatedDataItemView consists of all ground truths
  /// and predictions on
  /// `data_item_payload`.
  final String evaluatedDataItemViewId;

  /// Explanations of
  /// `predictions`.
  /// Each element of the explanations indicates the explanation for one
  /// explanation Method.
  ///
  /// The attributions list in the
  /// `EvaluatedAnnotationExplanation.explanation`
  /// object corresponds to the
  /// `predictions`
  /// list. For example, the second element in the attributions list explains the
  /// second element in the predictions list.
  final List<EvaluatedAnnotationExplanation> explanations;

  /// Annotations of model error analysis results.
  final List<ErrorAnalysisAnnotation> errorAnalysisAnnotations;

  EvaluatedAnnotation({
    this.type = EvaluatedAnnotation_EvaluatedAnnotationType.$default,
    this.predictions = const [],
    this.groundTruths = const [],
    this.dataItemPayload,
    this.evaluatedDataItemViewId = '',
    this.explanations = const [],
    this.errorAnalysisAnnotations = const [],
  }) : super(fullyQualifiedName);

  factory EvaluatedAnnotation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluatedAnnotation(
      type: switch (json['type']) {
        null => EvaluatedAnnotation_EvaluatedAnnotationType.$default,
        Object $1 => EvaluatedAnnotation_EvaluatedAnnotationType.fromJson($1),
      },
      predictions: switch (json['predictions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"predictions" is not a list'),
      },
      groundTruths: switch (json['groundTruths']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"groundTruths" is not a list'),
      },
      dataItemPayload: switch (json['dataItemPayload']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      evaluatedDataItemViewId: switch (json['evaluatedDataItemViewId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      explanations: switch (json['explanations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) EvaluatedAnnotationExplanation.fromJson(i),
        ],
        _ => throw const FormatException('"explanations" is not a list'),
      },
      errorAnalysisAnnotations: switch (json['errorAnalysisAnnotations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ErrorAnalysisAnnotation.fromJson(i),
        ],
        _ => throw const FormatException(
          '"errorAnalysisAnnotations" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type.toJson(),
    if (predictions.isNotDefault) 'predictions': encodeList(predictions),
    if (groundTruths.isNotDefault) 'groundTruths': encodeList(groundTruths),
    if (dataItemPayload != null) 'dataItemPayload': dataItemPayload!.toJson(),
    if (evaluatedDataItemViewId.isNotDefault)
      'evaluatedDataItemViewId': evaluatedDataItemViewId,
    if (explanations.isNotDefault) 'explanations': encodeList(explanations),
    if (errorAnalysisAnnotations.isNotDefault)
      'errorAnalysisAnnotations': encodeList(errorAnalysisAnnotations),
  };

  @override
  String toString() {
    final contents = [
      'type=$type',
      'evaluatedDataItemViewId=$evaluatedDataItemViewId',
    ].join(',');
    return 'EvaluatedAnnotation($contents)';
  }
}

/// Describes the type of the EvaluatedAnnotation. The type is determined
final class EvaluatedAnnotation_EvaluatedAnnotationType extends ProtoEnum {
  /// Invalid value.
  static const evaluatedAnnotationTypeUnspecified =
      EvaluatedAnnotation_EvaluatedAnnotationType(
        'EVALUATED_ANNOTATION_TYPE_UNSPECIFIED',
      );

  /// The EvaluatedAnnotation is a true positive. It has a prediction created
  /// by the Model and a ground truth Annotation which the prediction matches.
  static const truePositive = EvaluatedAnnotation_EvaluatedAnnotationType(
    'TRUE_POSITIVE',
  );

  /// The EvaluatedAnnotation is false positive. It has a prediction created by
  /// the Model which does not match any ground truth annotation.
  static const falsePositive = EvaluatedAnnotation_EvaluatedAnnotationType(
    'FALSE_POSITIVE',
  );

  /// The EvaluatedAnnotation is false negative. It has a ground truth
  /// annotation which is not matched by any of the model created predictions.
  static const falseNegative = EvaluatedAnnotation_EvaluatedAnnotationType(
    'FALSE_NEGATIVE',
  );

  /// The default value for [EvaluatedAnnotation_EvaluatedAnnotationType].
  static const $default = evaluatedAnnotationTypeUnspecified;

  const EvaluatedAnnotation_EvaluatedAnnotationType(super.value);

  factory EvaluatedAnnotation_EvaluatedAnnotationType.fromJson(Object? json) =>
      EvaluatedAnnotation_EvaluatedAnnotationType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'EvaluatedAnnotationType.$value';
}

/// Explanation result of the prediction produced by the Model.
final class EvaluatedAnnotationExplanation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluatedAnnotationExplanation';

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are:
  ///
  ///   * `image-integrated-gradients`
  ///   * `image-xrai`
  final String explanationType;

  /// Explanation attribution response details.
  final Explanation? explanation;

  EvaluatedAnnotationExplanation({this.explanationType = '', this.explanation})
    : super(fullyQualifiedName);

  factory EvaluatedAnnotationExplanation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluatedAnnotationExplanation(
      explanationType: switch (json['explanationType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      explanation: switch (json['explanation']) {
        null => null,
        Object $1 => Explanation.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (explanationType.isNotDefault) 'explanationType': explanationType,
    if (explanation != null) 'explanation': explanation!.toJson(),
  };

  @override
  String toString() {
    final contents = ['explanationType=$explanationType'].join(',');
    return 'EvaluatedAnnotationExplanation($contents)';
  }
}

/// Model error analysis for each annotation.
final class ErrorAnalysisAnnotation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ErrorAnalysisAnnotation';

  /// Attributed items for a given annotation, typically representing neighbors
  /// from the training sets constrained by the query type.
  final List<ErrorAnalysisAnnotation_AttributedItem> attributedItems;

  /// The query type used for finding the attributed items.
  final ErrorAnalysisAnnotation_QueryType queryType;

  /// The outlier score of this annotated item. Usually defined as the min of all
  /// distances from attributed items.
  final double outlierScore;

  /// The threshold used to determine if this annotation is an outlier or not.
  final double outlierThreshold;

  ErrorAnalysisAnnotation({
    this.attributedItems = const [],
    this.queryType = ErrorAnalysisAnnotation_QueryType.$default,
    this.outlierScore = 0,
    this.outlierThreshold = 0,
  }) : super(fullyQualifiedName);

  factory ErrorAnalysisAnnotation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ErrorAnalysisAnnotation(
      attributedItems: switch (json['attributedItems']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ErrorAnalysisAnnotation_AttributedItem.fromJson(i),
        ],
        _ => throw const FormatException('"attributedItems" is not a list'),
      },
      queryType: switch (json['queryType']) {
        null => ErrorAnalysisAnnotation_QueryType.$default,
        Object $1 => ErrorAnalysisAnnotation_QueryType.fromJson($1),
      },
      outlierScore: switch (json['outlierScore']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      outlierThreshold: switch (json['outlierThreshold']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (attributedItems.isNotDefault)
      'attributedItems': encodeList(attributedItems),
    if (queryType.isNotDefault) 'queryType': queryType.toJson(),
    if (outlierScore.isNotDefault) 'outlierScore': encodeDouble(outlierScore),
    if (outlierThreshold.isNotDefault)
      'outlierThreshold': encodeDouble(outlierThreshold),
  };

  @override
  String toString() {
    final contents = [
      'queryType=$queryType',
      'outlierScore=$outlierScore',
      'outlierThreshold=$outlierThreshold',
    ].join(',');
    return 'ErrorAnalysisAnnotation($contents)';
  }
}

/// Attributed items for a given annotation, typically representing neighbors
/// from the training sets constrained by the query type.
final class ErrorAnalysisAnnotation_AttributedItem extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ErrorAnalysisAnnotation.AttributedItem';

  /// The unique ID for each annotation. Used by FE to allocate the annotation
  /// in DB.
  final String annotationResourceName;

  /// The distance of this item to the annotation.
  final double distance;

  ErrorAnalysisAnnotation_AttributedItem({
    this.annotationResourceName = '',
    this.distance = 0,
  }) : super(fullyQualifiedName);

  factory ErrorAnalysisAnnotation_AttributedItem.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ErrorAnalysisAnnotation_AttributedItem(
      annotationResourceName: switch (json['annotationResourceName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      distance: switch (json['distance']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (annotationResourceName.isNotDefault)
      'annotationResourceName': annotationResourceName,
    if (distance.isNotDefault) 'distance': encodeDouble(distance),
  };

  @override
  String toString() {
    final contents = [
      'annotationResourceName=$annotationResourceName',
      'distance=$distance',
    ].join(',');
    return 'AttributedItem($contents)';
  }
}

/// The query type used for finding the attributed items.
final class ErrorAnalysisAnnotation_QueryType extends ProtoEnum {
  /// Unspecified query type for model error analysis.
  static const queryTypeUnspecified = ErrorAnalysisAnnotation_QueryType(
    'QUERY_TYPE_UNSPECIFIED',
  );

  /// Query similar samples across all classes in the dataset.
  static const allSimilar = ErrorAnalysisAnnotation_QueryType('ALL_SIMILAR');

  /// Query similar samples from the same class of the input sample.
  static const sameClassSimilar = ErrorAnalysisAnnotation_QueryType(
    'SAME_CLASS_SIMILAR',
  );

  /// Query dissimilar samples from the same class of the input sample.
  static const sameClassDissimilar = ErrorAnalysisAnnotation_QueryType(
    'SAME_CLASS_DISSIMILAR',
  );

  /// The default value for [ErrorAnalysisAnnotation_QueryType].
  static const $default = queryTypeUnspecified;

  const ErrorAnalysisAnnotation_QueryType(super.value);

  factory ErrorAnalysisAnnotation_QueryType.fromJson(Object? json) =>
      ErrorAnalysisAnnotation_QueryType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'QueryType.$value';
}

/// Operation metadata for Dataset Evaluation.
final class EvaluateDatasetOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateDatasetOperationMetadata';

  /// Generic operation metadata.
  final GenericOperationMetadata? genericMetadata;

  EvaluateDatasetOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory EvaluateDatasetOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluateDatasetOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'EvaluateDatasetOperationMetadata()';
}

/// Response in LRO for EvaluationService.EvaluateDataset.
final class EvaluateDatasetResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateDatasetResponse';

  /// Output only. Aggregation statistics derived from results of
  /// EvaluationService.EvaluateDataset.
  final AggregationOutput? aggregationOutput;

  /// Output only. Output info for EvaluationService.EvaluateDataset.
  final OutputInfo? outputInfo;

  EvaluateDatasetResponse({this.aggregationOutput, this.outputInfo})
    : super(fullyQualifiedName);

  factory EvaluateDatasetResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluateDatasetResponse(
      aggregationOutput: switch (json['aggregationOutput']) {
        null => null,
        Object $1 => AggregationOutput.fromJson($1),
      },
      outputInfo: switch (json['outputInfo']) {
        null => null,
        Object $1 => OutputInfo.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (aggregationOutput != null)
      'aggregationOutput': aggregationOutput!.toJson(),
    if (outputInfo != null) 'outputInfo': outputInfo!.toJson(),
  };

  @override
  String toString() => 'EvaluateDatasetResponse()';
}

/// Describes the info for output of EvaluationService.EvaluateDataset.
final class OutputInfo extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.OutputInfo';

  /// Output only. The full path of the Cloud Storage directory created, into
  /// which the evaluation results and aggregation results are written.
  final String? gcsOutputDirectory;

  OutputInfo({this.gcsOutputDirectory}) : super(fullyQualifiedName);

  factory OutputInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return OutputInfo(
      gcsOutputDirectory: switch (json['gcsOutputDirectory']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsOutputDirectory != null) 'gcsOutputDirectory': gcsOutputDirectory,
  };

  @override
  String toString() {
    final contents = [
      if (gcsOutputDirectory != null) 'gcsOutputDirectory=$gcsOutputDirectory',
    ].join(',');
    return 'OutputInfo($contents)';
  }
}

/// The aggregation result for the entire dataset and all metrics.
final class AggregationOutput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AggregationOutput';

  /// The dataset used for evaluation & aggregation.
  final EvaluationDataset? dataset;

  /// One AggregationResult per metric.
  final List<AggregationResult> aggregationResults;

  AggregationOutput({this.dataset, this.aggregationResults = const []})
    : super(fullyQualifiedName);

  factory AggregationOutput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AggregationOutput(
      dataset: switch (json['dataset']) {
        null => null,
        Object $1 => EvaluationDataset.fromJson($1),
      },
      aggregationResults: switch (json['aggregationResults']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) AggregationResult.fromJson(i)],
        _ => throw const FormatException('"aggregationResults" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataset != null) 'dataset': dataset!.toJson(),
    if (aggregationResults.isNotDefault)
      'aggregationResults': encodeList(aggregationResults),
  };

  @override
  String toString() => 'AggregationOutput()';
}

/// The aggregation result for a single metric.
final class AggregationResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AggregationResult';

  /// Result for pointwise metric.
  final PointwiseMetricResult? pointwiseMetricResult;

  /// Result for pairwise metric.
  final PairwiseMetricResult? pairwiseMetricResult;

  /// Results for exact match metric.
  final ExactMatchMetricValue? exactMatchMetricValue;

  /// Results for bleu metric.
  final BleuMetricValue? bleuMetricValue;

  /// Results for rouge metric.
  final RougeMetricValue? rougeMetricValue;

  /// Aggregation metric.
  final Metric_AggregationMetric aggregationMetric;

  AggregationResult({
    this.pointwiseMetricResult,
    this.pairwiseMetricResult,
    this.exactMatchMetricValue,
    this.bleuMetricValue,
    this.rougeMetricValue,
    this.aggregationMetric = Metric_AggregationMetric.$default,
  }) : super(fullyQualifiedName);

  factory AggregationResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AggregationResult(
      pointwiseMetricResult: switch (json['pointwiseMetricResult']) {
        null => null,
        Object $1 => PointwiseMetricResult.fromJson($1),
      },
      pairwiseMetricResult: switch (json['pairwiseMetricResult']) {
        null => null,
        Object $1 => PairwiseMetricResult.fromJson($1),
      },
      exactMatchMetricValue: switch (json['exactMatchMetricValue']) {
        null => null,
        Object $1 => ExactMatchMetricValue.fromJson($1),
      },
      bleuMetricValue: switch (json['bleuMetricValue']) {
        null => null,
        Object $1 => BleuMetricValue.fromJson($1),
      },
      rougeMetricValue: switch (json['rougeMetricValue']) {
        null => null,
        Object $1 => RougeMetricValue.fromJson($1),
      },
      aggregationMetric: switch (json['aggregationMetric']) {
        null => Metric_AggregationMetric.$default,
        Object $1 => Metric_AggregationMetric.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (pointwiseMetricResult != null)
      'pointwiseMetricResult': pointwiseMetricResult!.toJson(),
    if (pairwiseMetricResult != null)
      'pairwiseMetricResult': pairwiseMetricResult!.toJson(),
    if (exactMatchMetricValue != null)
      'exactMatchMetricValue': exactMatchMetricValue!.toJson(),
    if (bleuMetricValue != null) 'bleuMetricValue': bleuMetricValue!.toJson(),
    if (rougeMetricValue != null)
      'rougeMetricValue': rougeMetricValue!.toJson(),
    if (aggregationMetric.isNotDefault)
      'aggregationMetric': aggregationMetric.toJson(),
  };

  @override
  String toString() {
    final contents = ['aggregationMetric=$aggregationMetric'].join(',');
    return 'AggregationResult($contents)';
  }
}

/// Request message for EvaluationService.EvaluateDataset.
final class EvaluateDatasetRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateDatasetRequest';

  /// Required. The resource name of the Location to evaluate the dataset.
  /// Format: `projects/{project}/locations/{location}`
  final String location;

  /// Required. The dataset used for evaluation.
  final EvaluationDataset? dataset;

  /// Required. The metrics used for evaluation.
  final List<Metric> metrics;

  /// Required. Config for evaluation output.
  final OutputConfig? outputConfig;

  /// Optional. Autorater config used for evaluation. Currently only publisher
  /// Gemini models are supported. Format:
  /// `projects/{PROJECT}/locations/{LOCATION}/publishers/google/models/{MODEL}.`
  final AutoraterConfig? autoraterConfig;

  EvaluateDatasetRequest({
    required this.location,
    required this.dataset,
    required this.metrics,
    required this.outputConfig,
    this.autoraterConfig,
  }) : super(fullyQualifiedName);

  factory EvaluateDatasetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluateDatasetRequest(
      location: switch (json['location']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataset: switch (json['dataset']) {
        null => null,
        Object $1 => EvaluationDataset.fromJson($1),
      },
      metrics: switch (json['metrics']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Metric.fromJson(i)],
        _ => throw const FormatException('"metrics" is not a list'),
      },
      outputConfig: switch (json['outputConfig']) {
        null => null,
        Object $1 => OutputConfig.fromJson($1),
      },
      autoraterConfig: switch (json['autoraterConfig']) {
        null => null,
        Object $1 => AutoraterConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'location': location,
    if (dataset != null) 'dataset': dataset!.toJson(),
    'metrics': encodeList(metrics),
    if (outputConfig != null) 'outputConfig': outputConfig!.toJson(),
    if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['location=$location'].join(',');
    return 'EvaluateDatasetRequest($contents)';
  }
}

/// Config for evaluation output.
final class OutputConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.OutputConfig';

  /// Cloud storage destination for evaluation output.
  final GcsDestination? gcsDestination;

  OutputConfig({this.gcsDestination}) : super(fullyQualifiedName);

  factory OutputConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return OutputConfig(
      gcsDestination: switch (json['gcsDestination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
  };

  @override
  String toString() => 'OutputConfig()';
}

/// The metric used for dataset level evaluation.
final class Metric extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Metric';

  /// Spec for pointwise metric.
  final PointwiseMetricSpec? pointwiseMetricSpec;

  /// Spec for pairwise metric.
  final PairwiseMetricSpec? pairwiseMetricSpec;

  /// Spec for exact match metric.
  final ExactMatchSpec? exactMatchSpec;

  /// Spec for bleu metric.
  final BleuSpec? bleuSpec;

  /// Spec for rouge metric.
  final RougeSpec? rougeSpec;

  /// Optional. The aggregation metrics to use.
  final List<Metric_AggregationMetric> aggregationMetrics;

  Metric({
    this.pointwiseMetricSpec,
    this.pairwiseMetricSpec,
    this.exactMatchSpec,
    this.bleuSpec,
    this.rougeSpec,
    this.aggregationMetrics = const [],
  }) : super(fullyQualifiedName);

  factory Metric.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Metric(
      pointwiseMetricSpec: switch (json['pointwiseMetricSpec']) {
        null => null,
        Object $1 => PointwiseMetricSpec.fromJson($1),
      },
      pairwiseMetricSpec: switch (json['pairwiseMetricSpec']) {
        null => null,
        Object $1 => PairwiseMetricSpec.fromJson($1),
      },
      exactMatchSpec: switch (json['exactMatchSpec']) {
        null => null,
        Object $1 => ExactMatchSpec.fromJson($1),
      },
      bleuSpec: switch (json['bleuSpec']) {
        null => null,
        Object $1 => BleuSpec.fromJson($1),
      },
      rougeSpec: switch (json['rougeSpec']) {
        null => null,
        Object $1 => RougeSpec.fromJson($1),
      },
      aggregationMetrics: switch (json['aggregationMetrics']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Metric_AggregationMetric.fromJson(i),
        ],
        _ => throw const FormatException('"aggregationMetrics" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (pointwiseMetricSpec != null)
      'pointwiseMetricSpec': pointwiseMetricSpec!.toJson(),
    if (pairwiseMetricSpec != null)
      'pairwiseMetricSpec': pairwiseMetricSpec!.toJson(),
    if (exactMatchSpec != null) 'exactMatchSpec': exactMatchSpec!.toJson(),
    if (bleuSpec != null) 'bleuSpec': bleuSpec!.toJson(),
    if (rougeSpec != null) 'rougeSpec': rougeSpec!.toJson(),
    if (aggregationMetrics.isNotDefault)
      'aggregationMetrics': encodeList(aggregationMetrics),
  };

  @override
  String toString() => 'Metric()';
}

/// The aggregation metrics supported by EvaluationService.EvaluateDataset.
final class Metric_AggregationMetric extends ProtoEnum {
  /// Unspecified aggregation metric.
  static const aggregationMetricUnspecified = Metric_AggregationMetric(
    'AGGREGATION_METRIC_UNSPECIFIED',
  );

  /// Average aggregation metric. Not supported for Pairwise metric.
  static const average = Metric_AggregationMetric('AVERAGE');

  /// Mode aggregation metric.
  static const mode = Metric_AggregationMetric('MODE');

  /// Standard deviation aggregation metric. Not supported for pairwise metric.
  static const standardDeviation = Metric_AggregationMetric(
    'STANDARD_DEVIATION',
  );

  /// Variance aggregation metric. Not supported for pairwise metric.
  static const variance = Metric_AggregationMetric('VARIANCE');

  /// Minimum aggregation metric. Not supported for pairwise metric.
  static const minimum = Metric_AggregationMetric('MINIMUM');

  /// Maximum aggregation metric. Not supported for pairwise metric.
  static const maximum = Metric_AggregationMetric('MAXIMUM');

  /// Median aggregation metric. Not supported for pairwise metric.
  static const median = Metric_AggregationMetric('MEDIAN');

  /// 90th percentile aggregation metric. Not supported for pairwise metric.
  static const percentileP90 = Metric_AggregationMetric('PERCENTILE_P90');

  /// 95th percentile aggregation metric. Not supported for pairwise metric.
  static const percentileP95 = Metric_AggregationMetric('PERCENTILE_P95');

  /// 99th percentile aggregation metric. Not supported for pairwise metric.
  static const percentileP99 = Metric_AggregationMetric('PERCENTILE_P99');

  /// The default value for [Metric_AggregationMetric].
  static const $default = aggregationMetricUnspecified;

  const Metric_AggregationMetric(super.value);

  factory Metric_AggregationMetric.fromJson(Object? json) =>
      Metric_AggregationMetric(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'AggregationMetric.$value';
}

/// The dataset used for evaluation.
final class EvaluationDataset extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluationDataset';

  /// Cloud storage source holds the dataset. Currently only one Cloud Storage
  /// file path is supported.
  final GcsSource? gcsSource;

  /// BigQuery source holds the dataset.
  final BigQuerySource? bigquerySource;

  EvaluationDataset({this.gcsSource, this.bigquerySource})
    : super(fullyQualifiedName);

  factory EvaluationDataset.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluationDataset(
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      bigquerySource: switch (json['bigquerySource']) {
        null => null,
        Object $1 => BigQuerySource.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
  };

  @override
  String toString() => 'EvaluationDataset()';
}

/// The configs for autorater. This is applicable to both EvaluateInstances and
/// EvaluateDataset.
final class AutoraterConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AutoraterConfig';

  /// Optional. Number of samples for each instance in the dataset.
  /// If not specified, the default is 4. Minimum value is 1, maximum value
  /// is 32.
  final int? samplingCount;

  /// Optional. Default is true. Whether to flip the candidate and baseline
  /// responses. This is only applicable to the pairwise metric. If enabled, also
  /// provide PairwiseMetricSpec.candidate_response_field_name and
  /// PairwiseMetricSpec.baseline_response_field_name. When rendering
  /// PairwiseMetricSpec.metric_prompt_template, the candidate and baseline
  /// fields will be flipped for half of the samples to reduce bias.
  final bool? flipEnabled;

  /// Optional. The fully qualified name of the publisher model or tuned
  /// autorater endpoint to use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers/*/models/*`
  ///
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String autoraterModel;

  AutoraterConfig({
    this.samplingCount,
    this.flipEnabled,
    this.autoraterModel = '',
  }) : super(fullyQualifiedName);

  factory AutoraterConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AutoraterConfig(
      samplingCount: switch (json['samplingCount']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      flipEnabled: switch (json['flipEnabled']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      autoraterModel: switch (json['autoraterModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (samplingCount != null) 'samplingCount': samplingCount,
    if (flipEnabled != null) 'flipEnabled': flipEnabled,
    if (autoraterModel.isNotDefault) 'autoraterModel': autoraterModel,
  };

  @override
  String toString() {
    final contents = [
      if (samplingCount != null) 'samplingCount=$samplingCount',
      if (flipEnabled != null) 'flipEnabled=$flipEnabled',
      'autoraterModel=$autoraterModel',
    ].join(',');
    return 'AutoraterConfig($contents)';
  }
}

/// Request message for EvaluationService.EvaluateInstances.
final class EvaluateInstancesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateInstancesRequest';

  /// Auto metric instances.
  /// Instances and metric spec for exact match metric.
  final ExactMatchInput? exactMatchInput;

  /// Instances and metric spec for bleu metric.
  final BleuInput? bleuInput;

  /// Instances and metric spec for rouge metric.
  final RougeInput? rougeInput;

  /// LLM-based metric instance.
  /// General text generation metrics, applicable to other categories.
  /// Input for fluency metric.
  final FluencyInput? fluencyInput;

  /// Input for coherence metric.
  final CoherenceInput? coherenceInput;

  /// Input for safety metric.
  final SafetyInput? safetyInput;

  /// Input for groundedness metric.
  final GroundednessInput? groundednessInput;

  /// Input for fulfillment metric.
  final FulfillmentInput? fulfillmentInput;

  /// Input for summarization quality metric.
  final SummarizationQualityInput? summarizationQualityInput;

  /// Input for pairwise summarization quality metric.
  final PairwiseSummarizationQualityInput? pairwiseSummarizationQualityInput;

  /// Input for summarization helpfulness metric.
  final SummarizationHelpfulnessInput? summarizationHelpfulnessInput;

  /// Input for summarization verbosity metric.
  final SummarizationVerbosityInput? summarizationVerbosityInput;

  /// Input for question answering quality metric.
  final QuestionAnsweringQualityInput? questionAnsweringQualityInput;

  /// Input for pairwise question answering quality metric.
  final PairwiseQuestionAnsweringQualityInput?
  pairwiseQuestionAnsweringQualityInput;

  /// Input for question answering relevance metric.
  final QuestionAnsweringRelevanceInput? questionAnsweringRelevanceInput;

  /// Input for question answering helpfulness
  /// metric.
  final QuestionAnsweringHelpfulnessInput? questionAnsweringHelpfulnessInput;

  /// Input for question answering correctness
  /// metric.
  final QuestionAnsweringCorrectnessInput? questionAnsweringCorrectnessInput;

  /// Input for pointwise metric.
  final PointwiseMetricInput? pointwiseMetricInput;

  /// Input for pairwise metric.
  final PairwiseMetricInput? pairwiseMetricInput;

  /// Tool call metric instances.
  /// Input for tool call valid metric.
  final ToolCallValidInput? toolCallValidInput;

  /// Input for tool name match metric.
  final ToolNameMatchInput? toolNameMatchInput;

  /// Input for tool parameter key match metric.
  final ToolParameterKeyMatchInput? toolParameterKeyMatchInput;

  /// Input for tool parameter key value match metric.
  final ToolParameterKvmatchInput? toolParameterKvMatchInput;

  /// Translation metrics.
  /// Input for Comet metric.
  final CometInput? cometInput;

  /// Input for Metricx metric.
  final MetricxInput? metricxInput;

  /// Input for trajectory exact match metric.
  final TrajectoryExactMatchInput? trajectoryExactMatchInput;

  /// Input for trajectory in order match metric.
  final TrajectoryInOrderMatchInput? trajectoryInOrderMatchInput;

  /// Input for trajectory match any order metric.
  final TrajectoryAnyOrderMatchInput? trajectoryAnyOrderMatchInput;

  /// Input for trajectory precision metric.
  final TrajectoryPrecisionInput? trajectoryPrecisionInput;

  /// Input for trajectory recall metric.
  final TrajectoryRecallInput? trajectoryRecallInput;

  /// Input for trajectory single tool use metric.
  final TrajectorySingleToolUseInput? trajectorySingleToolUseInput;

  /// Rubric Based Instruction Following metric.
  final RubricBasedInstructionFollowingInput?
  rubricBasedInstructionFollowingInput;

  /// Required. The resource name of the Location to evaluate the instances.
  /// Format: `projects/{project}/locations/{location}`
  final String location;

  /// Optional. Autorater config used for evaluation.
  final AutoraterConfig? autoraterConfig;

  EvaluateInstancesRequest({
    this.exactMatchInput,
    this.bleuInput,
    this.rougeInput,
    this.fluencyInput,
    this.coherenceInput,
    this.safetyInput,
    this.groundednessInput,
    this.fulfillmentInput,
    this.summarizationQualityInput,
    this.pairwiseSummarizationQualityInput,
    this.summarizationHelpfulnessInput,
    this.summarizationVerbosityInput,
    this.questionAnsweringQualityInput,
    this.pairwiseQuestionAnsweringQualityInput,
    this.questionAnsweringRelevanceInput,
    this.questionAnsweringHelpfulnessInput,
    this.questionAnsweringCorrectnessInput,
    this.pointwiseMetricInput,
    this.pairwiseMetricInput,
    this.toolCallValidInput,
    this.toolNameMatchInput,
    this.toolParameterKeyMatchInput,
    this.toolParameterKvMatchInput,
    this.cometInput,
    this.metricxInput,
    this.trajectoryExactMatchInput,
    this.trajectoryInOrderMatchInput,
    this.trajectoryAnyOrderMatchInput,
    this.trajectoryPrecisionInput,
    this.trajectoryRecallInput,
    this.trajectorySingleToolUseInput,
    this.rubricBasedInstructionFollowingInput,
    required this.location,
    this.autoraterConfig,
  }) : super(fullyQualifiedName);

  factory EvaluateInstancesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluateInstancesRequest(
      exactMatchInput: switch (json['exactMatchInput']) {
        null => null,
        Object $1 => ExactMatchInput.fromJson($1),
      },
      bleuInput: switch (json['bleuInput']) {
        null => null,
        Object $1 => BleuInput.fromJson($1),
      },
      rougeInput: switch (json['rougeInput']) {
        null => null,
        Object $1 => RougeInput.fromJson($1),
      },
      fluencyInput: switch (json['fluencyInput']) {
        null => null,
        Object $1 => FluencyInput.fromJson($1),
      },
      coherenceInput: switch (json['coherenceInput']) {
        null => null,
        Object $1 => CoherenceInput.fromJson($1),
      },
      safetyInput: switch (json['safetyInput']) {
        null => null,
        Object $1 => SafetyInput.fromJson($1),
      },
      groundednessInput: switch (json['groundednessInput']) {
        null => null,
        Object $1 => GroundednessInput.fromJson($1),
      },
      fulfillmentInput: switch (json['fulfillmentInput']) {
        null => null,
        Object $1 => FulfillmentInput.fromJson($1),
      },
      summarizationQualityInput: switch (json['summarizationQualityInput']) {
        null => null,
        Object $1 => SummarizationQualityInput.fromJson($1),
      },
      pairwiseSummarizationQualityInput:
          switch (json['pairwiseSummarizationQualityInput']) {
            null => null,
            Object $1 => PairwiseSummarizationQualityInput.fromJson($1),
          },
      summarizationHelpfulnessInput:
          switch (json['summarizationHelpfulnessInput']) {
            null => null,
            Object $1 => SummarizationHelpfulnessInput.fromJson($1),
          },
      summarizationVerbosityInput:
          switch (json['summarizationVerbosityInput']) {
            null => null,
            Object $1 => SummarizationVerbosityInput.fromJson($1),
          },
      questionAnsweringQualityInput:
          switch (json['questionAnsweringQualityInput']) {
            null => null,
            Object $1 => QuestionAnsweringQualityInput.fromJson($1),
          },
      pairwiseQuestionAnsweringQualityInput:
          switch (json['pairwiseQuestionAnsweringQualityInput']) {
            null => null,
            Object $1 => PairwiseQuestionAnsweringQualityInput.fromJson($1),
          },
      questionAnsweringRelevanceInput:
          switch (json['questionAnsweringRelevanceInput']) {
            null => null,
            Object $1 => QuestionAnsweringRelevanceInput.fromJson($1),
          },
      questionAnsweringHelpfulnessInput:
          switch (json['questionAnsweringHelpfulnessInput']) {
            null => null,
            Object $1 => QuestionAnsweringHelpfulnessInput.fromJson($1),
          },
      questionAnsweringCorrectnessInput:
          switch (json['questionAnsweringCorrectnessInput']) {
            null => null,
            Object $1 => QuestionAnsweringCorrectnessInput.fromJson($1),
          },
      pointwiseMetricInput: switch (json['pointwiseMetricInput']) {
        null => null,
        Object $1 => PointwiseMetricInput.fromJson($1),
      },
      pairwiseMetricInput: switch (json['pairwiseMetricInput']) {
        null => null,
        Object $1 => PairwiseMetricInput.fromJson($1),
      },
      toolCallValidInput: switch (json['toolCallValidInput']) {
        null => null,
        Object $1 => ToolCallValidInput.fromJson($1),
      },
      toolNameMatchInput: switch (json['toolNameMatchInput']) {
        null => null,
        Object $1 => ToolNameMatchInput.fromJson($1),
      },
      toolParameterKeyMatchInput: switch (json['toolParameterKeyMatchInput']) {
        null => null,
        Object $1 => ToolParameterKeyMatchInput.fromJson($1),
      },
      toolParameterKvMatchInput: switch (json['toolParameterKvMatchInput']) {
        null => null,
        Object $1 => ToolParameterKvmatchInput.fromJson($1),
      },
      cometInput: switch (json['cometInput']) {
        null => null,
        Object $1 => CometInput.fromJson($1),
      },
      metricxInput: switch (json['metricxInput']) {
        null => null,
        Object $1 => MetricxInput.fromJson($1),
      },
      trajectoryExactMatchInput: switch (json['trajectoryExactMatchInput']) {
        null => null,
        Object $1 => TrajectoryExactMatchInput.fromJson($1),
      },
      trajectoryInOrderMatchInput:
          switch (json['trajectoryInOrderMatchInput']) {
            null => null,
            Object $1 => TrajectoryInOrderMatchInput.fromJson($1),
          },
      trajectoryAnyOrderMatchInput:
          switch (json['trajectoryAnyOrderMatchInput']) {
            null => null,
            Object $1 => TrajectoryAnyOrderMatchInput.fromJson($1),
          },
      trajectoryPrecisionInput: switch (json['trajectoryPrecisionInput']) {
        null => null,
        Object $1 => TrajectoryPrecisionInput.fromJson($1),
      },
      trajectoryRecallInput: switch (json['trajectoryRecallInput']) {
        null => null,
        Object $1 => TrajectoryRecallInput.fromJson($1),
      },
      trajectorySingleToolUseInput:
          switch (json['trajectorySingleToolUseInput']) {
            null => null,
            Object $1 => TrajectorySingleToolUseInput.fromJson($1),
          },
      rubricBasedInstructionFollowingInput:
          switch (json['rubricBasedInstructionFollowingInput']) {
            null => null,
            Object $1 => RubricBasedInstructionFollowingInput.fromJson($1),
          },
      location: switch (json['location']) {
        null => '',
        Object $1 => decodeString($1),
      },
      autoraterConfig: switch (json['autoraterConfig']) {
        null => null,
        Object $1 => AutoraterConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (exactMatchInput != null) 'exactMatchInput': exactMatchInput!.toJson(),
    if (bleuInput != null) 'bleuInput': bleuInput!.toJson(),
    if (rougeInput != null) 'rougeInput': rougeInput!.toJson(),
    if (fluencyInput != null) 'fluencyInput': fluencyInput!.toJson(),
    if (coherenceInput != null) 'coherenceInput': coherenceInput!.toJson(),
    if (safetyInput != null) 'safetyInput': safetyInput!.toJson(),
    if (groundednessInput != null)
      'groundednessInput': groundednessInput!.toJson(),
    if (fulfillmentInput != null)
      'fulfillmentInput': fulfillmentInput!.toJson(),
    if (summarizationQualityInput != null)
      'summarizationQualityInput': summarizationQualityInput!.toJson(),
    if (pairwiseSummarizationQualityInput != null)
      'pairwiseSummarizationQualityInput': pairwiseSummarizationQualityInput!
          .toJson(),
    if (summarizationHelpfulnessInput != null)
      'summarizationHelpfulnessInput': summarizationHelpfulnessInput!.toJson(),
    if (summarizationVerbosityInput != null)
      'summarizationVerbosityInput': summarizationVerbosityInput!.toJson(),
    if (questionAnsweringQualityInput != null)
      'questionAnsweringQualityInput': questionAnsweringQualityInput!.toJson(),
    if (pairwiseQuestionAnsweringQualityInput != null)
      'pairwiseQuestionAnsweringQualityInput':
          pairwiseQuestionAnsweringQualityInput!.toJson(),
    if (questionAnsweringRelevanceInput != null)
      'questionAnsweringRelevanceInput': questionAnsweringRelevanceInput!
          .toJson(),
    if (questionAnsweringHelpfulnessInput != null)
      'questionAnsweringHelpfulnessInput': questionAnsweringHelpfulnessInput!
          .toJson(),
    if (questionAnsweringCorrectnessInput != null)
      'questionAnsweringCorrectnessInput': questionAnsweringCorrectnessInput!
          .toJson(),
    if (pointwiseMetricInput != null)
      'pointwiseMetricInput': pointwiseMetricInput!.toJson(),
    if (pairwiseMetricInput != null)
      'pairwiseMetricInput': pairwiseMetricInput!.toJson(),
    if (toolCallValidInput != null)
      'toolCallValidInput': toolCallValidInput!.toJson(),
    if (toolNameMatchInput != null)
      'toolNameMatchInput': toolNameMatchInput!.toJson(),
    if (toolParameterKeyMatchInput != null)
      'toolParameterKeyMatchInput': toolParameterKeyMatchInput!.toJson(),
    if (toolParameterKvMatchInput != null)
      'toolParameterKvMatchInput': toolParameterKvMatchInput!.toJson(),
    if (cometInput != null) 'cometInput': cometInput!.toJson(),
    if (metricxInput != null) 'metricxInput': metricxInput!.toJson(),
    if (trajectoryExactMatchInput != null)
      'trajectoryExactMatchInput': trajectoryExactMatchInput!.toJson(),
    if (trajectoryInOrderMatchInput != null)
      'trajectoryInOrderMatchInput': trajectoryInOrderMatchInput!.toJson(),
    if (trajectoryAnyOrderMatchInput != null)
      'trajectoryAnyOrderMatchInput': trajectoryAnyOrderMatchInput!.toJson(),
    if (trajectoryPrecisionInput != null)
      'trajectoryPrecisionInput': trajectoryPrecisionInput!.toJson(),
    if (trajectoryRecallInput != null)
      'trajectoryRecallInput': trajectoryRecallInput!.toJson(),
    if (trajectorySingleToolUseInput != null)
      'trajectorySingleToolUseInput': trajectorySingleToolUseInput!.toJson(),
    if (rubricBasedInstructionFollowingInput != null)
      'rubricBasedInstructionFollowingInput':
          rubricBasedInstructionFollowingInput!.toJson(),
    'location': location,
    if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['location=$location'].join(',');
    return 'EvaluateInstancesRequest($contents)';
  }
}

/// Response message for EvaluationService.EvaluateInstances.
final class EvaluateInstancesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateInstancesResponse';

  /// Auto metric evaluation results.
  /// Results for exact match metric.
  final ExactMatchResults? exactMatchResults;

  /// Results for bleu metric.
  final BleuResults? bleuResults;

  /// Results for rouge metric.
  final RougeResults? rougeResults;

  /// LLM-based metric evaluation result.
  /// General text generation metrics, applicable to other categories.
  /// Result for fluency metric.
  final FluencyResult? fluencyResult;

  /// Result for coherence metric.
  final CoherenceResult? coherenceResult;

  /// Result for safety metric.
  final SafetyResult? safetyResult;

  /// Result for groundedness metric.
  final GroundednessResult? groundednessResult;

  /// Result for fulfillment metric.
  final FulfillmentResult? fulfillmentResult;

  /// Summarization only metrics.
  /// Result for summarization quality metric.
  final SummarizationQualityResult? summarizationQualityResult;

  /// Result for pairwise summarization quality metric.
  final PairwiseSummarizationQualityResult? pairwiseSummarizationQualityResult;

  /// Result for summarization helpfulness metric.
  final SummarizationHelpfulnessResult? summarizationHelpfulnessResult;

  /// Result for summarization verbosity metric.
  final SummarizationVerbosityResult? summarizationVerbosityResult;

  /// Question answering only metrics.
  /// Result for question answering quality metric.
  final QuestionAnsweringQualityResult? questionAnsweringQualityResult;

  /// Result for pairwise question answering quality metric.
  final PairwiseQuestionAnsweringQualityResult?
  pairwiseQuestionAnsweringQualityResult;

  /// Result for question answering relevance metric.
  final QuestionAnsweringRelevanceResult? questionAnsweringRelevanceResult;

  /// Result for question answering helpfulness metric.
  final QuestionAnsweringHelpfulnessResult? questionAnsweringHelpfulnessResult;

  /// Result for question answering correctness metric.
  final QuestionAnsweringCorrectnessResult? questionAnsweringCorrectnessResult;

  /// Generic metrics.
  /// Result for pointwise metric.
  final PointwiseMetricResult? pointwiseMetricResult;

  /// Result for pairwise metric.
  final PairwiseMetricResult? pairwiseMetricResult;

  /// Tool call metrics.
  ///  Results for tool call valid metric.
  final ToolCallValidResults? toolCallValidResults;

  /// Results for tool name match metric.
  final ToolNameMatchResults? toolNameMatchResults;

  /// Results for tool parameter key match  metric.
  final ToolParameterKeyMatchResults? toolParameterKeyMatchResults;

  /// Results for tool parameter key value match metric.
  final ToolParameterKvmatchResults? toolParameterKvMatchResults;

  /// Translation metrics.
  /// Result for Comet metric.
  final CometResult? cometResult;

  /// Result for Metricx metric.
  final MetricxResult? metricxResult;

  /// Result for trajectory exact match metric.
  final TrajectoryExactMatchResults? trajectoryExactMatchResults;

  /// Result for trajectory in order match metric.
  final TrajectoryInOrderMatchResults? trajectoryInOrderMatchResults;

  /// Result for trajectory any order match metric.
  final TrajectoryAnyOrderMatchResults? trajectoryAnyOrderMatchResults;

  /// Result for trajectory precision metric.
  final TrajectoryPrecisionResults? trajectoryPrecisionResults;

  /// Results for trajectory recall metric.
  final TrajectoryRecallResults? trajectoryRecallResults;

  /// Results for trajectory single tool use metric.
  final TrajectorySingleToolUseResults? trajectorySingleToolUseResults;

  /// Result for rubric based instruction following metric.
  final RubricBasedInstructionFollowingResult?
  rubricBasedInstructionFollowingResult;

  EvaluateInstancesResponse({
    this.exactMatchResults,
    this.bleuResults,
    this.rougeResults,
    this.fluencyResult,
    this.coherenceResult,
    this.safetyResult,
    this.groundednessResult,
    this.fulfillmentResult,
    this.summarizationQualityResult,
    this.pairwiseSummarizationQualityResult,
    this.summarizationHelpfulnessResult,
    this.summarizationVerbosityResult,
    this.questionAnsweringQualityResult,
    this.pairwiseQuestionAnsweringQualityResult,
    this.questionAnsweringRelevanceResult,
    this.questionAnsweringHelpfulnessResult,
    this.questionAnsweringCorrectnessResult,
    this.pointwiseMetricResult,
    this.pairwiseMetricResult,
    this.toolCallValidResults,
    this.toolNameMatchResults,
    this.toolParameterKeyMatchResults,
    this.toolParameterKvMatchResults,
    this.cometResult,
    this.metricxResult,
    this.trajectoryExactMatchResults,
    this.trajectoryInOrderMatchResults,
    this.trajectoryAnyOrderMatchResults,
    this.trajectoryPrecisionResults,
    this.trajectoryRecallResults,
    this.trajectorySingleToolUseResults,
    this.rubricBasedInstructionFollowingResult,
  }) : super(fullyQualifiedName);

  factory EvaluateInstancesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluateInstancesResponse(
      exactMatchResults: switch (json['exactMatchResults']) {
        null => null,
        Object $1 => ExactMatchResults.fromJson($1),
      },
      bleuResults: switch (json['bleuResults']) {
        null => null,
        Object $1 => BleuResults.fromJson($1),
      },
      rougeResults: switch (json['rougeResults']) {
        null => null,
        Object $1 => RougeResults.fromJson($1),
      },
      fluencyResult: switch (json['fluencyResult']) {
        null => null,
        Object $1 => FluencyResult.fromJson($1),
      },
      coherenceResult: switch (json['coherenceResult']) {
        null => null,
        Object $1 => CoherenceResult.fromJson($1),
      },
      safetyResult: switch (json['safetyResult']) {
        null => null,
        Object $1 => SafetyResult.fromJson($1),
      },
      groundednessResult: switch (json['groundednessResult']) {
        null => null,
        Object $1 => GroundednessResult.fromJson($1),
      },
      fulfillmentResult: switch (json['fulfillmentResult']) {
        null => null,
        Object $1 => FulfillmentResult.fromJson($1),
      },
      summarizationQualityResult: switch (json['summarizationQualityResult']) {
        null => null,
        Object $1 => SummarizationQualityResult.fromJson($1),
      },
      pairwiseSummarizationQualityResult:
          switch (json['pairwiseSummarizationQualityResult']) {
            null => null,
            Object $1 => PairwiseSummarizationQualityResult.fromJson($1),
          },
      summarizationHelpfulnessResult:
          switch (json['summarizationHelpfulnessResult']) {
            null => null,
            Object $1 => SummarizationHelpfulnessResult.fromJson($1),
          },
      summarizationVerbosityResult:
          switch (json['summarizationVerbosityResult']) {
            null => null,
            Object $1 => SummarizationVerbosityResult.fromJson($1),
          },
      questionAnsweringQualityResult:
          switch (json['questionAnsweringQualityResult']) {
            null => null,
            Object $1 => QuestionAnsweringQualityResult.fromJson($1),
          },
      pairwiseQuestionAnsweringQualityResult:
          switch (json['pairwiseQuestionAnsweringQualityResult']) {
            null => null,
            Object $1 => PairwiseQuestionAnsweringQualityResult.fromJson($1),
          },
      questionAnsweringRelevanceResult:
          switch (json['questionAnsweringRelevanceResult']) {
            null => null,
            Object $1 => QuestionAnsweringRelevanceResult.fromJson($1),
          },
      questionAnsweringHelpfulnessResult:
          switch (json['questionAnsweringHelpfulnessResult']) {
            null => null,
            Object $1 => QuestionAnsweringHelpfulnessResult.fromJson($1),
          },
      questionAnsweringCorrectnessResult:
          switch (json['questionAnsweringCorrectnessResult']) {
            null => null,
            Object $1 => QuestionAnsweringCorrectnessResult.fromJson($1),
          },
      pointwiseMetricResult: switch (json['pointwiseMetricResult']) {
        null => null,
        Object $1 => PointwiseMetricResult.fromJson($1),
      },
      pairwiseMetricResult: switch (json['pairwiseMetricResult']) {
        null => null,
        Object $1 => PairwiseMetricResult.fromJson($1),
      },
      toolCallValidResults: switch (json['toolCallValidResults']) {
        null => null,
        Object $1 => ToolCallValidResults.fromJson($1),
      },
      toolNameMatchResults: switch (json['toolNameMatchResults']) {
        null => null,
        Object $1 => ToolNameMatchResults.fromJson($1),
      },
      toolParameterKeyMatchResults:
          switch (json['toolParameterKeyMatchResults']) {
            null => null,
            Object $1 => ToolParameterKeyMatchResults.fromJson($1),
          },
      toolParameterKvMatchResults:
          switch (json['toolParameterKvMatchResults']) {
            null => null,
            Object $1 => ToolParameterKvmatchResults.fromJson($1),
          },
      cometResult: switch (json['cometResult']) {
        null => null,
        Object $1 => CometResult.fromJson($1),
      },
      metricxResult: switch (json['metricxResult']) {
        null => null,
        Object $1 => MetricxResult.fromJson($1),
      },
      trajectoryExactMatchResults:
          switch (json['trajectoryExactMatchResults']) {
            null => null,
            Object $1 => TrajectoryExactMatchResults.fromJson($1),
          },
      trajectoryInOrderMatchResults:
          switch (json['trajectoryInOrderMatchResults']) {
            null => null,
            Object $1 => TrajectoryInOrderMatchResults.fromJson($1),
          },
      trajectoryAnyOrderMatchResults:
          switch (json['trajectoryAnyOrderMatchResults']) {
            null => null,
            Object $1 => TrajectoryAnyOrderMatchResults.fromJson($1),
          },
      trajectoryPrecisionResults: switch (json['trajectoryPrecisionResults']) {
        null => null,
        Object $1 => TrajectoryPrecisionResults.fromJson($1),
      },
      trajectoryRecallResults: switch (json['trajectoryRecallResults']) {
        null => null,
        Object $1 => TrajectoryRecallResults.fromJson($1),
      },
      trajectorySingleToolUseResults:
          switch (json['trajectorySingleToolUseResults']) {
            null => null,
            Object $1 => TrajectorySingleToolUseResults.fromJson($1),
          },
      rubricBasedInstructionFollowingResult:
          switch (json['rubricBasedInstructionFollowingResult']) {
            null => null,
            Object $1 => RubricBasedInstructionFollowingResult.fromJson($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (exactMatchResults != null)
      'exactMatchResults': exactMatchResults!.toJson(),
    if (bleuResults != null) 'bleuResults': bleuResults!.toJson(),
    if (rougeResults != null) 'rougeResults': rougeResults!.toJson(),
    if (fluencyResult != null) 'fluencyResult': fluencyResult!.toJson(),
    if (coherenceResult != null) 'coherenceResult': coherenceResult!.toJson(),
    if (safetyResult != null) 'safetyResult': safetyResult!.toJson(),
    if (groundednessResult != null)
      'groundednessResult': groundednessResult!.toJson(),
    if (fulfillmentResult != null)
      'fulfillmentResult': fulfillmentResult!.toJson(),
    if (summarizationQualityResult != null)
      'summarizationQualityResult': summarizationQualityResult!.toJson(),
    if (pairwiseSummarizationQualityResult != null)
      'pairwiseSummarizationQualityResult': pairwiseSummarizationQualityResult!
          .toJson(),
    if (summarizationHelpfulnessResult != null)
      'summarizationHelpfulnessResult': summarizationHelpfulnessResult!
          .toJson(),
    if (summarizationVerbosityResult != null)
      'summarizationVerbosityResult': summarizationVerbosityResult!.toJson(),
    if (questionAnsweringQualityResult != null)
      'questionAnsweringQualityResult': questionAnsweringQualityResult!
          .toJson(),
    if (pairwiseQuestionAnsweringQualityResult != null)
      'pairwiseQuestionAnsweringQualityResult':
          pairwiseQuestionAnsweringQualityResult!.toJson(),
    if (questionAnsweringRelevanceResult != null)
      'questionAnsweringRelevanceResult': questionAnsweringRelevanceResult!
          .toJson(),
    if (questionAnsweringHelpfulnessResult != null)
      'questionAnsweringHelpfulnessResult': questionAnsweringHelpfulnessResult!
          .toJson(),
    if (questionAnsweringCorrectnessResult != null)
      'questionAnsweringCorrectnessResult': questionAnsweringCorrectnessResult!
          .toJson(),
    if (pointwiseMetricResult != null)
      'pointwiseMetricResult': pointwiseMetricResult!.toJson(),
    if (pairwiseMetricResult != null)
      'pairwiseMetricResult': pairwiseMetricResult!.toJson(),
    if (toolCallValidResults != null)
      'toolCallValidResults': toolCallValidResults!.toJson(),
    if (toolNameMatchResults != null)
      'toolNameMatchResults': toolNameMatchResults!.toJson(),
    if (toolParameterKeyMatchResults != null)
      'toolParameterKeyMatchResults': toolParameterKeyMatchResults!.toJson(),
    if (toolParameterKvMatchResults != null)
      'toolParameterKvMatchResults': toolParameterKvMatchResults!.toJson(),
    if (cometResult != null) 'cometResult': cometResult!.toJson(),
    if (metricxResult != null) 'metricxResult': metricxResult!.toJson(),
    if (trajectoryExactMatchResults != null)
      'trajectoryExactMatchResults': trajectoryExactMatchResults!.toJson(),
    if (trajectoryInOrderMatchResults != null)
      'trajectoryInOrderMatchResults': trajectoryInOrderMatchResults!.toJson(),
    if (trajectoryAnyOrderMatchResults != null)
      'trajectoryAnyOrderMatchResults': trajectoryAnyOrderMatchResults!
          .toJson(),
    if (trajectoryPrecisionResults != null)
      'trajectoryPrecisionResults': trajectoryPrecisionResults!.toJson(),
    if (trajectoryRecallResults != null)
      'trajectoryRecallResults': trajectoryRecallResults!.toJson(),
    if (trajectorySingleToolUseResults != null)
      'trajectorySingleToolUseResults': trajectorySingleToolUseResults!
          .toJson(),
    if (rubricBasedInstructionFollowingResult != null)
      'rubricBasedInstructionFollowingResult':
          rubricBasedInstructionFollowingResult!.toJson(),
  };

  @override
  String toString() => 'EvaluateInstancesResponse()';
}

/// Input for exact match metric.
final class ExactMatchInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchInput';

  /// Required. Spec for exact match metric.
  final ExactMatchSpec? metricSpec;

  /// Required. Repeated exact match instances.
  final List<ExactMatchInstance> instances;

  ExactMatchInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory ExactMatchInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExactMatchInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => ExactMatchSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ExactMatchInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'ExactMatchInput()';
}

/// Spec for exact match instance.
final class ExactMatchInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ExactMatchInstance({required this.prediction, required this.reference})
    : super(fullyQualifiedName);

  factory ExactMatchInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExactMatchInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ExactMatchInstance($contents)';
  }
}

/// Spec for exact match metric - returns 1 if prediction and reference exactly
/// matches, otherwise 0.
final class ExactMatchSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchSpec';

  ExactMatchSpec() : super(fullyQualifiedName);

  factory ExactMatchSpec.fromJson(Object? j) => ExactMatchSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'ExactMatchSpec()';
}

/// Results for exact match metric.
final class ExactMatchResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchResults';

  /// Output only. Exact match metric values.
  final List<ExactMatchMetricValue> exactMatchMetricValues;

  ExactMatchResults({this.exactMatchMetricValues = const []})
    : super(fullyQualifiedName);

  factory ExactMatchResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExactMatchResults(
      exactMatchMetricValues: switch (json['exactMatchMetricValues']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ExactMatchMetricValue.fromJson(i),
        ],
        _ => throw const FormatException(
          '"exactMatchMetricValues" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (exactMatchMetricValues.isNotDefault)
      'exactMatchMetricValues': encodeList(exactMatchMetricValues),
  };

  @override
  String toString() => 'ExactMatchResults()';
}

/// Exact match metric value for an instance.
final class ExactMatchMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchMetricValue';

  /// Output only. Exact match score.
  final double? score;

  ExactMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory ExactMatchMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExactMatchMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ExactMatchMetricValue($contents)';
  }
}

/// Input for bleu metric.
final class BleuInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuInput';

  /// Required. Spec for bleu score metric.
  final BleuSpec? metricSpec;

  /// Required. Repeated bleu instances.
  final List<BleuInstance> instances;

  BleuInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory BleuInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BleuInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => BleuSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) BleuInstance.fromJson(i)],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'BleuInput()';
}

/// Spec for bleu instance.
final class BleuInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  BleuInstance({required this.prediction, required this.reference})
    : super(fullyQualifiedName);

  factory BleuInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BleuInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'BleuInstance($contents)';
  }
}

/// Spec for bleu score metric - calculates the precision of n-grams in the
/// prediction as compared to reference - returns a score ranging between 0 to 1.
final class BleuSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuSpec';

  /// Optional. Whether to use_effective_order to compute bleu score.
  final bool useEffectiveOrder;

  BleuSpec({this.useEffectiveOrder = false}) : super(fullyQualifiedName);

  factory BleuSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BleuSpec(
      useEffectiveOrder: switch (json['useEffectiveOrder']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useEffectiveOrder.isNotDefault) 'useEffectiveOrder': useEffectiveOrder,
  };

  @override
  String toString() {
    final contents = ['useEffectiveOrder=$useEffectiveOrder'].join(',');
    return 'BleuSpec($contents)';
  }
}

/// Results for bleu metric.
final class BleuResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuResults';

  /// Output only. Bleu metric values.
  final List<BleuMetricValue> bleuMetricValues;

  BleuResults({this.bleuMetricValues = const []}) : super(fullyQualifiedName);

  factory BleuResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BleuResults(
      bleuMetricValues: switch (json['bleuMetricValues']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) BleuMetricValue.fromJson(i)],
        _ => throw const FormatException('"bleuMetricValues" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (bleuMetricValues.isNotDefault)
      'bleuMetricValues': encodeList(bleuMetricValues),
  };

  @override
  String toString() => 'BleuResults()';
}

/// Bleu metric value for an instance.
final class BleuMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuMetricValue';

  /// Output only. Bleu score.
  final double? score;

  BleuMetricValue({this.score}) : super(fullyQualifiedName);

  factory BleuMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BleuMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'BleuMetricValue($contents)';
  }
}

/// Input for rouge metric.
final class RougeInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeInput';

  /// Required. Spec for rouge score metric.
  final RougeSpec? metricSpec;

  /// Required. Repeated rouge instances.
  final List<RougeInstance> instances;

  RougeInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory RougeInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RougeInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => RougeSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) RougeInstance.fromJson(i)],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'RougeInput()';
}

/// Spec for rouge instance.
final class RougeInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  RougeInstance({required this.prediction, required this.reference})
    : super(fullyQualifiedName);

  factory RougeInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RougeInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'RougeInstance($contents)';
  }
}

/// Spec for rouge score metric - calculates the recall of n-grams in prediction
/// as compared to reference - returns a score ranging between 0 and 1.
final class RougeSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeSpec';

  /// Optional. Supported rouge types are rougen[1-9], rougeL, and rougeLsum.
  final String rougeType;

  /// Optional. Whether to use stemmer to compute rouge score.
  final bool useStemmer;

  /// Optional. Whether to split summaries while using rougeLsum.
  final bool splitSummaries;

  RougeSpec({
    this.rougeType = '',
    this.useStemmer = false,
    this.splitSummaries = false,
  }) : super(fullyQualifiedName);

  factory RougeSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RougeSpec(
      rougeType: switch (json['rougeType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      useStemmer: switch (json['useStemmer']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      splitSummaries: switch (json['splitSummaries']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (rougeType.isNotDefault) 'rougeType': rougeType,
    if (useStemmer.isNotDefault) 'useStemmer': useStemmer,
    if (splitSummaries.isNotDefault) 'splitSummaries': splitSummaries,
  };

  @override
  String toString() {
    final contents = [
      'rougeType=$rougeType',
      'useStemmer=$useStemmer',
      'splitSummaries=$splitSummaries',
    ].join(',');
    return 'RougeSpec($contents)';
  }
}

/// Results for rouge metric.
final class RougeResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeResults';

  /// Output only. Rouge metric values.
  final List<RougeMetricValue> rougeMetricValues;

  RougeResults({this.rougeMetricValues = const []}) : super(fullyQualifiedName);

  factory RougeResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RougeResults(
      rougeMetricValues: switch (json['rougeMetricValues']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) RougeMetricValue.fromJson(i)],
        _ => throw const FormatException('"rougeMetricValues" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (rougeMetricValues.isNotDefault)
      'rougeMetricValues': encodeList(rougeMetricValues),
  };

  @override
  String toString() => 'RougeResults()';
}

/// Rouge metric value for an instance.
final class RougeMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeMetricValue';

  /// Output only. Rouge score.
  final double? score;

  RougeMetricValue({this.score}) : super(fullyQualifiedName);

  factory RougeMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RougeMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'RougeMetricValue($contents)';
  }
}

/// Input for coherence metric.
final class CoherenceInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CoherenceInput';

  /// Required. Spec for coherence score metric.
  final CoherenceSpec? metricSpec;

  /// Required. Coherence instance.
  final CoherenceInstance? instance;

  CoherenceInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory CoherenceInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CoherenceInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => CoherenceSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => CoherenceInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'CoherenceInput()';
}

/// Spec for coherence instance.
final class CoherenceInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CoherenceInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  CoherenceInstance({required this.prediction}) : super(fullyQualifiedName);

  factory CoherenceInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CoherenceInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (prediction != null) 'prediction': prediction};

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
    ].join(',');
    return 'CoherenceInstance($contents)';
  }
}

/// Spec for coherence score metric.
final class CoherenceSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CoherenceSpec';

  /// Optional. Which version to use for evaluation.
  final int version;

  CoherenceSpec({this.version = 0}) : super(fullyQualifiedName);

  factory CoherenceSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CoherenceSpec(
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {if (version.isNotDefault) 'version': version};

  @override
  String toString() {
    final contents = ['version=$version'].join(',');
    return 'CoherenceSpec($contents)';
  }
}

/// Spec for coherence result.
final class CoherenceResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CoherenceResult';

  /// Output only. Coherence score.
  final double? score;

  /// Output only. Explanation for coherence score.
  final String explanation;

  /// Output only. Confidence for coherence score.
  final double? confidence;

  CoherenceResult({this.score, this.explanation = '', this.confidence})
    : super(fullyQualifiedName);

  factory CoherenceResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CoherenceResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'CoherenceResult($contents)';
  }
}

/// Input for fluency metric.
final class FluencyInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FluencyInput';

  /// Required. Spec for fluency score metric.
  final FluencySpec? metricSpec;

  /// Required. Fluency instance.
  final FluencyInstance? instance;

  FluencyInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory FluencyInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FluencyInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => FluencySpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => FluencyInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'FluencyInput()';
}

/// Spec for fluency instance.
final class FluencyInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FluencyInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  FluencyInstance({required this.prediction}) : super(fullyQualifiedName);

  factory FluencyInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FluencyInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (prediction != null) 'prediction': prediction};

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
    ].join(',');
    return 'FluencyInstance($contents)';
  }
}

/// Spec for fluency score metric.
final class FluencySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FluencySpec';

  /// Optional. Which version to use for evaluation.
  final int version;

  FluencySpec({this.version = 0}) : super(fullyQualifiedName);

  factory FluencySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FluencySpec(
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {if (version.isNotDefault) 'version': version};

  @override
  String toString() {
    final contents = ['version=$version'].join(',');
    return 'FluencySpec($contents)';
  }
}

/// Spec for fluency result.
final class FluencyResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FluencyResult';

  /// Output only. Fluency score.
  final double? score;

  /// Output only. Explanation for fluency score.
  final String explanation;

  /// Output only. Confidence for fluency score.
  final double? confidence;

  FluencyResult({this.score, this.explanation = '', this.confidence})
    : super(fullyQualifiedName);

  factory FluencyResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FluencyResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'FluencyResult($contents)';
  }
}

/// Input for safety metric.
final class SafetyInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetyInput';

  /// Required. Spec for safety metric.
  final SafetySpec? metricSpec;

  /// Required. Safety instance.
  final SafetyInstance? instance;

  SafetyInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory SafetyInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SafetyInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => SafetySpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => SafetyInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'SafetyInput()';
}

/// Spec for safety instance.
final class SafetyInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetyInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  SafetyInstance({required this.prediction}) : super(fullyQualifiedName);

  factory SafetyInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SafetyInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (prediction != null) 'prediction': prediction};

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
    ].join(',');
    return 'SafetyInstance($contents)';
  }
}

/// Spec for safety metric.
final class SafetySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetySpec';

  /// Optional. Which version to use for evaluation.
  final int version;

  SafetySpec({this.version = 0}) : super(fullyQualifiedName);

  factory SafetySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SafetySpec(
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {if (version.isNotDefault) 'version': version};

  @override
  String toString() {
    final contents = ['version=$version'].join(',');
    return 'SafetySpec($contents)';
  }
}

/// Spec for safety result.
final class SafetyResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetyResult';

  /// Output only. Safety score.
  final double? score;

  /// Output only. Explanation for safety score.
  final String explanation;

  /// Output only. Confidence for safety score.
  final double? confidence;

  SafetyResult({this.score, this.explanation = '', this.confidence})
    : super(fullyQualifiedName);

  factory SafetyResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SafetyResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'SafetyResult($contents)';
  }
}

/// Input for groundedness metric.
final class GroundednessInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundednessInput';

  /// Required. Spec for groundedness metric.
  final GroundednessSpec? metricSpec;

  /// Required. Groundedness instance.
  final GroundednessInstance? instance;

  GroundednessInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory GroundednessInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundednessInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => GroundednessSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => GroundednessInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'GroundednessInput()';
}

/// Spec for groundedness instance.
final class GroundednessInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundednessInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Background information provided in context used to compare
  /// against the prediction.
  final String? context;

  GroundednessInstance({required this.prediction, required this.context})
    : super(fullyQualifiedName);

  factory GroundednessInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundednessInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (context != null) 'context': context,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (context != null) 'context=$context',
    ].join(',');
    return 'GroundednessInstance($contents)';
  }
}

/// Spec for groundedness metric.
final class GroundednessSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundednessSpec';

  /// Optional. Which version to use for evaluation.
  final int version;

  GroundednessSpec({this.version = 0}) : super(fullyQualifiedName);

  factory GroundednessSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundednessSpec(
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {if (version.isNotDefault) 'version': version};

  @override
  String toString() {
    final contents = ['version=$version'].join(',');
    return 'GroundednessSpec($contents)';
  }
}

/// Spec for groundedness result.
final class GroundednessResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundednessResult';

  /// Output only. Groundedness score.
  final double? score;

  /// Output only. Explanation for groundedness score.
  final String explanation;

  /// Output only. Confidence for groundedness score.
  final double? confidence;

  GroundednessResult({this.score, this.explanation = '', this.confidence})
    : super(fullyQualifiedName);

  factory GroundednessResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GroundednessResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'GroundednessResult($contents)';
  }
}

/// Input for fulfillment metric.
final class FulfillmentInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FulfillmentInput';

  /// Required. Spec for fulfillment score metric.
  final FulfillmentSpec? metricSpec;

  /// Required. Fulfillment instance.
  final FulfillmentInstance? instance;

  FulfillmentInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory FulfillmentInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FulfillmentInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => FulfillmentSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => FulfillmentInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'FulfillmentInput()';
}

/// Spec for fulfillment instance.
final class FulfillmentInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FulfillmentInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Inference instruction prompt to compare prediction with.
  final String? instruction;

  FulfillmentInstance({required this.prediction, required this.instruction})
    : super(fullyQualifiedName);

  factory FulfillmentInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FulfillmentInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'FulfillmentInstance($contents)';
  }
}

/// Spec for fulfillment metric.
final class FulfillmentSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FulfillmentSpec';

  /// Optional. Which version to use for evaluation.
  final int version;

  FulfillmentSpec({this.version = 0}) : super(fullyQualifiedName);

  factory FulfillmentSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FulfillmentSpec(
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {if (version.isNotDefault) 'version': version};

  @override
  String toString() {
    final contents = ['version=$version'].join(',');
    return 'FulfillmentSpec($contents)';
  }
}

/// Spec for fulfillment result.
final class FulfillmentResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FulfillmentResult';

  /// Output only. Fulfillment score.
  final double? score;

  /// Output only. Explanation for fulfillment score.
  final String explanation;

  /// Output only. Confidence for fulfillment score.
  final double? confidence;

  FulfillmentResult({this.score, this.explanation = '', this.confidence})
    : super(fullyQualifiedName);

  factory FulfillmentResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FulfillmentResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'FulfillmentResult($contents)';
  }
}

/// Input for summarization quality metric.
final class SummarizationQualityInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationQualityInput';

  /// Required. Spec for summarization quality score metric.
  final SummarizationQualitySpec? metricSpec;

  /// Required. Summarization quality instance.
  final SummarizationQualityInstance? instance;

  SummarizationQualityInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory SummarizationQualityInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationQualityInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => SummarizationQualitySpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => SummarizationQualityInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'SummarizationQualityInput()';
}

/// Spec for summarization quality instance.
final class SummarizationQualityInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationQualityInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to be summarized.
  final String? context;

  /// Required. Summarization prompt for LLM.
  final String? instruction;

  SummarizationQualityInstance({
    required this.prediction,
    this.reference,
    required this.context,
    required this.instruction,
  }) : super(fullyQualifiedName);

  factory SummarizationQualityInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationQualityInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'SummarizationQualityInstance($contents)';
  }
}

/// Spec for summarization quality score metric.
final class SummarizationQualitySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationQualitySpec';

  /// Optional. Whether to use instance.reference to compute summarization
  /// quality.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  SummarizationQualitySpec({this.useReference = false, this.version = 0})
    : super(fullyQualifiedName);

  factory SummarizationQualitySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationQualitySpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'SummarizationQualitySpec($contents)';
  }
}

/// Spec for summarization quality result.
final class SummarizationQualityResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationQualityResult';

  /// Output only. Summarization Quality score.
  final double? score;

  /// Output only. Explanation for summarization quality score.
  final String explanation;

  /// Output only. Confidence for summarization quality score.
  final double? confidence;

  SummarizationQualityResult({
    this.score,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory SummarizationQualityResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationQualityResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'SummarizationQualityResult($contents)';
  }
}

/// Input for pairwise summarization quality metric.
final class PairwiseSummarizationQualityInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseSummarizationQualityInput';

  /// Required. Spec for pairwise summarization quality score metric.
  final PairwiseSummarizationQualitySpec? metricSpec;

  /// Required. Pairwise summarization quality instance.
  final PairwiseSummarizationQualityInstance? instance;

  PairwiseSummarizationQualityInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory PairwiseSummarizationQualityInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseSummarizationQualityInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => PairwiseSummarizationQualitySpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => PairwiseSummarizationQualityInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'PairwiseSummarizationQualityInput()';
}

/// Spec for pairwise summarization quality instance.
final class PairwiseSummarizationQualityInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseSummarizationQualityInstance';

  /// Required. Output of the candidate model.
  final String? prediction;

  /// Required. Output of the baseline model.
  final String? baselinePrediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to be summarized.
  final String? context;

  /// Required. Summarization prompt for LLM.
  final String? instruction;

  PairwiseSummarizationQualityInstance({
    required this.prediction,
    required this.baselinePrediction,
    this.reference,
    required this.context,
    required this.instruction,
  }) : super(fullyQualifiedName);

  factory PairwiseSummarizationQualityInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseSummarizationQualityInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      baselinePrediction: switch (json['baselinePrediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (baselinePrediction != null) 'baselinePrediction': baselinePrediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (baselinePrediction != null) 'baselinePrediction=$baselinePrediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'PairwiseSummarizationQualityInstance($contents)';
  }
}

/// Spec for pairwise summarization quality score metric.
final class PairwiseSummarizationQualitySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseSummarizationQualitySpec';

  /// Optional. Whether to use instance.reference to compute pairwise
  /// summarization quality.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  PairwiseSummarizationQualitySpec({
    this.useReference = false,
    this.version = 0,
  }) : super(fullyQualifiedName);

  factory PairwiseSummarizationQualitySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseSummarizationQualitySpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'PairwiseSummarizationQualitySpec($contents)';
  }
}

/// Spec for pairwise summarization quality result.
final class PairwiseSummarizationQualityResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseSummarizationQualityResult';

  /// Output only. Pairwise summarization prediction choice.
  final PairwiseChoice pairwiseChoice;

  /// Output only. Explanation for summarization quality score.
  final String explanation;

  /// Output only. Confidence for summarization quality score.
  final double? confidence;

  PairwiseSummarizationQualityResult({
    this.pairwiseChoice = PairwiseChoice.$default,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory PairwiseSummarizationQualityResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseSummarizationQualityResult(
      pairwiseChoice: switch (json['pairwiseChoice']) {
        null => PairwiseChoice.$default,
        Object $1 => PairwiseChoice.fromJson($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (pairwiseChoice.isNotDefault) 'pairwiseChoice': pairwiseChoice.toJson(),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      'pairwiseChoice=$pairwiseChoice',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'PairwiseSummarizationQualityResult($contents)';
  }
}

/// Input for summarization helpfulness metric.
final class SummarizationHelpfulnessInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationHelpfulnessInput';

  /// Required. Spec for summarization helpfulness score metric.
  final SummarizationHelpfulnessSpec? metricSpec;

  /// Required. Summarization helpfulness instance.
  final SummarizationHelpfulnessInstance? instance;

  SummarizationHelpfulnessInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory SummarizationHelpfulnessInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationHelpfulnessInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => SummarizationHelpfulnessSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => SummarizationHelpfulnessInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'SummarizationHelpfulnessInput()';
}

/// Spec for summarization helpfulness instance.
final class SummarizationHelpfulnessInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationHelpfulnessInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to be summarized.
  final String? context;

  /// Optional. Summarization prompt for LLM.
  final String? instruction;

  SummarizationHelpfulnessInstance({
    required this.prediction,
    this.reference,
    required this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory SummarizationHelpfulnessInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationHelpfulnessInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'SummarizationHelpfulnessInstance($contents)';
  }
}

/// Spec for summarization helpfulness score metric.
final class SummarizationHelpfulnessSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationHelpfulnessSpec';

  /// Optional. Whether to use instance.reference to compute summarization
  /// helpfulness.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  SummarizationHelpfulnessSpec({this.useReference = false, this.version = 0})
    : super(fullyQualifiedName);

  factory SummarizationHelpfulnessSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationHelpfulnessSpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'SummarizationHelpfulnessSpec($contents)';
  }
}

/// Spec for summarization helpfulness result.
final class SummarizationHelpfulnessResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationHelpfulnessResult';

  /// Output only. Summarization Helpfulness score.
  final double? score;

  /// Output only. Explanation for summarization helpfulness score.
  final String explanation;

  /// Output only. Confidence for summarization helpfulness score.
  final double? confidence;

  SummarizationHelpfulnessResult({
    this.score,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory SummarizationHelpfulnessResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationHelpfulnessResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'SummarizationHelpfulnessResult($contents)';
  }
}

/// Input for summarization verbosity metric.
final class SummarizationVerbosityInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationVerbosityInput';

  /// Required. Spec for summarization verbosity score metric.
  final SummarizationVerbositySpec? metricSpec;

  /// Required. Summarization verbosity instance.
  final SummarizationVerbosityInstance? instance;

  SummarizationVerbosityInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory SummarizationVerbosityInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationVerbosityInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => SummarizationVerbositySpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => SummarizationVerbosityInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'SummarizationVerbosityInput()';
}

/// Spec for summarization verbosity instance.
final class SummarizationVerbosityInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationVerbosityInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to be summarized.
  final String? context;

  /// Optional. Summarization prompt for LLM.
  final String? instruction;

  SummarizationVerbosityInstance({
    required this.prediction,
    this.reference,
    required this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory SummarizationVerbosityInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationVerbosityInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'SummarizationVerbosityInstance($contents)';
  }
}

/// Spec for summarization verbosity score metric.
final class SummarizationVerbositySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationVerbositySpec';

  /// Optional. Whether to use instance.reference to compute summarization
  /// verbosity.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  SummarizationVerbositySpec({this.useReference = false, this.version = 0})
    : super(fullyQualifiedName);

  factory SummarizationVerbositySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationVerbositySpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'SummarizationVerbositySpec($contents)';
  }
}

/// Spec for summarization verbosity result.
final class SummarizationVerbosityResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationVerbosityResult';

  /// Output only. Summarization Verbosity score.
  final double? score;

  /// Output only. Explanation for summarization verbosity score.
  final String explanation;

  /// Output only. Confidence for summarization verbosity score.
  final double? confidence;

  SummarizationVerbosityResult({
    this.score,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory SummarizationVerbosityResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SummarizationVerbosityResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'SummarizationVerbosityResult($contents)';
  }
}

/// Input for question answering quality metric.
final class QuestionAnsweringQualityInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringQualityInput';

  /// Required. Spec for question answering quality score metric.
  final QuestionAnsweringQualitySpec? metricSpec;

  /// Required. Question answering quality instance.
  final QuestionAnsweringQualityInstance? instance;

  QuestionAnsweringQualityInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringQualityInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringQualityInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => QuestionAnsweringQualitySpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => QuestionAnsweringQualityInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'QuestionAnsweringQualityInput()';
}

/// Spec for question answering quality instance.
final class QuestionAnsweringQualityInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringQualityInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to answer the question.
  final String? context;

  /// Required. Question Answering prompt for LLM.
  final String? instruction;

  QuestionAnsweringQualityInstance({
    required this.prediction,
    this.reference,
    required this.context,
    required this.instruction,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringQualityInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringQualityInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'QuestionAnsweringQualityInstance($contents)';
  }
}

/// Spec for question answering quality score metric.
final class QuestionAnsweringQualitySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringQualitySpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// quality.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  QuestionAnsweringQualitySpec({this.useReference = false, this.version = 0})
    : super(fullyQualifiedName);

  factory QuestionAnsweringQualitySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringQualitySpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'QuestionAnsweringQualitySpec($contents)';
  }
}

/// Spec for question answering quality result.
final class QuestionAnsweringQualityResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringQualityResult';

  /// Output only. Question Answering Quality score.
  final double? score;

  /// Output only. Explanation for question answering quality score.
  final String explanation;

  /// Output only. Confidence for question answering quality score.
  final double? confidence;

  QuestionAnsweringQualityResult({
    this.score,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringQualityResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringQualityResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'QuestionAnsweringQualityResult($contents)';
  }
}

/// Input for pairwise question answering quality metric.
final class PairwiseQuestionAnsweringQualityInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseQuestionAnsweringQualityInput';

  /// Required. Spec for pairwise question answering quality score metric.
  final PairwiseQuestionAnsweringQualitySpec? metricSpec;

  /// Required. Pairwise question answering quality instance.
  final PairwiseQuestionAnsweringQualityInstance? instance;

  PairwiseQuestionAnsweringQualityInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory PairwiseQuestionAnsweringQualityInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseQuestionAnsweringQualityInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => PairwiseQuestionAnsweringQualitySpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => PairwiseQuestionAnsweringQualityInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'PairwiseQuestionAnsweringQualityInput()';
}

/// Spec for pairwise question answering quality instance.
final class PairwiseQuestionAnsweringQualityInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseQuestionAnsweringQualityInstance';

  /// Required. Output of the candidate model.
  final String? prediction;

  /// Required. Output of the baseline model.
  final String? baselinePrediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to answer the question.
  final String? context;

  /// Required. Question Answering prompt for LLM.
  final String? instruction;

  PairwiseQuestionAnsweringQualityInstance({
    required this.prediction,
    required this.baselinePrediction,
    this.reference,
    required this.context,
    required this.instruction,
  }) : super(fullyQualifiedName);

  factory PairwiseQuestionAnsweringQualityInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseQuestionAnsweringQualityInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      baselinePrediction: switch (json['baselinePrediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (baselinePrediction != null) 'baselinePrediction': baselinePrediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (baselinePrediction != null) 'baselinePrediction=$baselinePrediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'PairwiseQuestionAnsweringQualityInstance($contents)';
  }
}

/// Spec for pairwise question answering quality score metric.
final class PairwiseQuestionAnsweringQualitySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseQuestionAnsweringQualitySpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// quality.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  PairwiseQuestionAnsweringQualitySpec({
    this.useReference = false,
    this.version = 0,
  }) : super(fullyQualifiedName);

  factory PairwiseQuestionAnsweringQualitySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseQuestionAnsweringQualitySpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'PairwiseQuestionAnsweringQualitySpec($contents)';
  }
}

/// Spec for pairwise question answering quality result.
final class PairwiseQuestionAnsweringQualityResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseQuestionAnsweringQualityResult';

  /// Output only. Pairwise question answering prediction choice.
  final PairwiseChoice pairwiseChoice;

  /// Output only. Explanation for question answering quality score.
  final String explanation;

  /// Output only. Confidence for question answering quality score.
  final double? confidence;

  PairwiseQuestionAnsweringQualityResult({
    this.pairwiseChoice = PairwiseChoice.$default,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory PairwiseQuestionAnsweringQualityResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseQuestionAnsweringQualityResult(
      pairwiseChoice: switch (json['pairwiseChoice']) {
        null => PairwiseChoice.$default,
        Object $1 => PairwiseChoice.fromJson($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (pairwiseChoice.isNotDefault) 'pairwiseChoice': pairwiseChoice.toJson(),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      'pairwiseChoice=$pairwiseChoice',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'PairwiseQuestionAnsweringQualityResult($contents)';
  }
}

/// Input for question answering relevance metric.
final class QuestionAnsweringRelevanceInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringRelevanceInput';

  /// Required. Spec for question answering relevance score metric.
  final QuestionAnsweringRelevanceSpec? metricSpec;

  /// Required. Question answering relevance instance.
  final QuestionAnsweringRelevanceInstance? instance;

  QuestionAnsweringRelevanceInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringRelevanceInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringRelevanceInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => QuestionAnsweringRelevanceSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => QuestionAnsweringRelevanceInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'QuestionAnsweringRelevanceInput()';
}

/// Spec for question answering relevance instance.
final class QuestionAnsweringRelevanceInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringRelevanceInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Text provided as context to answer the question.
  final String? context;

  /// Required. The question asked and other instruction in the inference prompt.
  final String? instruction;

  QuestionAnsweringRelevanceInstance({
    required this.prediction,
    this.reference,
    this.context,
    required this.instruction,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringRelevanceInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringRelevanceInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'QuestionAnsweringRelevanceInstance($contents)';
  }
}

/// Spec for question answering relevance metric.
final class QuestionAnsweringRelevanceSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringRelevanceSpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// relevance.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  QuestionAnsweringRelevanceSpec({this.useReference = false, this.version = 0})
    : super(fullyQualifiedName);

  factory QuestionAnsweringRelevanceSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringRelevanceSpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'QuestionAnsweringRelevanceSpec($contents)';
  }
}

/// Spec for question answering relevance result.
final class QuestionAnsweringRelevanceResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringRelevanceResult';

  /// Output only. Question Answering Relevance score.
  final double? score;

  /// Output only. Explanation for question answering relevance score.
  final String explanation;

  /// Output only. Confidence for question answering relevance score.
  final double? confidence;

  QuestionAnsweringRelevanceResult({
    this.score,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringRelevanceResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringRelevanceResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'QuestionAnsweringRelevanceResult($contents)';
  }
}

/// Input for question answering helpfulness metric.
final class QuestionAnsweringHelpfulnessInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringHelpfulnessInput';

  /// Required. Spec for question answering helpfulness score metric.
  final QuestionAnsweringHelpfulnessSpec? metricSpec;

  /// Required. Question answering helpfulness instance.
  final QuestionAnsweringHelpfulnessInstance? instance;

  QuestionAnsweringHelpfulnessInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringHelpfulnessInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringHelpfulnessInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => QuestionAnsweringHelpfulnessSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => QuestionAnsweringHelpfulnessInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'QuestionAnsweringHelpfulnessInput()';
}

/// Spec for question answering helpfulness instance.
final class QuestionAnsweringHelpfulnessInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringHelpfulnessInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Text provided as context to answer the question.
  final String? context;

  /// Required. The question asked and other instruction in the inference prompt.
  final String? instruction;

  QuestionAnsweringHelpfulnessInstance({
    required this.prediction,
    this.reference,
    this.context,
    required this.instruction,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringHelpfulnessInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringHelpfulnessInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'QuestionAnsweringHelpfulnessInstance($contents)';
  }
}

/// Spec for question answering helpfulness metric.
final class QuestionAnsweringHelpfulnessSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringHelpfulnessSpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// helpfulness.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  QuestionAnsweringHelpfulnessSpec({
    this.useReference = false,
    this.version = 0,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringHelpfulnessSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringHelpfulnessSpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'QuestionAnsweringHelpfulnessSpec($contents)';
  }
}

/// Spec for question answering helpfulness result.
final class QuestionAnsweringHelpfulnessResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringHelpfulnessResult';

  /// Output only. Question Answering Helpfulness score.
  final double? score;

  /// Output only. Explanation for question answering helpfulness score.
  final String explanation;

  /// Output only. Confidence for question answering helpfulness score.
  final double? confidence;

  QuestionAnsweringHelpfulnessResult({
    this.score,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringHelpfulnessResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringHelpfulnessResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'QuestionAnsweringHelpfulnessResult($contents)';
  }
}

/// Input for question answering correctness metric.
final class QuestionAnsweringCorrectnessInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringCorrectnessInput';

  /// Required. Spec for question answering correctness score metric.
  final QuestionAnsweringCorrectnessSpec? metricSpec;

  /// Required. Question answering correctness instance.
  final QuestionAnsweringCorrectnessInstance? instance;

  QuestionAnsweringCorrectnessInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringCorrectnessInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringCorrectnessInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => QuestionAnsweringCorrectnessSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => QuestionAnsweringCorrectnessInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'QuestionAnsweringCorrectnessInput()';
}

/// Spec for question answering correctness instance.
final class QuestionAnsweringCorrectnessInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringCorrectnessInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Text provided as context to answer the question.
  final String? context;

  /// Required. The question asked and other instruction in the inference prompt.
  final String? instruction;

  QuestionAnsweringCorrectnessInstance({
    required this.prediction,
    this.reference,
    this.context,
    required this.instruction,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringCorrectnessInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringCorrectnessInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instruction: switch (json['instruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (context != null) 'context': context,
    if (instruction != null) 'instruction': instruction,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'QuestionAnsweringCorrectnessInstance($contents)';
  }
}

/// Spec for question answering correctness metric.
final class QuestionAnsweringCorrectnessSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringCorrectnessSpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// correctness.
  final bool useReference;

  /// Optional. Which version to use for evaluation.
  final int version;

  QuestionAnsweringCorrectnessSpec({
    this.useReference = false,
    this.version = 0,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringCorrectnessSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringCorrectnessSpec(
      useReference: switch (json['useReference']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useReference.isNotDefault) 'useReference': useReference,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'useReference=$useReference',
      'version=$version',
    ].join(',');
    return 'QuestionAnsweringCorrectnessSpec($contents)';
  }
}

/// Spec for question answering correctness result.
final class QuestionAnsweringCorrectnessResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringCorrectnessResult';

  /// Output only. Question Answering Correctness score.
  final double? score;

  /// Output only. Explanation for question answering correctness score.
  final String explanation;

  /// Output only. Confidence for question answering correctness score.
  final double? confidence;

  QuestionAnsweringCorrectnessResult({
    this.score,
    this.explanation = '',
    this.confidence,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringCorrectnessResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuestionAnsweringCorrectnessResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (confidence != null) 'confidence': encodeDouble(confidence),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'QuestionAnsweringCorrectnessResult($contents)';
  }
}

/// Input for pointwise metric.
final class PointwiseMetricInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PointwiseMetricInput';

  /// Required. Spec for pointwise metric.
  final PointwiseMetricSpec? metricSpec;

  /// Required. Pointwise metric instance.
  final PointwiseMetricInstance? instance;

  PointwiseMetricInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory PointwiseMetricInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PointwiseMetricInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => PointwiseMetricSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => PointwiseMetricInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'PointwiseMetricInput()';
}

/// Pointwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
final class PointwiseMetricInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PointwiseMetricInstance';

  /// Instance specified as a json string. String key-value pairs are expected
  /// in the json_instance to render
  /// PointwiseMetricSpec.instance_prompt_template.
  final String? jsonInstance;

  /// Key-value contents for the mutlimodality input, including text, image,
  /// video, audio, and pdf, etc. The key is placeholder in metric prompt
  /// template, and the value is the multimodal content.
  final ContentMap? contentMapInstance;

  PointwiseMetricInstance({this.jsonInstance, this.contentMapInstance})
    : super(fullyQualifiedName);

  factory PointwiseMetricInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PointwiseMetricInstance(
      jsonInstance: switch (json['jsonInstance']) {
        null => null,
        Object $1 => decodeString($1),
      },
      contentMapInstance: switch (json['contentMapInstance']) {
        null => null,
        Object $1 => ContentMap.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (jsonInstance != null) 'jsonInstance': jsonInstance,
    if (contentMapInstance != null)
      'contentMapInstance': contentMapInstance!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (jsonInstance != null) 'jsonInstance=$jsonInstance',
    ].join(',');
    return 'PointwiseMetricInstance($contents)';
  }
}

/// Spec for pointwise metric.
final class PointwiseMetricSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PointwiseMetricSpec';

  /// Required. Metric prompt template for pointwise metric.
  final String? metricPromptTemplate;

  /// Optional. System instructions for pointwise metric.
  final String? systemInstruction;

  /// Optional. CustomOutputFormatConfig allows customization of metric output.
  /// By default, metrics return a score and explanation.
  /// When this config is set, the default output is replaced with either:
  ///  - The raw output string.
  ///  - A parsed output based on a user-defined schema.
  /// If a custom format is chosen, the `score` and `explanation` fields in the
  /// corresponding metric result will be empty.
  final CustomOutputFormatConfig? customOutputFormatConfig;

  PointwiseMetricSpec({
    required this.metricPromptTemplate,
    this.systemInstruction,
    this.customOutputFormatConfig,
  }) : super(fullyQualifiedName);

  factory PointwiseMetricSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PointwiseMetricSpec(
      metricPromptTemplate: switch (json['metricPromptTemplate']) {
        null => null,
        Object $1 => decodeString($1),
      },
      systemInstruction: switch (json['systemInstruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      customOutputFormatConfig: switch (json['customOutputFormatConfig']) {
        null => null,
        Object $1 => CustomOutputFormatConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricPromptTemplate != null)
      'metricPromptTemplate': metricPromptTemplate,
    if (systemInstruction != null) 'systemInstruction': systemInstruction,
    if (customOutputFormatConfig != null)
      'customOutputFormatConfig': customOutputFormatConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (metricPromptTemplate != null)
        'metricPromptTemplate=$metricPromptTemplate',
      if (systemInstruction != null) 'systemInstruction=$systemInstruction',
    ].join(',');
    return 'PointwiseMetricSpec($contents)';
  }
}

/// Spec for custom output format configuration.
final class CustomOutputFormatConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CustomOutputFormatConfig';

  /// Optional. Whether to return raw output.
  final bool? returnRawOutput;

  CustomOutputFormatConfig({this.returnRawOutput}) : super(fullyQualifiedName);

  factory CustomOutputFormatConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CustomOutputFormatConfig(
      returnRawOutput: switch (json['returnRawOutput']) {
        null => null,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (returnRawOutput != null) 'returnRawOutput': returnRawOutput,
  };

  @override
  String toString() {
    final contents = [
      if (returnRawOutput != null) 'returnRawOutput=$returnRawOutput',
    ].join(',');
    return 'CustomOutputFormatConfig($contents)';
  }
}

/// Spec for pointwise metric result.
final class PointwiseMetricResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PointwiseMetricResult';

  /// Output only. Pointwise metric score.
  final double? score;

  /// Output only. Explanation for pointwise metric score.
  final String explanation;

  /// Output only. Spec for custom output.
  final CustomOutput? customOutput;

  PointwiseMetricResult({this.score, this.explanation = '', this.customOutput})
    : super(fullyQualifiedName);

  factory PointwiseMetricResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PointwiseMetricResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      customOutput: switch (json['customOutput']) {
        null => null,
        Object $1 => CustomOutput.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (customOutput != null) 'customOutput': customOutput!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      'explanation=$explanation',
    ].join(',');
    return 'PointwiseMetricResult($contents)';
  }
}

/// Spec for custom output.
final class CustomOutput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CustomOutput';

  /// Output only. List of raw output strings.
  final RawOutput? rawOutputs;

  CustomOutput({this.rawOutputs}) : super(fullyQualifiedName);

  factory CustomOutput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CustomOutput(
      rawOutputs: switch (json['rawOutputs']) {
        null => null,
        Object $1 => RawOutput.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (rawOutputs != null) 'rawOutputs': rawOutputs!.toJson(),
  };

  @override
  String toString() => 'CustomOutput()';
}

/// Raw output.
final class RawOutput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RawOutput';

  /// Output only. Raw output string.
  final List<String> rawOutput;

  RawOutput({this.rawOutput = const []}) : super(fullyQualifiedName);

  factory RawOutput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RawOutput(
      rawOutput: switch (json['rawOutput']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"rawOutput" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (rawOutput.isNotDefault) 'rawOutput': rawOutput};

  @override
  String toString() => 'RawOutput()';
}

/// Input for pairwise metric.
final class PairwiseMetricInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseMetricInput';

  /// Required. Spec for pairwise metric.
  final PairwiseMetricSpec? metricSpec;

  /// Required. Pairwise metric instance.
  final PairwiseMetricInstance? instance;

  PairwiseMetricInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory PairwiseMetricInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseMetricInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => PairwiseMetricSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => PairwiseMetricInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'PairwiseMetricInput()';
}

/// Pairwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
final class PairwiseMetricInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseMetricInstance';

  /// Instance specified as a json string. String key-value pairs are expected
  /// in the json_instance to render
  /// PairwiseMetricSpec.instance_prompt_template.
  final String? jsonInstance;

  /// Key-value contents for the mutlimodality input, including text, image,
  /// video, audio, and pdf, etc. The key is placeholder in metric prompt
  /// template, and the value is the multimodal content.
  final ContentMap? contentMapInstance;

  PairwiseMetricInstance({this.jsonInstance, this.contentMapInstance})
    : super(fullyQualifiedName);

  factory PairwiseMetricInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseMetricInstance(
      jsonInstance: switch (json['jsonInstance']) {
        null => null,
        Object $1 => decodeString($1),
      },
      contentMapInstance: switch (json['contentMapInstance']) {
        null => null,
        Object $1 => ContentMap.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (jsonInstance != null) 'jsonInstance': jsonInstance,
    if (contentMapInstance != null)
      'contentMapInstance': contentMapInstance!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (jsonInstance != null) 'jsonInstance=$jsonInstance',
    ].join(',');
    return 'PairwiseMetricInstance($contents)';
  }
}

/// Spec for pairwise metric.
final class PairwiseMetricSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseMetricSpec';

  /// Required. Metric prompt template for pairwise metric.
  final String? metricPromptTemplate;

  /// Optional. The field name of the candidate response.
  final String candidateResponseFieldName;

  /// Optional. The field name of the baseline response.
  final String baselineResponseFieldName;

  /// Optional. System instructions for pairwise metric.
  final String? systemInstruction;

  /// Optional. CustomOutputFormatConfig allows customization of metric output.
  /// When this config is set, the default output is replaced with
  /// the raw output string.
  /// If a custom format is chosen, the `pairwise_choice` and `explanation`
  /// fields in the corresponding metric result will be empty.
  final CustomOutputFormatConfig? customOutputFormatConfig;

  PairwiseMetricSpec({
    required this.metricPromptTemplate,
    this.candidateResponseFieldName = '',
    this.baselineResponseFieldName = '',
    this.systemInstruction,
    this.customOutputFormatConfig,
  }) : super(fullyQualifiedName);

  factory PairwiseMetricSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseMetricSpec(
      metricPromptTemplate: switch (json['metricPromptTemplate']) {
        null => null,
        Object $1 => decodeString($1),
      },
      candidateResponseFieldName: switch (json['candidateResponseFieldName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      baselineResponseFieldName: switch (json['baselineResponseFieldName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      systemInstruction: switch (json['systemInstruction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      customOutputFormatConfig: switch (json['customOutputFormatConfig']) {
        null => null,
        Object $1 => CustomOutputFormatConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricPromptTemplate != null)
      'metricPromptTemplate': metricPromptTemplate,
    if (candidateResponseFieldName.isNotDefault)
      'candidateResponseFieldName': candidateResponseFieldName,
    if (baselineResponseFieldName.isNotDefault)
      'baselineResponseFieldName': baselineResponseFieldName,
    if (systemInstruction != null) 'systemInstruction': systemInstruction,
    if (customOutputFormatConfig != null)
      'customOutputFormatConfig': customOutputFormatConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (metricPromptTemplate != null)
        'metricPromptTemplate=$metricPromptTemplate',
      'candidateResponseFieldName=$candidateResponseFieldName',
      'baselineResponseFieldName=$baselineResponseFieldName',
      if (systemInstruction != null) 'systemInstruction=$systemInstruction',
    ].join(',');
    return 'PairwiseMetricSpec($contents)';
  }
}

/// Spec for pairwise metric result.
final class PairwiseMetricResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseMetricResult';

  /// Output only. Pairwise metric choice.
  final PairwiseChoice pairwiseChoice;

  /// Output only. Explanation for pairwise metric score.
  final String explanation;

  /// Output only. Spec for custom output.
  final CustomOutput? customOutput;

  PairwiseMetricResult({
    this.pairwiseChoice = PairwiseChoice.$default,
    this.explanation = '',
    this.customOutput,
  }) : super(fullyQualifiedName);

  factory PairwiseMetricResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PairwiseMetricResult(
      pairwiseChoice: switch (json['pairwiseChoice']) {
        null => PairwiseChoice.$default,
        Object $1 => PairwiseChoice.fromJson($1),
      },
      explanation: switch (json['explanation']) {
        null => '',
        Object $1 => decodeString($1),
      },
      customOutput: switch (json['customOutput']) {
        null => null,
        Object $1 => CustomOutput.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (pairwiseChoice.isNotDefault) 'pairwiseChoice': pairwiseChoice.toJson(),
    if (explanation.isNotDefault) 'explanation': explanation,
    if (customOutput != null) 'customOutput': customOutput!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'pairwiseChoice=$pairwiseChoice',
      'explanation=$explanation',
    ].join(',');
    return 'PairwiseMetricResult($contents)';
  }
}

/// Input for tool call valid metric.
final class ToolCallValidInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidInput';

  /// Required. Spec for tool call valid metric.
  final ToolCallValidSpec? metricSpec;

  /// Required. Repeated tool call valid instances.
  final List<ToolCallValidInstance> instances;

  ToolCallValidInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory ToolCallValidInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolCallValidInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => ToolCallValidSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ToolCallValidInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'ToolCallValidInput()';
}

/// Spec for tool call valid metric.
final class ToolCallValidSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidSpec';

  ToolCallValidSpec() : super(fullyQualifiedName);

  factory ToolCallValidSpec.fromJson(Object? j) => ToolCallValidSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'ToolCallValidSpec()';
}

/// Spec for tool call valid instance.
final class ToolCallValidInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ToolCallValidInstance({required this.prediction, required this.reference})
    : super(fullyQualifiedName);

  factory ToolCallValidInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolCallValidInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ToolCallValidInstance($contents)';
  }
}

/// Results for tool call valid metric.
final class ToolCallValidResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidResults';

  /// Output only. Tool call valid metric values.
  final List<ToolCallValidMetricValue> toolCallValidMetricValues;

  ToolCallValidResults({this.toolCallValidMetricValues = const []})
    : super(fullyQualifiedName);

  factory ToolCallValidResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolCallValidResults(
      toolCallValidMetricValues: switch (json['toolCallValidMetricValues']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ToolCallValidMetricValue.fromJson(i),
        ],
        _ => throw const FormatException(
          '"toolCallValidMetricValues" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (toolCallValidMetricValues.isNotDefault)
      'toolCallValidMetricValues': encodeList(toolCallValidMetricValues),
  };

  @override
  String toString() => 'ToolCallValidResults()';
}

/// Tool call valid metric value for an instance.
final class ToolCallValidMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidMetricValue';

  /// Output only. Tool call valid score.
  final double? score;

  ToolCallValidMetricValue({this.score}) : super(fullyQualifiedName);

  factory ToolCallValidMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolCallValidMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ToolCallValidMetricValue($contents)';
  }
}

/// Input for tool name match metric.
final class ToolNameMatchInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchInput';

  /// Required. Spec for tool name match metric.
  final ToolNameMatchSpec? metricSpec;

  /// Required. Repeated tool name match instances.
  final List<ToolNameMatchInstance> instances;

  ToolNameMatchInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory ToolNameMatchInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolNameMatchInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => ToolNameMatchSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ToolNameMatchInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'ToolNameMatchInput()';
}

/// Spec for tool name match metric.
final class ToolNameMatchSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchSpec';

  ToolNameMatchSpec() : super(fullyQualifiedName);

  factory ToolNameMatchSpec.fromJson(Object? j) => ToolNameMatchSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'ToolNameMatchSpec()';
}

/// Spec for tool name match instance.
final class ToolNameMatchInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ToolNameMatchInstance({required this.prediction, required this.reference})
    : super(fullyQualifiedName);

  factory ToolNameMatchInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolNameMatchInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ToolNameMatchInstance($contents)';
  }
}

/// Results for tool name match metric.
final class ToolNameMatchResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchResults';

  /// Output only. Tool name match metric values.
  final List<ToolNameMatchMetricValue> toolNameMatchMetricValues;

  ToolNameMatchResults({this.toolNameMatchMetricValues = const []})
    : super(fullyQualifiedName);

  factory ToolNameMatchResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolNameMatchResults(
      toolNameMatchMetricValues: switch (json['toolNameMatchMetricValues']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ToolNameMatchMetricValue.fromJson(i),
        ],
        _ => throw const FormatException(
          '"toolNameMatchMetricValues" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (toolNameMatchMetricValues.isNotDefault)
      'toolNameMatchMetricValues': encodeList(toolNameMatchMetricValues),
  };

  @override
  String toString() => 'ToolNameMatchResults()';
}

/// Tool name match metric value for an instance.
final class ToolNameMatchMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchMetricValue';

  /// Output only. Tool name match score.
  final double? score;

  ToolNameMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory ToolNameMatchMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolNameMatchMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ToolNameMatchMetricValue($contents)';
  }
}

/// Input for tool parameter key match metric.
final class ToolParameterKeyMatchInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchInput';

  /// Required. Spec for tool parameter key match metric.
  final ToolParameterKeyMatchSpec? metricSpec;

  /// Required. Repeated tool parameter key match instances.
  final List<ToolParameterKeyMatchInstance> instances;

  ToolParameterKeyMatchInput({
    required this.metricSpec,
    required this.instances,
  }) : super(fullyQualifiedName);

  factory ToolParameterKeyMatchInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKeyMatchInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => ToolParameterKeyMatchSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ToolParameterKeyMatchInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'ToolParameterKeyMatchInput()';
}

/// Spec for tool parameter key match metric.
final class ToolParameterKeyMatchSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchSpec';

  ToolParameterKeyMatchSpec() : super(fullyQualifiedName);

  factory ToolParameterKeyMatchSpec.fromJson(Object? j) =>
      ToolParameterKeyMatchSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'ToolParameterKeyMatchSpec()';
}

/// Spec for tool parameter key match instance.
final class ToolParameterKeyMatchInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ToolParameterKeyMatchInstance({
    required this.prediction,
    required this.reference,
  }) : super(fullyQualifiedName);

  factory ToolParameterKeyMatchInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKeyMatchInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ToolParameterKeyMatchInstance($contents)';
  }
}

/// Results for tool parameter key match metric.
final class ToolParameterKeyMatchResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchResults';

  /// Output only. Tool parameter key match metric values.
  final List<ToolParameterKeyMatchMetricValue>
  toolParameterKeyMatchMetricValues;

  ToolParameterKeyMatchResults({
    this.toolParameterKeyMatchMetricValues = const [],
  }) : super(fullyQualifiedName);

  factory ToolParameterKeyMatchResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKeyMatchResults(
      toolParameterKeyMatchMetricValues:
          switch (json['toolParameterKeyMatchMetricValues']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) ToolParameterKeyMatchMetricValue.fromJson(i),
            ],
            _ => throw const FormatException(
              '"toolParameterKeyMatchMetricValues" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (toolParameterKeyMatchMetricValues.isNotDefault)
      'toolParameterKeyMatchMetricValues': encodeList(
        toolParameterKeyMatchMetricValues,
      ),
  };

  @override
  String toString() => 'ToolParameterKeyMatchResults()';
}

/// Tool parameter key match metric value for an instance.
final class ToolParameterKeyMatchMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchMetricValue';

  /// Output only. Tool parameter key match score.
  final double? score;

  ToolParameterKeyMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory ToolParameterKeyMatchMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKeyMatchMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ToolParameterKeyMatchMetricValue($contents)';
  }
}

/// Input for tool parameter key value match metric.
final class ToolParameterKvmatchInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchInput';

  /// Required. Spec for tool parameter key value match metric.
  final ToolParameterKvmatchSpec? metricSpec;

  /// Required. Repeated tool parameter key value match instances.
  final List<ToolParameterKvmatchInstance> instances;

  ToolParameterKvmatchInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory ToolParameterKvmatchInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKvmatchInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => ToolParameterKvmatchSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ToolParameterKvmatchInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'ToolParameterKVMatchInput()';
}

/// Spec for tool parameter key value match metric.
final class ToolParameterKvmatchSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchSpec';

  /// Optional. Whether to use STRICT string match on parameter values.
  final bool useStrictStringMatch;

  ToolParameterKvmatchSpec({this.useStrictStringMatch = false})
    : super(fullyQualifiedName);

  factory ToolParameterKvmatchSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKvmatchSpec(
      useStrictStringMatch: switch (json['useStrictStringMatch']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useStrictStringMatch.isNotDefault)
      'useStrictStringMatch': useStrictStringMatch,
  };

  @override
  String toString() {
    final contents = ['useStrictStringMatch=$useStrictStringMatch'].join(',');
    return 'ToolParameterKVMatchSpec($contents)';
  }
}

/// Spec for tool parameter key value match instance.
final class ToolParameterKvmatchInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ToolParameterKvmatchInstance({
    required this.prediction,
    required this.reference,
  }) : super(fullyQualifiedName);

  factory ToolParameterKvmatchInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKvmatchInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ToolParameterKVMatchInstance($contents)';
  }
}

/// Results for tool parameter key value match metric.
final class ToolParameterKvmatchResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchResults';

  /// Output only. Tool parameter key value match metric values.
  final List<ToolParameterKvmatchMetricValue> toolParameterKvMatchMetricValues;

  ToolParameterKvmatchResults({
    this.toolParameterKvMatchMetricValues = const [],
  }) : super(fullyQualifiedName);

  factory ToolParameterKvmatchResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKvmatchResults(
      toolParameterKvMatchMetricValues:
          switch (json['toolParameterKvMatchMetricValues']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) ToolParameterKvmatchMetricValue.fromJson(i),
            ],
            _ => throw const FormatException(
              '"toolParameterKvMatchMetricValues" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (toolParameterKvMatchMetricValues.isNotDefault)
      'toolParameterKvMatchMetricValues': encodeList(
        toolParameterKvMatchMetricValues,
      ),
  };

  @override
  String toString() => 'ToolParameterKVMatchResults()';
}

/// Tool parameter key value match metric value for an instance.
final class ToolParameterKvmatchMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchMetricValue';

  /// Output only. Tool parameter key value match score.
  final double? score;

  ToolParameterKvmatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory ToolParameterKvmatchMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolParameterKvmatchMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ToolParameterKVMatchMetricValue($contents)';
  }
}

/// Input for Comet metric.
final class CometInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CometInput';

  /// Required. Spec for comet metric.
  final CometSpec? metricSpec;

  /// Required. Comet instance.
  final CometInstance? instance;

  CometInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory CometInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CometInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => CometSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => CometInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'CometInput()';
}

/// Spec for Comet metric.
final class CometSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CometSpec';

  /// Required. Which version to use for evaluation.
  final CometSpec_CometVersion? version;

  /// Optional. Source language in BCP-47 format.
  final String sourceLanguage;

  /// Optional. Target language in BCP-47 format. Covers both prediction and
  /// reference.
  final String targetLanguage;

  CometSpec({
    required this.version,
    this.sourceLanguage = '',
    this.targetLanguage = '',
  }) : super(fullyQualifiedName);

  factory CometSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CometSpec(
      version: switch (json['version']) {
        null => null,
        Object $1 => CometSpec_CometVersion.fromJson($1),
      },
      sourceLanguage: switch (json['sourceLanguage']) {
        null => '',
        Object $1 => decodeString($1),
      },
      targetLanguage: switch (json['targetLanguage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (version != null) 'version': version!.toJson(),
    if (sourceLanguage.isNotDefault) 'sourceLanguage': sourceLanguage,
    if (targetLanguage.isNotDefault) 'targetLanguage': targetLanguage,
  };

  @override
  String toString() {
    final contents = [
      if (version != null) 'version=$version',
      'sourceLanguage=$sourceLanguage',
      'targetLanguage=$targetLanguage',
    ].join(',');
    return 'CometSpec($contents)';
  }
}

/// Comet version options.
final class CometSpec_CometVersion extends ProtoEnum {
  /// Comet version unspecified.
  static const cometVersionUnspecified = CometSpec_CometVersion(
    'COMET_VERSION_UNSPECIFIED',
  );

  /// Comet 22 for translation + source + reference
  /// (source-reference-combined).
  static const comet22SrcRef = CometSpec_CometVersion('COMET_22_SRC_REF');

  /// The default value for [CometSpec_CometVersion].
  static const $default = cometVersionUnspecified;

  const CometSpec_CometVersion(super.value);

  factory CometSpec_CometVersion.fromJson(Object? json) =>
      CometSpec_CometVersion(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'CometVersion.$value';
}

/// Spec for Comet instance - The fields used for evaluation are dependent on the
/// comet version.
final class CometInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CometInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Source text in original language.
  final String? source;

  CometInstance({required this.prediction, this.reference, this.source})
    : super(fullyQualifiedName);

  factory CometInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CometInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      source: switch (json['source']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (source != null) 'source': source,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (source != null) 'source=$source',
    ].join(',');
    return 'CometInstance($contents)';
  }
}

/// Spec for Comet result - calculates the comet score for the given instance
/// using the version specified in the spec.
final class CometResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CometResult';

  /// Output only. Comet score. Range depends on version.
  final double? score;

  CometResult({this.score}) : super(fullyQualifiedName);

  factory CometResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CometResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'CometResult($contents)';
  }
}

/// Input for MetricX metric.
final class MetricxInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetricxInput';

  /// Required. Spec for Metricx metric.
  final MetricxSpec? metricSpec;

  /// Required. Metricx instance.
  final MetricxInstance? instance;

  MetricxInput({required this.metricSpec, required this.instance})
    : super(fullyQualifiedName);

  factory MetricxInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetricxInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => MetricxSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => MetricxInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'MetricxInput()';
}

/// Spec for MetricX metric.
final class MetricxSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetricxSpec';

  /// Required. Which version to use for evaluation.
  final MetricxSpec_MetricxVersion? version;

  /// Optional. Source language in BCP-47 format.
  final String sourceLanguage;

  /// Optional. Target language in BCP-47 format. Covers both prediction and
  /// reference.
  final String targetLanguage;

  MetricxSpec({
    required this.version,
    this.sourceLanguage = '',
    this.targetLanguage = '',
  }) : super(fullyQualifiedName);

  factory MetricxSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetricxSpec(
      version: switch (json['version']) {
        null => null,
        Object $1 => MetricxSpec_MetricxVersion.fromJson($1),
      },
      sourceLanguage: switch (json['sourceLanguage']) {
        null => '',
        Object $1 => decodeString($1),
      },
      targetLanguage: switch (json['targetLanguage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (version != null) 'version': version!.toJson(),
    if (sourceLanguage.isNotDefault) 'sourceLanguage': sourceLanguage,
    if (targetLanguage.isNotDefault) 'targetLanguage': targetLanguage,
  };

  @override
  String toString() {
    final contents = [
      if (version != null) 'version=$version',
      'sourceLanguage=$sourceLanguage',
      'targetLanguage=$targetLanguage',
    ].join(',');
    return 'MetricxSpec($contents)';
  }
}

/// MetricX Version options.
final class MetricxSpec_MetricxVersion extends ProtoEnum {
  /// MetricX version unspecified.
  static const metricxVersionUnspecified = MetricxSpec_MetricxVersion(
    'METRICX_VERSION_UNSPECIFIED',
  );

  /// MetricX 2024 (2.6) for translation + reference (reference-based).
  static const metricx24Ref = MetricxSpec_MetricxVersion('METRICX_24_REF');

  /// MetricX 2024 (2.6) for translation + source (QE).
  static const metricx24Src = MetricxSpec_MetricxVersion('METRICX_24_SRC');

  /// MetricX 2024 (2.6) for translation + source + reference
  /// (source-reference-combined).
  static const metricx24SrcRef = MetricxSpec_MetricxVersion(
    'METRICX_24_SRC_REF',
  );

  /// The default value for [MetricxSpec_MetricxVersion].
  static const $default = metricxVersionUnspecified;

  const MetricxSpec_MetricxVersion(super.value);

  factory MetricxSpec_MetricxVersion.fromJson(Object? json) =>
      MetricxSpec_MetricxVersion(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'MetricxVersion.$value';
}

/// Spec for MetricX instance - The fields used for evaluation are dependent on
/// the MetricX version.
final class MetricxInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetricxInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Source text in original language.
  final String? source;

  MetricxInstance({required this.prediction, this.reference, this.source})
    : super(fullyQualifiedName);

  factory MetricxInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetricxInstance(
      prediction: switch (json['prediction']) {
        null => null,
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => decodeString($1),
      },
      source: switch (json['source']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (prediction != null) 'prediction': prediction,
    if (reference != null) 'reference': reference,
    if (source != null) 'source': source,
  };

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (source != null) 'source=$source',
    ].join(',');
    return 'MetricxInstance($contents)';
  }
}

/// Spec for MetricX result - calculates the MetricX score for the given instance
/// using the version specified in the spec.
final class MetricxResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetricxResult';

  /// Output only. MetricX score. Range depends on version.
  final double? score;

  MetricxResult({this.score}) : super(fullyQualifiedName);

  factory MetricxResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetricxResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'MetricxResult($contents)';
  }
}

/// Instance and metric spec for RubricBasedInstructionFollowing metric.
final class RubricBasedInstructionFollowingInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricBasedInstructionFollowingInput';

  /// Required. Spec for RubricBasedInstructionFollowing metric.
  final RubricBasedInstructionFollowingSpec? metricSpec;

  /// Required. Instance for RubricBasedInstructionFollowing metric.
  final RubricBasedInstructionFollowingInstance? instance;

  RubricBasedInstructionFollowingInput({
    required this.metricSpec,
    required this.instance,
  }) : super(fullyQualifiedName);

  factory RubricBasedInstructionFollowingInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RubricBasedInstructionFollowingInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => RubricBasedInstructionFollowingSpec.fromJson($1),
      },
      instance: switch (json['instance']) {
        null => null,
        Object $1 => RubricBasedInstructionFollowingInstance.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    if (instance != null) 'instance': instance!.toJson(),
  };

  @override
  String toString() => 'RubricBasedInstructionFollowingInput()';
}

/// Instance for RubricBasedInstructionFollowing metric - one instance
/// corresponds to one row in an evaluation dataset.
final class RubricBasedInstructionFollowingInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricBasedInstructionFollowingInstance';

  /// Required. Instance specified as a json string. String key-value pairs are
  /// expected in the json_instance to render RubricBasedInstructionFollowing
  /// prompt templates.
  final String? jsonInstance;

  RubricBasedInstructionFollowingInstance({required this.jsonInstance})
    : super(fullyQualifiedName);

  factory RubricBasedInstructionFollowingInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RubricBasedInstructionFollowingInstance(
      jsonInstance: switch (json['jsonInstance']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (jsonInstance != null) 'jsonInstance': jsonInstance};

  @override
  String toString() {
    final contents = [
      if (jsonInstance != null) 'jsonInstance=$jsonInstance',
    ].join(',');
    return 'RubricBasedInstructionFollowingInstance($contents)';
  }
}

/// Spec for RubricBasedInstructionFollowing metric - returns rubrics
/// and verdicts corresponding to rubrics along with overall score.
final class RubricBasedInstructionFollowingSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricBasedInstructionFollowingSpec';

  RubricBasedInstructionFollowingSpec() : super(fullyQualifiedName);

  factory RubricBasedInstructionFollowingSpec.fromJson(Object? j) =>
      RubricBasedInstructionFollowingSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'RubricBasedInstructionFollowingSpec()';
}

/// Result for RubricBasedInstructionFollowing metric.
final class RubricBasedInstructionFollowingResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricBasedInstructionFollowingResult';

  /// Output only. Overall score for the instruction following.
  final double? score;

  /// Output only. List of per rubric critique results.
  final List<RubricCritiqueResult> rubricCritiqueResults;

  RubricBasedInstructionFollowingResult({
    this.score,
    this.rubricCritiqueResults = const [],
  }) : super(fullyQualifiedName);

  factory RubricBasedInstructionFollowingResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RubricBasedInstructionFollowingResult(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      rubricCritiqueResults: switch (json['rubricCritiqueResults']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) RubricCritiqueResult.fromJson(i),
        ],
        _ => throw const FormatException(
          '"rubricCritiqueResults" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (score != null) 'score': encodeDouble(score),
    if (rubricCritiqueResults.isNotDefault)
      'rubricCritiqueResults': encodeList(rubricCritiqueResults),
  };

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'RubricBasedInstructionFollowingResult($contents)';
  }
}

/// Rubric critique result.
final class RubricCritiqueResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricCritiqueResult';

  /// Output only. Rubric to be evaluated.
  final String rubric;

  /// Output only. Verdict for the rubric - true if the rubric is met, false
  /// otherwise.
  final bool verdict;

  RubricCritiqueResult({this.rubric = '', this.verdict = false})
    : super(fullyQualifiedName);

  factory RubricCritiqueResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RubricCritiqueResult(
      rubric: switch (json['rubric']) {
        null => '',
        Object $1 => decodeString($1),
      },
      verdict: switch (json['verdict']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (rubric.isNotDefault) 'rubric': rubric,
    if (verdict.isNotDefault) 'verdict': verdict,
  };

  @override
  String toString() {
    final contents = ['rubric=$rubric', 'verdict=$verdict'].join(',');
    return 'RubricCritiqueResult($contents)';
  }
}

/// Instances and metric spec for TrajectoryExactMatch metric.
final class TrajectoryExactMatchInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchInput';

  /// Required. Spec for TrajectoryExactMatch metric.
  final TrajectoryExactMatchSpec? metricSpec;

  /// Required. Repeated TrajectoryExactMatch instance.
  final List<TrajectoryExactMatchInstance> instances;

  TrajectoryExactMatchInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory TrajectoryExactMatchInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryExactMatchInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => TrajectoryExactMatchSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TrajectoryExactMatchInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'TrajectoryExactMatchInput()';
}

/// Spec for TrajectoryExactMatch metric - returns 1 if tool calls in the
/// reference trajectory exactly match the predicted trajectory, else 0.
final class TrajectoryExactMatchSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchSpec';

  TrajectoryExactMatchSpec() : super(fullyQualifiedName);

  factory TrajectoryExactMatchSpec.fromJson(Object? j) =>
      TrajectoryExactMatchSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'TrajectoryExactMatchSpec()';
}

/// Spec for TrajectoryExactMatch instance.
final class TrajectoryExactMatchInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryExactMatchInstance({
    required this.predictedTrajectory,
    required this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryExactMatchInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryExactMatchInstance(
      predictedTrajectory: switch (json['predictedTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
      referenceTrajectory: switch (json['referenceTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!.toJson(),
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!.toJson(),
  };

  @override
  String toString() => 'TrajectoryExactMatchInstance()';
}

/// Results for TrajectoryExactMatch metric.
final class TrajectoryExactMatchResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchResults';

  /// Output only. TrajectoryExactMatch metric values.
  final List<TrajectoryExactMatchMetricValue> trajectoryExactMatchMetricValues;

  TrajectoryExactMatchResults({
    this.trajectoryExactMatchMetricValues = const [],
  }) : super(fullyQualifiedName);

  factory TrajectoryExactMatchResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryExactMatchResults(
      trajectoryExactMatchMetricValues:
          switch (json['trajectoryExactMatchMetricValues']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) TrajectoryExactMatchMetricValue.fromJson(i),
            ],
            _ => throw const FormatException(
              '"trajectoryExactMatchMetricValues" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (trajectoryExactMatchMetricValues.isNotDefault)
      'trajectoryExactMatchMetricValues': encodeList(
        trajectoryExactMatchMetricValues,
      ),
  };

  @override
  String toString() => 'TrajectoryExactMatchResults()';
}

/// TrajectoryExactMatch metric value for an instance.
final class TrajectoryExactMatchMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchMetricValue';

  /// Output only. TrajectoryExactMatch score.
  final double? score;

  TrajectoryExactMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryExactMatchMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryExactMatchMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryExactMatchMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectoryInOrderMatch metric.
final class TrajectoryInOrderMatchInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchInput';

  /// Required. Spec for TrajectoryInOrderMatch metric.
  final TrajectoryInOrderMatchSpec? metricSpec;

  /// Required. Repeated TrajectoryInOrderMatch instance.
  final List<TrajectoryInOrderMatchInstance> instances;

  TrajectoryInOrderMatchInput({
    required this.metricSpec,
    required this.instances,
  }) : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryInOrderMatchInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => TrajectoryInOrderMatchSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TrajectoryInOrderMatchInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'TrajectoryInOrderMatchInput()';
}

/// Spec for TrajectoryInOrderMatch metric - returns 1 if tool calls in the
/// reference trajectory appear in the predicted trajectory in the same order,
/// else 0.
final class TrajectoryInOrderMatchSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchSpec';

  TrajectoryInOrderMatchSpec() : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchSpec.fromJson(Object? j) =>
      TrajectoryInOrderMatchSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'TrajectoryInOrderMatchSpec()';
}

/// Spec for TrajectoryInOrderMatch instance.
final class TrajectoryInOrderMatchInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryInOrderMatchInstance({
    required this.predictedTrajectory,
    required this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryInOrderMatchInstance(
      predictedTrajectory: switch (json['predictedTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
      referenceTrajectory: switch (json['referenceTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!.toJson(),
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!.toJson(),
  };

  @override
  String toString() => 'TrajectoryInOrderMatchInstance()';
}

/// Results for TrajectoryInOrderMatch metric.
final class TrajectoryInOrderMatchResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchResults';

  /// Output only. TrajectoryInOrderMatch metric values.
  final List<TrajectoryInOrderMatchMetricValue>
  trajectoryInOrderMatchMetricValues;

  TrajectoryInOrderMatchResults({
    this.trajectoryInOrderMatchMetricValues = const [],
  }) : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryInOrderMatchResults(
      trajectoryInOrderMatchMetricValues:
          switch (json['trajectoryInOrderMatchMetricValues']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) TrajectoryInOrderMatchMetricValue.fromJson(i),
            ],
            _ => throw const FormatException(
              '"trajectoryInOrderMatchMetricValues" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (trajectoryInOrderMatchMetricValues.isNotDefault)
      'trajectoryInOrderMatchMetricValues': encodeList(
        trajectoryInOrderMatchMetricValues,
      ),
  };

  @override
  String toString() => 'TrajectoryInOrderMatchResults()';
}

/// TrajectoryInOrderMatch metric value for an instance.
final class TrajectoryInOrderMatchMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchMetricValue';

  /// Output only. TrajectoryInOrderMatch score.
  final double? score;

  TrajectoryInOrderMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryInOrderMatchMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryInOrderMatchMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectoryAnyOrderMatch metric.
final class TrajectoryAnyOrderMatchInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchInput';

  /// Required. Spec for TrajectoryAnyOrderMatch metric.
  final TrajectoryAnyOrderMatchSpec? metricSpec;

  /// Required. Repeated TrajectoryAnyOrderMatch instance.
  final List<TrajectoryAnyOrderMatchInstance> instances;

  TrajectoryAnyOrderMatchInput({
    required this.metricSpec,
    required this.instances,
  }) : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryAnyOrderMatchInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => TrajectoryAnyOrderMatchSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TrajectoryAnyOrderMatchInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'TrajectoryAnyOrderMatchInput()';
}

/// Spec for TrajectoryAnyOrderMatch metric - returns 1 if all tool calls in the
/// reference trajectory appear in the predicted trajectory in any order, else
/// 0.
final class TrajectoryAnyOrderMatchSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchSpec';

  TrajectoryAnyOrderMatchSpec() : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchSpec.fromJson(Object? j) =>
      TrajectoryAnyOrderMatchSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'TrajectoryAnyOrderMatchSpec()';
}

/// Spec for TrajectoryAnyOrderMatch instance.
final class TrajectoryAnyOrderMatchInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryAnyOrderMatchInstance({
    required this.predictedTrajectory,
    required this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryAnyOrderMatchInstance(
      predictedTrajectory: switch (json['predictedTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
      referenceTrajectory: switch (json['referenceTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!.toJson(),
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!.toJson(),
  };

  @override
  String toString() => 'TrajectoryAnyOrderMatchInstance()';
}

/// Results for TrajectoryAnyOrderMatch metric.
final class TrajectoryAnyOrderMatchResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchResults';

  /// Output only. TrajectoryAnyOrderMatch metric values.
  final List<TrajectoryAnyOrderMatchMetricValue>
  trajectoryAnyOrderMatchMetricValues;

  TrajectoryAnyOrderMatchResults({
    this.trajectoryAnyOrderMatchMetricValues = const [],
  }) : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryAnyOrderMatchResults(
      trajectoryAnyOrderMatchMetricValues:
          switch (json['trajectoryAnyOrderMatchMetricValues']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1)
                TrajectoryAnyOrderMatchMetricValue.fromJson(i),
            ],
            _ => throw const FormatException(
              '"trajectoryAnyOrderMatchMetricValues" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (trajectoryAnyOrderMatchMetricValues.isNotDefault)
      'trajectoryAnyOrderMatchMetricValues': encodeList(
        trajectoryAnyOrderMatchMetricValues,
      ),
  };

  @override
  String toString() => 'TrajectoryAnyOrderMatchResults()';
}

/// TrajectoryAnyOrderMatch metric value for an instance.
final class TrajectoryAnyOrderMatchMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchMetricValue';

  /// Output only. TrajectoryAnyOrderMatch score.
  final double? score;

  TrajectoryAnyOrderMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryAnyOrderMatchMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryAnyOrderMatchMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectoryPrecision metric.
final class TrajectoryPrecisionInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionInput';

  /// Required. Spec for TrajectoryPrecision metric.
  final TrajectoryPrecisionSpec? metricSpec;

  /// Required. Repeated TrajectoryPrecision instance.
  final List<TrajectoryPrecisionInstance> instances;

  TrajectoryPrecisionInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory TrajectoryPrecisionInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryPrecisionInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => TrajectoryPrecisionSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TrajectoryPrecisionInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'TrajectoryPrecisionInput()';
}

/// Spec for TrajectoryPrecision metric - returns a float score based on average
/// precision of individual tool calls.
final class TrajectoryPrecisionSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionSpec';

  TrajectoryPrecisionSpec() : super(fullyQualifiedName);

  factory TrajectoryPrecisionSpec.fromJson(Object? j) =>
      TrajectoryPrecisionSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'TrajectoryPrecisionSpec()';
}

/// Spec for TrajectoryPrecision instance.
final class TrajectoryPrecisionInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryPrecisionInstance({
    required this.predictedTrajectory,
    required this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryPrecisionInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryPrecisionInstance(
      predictedTrajectory: switch (json['predictedTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
      referenceTrajectory: switch (json['referenceTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!.toJson(),
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!.toJson(),
  };

  @override
  String toString() => 'TrajectoryPrecisionInstance()';
}

/// Results for TrajectoryPrecision metric.
final class TrajectoryPrecisionResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionResults';

  /// Output only. TrajectoryPrecision metric values.
  final List<TrajectoryPrecisionMetricValue> trajectoryPrecisionMetricValues;

  TrajectoryPrecisionResults({this.trajectoryPrecisionMetricValues = const []})
    : super(fullyQualifiedName);

  factory TrajectoryPrecisionResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryPrecisionResults(
      trajectoryPrecisionMetricValues:
          switch (json['trajectoryPrecisionMetricValues']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) TrajectoryPrecisionMetricValue.fromJson(i),
            ],
            _ => throw const FormatException(
              '"trajectoryPrecisionMetricValues" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (trajectoryPrecisionMetricValues.isNotDefault)
      'trajectoryPrecisionMetricValues': encodeList(
        trajectoryPrecisionMetricValues,
      ),
  };

  @override
  String toString() => 'TrajectoryPrecisionResults()';
}

/// TrajectoryPrecision metric value for an instance.
final class TrajectoryPrecisionMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionMetricValue';

  /// Output only. TrajectoryPrecision score.
  final double? score;

  TrajectoryPrecisionMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryPrecisionMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryPrecisionMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryPrecisionMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectoryRecall metric.
final class TrajectoryRecallInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallInput';

  /// Required. Spec for TrajectoryRecall metric.
  final TrajectoryRecallSpec? metricSpec;

  /// Required. Repeated TrajectoryRecall instance.
  final List<TrajectoryRecallInstance> instances;

  TrajectoryRecallInput({required this.metricSpec, required this.instances})
    : super(fullyQualifiedName);

  factory TrajectoryRecallInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryRecallInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => TrajectoryRecallSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TrajectoryRecallInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'TrajectoryRecallInput()';
}

/// Spec for TrajectoryRecall metric - returns a float score based on average
/// recall of individual tool calls.
final class TrajectoryRecallSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallSpec';

  TrajectoryRecallSpec() : super(fullyQualifiedName);

  factory TrajectoryRecallSpec.fromJson(Object? j) => TrajectoryRecallSpec();

  @override
  Object toJson() => {};

  @override
  String toString() => 'TrajectoryRecallSpec()';
}

/// Spec for TrajectoryRecall instance.
final class TrajectoryRecallInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryRecallInstance({
    required this.predictedTrajectory,
    required this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryRecallInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryRecallInstance(
      predictedTrajectory: switch (json['predictedTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
      referenceTrajectory: switch (json['referenceTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!.toJson(),
    if (referenceTrajectory != null)
      'referenceTrajectory': referenceTrajectory!.toJson(),
  };

  @override
  String toString() => 'TrajectoryRecallInstance()';
}

/// Results for TrajectoryRecall metric.
final class TrajectoryRecallResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallResults';

  /// Output only. TrajectoryRecall metric values.
  final List<TrajectoryRecallMetricValue> trajectoryRecallMetricValues;

  TrajectoryRecallResults({this.trajectoryRecallMetricValues = const []})
    : super(fullyQualifiedName);

  factory TrajectoryRecallResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryRecallResults(
      trajectoryRecallMetricValues:
          switch (json['trajectoryRecallMetricValues']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) TrajectoryRecallMetricValue.fromJson(i),
            ],
            _ => throw const FormatException(
              '"trajectoryRecallMetricValues" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (trajectoryRecallMetricValues.isNotDefault)
      'trajectoryRecallMetricValues': encodeList(trajectoryRecallMetricValues),
  };

  @override
  String toString() => 'TrajectoryRecallResults()';
}

/// TrajectoryRecall metric value for an instance.
final class TrajectoryRecallMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallMetricValue';

  /// Output only. TrajectoryRecall score.
  final double? score;

  TrajectoryRecallMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryRecallMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectoryRecallMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryRecallMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectorySingleToolUse metric.
final class TrajectorySingleToolUseInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseInput';

  /// Required. Spec for TrajectorySingleToolUse metric.
  final TrajectorySingleToolUseSpec? metricSpec;

  /// Required. Repeated TrajectorySingleToolUse instance.
  final List<TrajectorySingleToolUseInstance> instances;

  TrajectorySingleToolUseInput({
    required this.metricSpec,
    required this.instances,
  }) : super(fullyQualifiedName);

  factory TrajectorySingleToolUseInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectorySingleToolUseInput(
      metricSpec: switch (json['metricSpec']) {
        null => null,
        Object $1 => TrajectorySingleToolUseSpec.fromJson($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TrajectorySingleToolUseInstance.fromJson(i),
        ],
        _ => throw const FormatException('"instances" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
    'instances': encodeList(instances),
  };

  @override
  String toString() => 'TrajectorySingleToolUseInput()';
}

/// Spec for TrajectorySingleToolUse metric - returns 1 if tool is present in the
/// predicted trajectory, else 0.
final class TrajectorySingleToolUseSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseSpec';

  /// Required. Spec for tool name to be checked for in the predicted trajectory.
  final String? toolName;

  TrajectorySingleToolUseSpec({required this.toolName})
    : super(fullyQualifiedName);

  factory TrajectorySingleToolUseSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectorySingleToolUseSpec(
      toolName: switch (json['toolName']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (toolName != null) 'toolName': toolName};

  @override
  String toString() {
    final contents = [if (toolName != null) 'toolName=$toolName'].join(',');
    return 'TrajectorySingleToolUseSpec($contents)';
  }
}

/// Spec for TrajectorySingleToolUse instance.
final class TrajectorySingleToolUseInstance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  TrajectorySingleToolUseInstance({required this.predictedTrajectory})
    : super(fullyQualifiedName);

  factory TrajectorySingleToolUseInstance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectorySingleToolUseInstance(
      predictedTrajectory: switch (json['predictedTrajectory']) {
        null => null,
        Object $1 => Trajectory.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (predictedTrajectory != null)
      'predictedTrajectory': predictedTrajectory!.toJson(),
  };

  @override
  String toString() => 'TrajectorySingleToolUseInstance()';
}

/// Results for TrajectorySingleToolUse metric.
final class TrajectorySingleToolUseResults extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseResults';

  /// Output only. TrajectorySingleToolUse metric values.
  final List<TrajectorySingleToolUseMetricValue>
  trajectorySingleToolUseMetricValues;

  TrajectorySingleToolUseResults({
    this.trajectorySingleToolUseMetricValues = const [],
  }) : super(fullyQualifiedName);

  factory TrajectorySingleToolUseResults.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectorySingleToolUseResults(
      trajectorySingleToolUseMetricValues:
          switch (json['trajectorySingleToolUseMetricValues']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1)
                TrajectorySingleToolUseMetricValue.fromJson(i),
            ],
            _ => throw const FormatException(
              '"trajectorySingleToolUseMetricValues" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (trajectorySingleToolUseMetricValues.isNotDefault)
      'trajectorySingleToolUseMetricValues': encodeList(
        trajectorySingleToolUseMetricValues,
      ),
  };

  @override
  String toString() => 'TrajectorySingleToolUseResults()';
}

/// TrajectorySingleToolUse metric value for an instance.
final class TrajectorySingleToolUseMetricValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseMetricValue';

  /// Output only. TrajectorySingleToolUse score.
  final double? score;

  TrajectorySingleToolUseMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectorySingleToolUseMetricValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrajectorySingleToolUseMetricValue(
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (score != null) 'score': encodeDouble(score)};

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectorySingleToolUseMetricValue($contents)';
  }
}

/// Spec for trajectory.
final class Trajectory extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Trajectory';

  /// Required. Tool calls in the trajectory.
  final List<ToolCall> toolCalls;

  Trajectory({required this.toolCalls}) : super(fullyQualifiedName);

  factory Trajectory.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Trajectory(
      toolCalls: switch (json['toolCalls']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ToolCall.fromJson(i)],
        _ => throw const FormatException('"toolCalls" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'toolCalls': encodeList(toolCalls)};

  @override
  String toString() => 'Trajectory()';
}

/// Spec for tool call.
final class ToolCall extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCall';

  /// Required. Spec for tool name
  final String? toolName;

  /// Optional. Spec for tool input
  final String? toolInput;

  ToolCall({required this.toolName, this.toolInput})
    : super(fullyQualifiedName);

  factory ToolCall.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolCall(
      toolName: switch (json['toolName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      toolInput: switch (json['toolInput']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (toolName != null) 'toolName': toolName,
    if (toolInput != null) 'toolInput': toolInput,
  };

  @override
  String toString() {
    final contents = [
      if (toolName != null) 'toolName=$toolName',
      if (toolInput != null) 'toolInput=$toolInput',
    ].join(',');
    return 'ToolCall($contents)';
  }
}

/// Map of placeholder in metric prompt template to contents of model input.
final class ContentMap extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContentMap';

  /// Optional. Map of placeholder to contents.
  final Map<String, ContentMap_Contents> values;

  ContentMap({this.values = const {}}) : super(fullyQualifiedName);

  factory ContentMap.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ContentMap(
      values: switch (json['values']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ContentMap_Contents.fromJson(e.value),
        },
        _ => throw const FormatException('"values" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {if (values.isNotDefault) 'values': encodeMap(values)};

  @override
  String toString() => 'ContentMap()';
}

/// Repeated Content type.
final class ContentMap_Contents extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContentMap.Contents';

  /// Optional. Repeated contents.
  final List<Content> contents;

  ContentMap_Contents({this.contents = const []}) : super(fullyQualifiedName);

  factory ContentMap_Contents.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ContentMap_Contents(
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (contents.isNotDefault) 'contents': encodeList(contents),
  };

  @override
  String toString() => 'Contents()';
}

/// An edge describing the relationship between an Artifact and an Execution in
/// a lineage graph.
final class Event extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Event';

  /// Required. The relative resource name of the Artifact in the Event.
  final String artifact;

  /// Output only. The relative resource name of the Execution in the Event.
  final String execution;

  /// Output only. Time the Event occurred.
  final protobuf.Timestamp? eventTime;

  /// Required. The type of the Event.
  final Event_Type type;

  /// The labels with user-defined metadata to annotate Events.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Event (System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> labels;

  Event({
    required this.artifact,
    this.execution = '',
    this.eventTime,
    required this.type,
    this.labels = const {},
  }) : super(fullyQualifiedName);

  factory Event.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Event(
      artifact: switch (json['artifact']) {
        null => '',
        Object $1 => decodeString($1),
      },
      execution: switch (json['execution']) {
        null => '',
        Object $1 => decodeString($1),
      },
      eventTime: switch (json['eventTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      type: switch (json['type']) {
        null => Event_Type.$default,
        Object $1 => Event_Type.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    'artifact': artifact,
    if (execution.isNotDefault) 'execution': execution,
    if (eventTime != null) 'eventTime': eventTime!.toJson(),
    'type': type.toJson(),
    if (labels.isNotDefault) 'labels': labels,
  };

  @override
  String toString() {
    final contents = [
      'artifact=$artifact',
      'execution=$execution',
      'type=$type',
    ].join(',');
    return 'Event($contents)';
  }
}

/// Describes whether an Event's Artifact is the Execution's input or output.
final class Event_Type extends ProtoEnum {
  /// Unspecified whether input or output of the Execution.
  static const typeUnspecified = Event_Type('TYPE_UNSPECIFIED');

  /// An input of the Execution.
  static const input = Event_Type('INPUT');

  /// An output of the Execution.
  static const output = Event_Type('OUTPUT');

  /// The default value for [Event_Type].
  static const $default = typeUnspecified;

  const Event_Type(super.value);

  factory Event_Type.fromJson(Object? json) => Event_Type(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// A single example of a conversation with the model.
final class ContentsExample extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContentsExample';

  /// Required. The content of the conversation with the model that resulted in
  /// the expected output.
  final List<Content> contents;

  /// Required. The expected output for the given `contents`. To represent
  /// multi-step reasoning, this is a repeated field that contains the iterative
  /// steps of the expected output.
  final List<ContentsExample_ExpectedContent> expectedContents;

  ContentsExample({required this.contents, required this.expectedContents})
    : super(fullyQualifiedName);

  factory ContentsExample.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ContentsExample(
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
      expectedContents: switch (json['expectedContents']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ContentsExample_ExpectedContent.fromJson(i),
        ],
        _ => throw const FormatException('"expectedContents" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'contents': encodeList(contents),
    'expectedContents': encodeList(expectedContents),
  };

  @override
  String toString() => 'ContentsExample()';
}

/// A single step of the expected output.
final class ContentsExample_ExpectedContent extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContentsExample.ExpectedContent';

  /// Required. A single step's content.
  final Content? content;

  ContentsExample_ExpectedContent({required this.content})
    : super(fullyQualifiedName);

  factory ContentsExample_ExpectedContent.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ContentsExample_ExpectedContent(
      content: switch (json['content']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (content != null) 'content': content!.toJson()};

  @override
  String toString() => 'ExpectedContent()';
}

/// A ContentsExample to be used with GenerateContent alongside information
/// required for storage and retrieval with Example Store.
final class StoredContentsExample extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExample';

  /// Optional. (Optional) the search key used for retrieval. If not provided at
  /// upload-time, the search key will be generated from
  /// `contents_example.contents` using the method provided by
  /// `search_key_generation_method`. The generated search key will be included
  /// in retrieved examples.
  final String searchKey;

  /// Required. The example to be used with GenerateContent.
  final ContentsExample? contentsExample;

  /// Optional. The method used to generate the search key from
  /// `contents_example.contents`. This is ignored when uploading an example if
  /// `search_key` is provided.
  final StoredContentsExample_SearchKeyGenerationMethod?
  searchKeyGenerationMethod;

  StoredContentsExample({
    this.searchKey = '',
    required this.contentsExample,
    this.searchKeyGenerationMethod,
  }) : super(fullyQualifiedName);

  factory StoredContentsExample.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StoredContentsExample(
      searchKey: switch (json['searchKey']) {
        null => '',
        Object $1 => decodeString($1),
      },
      contentsExample: switch (json['contentsExample']) {
        null => null,
        Object $1 => ContentsExample.fromJson($1),
      },
      searchKeyGenerationMethod: switch (json['searchKeyGenerationMethod']) {
        null => null,
        Object $1 => StoredContentsExample_SearchKeyGenerationMethod.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (searchKey.isNotDefault) 'searchKey': searchKey,
    if (contentsExample != null) 'contentsExample': contentsExample!.toJson(),
    if (searchKeyGenerationMethod != null)
      'searchKeyGenerationMethod': searchKeyGenerationMethod!.toJson(),
  };

  @override
  String toString() {
    final contents = ['searchKey=$searchKey'].join(',');
    return 'StoredContentsExample($contents)';
  }
}

/// Options for generating the search key from the conversation history.
final class StoredContentsExample_SearchKeyGenerationMethod
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExample.SearchKeyGenerationMethod';

  /// Use only the last entry of the conversation history
  /// (`contents_example.contents`) as the search key.
  final StoredContentsExample_SearchKeyGenerationMethod_LastEntry? lastEntry;

  StoredContentsExample_SearchKeyGenerationMethod({this.lastEntry})
    : super(fullyQualifiedName);

  factory StoredContentsExample_SearchKeyGenerationMethod.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StoredContentsExample_SearchKeyGenerationMethod(
      lastEntry: switch (json['lastEntry']) {
        null => null,
        Object $1 =>
          StoredContentsExample_SearchKeyGenerationMethod_LastEntry.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {if (lastEntry != null) 'lastEntry': lastEntry!.toJson()};

  @override
  String toString() => 'SearchKeyGenerationMethod()';
}

/// Configuration for using only the last entry of the conversation history
/// as the search key.
final class StoredContentsExample_SearchKeyGenerationMethod_LastEntry
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExample.SearchKeyGenerationMethod.LastEntry';

  StoredContentsExample_SearchKeyGenerationMethod_LastEntry()
    : super(fullyQualifiedName);

  factory StoredContentsExample_SearchKeyGenerationMethod_LastEntry.fromJson(
    Object? j,
  ) => StoredContentsExample_SearchKeyGenerationMethod_LastEntry();

  @override
  Object toJson() => {};

  @override
  String toString() => 'LastEntry()';
}

/// Represents an executable service to manage and retrieve examples.
final class ExampleStore extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExampleStore';

  /// Identifier. The resource name of the ExampleStore. This is a unique
  /// identifier. Format:
  /// projects/{project}/locations/{location}/exampleStores/{example_store}
  final String name;

  /// Required. Display name of the ExampleStore.
  final String displayName;

  /// Optional. Description of the ExampleStore.
  final String description;

  /// Output only. Timestamp when this ExampleStore was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ExampleStore was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Required. Example Store config.
  final ExampleStoreConfig? exampleStoreConfig;

  ExampleStore({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.createTime,
    this.updateTime,
    required this.exampleStoreConfig,
  }) : super(fullyQualifiedName);

  factory ExampleStore.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExampleStore(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      exampleStoreConfig: switch (json['exampleStoreConfig']) {
        null => null,
        Object $1 => ExampleStoreConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (exampleStoreConfig != null)
      'exampleStoreConfig': exampleStoreConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
    ].join(',');
    return 'ExampleStore($contents)';
  }
}

/// Configuration for the Example Store.
final class ExampleStoreConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExampleStoreConfig';

  /// Required. The embedding model to be used for vector embedding.
  /// Immutable.
  /// Supported models:
  /// * "textembedding-gecko@003"
  /// * "text-embedding-004"
  /// * "text-embedding-005"
  /// * "text-multilingual-embedding-002"
  final String vertexEmbeddingModel;

  ExampleStoreConfig({required this.vertexEmbeddingModel})
    : super(fullyQualifiedName);

  factory ExampleStoreConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExampleStoreConfig(
      vertexEmbeddingModel: switch (json['vertexEmbeddingModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'vertexEmbeddingModel': vertexEmbeddingModel};

  @override
  String toString() {
    final contents = ['vertexEmbeddingModel=$vertexEmbeddingModel'].join(',');
    return 'ExampleStoreConfig($contents)';
  }
}

/// The metadata filters that will be used to remove or fetch
/// StoredContentsExamples. If a field is unspecified, then no filtering for that
/// field will be applied.
final class StoredContentsExampleFilter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExampleFilter';

  /// Optional. The search keys for filtering. Only examples with one of the
  /// specified search keys
  /// (`StoredContentsExample.search_key`)
  /// are eligible to be returned.
  final List<String> searchKeys;

  /// Optional. The function names for filtering.
  final ExamplesArrayFilter? functionNames;

  StoredContentsExampleFilter({this.searchKeys = const [], this.functionNames})
    : super(fullyQualifiedName);

  factory StoredContentsExampleFilter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StoredContentsExampleFilter(
      searchKeys: switch (json['searchKeys']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"searchKeys" is not a list'),
      },
      functionNames: switch (json['functionNames']) {
        null => null,
        Object $1 => ExamplesArrayFilter.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (searchKeys.isNotDefault) 'searchKeys': searchKeys,
    if (functionNames != null) 'functionNames': functionNames!.toJson(),
  };

  @override
  String toString() => 'StoredContentsExampleFilter()';
}

/// The metadata filters that will be used to search StoredContentsExamples.
/// If a field is unspecified, then no filtering for that field will be applied
final class StoredContentsExampleParameters extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExampleParameters';

  /// The exact search key to use for retrieval.
  final String? searchKey;

  /// The chat history to use to generate the search key for retrieval.
  final StoredContentsExampleParameters_ContentSearchKey? contentSearchKey;

  /// Optional. The function names for filtering.
  final ExamplesArrayFilter? functionNames;

  StoredContentsExampleParameters({
    this.searchKey,
    this.contentSearchKey,
    this.functionNames,
  }) : super(fullyQualifiedName);

  factory StoredContentsExampleParameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StoredContentsExampleParameters(
      searchKey: switch (json['searchKey']) {
        null => null,
        Object $1 => decodeString($1),
      },
      contentSearchKey: switch (json['contentSearchKey']) {
        null => null,
        Object $1 => StoredContentsExampleParameters_ContentSearchKey.fromJson(
          $1,
        ),
      },
      functionNames: switch (json['functionNames']) {
        null => null,
        Object $1 => ExamplesArrayFilter.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (searchKey != null) 'searchKey': searchKey,
    if (contentSearchKey != null)
      'contentSearchKey': contentSearchKey!.toJson(),
    if (functionNames != null) 'functionNames': functionNames!.toJson(),
  };

  @override
  String toString() {
    final contents = [if (searchKey != null) 'searchKey=$searchKey'].join(',');
    return 'StoredContentsExampleParameters($contents)';
  }
}

/// The chat history to use to generate the search key for retrieval.
final class StoredContentsExampleParameters_ContentSearchKey
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExampleParameters.ContentSearchKey';

  /// Required. The conversation for generating a search key.
  final List<Content> contents;

  /// Required. The method of generating a search key.
  final StoredContentsExample_SearchKeyGenerationMethod?
  searchKeyGenerationMethod;

  StoredContentsExampleParameters_ContentSearchKey({
    required this.contents,
    required this.searchKeyGenerationMethod,
  }) : super(fullyQualifiedName);

  factory StoredContentsExampleParameters_ContentSearchKey.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StoredContentsExampleParameters_ContentSearchKey(
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
      searchKeyGenerationMethod: switch (json['searchKeyGenerationMethod']) {
        null => null,
        Object $1 => StoredContentsExample_SearchKeyGenerationMethod.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    'contents': encodeList(contents),
    if (searchKeyGenerationMethod != null)
      'searchKeyGenerationMethod': searchKeyGenerationMethod!.toJson(),
  };

  @override
  String toString() => 'ContentSearchKey()';
}

/// Filters for examples' array metadata fields. An array field is example
/// metadata where multiple values are attributed to a single example.
final class ExamplesArrayFilter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExamplesArrayFilter';

  /// Required. The values by which to filter examples.
  final List<String> values;

  /// Required. The operator logic to use for filtering.
  final ExamplesArrayFilter_ArrayOperator arrayOperator;

  ExamplesArrayFilter({required this.values, required this.arrayOperator})
    : super(fullyQualifiedName);

  factory ExamplesArrayFilter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExamplesArrayFilter(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
      arrayOperator: switch (json['arrayOperator']) {
        null => ExamplesArrayFilter_ArrayOperator.$default,
        Object $1 => ExamplesArrayFilter_ArrayOperator.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'values': values,
    'arrayOperator': arrayOperator.toJson(),
  };

  @override
  String toString() {
    final contents = ['arrayOperator=$arrayOperator'].join(',');
    return 'ExamplesArrayFilter($contents)';
  }
}

/// The logic to use for filtering.
final class ExamplesArrayFilter_ArrayOperator extends ProtoEnum {
  /// Not specified. This value should not be used.
  static const arrayOperatorUnspecified = ExamplesArrayFilter_ArrayOperator(
    'ARRAY_OPERATOR_UNSPECIFIED',
  );

  /// The metadata array field in the example must contain at least one of the
  /// values.
  static const containsAny = ExamplesArrayFilter_ArrayOperator('CONTAINS_ANY');

  /// The metadata array field in the example must contain all of the values.
  static const containsAll = ExamplesArrayFilter_ArrayOperator('CONTAINS_ALL');

  /// The default value for [ExamplesArrayFilter_ArrayOperator].
  static const $default = arrayOperatorUnspecified;

  const ExamplesArrayFilter_ArrayOperator(super.value);

  factory ExamplesArrayFilter_ArrayOperator.fromJson(Object? json) =>
      ExamplesArrayFilter_ArrayOperator(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ArrayOperator.$value';
}

/// Request message for
/// `ExampleStoreService.CreateExampleStore`.
final class CreateExampleStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateExampleStoreRequest';

  /// Required. The resource name of the Location to create the ExampleStore in.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Example Store to be created.
  final ExampleStore? exampleStore;

  CreateExampleStoreRequest({required this.parent, required this.exampleStore})
    : super(fullyQualifiedName);

  factory CreateExampleStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateExampleStoreRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      exampleStore: switch (json['exampleStore']) {
        null => null,
        Object $1 => ExampleStore.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (exampleStore != null) 'exampleStore': exampleStore!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateExampleStoreRequest($contents)';
  }
}

/// Details of
/// `ExampleStoreService.CreateExampleStore`
/// operation.
final class CreateExampleStoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateExampleStoreOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateExampleStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateExampleStoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateExampleStoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateExampleStoreOperationMetadata()';
}

/// Request message for
/// `ExampleStoreService.GetExampleStore`.
final class GetExampleStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetExampleStoreRequest';

  /// Required. The resource name of the ExampleStore.
  /// Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String name;

  GetExampleStoreRequest({required this.name}) : super(fullyQualifiedName);

  factory GetExampleStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetExampleStoreRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetExampleStoreRequest($contents)';
  }
}

/// Request message for
/// `ExampleStoreService.UpdateExampleStore`.
final class UpdateExampleStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExampleStoreRequest';

  /// Required. The Example Store which replaces the resource on the server.
  final ExampleStore? exampleStore;

  /// Optional. Mask specifying which fields to update.
  /// Supported fields:
  ///
  ///    * `display_name`
  ///    * `description`
  final protobuf.FieldMask? updateMask;

  UpdateExampleStoreRequest({required this.exampleStore, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateExampleStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateExampleStoreRequest(
      exampleStore: switch (json['exampleStore']) {
        null => null,
        Object $1 => ExampleStore.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (exampleStore != null) 'exampleStore': exampleStore!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateExampleStoreRequest()';
}

/// Details of
/// `ExampleStoreService.UpdateExampleStore`
/// operation.
final class UpdateExampleStoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExampleStoreOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UpdateExampleStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateExampleStoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateExampleStoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateExampleStoreOperationMetadata()';
}

/// Request message for
/// `ExampleStoreService.DeleteExampleStore`.
final class DeleteExampleStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteExampleStoreRequest';

  /// Required. The resource name of the ExampleStore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String name;

  DeleteExampleStoreRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteExampleStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteExampleStoreRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteExampleStoreRequest($contents)';
  }
}

/// Details of
/// `ExampleStoreService.DeleteExampleStore`
/// operation.
final class DeleteExampleStoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteExampleStoreOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  DeleteExampleStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory DeleteExampleStoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteExampleStoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'DeleteExampleStoreOperationMetadata()';
}

/// Request message for
/// `ExampleStoreService.ListExampleStores`.
final class ListExampleStoresRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExampleStoresRequest';

  /// Required. The resource name of the Location to list the ExampleStores from.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  final String pageToken;

  ListExampleStoresRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListExampleStoresRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListExampleStoresRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListExampleStoresRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.ListExampleStores`.
final class ListExampleStoresResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExampleStoresResponse';

  /// List of ExampleStore in the requested page.
  final List<ExampleStore> exampleStores;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListExampleStoresRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListExampleStoresResponse({
    this.exampleStores = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListExampleStoresResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListExampleStoresResponse(
      exampleStores: switch (json['exampleStores']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ExampleStore.fromJson(i)],
        _ => throw const FormatException('"exampleStores" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (exampleStores.isNotDefault) 'exampleStores': encodeList(exampleStores),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListExampleStoresResponse($contents)';
  }
}

/// A single example to upload or read from the Example Store.
final class Example extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Example';

  /// An example of chat history and its expected outcome to be used with
  /// GenerateContent.
  final StoredContentsExample? storedContentsExample;

  /// Optional. The display name for Example.
  final String displayName;

  /// Optional. Immutable. Unique identifier of an example. If not specified when
  /// upserting new examples, the example_id will be generated.
  final String exampleId;

  /// Output only. Timestamp when this Example was created.
  final protobuf.Timestamp? createTime;

  Example({
    this.storedContentsExample,
    this.displayName = '',
    this.exampleId = '',
    this.createTime,
  }) : super(fullyQualifiedName);

  factory Example.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Example(
      storedContentsExample: switch (json['storedContentsExample']) {
        null => null,
        Object $1 => StoredContentsExample.fromJson($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      exampleId: switch (json['exampleId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (storedContentsExample != null)
      'storedContentsExample': storedContentsExample!.toJson(),
    if (displayName.isNotDefault) 'displayName': displayName,
    if (exampleId.isNotDefault) 'exampleId': exampleId,
    if (createTime != null) 'createTime': createTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'displayName=$displayName',
      'exampleId=$exampleId',
    ].join(',');
    return 'Example($contents)';
  }
}

/// Request message for
/// `ExampleStoreService.UpsertExamples`.
final class UpsertExamplesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertExamplesRequest';

  /// Required. The name of the ExampleStore resource that examples are added to
  /// or updated in. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String exampleStore;

  /// Required. A list of examples to be created/updated.
  final List<Example> examples;

  /// Optional. A flag indicating whether an example can be overwritten if it
  /// already exists. If False (default) and the example already exists, the
  /// example will not be updated. This does not affect behavior if the example
  /// does not exist already.
  final bool overwrite;

  UpsertExamplesRequest({
    required this.exampleStore,
    required this.examples,
    this.overwrite = false,
  }) : super(fullyQualifiedName);

  factory UpsertExamplesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpsertExamplesRequest(
      exampleStore: switch (json['exampleStore']) {
        null => '',
        Object $1 => decodeString($1),
      },
      examples: switch (json['examples']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Example.fromJson(i)],
        _ => throw const FormatException('"examples" is not a list'),
      },
      overwrite: switch (json['overwrite']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'exampleStore': exampleStore,
    'examples': encodeList(examples),
    if (overwrite.isNotDefault) 'overwrite': overwrite,
  };

  @override
  String toString() {
    final contents = [
      'exampleStore=$exampleStore',
      'overwrite=$overwrite',
    ].join(',');
    return 'UpsertExamplesRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.UpsertExamples`.
final class UpsertExamplesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertExamplesResponse';

  /// A list of results for creating/updating. It's either a successfully
  /// created/updated example or a status with an error message.
  final List<UpsertExamplesResponse_UpsertResult> results;

  UpsertExamplesResponse({this.results = const []}) : super(fullyQualifiedName);

  factory UpsertExamplesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpsertExamplesResponse(
      results: switch (json['results']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) UpsertExamplesResponse_UpsertResult.fromJson(i),
        ],
        _ => throw const FormatException('"results" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (results.isNotDefault) 'results': encodeList(results)};

  @override
  String toString() => 'UpsertExamplesResponse()';
}

/// The result for creating/updating a single example.
final class UpsertExamplesResponse_UpsertResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertExamplesResponse.UpsertResult';

  /// The example created/updated successfully.
  final Example? example;

  /// The error message of the example that was not created/updated
  /// successfully.
  final Status? status;

  UpsertExamplesResponse_UpsertResult({this.example, this.status})
    : super(fullyQualifiedName);

  factory UpsertExamplesResponse_UpsertResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpsertExamplesResponse_UpsertResult(
      example: switch (json['example']) {
        null => null,
        Object $1 => Example.fromJson($1),
      },
      status: switch (json['status']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (example != null) 'example': example!.toJson(),
    if (status != null) 'status': status!.toJson(),
  };

  @override
  String toString() => 'UpsertResult()';
}

/// Request message for
/// `ExampleStoreService.RemoveExamples`.
final class RemoveExamplesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveExamplesRequest';

  /// The metadata filters for StoredContentsExamples.
  final StoredContentsExampleFilter? storedContentsExampleFilter;

  /// Required. The name of the ExampleStore resource that the examples should be
  /// removed from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String exampleStore;

  /// Optional. Example IDs to remove. If both metadata filters and Example IDs
  /// are specified, the metadata filters will be applied to the specified
  /// examples in order to identify which should be removed.
  final List<String> exampleIds;

  RemoveExamplesRequest({
    this.storedContentsExampleFilter,
    required this.exampleStore,
    this.exampleIds = const [],
  }) : super(fullyQualifiedName);

  factory RemoveExamplesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RemoveExamplesRequest(
      storedContentsExampleFilter:
          switch (json['storedContentsExampleFilter']) {
            null => null,
            Object $1 => StoredContentsExampleFilter.fromJson($1),
          },
      exampleStore: switch (json['exampleStore']) {
        null => '',
        Object $1 => decodeString($1),
      },
      exampleIds: switch (json['exampleIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"exampleIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (storedContentsExampleFilter != null)
      'storedContentsExampleFilter': storedContentsExampleFilter!.toJson(),
    'exampleStore': exampleStore,
    if (exampleIds.isNotDefault) 'exampleIds': exampleIds,
  };

  @override
  String toString() {
    final contents = ['exampleStore=$exampleStore'].join(',');
    return 'RemoveExamplesRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.RemoveExamples`.
final class RemoveExamplesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveExamplesResponse';

  /// The IDs for the removed examples.
  final List<String> exampleIds;

  RemoveExamplesResponse({this.exampleIds = const []})
    : super(fullyQualifiedName);

  factory RemoveExamplesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RemoveExamplesResponse(
      exampleIds: switch (json['exampleIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"exampleIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (exampleIds.isNotDefault) 'exampleIds': exampleIds};

  @override
  String toString() => 'RemoveExamplesResponse()';
}

/// Request message for
/// `ExampleStoreService.SearchExamples`.
final class SearchExamplesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchExamplesRequest';

  /// The parameters of StoredContentsExamples to be searched.
  final StoredContentsExampleParameters? storedContentsExampleParameters;

  /// Required. The name of the ExampleStore resource that examples are retrieved
  /// from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String exampleStore;

  /// Optional. The number of similar examples to return.
  final int topK;

  SearchExamplesRequest({
    this.storedContentsExampleParameters,
    required this.exampleStore,
    this.topK = 0,
  }) : super(fullyQualifiedName);

  factory SearchExamplesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchExamplesRequest(
      storedContentsExampleParameters:
          switch (json['storedContentsExampleParameters']) {
            null => null,
            Object $1 => StoredContentsExampleParameters.fromJson($1),
          },
      exampleStore: switch (json['exampleStore']) {
        null => '',
        Object $1 => decodeString($1),
      },
      topK: switch (json['topK']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (storedContentsExampleParameters != null)
      'storedContentsExampleParameters': storedContentsExampleParameters!
          .toJson(),
    'exampleStore': exampleStore,
    if (topK.isNotDefault) 'topK': encodeInt64(topK),
  };

  @override
  String toString() {
    final contents = ['exampleStore=$exampleStore', 'topK=$topK'].join(',');
    return 'SearchExamplesRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.SearchExamples`.
final class SearchExamplesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchExamplesResponse';

  /// The results of searching for similar examples.
  final List<SearchExamplesResponse_SimilarExample> results;

  SearchExamplesResponse({this.results = const []}) : super(fullyQualifiedName);

  factory SearchExamplesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchExamplesResponse(
      results: switch (json['results']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) SearchExamplesResponse_SimilarExample.fromJson(i),
        ],
        _ => throw const FormatException('"results" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (results.isNotDefault) 'results': encodeList(results)};

  @override
  String toString() => 'SearchExamplesResponse()';
}

/// The result of the similar example.
final class SearchExamplesResponse_SimilarExample extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchExamplesResponse.SimilarExample';

  /// The example that is similar to the searched query.
  final Example? example;

  /// The similarity score of this example.
  final double similarityScore;

  SearchExamplesResponse_SimilarExample({
    this.example,
    this.similarityScore = 0,
  }) : super(fullyQualifiedName);

  factory SearchExamplesResponse_SimilarExample.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchExamplesResponse_SimilarExample(
      example: switch (json['example']) {
        null => null,
        Object $1 => Example.fromJson($1),
      },
      similarityScore: switch (json['similarityScore']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (example != null) 'example': example!.toJson(),
    if (similarityScore.isNotDefault)
      'similarityScore': encodeDouble(similarityScore),
  };

  @override
  String toString() {
    final contents = ['similarityScore=$similarityScore'].join(',');
    return 'SimilarExample($contents)';
  }
}

/// Request message for
/// `ExampleStoreService.FetchExamples`.
final class FetchExamplesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchExamplesRequest';

  /// The metadata filters for StoredContentsExamples.
  final StoredContentsExampleFilter? storedContentsExampleFilter;

  /// Required. The name of the ExampleStore resource that the examples should be
  /// fetched from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String exampleStore;

  /// Optional. The maximum number of examples to return. The service may return
  /// fewer than this value. If unspecified, at most 100 examples will be
  /// returned.
  final int pageSize;

  /// Optional. The
  /// `next_page_token`
  /// value returned from a previous list
  /// `ExampleStoreService.FetchExamplesResponse` call.
  final String pageToken;

  /// Optional. Example IDs to fetch. If both metadata filters and Example IDs
  /// are specified, then both ID and metadata filtering will be applied.
  final List<String> exampleIds;

  FetchExamplesRequest({
    this.storedContentsExampleFilter,
    required this.exampleStore,
    this.pageSize = 0,
    this.pageToken = '',
    this.exampleIds = const [],
  }) : super(fullyQualifiedName);

  factory FetchExamplesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FetchExamplesRequest(
      storedContentsExampleFilter:
          switch (json['storedContentsExampleFilter']) {
            null => null,
            Object $1 => StoredContentsExampleFilter.fromJson($1),
          },
      exampleStore: switch (json['exampleStore']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      exampleIds: switch (json['exampleIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"exampleIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (storedContentsExampleFilter != null)
      'storedContentsExampleFilter': storedContentsExampleFilter!.toJson(),
    'exampleStore': exampleStore,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (exampleIds.isNotDefault) 'exampleIds': exampleIds,
  };

  @override
  String toString() {
    final contents = [
      'exampleStore=$exampleStore',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'FetchExamplesRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.FetchExamples`.
final class FetchExamplesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchExamplesResponse';

  /// The examples in the Example Store that satisfy the metadata filters.
  final List<Example> examples;

  /// A token, which can be sent as `FetchExamplesRequest.page_token` to
  /// retrieve the next page. Absence of this field indicates there are no
  /// subsequent pages.
  final String nextPageToken;

  FetchExamplesResponse({this.examples = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory FetchExamplesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FetchExamplesResponse(
      examples: switch (json['examples']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Example.fromJson(i)],
        _ => throw const FormatException('"examples" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (examples.isNotDefault) 'examples': encodeList(examples),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'FetchExamplesResponse($contents)';
  }
}

/// Instance of a general execution.
final class Execution extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Execution';

  /// Output only. The resource name of the Execution.
  final String name;

  /// User provided display name of the Execution.
  /// May be up to 128 Unicode characters.
  final String displayName;

  /// The state of this Execution. This is a property of the Execution, and does
  /// not imply or capture any ongoing process. This property is managed by
  /// clients (such as Vertex AI Pipelines) and the system does not prescribe
  /// or check the validity of state transitions.
  final Execution_State state;

  /// An eTag used to perform consistent read-modify-write updates. If not set, a
  /// blind "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize your Executions.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Execution (System
  /// labels are excluded).
  final Map<String, String> labels;

  /// Output only. Timestamp when this Execution was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Execution was last updated.
  final protobuf.Timestamp? updateTime;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String schemaTitle;

  /// The version of the schema in `schema_title` to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String schemaVersion;

  /// Properties of the Execution.
  /// Top level metadata keys' heading and trailing spaces will be trimmed.
  /// The size of this field should not exceed 200KB.
  final protobuf.Struct? metadata;

  /// Description of the Execution
  final String description;

  Execution({
    this.name = '',
    this.displayName = '',
    this.state = Execution_State.$default,
    this.etag = '',
    this.labels = const {},
    this.createTime,
    this.updateTime,
    this.schemaTitle = '',
    this.schemaVersion = '',
    this.metadata,
    this.description = '',
  }) : super(fullyQualifiedName);

  factory Execution.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Execution(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => Execution_State.$default,
        Object $1 => Execution_State.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      schemaTitle: switch (json['schemaTitle']) {
        null => '',
        Object $1 => decodeString($1),
      },
      schemaVersion: switch (json['schemaVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (state.isNotDefault) 'state': state.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (schemaTitle.isNotDefault) 'schemaTitle': schemaTitle,
    if (schemaVersion.isNotDefault) 'schemaVersion': schemaVersion,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'state=$state',
      'etag=$etag',
      'schemaTitle=$schemaTitle',
      'schemaVersion=$schemaVersion',
      'description=$description',
    ].join(',');
    return 'Execution($contents)';
  }
}

/// Describes the state of the Execution.
final class Execution_State extends ProtoEnum {
  /// Unspecified Execution state
  static const stateUnspecified = Execution_State('STATE_UNSPECIFIED');

  /// The Execution is new
  static const new$ = Execution_State('NEW');

  /// The Execution is running
  static const running = Execution_State('RUNNING');

  /// The Execution has finished running
  static const complete = Execution_State('COMPLETE');

  /// The Execution has failed
  static const failed = Execution_State('FAILED');

  /// The Execution completed through Cache hit.
  static const cached = Execution_State('CACHED');

  /// The Execution was cancelled.
  static const cancelled = Execution_State('CANCELLED');

  /// The default value for [Execution_State].
  static const $default = stateUnspecified;

  const Execution_State(super.value);

  factory Execution_State.fromJson(Object? json) =>
      Execution_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Explanation of a prediction (provided in
/// `PredictResponse.predictions`)
/// produced by the Model on a given
/// `instance`.
final class Explanation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Explanation';

  /// Output only. Feature attributions grouped by predicted outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item.
  /// `Attribution.output_index`
  /// can be used to identify which output this attribution is explaining.
  ///
  /// By default, we provide Shapley values for the predicted class. However,
  /// you can configure the explanation request to generate Shapley values for
  /// any other classes too. For example, if a model predicts a probability of
  /// `0.4` for approving a loan application, the model's decision is to reject
  /// the application since `p(reject) = 0.6 > p(approve) = 0.4`, and the default
  /// Shapley values would be computed for rejection decision and not approval,
  /// even though the latter might be the positive class.
  ///
  /// If users set
  /// `ExplanationParameters.top_k`,
  /// the attributions are sorted by
  /// `instance_output_value` in descending
  /// order. If
  /// `ExplanationParameters.output_indices`
  /// is specified, the attributions are stored by
  /// `Attribution.output_index`
  /// in the same order as they appear in the output_indices.
  final List<Attribution> attributions;

  /// Output only. List of the nearest neighbors for example-based explanations.
  ///
  /// For models deployed with the examples explanations feature enabled, the
  /// attributions field is empty and instead the neighbors field is populated.
  final List<Neighbor> neighbors;

  Explanation({this.attributions = const [], this.neighbors = const []})
    : super(fullyQualifiedName);

  factory Explanation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Explanation(
      attributions: switch (json['attributions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Attribution.fromJson(i)],
        _ => throw const FormatException('"attributions" is not a list'),
      },
      neighbors: switch (json['neighbors']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Neighbor.fromJson(i)],
        _ => throw const FormatException('"neighbors" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (attributions.isNotDefault) 'attributions': encodeList(attributions),
    if (neighbors.isNotDefault) 'neighbors': encodeList(neighbors),
  };

  @override
  String toString() => 'Explanation()';
}

/// Aggregated explanation metrics for a Model over a set of instances.
final class ModelExplanation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelExplanation';

  /// Output only. Aggregated attributions explaining the Model's prediction
  /// outputs over the set of instances. The attributions are grouped by outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item.
  /// `Attribution.output_index`
  /// can be used to identify which output this attribution is explaining.
  ///
  /// The
  /// `baselineOutputValue`,
  /// `instanceOutputValue`
  /// and
  /// `featureAttributions`
  /// fields are averaged over the test data.
  ///
  /// NOTE: Currently AutoML tabular classification Models produce only one
  /// attribution, which averages attributions over all the classes it predicts.
  /// `Attribution.approximation_error`
  /// is not populated.
  final List<Attribution> meanAttributions;

  ModelExplanation({this.meanAttributions = const []})
    : super(fullyQualifiedName);

  factory ModelExplanation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelExplanation(
      meanAttributions: switch (json['meanAttributions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Attribution.fromJson(i)],
        _ => throw const FormatException('"meanAttributions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (meanAttributions.isNotDefault)
      'meanAttributions': encodeList(meanAttributions),
  };

  @override
  String toString() => 'ModelExplanation()';
}

/// Attribution that explains a particular prediction output.
final class Attribution extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Attribution';

  /// Output only. Model predicted output if the input instance is constructed
  /// from the baselines of all the features defined in
  /// `ExplanationMetadata.inputs`.
  /// The field name of the output is determined by the key in
  /// `ExplanationMetadata.outputs`.
  ///
  /// If the Model's predicted output has multiple dimensions (rank > 1), this is
  /// the value in the output located by
  /// `output_index`.
  ///
  /// If there are multiple baselines, their output values are averaged.
  final double baselineOutputValue;

  /// Output only. Model predicted output on the corresponding [explanation
  /// instance][ExplainRequest.instances]. The field name of the output is
  /// determined by the key in
  /// `ExplanationMetadata.outputs`.
  ///
  /// If the Model predicted output has multiple dimensions, this is the value in
  /// the output located by
  /// `output_index`.
  final double instanceOutputValue;

  /// Output only. Attributions of each explained feature. Features are extracted
  /// from the [prediction
  /// instances][google.cloud.aiplatform.v1beta1.ExplainRequest.instances]
  /// according to [explanation metadata for
  /// inputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs].
  ///
  /// The value is a struct, whose keys are the name of the feature. The values
  /// are how much the feature in the
  /// `instance`
  /// contributed to the predicted result.
  ///
  /// The format of the value is determined by the feature's input format:
  ///
  ///   * If the feature is a scalar value, the attribution value is a
  ///     [floating number][google.protobuf.Value.number_value].
  ///
  ///   * If the feature is an array of scalar values, the attribution value is
  ///     an `array`.
  ///
  ///   * If the feature is a struct, the attribution value is a
  ///     `struct`. The keys in the
  ///     attribution value struct are the same as the keys in the feature
  ///     struct. The formats of the values in the attribution struct are
  ///     determined by the formats of the values in the feature struct.
  ///
  /// The
  /// `ExplanationMetadata.feature_attributions_schema_uri`
  /// field, pointed to by the
  /// `ExplanationSpec` field of
  /// the
  /// `Endpoint.deployed_models`
  /// object, points to the schema file that describes the features and their
  /// attribution values (if it is populated).
  final protobuf.Value? featureAttributions;

  /// Output only. The index that locates the explained prediction output.
  ///
  /// If the prediction output is a scalar value, output_index is not populated.
  /// If the prediction output has multiple dimensions, the length of the
  /// output_index list is the same as the number of dimensions of the output.
  /// The i-th element in output_index is the element index of the i-th dimension
  /// of the output vector. Indices start from 0.
  final List<int> outputIndex;

  /// Output only. The display name of the output identified by
  /// `output_index`.
  /// For example, the predicted class name by a multi-classification Model.
  ///
  /// This field is only populated iff the Model predicts display names as a
  /// separate field along with the explained output. The predicted display name
  /// must has the same shape of the explained output, and can be located using
  /// output_index.
  final String outputDisplayName;

  /// Output only. Error of
  /// `feature_attributions`
  /// caused by approximation used in the explanation method. Lower value means
  /// more precise attributions.
  ///
  /// * For Sampled Shapley
  /// `attribution`,
  /// increasing
  /// `path_count`
  /// might reduce the error.
  /// * For Integrated Gradients
  /// `attribution`,
  /// increasing
  /// `step_count`
  /// might reduce the error.
  /// * For [XRAI
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.xrai_attribution],
  /// increasing
  /// `step_count`
  /// might reduce the error.
  ///
  /// See [this introduction](/vertex-ai/docs/explainable-ai/overview)
  /// for more information.
  final double approximationError;

  /// Output only. Name of the explain output. Specified as the key in
  /// `ExplanationMetadata.outputs`.
  final String outputName;

  Attribution({
    this.baselineOutputValue = 0,
    this.instanceOutputValue = 0,
    this.featureAttributions,
    this.outputIndex = const [],
    this.outputDisplayName = '',
    this.approximationError = 0,
    this.outputName = '',
  }) : super(fullyQualifiedName);

  factory Attribution.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Attribution(
      baselineOutputValue: switch (json['baselineOutputValue']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      instanceOutputValue: switch (json['instanceOutputValue']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      featureAttributions: switch (json['featureAttributions']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      outputIndex: switch (json['outputIndex']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt(i)],
        _ => throw const FormatException('"outputIndex" is not a list'),
      },
      outputDisplayName: switch (json['outputDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      approximationError: switch (json['approximationError']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      outputName: switch (json['outputName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (baselineOutputValue.isNotDefault)
      'baselineOutputValue': encodeDouble(baselineOutputValue),
    if (instanceOutputValue.isNotDefault)
      'instanceOutputValue': encodeDouble(instanceOutputValue),
    if (featureAttributions != null)
      'featureAttributions': featureAttributions!.toJson(),
    if (outputIndex.isNotDefault) 'outputIndex': outputIndex,
    if (outputDisplayName.isNotDefault) 'outputDisplayName': outputDisplayName,
    if (approximationError.isNotDefault)
      'approximationError': encodeDouble(approximationError),
    if (outputName.isNotDefault) 'outputName': outputName,
  };

  @override
  String toString() {
    final contents = [
      'baselineOutputValue=$baselineOutputValue',
      'instanceOutputValue=$instanceOutputValue',
      'outputDisplayName=$outputDisplayName',
      'approximationError=$approximationError',
      'outputName=$outputName',
    ].join(',');
    return 'Attribution($contents)';
  }
}

/// Neighbors for example-based explanations.
final class Neighbor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Neighbor';

  /// Output only. The neighbor id.
  final String neighborId;

  /// Output only. The neighbor distance.
  final double neighborDistance;

  Neighbor({this.neighborId = '', this.neighborDistance = 0})
    : super(fullyQualifiedName);

  factory Neighbor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Neighbor(
      neighborId: switch (json['neighborId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      neighborDistance: switch (json['neighborDistance']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (neighborId.isNotDefault) 'neighborId': neighborId,
    if (neighborDistance.isNotDefault)
      'neighborDistance': encodeDouble(neighborDistance),
  };

  @override
  String toString() {
    final contents = [
      'neighborId=$neighborId',
      'neighborDistance=$neighborDistance',
    ].join(',');
    return 'Neighbor($contents)';
  }
}

/// Specification of Model explanation.
final class ExplanationSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationSpec';

  /// Required. Parameters that configure explaining of the Model's predictions.
  final ExplanationParameters? parameters;

  /// Optional. Metadata describing the Model's input and output for explanation.
  final ExplanationMetadata? metadata;

  ExplanationSpec({required this.parameters, this.metadata})
    : super(fullyQualifiedName);

  factory ExplanationSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplanationSpec(
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => ExplanationParameters.fromJson($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => ExplanationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (parameters != null) 'parameters': parameters!.toJson(),
    if (metadata != null) 'metadata': metadata!.toJson(),
  };

  @override
  String toString() => 'ExplanationSpec()';
}

/// Parameters to configure explaining for Model's predictions.
final class ExplanationParameters extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationParameters';

  /// An attribution method that approximates Shapley values for features that
  /// contribute to the label being predicted. A sampling strategy is used to
  /// approximate the value rather than considering all subsets of features.
  /// Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
  final SampledShapleyAttribution? sampledShapleyAttribution;

  /// An attribution method that computes Aumann-Shapley values taking
  /// advantage of the model's fully differentiable structure. Refer to this
  /// paper for more details: https://arxiv.org/abs/1703.01365
  final IntegratedGradientsAttribution? integratedGradientsAttribution;

  /// An attribution method that redistributes Integrated Gradients
  /// attribution to segmented regions, taking advantage of the model's fully
  /// differentiable structure. Refer to this paper for
  /// more details: https://arxiv.org/abs/1906.02825
  ///
  /// XRAI currently performs better on natural images, like a picture of a
  /// house or an animal. If the images are taken in artificial environments,
  /// like a lab or manufacturing line, or from diagnostic equipment, like
  /// x-rays or quality-control cameras, use Integrated Gradients instead.
  final XraiAttribution? xraiAttribution;

  /// Example-based explanations that returns the nearest neighbors from the
  /// provided dataset.
  final Examples? examples;

  /// If populated, returns attributions for top K indices of outputs
  /// (defaults to 1). Only applies to Models that predicts more than one outputs
  /// (e,g, multi-class Models). When set to -1, returns explanations for all
  /// outputs.
  final int topK;

  /// If populated, only returns attributions that have
  /// `output_index`
  /// contained in output_indices. It must be an ndarray of integers, with the
  /// same shape of the output it's explaining.
  ///
  /// If not populated, returns attributions for
  /// `top_k`
  /// indices of outputs. If neither top_k nor output_indices is populated,
  /// returns the argmax index of the outputs.
  ///
  /// Only applicable to Models that predict multiple outputs (e,g, multi-class
  /// Models that predict multiple classes).
  final protobuf.ListValue? outputIndices;

  ExplanationParameters({
    this.sampledShapleyAttribution,
    this.integratedGradientsAttribution,
    this.xraiAttribution,
    this.examples,
    this.topK = 0,
    this.outputIndices,
  }) : super(fullyQualifiedName);

  factory ExplanationParameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplanationParameters(
      sampledShapleyAttribution: switch (json['sampledShapleyAttribution']) {
        null => null,
        Object $1 => SampledShapleyAttribution.fromJson($1),
      },
      integratedGradientsAttribution:
          switch (json['integratedGradientsAttribution']) {
            null => null,
            Object $1 => IntegratedGradientsAttribution.fromJson($1),
          },
      xraiAttribution: switch (json['xraiAttribution']) {
        null => null,
        Object $1 => XraiAttribution.fromJson($1),
      },
      examples: switch (json['examples']) {
        null => null,
        Object $1 => Examples.fromJson($1),
      },
      topK: switch (json['topK']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      outputIndices: switch (json['outputIndices']) {
        null => null,
        Object $1 => protobuf.ListValue.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sampledShapleyAttribution != null)
      'sampledShapleyAttribution': sampledShapleyAttribution!.toJson(),
    if (integratedGradientsAttribution != null)
      'integratedGradientsAttribution': integratedGradientsAttribution!
          .toJson(),
    if (xraiAttribution != null) 'xraiAttribution': xraiAttribution!.toJson(),
    if (examples != null) 'examples': examples!.toJson(),
    if (topK.isNotDefault) 'topK': topK,
    if (outputIndices != null) 'outputIndices': outputIndices!.toJson(),
  };

  @override
  String toString() {
    final contents = ['topK=$topK'].join(',');
    return 'ExplanationParameters($contents)';
  }
}

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted. A sampling strategy is used to
/// approximate the value rather than considering all subsets of features.
final class SampledShapleyAttribution extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SampledShapleyAttribution';

  /// Required. The number of feature permutations to consider when approximating
  /// the Shapley values.
  ///
  /// Valid range of its value is [1, 50], inclusively.
  final int pathCount;

  SampledShapleyAttribution({required this.pathCount})
    : super(fullyQualifiedName);

  factory SampledShapleyAttribution.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SampledShapleyAttribution(
      pathCount: switch (json['pathCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {'pathCount': pathCount};

  @override
  String toString() {
    final contents = ['pathCount=$pathCount'].join(',');
    return 'SampledShapleyAttribution($contents)';
  }
}

/// An attribution method that computes the Aumann-Shapley value taking advantage
/// of the model's fully differentiable structure. Refer to this paper for
/// more details: https://arxiv.org/abs/1703.01365
final class IntegratedGradientsAttribution extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IntegratedGradientsAttribution';

  /// Required. The number of steps for approximating the path integral.
  /// A good value to start is 50 and gradually increase until the
  /// sum to diff property is within the desired error range.
  ///
  /// Valid range of its value is [1, 100], inclusively.
  final int stepCount;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding
  /// noise can help improve the computed gradients. Refer to this paper for more
  /// details: https://arxiv.org/pdf/1706.03825.pdf
  final SmoothGradConfig? smoothGradConfig;

  /// Config for IG with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image) is
  /// motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  final BlurBaselineConfig? blurBaselineConfig;

  IntegratedGradientsAttribution({
    required this.stepCount,
    this.smoothGradConfig,
    this.blurBaselineConfig,
  }) : super(fullyQualifiedName);

  factory IntegratedGradientsAttribution.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IntegratedGradientsAttribution(
      stepCount: switch (json['stepCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      smoothGradConfig: switch (json['smoothGradConfig']) {
        null => null,
        Object $1 => SmoothGradConfig.fromJson($1),
      },
      blurBaselineConfig: switch (json['blurBaselineConfig']) {
        null => null,
        Object $1 => BlurBaselineConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'stepCount': stepCount,
    if (smoothGradConfig != null)
      'smoothGradConfig': smoothGradConfig!.toJson(),
    if (blurBaselineConfig != null)
      'blurBaselineConfig': blurBaselineConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['stepCount=$stepCount'].join(',');
    return 'IntegratedGradientsAttribution($contents)';
  }
}

/// An explanation method that redistributes Integrated Gradients
/// attributions to segmented regions, taking advantage of the model's fully
/// differentiable structure. Refer to this paper for more details:
/// https://arxiv.org/abs/1906.02825
///
/// Supported only by image Models.
final class XraiAttribution extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.XraiAttribution';

  /// Required. The number of steps for approximating the path integral.
  /// A good value to start is 50 and gradually increase until the
  /// sum to diff property is met within the desired error range.
  ///
  /// Valid range of its value is [1, 100], inclusively.
  final int stepCount;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding
  /// noise can help improve the computed gradients. Refer to this paper for more
  /// details: https://arxiv.org/pdf/1706.03825.pdf
  final SmoothGradConfig? smoothGradConfig;

  /// Config for XRAI with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image) is
  /// motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  final BlurBaselineConfig? blurBaselineConfig;

  XraiAttribution({
    required this.stepCount,
    this.smoothGradConfig,
    this.blurBaselineConfig,
  }) : super(fullyQualifiedName);

  factory XraiAttribution.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return XraiAttribution(
      stepCount: switch (json['stepCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      smoothGradConfig: switch (json['smoothGradConfig']) {
        null => null,
        Object $1 => SmoothGradConfig.fromJson($1),
      },
      blurBaselineConfig: switch (json['blurBaselineConfig']) {
        null => null,
        Object $1 => BlurBaselineConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'stepCount': stepCount,
    if (smoothGradConfig != null)
      'smoothGradConfig': smoothGradConfig!.toJson(),
    if (blurBaselineConfig != null)
      'blurBaselineConfig': blurBaselineConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['stepCount=$stepCount'].join(',');
    return 'XraiAttribution($contents)';
  }
}

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// https://arxiv.org/pdf/1706.03825.pdf
final class SmoothGradConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SmoothGradConfig';

  /// This is a single float value and will be used to add noise to all the
  /// features. Use this field when all features are normalized to have the
  /// same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where
  /// features are normalized to have 0-mean and 1-variance. Learn more about
  /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
  ///
  /// For best results the recommended value is about 10% - 20% of the standard
  /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
  /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1.
  ///
  /// If the distribution is different per feature, set
  /// `feature_noise_sigma`
  /// instead for each feature.
  final double? noiseSigma;

  /// This is similar to
  /// `noise_sigma`,
  /// but provides additional flexibility. A separate noise sigma can be
  /// provided for each feature, which is useful if their distributions are
  /// different. No noise is added to features that are not set. If this field
  /// is unset,
  /// `noise_sigma`
  /// will be used for all features.
  final FeatureNoiseSigma? featureNoiseSigma;

  /// The number of gradient samples to use for
  /// approximation. The higher this number, the more accurate the gradient
  /// is, but the runtime complexity increases by this factor as well.
  /// Valid range of its value is [1, 50]. Defaults to 3.
  final int noisySampleCount;

  SmoothGradConfig({
    this.noiseSigma,
    this.featureNoiseSigma,
    this.noisySampleCount = 0,
  }) : super(fullyQualifiedName);

  factory SmoothGradConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SmoothGradConfig(
      noiseSigma: switch (json['noiseSigma']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      featureNoiseSigma: switch (json['featureNoiseSigma']) {
        null => null,
        Object $1 => FeatureNoiseSigma.fromJson($1),
      },
      noisySampleCount: switch (json['noisySampleCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (noiseSigma != null) 'noiseSigma': encodeDouble(noiseSigma),
    if (featureNoiseSigma != null)
      'featureNoiseSigma': featureNoiseSigma!.toJson(),
    if (noisySampleCount.isNotDefault) 'noisySampleCount': noisySampleCount,
  };

  @override
  String toString() {
    final contents = [
      if (noiseSigma != null) 'noiseSigma=$noiseSigma',
      'noisySampleCount=$noisySampleCount',
    ].join(',');
    return 'SmoothGradConfig($contents)';
  }
}

/// Noise sigma by features. Noise sigma represents the standard deviation of the
/// gaussian kernel that will be used to add noise to interpolated inputs prior
/// to computing gradients.
final class FeatureNoiseSigma extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureNoiseSigma';

  /// Noise sigma per feature. No noise is added to features that are not set.
  final List<FeatureNoiseSigma_NoiseSigmaForFeature> noiseSigma;

  FeatureNoiseSigma({this.noiseSigma = const []}) : super(fullyQualifiedName);

  factory FeatureNoiseSigma.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureNoiseSigma(
      noiseSigma: switch (json['noiseSigma']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            FeatureNoiseSigma_NoiseSigmaForFeature.fromJson(i),
        ],
        _ => throw const FormatException('"noiseSigma" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (noiseSigma.isNotDefault) 'noiseSigma': encodeList(noiseSigma),
  };

  @override
  String toString() => 'FeatureNoiseSigma()';
}

/// Noise sigma for a single feature.
final class FeatureNoiseSigma_NoiseSigmaForFeature extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureNoiseSigma.NoiseSigmaForFeature';

  /// The name of the input feature for which noise sigma is provided. The
  /// features are defined in
  /// [explanation metadata
  /// inputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs].
  final String name;

  /// This represents the standard deviation of the Gaussian kernel that will
  /// be used to add noise to the feature prior to computing gradients. Similar
  /// to
  /// `noise_sigma`
  /// but represents the noise added to the current feature. Defaults to 0.1.
  final double sigma;

  FeatureNoiseSigma_NoiseSigmaForFeature({this.name = '', this.sigma = 0})
    : super(fullyQualifiedName);

  factory FeatureNoiseSigma_NoiseSigmaForFeature.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureNoiseSigma_NoiseSigmaForFeature(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sigma: switch (json['sigma']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (sigma.isNotDefault) 'sigma': encodeDouble(sigma),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'sigma=$sigma'].join(',');
    return 'NoiseSigmaForFeature($contents)';
  }
}

/// Config for blur baseline.
///
/// When enabled, a linear path from the maximally blurred image to the input
/// image is created. Using a blurred baseline instead of zero (black image) is
/// motivated by the BlurIG approach explained here:
/// https://arxiv.org/abs/2004.03383
final class BlurBaselineConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BlurBaselineConfig';

  /// The standard deviation of the blur kernel for the blurred baseline. The
  /// same blurring parameter is used for both the height and the width
  /// dimension. If not set, the method defaults to the zero (i.e. black for
  /// images) baseline.
  final double maxBlurSigma;

  BlurBaselineConfig({this.maxBlurSigma = 0}) : super(fullyQualifiedName);

  factory BlurBaselineConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BlurBaselineConfig(
      maxBlurSigma: switch (json['maxBlurSigma']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxBlurSigma.isNotDefault) 'maxBlurSigma': encodeDouble(maxBlurSigma),
  };

  @override
  String toString() {
    final contents = ['maxBlurSigma=$maxBlurSigma'].join(',');
    return 'BlurBaselineConfig($contents)';
  }
}

/// Example-based explainability that returns the nearest neighbors from the
/// provided dataset.
final class Examples extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Examples';

  /// The Cloud Storage input instances.
  final Examples_ExampleGcsSource? exampleGcsSource;

  /// The full configuration for the generated index, the semantics are the
  /// same as `metadata` and
  /// should match
  /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
  final protobuf.Value? nearestNeighborSearchConfig;

  /// Simplified preset configuration, which automatically sets configuration
  /// values based on the desired query speed-precision trade-off and modality.
  final Presets? presets;

  /// The Cloud Storage locations that contain the instances to be
  /// indexed for approximate nearest neighbor search.
  final GcsSource? gcsSource;

  /// The number of neighbors to return when querying for examples.
  final int neighborCount;

  Examples({
    this.exampleGcsSource,
    this.nearestNeighborSearchConfig,
    this.presets,
    this.gcsSource,
    this.neighborCount = 0,
  }) : super(fullyQualifiedName);

  factory Examples.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Examples(
      exampleGcsSource: switch (json['exampleGcsSource']) {
        null => null,
        Object $1 => Examples_ExampleGcsSource.fromJson($1),
      },
      nearestNeighborSearchConfig:
          switch (json['nearestNeighborSearchConfig']) {
            null => null,
            Object $1 => protobuf.Value.fromJson($1),
          },
      presets: switch (json['presets']) {
        null => null,
        Object $1 => Presets.fromJson($1),
      },
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      neighborCount: switch (json['neighborCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (exampleGcsSource != null)
      'exampleGcsSource': exampleGcsSource!.toJson(),
    if (nearestNeighborSearchConfig != null)
      'nearestNeighborSearchConfig': nearestNeighborSearchConfig!.toJson(),
    if (presets != null) 'presets': presets!.toJson(),
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    if (neighborCount.isNotDefault) 'neighborCount': neighborCount,
  };

  @override
  String toString() {
    final contents = ['neighborCount=$neighborCount'].join(',');
    return 'Examples($contents)';
  }
}

/// The Cloud Storage input instances.
final class Examples_ExampleGcsSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Examples.ExampleGcsSource';

  /// The format in which instances are given, if not specified, assume it's
  /// JSONL format. Currently only JSONL format is supported.
  final Examples_ExampleGcsSource_DataFormat dataFormat;

  /// The Cloud Storage location for the input instances.
  final GcsSource? gcsSource;

  Examples_ExampleGcsSource({
    this.dataFormat = Examples_ExampleGcsSource_DataFormat.$default,
    this.gcsSource,
  }) : super(fullyQualifiedName);

  factory Examples_ExampleGcsSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Examples_ExampleGcsSource(
      dataFormat: switch (json['dataFormat']) {
        null => Examples_ExampleGcsSource_DataFormat.$default,
        Object $1 => Examples_ExampleGcsSource_DataFormat.fromJson($1),
      },
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataFormat.isNotDefault) 'dataFormat': dataFormat.toJson(),
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
  };

  @override
  String toString() {
    final contents = ['dataFormat=$dataFormat'].join(',');
    return 'ExampleGcsSource($contents)';
  }
}

/// The format of the input example instances.
final class Examples_ExampleGcsSource_DataFormat extends ProtoEnum {
  /// Format unspecified, used when unset.
  static const dataFormatUnspecified = Examples_ExampleGcsSource_DataFormat(
    'DATA_FORMAT_UNSPECIFIED',
  );

  /// Examples are stored in JSONL files.
  static const jsonl = Examples_ExampleGcsSource_DataFormat('JSONL');

  /// The default value for [Examples_ExampleGcsSource_DataFormat].
  static const $default = dataFormatUnspecified;

  const Examples_ExampleGcsSource_DataFormat(super.value);

  factory Examples_ExampleGcsSource_DataFormat.fromJson(Object? json) =>
      Examples_ExampleGcsSource_DataFormat(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DataFormat.$value';
}

/// Preset configuration for example-based explanations
final class Presets extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Presets';

  /// Preset option controlling parameters for speed-precision trade-off when
  /// querying for examples. If omitted, defaults to `PRECISE`.
  final Presets_Query? query;

  /// The modality of the uploaded model, which automatically configures the
  /// distance measurement and feature normalization for the underlying example
  /// index and queries. If your model does not precisely fit one of these types,
  /// it is okay to choose the closest type.
  final Presets_Modality modality;

  Presets({this.query, this.modality = Presets_Modality.$default})
    : super(fullyQualifiedName);

  factory Presets.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Presets(
      query: switch (json['query']) {
        null => null,
        Object $1 => Presets_Query.fromJson($1),
      },
      modality: switch (json['modality']) {
        null => Presets_Modality.$default,
        Object $1 => Presets_Modality.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (query != null) 'query': query!.toJson(),
    if (modality.isNotDefault) 'modality': modality.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (query != null) 'query=$query',
      'modality=$modality',
    ].join(',');
    return 'Presets($contents)';
  }
}

/// Preset option controlling parameters for query speed-precision trade-off
final class Presets_Query extends ProtoEnum {
  /// More precise neighbors as a trade-off against slower response.
  static const precise = Presets_Query('PRECISE');

  /// Faster response as a trade-off against less precise neighbors.
  static const fast = Presets_Query('FAST');

  /// The default value for [Presets_Query].
  static const $default = precise;

  const Presets_Query(super.value);

  factory Presets_Query.fromJson(Object? json) => Presets_Query(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Query.$value';
}

/// Preset option controlling parameters for different modalities
final class Presets_Modality extends ProtoEnum {
  /// Should not be set. Added as a recommended best practice for enums
  static const modalityUnspecified = Presets_Modality('MODALITY_UNSPECIFIED');

  /// IMAGE modality
  static const image = Presets_Modality('IMAGE');

  /// TEXT modality
  static const text = Presets_Modality('TEXT');

  /// TABULAR modality
  static const tabular = Presets_Modality('TABULAR');

  /// The default value for [Presets_Modality].
  static const $default = modalityUnspecified;

  const Presets_Modality(super.value);

  factory Presets_Modality.fromJson(Object? json) =>
      Presets_Modality(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Modality.$value';
}

/// The `ExplanationSpec`
/// entries that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1beta1.PredictionService.Explain] time.
final class ExplanationSpecOverride extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationSpecOverride';

  /// The parameters to be overridden. Note that the
  /// attribution method cannot be changed. If not specified,
  /// no parameter is overridden.
  final ExplanationParameters? parameters;

  /// The metadata to be overridden. If not specified, no metadata is overridden.
  final ExplanationMetadataOverride? metadata;

  /// The example-based explanations parameter overrides.
  final ExamplesOverride? examplesOverride;

  ExplanationSpecOverride({
    this.parameters,
    this.metadata,
    this.examplesOverride,
  }) : super(fullyQualifiedName);

  factory ExplanationSpecOverride.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplanationSpecOverride(
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => ExplanationParameters.fromJson($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => ExplanationMetadataOverride.fromJson($1),
      },
      examplesOverride: switch (json['examplesOverride']) {
        null => null,
        Object $1 => ExamplesOverride.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (parameters != null) 'parameters': parameters!.toJson(),
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (examplesOverride != null)
      'examplesOverride': examplesOverride!.toJson(),
  };

  @override
  String toString() => 'ExplanationSpecOverride()';
}

/// The
/// `ExplanationMetadata`
/// entries that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1beta1.PredictionService.Explain] time.
final class ExplanationMetadataOverride extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadataOverride';

  /// Required. Overrides the [input
  /// metadata][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs] of
  /// the features. The key is the name of the feature to be overridden. The keys
  /// specified here must exist in the input metadata to be overridden. If a
  /// feature is not specified here, the corresponding feature's input metadata
  /// is not overridden.
  final Map<String, ExplanationMetadataOverride_InputMetadataOverride> inputs;

  ExplanationMetadataOverride({required this.inputs})
    : super(fullyQualifiedName);

  factory ExplanationMetadataOverride.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplanationMetadataOverride(
      inputs: switch (json['inputs']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(
              e.key,
            ): ExplanationMetadataOverride_InputMetadataOverride.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"inputs" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {'inputs': encodeMap(inputs)};

  @override
  String toString() => 'ExplanationMetadataOverride()';
}

/// The [input
/// metadata][google.cloud.aiplatform.v1beta1.ExplanationMetadata.InputMetadata]
/// entries to be overridden.
final class ExplanationMetadataOverride_InputMetadataOverride
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadataOverride.InputMetadataOverride';

  /// Baseline inputs for this feature.
  ///
  /// This overrides the `input_baseline` field of the
  /// `ExplanationMetadata.InputMetadata`
  /// object of the corresponding feature's input metadata. If it's not
  /// specified, the original baselines are not overridden.
  final List<protobuf.Value> inputBaselines;

  ExplanationMetadataOverride_InputMetadataOverride({
    this.inputBaselines = const [],
  }) : super(fullyQualifiedName);

  factory ExplanationMetadataOverride_InputMetadataOverride.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ExplanationMetadataOverride_InputMetadataOverride(
      inputBaselines: switch (json['inputBaselines']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"inputBaselines" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (inputBaselines.isNotDefault)
      'inputBaselines': encodeList(inputBaselines),
  };

  @override
  String toString() => 'InputMetadataOverride()';
}

/// Overrides for example-based explanations.
final class ExamplesOverride extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExamplesOverride';

  /// The number of neighbors to return.
  final int neighborCount;

  /// The number of neighbors to return that have the same crowding tag.
  final int crowdingCount;

  /// Restrict the resulting nearest neighbors to respect these constraints.
  final List<ExamplesRestrictionsNamespace> restrictions;

  /// If true, return the embeddings instead of neighbors.
  final bool returnEmbeddings;

  /// The format of the data being provided with each call.
  final ExamplesOverride_DataFormat dataFormat;

  ExamplesOverride({
    this.neighborCount = 0,
    this.crowdingCount = 0,
    this.restrictions = const [],
    this.returnEmbeddings = false,
    this.dataFormat = ExamplesOverride_DataFormat.$default,
  }) : super(fullyQualifiedName);

  factory ExamplesOverride.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExamplesOverride(
      neighborCount: switch (json['neighborCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      crowdingCount: switch (json['crowdingCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      restrictions: switch (json['restrictions']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ExamplesRestrictionsNamespace.fromJson(i),
        ],
        _ => throw const FormatException('"restrictions" is not a list'),
      },
      returnEmbeddings: switch (json['returnEmbeddings']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      dataFormat: switch (json['dataFormat']) {
        null => ExamplesOverride_DataFormat.$default,
        Object $1 => ExamplesOverride_DataFormat.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (neighborCount.isNotDefault) 'neighborCount': neighborCount,
    if (crowdingCount.isNotDefault) 'crowdingCount': crowdingCount,
    if (restrictions.isNotDefault) 'restrictions': encodeList(restrictions),
    if (returnEmbeddings.isNotDefault) 'returnEmbeddings': returnEmbeddings,
    if (dataFormat.isNotDefault) 'dataFormat': dataFormat.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'neighborCount=$neighborCount',
      'crowdingCount=$crowdingCount',
      'returnEmbeddings=$returnEmbeddings',
      'dataFormat=$dataFormat',
    ].join(',');
    return 'ExamplesOverride($contents)';
  }
}

/// Data format enum.
final class ExamplesOverride_DataFormat extends ProtoEnum {
  /// Unspecified format. Must not be used.
  static const dataFormatUnspecified = ExamplesOverride_DataFormat(
    'DATA_FORMAT_UNSPECIFIED',
  );

  /// Provided data is a set of model inputs.
  static const instances = ExamplesOverride_DataFormat('INSTANCES');

  /// Provided data is a set of embeddings.
  static const embeddings = ExamplesOverride_DataFormat('EMBEDDINGS');

  /// The default value for [ExamplesOverride_DataFormat].
  static const $default = dataFormatUnspecified;

  const ExamplesOverride_DataFormat(super.value);

  factory ExamplesOverride_DataFormat.fromJson(Object? json) =>
      ExamplesOverride_DataFormat(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DataFormat.$value';
}

/// Restrictions namespace for example-based explanations overrides.
final class ExamplesRestrictionsNamespace extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExamplesRestrictionsNamespace';

  /// The namespace name.
  final String namespaceName;

  /// The list of allowed tags.
  final List<String> allow;

  /// The list of deny tags.
  final List<String> deny;

  ExamplesRestrictionsNamespace({
    this.namespaceName = '',
    this.allow = const [],
    this.deny = const [],
  }) : super(fullyQualifiedName);

  factory ExamplesRestrictionsNamespace.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExamplesRestrictionsNamespace(
      namespaceName: switch (json['namespaceName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      allow: switch (json['allow']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"allow" is not a list'),
      },
      deny: switch (json['deny']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"deny" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (namespaceName.isNotDefault) 'namespaceName': namespaceName,
    if (allow.isNotDefault) 'allow': allow,
    if (deny.isNotDefault) 'deny': deny,
  };

  @override
  String toString() {
    final contents = ['namespaceName=$namespaceName'].join(',');
    return 'ExamplesRestrictionsNamespace($contents)';
  }
}

/// Metadata describing the Model's input and output for explanation.
final class ExplanationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata';

  /// Required. Map from feature names to feature input metadata. Keys are the
  /// name of the features. Values are the specification of the feature.
  ///
  /// An empty InputMetadata is valid. It describes a text feature which has the
  /// name specified as the key in
  /// `ExplanationMetadata.inputs`.
  /// The baseline of the empty feature is chosen by Vertex AI.
  ///
  /// For Vertex AI-provided Tensorflow images, the key can be any friendly
  /// name of the feature. Once specified,
  /// `featureAttributions`
  /// are keyed by this key (if not grouped with another feature).
  ///
  /// For custom images, the key must match with the key in
  /// `instance`.
  final Map<String, ExplanationMetadata_InputMetadata> inputs;

  /// Required. Map from output names to output metadata.
  ///
  /// For Vertex AI-provided Tensorflow images, keys can be any user defined
  /// string that consists of any UTF-8 characters.
  ///
  /// For custom images, keys are the name of the output field in the prediction
  /// to be explained.
  ///
  /// Currently only one key is allowed.
  final Map<String, ExplanationMetadata_OutputMetadata> outputs;

  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of the [feature
  /// attributions][google.cloud.aiplatform.v1beta1.Attribution.feature_attributions].
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML tabular Models always have this field populated by Vertex AI.
  /// Note: The URI given on output may be different, including the URI scheme,
  /// than the one given on input. The output URI will point to a location where
  /// the user only has a read access.
  final String featureAttributionsSchemaUri;

  /// Name of the source to generate embeddings for example based explanations.
  final String latentSpaceSource;

  ExplanationMetadata({
    required this.inputs,
    required this.outputs,
    this.featureAttributionsSchemaUri = '',
    this.latentSpaceSource = '',
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplanationMetadata(
      inputs: switch (json['inputs']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ExplanationMetadata_InputMetadata.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"inputs" is not an object'),
      },
      outputs: switch (json['outputs']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ExplanationMetadata_OutputMetadata.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"outputs" is not an object'),
      },
      featureAttributionsSchemaUri:
          switch (json['featureAttributionsSchemaUri']) {
            null => '',
            Object $1 => decodeString($1),
          },
      latentSpaceSource: switch (json['latentSpaceSource']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'inputs': encodeMap(inputs),
    'outputs': encodeMap(outputs),
    if (featureAttributionsSchemaUri.isNotDefault)
      'featureAttributionsSchemaUri': featureAttributionsSchemaUri,
    if (latentSpaceSource.isNotDefault) 'latentSpaceSource': latentSpaceSource,
  };

  @override
  String toString() {
    final contents = [
      'featureAttributionsSchemaUri=$featureAttributionsSchemaUri',
      'latentSpaceSource=$latentSpaceSource',
    ].join(',');
    return 'ExplanationMetadata($contents)';
  }
}

/// Metadata of the input of a feature.
///
/// Fields other than
/// `InputMetadata.input_baselines`
/// are applicable only for Models that are using Vertex AI-provided images for
/// Tensorflow.
final class ExplanationMetadata_InputMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata.InputMetadata';

  /// Baseline inputs for this feature.
  ///
  /// If no baseline is specified, Vertex AI chooses the baseline for this
  /// feature. If multiple baselines are specified, Vertex AI returns the
  /// average attributions across them in
  /// `Attribution.feature_attributions`.
  ///
  /// For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape
  /// of each baseline must match the shape of the input tensor. If a scalar is
  /// provided, we broadcast to the same shape as the input tensor.
  ///
  /// For custom images, the element of the baselines must be in the same
  /// format as the feature's input in the
  /// `instance`[].
  /// The schema of any single instance may be specified via Endpoint's
  /// DeployedModels'
  /// [Model's][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`.
  final List<protobuf.Value> inputBaselines;

  /// Name of the input tensor for this feature. Required and is only
  /// applicable to Vertex AI-provided images for Tensorflow.
  final String inputTensorName;

  /// Defines how the feature is encoded into the input tensor. Defaults to
  /// IDENTITY.
  final ExplanationMetadata_InputMetadata_Encoding encoding;

  /// Modality of the feature. Valid values are: numeric, image. Defaults to
  /// numeric.
  final String modality;

  /// The domain details of the input feature value. Like min/max, original
  /// mean or standard deviation if normalized.
  final ExplanationMetadata_InputMetadata_FeatureValueDomain?
  featureValueDomain;

  /// Specifies the index of the values of the input tensor.
  /// Required when the input tensor is a sparse representation. Refer to
  /// Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  final String indicesTensorName;

  /// Specifies the shape of the values of the input if the input is a sparse
  /// representation. Refer to Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  final String denseShapeTensorName;

  /// A list of feature names for each index in the input tensor.
  /// Required when the input
  /// `InputMetadata.encoding`
  /// is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
  final List<String> indexFeatureMapping;

  /// Encoded tensor is a transformation of the input tensor. Must be provided
  /// if choosing
  /// [Integrated Gradients
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.integrated_gradients_attribution]
  /// or [XRAI
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.xrai_attribution]
  /// and the input tensor is not differentiable.
  ///
  /// An encoded tensor is generated if the input tensor is encoded by a lookup
  /// table.
  final String encodedTensorName;

  /// A list of baselines for the encoded tensor.
  ///
  /// The shape of each baseline should match the shape of the encoded tensor.
  /// If a scalar is provided, Vertex AI broadcasts to the same shape as the
  /// encoded tensor.
  final List<protobuf.Value> encodedBaselines;

  /// Visualization configurations for image explanation.
  final ExplanationMetadata_InputMetadata_Visualization? visualization;

  /// Name of the group that the input belongs to. Features with the same group
  /// name will be treated as one feature when computing attributions. Features
  /// grouped together can have different shapes in value. If provided, there
  /// will be one single attribution generated in
  /// `Attribution.feature_attributions`,
  /// keyed by the group name.
  final String groupName;

  ExplanationMetadata_InputMetadata({
    this.inputBaselines = const [],
    this.inputTensorName = '',
    this.encoding = ExplanationMetadata_InputMetadata_Encoding.$default,
    this.modality = '',
    this.featureValueDomain,
    this.indicesTensorName = '',
    this.denseShapeTensorName = '',
    this.indexFeatureMapping = const [],
    this.encodedTensorName = '',
    this.encodedBaselines = const [],
    this.visualization,
    this.groupName = '',
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata_InputMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplanationMetadata_InputMetadata(
      inputBaselines: switch (json['inputBaselines']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"inputBaselines" is not a list'),
      },
      inputTensorName: switch (json['inputTensorName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      encoding: switch (json['encoding']) {
        null => ExplanationMetadata_InputMetadata_Encoding.$default,
        Object $1 => ExplanationMetadata_InputMetadata_Encoding.fromJson($1),
      },
      modality: switch (json['modality']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureValueDomain: switch (json['featureValueDomain']) {
        null => null,
        Object $1 =>
          ExplanationMetadata_InputMetadata_FeatureValueDomain.fromJson($1),
      },
      indicesTensorName: switch (json['indicesTensorName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      denseShapeTensorName: switch (json['denseShapeTensorName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      indexFeatureMapping: switch (json['indexFeatureMapping']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"indexFeatureMapping" is not a list'),
      },
      encodedTensorName: switch (json['encodedTensorName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      encodedBaselines: switch (json['encodedBaselines']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"encodedBaselines" is not a list'),
      },
      visualization: switch (json['visualization']) {
        null => null,
        Object $1 => ExplanationMetadata_InputMetadata_Visualization.fromJson(
          $1,
        ),
      },
      groupName: switch (json['groupName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (inputBaselines.isNotDefault)
      'inputBaselines': encodeList(inputBaselines),
    if (inputTensorName.isNotDefault) 'inputTensorName': inputTensorName,
    if (encoding.isNotDefault) 'encoding': encoding.toJson(),
    if (modality.isNotDefault) 'modality': modality,
    if (featureValueDomain != null)
      'featureValueDomain': featureValueDomain!.toJson(),
    if (indicesTensorName.isNotDefault) 'indicesTensorName': indicesTensorName,
    if (denseShapeTensorName.isNotDefault)
      'denseShapeTensorName': denseShapeTensorName,
    if (indexFeatureMapping.isNotDefault)
      'indexFeatureMapping': indexFeatureMapping,
    if (encodedTensorName.isNotDefault) 'encodedTensorName': encodedTensorName,
    if (encodedBaselines.isNotDefault)
      'encodedBaselines': encodeList(encodedBaselines),
    if (visualization != null) 'visualization': visualization!.toJson(),
    if (groupName.isNotDefault) 'groupName': groupName,
  };

  @override
  String toString() {
    final contents = [
      'inputTensorName=$inputTensorName',
      'encoding=$encoding',
      'modality=$modality',
      'indicesTensorName=$indicesTensorName',
      'denseShapeTensorName=$denseShapeTensorName',
      'encodedTensorName=$encodedTensorName',
      'groupName=$groupName',
    ].join(',');
    return 'InputMetadata($contents)';
  }
}

/// Domain details of the input feature value. Provides numeric information
/// about the feature, such as its range (min, max). If the feature has been
/// pre-processed, for example with z-scoring, then it provides information
/// about how to recover the original feature. For example, if the input
/// feature is an image and it has been pre-processed to obtain 0-mean and
/// stddev = 1 values, then original_mean, and original_stddev refer to the
/// mean and stddev of the original feature (e.g. image tensor) from which
/// input feature (with mean = 0 and stddev = 1) was obtained.
final class ExplanationMetadata_InputMetadata_FeatureValueDomain
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata.InputMetadata.FeatureValueDomain';

  /// The minimum permissible value for this feature.
  final double minValue;

  /// The maximum permissible value for this feature.
  final double maxValue;

  /// If this input feature has been normalized to a mean value of 0,
  /// the original_mean specifies the mean value of the domain prior to
  /// normalization.
  final double originalMean;

  /// If this input feature has been normalized to a standard deviation of
  /// 1.0, the original_stddev specifies the standard deviation of the domain
  /// prior to normalization.
  final double originalStddev;

  ExplanationMetadata_InputMetadata_FeatureValueDomain({
    this.minValue = 0,
    this.maxValue = 0,
    this.originalMean = 0,
    this.originalStddev = 0,
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata_InputMetadata_FeatureValueDomain.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ExplanationMetadata_InputMetadata_FeatureValueDomain(
      minValue: switch (json['minValue']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      maxValue: switch (json['maxValue']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      originalMean: switch (json['originalMean']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      originalStddev: switch (json['originalStddev']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (minValue.isNotDefault) 'minValue': encodeDouble(minValue),
    if (maxValue.isNotDefault) 'maxValue': encodeDouble(maxValue),
    if (originalMean.isNotDefault) 'originalMean': encodeDouble(originalMean),
    if (originalStddev.isNotDefault)
      'originalStddev': encodeDouble(originalStddev),
  };

  @override
  String toString() {
    final contents = [
      'minValue=$minValue',
      'maxValue=$maxValue',
      'originalMean=$originalMean',
      'originalStddev=$originalStddev',
    ].join(',');
    return 'FeatureValueDomain($contents)';
  }
}

/// Visualization configurations for image explanation.
final class ExplanationMetadata_InputMetadata_Visualization
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata.InputMetadata.Visualization';

  /// Type of the image visualization. Only applicable to
  /// [Integrated Gradients
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.integrated_gradients_attribution].
  /// OUTLINES shows regions of attribution, while PIXELS shows per-pixel
  /// attribution. Defaults to OUTLINES.
  final ExplanationMetadata_InputMetadata_Visualization_Type type;

  /// Whether to only highlight pixels with positive contributions, negative
  /// or both. Defaults to POSITIVE.
  final ExplanationMetadata_InputMetadata_Visualization_Polarity polarity;

  /// The color scheme used for the highlighted areas.
  ///
  /// Defaults to PINK_GREEN for
  /// [Integrated Gradients
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.integrated_gradients_attribution],
  /// which shows positive attributions in green and negative in pink.
  ///
  /// Defaults to VIRIDIS for
  /// [XRAI
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.xrai_attribution],
  /// which highlights the most influential regions in yellow and the least
  /// influential in blue.
  final ExplanationMetadata_InputMetadata_Visualization_ColorMap colorMap;

  /// Excludes attributions above the specified percentile from the
  /// highlighted areas. Using the clip_percent_upperbound and
  /// clip_percent_lowerbound together can be useful for filtering out noise
  /// and making it easier to see areas of strong attribution. Defaults to
  /// 99.9.
  final double clipPercentUpperbound;

  /// Excludes attributions below the specified percentile, from the
  /// highlighted areas. Defaults to 62.
  final double clipPercentLowerbound;

  /// How the original image is displayed in the visualization.
  /// Adjusting the overlay can help increase visual clarity if the original
  /// image makes it difficult to view the visualization. Defaults to NONE.
  final ExplanationMetadata_InputMetadata_Visualization_OverlayType overlayType;

  ExplanationMetadata_InputMetadata_Visualization({
    this.type = ExplanationMetadata_InputMetadata_Visualization_Type.$default,
    this.polarity =
        ExplanationMetadata_InputMetadata_Visualization_Polarity.$default,
    this.colorMap =
        ExplanationMetadata_InputMetadata_Visualization_ColorMap.$default,
    this.clipPercentUpperbound = 0,
    this.clipPercentLowerbound = 0,
    this.overlayType =
        ExplanationMetadata_InputMetadata_Visualization_OverlayType.$default,
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata_InputMetadata_Visualization.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplanationMetadata_InputMetadata_Visualization(
      type: switch (json['type']) {
        null => ExplanationMetadata_InputMetadata_Visualization_Type.$default,
        Object $1 =>
          ExplanationMetadata_InputMetadata_Visualization_Type.fromJson($1),
      },
      polarity: switch (json['polarity']) {
        null =>
          ExplanationMetadata_InputMetadata_Visualization_Polarity.$default,
        Object $1 =>
          ExplanationMetadata_InputMetadata_Visualization_Polarity.fromJson($1),
      },
      colorMap: switch (json['colorMap']) {
        null =>
          ExplanationMetadata_InputMetadata_Visualization_ColorMap.$default,
        Object $1 =>
          ExplanationMetadata_InputMetadata_Visualization_ColorMap.fromJson($1),
      },
      clipPercentUpperbound: switch (json['clipPercentUpperbound']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      clipPercentLowerbound: switch (json['clipPercentLowerbound']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      overlayType: switch (json['overlayType']) {
        null =>
          ExplanationMetadata_InputMetadata_Visualization_OverlayType.$default,
        Object $1 =>
          ExplanationMetadata_InputMetadata_Visualization_OverlayType.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type.toJson(),
    if (polarity.isNotDefault) 'polarity': polarity.toJson(),
    if (colorMap.isNotDefault) 'colorMap': colorMap.toJson(),
    if (clipPercentUpperbound.isNotDefault)
      'clipPercentUpperbound': encodeDouble(clipPercentUpperbound),
    if (clipPercentLowerbound.isNotDefault)
      'clipPercentLowerbound': encodeDouble(clipPercentLowerbound),
    if (overlayType.isNotDefault) 'overlayType': overlayType.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'type=$type',
      'polarity=$polarity',
      'colorMap=$colorMap',
      'clipPercentUpperbound=$clipPercentUpperbound',
      'clipPercentLowerbound=$clipPercentLowerbound',
      'overlayType=$overlayType',
    ].join(',');
    return 'Visualization($contents)';
  }
}

/// Type of the image visualization. Only applicable to
/// [Integrated Gradients
/// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.integrated_gradients_attribution].
final class ExplanationMetadata_InputMetadata_Visualization_Type
    extends ProtoEnum {
  /// Should not be used.
  static const typeUnspecified =
      ExplanationMetadata_InputMetadata_Visualization_Type('TYPE_UNSPECIFIED');

  /// Shows which pixel contributed to the image prediction.
  static const pixels = ExplanationMetadata_InputMetadata_Visualization_Type(
    'PIXELS',
  );

  /// Shows which region contributed to the image prediction by outlining
  /// the region.
  static const outlines = ExplanationMetadata_InputMetadata_Visualization_Type(
    'OUTLINES',
  );

  /// The default value for [ExplanationMetadata_InputMetadata_Visualization_Type].
  static const $default = typeUnspecified;

  const ExplanationMetadata_InputMetadata_Visualization_Type(super.value);

  factory ExplanationMetadata_InputMetadata_Visualization_Type.fromJson(
    Object? json,
  ) => ExplanationMetadata_InputMetadata_Visualization_Type(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Whether to only highlight pixels with positive contributions, negative
/// or both. Defaults to POSITIVE.
final class ExplanationMetadata_InputMetadata_Visualization_Polarity
    extends ProtoEnum {
  /// Default value. This is the same as POSITIVE.
  static const polarityUnspecified =
      ExplanationMetadata_InputMetadata_Visualization_Polarity(
        'POLARITY_UNSPECIFIED',
      );

  /// Highlights the pixels/outlines that were most influential to the
  /// model's prediction.
  static const positive =
      ExplanationMetadata_InputMetadata_Visualization_Polarity('POSITIVE');

  /// Setting polarity to negative highlights areas that does not lead to
  /// the models's current prediction.
  static const negative =
      ExplanationMetadata_InputMetadata_Visualization_Polarity('NEGATIVE');

  /// Shows both positive and negative attributions.
  static const both = ExplanationMetadata_InputMetadata_Visualization_Polarity(
    'BOTH',
  );

  /// The default value for [ExplanationMetadata_InputMetadata_Visualization_Polarity].
  static const $default = polarityUnspecified;

  const ExplanationMetadata_InputMetadata_Visualization_Polarity(super.value);

  factory ExplanationMetadata_InputMetadata_Visualization_Polarity.fromJson(
    Object? json,
  ) => ExplanationMetadata_InputMetadata_Visualization_Polarity(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Polarity.$value';
}

/// The color scheme used for highlighting areas.
final class ExplanationMetadata_InputMetadata_Visualization_ColorMap
    extends ProtoEnum {
  /// Should not be used.
  static const colorMapUnspecified =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap(
        'COLOR_MAP_UNSPECIFIED',
      );

  /// Positive: green. Negative: pink.
  static const pinkGreen =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap('PINK_GREEN');

  /// Viridis color map: A perceptually uniform color mapping which is
  /// easier to see by those with colorblindness and progresses from yellow
  /// to green to blue. Positive: yellow. Negative: blue.
  static const viridis =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap('VIRIDIS');

  /// Positive: red. Negative: red.
  static const red = ExplanationMetadata_InputMetadata_Visualization_ColorMap(
    'RED',
  );

  /// Positive: green. Negative: green.
  static const green = ExplanationMetadata_InputMetadata_Visualization_ColorMap(
    'GREEN',
  );

  /// Positive: green. Negative: red.
  static const redGreen =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap('RED_GREEN');

  /// PiYG palette.
  static const pinkWhiteGreen =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap(
        'PINK_WHITE_GREEN',
      );

  /// The default value for [ExplanationMetadata_InputMetadata_Visualization_ColorMap].
  static const $default = colorMapUnspecified;

  const ExplanationMetadata_InputMetadata_Visualization_ColorMap(super.value);

  factory ExplanationMetadata_InputMetadata_Visualization_ColorMap.fromJson(
    Object? json,
  ) => ExplanationMetadata_InputMetadata_Visualization_ColorMap(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ColorMap.$value';
}

/// How the original image is displayed in the visualization.
final class ExplanationMetadata_InputMetadata_Visualization_OverlayType
    extends ProtoEnum {
  /// Default value. This is the same as NONE.
  static const overlayTypeUnspecified =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType(
        'OVERLAY_TYPE_UNSPECIFIED',
      );

  /// No overlay.
  static const none =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType('NONE');

  /// The attributions are shown on top of the original image.
  static const original =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType('ORIGINAL');

  /// The attributions are shown on top of grayscaled version of the
  /// original image.
  static const grayscale =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType('GRAYSCALE');

  /// The attributions are used as a mask to reveal predictive parts of
  /// the image and hide the un-predictive parts.
  static const maskBlack =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType('MASK_BLACK');

  /// The default value for [ExplanationMetadata_InputMetadata_Visualization_OverlayType].
  static const $default = overlayTypeUnspecified;

  const ExplanationMetadata_InputMetadata_Visualization_OverlayType(
    super.value,
  );

  factory ExplanationMetadata_InputMetadata_Visualization_OverlayType.fromJson(
    Object? json,
  ) => ExplanationMetadata_InputMetadata_Visualization_OverlayType(
    json as String,
  );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'OverlayType.$value';
}

/// Defines how a feature is encoded. Defaults to IDENTITY.
final class ExplanationMetadata_InputMetadata_Encoding extends ProtoEnum {
  /// Default value. This is the same as IDENTITY.
  static const encodingUnspecified = ExplanationMetadata_InputMetadata_Encoding(
    'ENCODING_UNSPECIFIED',
  );

  /// The tensor represents one feature.
  static const identity = ExplanationMetadata_InputMetadata_Encoding(
    'IDENTITY',
  );

  /// The tensor represents a bag of features where each index maps to
  /// a feature.
  /// `InputMetadata.index_feature_mapping`
  /// must be provided for this encoding. For example:
  /// ```
  /// input = [27, 6.0, 150]
  /// index_feature_mapping = ["age", "height", "weight"]
  /// ```
  static const bagOfFeatures = ExplanationMetadata_InputMetadata_Encoding(
    'BAG_OF_FEATURES',
  );

  /// The tensor represents a bag of features where each index maps to a
  /// feature. Zero values in the tensor indicates feature being
  /// non-existent.
  /// `InputMetadata.index_feature_mapping`
  /// must be provided for this encoding. For example:
  /// ```
  /// input = [2, 0, 5, 0, 1]
  /// index_feature_mapping = ["a", "b", "c", "d", "e"]
  /// ```
  static const bagOfFeaturesSparse = ExplanationMetadata_InputMetadata_Encoding(
    'BAG_OF_FEATURES_SPARSE',
  );

  /// The tensor is a list of binaries representing whether a feature exists
  /// or not (1 indicates existence).
  /// `InputMetadata.index_feature_mapping`
  /// must be provided for this encoding. For example:
  /// ```
  /// input = [1, 0, 1, 0, 1]
  /// index_feature_mapping = ["a", "b", "c", "d", "e"]
  /// ```
  static const indicator = ExplanationMetadata_InputMetadata_Encoding(
    'INDICATOR',
  );

  /// The tensor is encoded into a 1-dimensional array represented by an
  /// encoded tensor.
  /// `InputMetadata.encoded_tensor_name`
  /// must be provided for this encoding. For example:
  /// ```
  /// input = ["This", "is", "a", "test", "."]
  /// encoded = [0.1, 0.2, 0.3, 0.4, 0.5]
  /// ```
  static const combinedEmbedding = ExplanationMetadata_InputMetadata_Encoding(
    'COMBINED_EMBEDDING',
  );

  /// Select this encoding when the input tensor is encoded into a
  /// 2-dimensional array represented by an encoded tensor.
  /// `InputMetadata.encoded_tensor_name`
  /// must be provided for this encoding. The first dimension of the encoded
  /// tensor's shape is the same as the input tensor's shape. For example:
  /// ```
  /// input = ["This", "is", "a", "test", "."]
  /// encoded = [[0.1, 0.2, 0.3, 0.4, 0.5],
  ///            [0.2, 0.1, 0.4, 0.3, 0.5],
  ///            [0.5, 0.1, 0.3, 0.5, 0.4],
  ///            [0.5, 0.3, 0.1, 0.2, 0.4],
  ///            [0.4, 0.3, 0.2, 0.5, 0.1]]
  /// ```
  static const concatEmbedding = ExplanationMetadata_InputMetadata_Encoding(
    'CONCAT_EMBEDDING',
  );

  /// The default value for [ExplanationMetadata_InputMetadata_Encoding].
  static const $default = encodingUnspecified;

  const ExplanationMetadata_InputMetadata_Encoding(super.value);

  factory ExplanationMetadata_InputMetadata_Encoding.fromJson(Object? json) =>
      ExplanationMetadata_InputMetadata_Encoding(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Encoding.$value';
}

/// Metadata of the prediction output to be explained.
final class ExplanationMetadata_OutputMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata.OutputMetadata';

  /// Static mapping between the index and display name.
  ///
  /// Use this if the outputs are a deterministic n-dimensional array, e.g. a
  /// list of scores of all the classes in a pre-defined order for a
  /// multi-classification Model. It's not feasible if the outputs are
  /// non-deterministic, e.g. the Model produces top-k classes or sort the
  /// outputs by their values.
  ///
  /// The shape of the value must be an n-dimensional array of strings. The
  /// number of dimensions must match that of the outputs to be explained.
  /// The
  /// `Attribution.output_display_name`
  /// is populated by locating in the mapping with
  /// `Attribution.output_index`.
  final protobuf.Value? indexDisplayNameMapping;

  /// Specify a field name in the prediction to look for the display name.
  ///
  /// Use this if the prediction contains the display names for the outputs.
  ///
  /// The display names in the prediction must have the same shape of the
  /// outputs, so that it can be located by
  /// `Attribution.output_index`
  /// for a specific output.
  final String? displayNameMappingKey;

  /// Name of the output tensor. Required and is only applicable to Vertex
  /// AI provided images for Tensorflow.
  final String outputTensorName;

  ExplanationMetadata_OutputMetadata({
    this.indexDisplayNameMapping,
    this.displayNameMappingKey,
    this.outputTensorName = '',
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata_OutputMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplanationMetadata_OutputMetadata(
      indexDisplayNameMapping: switch (json['indexDisplayNameMapping']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      displayNameMappingKey: switch (json['displayNameMappingKey']) {
        null => null,
        Object $1 => decodeString($1),
      },
      outputTensorName: switch (json['outputTensorName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (indexDisplayNameMapping != null)
      'indexDisplayNameMapping': indexDisplayNameMapping!.toJson(),
    if (displayNameMappingKey != null)
      'displayNameMappingKey': displayNameMappingKey,
    if (outputTensorName.isNotDefault) 'outputTensorName': outputTensorName,
  };

  @override
  String toString() {
    final contents = [
      if (displayNameMappingKey != null)
        'displayNameMappingKey=$displayNameMappingKey',
      'outputTensorName=$outputTensorName',
    ].join(',');
    return 'OutputMetadata($contents)';
  }
}

/// Extensions are tools for large language models to access external data, run
/// computations, etc.
final class Extension extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Extension';

  /// Identifier. The resource name of the Extension.
  final String name;

  /// Required. The display name of the Extension.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Optional. The description of the Extension.
  final String description;

  /// Output only. Timestamp when this Extension was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Extension was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Required. Manifest of the Extension.
  final ExtensionManifest? manifest;

  /// Output only. Supported operations.
  final List<ExtensionOperation> extensionOperations;

  /// Optional. Runtime config controlling the runtime behavior of this
  /// Extension.
  final RuntimeConfig? runtimeConfig;

  /// Optional. Examples to illustrate the usage of the extension as a tool.
  final List<ToolUseExample> toolUseExamples;

  /// Optional. The PrivateServiceConnect config for the extension.
  /// If specified, the service endpoints associated with the
  /// Extension should be registered with private network access in the provided
  /// Service Directory
  /// (https://cloud.google.com/service-directory/docs/configuring-private-network-access).
  ///
  /// If the service contains more than one endpoint with a network, the service
  /// will arbitrarilty choose one of the endpoints to use for extension
  /// execution.
  final ExtensionPrivateServiceConnectConfig? privateServiceConnectConfig;

  Extension({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.createTime,
    this.updateTime,
    this.etag = '',
    required this.manifest,
    this.extensionOperations = const [],
    this.runtimeConfig,
    this.toolUseExamples = const [],
    this.privateServiceConnectConfig,
  }) : super(fullyQualifiedName);

  factory Extension.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Extension(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      manifest: switch (json['manifest']) {
        null => null,
        Object $1 => ExtensionManifest.fromJson($1),
      },
      extensionOperations: switch (json['extensionOperations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ExtensionOperation.fromJson(i),
        ],
        _ => throw const FormatException('"extensionOperations" is not a list'),
      },
      runtimeConfig: switch (json['runtimeConfig']) {
        null => null,
        Object $1 => RuntimeConfig.fromJson($1),
      },
      toolUseExamples: switch (json['toolUseExamples']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ToolUseExample.fromJson(i)],
        _ => throw const FormatException('"toolUseExamples" is not a list'),
      },
      privateServiceConnectConfig:
          switch (json['privateServiceConnectConfig']) {
            null => null,
            Object $1 => ExtensionPrivateServiceConnectConfig.fromJson($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (manifest != null) 'manifest': manifest!.toJson(),
    if (extensionOperations.isNotDefault)
      'extensionOperations': encodeList(extensionOperations),
    if (runtimeConfig != null) 'runtimeConfig': runtimeConfig!.toJson(),
    if (toolUseExamples.isNotDefault)
      'toolUseExamples': encodeList(toolUseExamples),
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'etag=$etag',
    ].join(',');
    return 'Extension($contents)';
  }
}

/// Manifest spec of an Extension needed for runtime execution.
final class ExtensionManifest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExtensionManifest';

  /// Required. Extension name shown to the LLM.
  /// The name can be up to 128 characters long.
  final String name;

  /// Required. The natural language description shown to the LLM.
  /// It should describe the usage of the extension, and is essential for the LLM
  /// to perform reasoning. e.g., if the extension is a data store, you can let
  /// the LLM know what data it contains.
  final String description;

  /// Required. Immutable. The API specification shown to the LLM.
  final ExtensionManifest_ApiSpec? apiSpec;

  /// Required. Immutable. Type of auth supported by this extension.
  final AuthConfig? authConfig;

  ExtensionManifest({
    required this.name,
    required this.description,
    required this.apiSpec,
    required this.authConfig,
  }) : super(fullyQualifiedName);

  factory ExtensionManifest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExtensionManifest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      apiSpec: switch (json['apiSpec']) {
        null => null,
        Object $1 => ExtensionManifest_ApiSpec.fromJson($1),
      },
      authConfig: switch (json['authConfig']) {
        null => null,
        Object $1 => AuthConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    'description': description,
    if (apiSpec != null) 'apiSpec': apiSpec!.toJson(),
    if (authConfig != null) 'authConfig': authConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'description=$description'].join(',');
    return 'ExtensionManifest($contents)';
  }
}

/// The API specification shown to the LLM.
final class ExtensionManifest_ApiSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExtensionManifest.ApiSpec';

  /// The API spec in Open API standard and YAML format.
  final String? openApiYaml;

  /// Cloud Storage URI pointing to the OpenAPI spec.
  final String? openApiGcsUri;

  ExtensionManifest_ApiSpec({this.openApiYaml, this.openApiGcsUri})
    : super(fullyQualifiedName);

  factory ExtensionManifest_ApiSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExtensionManifest_ApiSpec(
      openApiYaml: switch (json['openApiYaml']) {
        null => null,
        Object $1 => decodeString($1),
      },
      openApiGcsUri: switch (json['openApiGcsUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (openApiYaml != null) 'openApiYaml': openApiYaml,
    if (openApiGcsUri != null) 'openApiGcsUri': openApiGcsUri,
  };

  @override
  String toString() {
    final contents = [
      if (openApiYaml != null) 'openApiYaml=$openApiYaml',
      if (openApiGcsUri != null) 'openApiGcsUri=$openApiGcsUri',
    ].join(',');
    return 'ApiSpec($contents)';
  }
}

/// Operation of an extension.
final class ExtensionOperation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExtensionOperation';

  /// Operation ID that uniquely identifies the operations among the extension.
  /// See: "Operation Object" in https://swagger.io/specification/.
  ///
  /// This field is parsed from the OpenAPI spec. For HTTP extensions, if it does
  /// not exist in the spec, we will generate one from the HTTP method and path.
  final String operationId;

  /// Output only. Structured representation of a function declaration as defined
  /// by the OpenAPI Spec.
  final FunctionDeclaration? functionDeclaration;

  ExtensionOperation({this.operationId = '', this.functionDeclaration})
    : super(fullyQualifiedName);

  factory ExtensionOperation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExtensionOperation(
      operationId: switch (json['operationId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      functionDeclaration: switch (json['functionDeclaration']) {
        null => null,
        Object $1 => FunctionDeclaration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (operationId.isNotDefault) 'operationId': operationId,
    if (functionDeclaration != null)
      'functionDeclaration': functionDeclaration!.toJson(),
  };

  @override
  String toString() {
    final contents = ['operationId=$operationId'].join(',');
    return 'ExtensionOperation($contents)';
  }
}

/// Auth configuration to run the extension.
final class AuthConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig';

  /// Config for API key auth.
  final AuthConfig_ApiKeyConfig? apiKeyConfig;

  /// Config for HTTP Basic auth.
  final AuthConfig_HttpBasicAuthConfig? httpBasicAuthConfig;

  /// Config for Google Service Account auth.
  final AuthConfig_GoogleServiceAccountConfig? googleServiceAccountConfig;

  /// Config for user oauth.
  final AuthConfig_OauthConfig? oauthConfig;

  /// Config for user OIDC auth.
  final AuthConfig_OidcConfig? oidcConfig;

  /// Type of auth scheme.
  final AuthType authType;

  AuthConfig({
    this.apiKeyConfig,
    this.httpBasicAuthConfig,
    this.googleServiceAccountConfig,
    this.oauthConfig,
    this.oidcConfig,
    this.authType = AuthType.$default,
  }) : super(fullyQualifiedName);

  factory AuthConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthConfig(
      apiKeyConfig: switch (json['apiKeyConfig']) {
        null => null,
        Object $1 => AuthConfig_ApiKeyConfig.fromJson($1),
      },
      httpBasicAuthConfig: switch (json['httpBasicAuthConfig']) {
        null => null,
        Object $1 => AuthConfig_HttpBasicAuthConfig.fromJson($1),
      },
      googleServiceAccountConfig: switch (json['googleServiceAccountConfig']) {
        null => null,
        Object $1 => AuthConfig_GoogleServiceAccountConfig.fromJson($1),
      },
      oauthConfig: switch (json['oauthConfig']) {
        null => null,
        Object $1 => AuthConfig_OauthConfig.fromJson($1),
      },
      oidcConfig: switch (json['oidcConfig']) {
        null => null,
        Object $1 => AuthConfig_OidcConfig.fromJson($1),
      },
      authType: switch (json['authType']) {
        null => AuthType.$default,
        Object $1 => AuthType.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!.toJson(),
    if (httpBasicAuthConfig != null)
      'httpBasicAuthConfig': httpBasicAuthConfig!.toJson(),
    if (googleServiceAccountConfig != null)
      'googleServiceAccountConfig': googleServiceAccountConfig!.toJson(),
    if (oauthConfig != null) 'oauthConfig': oauthConfig!.toJson(),
    if (oidcConfig != null) 'oidcConfig': oidcConfig!.toJson(),
    if (authType.isNotDefault) 'authType': authType.toJson(),
  };

  @override
  String toString() {
    final contents = ['authType=$authType'].join(',');
    return 'AuthConfig($contents)';
  }
}

/// Config for authentication with API key.
final class AuthConfig_ApiKeyConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.ApiKeyConfig';

  /// Required. The parameter name of the API key.
  /// E.g. If the API request is "https://example.com/act?api_key=<API KEY>",
  /// "api_key" would be the parameter name.
  final String name;

  /// Required. The name of the SecretManager secret version resource storing
  /// the API key. Format:
  /// `projects/{project}/secrets/{secrete}/versions/{version}`
  ///
  /// - If specified, the `secretmanager.versions.access` permission should be
  /// granted to Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified resource.
  final String apiKeySecret;

  /// Required. The location of the API key.
  final HttpElementLocation httpElementLocation;

  AuthConfig_ApiKeyConfig({
    required this.name,
    required this.apiKeySecret,
    required this.httpElementLocation,
  }) : super(fullyQualifiedName);

  factory AuthConfig_ApiKeyConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthConfig_ApiKeyConfig(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      apiKeySecret: switch (json['apiKeySecret']) {
        null => '',
        Object $1 => decodeString($1),
      },
      httpElementLocation: switch (json['httpElementLocation']) {
        null => HttpElementLocation.$default,
        Object $1 => HttpElementLocation.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    'apiKeySecret': apiKeySecret,
    'httpElementLocation': httpElementLocation.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'apiKeySecret=$apiKeySecret',
      'httpElementLocation=$httpElementLocation',
    ].join(',');
    return 'ApiKeyConfig($contents)';
  }
}

/// Config for HTTP Basic Authentication.
final class AuthConfig_HttpBasicAuthConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.HttpBasicAuthConfig';

  /// Required. The name of the SecretManager secret version resource storing
  /// the base64 encoded credentials. Format:
  /// `projects/{project}/secrets/{secrete}/versions/{version}`
  ///
  /// - If specified, the `secretmanager.versions.access` permission should be
  /// granted to Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified resource.
  final String credentialSecret;

  AuthConfig_HttpBasicAuthConfig({required this.credentialSecret})
    : super(fullyQualifiedName);

  factory AuthConfig_HttpBasicAuthConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthConfig_HttpBasicAuthConfig(
      credentialSecret: switch (json['credentialSecret']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'credentialSecret': credentialSecret};

  @override
  String toString() {
    final contents = ['credentialSecret=$credentialSecret'].join(',');
    return 'HttpBasicAuthConfig($contents)';
  }
}

/// Config for Google Service Account Authentication.
final class AuthConfig_GoogleServiceAccountConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.GoogleServiceAccountConfig';

  /// Optional. The service account that the extension execution service runs
  /// as.
  ///
  /// - If the service account is specified,
  /// the `iam.serviceAccounts.getAccessToken` permission should be granted to
  /// Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified service account.
  ///
  /// - If not specified, the Vertex AI Extension Service Agent
  /// will be used to execute the Extension.
  final String serviceAccount;

  AuthConfig_GoogleServiceAccountConfig({this.serviceAccount = ''})
    : super(fullyQualifiedName);

  factory AuthConfig_GoogleServiceAccountConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthConfig_GoogleServiceAccountConfig(
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
  };

  @override
  String toString() {
    final contents = ['serviceAccount=$serviceAccount'].join(',');
    return 'GoogleServiceAccountConfig($contents)';
  }
}

/// Config for user oauth.
final class AuthConfig_OauthConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.OauthConfig';

  /// Access token for extension endpoint.
  /// Only used to propagate token from
  /// [[ExecuteExtensionRequest.runtime_auth_config]] at request time.
  final String? accessToken;

  /// The service account used to generate access tokens for executing the
  /// Extension.
  ///
  /// - If the service account is specified,
  /// the `iam.serviceAccounts.getAccessToken` permission should be granted
  /// to Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the provided service account.
  final String? serviceAccount;

  AuthConfig_OauthConfig({this.accessToken, this.serviceAccount})
    : super(fullyQualifiedName);

  factory AuthConfig_OauthConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthConfig_OauthConfig(
      accessToken: switch (json['accessToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (accessToken != null) 'accessToken': accessToken,
    if (serviceAccount != null) 'serviceAccount': serviceAccount,
  };

  @override
  String toString() {
    final contents = [
      if (accessToken != null) 'accessToken=$accessToken',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
    ].join(',');
    return 'OauthConfig($contents)';
  }
}

/// Config for user OIDC auth.
final class AuthConfig_OidcConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.OidcConfig';

  /// OpenID Connect formatted ID token for extension endpoint.
  /// Only used to propagate token from
  /// [[ExecuteExtensionRequest.runtime_auth_config]] at request time.
  final String? idToken;

  /// The service account used to generate an OpenID Connect
  /// (OIDC)-compatible JWT token signed by the Google OIDC Provider
  /// (accounts.google.com) for extension endpoint
  /// (https://cloud.google.com/iam/docs/create-short-lived-credentials-direct#sa-credentials-oidc).
  ///
  /// - The audience for the token will be set to the URL in the server url
  /// defined in the OpenApi spec.
  ///
  /// - If the service account is provided, the service account should grant
  /// `iam.serviceAccounts.getOpenIdToken` permission to Vertex AI Extension
  /// Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  final String? serviceAccount;

  AuthConfig_OidcConfig({this.idToken, this.serviceAccount})
    : super(fullyQualifiedName);

  factory AuthConfig_OidcConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthConfig_OidcConfig(
      idToken: switch (json['idToken']) {
        null => null,
        Object $1 => decodeString($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (idToken != null) 'idToken': idToken,
    if (serviceAccount != null) 'serviceAccount': serviceAccount,
  };

  @override
  String toString() {
    final contents = [
      if (idToken != null) 'idToken=$idToken',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
    ].join(',');
    return 'OidcConfig($contents)';
  }
}

/// Runtime configuration to run the extension.
final class RuntimeConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RuntimeConfig';

  /// Code execution runtime configurations for code interpreter extension.
  final RuntimeConfig_CodeInterpreterRuntimeConfig?
  codeInterpreterRuntimeConfig;

  /// Runtime configuration for Vertex AI Search extension.
  final RuntimeConfig_VertexAisearchRuntimeConfig? vertexAiSearchRuntimeConfig;

  /// Optional. Default parameters that will be set for all the execution of this
  /// extension. If specified, the parameter values can be overridden by values
  /// in [[ExecuteExtensionRequest.operation_params]] at request time.
  ///
  /// The struct should be in a form of map with param name as the key and actual
  /// param value as the value.
  /// E.g. If this operation requires a param "name" to be set to "abc". you can
  /// set this to something like {"name": "abc"}.
  final protobuf.Struct? defaultParams;

  RuntimeConfig({
    this.codeInterpreterRuntimeConfig,
    this.vertexAiSearchRuntimeConfig,
    this.defaultParams,
  }) : super(fullyQualifiedName);

  factory RuntimeConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RuntimeConfig(
      codeInterpreterRuntimeConfig:
          switch (json['codeInterpreterRuntimeConfig']) {
            null => null,
            Object $1 => RuntimeConfig_CodeInterpreterRuntimeConfig.fromJson(
              $1,
            ),
          },
      vertexAiSearchRuntimeConfig:
          switch (json['vertexAiSearchRuntimeConfig']) {
            null => null,
            Object $1 => RuntimeConfig_VertexAisearchRuntimeConfig.fromJson($1),
          },
      defaultParams: switch (json['defaultParams']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (codeInterpreterRuntimeConfig != null)
      'codeInterpreterRuntimeConfig': codeInterpreterRuntimeConfig!.toJson(),
    if (vertexAiSearchRuntimeConfig != null)
      'vertexAiSearchRuntimeConfig': vertexAiSearchRuntimeConfig!.toJson(),
    if (defaultParams != null) 'defaultParams': defaultParams!.toJson(),
  };

  @override
  String toString() => 'RuntimeConfig()';
}

final class RuntimeConfig_CodeInterpreterRuntimeConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RuntimeConfig.CodeInterpreterRuntimeConfig';

  /// Optional. The Cloud Storage bucket for file input of this Extension.
  /// If specified, support input from the Cloud Storage bucket.
  /// Vertex Extension Custom Code Service Agent should be granted
  /// file reader to this bucket.
  /// If not specified, the extension will only accept file contents from
  /// request body and reject Cloud Storage file inputs.
  final String fileInputGcsBucket;

  /// Optional. The Cloud Storage bucket for file output of this Extension.
  /// If specified, write all output files to the Cloud Storage bucket.
  /// Vertex Extension Custom Code Service Agent should be granted
  /// file writer to this bucket.
  /// If not specified, the file content will be output in response body.
  final String fileOutputGcsBucket;

  RuntimeConfig_CodeInterpreterRuntimeConfig({
    this.fileInputGcsBucket = '',
    this.fileOutputGcsBucket = '',
  }) : super(fullyQualifiedName);

  factory RuntimeConfig_CodeInterpreterRuntimeConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RuntimeConfig_CodeInterpreterRuntimeConfig(
      fileInputGcsBucket: switch (json['fileInputGcsBucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      fileOutputGcsBucket: switch (json['fileOutputGcsBucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (fileInputGcsBucket.isNotDefault)
      'fileInputGcsBucket': fileInputGcsBucket,
    if (fileOutputGcsBucket.isNotDefault)
      'fileOutputGcsBucket': fileOutputGcsBucket,
  };

  @override
  String toString() {
    final contents = [
      'fileInputGcsBucket=$fileInputGcsBucket',
      'fileOutputGcsBucket=$fileOutputGcsBucket',
    ].join(',');
    return 'CodeInterpreterRuntimeConfig($contents)';
  }
}

final class RuntimeConfig_VertexAisearchRuntimeConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RuntimeConfig.VertexAISearchRuntimeConfig';

  /// Optional. Vertex AI Search serving config name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config}`
  final String servingConfigName;

  /// Optional. Vertex AI Search engine ID. This is used to construct the
  /// search request. By setting this engine_id, API will construct the serving
  /// config using the default value to call search API for the user. The
  /// engine_id and serving_config_name cannot both be empty at the same time.
  final String engineId;

  RuntimeConfig_VertexAisearchRuntimeConfig({
    this.servingConfigName = '',
    this.engineId = '',
  }) : super(fullyQualifiedName);

  factory RuntimeConfig_VertexAisearchRuntimeConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RuntimeConfig_VertexAisearchRuntimeConfig(
      servingConfigName: switch (json['servingConfigName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      engineId: switch (json['engineId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (servingConfigName.isNotDefault) 'servingConfigName': servingConfigName,
    if (engineId.isNotDefault) 'engineId': engineId,
  };

  @override
  String toString() {
    final contents = [
      'servingConfigName=$servingConfigName',
      'engineId=$engineId',
    ].join(',');
    return 'VertexAISearchRuntimeConfig($contents)';
  }
}

/// PrivateExtensionConfig configuration for the extension.
final class ExtensionPrivateServiceConnectConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExtensionPrivateServiceConnectConfig';

  /// Required. The Service Directory resource name in which the service
  /// endpoints associated to the extension are registered. Format:
  /// `projects/{project_id}/locations/{location_id}/namespaces/{namespace_id}/services/{service_id}`
  ///
  /// - The Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// should be granted `servicedirectory.viewer` and
  /// `servicedirectory.pscAuthorizedService` roles on the resource.
  final String serviceDirectory;

  ExtensionPrivateServiceConnectConfig({required this.serviceDirectory})
    : super(fullyQualifiedName);

  factory ExtensionPrivateServiceConnectConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExtensionPrivateServiceConnectConfig(
      serviceDirectory: switch (json['serviceDirectory']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'serviceDirectory': serviceDirectory};

  @override
  String toString() {
    final contents = ['serviceDirectory=$serviceDirectory'].join(',');
    return 'ExtensionPrivateServiceConnectConfig($contents)';
  }
}

/// Request message for
/// `ExtensionExecutionService.ExecuteExtension`.
final class ExecuteExtensionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExecuteExtensionRequest';

  /// Required. Name (identifier) of the extension;
  /// Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  final String name;

  /// Required. The desired ID of the operation to be executed in this extension
  ///  as defined in
  ///  `ExtensionOperation.operation_id`.
  final String operationId;

  /// Optional. Request parameters that will be used for executing this
  /// operation.
  ///
  /// The struct should be in a form of map with param name as the key and actual
  /// param value as the value.
  /// E.g. If this operation requires a param "name" to be set to "abc". you can
  /// set this to something like {"name": "abc"}.
  final protobuf.Struct? operationParams;

  /// Optional. Auth config provided at runtime to override the default value in
  /// `Extension.manifest.auth_config`.
  /// The AuthConfig.auth_type should match the value in
  /// `Extension.manifest.auth_config`.
  final AuthConfig? runtimeAuthConfig;

  ExecuteExtensionRequest({
    required this.name,
    required this.operationId,
    this.operationParams,
    this.runtimeAuthConfig,
  }) : super(fullyQualifiedName);

  factory ExecuteExtensionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExecuteExtensionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      operationId: switch (json['operationId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      operationParams: switch (json['operationParams']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      runtimeAuthConfig: switch (json['runtimeAuthConfig']) {
        null => null,
        Object $1 => AuthConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    'operationId': operationId,
    if (operationParams != null) 'operationParams': operationParams!.toJson(),
    if (runtimeAuthConfig != null)
      'runtimeAuthConfig': runtimeAuthConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'operationId=$operationId'].join(',');
    return 'ExecuteExtensionRequest($contents)';
  }
}

/// Response message for
/// `ExtensionExecutionService.ExecuteExtension`.
final class ExecuteExtensionResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExecuteExtensionResponse';

  /// Response content from the extension. The content should be conformant to
  /// the response.content schema in the extension's manifest/OpenAPI spec.
  final String content;

  ExecuteExtensionResponse({this.content = ''}) : super(fullyQualifiedName);

  factory ExecuteExtensionResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExecuteExtensionResponse(
      content: switch (json['content']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (content.isNotDefault) 'content': content};

  @override
  String toString() {
    final contents = ['content=$content'].join(',');
    return 'ExecuteExtensionResponse($contents)';
  }
}

/// Request message for
/// `ExtensionExecutionService.QueryExtension`.
final class QueryExtensionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryExtensionRequest';

  /// Required. Name (identifier) of the extension;
  /// Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  final String name;

  /// Required. The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn queries,
  /// this is a repeated field that contains conversation history + latest
  /// request.
  final List<Content> contents;

  QueryExtensionRequest({required this.name, required this.contents})
    : super(fullyQualifiedName);

  factory QueryExtensionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryExtensionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'name': name, 'contents': encodeList(contents)};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'QueryExtensionRequest($contents)';
  }
}

/// Response message for
/// `ExtensionExecutionService.QueryExtension`.
final class QueryExtensionResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryExtensionResponse';

  /// Steps of extension or LLM interaction, can contain function call,
  /// function response, or text response. The last step contains the final
  /// response to the query.
  final List<Content> steps;

  /// Failure message if any.
  final String failureMessage;

  QueryExtensionResponse({this.steps = const [], this.failureMessage = ''})
    : super(fullyQualifiedName);

  factory QueryExtensionResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryExtensionResponse(
      steps: switch (json['steps']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"steps" is not a list'),
      },
      failureMessage: switch (json['failureMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (steps.isNotDefault) 'steps': encodeList(steps),
    if (failureMessage.isNotDefault) 'failureMessage': failureMessage,
  };

  @override
  String toString() {
    final contents = ['failureMessage=$failureMessage'].join(',');
    return 'QueryExtensionResponse($contents)';
  }
}

/// Request message for
/// `ExtensionRegistryService.ImportExtension`.
final class ImportExtensionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportExtensionRequest';

  /// Required. The resource name of the Location to import the Extension in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Extension to import.
  final Extension? extension;

  ImportExtensionRequest({required this.parent, required this.extension})
    : super(fullyQualifiedName);

  factory ImportExtensionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportExtensionRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      extension: switch (json['extension']) {
        null => null,
        Object $1 => Extension.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (extension != null) 'extension': extension!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ImportExtensionRequest($contents)';
  }
}

/// Details of
/// `ExtensionRegistryService.ImportExtension`
/// operation.
final class ImportExtensionOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportExtensionOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  ImportExtensionOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ImportExtensionOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportExtensionOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'ImportExtensionOperationMetadata()';
}

/// Request message for
/// `ExtensionRegistryService.GetExtension`.
final class GetExtensionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetExtensionRequest';

  /// Required. The name of the Extension resource.
  /// Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  final String name;

  GetExtensionRequest({required this.name}) : super(fullyQualifiedName);

  factory GetExtensionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetExtensionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetExtensionRequest($contents)';
  }
}

/// Request message for
/// `ExtensionRegistryService.UpdateExtension`.
final class UpdateExtensionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExtensionRequest';

  /// Required. The Extension which replaces the resource on the server.
  final Extension? extension;

  /// Required. Mask specifying which fields to update.
  /// Supported fields:
  ///
  ///    * `display_name`
  ///    * `description`
  ///    * `runtime_config`
  ///    * `tool_use_examples`
  ///    * `manifest.description`
  final protobuf.FieldMask? updateMask;

  UpdateExtensionRequest({required this.extension, required this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateExtensionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateExtensionRequest(
      extension: switch (json['extension']) {
        null => null,
        Object $1 => Extension.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (extension != null) 'extension': extension!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateExtensionRequest()';
}

/// Request message for
/// `ExtensionRegistryService.ListExtensions`.
final class ListExtensionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExtensionsRequest';

  /// Required. The resource name of the Location to list the Extensions from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list filter.
  /// Supported fields:
  ///    * `display_name`
  ///    * `create_time`
  ///    * `update_time`
  ///
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  final String pageToken;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `display_name, create_time desc`.
  final String orderBy;

  ListExtensionsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListExtensionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListExtensionsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListExtensionsRequest($contents)';
  }
}

/// Response message for
/// `ExtensionRegistryService.ListExtensions`
final class ListExtensionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExtensionsResponse';

  /// List of Extension in the requested page.
  final List<Extension> extensions;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListExtensionsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListExtensionsResponse({this.extensions = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListExtensionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListExtensionsResponse(
      extensions: switch (json['extensions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Extension.fromJson(i)],
        _ => throw const FormatException('"extensions" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (extensions.isNotDefault) 'extensions': encodeList(extensions),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListExtensionsResponse($contents)';
  }
}

/// Request message for
/// `ExtensionRegistryService.DeleteExtension`.
final class DeleteExtensionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteExtensionRequest';

  /// Required. The name of the Extension resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  final String name;

  DeleteExtensionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteExtensionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteExtensionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteExtensionRequest($contents)';
  }
}

/// Feature Metadata information.
/// For example, color is a feature that describes an apple.
final class Feature extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Feature';

  /// Immutable. Name of the Feature.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  ///
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and a-z,
  /// underscore(_), and ASCII digits 0-9 starting with a letter. The value will
  /// be unique given an entity type.
  final String name;

  /// Description of the Feature.
  final String description;

  /// Immutable. Only applicable for Vertex AI Feature Store (Legacy).
  /// Type of Feature value.
  final Feature_ValueType valueType;

  /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
  /// Timestamp when this EntityType was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
  /// Timestamp when this EntityType was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The labels with user-defined metadata to organize your Features.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one Feature (System
  /// labels are excluded)."
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> labels;

  /// Used to perform a consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// Optional. Only applicable for Vertex AI Feature Store (Legacy).
  /// Deprecated: The custom monitoring configuration for this Feature, if not
  /// set, use the monitoring_config defined for the EntityType this Feature
  /// belongs to.
  /// Only Features with type
  /// (`Feature.ValueType`)
  /// BOOL, STRING, DOUBLE or INT64 can enable monitoring.
  ///
  /// If this is populated with
  /// `FeaturestoreMonitoringConfig.disabled` = true, snapshot analysis
  /// monitoring is disabled; if
  /// `FeaturestoreMonitoringConfig.monitoring_interval` specified, snapshot
  /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring
  /// config is same as the EntityType's this Feature belongs to.
  final FeaturestoreMonitoringConfig? monitoringConfig;

  /// Optional. Only applicable for Vertex AI Feature Store (Legacy).
  /// If not set, use the monitoring_config defined for the EntityType this
  /// Feature belongs to.
  /// Only Features with type
  /// (`Feature.ValueType`)
  /// BOOL, STRING, DOUBLE or INT64 can enable monitoring.
  ///
  /// If set to true, all types of data monitoring are disabled despite the
  /// config on EntityType.
  final bool disableMonitoring;

  /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
  /// A list of historical
  /// `SnapshotAnalysis`
  /// stats requested by user, sorted by
  /// `FeatureStatsAnomaly.start_time`
  /// descending.
  final List<FeatureStatsAnomaly> monitoringStats;

  /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
  /// The list of historical stats and anomalies with specified objectives.
  final List<Feature_MonitoringStatsAnomaly> monitoringStatsAnomalies;

  /// Output only. Only applicable for Vertex AI Feature Store.
  /// The list of historical stats and anomalies.
  final List<FeatureStatsAndAnomaly> featureStatsAndAnomaly;

  /// Only applicable for Vertex AI Feature Store.
  /// The name of the BigQuery Table/View column hosting data for this version.
  /// If no value is provided, will use feature_id.
  final String versionColumnName;

  /// Entity responsible for maintaining this feature. Can be comma separated
  /// list of email addresses or URIs.
  final String pointOfContact;

  Feature({
    this.name = '',
    this.description = '',
    this.valueType = Feature_ValueType.$default,
    this.createTime,
    this.updateTime,
    this.labels = const {},
    this.etag = '',
    this.monitoringConfig,
    this.disableMonitoring = false,
    this.monitoringStats = const [],
    this.monitoringStatsAnomalies = const [],
    this.featureStatsAndAnomaly = const [],
    this.versionColumnName = '',
    this.pointOfContact = '',
  }) : super(fullyQualifiedName);

  factory Feature.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Feature(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      valueType: switch (json['valueType']) {
        null => Feature_ValueType.$default,
        Object $1 => Feature_ValueType.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      monitoringConfig: switch (json['monitoringConfig']) {
        null => null,
        Object $1 => FeaturestoreMonitoringConfig.fromJson($1),
      },
      disableMonitoring: switch (json['disableMonitoring']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      monitoringStats: switch (json['monitoringStats']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FeatureStatsAnomaly.fromJson(i),
        ],
        _ => throw const FormatException('"monitoringStats" is not a list'),
      },
      monitoringStatsAnomalies: switch (json['monitoringStatsAnomalies']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Feature_MonitoringStatsAnomaly.fromJson(i),
        ],
        _ => throw const FormatException(
          '"monitoringStatsAnomalies" is not a list',
        ),
      },
      featureStatsAndAnomaly: switch (json['featureStatsAndAnomaly']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FeatureStatsAndAnomaly.fromJson(i),
        ],
        _ => throw const FormatException(
          '"featureStatsAndAnomaly" is not a list',
        ),
      },
      versionColumnName: switch (json['versionColumnName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pointOfContact: switch (json['pointOfContact']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (description.isNotDefault) 'description': description,
    if (valueType.isNotDefault) 'valueType': valueType.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (etag.isNotDefault) 'etag': etag,
    if (monitoringConfig != null)
      'monitoringConfig': monitoringConfig!.toJson(),
    if (disableMonitoring.isNotDefault) 'disableMonitoring': disableMonitoring,
    if (monitoringStats.isNotDefault)
      'monitoringStats': encodeList(monitoringStats),
    if (monitoringStatsAnomalies.isNotDefault)
      'monitoringStatsAnomalies': encodeList(monitoringStatsAnomalies),
    if (featureStatsAndAnomaly.isNotDefault)
      'featureStatsAndAnomaly': encodeList(featureStatsAndAnomaly),
    if (versionColumnName.isNotDefault) 'versionColumnName': versionColumnName,
    if (pointOfContact.isNotDefault) 'pointOfContact': pointOfContact,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'description=$description',
      'valueType=$valueType',
      'etag=$etag',
      'disableMonitoring=$disableMonitoring',
      'versionColumnName=$versionColumnName',
      'pointOfContact=$pointOfContact',
    ].join(',');
    return 'Feature($contents)';
  }
}

/// A list of historical
/// `SnapshotAnalysis`
/// or
/// `ImportFeaturesAnalysis`
/// stats requested by user, sorted by
/// `FeatureStatsAnomaly.start_time`
/// descending.
final class Feature_MonitoringStatsAnomaly extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Feature.MonitoringStatsAnomaly';

  /// Output only. The objective for each stats.
  final Feature_MonitoringStatsAnomaly_Objective objective;

  /// Output only. The stats and anomalies generated at specific timestamp.
  final FeatureStatsAnomaly? featureStatsAnomaly;

  Feature_MonitoringStatsAnomaly({
    this.objective = Feature_MonitoringStatsAnomaly_Objective.$default,
    this.featureStatsAnomaly,
  }) : super(fullyQualifiedName);

  factory Feature_MonitoringStatsAnomaly.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Feature_MonitoringStatsAnomaly(
      objective: switch (json['objective']) {
        null => Feature_MonitoringStatsAnomaly_Objective.$default,
        Object $1 => Feature_MonitoringStatsAnomaly_Objective.fromJson($1),
      },
      featureStatsAnomaly: switch (json['featureStatsAnomaly']) {
        null => null,
        Object $1 => FeatureStatsAnomaly.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (objective.isNotDefault) 'objective': objective.toJson(),
    if (featureStatsAnomaly != null)
      'featureStatsAnomaly': featureStatsAnomaly!.toJson(),
  };

  @override
  String toString() {
    final contents = ['objective=$objective'].join(',');
    return 'MonitoringStatsAnomaly($contents)';
  }
}

/// If the objective in the request is both
/// Import Feature Analysis and Snapshot Analysis, this objective could be
/// one of them. Otherwise, this objective should be the same as the
/// objective in the request.
final class Feature_MonitoringStatsAnomaly_Objective extends ProtoEnum {
  /// If it's OBJECTIVE_UNSPECIFIED, monitoring_stats will be empty.
  static const objectiveUnspecified = Feature_MonitoringStatsAnomaly_Objective(
    'OBJECTIVE_UNSPECIFIED',
  );

  /// Stats are generated by Import Feature Analysis.
  static const importFeatureAnalysis = Feature_MonitoringStatsAnomaly_Objective(
    'IMPORT_FEATURE_ANALYSIS',
  );

  /// Stats are generated by Snapshot Analysis.
  static const snapshotAnalysis = Feature_MonitoringStatsAnomaly_Objective(
    'SNAPSHOT_ANALYSIS',
  );

  /// The default value for [Feature_MonitoringStatsAnomaly_Objective].
  static const $default = objectiveUnspecified;

  const Feature_MonitoringStatsAnomaly_Objective(super.value);

  factory Feature_MonitoringStatsAnomaly_Objective.fromJson(Object? json) =>
      Feature_MonitoringStatsAnomaly_Objective(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Objective.$value';
}

/// Only applicable for Vertex AI Legacy Feature Store.
/// An enum representing the value type of a feature.
final class Feature_ValueType extends ProtoEnum {
  /// The value type is unspecified.
  static const valueTypeUnspecified = Feature_ValueType(
    'VALUE_TYPE_UNSPECIFIED',
  );

  /// Used for Feature that is a boolean.
  static const bool$ = Feature_ValueType('BOOL');

  /// Used for Feature that is a list of boolean.
  static const boolArray = Feature_ValueType('BOOL_ARRAY');

  /// Used for Feature that is double.
  static const double$ = Feature_ValueType('DOUBLE');

  /// Used for Feature that is a list of double.
  static const doubleArray = Feature_ValueType('DOUBLE_ARRAY');

  /// Used for Feature that is INT64.
  static const int64 = Feature_ValueType('INT64');

  /// Used for Feature that is a list of INT64.
  static const int64Array = Feature_ValueType('INT64_ARRAY');

  /// Used for Feature that is string.
  static const string = Feature_ValueType('STRING');

  /// Used for Feature that is a list of String.
  static const stringArray = Feature_ValueType('STRING_ARRAY');

  /// Used for Feature that is bytes.
  static const bytes = Feature_ValueType('BYTES');

  /// Used for Feature that is struct.
  static const struct = Feature_ValueType('STRUCT');

  /// The default value for [Feature_ValueType].
  static const $default = valueTypeUnspecified;

  const Feature_ValueType(super.value);

  factory Feature_ValueType.fromJson(Object? json) =>
      Feature_ValueType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ValueType.$value';
}

/// Vertex AI Feature Group.
final class FeatureGroup extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureGroup';

  /// Indicates that features for this group come from BigQuery Table/View.
  /// By default treats the source as a sparse time series source. The BigQuery
  /// source table or view must have at least one entity ID column and a column
  /// named `feature_timestamp`.
  final FeatureGroup_BigQuery? bigQuery;

  /// Identifier. Name of the FeatureGroup. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  final String name;

  /// Output only. Timestamp when this FeatureGroup was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this FeatureGroup was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureGroup.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureGroup(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String> labels;

  /// Optional. Description of the FeatureGroup.
  final String description;

  /// Optional. Service agent type used during jobs under a FeatureGroup. By
  /// default, the Vertex AI Service Agent is used. When using an IAM Policy to
  /// isolate this FeatureGroup within a project, a separate service account
  /// should be provisioned by setting this field to
  /// `SERVICE_AGENT_TYPE_FEATURE_GROUP`. This will generate a separate service
  /// account to access the BigQuery source table.
  final FeatureGroup_ServiceAgentType serviceAgentType;

  /// Output only. A Service Account unique to this FeatureGroup. The role
  /// bigquery.dataViewer should be granted to this service account to allow
  /// Vertex AI Feature Store to access source data while running jobs under this
  /// FeatureGroup.
  final String serviceAccountEmail;

  FeatureGroup({
    this.bigQuery,
    this.name = '',
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.labels = const {},
    this.description = '',
    this.serviceAgentType = FeatureGroup_ServiceAgentType.$default,
    this.serviceAccountEmail = '',
  }) : super(fullyQualifiedName);

  factory FeatureGroup.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureGroup(
      bigQuery: switch (json['bigQuery']) {
        null => null,
        Object $1 => FeatureGroup_BigQuery.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAgentType: switch (json['serviceAgentType']) {
        null => FeatureGroup_ServiceAgentType.$default,
        Object $1 => FeatureGroup_ServiceAgentType.fromJson($1),
      },
      serviceAccountEmail: switch (json['serviceAccountEmail']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bigQuery != null) 'bigQuery': bigQuery!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (description.isNotDefault) 'description': description,
    if (serviceAgentType.isNotDefault)
      'serviceAgentType': serviceAgentType.toJson(),
    if (serviceAccountEmail.isNotDefault)
      'serviceAccountEmail': serviceAccountEmail,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'etag=$etag',
      'description=$description',
      'serviceAgentType=$serviceAgentType',
      'serviceAccountEmail=$serviceAccountEmail',
    ].join(',');
    return 'FeatureGroup($contents)';
  }
}

/// Input source type for BigQuery Tables and Views.
final class FeatureGroup_BigQuery extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureGroup.BigQuery';

  /// Required. Immutable. The BigQuery source URI that points to either a
  /// BigQuery Table or View.
  final BigQuerySource? bigQuerySource;

  /// Optional. Columns to construct entity_id / row keys.
  /// If not provided defaults to `entity_id`.
  final List<String> entityIdColumns;

  /// Optional. Set if the data source is not a time-series.
  final bool staticDataSource;

  /// Optional. If the source is a time-series source, this can be set to
  /// control how downstream sources (ex:
  /// `FeatureView` ) will treat
  /// time-series sources. If not set, will treat the source as a time-series
  /// source with `feature_timestamp` as timestamp column and no scan boundary.
  final FeatureGroup_BigQuery_TimeSeries? timeSeries;

  /// Optional. If set, all feature values will be fetched
  /// from a single row per unique entityId including nulls.
  /// If not set, will collapse all rows for each unique entityId into a singe
  /// row with any non-null values if present, if no non-null values are
  /// present will sync null.
  /// ex: If source has schema
  /// `(entity_id, feature_timestamp, f0, f1)` and the following rows:
  /// `(e1, 2020-01-01T10:00:00.123Z, 10, 15)`
  /// `(e1, 2020-02-01T10:00:00.123Z, 20, null)`
  /// If dense is set, `(e1, 20, null)` is synced to online stores. If dense is
  /// not set, `(e1, 20, 15)` is synced to online stores.
  final bool dense;

  FeatureGroup_BigQuery({
    required this.bigQuerySource,
    this.entityIdColumns = const [],
    this.staticDataSource = false,
    this.timeSeries,
    this.dense = false,
  }) : super(fullyQualifiedName);

  factory FeatureGroup_BigQuery.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureGroup_BigQuery(
      bigQuerySource: switch (json['bigQuerySource']) {
        null => null,
        Object $1 => BigQuerySource.fromJson($1),
      },
      entityIdColumns: switch (json['entityIdColumns']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"entityIdColumns" is not a list'),
      },
      staticDataSource: switch (json['staticDataSource']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      timeSeries: switch (json['timeSeries']) {
        null => null,
        Object $1 => FeatureGroup_BigQuery_TimeSeries.fromJson($1),
      },
      dense: switch (json['dense']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bigQuerySource != null) 'bigQuerySource': bigQuerySource!.toJson(),
    if (entityIdColumns.isNotDefault) 'entityIdColumns': entityIdColumns,
    if (staticDataSource.isNotDefault) 'staticDataSource': staticDataSource,
    if (timeSeries != null) 'timeSeries': timeSeries!.toJson(),
    if (dense.isNotDefault) 'dense': dense,
  };

  @override
  String toString() {
    final contents = [
      'staticDataSource=$staticDataSource',
      'dense=$dense',
    ].join(',');
    return 'BigQuery($contents)';
  }
}

final class FeatureGroup_BigQuery_TimeSeries extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureGroup.BigQuery.TimeSeries';

  /// Optional. Column hosting timestamp values for a time-series source.
  /// Will be used to determine the latest `feature_values` for each entity.
  /// Optional. If not provided, column named `feature_timestamp` of
  /// type `TIMESTAMP` will be used.
  final String timestampColumn;

  FeatureGroup_BigQuery_TimeSeries({this.timestampColumn = ''})
    : super(fullyQualifiedName);

  factory FeatureGroup_BigQuery_TimeSeries.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureGroup_BigQuery_TimeSeries(
      timestampColumn: switch (json['timestampColumn']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (timestampColumn.isNotDefault) 'timestampColumn': timestampColumn,
  };

  @override
  String toString() {
    final contents = ['timestampColumn=$timestampColumn'].join(',');
    return 'TimeSeries($contents)';
  }
}

/// Service agent type used during jobs under a FeatureGroup.
final class FeatureGroup_ServiceAgentType extends ProtoEnum {
  /// By default, the project-level Vertex AI Service Agent is enabled.
  static const serviceAgentTypeUnspecified = FeatureGroup_ServiceAgentType(
    'SERVICE_AGENT_TYPE_UNSPECIFIED',
  );

  /// Specifies the project-level Vertex AI Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  static const serviceAgentTypeProject = FeatureGroup_ServiceAgentType(
    'SERVICE_AGENT_TYPE_PROJECT',
  );

  /// Enable a FeatureGroup service account to be created by Vertex AI and
  /// output in the field `service_account_email`. This service account will
  /// be used to read from the source BigQuery table during jobs under a
  /// FeatureGroup.
  static const serviceAgentTypeFeatureGroup = FeatureGroup_ServiceAgentType(
    'SERVICE_AGENT_TYPE_FEATURE_GROUP',
  );

  /// The default value for [FeatureGroup_ServiceAgentType].
  static const $default = serviceAgentTypeUnspecified;

  const FeatureGroup_ServiceAgentType(super.value);

  factory FeatureGroup_ServiceAgentType.fromJson(Object? json) =>
      FeatureGroup_ServiceAgentType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ServiceAgentType.$value';
}

/// Vertex AI Feature Monitor.
final class FeatureMonitor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureMonitor';

  /// Identifier. Name of the FeatureMonitor. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}/featureMonitors/{featureMonitor}`
  final String name;

  /// Output only. Timestamp when this FeatureMonitor was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this FeatureMonitor was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureMonitor.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureMonitor(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String> labels;

  /// Optional. Description of the FeatureMonitor.
  final String description;

  /// Required. Schedule config for the FeatureMonitor.
  final ScheduleConfig? scheduleConfig;

  /// Required. Feature selection config for the FeatureMonitor.
  final FeatureSelectionConfig? featureSelectionConfig;

  FeatureMonitor({
    this.name = '',
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.labels = const {},
    this.description = '',
    required this.scheduleConfig,
    required this.featureSelectionConfig,
  }) : super(fullyQualifiedName);

  factory FeatureMonitor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureMonitor(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      scheduleConfig: switch (json['scheduleConfig']) {
        null => null,
        Object $1 => ScheduleConfig.fromJson($1),
      },
      featureSelectionConfig: switch (json['featureSelectionConfig']) {
        null => null,
        Object $1 => FeatureSelectionConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (description.isNotDefault) 'description': description,
    if (scheduleConfig != null) 'scheduleConfig': scheduleConfig!.toJson(),
    if (featureSelectionConfig != null)
      'featureSelectionConfig': featureSelectionConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'etag=$etag',
      'description=$description',
    ].join(',');
    return 'FeatureMonitor($contents)';
  }
}

/// Schedule configuration for the FeatureMonitor.
final class ScheduleConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ScheduleConfig';

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs. To explicitly set a timezone to the cron tab, apply a prefix in
  /// the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
  /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
  /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
  /// "TZ=America/New_York 1 * * * *".
  final String cron;

  ScheduleConfig({this.cron = ''}) : super(fullyQualifiedName);

  factory ScheduleConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ScheduleConfig(
      cron: switch (json['cron']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (cron.isNotDefault) 'cron': cron};

  @override
  String toString() {
    final contents = ['cron=$cron'].join(',');
    return 'ScheduleConfig($contents)';
  }
}

/// Feature selection configuration for the FeatureMonitor.
final class FeatureSelectionConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureSelectionConfig';

  /// Optional. A list of features to be monitored and each feature's drift
  /// threshold.
  final List<FeatureSelectionConfig_FeatureConfig> featureConfigs;

  FeatureSelectionConfig({this.featureConfigs = const []})
    : super(fullyQualifiedName);

  factory FeatureSelectionConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureSelectionConfig(
      featureConfigs: switch (json['featureConfigs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FeatureSelectionConfig_FeatureConfig.fromJson(i),
        ],
        _ => throw const FormatException('"featureConfigs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureConfigs.isNotDefault)
      'featureConfigs': encodeList(featureConfigs),
  };

  @override
  String toString() => 'FeatureSelectionConfig()';
}

/// Feature configuration.
final class FeatureSelectionConfig_FeatureConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureSelectionConfig.FeatureConfig';

  /// Required. The ID of the feature resource. Final component of the
  /// Feature's resource name.
  final String featureId;

  /// Optional. Drift threshold. If calculated difference with baseline data
  /// larger than threshold, it will be considered as the feature has drift. If
  /// not present, the threshold will be default to 0.3.
  final double driftThreshold;

  FeatureSelectionConfig_FeatureConfig({
    required this.featureId,
    this.driftThreshold = 0,
  }) : super(fullyQualifiedName);

  factory FeatureSelectionConfig_FeatureConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureSelectionConfig_FeatureConfig(
      featureId: switch (json['featureId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      driftThreshold: switch (json['driftThreshold']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    'featureId': featureId,
    if (driftThreshold.isNotDefault)
      'driftThreshold': encodeDouble(driftThreshold),
  };

  @override
  String toString() {
    final contents = [
      'featureId=$featureId',
      'driftThreshold=$driftThreshold',
    ].join(',');
    return 'FeatureConfig($contents)';
  }
}

/// Stats and Anomaly generated by FeatureMonitorJobs. Anomaly only includes
/// Drift.
final class FeatureStatsAndAnomaly extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureStatsAndAnomaly';

  /// Feature Id.
  final String featureId;

  /// Feature stats. e.g. histogram buckets.
  /// In the format of tensorflow.metadata.v0.DatasetFeatureStatistics.
  final protobuf.Value? featureStats;

  /// Deviation from the current stats to baseline stats.
  ///   1. For categorical feature, the distribution distance is calculated by
  ///      L-inifinity norm.
  ///   2. For numerical feature, the distribution distance is calculated by
  ///      JensenShannon divergence.
  final double distributionDeviation;

  /// This is the threshold used when detecting drifts, which is set in
  /// FeatureMonitor.FeatureSelectionConfig.FeatureConfig.drift_threshold
  final double driftDetectionThreshold;

  /// If set to true, indicates current stats is detected as and comparing
  /// with baseline stats.
  final bool driftDetected;

  /// The timestamp we take snapshot for feature values to generate stats.
  final protobuf.Timestamp? statsTime;

  /// The ID of the FeatureMonitorJob that generated this FeatureStatsAndAnomaly.
  final int featureMonitorJobId;

  /// The ID of the FeatureMonitor that this FeatureStatsAndAnomaly generated
  /// according to.
  final String featureMonitorId;

  FeatureStatsAndAnomaly({
    this.featureId = '',
    this.featureStats,
    this.distributionDeviation = 0,
    this.driftDetectionThreshold = 0,
    this.driftDetected = false,
    this.statsTime,
    this.featureMonitorJobId = 0,
    this.featureMonitorId = '',
  }) : super(fullyQualifiedName);

  factory FeatureStatsAndAnomaly.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureStatsAndAnomaly(
      featureId: switch (json['featureId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureStats: switch (json['featureStats']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      distributionDeviation: switch (json['distributionDeviation']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      driftDetectionThreshold: switch (json['driftDetectionThreshold']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      driftDetected: switch (json['driftDetected']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      statsTime: switch (json['statsTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      featureMonitorJobId: switch (json['featureMonitorJobId']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      featureMonitorId: switch (json['featureMonitorId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureId.isNotDefault) 'featureId': featureId,
    if (featureStats != null) 'featureStats': featureStats!.toJson(),
    if (distributionDeviation.isNotDefault)
      'distributionDeviation': encodeDouble(distributionDeviation),
    if (driftDetectionThreshold.isNotDefault)
      'driftDetectionThreshold': encodeDouble(driftDetectionThreshold),
    if (driftDetected.isNotDefault) 'driftDetected': driftDetected,
    if (statsTime != null) 'statsTime': statsTime!.toJson(),
    if (featureMonitorJobId.isNotDefault)
      'featureMonitorJobId': encodeInt64(featureMonitorJobId),
    if (featureMonitorId.isNotDefault) 'featureMonitorId': featureMonitorId,
  };

  @override
  String toString() {
    final contents = [
      'featureId=$featureId',
      'distributionDeviation=$distributionDeviation',
      'driftDetectionThreshold=$driftDetectionThreshold',
      'driftDetected=$driftDetected',
      'featureMonitorJobId=$featureMonitorJobId',
      'featureMonitorId=$featureMonitorId',
    ].join(',');
    return 'FeatureStatsAndAnomaly($contents)';
  }
}

/// Defines how to select FeatureStatsAndAnomaly to be populated in response.
/// If set, retrieves FeatureStatsAndAnomaly generated by FeatureMonitors based
/// on this spec.
final class FeatureStatsAndAnomalySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureStatsAndAnomalySpec';

  /// Optional. If set, returns the most recent count of stats. Valid value is
  /// [0, 100]. If stats_time_range is set, return most recent count of stats
  /// within the stats_time_range.
  final int? latestStatsCount;

  /// Optional. If set, return all stats generated between [start_time,
  /// end_time). If latest_stats_count is set, return the most recent count of
  /// stats within the stats_time_range.
  final Interval? statsTimeRange;

  FeatureStatsAndAnomalySpec({this.latestStatsCount, this.statsTimeRange})
    : super(fullyQualifiedName);

  factory FeatureStatsAndAnomalySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureStatsAndAnomalySpec(
      latestStatsCount: switch (json['latestStatsCount']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      statsTimeRange: switch (json['statsTimeRange']) {
        null => null,
        Object $1 => Interval.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (latestStatsCount != null) 'latestStatsCount': latestStatsCount,
    if (statsTimeRange != null) 'statsTimeRange': statsTimeRange!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (latestStatsCount != null) 'latestStatsCount=$latestStatsCount',
    ].join(',');
    return 'FeatureStatsAndAnomalySpec($contents)';
  }
}

/// Vertex AI Feature Monitor Job.
final class FeatureMonitorJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureMonitorJob';

  /// Identifier. Name of the FeatureMonitorJob. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}/featureMonitorJobs/{feature_monitor_job}`.
  final String name;

  /// Output only. Timestamp when this FeatureMonitorJob was created. Creation of
  /// a FeatureMonitorJob means that the job is pending / waiting for sufficient
  /// resources but may not have started running yet.
  final protobuf.Timestamp? createTime;

  /// Output only. Final status of the FeatureMonitorJob.
  final Status? finalStatus;

  /// Output only. Summary from the FeatureMonitorJob.
  final FeatureMonitorJob_JobSummary? jobSummary;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureMonitorJob.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureMonitor(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String> labels;

  /// Optional. Description of the FeatureMonitor.
  final String description;

  /// Output only. FeatureMonitorJob ID comparing to which the drift is
  /// calculated.
  final int driftBaseFeatureMonitorJobId;

  /// Output only. Data snapshot time comparing to which the drift is calculated.
  final protobuf.Timestamp? driftBaseSnapshotTime;

  /// Output only. Feature selection config used when creating FeatureMonitorJob.
  final FeatureSelectionConfig? featureSelectionConfig;

  /// Output only. Trigger type of the Feature Monitor Job.
  final FeatureMonitorJob_FeatureMonitorJobTrigger triggerType;

  FeatureMonitorJob({
    this.name = '',
    this.createTime,
    this.finalStatus,
    this.jobSummary,
    this.labels = const {},
    this.description = '',
    this.driftBaseFeatureMonitorJobId = 0,
    this.driftBaseSnapshotTime,
    this.featureSelectionConfig,
    this.triggerType = FeatureMonitorJob_FeatureMonitorJobTrigger.$default,
  }) : super(fullyQualifiedName);

  factory FeatureMonitorJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureMonitorJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      finalStatus: switch (json['finalStatus']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      jobSummary: switch (json['jobSummary']) {
        null => null,
        Object $1 => FeatureMonitorJob_JobSummary.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      driftBaseFeatureMonitorJobId:
          switch (json['driftBaseFeatureMonitorJobId']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
      driftBaseSnapshotTime: switch (json['driftBaseSnapshotTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      featureSelectionConfig: switch (json['featureSelectionConfig']) {
        null => null,
        Object $1 => FeatureSelectionConfig.fromJson($1),
      },
      triggerType: switch (json['triggerType']) {
        null => FeatureMonitorJob_FeatureMonitorJobTrigger.$default,
        Object $1 => FeatureMonitorJob_FeatureMonitorJobTrigger.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (finalStatus != null) 'finalStatus': finalStatus!.toJson(),
    if (jobSummary != null) 'jobSummary': jobSummary!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (description.isNotDefault) 'description': description,
    if (driftBaseFeatureMonitorJobId.isNotDefault)
      'driftBaseFeatureMonitorJobId': encodeInt64(driftBaseFeatureMonitorJobId),
    if (driftBaseSnapshotTime != null)
      'driftBaseSnapshotTime': driftBaseSnapshotTime!.toJson(),
    if (featureSelectionConfig != null)
      'featureSelectionConfig': featureSelectionConfig!.toJson(),
    if (triggerType.isNotDefault) 'triggerType': triggerType.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'description=$description',
      'driftBaseFeatureMonitorJobId=$driftBaseFeatureMonitorJobId',
      'triggerType=$triggerType',
    ].join(',');
    return 'FeatureMonitorJob($contents)';
  }
}

/// Summary from the FeatureMonitorJob.
final class FeatureMonitorJob_JobSummary extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureMonitorJob.JobSummary';

  /// Output only. BigQuery slot milliseconds consumed.
  final int totalSlotMs;

  /// Output only. Features and their stats and anomalies
  final List<FeatureStatsAndAnomaly> featureStatsAndAnomalies;

  FeatureMonitorJob_JobSummary({
    this.totalSlotMs = 0,
    this.featureStatsAndAnomalies = const [],
  }) : super(fullyQualifiedName);

  factory FeatureMonitorJob_JobSummary.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureMonitorJob_JobSummary(
      totalSlotMs: switch (json['totalSlotMs']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      featureStatsAndAnomalies: switch (json['featureStatsAndAnomalies']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FeatureStatsAndAnomaly.fromJson(i),
        ],
        _ => throw const FormatException(
          '"featureStatsAndAnomalies" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (totalSlotMs.isNotDefault) 'totalSlotMs': encodeInt64(totalSlotMs),
    if (featureStatsAndAnomalies.isNotDefault)
      'featureStatsAndAnomalies': encodeList(featureStatsAndAnomalies),
  };

  @override
  String toString() {
    final contents = ['totalSlotMs=$totalSlotMs'].join(',');
    return 'JobSummary($contents)';
  }
}

/// Choices of the trigger type.
final class FeatureMonitorJob_FeatureMonitorJobTrigger extends ProtoEnum {
  /// Trigger type unspecified.
  static const featureMonitorJobTriggerUnspecified =
      FeatureMonitorJob_FeatureMonitorJobTrigger(
        'FEATURE_MONITOR_JOB_TRIGGER_UNSPECIFIED',
      );

  /// Triggered by periodic schedule.
  static const featureMonitorJobTriggerPeriodic =
      FeatureMonitorJob_FeatureMonitorJobTrigger(
        'FEATURE_MONITOR_JOB_TRIGGER_PERIODIC',
      );

  /// Triggered on demand by CreateFeatureMonitorJob request.
  static const featureMonitorJobTriggerOnDemand =
      FeatureMonitorJob_FeatureMonitorJobTrigger(
        'FEATURE_MONITOR_JOB_TRIGGER_ON_DEMAND',
      );

  /// The default value for [FeatureMonitorJob_FeatureMonitorJobTrigger].
  static const $default = featureMonitorJobTriggerUnspecified;

  const FeatureMonitorJob_FeatureMonitorJobTrigger(super.value);

  factory FeatureMonitorJob_FeatureMonitorJobTrigger.fromJson(Object? json) =>
      FeatureMonitorJob_FeatureMonitorJobTrigger(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'FeatureMonitorJobTrigger.$value';
}

/// Stats and Anomaly generated at specific timestamp for specific Feature.
/// The start_time and end_time are used to define the time range of the dataset
/// that current stats belongs to, e.g. prediction traffic is bucketed into
/// prediction datasets by time window. If the Dataset is not defined by time
/// window, start_time = end_time. Timestamp of the stats and anomalies always
/// refers to end_time. Raw stats and anomalies are stored in stats_uri or
/// anomaly_uri in the tensorflow defined protos. Field data_stats contains
/// almost identical information with the raw stats in Vertex AI
/// defined proto, for UI to display.
final class FeatureStatsAnomaly extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureStatsAnomaly';

  /// Feature importance score, only populated when cross-feature monitoring is
  /// enabled. For now only used to represent feature attribution score within
  /// range [0, 1] for
  /// `ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW`
  /// and
  /// `ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT`.
  final double score;

  /// Path of the stats file for current feature values in Cloud Storage bucket.
  /// Format: gs://<bucket_name>/<object_name>/stats.
  /// Example: gs://monitoring_bucket/feature_name/stats.
  /// Stats are stored as binary format with Protobuf message
  /// [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
  final String statsUri;

  /// Path of the anomaly file for current feature values in Cloud Storage
  /// bucket.
  /// Format: gs://<bucket_name>/<object_name>/anomalies.
  /// Example: gs://monitoring_bucket/feature_name/anomalies.
  /// Stats are stored as binary format with Protobuf message
  /// Anoamlies are stored as binary format with Protobuf message
  /// [tensorflow.metadata.v0.AnomalyInfo]
  /// (https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto).
  final String anomalyUri;

  /// Deviation from the current stats to baseline stats.
  ///   1. For categorical feature, the distribution distance is calculated by
  ///      L-inifinity norm.
  ///   2. For numerical feature, the distribution distance is calculated by
  ///      JensenShannon divergence.
  final double distributionDeviation;

  /// This is the threshold used when detecting anomalies.
  /// The threshold can be changed by user, so this one might be different from
  /// `ThresholdConfig.value`.
  final double anomalyDetectionThreshold;

  /// The start timestamp of window where stats were generated.
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), start_time is only used to indicate the monitoring
  /// intervals, so it always equals to (end_time - monitoring_interval).
  final protobuf.Timestamp? startTime;

  /// The end timestamp of window where stats were generated.
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), end_time indicates the timestamp of the data used to
  /// generate stats (e.g. timestamp we take snapshots for feature values).
  final protobuf.Timestamp? endTime;

  FeatureStatsAnomaly({
    this.score = 0,
    this.statsUri = '',
    this.anomalyUri = '',
    this.distributionDeviation = 0,
    this.anomalyDetectionThreshold = 0,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory FeatureStatsAnomaly.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureStatsAnomaly(
      score: switch (json['score']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      statsUri: switch (json['statsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      anomalyUri: switch (json['anomalyUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      distributionDeviation: switch (json['distributionDeviation']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      anomalyDetectionThreshold: switch (json['anomalyDetectionThreshold']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (score.isNotDefault) 'score': encodeDouble(score),
    if (statsUri.isNotDefault) 'statsUri': statsUri,
    if (anomalyUri.isNotDefault) 'anomalyUri': anomalyUri,
    if (distributionDeviation.isNotDefault)
      'distributionDeviation': encodeDouble(distributionDeviation),
    if (anomalyDetectionThreshold.isNotDefault)
      'anomalyDetectionThreshold': encodeDouble(anomalyDetectionThreshold),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'score=$score',
      'statsUri=$statsUri',
      'anomalyUri=$anomalyUri',
      'distributionDeviation=$distributionDeviation',
      'anomalyDetectionThreshold=$anomalyDetectionThreshold',
    ].join(',');
    return 'FeatureStatsAnomaly($contents)';
  }
}

/// Vertex AI Feature Online Store provides a centralized repository for serving
/// ML features and embedding indexes at low latency. The Feature Online Store is
/// a top-level container.
final class FeatureOnlineStore extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore';

  /// Contains settings for the Cloud Bigtable instance that will be created
  /// to serve featureValues for all FeatureViews under this
  /// FeatureOnlineStore.
  final FeatureOnlineStore_Bigtable? bigtable;

  /// Contains settings for the Optimized store that will be created
  /// to serve featureValues for all FeatureViews under this
  /// FeatureOnlineStore. When choose Optimized storage type, need to set
  /// `PrivateServiceConnectConfig.enable_private_service_connect`
  /// to use private endpoint. Otherwise will use public endpoint by default.
  final FeatureOnlineStore_Optimized? optimized;

  /// Identifier. Name of the FeatureOnlineStore. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}`
  final String name;

  /// Output only. Timestamp when this FeatureOnlineStore was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this FeatureOnlineStore was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureOnlineStore.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String> labels;

  /// Output only. State of the featureOnlineStore.
  final FeatureOnlineStore_State state;

  /// Optional. The dedicated serving endpoint for this FeatureOnlineStore, which
  /// is different from common Vertex service endpoint.
  final FeatureOnlineStore_DedicatedServingEndpoint? dedicatedServingEndpoint;

  /// Optional. Deprecated: This field is no longer needed anymore and embedding
  /// management is automatically enabled when specifying Optimized storage type.
  final FeatureOnlineStore_EmbeddingManagement? embeddingManagement;

  /// Optional. Customer-managed encryption key spec for data storage. If set,
  /// online store will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  FeatureOnlineStore({
    this.bigtable,
    this.optimized,
    this.name = '',
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.labels = const {},
    this.state = FeatureOnlineStore_State.$default,
    this.dedicatedServingEndpoint,
    this.embeddingManagement,
    this.encryptionSpec,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureOnlineStore(
      bigtable: switch (json['bigtable']) {
        null => null,
        Object $1 => FeatureOnlineStore_Bigtable.fromJson($1),
      },
      optimized: switch (json['optimized']) {
        null => null,
        Object $1 => FeatureOnlineStore_Optimized.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      state: switch (json['state']) {
        null => FeatureOnlineStore_State.$default,
        Object $1 => FeatureOnlineStore_State.fromJson($1),
      },
      dedicatedServingEndpoint: switch (json['dedicatedServingEndpoint']) {
        null => null,
        Object $1 => FeatureOnlineStore_DedicatedServingEndpoint.fromJson($1),
      },
      embeddingManagement: switch (json['embeddingManagement']) {
        null => null,
        Object $1 => FeatureOnlineStore_EmbeddingManagement.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bigtable != null) 'bigtable': bigtable!.toJson(),
    if (optimized != null) 'optimized': optimized!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (state.isNotDefault) 'state': state.toJson(),
    if (dedicatedServingEndpoint != null)
      'dedicatedServingEndpoint': dedicatedServingEndpoint!.toJson(),
    if (embeddingManagement != null)
      'embeddingManagement': embeddingManagement!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'etag=$etag',
      'state=$state',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'FeatureOnlineStore($contents)';
  }
}

final class FeatureOnlineStore_Bigtable extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.Bigtable';

  /// Required. Autoscaling config applied to Bigtable Instance.
  final FeatureOnlineStore_Bigtable_AutoScaling? autoScaling;

  /// If true, enable direct access to the Bigtable instance.
  final bool enableDirectBigtableAccess;

  /// Metadata of the Bigtable instance. Output only.
  final FeatureOnlineStore_Bigtable_BigtableMetadata? bigtableMetadata;

  FeatureOnlineStore_Bigtable({
    required this.autoScaling,
    this.enableDirectBigtableAccess = false,
    this.bigtableMetadata,
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore_Bigtable.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureOnlineStore_Bigtable(
      autoScaling: switch (json['autoScaling']) {
        null => null,
        Object $1 => FeatureOnlineStore_Bigtable_AutoScaling.fromJson($1),
      },
      enableDirectBigtableAccess: switch (json['enableDirectBigtableAccess']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      bigtableMetadata: switch (json['bigtableMetadata']) {
        null => null,
        Object $1 => FeatureOnlineStore_Bigtable_BigtableMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (autoScaling != null) 'autoScaling': autoScaling!.toJson(),
    if (enableDirectBigtableAccess.isNotDefault)
      'enableDirectBigtableAccess': enableDirectBigtableAccess,
    if (bigtableMetadata != null)
      'bigtableMetadata': bigtableMetadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'enableDirectBigtableAccess=$enableDirectBigtableAccess',
    ].join(',');
    return 'Bigtable($contents)';
  }
}

final class FeatureOnlineStore_Bigtable_AutoScaling extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.Bigtable.AutoScaling';

  /// Required. The minimum number of nodes to scale down to. Must be greater
  /// than or equal to 1.
  final int minNodeCount;

  /// Required. The maximum number of nodes to scale up to. Must be greater
  /// than or equal to min_node_count, and less than or equal to 10 times of
  /// 'min_node_count'.
  final int maxNodeCount;

  /// Optional. A percentage of the cluster's CPU capacity. Can be from 10%
  /// to 80%. When a cluster's CPU utilization exceeds the target that you
  /// have set, Bigtable immediately adds nodes to the cluster. When CPU
  /// utilization is substantially lower than the target, Bigtable removes
  /// nodes. If not set will default to 50%.
  final int cpuUtilizationTarget;

  FeatureOnlineStore_Bigtable_AutoScaling({
    required this.minNodeCount,
    required this.maxNodeCount,
    this.cpuUtilizationTarget = 0,
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore_Bigtable_AutoScaling.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureOnlineStore_Bigtable_AutoScaling(
      minNodeCount: switch (json['minNodeCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      maxNodeCount: switch (json['maxNodeCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      cpuUtilizationTarget: switch (json['cpuUtilizationTarget']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    'minNodeCount': minNodeCount,
    'maxNodeCount': maxNodeCount,
    if (cpuUtilizationTarget.isNotDefault)
      'cpuUtilizationTarget': cpuUtilizationTarget,
  };

  @override
  String toString() {
    final contents = [
      'minNodeCount=$minNodeCount',
      'maxNodeCount=$maxNodeCount',
      'cpuUtilizationTarget=$cpuUtilizationTarget',
    ].join(',');
    return 'AutoScaling($contents)';
  }
}

/// Metadata of the Bigtable instance. This is used by direct read access to
/// the Bigtable in tenant project.
final class FeatureOnlineStore_Bigtable_BigtableMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.Bigtable.BigtableMetadata';

  /// Tenant project ID.
  final String tenantProjectId;

  /// The Cloud Bigtable instance id.
  final String instanceId;

  /// The Cloud Bigtable table id.
  final String tableId;

  FeatureOnlineStore_Bigtable_BigtableMetadata({
    this.tenantProjectId = '',
    this.instanceId = '',
    this.tableId = '',
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore_Bigtable_BigtableMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureOnlineStore_Bigtable_BigtableMetadata(
      tenantProjectId: switch (json['tenantProjectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      instanceId: switch (json['instanceId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tableId: switch (json['tableId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tenantProjectId.isNotDefault) 'tenantProjectId': tenantProjectId,
    if (instanceId.isNotDefault) 'instanceId': instanceId,
    if (tableId.isNotDefault) 'tableId': tableId,
  };

  @override
  String toString() {
    final contents = [
      'tenantProjectId=$tenantProjectId',
      'instanceId=$instanceId',
      'tableId=$tableId',
    ].join(',');
    return 'BigtableMetadata($contents)';
  }
}

/// Optimized storage type
final class FeatureOnlineStore_Optimized extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.Optimized';

  FeatureOnlineStore_Optimized() : super(fullyQualifiedName);

  factory FeatureOnlineStore_Optimized.fromJson(Object? j) =>
      FeatureOnlineStore_Optimized();

  @override
  Object toJson() => {};

  @override
  String toString() => 'Optimized()';
}

/// The dedicated serving endpoint for this FeatureOnlineStore. Only need to
/// set when you choose Optimized storage type. Public endpoint is provisioned
/// by default.
final class FeatureOnlineStore_DedicatedServingEndpoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.DedicatedServingEndpoint';

  /// Output only. This field will be populated with the domain name to use for
  /// this FeatureOnlineStore
  final String publicEndpointDomainName;

  /// Optional. Private service connect config. The private service connection
  /// is available only for Optimized storage type, not for embedding
  /// management now. If
  /// `PrivateServiceConnectConfig.enable_private_service_connect`
  /// set to true, customers will use private service connection to send
  /// request. Otherwise, the connection will set to public endpoint.
  final PrivateServiceConnectConfig? privateServiceConnectConfig;

  /// Output only. The name of the service attachment resource. Populated if
  /// private service connect is enabled and after FeatureViewSync is created.
  final String serviceAttachment;

  FeatureOnlineStore_DedicatedServingEndpoint({
    this.publicEndpointDomainName = '',
    this.privateServiceConnectConfig,
    this.serviceAttachment = '',
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore_DedicatedServingEndpoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureOnlineStore_DedicatedServingEndpoint(
      publicEndpointDomainName: switch (json['publicEndpointDomainName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      privateServiceConnectConfig:
          switch (json['privateServiceConnectConfig']) {
            null => null,
            Object $1 => PrivateServiceConnectConfig.fromJson($1),
          },
      serviceAttachment: switch (json['serviceAttachment']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (publicEndpointDomainName.isNotDefault)
      'publicEndpointDomainName': publicEndpointDomainName,
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
    if (serviceAttachment.isNotDefault) 'serviceAttachment': serviceAttachment,
  };

  @override
  String toString() {
    final contents = [
      'publicEndpointDomainName=$publicEndpointDomainName',
      'serviceAttachment=$serviceAttachment',
    ].join(',');
    return 'DedicatedServingEndpoint($contents)';
  }
}

/// Deprecated: This sub message is no longer needed anymore and embedding
/// management is automatically enabled when specifying Optimized storage type.
/// Contains settings for embedding management.
final class FeatureOnlineStore_EmbeddingManagement extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.EmbeddingManagement';

  /// Optional. Immutable. Whether to enable embedding management in this
  /// FeatureOnlineStore. It's immutable after creation to ensure the
  /// FeatureOnlineStore availability.
  final bool enabled;

  FeatureOnlineStore_EmbeddingManagement({this.enabled = false})
    : super(fullyQualifiedName);

  factory FeatureOnlineStore_EmbeddingManagement.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureOnlineStore_EmbeddingManagement(
      enabled: switch (json['enabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {if (enabled.isNotDefault) 'enabled': enabled};

  @override
  String toString() {
    final contents = ['enabled=$enabled'].join(',');
    return 'EmbeddingManagement($contents)';
  }
}

/// Possible states a featureOnlineStore can have.
final class FeatureOnlineStore_State extends ProtoEnum {
  /// Default value. This value is unused.
  static const stateUnspecified = FeatureOnlineStore_State('STATE_UNSPECIFIED');

  /// State when the featureOnlineStore configuration is not being updated and
  /// the fields reflect the current configuration of the featureOnlineStore.
  /// The featureOnlineStore is usable in this state.
  static const stable = FeatureOnlineStore_State('STABLE');

  /// The state of the featureOnlineStore configuration when it is being
  /// updated. During an update, the fields reflect either the original
  /// configuration or the updated configuration of the featureOnlineStore. The
  /// featureOnlineStore is still usable in this state.
  static const updating = FeatureOnlineStore_State('UPDATING');

  /// The default value for [FeatureOnlineStore_State].
  static const $default = stateUnspecified;

  const FeatureOnlineStore_State(super.value);

  factory FeatureOnlineStore_State.fromJson(Object? json) =>
      FeatureOnlineStore_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Request message for
/// `FeatureOnlineStoreAdminService.CreateFeatureOnlineStore`.
final class CreateFeatureOnlineStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureOnlineStoreRequest';

  /// Required. The resource name of the Location to create FeatureOnlineStores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The FeatureOnlineStore to create.
  final FeatureOnlineStore? featureOnlineStore;

  /// Required. The ID to use for this FeatureOnlineStore, which will become the
  /// final component of the FeatureOnlineStore's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the project and location.
  final String featureOnlineStoreId;

  CreateFeatureOnlineStoreRequest({
    required this.parent,
    required this.featureOnlineStore,
    required this.featureOnlineStoreId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureOnlineStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureOnlineStoreRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureOnlineStore: switch (json['featureOnlineStore']) {
        null => null,
        Object $1 => FeatureOnlineStore.fromJson($1),
      },
      featureOnlineStoreId: switch (json['featureOnlineStoreId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (featureOnlineStore != null)
      'featureOnlineStore': featureOnlineStore!.toJson(),
    'featureOnlineStoreId': featureOnlineStoreId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'featureOnlineStoreId=$featureOnlineStoreId',
    ].join(',');
    return 'CreateFeatureOnlineStoreRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.GetFeatureOnlineStore`.
final class GetFeatureOnlineStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureOnlineStoreRequest';

  /// Required. The name of the FeatureOnlineStore resource.
  final String name;

  GetFeatureOnlineStoreRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetFeatureOnlineStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFeatureOnlineStoreRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureOnlineStoreRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.ListFeatureOnlineStores`.
final class ListFeatureOnlineStoresRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureOnlineStoresRequest';

  /// Required. The resource name of the Location to list FeatureOnlineStores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the FeatureOnlineStores that match the filter expression. The
  /// following fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    FeatureOnlineStores created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    FeatureOnlineStores with label "env" set to "prod".
  final String filter;

  /// The maximum number of FeatureOnlineStores to return. The service may return
  /// fewer than this value. If unspecified, at most 100 FeatureOnlineStores will
  /// be returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `FeatureOnlineStoreAdminService.ListFeatureOnlineStores`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureOnlineStoreAdminService.ListFeatureOnlineStores`
  /// must match the call that provided the page token.
  final String pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  final String orderBy;

  ListFeatureOnlineStoresRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureOnlineStoresRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureOnlineStoresRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureOnlineStoresRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreAdminService.ListFeatureOnlineStores`.
final class ListFeatureOnlineStoresResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureOnlineStoresResponse';

  /// The FeatureOnlineStores matching the request.
  final List<FeatureOnlineStore> featureOnlineStores;

  /// A token, which can be sent as
  /// `ListFeatureOnlineStoresRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListFeatureOnlineStoresResponse({
    this.featureOnlineStores = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureOnlineStoresResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureOnlineStoresResponse(
      featureOnlineStores: switch (json['featureOnlineStores']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FeatureOnlineStore.fromJson(i),
        ],
        _ => throw const FormatException('"featureOnlineStores" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureOnlineStores.isNotDefault)
      'featureOnlineStores': encodeList(featureOnlineStores),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFeatureOnlineStoresResponse($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.UpdateFeatureOnlineStore`.
final class UpdateFeatureOnlineStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureOnlineStoreRequest';

  /// Required. The FeatureOnlineStore's `name` field is used to identify the
  /// FeatureOnlineStore to be updated. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  final FeatureOnlineStore? featureOnlineStore;

  /// Field mask is used to specify the fields to be overwritten in the
  /// FeatureOnlineStore resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `description`
  ///   * `bigtable`
  ///   * `bigtable.auto_scaling`
  ///   * `bigtable.enable_multi_region_replica`
  final protobuf.FieldMask? updateMask;

  UpdateFeatureOnlineStoreRequest({
    required this.featureOnlineStore,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateFeatureOnlineStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureOnlineStoreRequest(
      featureOnlineStore: switch (json['featureOnlineStore']) {
        null => null,
        Object $1 => FeatureOnlineStore.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureOnlineStore != null)
      'featureOnlineStore': featureOnlineStore!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureOnlineStoreRequest()';
}

/// Request message for
/// `FeatureOnlineStoreAdminService.DeleteFeatureOnlineStore`.
final class DeleteFeatureOnlineStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureOnlineStoreRequest';

  /// Required. The name of the FeatureOnlineStore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  final String name;

  /// If set to true, any FeatureViews and Features for this FeatureOnlineStore
  /// will also be deleted. (Otherwise, the request will only work if the
  /// FeatureOnlineStore has no FeatureViews.)
  final bool force;

  DeleteFeatureOnlineStoreRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteFeatureOnlineStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureOnlineStoreRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteFeatureOnlineStoreRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.CreateFeatureView`.
final class CreateFeatureViewRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureViewRequest';

  /// Required. The resource name of the FeatureOnlineStore to create
  /// FeatureViews. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  final String parent;

  /// Required. The FeatureView to create.
  final FeatureView? featureView;

  /// Required. The ID to use for the FeatureView, which will become the final
  /// component of the FeatureView's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within a FeatureOnlineStore.
  final String featureViewId;

  /// Immutable. If set to true, one on demand sync will be run immediately,
  /// regardless whether the
  /// `FeatureView.sync_config`
  /// is configured or not.
  final bool runSyncImmediately;

  CreateFeatureViewRequest({
    required this.parent,
    required this.featureView,
    required this.featureViewId,
    this.runSyncImmediately = false,
  }) : super(fullyQualifiedName);

  factory CreateFeatureViewRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureViewRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureView: switch (json['featureView']) {
        null => null,
        Object $1 => FeatureView.fromJson($1),
      },
      featureViewId: switch (json['featureViewId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      runSyncImmediately: switch (json['runSyncImmediately']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (featureView != null) 'featureView': featureView!.toJson(),
    'featureViewId': featureViewId,
    if (runSyncImmediately.isNotDefault)
      'runSyncImmediately': runSyncImmediately,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'featureViewId=$featureViewId',
      'runSyncImmediately=$runSyncImmediately',
    ].join(',');
    return 'CreateFeatureViewRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.GetFeatureView`.
final class GetFeatureViewRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureViewRequest';

  /// Required. The name of the FeatureView resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String name;

  GetFeatureViewRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureViewRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFeatureViewRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureViewRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.ListFeatureViews`.
final class ListFeatureViewsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureViewsRequest';

  /// Required. The resource name of the FeatureOnlineStore to list FeatureViews.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  final String parent;

  /// Lists the FeatureViews that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `labels`: Supports key-value equality as well as key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
  ///      update_time > \"2020-01-31T15:30:00.000000Z\"` --> FeatureViews
  ///      created or updated after 2020-01-31T15:30:00.000000Z.
  /// * `labels.active = yes AND labels.env = prod` --> FeatureViews having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any FeatureView which has a label with 'env' as the
  ///   key.
  final String filter;

  /// The maximum number of FeatureViews to return. The service may return fewer
  /// than this value. If unspecified, at most 1000 FeatureViews will be
  /// returned. The maximum value is 1000; any value greater than 1000 will be
  /// coerced to 1000.
  final int pageSize;

  /// A page token, received from a previous
  /// `FeatureOnlineStoreAdminService.ListFeatureViews`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureOnlineStoreAdminService.ListFeatureViews`
  /// must match the call that provided the page token.
  final String pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  ///
  /// Supported fields:
  ///
  ///   * `feature_view_id`
  ///   * `create_time`
  ///   * `update_time`
  final String orderBy;

  ListFeatureViewsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureViewsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureViewsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureViewsRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreAdminService.ListFeatureViews`.
final class ListFeatureViewsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureViewsResponse';

  /// The FeatureViews matching the request.
  final List<FeatureView> featureViews;

  /// A token, which can be sent as
  /// `ListFeatureViewsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListFeatureViewsResponse({
    this.featureViews = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureViewsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureViewsResponse(
      featureViews: switch (json['featureViews']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) FeatureView.fromJson(i)],
        _ => throw const FormatException('"featureViews" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureViews.isNotDefault) 'featureViews': encodeList(featureViews),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFeatureViewsResponse($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.UpdateFeatureView`.
final class UpdateFeatureViewRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureViewRequest';

  /// Required. The FeatureView's `name` field is used to identify the
  /// FeatureView to be updated. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final FeatureView? featureView;

  /// Field mask is used to specify the fields to be overwritten in the
  /// FeatureView resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `service_agent_type`
  ///   * `big_query_source`
  ///   * `big_query_source.uri`
  ///   * `big_query_source.entity_id_columns`
  ///   * `feature_registry_source`
  ///   * `feature_registry_source.feature_groups`
  ///   * `sync_config`
  ///   * `sync_config.cron`
  final protobuf.FieldMask? updateMask;

  UpdateFeatureViewRequest({required this.featureView, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeatureViewRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureViewRequest(
      featureView: switch (json['featureView']) {
        null => null,
        Object $1 => FeatureView.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureView != null) 'featureView': featureView!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureViewRequest()';
}

/// Request message for `FeatureOnlineStoreAdminService.DeleteFeatureViews`.
final class DeleteFeatureViewRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureViewRequest';

  /// Required. The name of the FeatureView to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String name;

  DeleteFeatureViewRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteFeatureViewRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureViewRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteFeatureViewRequest($contents)';
  }
}

/// Details of operations that perform create FeatureOnlineStore.
final class CreateFeatureOnlineStoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureOnlineStoreOperationMetadata';

  /// Operation metadata for FeatureOnlineStore.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureOnlineStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureOnlineStoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureOnlineStoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateFeatureOnlineStoreOperationMetadata()';
}

/// Details of operations that perform update FeatureOnlineStore.
final class UpdateFeatureOnlineStoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureOnlineStoreOperationMetadata';

  /// Operation metadata for FeatureOnlineStore.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureOnlineStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureOnlineStoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureOnlineStoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureOnlineStoreOperationMetadata()';
}

/// Details of operations that perform create FeatureView.
final class CreateFeatureViewOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureViewOperationMetadata';

  /// Operation metadata for FeatureView Create.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureViewOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureViewOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureViewOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateFeatureViewOperationMetadata()';
}

/// Details of operations that perform update FeatureView.
final class UpdateFeatureViewOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureViewOperationMetadata';

  /// Operation metadata for FeatureView Update.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureViewOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureViewOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureViewOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureViewOperationMetadata()';
}

/// Request message for
/// `FeatureOnlineStoreAdminService.SyncFeatureView`.
final class SyncFeatureViewRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SyncFeatureViewRequest';

  /// Required. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String featureView;

  SyncFeatureViewRequest({required this.featureView})
    : super(fullyQualifiedName);

  factory SyncFeatureViewRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SyncFeatureViewRequest(
      featureView: switch (json['featureView']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'featureView': featureView};

  @override
  String toString() {
    final contents = ['featureView=$featureView'].join(',');
    return 'SyncFeatureViewRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreAdminService.SyncFeatureView`.
final class SyncFeatureViewResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SyncFeatureViewResponse';

  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  final String featureViewSync;

  SyncFeatureViewResponse({this.featureViewSync = ''})
    : super(fullyQualifiedName);

  factory SyncFeatureViewResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SyncFeatureViewResponse(
      featureViewSync: switch (json['featureViewSync']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureViewSync.isNotDefault) 'featureViewSync': featureViewSync,
  };

  @override
  String toString() {
    final contents = ['featureViewSync=$featureViewSync'].join(',');
    return 'SyncFeatureViewResponse($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.GetFeatureViewSync`.
final class GetFeatureViewSyncRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureViewSyncRequest';

  /// Required. The name of the FeatureViewSync resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  final String name;

  GetFeatureViewSyncRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureViewSyncRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFeatureViewSyncRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureViewSyncRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.ListFeatureViewSyncs`.
final class ListFeatureViewSyncsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureViewSyncsRequest';

  /// Required. The resource name of the FeatureView to list FeatureViewSyncs.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String parent;

  /// Lists the FeatureViewSyncs that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  ///
  /// Examples:
  ///
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\"` --> FeatureViewSyncs
  ///      created after 2020-01-31T15:30:00.000000Z.
  final String filter;

  /// The maximum number of FeatureViewSyncs to return. The service may return
  /// fewer than this value. If unspecified, at most 1000 FeatureViewSyncs will
  /// be returned. The maximum value is 1000; any value greater than 1000 will be
  /// coerced to 1000.
  final int pageSize;

  /// A page token, received from a previous
  /// `FeatureOnlineStoreAdminService.ListFeatureViewSyncs`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureOnlineStoreAdminService.ListFeatureViewSyncs`
  /// must match the call that provided the page token.
  final String pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  ///
  /// Supported fields:
  ///
  ///   * `create_time`
  final String orderBy;

  ListFeatureViewSyncsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureViewSyncsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureViewSyncsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureViewSyncsRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreAdminService.ListFeatureViewSyncs`.
final class ListFeatureViewSyncsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureViewSyncsResponse';

  /// The FeatureViewSyncs matching the request.
  final List<FeatureViewSync> featureViewSyncs;

  /// A token, which can be sent as
  /// `ListFeatureViewSyncsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListFeatureViewSyncsResponse({
    this.featureViewSyncs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureViewSyncsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureViewSyncsResponse(
      featureViewSyncs: switch (json['featureViewSyncs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) FeatureViewSync.fromJson(i)],
        _ => throw const FormatException('"featureViewSyncs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureViewSyncs.isNotDefault)
      'featureViewSyncs': encodeList(featureViewSyncs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFeatureViewSyncsResponse($contents)';
  }
}

/// Lookup key for a feature view.
final class FeatureViewDataKey extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDataKey';

  /// String key to use for lookup.
  final String? key;

  /// The actual Entity ID will be composed from this struct. This should match
  /// with the way ID is defined in the FeatureView spec.
  final FeatureViewDataKey_CompositeKey? compositeKey;

  FeatureViewDataKey({this.key, this.compositeKey}) : super(fullyQualifiedName);

  factory FeatureViewDataKey.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureViewDataKey(
      key: switch (json['key']) {
        null => null,
        Object $1 => decodeString($1),
      },
      compositeKey: switch (json['compositeKey']) {
        null => null,
        Object $1 => FeatureViewDataKey_CompositeKey.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (key != null) 'key': key,
    if (compositeKey != null) 'compositeKey': compositeKey!.toJson(),
  };

  @override
  String toString() {
    final contents = [if (key != null) 'key=$key'].join(',');
    return 'FeatureViewDataKey($contents)';
  }
}

/// ID that is comprised from several parts (columns).
final class FeatureViewDataKey_CompositeKey extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDataKey.CompositeKey';

  /// Parts to construct Entity ID. Should match with the same ID columns as
  /// defined in FeatureView in the same order.
  final List<String> parts;

  FeatureViewDataKey_CompositeKey({this.parts = const []})
    : super(fullyQualifiedName);

  factory FeatureViewDataKey_CompositeKey.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureViewDataKey_CompositeKey(
      parts: switch (json['parts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"parts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (parts.isNotDefault) 'parts': parts};

  @override
  String toString() => 'CompositeKey()';
}

/// Request message for
/// `FeatureOnlineStoreService.FetchFeatureValues`.
/// All the features under the requested feature view will be returned.
final class FetchFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchFeatureValuesRequest';

  /// Simple ID. The whole string will be used as is to identify Entity to
  /// fetch feature values for.
  final String? id;

  /// Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String featureView;

  /// Optional. The request key to fetch feature values for.
  final FeatureViewDataKey? dataKey;

  /// Optional. Response data format. If not set,
  /// `FeatureViewDataFormat.KEY_VALUE`
  /// will be used.
  final FeatureViewDataFormat dataFormat;

  /// Specify response data format. If not set, KeyValue format will be used.
  /// Deprecated. Use
  /// `FetchFeatureValuesRequest.data_format`.
  final FetchFeatureValuesRequest_Format format;

  FetchFeatureValuesRequest({
    this.id,
    required this.featureView,
    this.dataKey,
    this.dataFormat = FeatureViewDataFormat.$default,
    this.format = FetchFeatureValuesRequest_Format.$default,
  }) : super(fullyQualifiedName);

  factory FetchFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FetchFeatureValuesRequest(
      id: switch (json['id']) {
        null => null,
        Object $1 => decodeString($1),
      },
      featureView: switch (json['featureView']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataKey: switch (json['dataKey']) {
        null => null,
        Object $1 => FeatureViewDataKey.fromJson($1),
      },
      dataFormat: switch (json['dataFormat']) {
        null => FeatureViewDataFormat.$default,
        Object $1 => FeatureViewDataFormat.fromJson($1),
      },
      format: switch (json['format']) {
        null => FetchFeatureValuesRequest_Format.$default,
        Object $1 => FetchFeatureValuesRequest_Format.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (id != null) 'id': id,
    'featureView': featureView,
    if (dataKey != null) 'dataKey': dataKey!.toJson(),
    if (dataFormat.isNotDefault) 'dataFormat': dataFormat.toJson(),
    if (format.isNotDefault) 'format': format.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      'featureView=$featureView',
      'dataFormat=$dataFormat',
      'format=$format',
    ].join(',');
    return 'FetchFeatureValuesRequest($contents)';
  }
}

/// Format of the response data.
final class FetchFeatureValuesRequest_Format extends ProtoEnum {
  /// Not set. Will be treated as the KeyValue format.
  static const formatUnspecified = FetchFeatureValuesRequest_Format(
    'FORMAT_UNSPECIFIED',
  );

  /// Return response data in key-value format.
  static const keyValue = FetchFeatureValuesRequest_Format('KEY_VALUE');

  /// Return response data in proto Struct format.
  static const protoStruct = FetchFeatureValuesRequest_Format('PROTO_STRUCT');

  /// The default value for [FetchFeatureValuesRequest_Format].
  static const $default = formatUnspecified;

  const FetchFeatureValuesRequest_Format(super.value);

  factory FetchFeatureValuesRequest_Format.fromJson(Object? json) =>
      FetchFeatureValuesRequest_Format(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Format.$value';
}

/// Response message for
/// `FeatureOnlineStoreService.FetchFeatureValues`
final class FetchFeatureValuesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchFeatureValuesResponse';

  /// Feature values in KeyValue format.
  final FetchFeatureValuesResponse_FeatureNameValuePairList? keyValues;

  /// Feature values in proto Struct format.
  final protobuf.Struct? protoStruct;

  /// The data key associated with this response.
  /// Will only be populated for
  /// `FeatureOnlineStoreService.StreamingFetchFeatureValues`
  /// RPCs.
  final FeatureViewDataKey? dataKey;

  FetchFeatureValuesResponse({this.keyValues, this.protoStruct, this.dataKey})
    : super(fullyQualifiedName);

  factory FetchFeatureValuesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FetchFeatureValuesResponse(
      keyValues: switch (json['keyValues']) {
        null => null,
        Object $1 =>
          FetchFeatureValuesResponse_FeatureNameValuePairList.fromJson($1),
      },
      protoStruct: switch (json['protoStruct']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      dataKey: switch (json['dataKey']) {
        null => null,
        Object $1 => FeatureViewDataKey.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (keyValues != null) 'keyValues': keyValues!.toJson(),
    if (protoStruct != null) 'protoStruct': protoStruct!.toJson(),
    if (dataKey != null) 'dataKey': dataKey!.toJson(),
  };

  @override
  String toString() => 'FetchFeatureValuesResponse()';
}

/// Response structure in the format of key (feature name) and (feature) value
/// pair.
final class FetchFeatureValuesResponse_FeatureNameValuePairList
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchFeatureValuesResponse.FeatureNameValuePairList';

  /// List of feature names and values.
  final List<
    FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair
  >
  features;

  FetchFeatureValuesResponse_FeatureNameValuePairList({
    this.features = const [],
  }) : super(fullyQualifiedName);

  factory FetchFeatureValuesResponse_FeatureNameValuePairList.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return FetchFeatureValuesResponse_FeatureNameValuePairList(
      features: switch (json['features']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException('"features" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (features.isNotDefault) 'features': encodeList(features),
  };

  @override
  String toString() => 'FeatureNameValuePairList()';
}

/// Feature name & value pair.
final class FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair';

  /// Feature value.
  final FeatureValue? value;

  /// Feature short name.
  final String name;

  FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair({
    this.value,
    this.name = '',
  }) : super(fullyQualifiedName);

  factory FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair(
      value: switch (json['value']) {
        null => null,
        Object $1 => FeatureValue.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (value != null) 'value': value!.toJson(),
    if (name.isNotDefault) 'name': name,
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'FeatureNameValuePair($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreService.StreamingFetchFeatureValues`.
/// For the entities requested, all features under the requested feature view
/// will be returned.
final class StreamingFetchFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingFetchFeatureValuesRequest';

  /// Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String featureView;

  final List<FeatureViewDataKey> dataKeys;

  /// Specify response data format. If not set, KeyValue format will be used.
  final FeatureViewDataFormat dataFormat;

  StreamingFetchFeatureValuesRequest({
    required this.featureView,
    this.dataKeys = const [],
    this.dataFormat = FeatureViewDataFormat.$default,
  }) : super(fullyQualifiedName);

  factory StreamingFetchFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamingFetchFeatureValuesRequest(
      featureView: switch (json['featureView']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataKeys: switch (json['dataKeys']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FeatureViewDataKey.fromJson(i),
        ],
        _ => throw const FormatException('"dataKeys" is not a list'),
      },
      dataFormat: switch (json['dataFormat']) {
        null => FeatureViewDataFormat.$default,
        Object $1 => FeatureViewDataFormat.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'featureView': featureView,
    if (dataKeys.isNotDefault) 'dataKeys': encodeList(dataKeys),
    if (dataFormat.isNotDefault) 'dataFormat': dataFormat.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'featureView=$featureView',
      'dataFormat=$dataFormat',
    ].join(',');
    return 'StreamingFetchFeatureValuesRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreService.StreamingFetchFeatureValues`.
final class StreamingFetchFeatureValuesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingFetchFeatureValuesResponse';

  /// Response status.
  /// If OK, then
  /// `StreamingFetchFeatureValuesResponse.data`
  /// will be populated. Otherwise
  /// `StreamingFetchFeatureValuesResponse.data_keys_with_error`
  /// will be populated with the appropriate data keys. The error only applies to
  /// the listed data keys - the stream will remain open for further
  /// `FeatureOnlineStoreService.StreamingFetchFeatureValuesRequest` requests.
  final Status? status;

  final List<FetchFeatureValuesResponse> data;

  final List<FeatureViewDataKey> dataKeysWithError;

  StreamingFetchFeatureValuesResponse({
    this.status,
    this.data = const [],
    this.dataKeysWithError = const [],
  }) : super(fullyQualifiedName);

  factory StreamingFetchFeatureValuesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamingFetchFeatureValuesResponse(
      status: switch (json['status']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      data: switch (json['data']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FetchFeatureValuesResponse.fromJson(i),
        ],
        _ => throw const FormatException('"data" is not a list'),
      },
      dataKeysWithError: switch (json['dataKeysWithError']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FeatureViewDataKey.fromJson(i),
        ],
        _ => throw const FormatException('"dataKeysWithError" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (status != null) 'status': status!.toJson(),
    if (data.isNotDefault) 'data': encodeList(data),
    if (dataKeysWithError.isNotDefault)
      'dataKeysWithError': encodeList(dataKeysWithError),
  };

  @override
  String toString() => 'StreamingFetchFeatureValuesResponse()';
}

/// A query to find a number of similar entities.
final class NearestNeighborQuery extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery';

  /// Optional. The entity id whose similar entities should be searched for.
  /// If embedding is set, search will use embedding instead of
  /// entity_id.
  final String? entityId;

  /// Optional. The embedding vector that be used for similar search.
  final NearestNeighborQuery_Embedding? embedding;

  /// Optional. The number of similar entities to be retrieved from feature view
  /// for each query.
  final int neighborCount;

  /// Optional. The list of string filters.
  final List<NearestNeighborQuery_StringFilter> stringFilters;

  /// Optional. The list of numeric filters.
  final List<NearestNeighborQuery_NumericFilter> numericFilters;

  /// Optional. Crowding is a constraint on a neighbor list produced by nearest
  /// neighbor search requiring that no more than
  /// sper_crowding_attribute_neighbor_count of the k neighbors returned have the
  /// same value of crowding_attribute. It's used for improving result diversity.
  final int perCrowdingAttributeNeighborCount;

  /// Optional. Parameters that can be set to tune query on the fly.
  final NearestNeighborQuery_Parameters? parameters;

  NearestNeighborQuery({
    this.entityId,
    this.embedding,
    this.neighborCount = 0,
    this.stringFilters = const [],
    this.numericFilters = const [],
    this.perCrowdingAttributeNeighborCount = 0,
    this.parameters,
  }) : super(fullyQualifiedName);

  factory NearestNeighborQuery.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NearestNeighborQuery(
      entityId: switch (json['entityId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      embedding: switch (json['embedding']) {
        null => null,
        Object $1 => NearestNeighborQuery_Embedding.fromJson($1),
      },
      neighborCount: switch (json['neighborCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      stringFilters: switch (json['stringFilters']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) NearestNeighborQuery_StringFilter.fromJson(i),
        ],
        _ => throw const FormatException('"stringFilters" is not a list'),
      },
      numericFilters: switch (json['numericFilters']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) NearestNeighborQuery_NumericFilter.fromJson(i),
        ],
        _ => throw const FormatException('"numericFilters" is not a list'),
      },
      perCrowdingAttributeNeighborCount:
          switch (json['perCrowdingAttributeNeighborCount']) {
            null => 0,
            Object $1 => decodeInt($1),
          },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => NearestNeighborQuery_Parameters.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (entityId != null) 'entityId': entityId,
    if (embedding != null) 'embedding': embedding!.toJson(),
    if (neighborCount.isNotDefault) 'neighborCount': neighborCount,
    if (stringFilters.isNotDefault) 'stringFilters': encodeList(stringFilters),
    if (numericFilters.isNotDefault)
      'numericFilters': encodeList(numericFilters),
    if (perCrowdingAttributeNeighborCount.isNotDefault)
      'perCrowdingAttributeNeighborCount': perCrowdingAttributeNeighborCount,
    if (parameters != null) 'parameters': parameters!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (entityId != null) 'entityId=$entityId',
      'neighborCount=$neighborCount',
      'perCrowdingAttributeNeighborCount=$perCrowdingAttributeNeighborCount',
    ].join(',');
    return 'NearestNeighborQuery($contents)';
  }
}

/// The embedding vector.
final class NearestNeighborQuery_Embedding extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery.Embedding';

  /// Optional. Individual value in the embedding.
  final List<double> value;

  NearestNeighborQuery_Embedding({this.value = const []})
    : super(fullyQualifiedName);

  factory NearestNeighborQuery_Embedding.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NearestNeighborQuery_Embedding(
      value: switch (json['value']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"value" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (value.isNotDefault) 'value': value};

  @override
  String toString() => 'Embedding()';
}

/// String filter is used to search a subset of the entities by using boolean
/// rules on string columns.
/// For example: if a query specifies string filter
/// with 'name = color, allow_tokens = {red, blue}, deny_tokens = {purple}','
/// then that query will match entities that are red or blue, but if those
/// points are also purple, then they will be excluded even if they are
/// red/blue. Only string filter is supported for now, numeric filter will be
/// supported in the near future.
final class NearestNeighborQuery_StringFilter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery.StringFilter';

  /// Required. Column names in BigQuery that used as filters.
  final String name;

  /// Optional. The allowed tokens.
  final List<String> allowTokens;

  /// Optional. The denied tokens.
  final List<String> denyTokens;

  NearestNeighborQuery_StringFilter({
    required this.name,
    this.allowTokens = const [],
    this.denyTokens = const [],
  }) : super(fullyQualifiedName);

  factory NearestNeighborQuery_StringFilter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NearestNeighborQuery_StringFilter(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      allowTokens: switch (json['allowTokens']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"allowTokens" is not a list'),
      },
      denyTokens: switch (json['denyTokens']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"denyTokens" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (allowTokens.isNotDefault) 'allowTokens': allowTokens,
    if (denyTokens.isNotDefault) 'denyTokens': denyTokens,
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StringFilter($contents)';
  }
}

/// Numeric filter is used to search a subset of the entities by using boolean
/// rules on numeric columns.
/// For example:
/// Database Point 0: {name: a value_int: 42} {name: b value_float: 1.0}
/// Database Point 1:  {name: a value_int: 10} {name: b value_float: 2.0}
/// Database Point 2: {name: a value_int: -1} {name: b value_float: 3.0}
/// Query: {name: a value_int: 12 operator: LESS}    // Matches Point 1, 2
/// {name: b value_float: 2.0 operator: EQUAL} // Matches Point 1
final class NearestNeighborQuery_NumericFilter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery.NumericFilter';

  /// int value type.
  final int? valueInt;

  /// float value type.
  final double? valueFloat;

  /// double value type.
  final double? valueDouble;

  /// Required. Column name in BigQuery that used as filters.
  final String name;

  /// Optional. This MUST be specified for queries and must NOT be specified
  /// for database points.
  final NearestNeighborQuery_NumericFilter_Operator? op;

  NearestNeighborQuery_NumericFilter({
    this.valueInt,
    this.valueFloat,
    this.valueDouble,
    required this.name,
    this.op,
  }) : super(fullyQualifiedName);

  factory NearestNeighborQuery_NumericFilter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NearestNeighborQuery_NumericFilter(
      valueInt: switch (json['valueInt']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      valueFloat: switch (json['valueFloat']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      valueDouble: switch (json['valueDouble']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      op: switch (json['op']) {
        null => null,
        Object $1 => NearestNeighborQuery_NumericFilter_Operator.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (valueInt != null) 'valueInt': encodeInt64(valueInt),
    if (valueFloat != null) 'valueFloat': encodeDouble(valueFloat),
    if (valueDouble != null) 'valueDouble': encodeDouble(valueDouble),
    'name': name,
    if (op != null) 'op': op!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (valueInt != null) 'valueInt=$valueInt',
      if (valueFloat != null) 'valueFloat=$valueFloat',
      if (valueDouble != null) 'valueDouble=$valueDouble',
      'name=$name',
      if (op != null) 'op=$op',
    ].join(',');
    return 'NumericFilter($contents)';
  }
}

/// Datapoints for which Operator is true relative to the querys Value
/// field will be allowlisted.
final class NearestNeighborQuery_NumericFilter_Operator extends ProtoEnum {
  /// Unspecified operator.
  static const operatorUnspecified =
      NearestNeighborQuery_NumericFilter_Operator('OPERATOR_UNSPECIFIED');

  /// Entities are eligible if their value is < the query's.
  static const less = NearestNeighborQuery_NumericFilter_Operator('LESS');

  /// Entities are eligible if their value is <= the query's.
  static const lessEqual = NearestNeighborQuery_NumericFilter_Operator(
    'LESS_EQUAL',
  );

  /// Entities are eligible if their value is == the query's.
  static const equal = NearestNeighborQuery_NumericFilter_Operator('EQUAL');

  /// Entities are eligible if their value is >= the query's.
  static const greaterEqual = NearestNeighborQuery_NumericFilter_Operator(
    'GREATER_EQUAL',
  );

  /// Entities are eligible if their value is > the query's.
  static const greater = NearestNeighborQuery_NumericFilter_Operator('GREATER');

  /// Entities are eligible if their value is != the query's.
  static const notEqual = NearestNeighborQuery_NumericFilter_Operator(
    'NOT_EQUAL',
  );

  /// The default value for [NearestNeighborQuery_NumericFilter_Operator].
  static const $default = operatorUnspecified;

  const NearestNeighborQuery_NumericFilter_Operator(super.value);

  factory NearestNeighborQuery_NumericFilter_Operator.fromJson(Object? json) =>
      NearestNeighborQuery_NumericFilter_Operator(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Operator.$value';
}

/// Parameters that can be overrided in each query to tune query latency and
/// recall.
final class NearestNeighborQuery_Parameters extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery.Parameters';

  /// Optional. The number of neighbors to find via approximate search before
  /// exact reordering is performed; if set, this value must be >
  /// neighbor_count.
  final int approximateNeighborCandidates;

  /// Optional. The fraction of the number of leaves to search, set at query
  /// time allows user to tune search performance. This value increase result
  /// in both search accuracy and latency increase. The value should be between
  /// 0.0 and 1.0.
  final double leafNodesSearchFraction;

  NearestNeighborQuery_Parameters({
    this.approximateNeighborCandidates = 0,
    this.leafNodesSearchFraction = 0,
  }) : super(fullyQualifiedName);

  factory NearestNeighborQuery_Parameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NearestNeighborQuery_Parameters(
      approximateNeighborCandidates:
          switch (json['approximateNeighborCandidates']) {
            null => 0,
            Object $1 => decodeInt($1),
          },
      leafNodesSearchFraction: switch (json['leafNodesSearchFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (approximateNeighborCandidates.isNotDefault)
      'approximateNeighborCandidates': approximateNeighborCandidates,
    if (leafNodesSearchFraction.isNotDefault)
      'leafNodesSearchFraction': encodeDouble(leafNodesSearchFraction),
  };

  @override
  String toString() {
    final contents = [
      'approximateNeighborCandidates=$approximateNeighborCandidates',
      'leafNodesSearchFraction=$leafNodesSearchFraction',
    ].join(',');
    return 'Parameters($contents)';
  }
}

/// The request message for
/// `FeatureOnlineStoreService.SearchNearestEntities`.
final class SearchNearestEntitiesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchNearestEntitiesRequest';

  /// Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String featureView;

  /// Required. The query.
  final NearestNeighborQuery? query;

  /// Optional. If set to true, the full entities (including all vector values
  /// and metadata) of the nearest neighbors are returned; otherwise only entity
  /// id of the nearest neighbors will be returned. Note that returning full
  /// entities will significantly increase the latency and cost of the query.
  final bool returnFullEntity;

  SearchNearestEntitiesRequest({
    required this.featureView,
    required this.query,
    this.returnFullEntity = false,
  }) : super(fullyQualifiedName);

  factory SearchNearestEntitiesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchNearestEntitiesRequest(
      featureView: switch (json['featureView']) {
        null => '',
        Object $1 => decodeString($1),
      },
      query: switch (json['query']) {
        null => null,
        Object $1 => NearestNeighborQuery.fromJson($1),
      },
      returnFullEntity: switch (json['returnFullEntity']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'featureView': featureView,
    if (query != null) 'query': query!.toJson(),
    if (returnFullEntity.isNotDefault) 'returnFullEntity': returnFullEntity,
  };

  @override
  String toString() {
    final contents = [
      'featureView=$featureView',
      'returnFullEntity=$returnFullEntity',
    ].join(',');
    return 'SearchNearestEntitiesRequest($contents)';
  }
}

/// Nearest neighbors for one query.
final class NearestNeighbors extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighbors';

  /// All its neighbors.
  final List<NearestNeighbors_Neighbor> neighbors;

  NearestNeighbors({this.neighbors = const []}) : super(fullyQualifiedName);

  factory NearestNeighbors.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NearestNeighbors(
      neighbors: switch (json['neighbors']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) NearestNeighbors_Neighbor.fromJson(i),
        ],
        _ => throw const FormatException('"neighbors" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (neighbors.isNotDefault) 'neighbors': encodeList(neighbors),
  };

  @override
  String toString() => 'NearestNeighbors()';
}

/// A neighbor of the query vector.
final class NearestNeighbors_Neighbor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighbors.Neighbor';

  /// The id of the similar entity.
  final String entityId;

  /// The distance between the neighbor and the query vector.
  final double distance;

  /// The attributes of the neighbor, e.g. filters, crowding and metadata
  /// Note that full entities are returned only when "return_full_entity"
  /// is set to true. Otherwise, only the "entity_id" and "distance" fields
  /// are populated.
  final FetchFeatureValuesResponse? entityKeyValues;

  NearestNeighbors_Neighbor({
    this.entityId = '',
    this.distance = 0,
    this.entityKeyValues,
  }) : super(fullyQualifiedName);

  factory NearestNeighbors_Neighbor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NearestNeighbors_Neighbor(
      entityId: switch (json['entityId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      distance: switch (json['distance']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      entityKeyValues: switch (json['entityKeyValues']) {
        null => null,
        Object $1 => FetchFeatureValuesResponse.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (entityId.isNotDefault) 'entityId': entityId,
    if (distance.isNotDefault) 'distance': encodeDouble(distance),
    if (entityKeyValues != null) 'entityKeyValues': entityKeyValues!.toJson(),
  };

  @override
  String toString() {
    final contents = ['entityId=$entityId', 'distance=$distance'].join(',');
    return 'Neighbor($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreService.SearchNearestEntities`
final class SearchNearestEntitiesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchNearestEntitiesResponse';

  /// The nearest neighbors of the query entity.
  final NearestNeighbors? nearestNeighbors;

  SearchNearestEntitiesResponse({this.nearestNeighbors})
    : super(fullyQualifiedName);

  factory SearchNearestEntitiesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchNearestEntitiesResponse(
      nearestNeighbors: switch (json['nearestNeighbors']) {
        null => null,
        Object $1 => NearestNeighbors.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (nearestNeighbors != null)
      'nearestNeighbors': nearestNeighbors!.toJson(),
  };

  @override
  String toString() => 'SearchNearestEntitiesResponse()';
}

/// Request message for
/// `FeatureOnlineStoreService.FeatureViewDirectWrite`.
final class FeatureViewDirectWriteRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteRequest';

  /// FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String featureView;

  /// Required. The data keys and associated feature values.
  final List<FeatureViewDirectWriteRequest_DataKeyAndFeatureValues>
  dataKeyAndFeatureValues;

  FeatureViewDirectWriteRequest({
    this.featureView = '',
    required this.dataKeyAndFeatureValues,
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureViewDirectWriteRequest(
      featureView: switch (json['featureView']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataKeyAndFeatureValues: switch (json['dataKeyAndFeatureValues']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            FeatureViewDirectWriteRequest_DataKeyAndFeatureValues.fromJson(i),
        ],
        _ => throw const FormatException(
          '"dataKeyAndFeatureValues" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureView.isNotDefault) 'featureView': featureView,
    'dataKeyAndFeatureValues': encodeList(dataKeyAndFeatureValues),
  };

  @override
  String toString() {
    final contents = ['featureView=$featureView'].join(',');
    return 'FeatureViewDirectWriteRequest($contents)';
  }
}

/// A data key and associated feature values to write to the feature view.
final class FeatureViewDirectWriteRequest_DataKeyAndFeatureValues
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues';

  /// The data key.
  final FeatureViewDataKey? dataKey;

  /// List of features to write.
  final List<FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature>
  features;

  FeatureViewDirectWriteRequest_DataKeyAndFeatureValues({
    this.dataKey,
    this.features = const [],
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteRequest_DataKeyAndFeatureValues.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return FeatureViewDirectWriteRequest_DataKeyAndFeatureValues(
      dataKey: switch (json['dataKey']) {
        null => null,
        Object $1 => FeatureViewDataKey.fromJson($1),
      },
      features: switch (json['features']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException('"features" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataKey != null) 'dataKey': dataKey!.toJson(),
    if (features.isNotDefault) 'features': encodeList(features),
  };

  @override
  String toString() => 'DataKeyAndFeatureValues()';
}

/// Feature name & value pair.
final class FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues.Feature';

  /// Feature value. A user provided timestamp may be set in the
  /// `FeatureValue.metadata.generate_time` field.
  final FeatureValue? value;

  /// Feature value and timestamp.
  final FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp?
  valueAndTimestamp;

  /// Feature short name.
  final String name;

  FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature({
    this.value,
    this.valueAndTimestamp,
    this.name = '',
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature(
      value: switch (json['value']) {
        null => null,
        Object $1 => FeatureValue.fromJson($1),
      },
      valueAndTimestamp: switch (json['valueAndTimestamp']) {
        null => null,
        Object $1 =>
          FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp.fromJson(
            $1,
          ),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (value != null) 'value': value!.toJson(),
    if (valueAndTimestamp != null)
      'valueAndTimestamp': valueAndTimestamp!.toJson(),
    if (name.isNotDefault) 'name': name,
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'Feature($contents)';
  }
}

/// Feature value and timestamp.
final class FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues.Feature.FeatureValueAndTimestamp';

  /// The feature value.
  final FeatureValue? value;

  /// The feature timestamp to store with this value.
  /// If not set, then the Feature Store server will generate a timestamp
  /// when it receives the write request.
  final protobuf.Timestamp? timestamp;

  FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp({
    this.value,
    this.timestamp,
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp(
      value: switch (json['value']) {
        null => null,
        Object $1 => FeatureValue.fromJson($1),
      },
      timestamp: switch (json['timestamp']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (value != null) 'value': value!.toJson(),
    if (timestamp != null) 'timestamp': timestamp!.toJson(),
  };

  @override
  String toString() => 'FeatureValueAndTimestamp()';
}

/// Response message for
/// `FeatureOnlineStoreService.FeatureViewDirectWrite`.
final class FeatureViewDirectWriteResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteResponse';

  /// Response status for the keys listed in
  /// `FeatureViewDirectWriteResponse.write_responses`.
  ///
  /// The error only applies to the
  /// listed data keys - the stream will remain open for further
  /// `FeatureOnlineStoreService.FeatureViewDirectWriteRequest` requests.
  ///
  /// Partial failures (e.g. if the first 10 keys of a request fail, but the
  /// rest succeed) from a single request may result in multiple responses -
  /// there will be one response for the successful request keys and one response
  /// for the failing request keys.
  final Status? status;

  /// Details about write for each key. If status is not OK,
  /// `WriteResponse.data_key`
  /// will have the key with error, but
  /// `WriteResponse.online_store_write_time`
  /// will not be present.
  final List<FeatureViewDirectWriteResponse_WriteResponse> writeResponses;

  FeatureViewDirectWriteResponse({this.status, this.writeResponses = const []})
    : super(fullyQualifiedName);

  factory FeatureViewDirectWriteResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureViewDirectWriteResponse(
      status: switch (json['status']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      writeResponses: switch (json['writeResponses']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            FeatureViewDirectWriteResponse_WriteResponse.fromJson(i),
        ],
        _ => throw const FormatException('"writeResponses" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (status != null) 'status': status!.toJson(),
    if (writeResponses.isNotDefault)
      'writeResponses': encodeList(writeResponses),
  };

  @override
  String toString() => 'FeatureViewDirectWriteResponse()';
}

/// Details about the write for each key.
final class FeatureViewDirectWriteResponse_WriteResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteResponse.WriteResponse';

  /// What key is this write response associated with.
  final FeatureViewDataKey? dataKey;

  /// When the feature values were written to the online store.
  /// If
  /// `FeatureViewDirectWriteResponse.status`
  /// is not OK, this field is not populated.
  final protobuf.Timestamp? onlineStoreWriteTime;

  FeatureViewDirectWriteResponse_WriteResponse({
    this.dataKey,
    this.onlineStoreWriteTime,
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteResponse_WriteResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureViewDirectWriteResponse_WriteResponse(
      dataKey: switch (json['dataKey']) {
        null => null,
        Object $1 => FeatureViewDataKey.fromJson($1),
      },
      onlineStoreWriteTime: switch (json['onlineStoreWriteTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataKey != null) 'dataKey': dataKey!.toJson(),
    if (onlineStoreWriteTime != null)
      'onlineStoreWriteTime': onlineStoreWriteTime!.toJson(),
  };

  @override
  String toString() => 'WriteResponse()';
}

/// Request message for `FeatureOnlineStoreService.GenerateFetchAccessToken`.
final class GenerateFetchAccessTokenRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateFetchAccessTokenRequest';

  /// FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String featureView;

  GenerateFetchAccessTokenRequest({this.featureView = ''})
    : super(fullyQualifiedName);

  factory GenerateFetchAccessTokenRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateFetchAccessTokenRequest(
      featureView: switch (json['featureView']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (featureView.isNotDefault) 'featureView': featureView};

  @override
  String toString() {
    final contents = ['featureView=$featureView'].join(',');
    return 'GenerateFetchAccessTokenRequest($contents)';
  }
}

/// Response message for `FeatureOnlineStoreService.GenerateFetchAccessToken`.
final class GenerateFetchAccessTokenResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateFetchAccessTokenResponse';

  /// The OAuth 2.0 access token.
  final String accessToken;

  /// Token expiration time. This is always set
  final protobuf.Timestamp? expireTime;

  GenerateFetchAccessTokenResponse({this.accessToken = '', this.expireTime})
    : super(fullyQualifiedName);

  factory GenerateFetchAccessTokenResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateFetchAccessTokenResponse(
      accessToken: switch (json['accessToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      expireTime: switch (json['expireTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (accessToken.isNotDefault) 'accessToken': accessToken,
    if (expireTime != null) 'expireTime': expireTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['accessToken=$accessToken'].join(',');
    return 'GenerateFetchAccessTokenResponse($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.CreateFeatureGroup`.
final class CreateFeatureGroupRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureGroupRequest';

  /// Required. The resource name of the Location to create FeatureGroups.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The FeatureGroup to create.
  final FeatureGroup? featureGroup;

  /// Required. The ID to use for this FeatureGroup, which will become the final
  /// component of the FeatureGroup's resource name.
  ///
  /// This value may be up to 128 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the project and location.
  final String featureGroupId;

  CreateFeatureGroupRequest({
    required this.parent,
    required this.featureGroup,
    required this.featureGroupId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureGroupRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureGroupRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureGroup: switch (json['featureGroup']) {
        null => null,
        Object $1 => FeatureGroup.fromJson($1),
      },
      featureGroupId: switch (json['featureGroupId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (featureGroup != null) 'featureGroup': featureGroup!.toJson(),
    'featureGroupId': featureGroupId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'featureGroupId=$featureGroupId',
    ].join(',');
    return 'CreateFeatureGroupRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.GetFeatureGroup`.
final class GetFeatureGroupRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureGroupRequest';

  /// Required. The name of the FeatureGroup resource.
  final String name;

  GetFeatureGroupRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureGroupRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFeatureGroupRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureGroupRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.ListFeatureGroups`.
final class ListFeatureGroupsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureGroupsRequest';

  /// Required. The resource name of the Location to list FeatureGroups.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the FeatureGroups that match the filter expression. The
  /// following fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    FeatureGroups created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    FeatureGroups with label "env" set to "prod".
  final String filter;

  /// The maximum number of FeatureGroups to return. The service may return
  /// fewer than this value. If unspecified, at most 100 FeatureGroups will
  /// be returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `FeatureGroupAdminService.ListFeatureGroups` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureGroupAdminService.ListFeatureGroups` must
  /// match the call that provided the page token.
  final String pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  final String orderBy;

  ListFeatureGroupsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureGroupsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureGroupsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureGroupsRequest($contents)';
  }
}

/// Response message for
/// `FeatureRegistryService.ListFeatureGroups`.
final class ListFeatureGroupsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureGroupsResponse';

  /// The FeatureGroups matching the request.
  final List<FeatureGroup> featureGroups;

  /// A token, which can be sent as
  /// `ListFeatureGroupsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListFeatureGroupsResponse({
    this.featureGroups = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureGroupsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureGroupsResponse(
      featureGroups: switch (json['featureGroups']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) FeatureGroup.fromJson(i)],
        _ => throw const FormatException('"featureGroups" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureGroups.isNotDefault) 'featureGroups': encodeList(featureGroups),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFeatureGroupsResponse($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.UpdateFeatureGroup`.
final class UpdateFeatureGroupRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureGroupRequest';

  /// Required. The FeatureGroup's `name` field is used to identify the
  /// FeatureGroup to be updated. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final FeatureGroup? featureGroup;

  /// Field mask is used to specify the fields to be overwritten in the
  /// FeatureGroup resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `description`
  ///   * `big_query`
  ///   * `big_query.entity_id_columns`
  final protobuf.FieldMask? updateMask;

  UpdateFeatureGroupRequest({required this.featureGroup, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeatureGroupRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureGroupRequest(
      featureGroup: switch (json['featureGroup']) {
        null => null,
        Object $1 => FeatureGroup.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureGroup != null) 'featureGroup': featureGroup!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureGroupRequest()';
}

/// Request message for
/// `FeatureRegistryService.DeleteFeatureGroup`.
final class DeleteFeatureGroupRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureGroupRequest';

  /// Required. The name of the FeatureGroup to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String name;

  /// If set to true, any Features under this FeatureGroup
  /// will also be deleted. (Otherwise, the request will only work if the
  /// FeatureGroup has no Features.)
  final bool force;

  DeleteFeatureGroupRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteFeatureGroupRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureGroupRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteFeatureGroupRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.CreateFeatureMonitorRequest`.
final class CreateFeatureMonitorRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureMonitorRequest';

  /// Required. The resource name of FeatureGroup to create FeatureMonitor.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featuregroup}`
  final String parent;

  /// Required. The Monitor to create.
  final FeatureMonitor? featureMonitor;

  /// Required. The ID to use for this FeatureMonitor, which will become the
  /// final component of the FeatureGroup's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the FeatureGroup.
  final String featureMonitorId;

  CreateFeatureMonitorRequest({
    required this.parent,
    required this.featureMonitor,
    required this.featureMonitorId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureMonitorRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureMonitorRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureMonitor: switch (json['featureMonitor']) {
        null => null,
        Object $1 => FeatureMonitor.fromJson($1),
      },
      featureMonitorId: switch (json['featureMonitorId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (featureMonitor != null) 'featureMonitor': featureMonitor!.toJson(),
    'featureMonitorId': featureMonitorId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'featureMonitorId=$featureMonitorId',
    ].join(',');
    return 'CreateFeatureMonitorRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.GetFeatureMonitor`.
final class GetFeatureMonitorRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureMonitorRequest';

  /// Required. The name of the FeatureMonitor resource.
  final String name;

  GetFeatureMonitorRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureMonitorRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFeatureMonitorRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureMonitorRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.ListFeatureMonitors`.
final class ListFeatureMonitorsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureMonitorsRequest';

  /// Required. The resource name of the FeatureGroup to list FeatureMonitors.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  final String parent;

  /// Optional. Lists the FeatureMonitors that match the filter expression. The
  /// following fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    FeatureMonitors created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    FeatureGroups with label "env" set to "prod".
  final String filter;

  /// Optional. The maximum number of FeatureGroups to return. The service may
  /// return fewer than this value. If unspecified, at most 100 FeatureMonitors
  /// will be returned. The maximum value is 100; any value greater than 100 will
  /// be coerced to 100.
  final int pageSize;

  /// Optional. A page token, received from a previous
  /// `FeatureRegistryService.ListFeatureMonitors`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureRegistryService.ListFeatureMonitors`
  /// must match the call that provided the page token.
  final String pageToken;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  final String orderBy;

  ListFeatureMonitorsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureMonitorsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureMonitorsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureMonitorsRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.UpdateFeatureMonitor`.
final class UpdateFeatureMonitorRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureMonitorRequest';

  /// Required. The FeatureMonitor's `name` field is used to identify the
  /// FeatureMonitor to be updated. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  final FeatureMonitor? featureMonitor;

  /// Optional. Field mask is used to specify the fields to be overwritten in the
  /// FeatureMonitor resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  final protobuf.FieldMask? updateMask;

  UpdateFeatureMonitorRequest({required this.featureMonitor, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeatureMonitorRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureMonitorRequest(
      featureMonitor: switch (json['featureMonitor']) {
        null => null,
        Object $1 => FeatureMonitor.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureMonitor != null) 'featureMonitor': featureMonitor!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureMonitorRequest()';
}

/// Request message for
/// `FeatureRegistryService.DeleteFeatureMonitor`.
final class DeleteFeatureMonitorRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureMonitorRequest';

  /// Required. The name of the FeatureMonitor to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  final String name;

  DeleteFeatureMonitorRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteFeatureMonitorRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureMonitorRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteFeatureMonitorRequest($contents)';
  }
}

/// Response message for
/// `FeatureRegistryService.ListFeatureMonitors`.
final class ListFeatureMonitorsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureMonitorsResponse';

  /// The FeatureMonitors matching the request.
  final List<FeatureMonitor> featureMonitors;

  /// A token, which can be sent as
  /// `ListFeatureMonitorsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListFeatureMonitorsResponse({
    this.featureMonitors = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureMonitorsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureMonitorsResponse(
      featureMonitors: switch (json['featureMonitors']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) FeatureMonitor.fromJson(i)],
        _ => throw const FormatException('"featureMonitors" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureMonitors.isNotDefault)
      'featureMonitors': encodeList(featureMonitors),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFeatureMonitorsResponse($contents)';
  }
}

/// Details of operations that perform create FeatureGroup.
final class CreateFeatureGroupOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureGroupOperationMetadata';

  /// Operation metadata for FeatureGroup.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureGroupOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureGroupOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureGroupOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateFeatureGroupOperationMetadata()';
}

/// Details of operations that perform update FeatureGroup.
final class UpdateFeatureGroupOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureGroupOperationMetadata';

  /// Operation metadata for FeatureGroup.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureGroupOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureGroupOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureGroupOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureGroupOperationMetadata()';
}

/// Details of operations that perform create FeatureGroup.
final class CreateRegistryFeatureOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateRegistryFeatureOperationMetadata';

  /// Operation metadata for Feature.
  final GenericOperationMetadata? genericMetadata;

  CreateRegistryFeatureOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateRegistryFeatureOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateRegistryFeatureOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateRegistryFeatureOperationMetadata()';
}

/// Details of operations that perform update Feature.
final class UpdateFeatureOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureOperationMetadata';

  /// Operation metadata for Feature Update.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureOperationMetadata()';
}

/// Details of operations that perform create FeatureMonitor.
final class CreateFeatureMonitorOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureMonitorOperationMetadata';

  /// Operation metadata for Feature.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureMonitorOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureMonitorOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureMonitorOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateFeatureMonitorOperationMetadata()';
}

/// Details of operations that perform update FeatureMonitor.
final class UpdateFeatureMonitorOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureMonitorOperationMetadata';

  /// Operation metadata for FeatureMonitor.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureMonitorOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureMonitorOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureMonitorOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureMonitorOperationMetadata()';
}

/// Request message for
/// `FeatureRegistryService.CreateFeatureMonitorJobRequest`.
final class CreateFeatureMonitorJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureMonitorJobRequest';

  /// Required. The resource name of FeatureMonitor to create FeatureMonitorJob.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  final String parent;

  /// Required. The Monitor to create.
  final FeatureMonitorJob? featureMonitorJob;

  /// Optional. Output only. System-generated ID for feature monitor job.
  final int featureMonitorJobId;

  CreateFeatureMonitorJobRequest({
    required this.parent,
    required this.featureMonitorJob,
    this.featureMonitorJobId = 0,
  }) : super(fullyQualifiedName);

  factory CreateFeatureMonitorJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureMonitorJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureMonitorJob: switch (json['featureMonitorJob']) {
        null => null,
        Object $1 => FeatureMonitorJob.fromJson($1),
      },
      featureMonitorJobId: switch (json['featureMonitorJobId']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (featureMonitorJob != null)
      'featureMonitorJob': featureMonitorJob!.toJson(),
    if (featureMonitorJobId.isNotDefault)
      'featureMonitorJobId': encodeInt64(featureMonitorJobId),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'featureMonitorJobId=$featureMonitorJobId',
    ].join(',');
    return 'CreateFeatureMonitorJobRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.GetFeatureMonitorJob`.
final class GetFeatureMonitorJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureMonitorJobRequest';

  /// Required. The name of the FeatureMonitorJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}/featureMonitorJobs/{feature_monitor_job}`
  final String name;

  GetFeatureMonitorJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureMonitorJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFeatureMonitorJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureMonitorJobRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.ListFeatureMonitorJobs`.
final class ListFeatureMonitorJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureMonitorJobsRequest';

  /// Required. The resource name of the FeatureMonitor to list
  /// FeatureMonitorJobs. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  final String parent;

  /// Optional. Lists the FeatureMonitorJobs that match the filter expression.
  /// The following fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01"`
  ///    FeatureMonitorJobs created after 2020-01-01.
  final String filter;

  /// Optional. The maximum number of FeatureMonitorJobs to return. The service
  /// may return fewer than this value. If unspecified, at most 100
  /// FeatureMonitorJobs will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  final int pageSize;

  /// Optional. A page token, received from a previous
  /// `FeatureRegistryService.ListFeatureMonitorJobs`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureRegistryService.ListFeatureMonitorJobs`
  /// must match the call that provided the page token.
  final String pageToken;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported Fields:
  ///
  ///   * `create_time`
  final String orderBy;

  ListFeatureMonitorJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureMonitorJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureMonitorJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureMonitorJobsRequest($contents)';
  }
}

/// Response message for
/// `FeatureRegistryService.ListFeatureMonitorJobs`.
final class ListFeatureMonitorJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureMonitorJobsResponse';

  /// The FeatureMonitorJobs matching the request.
  final List<FeatureMonitorJob> featureMonitorJobs;

  /// A token, which can be sent as
  /// `ListFeatureMonitorJobsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListFeatureMonitorJobsResponse({
    this.featureMonitorJobs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListFeatureMonitorJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeatureMonitorJobsResponse(
      featureMonitorJobs: switch (json['featureMonitorJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) FeatureMonitorJob.fromJson(i)],
        _ => throw const FormatException('"featureMonitorJobs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureMonitorJobs.isNotDefault)
      'featureMonitorJobs': encodeList(featureMonitorJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFeatureMonitorJobsResponse($contents)';
  }
}

/// Matcher for Features of an EntityType by Feature ID.
final class IdMatcher extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IdMatcher';

  /// Required. The following are accepted as `ids`:
  ///
  ///  * A single-element list containing only `*`, which selects all Features
  ///  in the target EntityType, or
  ///  * A list containing only Feature IDs, which selects only Features with
  ///  those IDs in the target EntityType.
  final List<String> ids;

  IdMatcher({required this.ids}) : super(fullyQualifiedName);

  factory IdMatcher.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IdMatcher(
      ids: switch (json['ids']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"ids" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'ids': ids};

  @override
  String toString() => 'IdMatcher()';
}

/// Selector for Features of an EntityType.
final class FeatureSelector extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureSelector';

  /// Required. Matches Features based on ID.
  final IdMatcher? idMatcher;

  FeatureSelector({required this.idMatcher}) : super(fullyQualifiedName);

  factory FeatureSelector.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureSelector(
      idMatcher: switch (json['idMatcher']) {
        null => null,
        Object $1 => IdMatcher.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (idMatcher != null) 'idMatcher': idMatcher!.toJson()};

  @override
  String toString() => 'FeatureSelector()';
}

/// FeatureView is representation of values that the FeatureOnlineStore will
/// serve based on its syncConfig.
final class FeatureView extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView';

  /// Optional. Configures how data is supposed to be extracted from a BigQuery
  /// source to be loaded onto the FeatureOnlineStore.
  final FeatureView_BigQuerySource? bigQuerySource;

  /// Optional. Configures the features from a Feature Registry source that
  /// need to be loaded onto the FeatureOnlineStore.
  final FeatureView_FeatureRegistrySource? featureRegistrySource;

  /// Optional. The Vertex RAG Source that the FeatureView is linked to.
  final FeatureView_VertexRagSource? vertexRagSource;

  /// Identifier. Name of the FeatureView. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String name;

  /// Output only. Timestamp when this FeatureView was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this FeatureView was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureViews.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String> labels;

  /// Configures when data is to be synced/updated for this FeatureView. At the
  /// end of the sync the latest featureValues for each entityId of this
  /// FeatureView are made ready for online serving.
  final FeatureView_SyncConfig? syncConfig;

  /// Optional. Deprecated: please use
  /// `FeatureView.index_config`
  /// instead.
  final FeatureView_VectorSearchConfig? vectorSearchConfig;

  /// Optional. Configuration for index preparation for vector search. It
  /// contains the required configurations to create an index from source data,
  /// so that approximate nearest neighbor (a.k.a ANN) algorithms search can be
  /// performed during online serving.
  final FeatureView_IndexConfig? indexConfig;

  /// Optional. Configuration for FeatureView created under Optimized
  /// FeatureOnlineStore.
  final FeatureView_OptimizedConfig? optimizedConfig;

  /// Optional. Service agent type used during data sync. By default, the Vertex
  /// AI Service Agent is used. When using an IAM Policy to isolate this
  /// FeatureView within a project, a separate service account should be
  /// provisioned by setting this field to `SERVICE_AGENT_TYPE_FEATURE_VIEW`.
  /// This will generate a separate service account to access the BigQuery source
  /// table.
  final FeatureView_ServiceAgentType serviceAgentType;

  /// Output only. A Service Account unique to this FeatureView. The role
  /// bigquery.dataViewer should be granted to this service account to allow
  /// Vertex AI Feature Store to sync data to the online store.
  final String serviceAccountEmail;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  /// Metadata containing information about the Cloud Bigtable.
  final FeatureView_BigtableMetadata? bigtableMetadata;

  FeatureView({
    this.bigQuerySource,
    this.featureRegistrySource,
    this.vertexRagSource,
    this.name = '',
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.labels = const {},
    this.syncConfig,
    this.vectorSearchConfig,
    this.indexConfig,
    this.optimizedConfig,
    this.serviceAgentType = FeatureView_ServiceAgentType.$default,
    this.serviceAccountEmail = '',
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
    this.bigtableMetadata,
  }) : super(fullyQualifiedName);

  factory FeatureView.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView(
      bigQuerySource: switch (json['bigQuerySource']) {
        null => null,
        Object $1 => FeatureView_BigQuerySource.fromJson($1),
      },
      featureRegistrySource: switch (json['featureRegistrySource']) {
        null => null,
        Object $1 => FeatureView_FeatureRegistrySource.fromJson($1),
      },
      vertexRagSource: switch (json['vertexRagSource']) {
        null => null,
        Object $1 => FeatureView_VertexRagSource.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      syncConfig: switch (json['syncConfig']) {
        null => null,
        Object $1 => FeatureView_SyncConfig.fromJson($1),
      },
      vectorSearchConfig: switch (json['vectorSearchConfig']) {
        null => null,
        Object $1 => FeatureView_VectorSearchConfig.fromJson($1),
      },
      indexConfig: switch (json['indexConfig']) {
        null => null,
        Object $1 => FeatureView_IndexConfig.fromJson($1),
      },
      optimizedConfig: switch (json['optimizedConfig']) {
        null => null,
        Object $1 => FeatureView_OptimizedConfig.fromJson($1),
      },
      serviceAgentType: switch (json['serviceAgentType']) {
        null => FeatureView_ServiceAgentType.$default,
        Object $1 => FeatureView_ServiceAgentType.fromJson($1),
      },
      serviceAccountEmail: switch (json['serviceAccountEmail']) {
        null => '',
        Object $1 => decodeString($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      bigtableMetadata: switch (json['bigtableMetadata']) {
        null => null,
        Object $1 => FeatureView_BigtableMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bigQuerySource != null) 'bigQuerySource': bigQuerySource!.toJson(),
    if (featureRegistrySource != null)
      'featureRegistrySource': featureRegistrySource!.toJson(),
    if (vertexRagSource != null) 'vertexRagSource': vertexRagSource!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (syncConfig != null) 'syncConfig': syncConfig!.toJson(),
    if (vectorSearchConfig != null)
      'vectorSearchConfig': vectorSearchConfig!.toJson(),
    if (indexConfig != null) 'indexConfig': indexConfig!.toJson(),
    if (optimizedConfig != null) 'optimizedConfig': optimizedConfig!.toJson(),
    if (serviceAgentType.isNotDefault)
      'serviceAgentType': serviceAgentType.toJson(),
    if (serviceAccountEmail.isNotDefault)
      'serviceAccountEmail': serviceAccountEmail,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
    if (bigtableMetadata != null)
      'bigtableMetadata': bigtableMetadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'etag=$etag',
      'serviceAgentType=$serviceAgentType',
      'serviceAccountEmail=$serviceAccountEmail',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'FeatureView($contents)';
  }
}

final class FeatureView_BigQuerySource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.BigQuerySource';

  /// Required. The BigQuery view URI that will be materialized on each sync
  /// trigger based on FeatureView.SyncConfig.
  final String uri;

  /// Required. Columns to construct entity_id / row keys.
  final List<String> entityIdColumns;

  FeatureView_BigQuerySource({required this.uri, required this.entityIdColumns})
    : super(fullyQualifiedName);

  factory FeatureView_BigQuerySource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_BigQuerySource(
      uri: switch (json['uri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entityIdColumns: switch (json['entityIdColumns']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"entityIdColumns" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'uri': uri, 'entityIdColumns': entityIdColumns};

  @override
  String toString() {
    final contents = ['uri=$uri'].join(',');
    return 'BigQuerySource($contents)';
  }
}

/// Configuration for Sync. Only one option is set.
final class FeatureView_SyncConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.SyncConfig';

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs. To explicitly set a timezone to the cron tab, apply a prefix in
  /// the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
  /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
  /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
  /// "TZ=America/New_York 1 * * * *".
  final String cron;

  FeatureView_SyncConfig({this.cron = ''}) : super(fullyQualifiedName);

  factory FeatureView_SyncConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_SyncConfig(
      cron: switch (json['cron']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (cron.isNotDefault) 'cron': cron};

  @override
  String toString() {
    final contents = ['cron=$cron'].join(',');
    return 'SyncConfig($contents)';
  }
}

/// Deprecated. Use
/// `IndexConfig`
/// instead.
final class FeatureView_VectorSearchConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.VectorSearchConfig';

  /// Optional. Configuration options for the tree-AH algorithm (Shallow tree
  /// + Asymmetric Hashing). Please refer to this paper for more details:
  /// https://arxiv.org/abs/1908.10396
  final FeatureView_VectorSearchConfig_TreeAhconfig? treeAhConfig;

  /// Optional. Configuration options for using brute force search, which
  /// simply implements the standard linear search in the database for each
  /// query. It is primarily meant for benchmarking and to generate the
  /// ground truth for approximate search.
  final FeatureView_VectorSearchConfig_BruteForceConfig? bruteForceConfig;

  /// Optional. Column of embedding. This column contains the source data to
  /// create index for vector search. embedding_column must be set when using
  /// vector search.
  final String embeddingColumn;

  /// Optional. Columns of features that're used to filter vector search
  /// results.
  final List<String> filterColumns;

  /// Optional. Column of crowding. This column contains crowding attribute
  /// which is a constraint on a neighbor list produced by
  /// `FeatureOnlineStoreService.SearchNearestEntities`
  /// to diversify search results. If
  /// `NearestNeighborQuery.per_crowding_attribute_neighbor_count`
  /// is set to K in
  /// `SearchNearestEntitiesRequest`,
  /// it's guaranteed that no more than K entities of the same crowding
  /// attribute are returned in the response.
  final String crowdingColumn;

  /// Optional. The number of dimensions of the input embedding.
  final int? embeddingDimension;

  /// Optional. The distance measure used in nearest neighbor search.
  final FeatureView_VectorSearchConfig_DistanceMeasureType distanceMeasureType;

  FeatureView_VectorSearchConfig({
    this.treeAhConfig,
    this.bruteForceConfig,
    this.embeddingColumn = '',
    this.filterColumns = const [],
    this.crowdingColumn = '',
    this.embeddingDimension,
    this.distanceMeasureType =
        FeatureView_VectorSearchConfig_DistanceMeasureType.$default,
  }) : super(fullyQualifiedName);

  factory FeatureView_VectorSearchConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_VectorSearchConfig(
      treeAhConfig: switch (json['treeAhConfig']) {
        null => null,
        Object $1 => FeatureView_VectorSearchConfig_TreeAhconfig.fromJson($1),
      },
      bruteForceConfig: switch (json['bruteForceConfig']) {
        null => null,
        Object $1 => FeatureView_VectorSearchConfig_BruteForceConfig.fromJson(
          $1,
        ),
      },
      embeddingColumn: switch (json['embeddingColumn']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filterColumns: switch (json['filterColumns']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"filterColumns" is not a list'),
      },
      crowdingColumn: switch (json['crowdingColumn']) {
        null => '',
        Object $1 => decodeString($1),
      },
      embeddingDimension: switch (json['embeddingDimension']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      distanceMeasureType: switch (json['distanceMeasureType']) {
        null => FeatureView_VectorSearchConfig_DistanceMeasureType.$default,
        Object $1 =>
          FeatureView_VectorSearchConfig_DistanceMeasureType.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (treeAhConfig != null) 'treeAhConfig': treeAhConfig!.toJson(),
    if (bruteForceConfig != null)
      'bruteForceConfig': bruteForceConfig!.toJson(),
    if (embeddingColumn.isNotDefault) 'embeddingColumn': embeddingColumn,
    if (filterColumns.isNotDefault) 'filterColumns': filterColumns,
    if (crowdingColumn.isNotDefault) 'crowdingColumn': crowdingColumn,
    if (embeddingDimension != null) 'embeddingDimension': embeddingDimension,
    if (distanceMeasureType.isNotDefault)
      'distanceMeasureType': distanceMeasureType.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'embeddingColumn=$embeddingColumn',
      'crowdingColumn=$crowdingColumn',
      if (embeddingDimension != null) 'embeddingDimension=$embeddingDimension',
      'distanceMeasureType=$distanceMeasureType',
    ].join(',');
    return 'VectorSearchConfig($contents)';
  }
}

final class FeatureView_VectorSearchConfig_BruteForceConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.VectorSearchConfig.BruteForceConfig';

  FeatureView_VectorSearchConfig_BruteForceConfig() : super(fullyQualifiedName);

  factory FeatureView_VectorSearchConfig_BruteForceConfig.fromJson(Object? j) =>
      FeatureView_VectorSearchConfig_BruteForceConfig();

  @override
  Object toJson() => {};

  @override
  String toString() => 'BruteForceConfig()';
}

final class FeatureView_VectorSearchConfig_TreeAhconfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.VectorSearchConfig.TreeAHConfig';

  /// Optional. Number of embeddings on each leaf node. The default value is
  /// 1000 if not set.
  final int? leafNodeEmbeddingCount;

  FeatureView_VectorSearchConfig_TreeAhconfig({this.leafNodeEmbeddingCount})
    : super(fullyQualifiedName);

  factory FeatureView_VectorSearchConfig_TreeAhconfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_VectorSearchConfig_TreeAhconfig(
      leafNodeEmbeddingCount: switch (json['leafNodeEmbeddingCount']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (leafNodeEmbeddingCount != null)
      'leafNodeEmbeddingCount': encodeInt64(leafNodeEmbeddingCount),
  };

  @override
  String toString() {
    final contents = [
      if (leafNodeEmbeddingCount != null)
        'leafNodeEmbeddingCount=$leafNodeEmbeddingCount',
    ].join(',');
    return 'TreeAHConfig($contents)';
  }
}

final class FeatureView_VectorSearchConfig_DistanceMeasureType
    extends ProtoEnum {
  /// Should not be set.
  static const distanceMeasureTypeUnspecified =
      FeatureView_VectorSearchConfig_DistanceMeasureType(
        'DISTANCE_MEASURE_TYPE_UNSPECIFIED',
      );

  /// Euclidean (L_2) Distance.
  static const squaredL2Distance =
      FeatureView_VectorSearchConfig_DistanceMeasureType('SQUARED_L2_DISTANCE');

  /// Cosine Distance. Defined as 1 - cosine similarity.
  ///
  /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead
  /// of COSINE distance. Our algorithms have been more optimized for
  /// DOT_PRODUCT distance which, when combined with UNIT_L2_NORM, is
  /// mathematically equivalent to COSINE distance and results in the same
  /// ranking.
  static const cosineDistance =
      FeatureView_VectorSearchConfig_DistanceMeasureType('COSINE_DISTANCE');

  /// Dot Product Distance. Defined as a negative of the dot product.
  static const dotProductDistance =
      FeatureView_VectorSearchConfig_DistanceMeasureType(
        'DOT_PRODUCT_DISTANCE',
      );

  /// The default value for [FeatureView_VectorSearchConfig_DistanceMeasureType].
  static const $default = distanceMeasureTypeUnspecified;

  const FeatureView_VectorSearchConfig_DistanceMeasureType(super.value);

  factory FeatureView_VectorSearchConfig_DistanceMeasureType.fromJson(
    Object? json,
  ) => FeatureView_VectorSearchConfig_DistanceMeasureType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DistanceMeasureType.$value';
}

/// Configuration for vector indexing.
final class FeatureView_IndexConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.IndexConfig';

  /// Optional. Configuration options for the tree-AH algorithm (Shallow tree
  /// + Asymmetric Hashing). Please refer to this paper for more details:
  /// https://arxiv.org/abs/1908.10396
  final FeatureView_IndexConfig_TreeAhconfig? treeAhConfig;

  /// Optional. Configuration options for using brute force search, which
  /// simply implements the standard linear search in the database for each
  /// query. It is primarily meant for benchmarking and to generate the
  /// ground truth for approximate search.
  final FeatureView_IndexConfig_BruteForceConfig? bruteForceConfig;

  /// Optional. Column of embedding. This column contains the source data to
  /// create index for vector search. embedding_column must be set when using
  /// vector search.
  final String embeddingColumn;

  /// Optional. Columns of features that're used to filter vector search
  /// results.
  final List<String> filterColumns;

  /// Optional. Column of crowding. This column contains crowding attribute
  /// which is a constraint on a neighbor list produced by
  /// `FeatureOnlineStoreService.SearchNearestEntities`
  /// to diversify search results. If
  /// `NearestNeighborQuery.per_crowding_attribute_neighbor_count`
  /// is set to K in
  /// `SearchNearestEntitiesRequest`,
  /// it's guaranteed that no more than K entities of the same crowding
  /// attribute are returned in the response.
  final String crowdingColumn;

  /// Optional. The number of dimensions of the input embedding.
  final int? embeddingDimension;

  /// Optional. The distance measure used in nearest neighbor search.
  final FeatureView_IndexConfig_DistanceMeasureType distanceMeasureType;

  FeatureView_IndexConfig({
    this.treeAhConfig,
    this.bruteForceConfig,
    this.embeddingColumn = '',
    this.filterColumns = const [],
    this.crowdingColumn = '',
    this.embeddingDimension,
    this.distanceMeasureType =
        FeatureView_IndexConfig_DistanceMeasureType.$default,
  }) : super(fullyQualifiedName);

  factory FeatureView_IndexConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_IndexConfig(
      treeAhConfig: switch (json['treeAhConfig']) {
        null => null,
        Object $1 => FeatureView_IndexConfig_TreeAhconfig.fromJson($1),
      },
      bruteForceConfig: switch (json['bruteForceConfig']) {
        null => null,
        Object $1 => FeatureView_IndexConfig_BruteForceConfig.fromJson($1),
      },
      embeddingColumn: switch (json['embeddingColumn']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filterColumns: switch (json['filterColumns']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"filterColumns" is not a list'),
      },
      crowdingColumn: switch (json['crowdingColumn']) {
        null => '',
        Object $1 => decodeString($1),
      },
      embeddingDimension: switch (json['embeddingDimension']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      distanceMeasureType: switch (json['distanceMeasureType']) {
        null => FeatureView_IndexConfig_DistanceMeasureType.$default,
        Object $1 => FeatureView_IndexConfig_DistanceMeasureType.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (treeAhConfig != null) 'treeAhConfig': treeAhConfig!.toJson(),
    if (bruteForceConfig != null)
      'bruteForceConfig': bruteForceConfig!.toJson(),
    if (embeddingColumn.isNotDefault) 'embeddingColumn': embeddingColumn,
    if (filterColumns.isNotDefault) 'filterColumns': filterColumns,
    if (crowdingColumn.isNotDefault) 'crowdingColumn': crowdingColumn,
    if (embeddingDimension != null) 'embeddingDimension': embeddingDimension,
    if (distanceMeasureType.isNotDefault)
      'distanceMeasureType': distanceMeasureType.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'embeddingColumn=$embeddingColumn',
      'crowdingColumn=$crowdingColumn',
      if (embeddingDimension != null) 'embeddingDimension=$embeddingDimension',
      'distanceMeasureType=$distanceMeasureType',
    ].join(',');
    return 'IndexConfig($contents)';
  }
}

/// Configuration options for using brute force search.
final class FeatureView_IndexConfig_BruteForceConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.IndexConfig.BruteForceConfig';

  FeatureView_IndexConfig_BruteForceConfig() : super(fullyQualifiedName);

  factory FeatureView_IndexConfig_BruteForceConfig.fromJson(Object? j) =>
      FeatureView_IndexConfig_BruteForceConfig();

  @override
  Object toJson() => {};

  @override
  String toString() => 'BruteForceConfig()';
}

/// Configuration options for the tree-AH algorithm.
final class FeatureView_IndexConfig_TreeAhconfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.IndexConfig.TreeAHConfig';

  /// Optional. Number of embeddings on each leaf node. The default value is
  /// 1000 if not set.
  final int? leafNodeEmbeddingCount;

  FeatureView_IndexConfig_TreeAhconfig({this.leafNodeEmbeddingCount})
    : super(fullyQualifiedName);

  factory FeatureView_IndexConfig_TreeAhconfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_IndexConfig_TreeAhconfig(
      leafNodeEmbeddingCount: switch (json['leafNodeEmbeddingCount']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (leafNodeEmbeddingCount != null)
      'leafNodeEmbeddingCount': encodeInt64(leafNodeEmbeddingCount),
  };

  @override
  String toString() {
    final contents = [
      if (leafNodeEmbeddingCount != null)
        'leafNodeEmbeddingCount=$leafNodeEmbeddingCount',
    ].join(',');
    return 'TreeAHConfig($contents)';
  }
}

/// The distance measure used in nearest neighbor search.
final class FeatureView_IndexConfig_DistanceMeasureType extends ProtoEnum {
  /// Should not be set.
  static const distanceMeasureTypeUnspecified =
      FeatureView_IndexConfig_DistanceMeasureType(
        'DISTANCE_MEASURE_TYPE_UNSPECIFIED',
      );

  /// Euclidean (L_2) Distance.
  static const squaredL2Distance = FeatureView_IndexConfig_DistanceMeasureType(
    'SQUARED_L2_DISTANCE',
  );

  /// Cosine Distance. Defined as 1 - cosine similarity.
  ///
  /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead
  /// of COSINE distance. Our algorithms have been more optimized for
  /// DOT_PRODUCT distance which, when combined with UNIT_L2_NORM, is
  /// mathematically equivalent to COSINE distance and results in the same
  /// ranking.
  static const cosineDistance = FeatureView_IndexConfig_DistanceMeasureType(
    'COSINE_DISTANCE',
  );

  /// Dot Product Distance. Defined as a negative of the dot product.
  static const dotProductDistance = FeatureView_IndexConfig_DistanceMeasureType(
    'DOT_PRODUCT_DISTANCE',
  );

  /// The default value for [FeatureView_IndexConfig_DistanceMeasureType].
  static const $default = distanceMeasureTypeUnspecified;

  const FeatureView_IndexConfig_DistanceMeasureType(super.value);

  factory FeatureView_IndexConfig_DistanceMeasureType.fromJson(Object? json) =>
      FeatureView_IndexConfig_DistanceMeasureType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DistanceMeasureType.$value';
}

/// A Feature Registry source for features that need to be synced to Online
/// Store.
final class FeatureView_FeatureRegistrySource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.FeatureRegistrySource';

  /// Required. List of features that need to be synced to Online Store.
  final List<FeatureView_FeatureRegistrySource_FeatureGroup> featureGroups;

  /// Optional. The project number of the parent project of the Feature Groups.
  final int? projectNumber;

  FeatureView_FeatureRegistrySource({
    required this.featureGroups,
    this.projectNumber,
  }) : super(fullyQualifiedName);

  factory FeatureView_FeatureRegistrySource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_FeatureRegistrySource(
      featureGroups: switch (json['featureGroups']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            FeatureView_FeatureRegistrySource_FeatureGroup.fromJson(i),
        ],
        _ => throw const FormatException('"featureGroups" is not a list'),
      },
      projectNumber: switch (json['projectNumber']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    'featureGroups': encodeList(featureGroups),
    if (projectNumber != null) 'projectNumber': encodeInt64(projectNumber),
  };

  @override
  String toString() {
    final contents = [
      if (projectNumber != null) 'projectNumber=$projectNumber',
    ].join(',');
    return 'FeatureRegistrySource($contents)';
  }
}

/// Features belonging to a single feature group that will be
/// synced to Online Store.
final class FeatureView_FeatureRegistrySource_FeatureGroup
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.FeatureRegistrySource.FeatureGroup';

  /// Required. Identifier of the feature group.
  final String featureGroupId;

  /// Required. Identifiers of features under the feature group.
  final List<String> featureIds;

  FeatureView_FeatureRegistrySource_FeatureGroup({
    required this.featureGroupId,
    required this.featureIds,
  }) : super(fullyQualifiedName);

  factory FeatureView_FeatureRegistrySource_FeatureGroup.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_FeatureRegistrySource_FeatureGroup(
      featureGroupId: switch (json['featureGroupId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureIds: switch (json['featureIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"featureIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'featureGroupId': featureGroupId,
    'featureIds': featureIds,
  };

  @override
  String toString() {
    final contents = ['featureGroupId=$featureGroupId'].join(',');
    return 'FeatureGroup($contents)';
  }
}

/// A Vertex Rag source for features that need to be synced to Online
/// Store.
final class FeatureView_VertexRagSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.VertexRagSource';

  /// Required. The BigQuery view/table URI that will be materialized on each
  /// manual sync trigger. The table/view is expected to have the following
  /// columns and types at least:
  ///  - `corpus_id` (STRING, NULLABLE/REQUIRED)
  ///  - `file_id` (STRING, NULLABLE/REQUIRED)
  ///  - `chunk_id` (STRING, NULLABLE/REQUIRED)
  ///  - `chunk_data_type` (STRING, NULLABLE/REQUIRED)
  ///  - `chunk_data` (STRING, NULLABLE/REQUIRED)
  ///  - `embeddings` (FLOAT, REPEATED)
  ///  - `file_original_uri` (STRING, NULLABLE/REQUIRED)
  final String uri;

  /// Optional. The RAG corpus id corresponding to this FeatureView.
  final int ragCorpusId;

  FeatureView_VertexRagSource({required this.uri, this.ragCorpusId = 0})
    : super(fullyQualifiedName);

  factory FeatureView_VertexRagSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_VertexRagSource(
      uri: switch (json['uri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ragCorpusId: switch (json['ragCorpusId']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    'uri': uri,
    if (ragCorpusId.isNotDefault) 'ragCorpusId': encodeInt64(ragCorpusId),
  };

  @override
  String toString() {
    final contents = ['uri=$uri', 'ragCorpusId=$ragCorpusId'].join(',');
    return 'VertexRagSource($contents)';
  }
}

/// Configuration for FeatureViews created in Optimized FeatureOnlineStore.
final class FeatureView_OptimizedConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.OptimizedConfig';

  /// Optional. A description of resources that the FeatureView uses, which to
  /// large degree are decided by Vertex AI, and optionally allows only a
  /// modest additional configuration. If min_replica_count is not set, the
  /// default value is 2. If max_replica_count is not set, the default value
  /// is 6. The max allowed replica count is 1000.
  final AutomaticResources? automaticResources;

  FeatureView_OptimizedConfig({this.automaticResources})
    : super(fullyQualifiedName);

  factory FeatureView_OptimizedConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_OptimizedConfig(
      automaticResources: switch (json['automaticResources']) {
        null => null,
        Object $1 => AutomaticResources.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (automaticResources != null)
      'automaticResources': automaticResources!.toJson(),
  };

  @override
  String toString() => 'OptimizedConfig()';
}

/// Metadata for the Cloud Bigtable that supports directly interacting Bigtable
/// instances.
final class FeatureView_BigtableMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.BigtableMetadata';

  /// The Bigtable App Profile to use for reading from Bigtable.
  final String readAppProfile;

  FeatureView_BigtableMetadata({this.readAppProfile = ''})
    : super(fullyQualifiedName);

  factory FeatureView_BigtableMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureView_BigtableMetadata(
      readAppProfile: switch (json['readAppProfile']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (readAppProfile.isNotDefault) 'readAppProfile': readAppProfile,
  };

  @override
  String toString() {
    final contents = ['readAppProfile=$readAppProfile'].join(',');
    return 'BigtableMetadata($contents)';
  }
}

/// Service agent type used during data sync.
final class FeatureView_ServiceAgentType extends ProtoEnum {
  /// By default, the project-level Vertex AI Service Agent is enabled.
  static const serviceAgentTypeUnspecified = FeatureView_ServiceAgentType(
    'SERVICE_AGENT_TYPE_UNSPECIFIED',
  );

  /// Indicates the project-level Vertex AI Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used during sync jobs.
  static const serviceAgentTypeProject = FeatureView_ServiceAgentType(
    'SERVICE_AGENT_TYPE_PROJECT',
  );

  /// Enable a FeatureView service account to be created by Vertex AI and
  /// output in the field `service_account_email`. This service account will
  /// be used to read from the source BigQuery table during sync.
  static const serviceAgentTypeFeatureView = FeatureView_ServiceAgentType(
    'SERVICE_AGENT_TYPE_FEATURE_VIEW',
  );

  /// The default value for [FeatureView_ServiceAgentType].
  static const $default = serviceAgentTypeUnspecified;

  const FeatureView_ServiceAgentType(super.value);

  factory FeatureView_ServiceAgentType.fromJson(Object? json) =>
      FeatureView_ServiceAgentType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ServiceAgentType.$value';
}

/// FeatureViewSync is a representation of sync operation which copies data from
/// data source to Feature View in Online Store.
final class FeatureViewSync extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewSync';

  /// Identifier. Name of the FeatureViewSync. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  final String name;

  /// Output only. Time when this FeatureViewSync is created. Creation of a
  /// FeatureViewSync means that the job is pending / waiting for sufficient
  /// resources but may not have started the actual data transfer yet.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when this FeatureViewSync is finished.
  final Interval? runTime;

  /// Output only. Final status of the FeatureViewSync.
  final Status? finalStatus;

  /// Output only. Summary of the sync job.
  final FeatureViewSync_SyncSummary? syncSummary;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  FeatureViewSync({
    this.name = '',
    this.createTime,
    this.runTime,
    this.finalStatus,
    this.syncSummary,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory FeatureViewSync.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureViewSync(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      runTime: switch (json['runTime']) {
        null => null,
        Object $1 => Interval.fromJson($1),
      },
      finalStatus: switch (json['finalStatus']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      syncSummary: switch (json['syncSummary']) {
        null => null,
        Object $1 => FeatureViewSync_SyncSummary.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (runTime != null) 'runTime': runTime!.toJson(),
    if (finalStatus != null) 'finalStatus': finalStatus!.toJson(),
    if (syncSummary != null) 'syncSummary': syncSummary!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'FeatureViewSync($contents)';
  }
}

/// Summary from the Sync job. For continuous syncs, the summary is updated
/// periodically. For batch syncs, it gets updated on completion of the sync.
final class FeatureViewSync_SyncSummary extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewSync.SyncSummary';

  /// Output only. Total number of rows synced.
  final int rowSynced;

  /// Output only. BigQuery slot milliseconds consumed for the sync job.
  final int totalSlot;

  /// Lower bound of the system time watermark for the sync job. This is only
  /// set for continuously syncing feature views.
  final protobuf.Timestamp? systemWatermarkTime;

  FeatureViewSync_SyncSummary({
    this.rowSynced = 0,
    this.totalSlot = 0,
    this.systemWatermarkTime,
  }) : super(fullyQualifiedName);

  factory FeatureViewSync_SyncSummary.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureViewSync_SyncSummary(
      rowSynced: switch (json['rowSynced']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      totalSlot: switch (json['totalSlot']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      systemWatermarkTime: switch (json['systemWatermarkTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (rowSynced.isNotDefault) 'rowSynced': encodeInt64(rowSynced),
    if (totalSlot.isNotDefault) 'totalSlot': encodeInt64(totalSlot),
    if (systemWatermarkTime != null)
      'systemWatermarkTime': systemWatermarkTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['rowSynced=$rowSynced', 'totalSlot=$totalSlot'].join(',');
    return 'SyncSummary($contents)';
  }
}

/// Vertex AI Feature Store provides a centralized repository for organizing,
/// storing, and serving ML features. The Featurestore is a top-level container
/// for your features and their values.
final class Featurestore extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Featurestore';

  /// Output only. Name of the Featurestore. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String name;

  /// Output only. Timestamp when this Featurestore was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Featurestore was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// Featurestore.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one Featurestore(System
  /// labels are excluded)."
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> labels;

  /// Optional. Config for online storage resources. The field should not
  /// co-exist with the field of `OnlineStoreReplicationConfig`. If both of it
  /// and OnlineStoreReplicationConfig are unset, the feature store will not have
  /// an online store and cannot be used for online serving.
  final Featurestore_OnlineServingConfig? onlineServingConfig;

  /// Output only. State of the featurestore.
  final Featurestore_State state;

  /// Optional. TTL in days for feature values that will be stored in online
  /// serving storage. The Feature Store online storage periodically removes
  /// obsolete feature values older than `online_storage_ttl_days` since the
  /// feature generation time. Note that `online_storage_ttl_days` should be less
  /// than or equal to `offline_storage_ttl_days` for each EntityType under a
  /// featurestore. If not set, default to 4000 days
  final int onlineStorageTtlDays;

  /// Optional. Customer-managed encryption key spec for data storage. If set,
  /// both of the online and offline data storage will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  Featurestore({
    this.name = '',
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.labels = const {},
    this.onlineServingConfig,
    this.state = Featurestore_State.$default,
    this.onlineStorageTtlDays = 0,
    this.encryptionSpec,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory Featurestore.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Featurestore(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      onlineServingConfig: switch (json['onlineServingConfig']) {
        null => null,
        Object $1 => Featurestore_OnlineServingConfig.fromJson($1),
      },
      state: switch (json['state']) {
        null => Featurestore_State.$default,
        Object $1 => Featurestore_State.fromJson($1),
      },
      onlineStorageTtlDays: switch (json['onlineStorageTtlDays']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (onlineServingConfig != null)
      'onlineServingConfig': onlineServingConfig!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (onlineStorageTtlDays.isNotDefault)
      'onlineStorageTtlDays': onlineStorageTtlDays,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'etag=$etag',
      'state=$state',
      'onlineStorageTtlDays=$onlineStorageTtlDays',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Featurestore($contents)';
  }
}

/// OnlineServingConfig specifies the details for provisioning online serving
/// resources.
final class Featurestore_OnlineServingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Featurestore.OnlineServingConfig';

  /// The number of nodes for the online store. The number of nodes doesn't
  /// scale automatically, but you can manually update the number of
  /// nodes. If set to 0, the featurestore will not have an
  /// online store and cannot be used for online serving.
  final int fixedNodeCount;

  /// Online serving scaling configuration.
  /// Only one of `fixed_node_count` and `scaling` can be set. Setting one will
  /// reset the other.
  final Featurestore_OnlineServingConfig_Scaling? scaling;

  Featurestore_OnlineServingConfig({this.fixedNodeCount = 0, this.scaling})
    : super(fullyQualifiedName);

  factory Featurestore_OnlineServingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Featurestore_OnlineServingConfig(
      fixedNodeCount: switch (json['fixedNodeCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      scaling: switch (json['scaling']) {
        null => null,
        Object $1 => Featurestore_OnlineServingConfig_Scaling.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (fixedNodeCount.isNotDefault) 'fixedNodeCount': fixedNodeCount,
    if (scaling != null) 'scaling': scaling!.toJson(),
  };

  @override
  String toString() {
    final contents = ['fixedNodeCount=$fixedNodeCount'].join(',');
    return 'OnlineServingConfig($contents)';
  }
}

/// Online serving scaling configuration. If min_node_count and
/// max_node_count are set to the same value, the cluster will be configured
/// with the fixed number of node (no auto-scaling).
final class Featurestore_OnlineServingConfig_Scaling extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Featurestore.OnlineServingConfig.Scaling';

  /// Required. The minimum number of nodes to scale down to. Must be greater
  /// than or equal to 1.
  final int minNodeCount;

  /// The maximum number of nodes to scale up to. Must be greater than
  /// min_node_count, and less than or equal to 10 times of 'min_node_count'.
  final int maxNodeCount;

  /// Optional. The cpu utilization that the Autoscaler should be trying to
  /// achieve. This number is on a scale from 0 (no utilization) to 100
  /// (total utilization), and is limited between 10 and 80. When a cluster's
  /// CPU utilization exceeds the target that you have set, Bigtable
  /// immediately adds nodes to the cluster. When CPU utilization is
  /// substantially lower than the target, Bigtable removes nodes. If not set
  /// or set to 0, default to 50.
  final int cpuUtilizationTarget;

  Featurestore_OnlineServingConfig_Scaling({
    required this.minNodeCount,
    this.maxNodeCount = 0,
    this.cpuUtilizationTarget = 0,
  }) : super(fullyQualifiedName);

  factory Featurestore_OnlineServingConfig_Scaling.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Featurestore_OnlineServingConfig_Scaling(
      minNodeCount: switch (json['minNodeCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      maxNodeCount: switch (json['maxNodeCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      cpuUtilizationTarget: switch (json['cpuUtilizationTarget']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    'minNodeCount': minNodeCount,
    if (maxNodeCount.isNotDefault) 'maxNodeCount': maxNodeCount,
    if (cpuUtilizationTarget.isNotDefault)
      'cpuUtilizationTarget': cpuUtilizationTarget,
  };

  @override
  String toString() {
    final contents = [
      'minNodeCount=$minNodeCount',
      'maxNodeCount=$maxNodeCount',
      'cpuUtilizationTarget=$cpuUtilizationTarget',
    ].join(',');
    return 'Scaling($contents)';
  }
}

/// Possible states a featurestore can have.
final class Featurestore_State extends ProtoEnum {
  /// Default value. This value is unused.
  static const stateUnspecified = Featurestore_State('STATE_UNSPECIFIED');

  /// State when the featurestore configuration is not being updated and the
  /// fields reflect the current configuration of the featurestore. The
  /// featurestore is usable in this state.
  static const stable = Featurestore_State('STABLE');

  /// The state of the featurestore configuration when it is being updated.
  /// During an update, the fields reflect either the original configuration
  /// or the updated configuration of the featurestore. For example,
  /// `online_serving_config.fixed_node_count` can take minutes to update.
  /// While the update is in progress, the featurestore is in the UPDATING
  /// state, and the value of `fixed_node_count` can be the original value or
  /// the updated value, depending on the progress of the operation. Until the
  /// update completes, the actual number of nodes can still be the original
  /// value of `fixed_node_count`. The featurestore is still usable in this
  /// state.
  static const updating = Featurestore_State('UPDATING');

  /// The default value for [Featurestore_State].
  static const $default = stateUnspecified;

  const Featurestore_State(super.value);

  factory Featurestore_State.fromJson(Object? json) =>
      Featurestore_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Configuration of how features in Featurestore are monitored.
final class FeaturestoreMonitoringConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeaturestoreMonitoringConfig';

  /// The config for Snapshot Analysis Based Feature Monitoring.
  final FeaturestoreMonitoringConfig_SnapshotAnalysis? snapshotAnalysis;

  /// The config for ImportFeatures Analysis Based Feature Monitoring.
  final FeaturestoreMonitoringConfig_ImportFeaturesAnalysis?
  importFeaturesAnalysis;

  /// Threshold for numerical features of anomaly detection.
  /// This is shared by all objectives of Featurestore Monitoring for numerical
  /// features (i.e. Features with type
  /// (`Feature.ValueType`)
  /// DOUBLE or INT64).
  final FeaturestoreMonitoringConfig_ThresholdConfig? numericalThresholdConfig;

  /// Threshold for categorical features of anomaly detection.
  /// This is shared by all types of Featurestore Monitoring for categorical
  /// features (i.e. Features with type
  /// (`Feature.ValueType`)
  /// BOOL or STRING).
  final FeaturestoreMonitoringConfig_ThresholdConfig?
  categoricalThresholdConfig;

  FeaturestoreMonitoringConfig({
    this.snapshotAnalysis,
    this.importFeaturesAnalysis,
    this.numericalThresholdConfig,
    this.categoricalThresholdConfig,
  }) : super(fullyQualifiedName);

  factory FeaturestoreMonitoringConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeaturestoreMonitoringConfig(
      snapshotAnalysis: switch (json['snapshotAnalysis']) {
        null => null,
        Object $1 => FeaturestoreMonitoringConfig_SnapshotAnalysis.fromJson($1),
      },
      importFeaturesAnalysis: switch (json['importFeaturesAnalysis']) {
        null => null,
        Object $1 =>
          FeaturestoreMonitoringConfig_ImportFeaturesAnalysis.fromJson($1),
      },
      numericalThresholdConfig: switch (json['numericalThresholdConfig']) {
        null => null,
        Object $1 => FeaturestoreMonitoringConfig_ThresholdConfig.fromJson($1),
      },
      categoricalThresholdConfig: switch (json['categoricalThresholdConfig']) {
        null => null,
        Object $1 => FeaturestoreMonitoringConfig_ThresholdConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (snapshotAnalysis != null)
      'snapshotAnalysis': snapshotAnalysis!.toJson(),
    if (importFeaturesAnalysis != null)
      'importFeaturesAnalysis': importFeaturesAnalysis!.toJson(),
    if (numericalThresholdConfig != null)
      'numericalThresholdConfig': numericalThresholdConfig!.toJson(),
    if (categoricalThresholdConfig != null)
      'categoricalThresholdConfig': categoricalThresholdConfig!.toJson(),
  };

  @override
  String toString() => 'FeaturestoreMonitoringConfig()';
}

/// Configuration of the Featurestore's Snapshot Analysis Based Monitoring.
/// This type of analysis generates statistics for each Feature based on a
/// snapshot of the latest feature value of each entities every
/// monitoring_interval.
final class FeaturestoreMonitoringConfig_SnapshotAnalysis extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeaturestoreMonitoringConfig.SnapshotAnalysis';

  /// The monitoring schedule for snapshot analysis.
  /// For EntityType-level config:
  ///   unset / disabled = true indicates disabled by
  ///   default for Features under it; otherwise by default enable snapshot
  ///   analysis monitoring with monitoring_interval for Features under it.
  /// Feature-level config:
  ///   disabled = true indicates disabled regardless of the EntityType-level
  ///   config; unset monitoring_interval indicates going with EntityType-level
  ///   config; otherwise run snapshot analysis monitoring with
  ///   monitoring_interval regardless of the EntityType-level config.
  /// Explicitly Disable the snapshot analysis based monitoring.
  final bool disabled;

  /// Configuration of the snapshot analysis based monitoring pipeline running
  /// interval. The value is rolled up to full day.
  /// If both
  /// `monitoring_interval_days`
  /// and the deprecated `monitoring_interval` field
  /// are set when creating/updating EntityTypes/Features,
  /// `monitoring_interval_days`
  /// will be used.
  final protobuf.Duration? monitoringInterval;

  /// Configuration of the snapshot analysis based monitoring pipeline
  /// running interval. The value indicates number of days.
  final int monitoringIntervalDays;

  /// Customized export features time window for snapshot analysis. Unit is one
  /// day. Default value is 3 weeks. Minimum value is 1 day. Maximum value is
  /// 4000 days.
  final int stalenessDays;

  FeaturestoreMonitoringConfig_SnapshotAnalysis({
    this.disabled = false,
    this.monitoringInterval,
    this.monitoringIntervalDays = 0,
    this.stalenessDays = 0,
  }) : super(fullyQualifiedName);

  factory FeaturestoreMonitoringConfig_SnapshotAnalysis.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeaturestoreMonitoringConfig_SnapshotAnalysis(
      disabled: switch (json['disabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      monitoringInterval: switch (json['monitoringInterval']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      monitoringIntervalDays: switch (json['monitoringIntervalDays']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      stalenessDays: switch (json['stalenessDays']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (disabled.isNotDefault) 'disabled': disabled,
    if (monitoringInterval != null)
      'monitoringInterval': monitoringInterval!.toJson(),
    if (monitoringIntervalDays.isNotDefault)
      'monitoringIntervalDays': monitoringIntervalDays,
    if (stalenessDays.isNotDefault) 'stalenessDays': stalenessDays,
  };

  @override
  String toString() {
    final contents = [
      'disabled=$disabled',
      'monitoringIntervalDays=$monitoringIntervalDays',
      'stalenessDays=$stalenessDays',
    ].join(',');
    return 'SnapshotAnalysis($contents)';
  }
}

/// Configuration of the Featurestore's ImportFeature Analysis Based
/// Monitoring. This type of analysis generates statistics for values of each
/// Feature imported by every
/// `ImportFeatureValues`
/// operation.
final class FeaturestoreMonitoringConfig_ImportFeaturesAnalysis
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis';

  /// Whether to enable / disable / inherite default hebavior for import
  /// features analysis.
  final FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State state;

  /// The baseline used to do anomaly detection for the statistics generated by
  /// import features analysis.
  final FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline
  anomalyDetectionBaseline;

  FeaturestoreMonitoringConfig_ImportFeaturesAnalysis({
    this.state =
        FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State.$default,
    this.anomalyDetectionBaseline =
        FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline.$default,
  }) : super(fullyQualifiedName);

  factory FeaturestoreMonitoringConfig_ImportFeaturesAnalysis.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return FeaturestoreMonitoringConfig_ImportFeaturesAnalysis(
      state: switch (json['state']) {
        null =>
          FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State.$default,
        Object $1 =>
          FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State.fromJson(
            $1,
          ),
      },
      anomalyDetectionBaseline: switch (json['anomalyDetectionBaseline']) {
        null =>
          FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline.$default,
        Object $1 =>
          FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (state.isNotDefault) 'state': state.toJson(),
    if (anomalyDetectionBaseline.isNotDefault)
      'anomalyDetectionBaseline': anomalyDetectionBaseline.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'state=$state',
      'anomalyDetectionBaseline=$anomalyDetectionBaseline',
    ].join(',');
    return 'ImportFeaturesAnalysis($contents)';
  }
}

/// The state defines whether to enable ImportFeature analysis.
final class FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State
    extends ProtoEnum {
  /// Should not be used.
  static const stateUnspecified =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State(
        'STATE_UNSPECIFIED',
      );

  /// The default behavior of whether to enable the monitoring.
  /// EntityType-level config: disabled.
  /// Feature-level config: inherited from the configuration of EntityType
  /// this Feature belongs to.
  static const default$ =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State('DEFAULT');

  /// Explicitly enables import features analysis.
  /// EntityType-level config: by default enables import features analysis
  /// for all Features under it. Feature-level config: enables import
  /// features analysis regardless of the EntityType-level config.
  static const enabled =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State('ENABLED');

  /// Explicitly disables import features analysis.
  /// EntityType-level config: by default disables import features analysis
  /// for all Features under it. Feature-level config: disables import
  /// features analysis regardless of the EntityType-level config.
  static const disabled =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State('DISABLED');

  /// The default value for [FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State].
  static const $default = stateUnspecified;

  const FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State(super.value);

  factory FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State.fromJson(
    Object? json,
  ) =>
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Defines the baseline to do anomaly detection for feature values imported
/// by each
/// `ImportFeatureValues`
/// operation.
final class FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline
    extends ProtoEnum {
  /// Should not be used.
  static const baselineUnspecified =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
        'BASELINE_UNSPECIFIED',
      );

  /// Choose the later one statistics generated by either most recent
  /// snapshot analysis or previous import features analysis. If non of them
  /// exists, skip anomaly detection and only generate a statistics.
  static const latestStats =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
        'LATEST_STATS',
      );

  /// Use the statistics generated by the most recent snapshot analysis if
  /// exists.
  static const mostRecentSnapshotStats =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
        'MOST_RECENT_SNAPSHOT_STATS',
      );

  /// Use the statistics generated by the previous import features analysis
  /// if exists.
  static const previousImportFeaturesStats =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
        'PREVIOUS_IMPORT_FEATURES_STATS',
      );

  /// The default value for [FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline].
  static const $default = baselineUnspecified;

  const FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
    super.value,
  );

  factory FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline.fromJson(
    Object? json,
  ) => FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
    json as String,
  );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Baseline.$value';
}

/// The config for Featurestore Monitoring threshold.
final class FeaturestoreMonitoringConfig_ThresholdConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeaturestoreMonitoringConfig.ThresholdConfig';

  /// Specify a threshold value that can trigger the alert.
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm.
  /// 2. For numerical feature, the distribution distance is calculated by
  /// JensenShannon divergence. Each feature must have a non-zero threshold
  /// if they need to be monitored. Otherwise no alert will be triggered for
  /// that feature.
  final double? value;

  FeaturestoreMonitoringConfig_ThresholdConfig({this.value})
    : super(fullyQualifiedName);

  factory FeaturestoreMonitoringConfig_ThresholdConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeaturestoreMonitoringConfig_ThresholdConfig(
      value: switch (json['value']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (value != null) 'value': encodeDouble(value)};

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'ThresholdConfig($contents)';
  }
}

/// Request message for
/// `FeaturestoreOnlineServingService.WriteFeatureValues`.
final class WriteFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteFeatureValuesRequest';

  /// Required. The resource name of the EntityType for the entities being
  /// written. Value format:
  /// `projects/{project}/locations/{location}/featurestores/
  /// {featurestore}/entityTypes/{entityType}`. For example,
  /// for a machine learning model predicting user clicks on a website, an
  /// EntityType ID could be `user`.
  final String entityType;

  /// Required. The entities to be written. Up to 100,000 feature values can be
  /// written across all `payloads`.
  final List<WriteFeatureValuesPayload> payloads;

  WriteFeatureValuesRequest({required this.entityType, required this.payloads})
    : super(fullyQualifiedName);

  factory WriteFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return WriteFeatureValuesRequest(
      entityType: switch (json['entityType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      payloads: switch (json['payloads']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) WriteFeatureValuesPayload.fromJson(i),
        ],
        _ => throw const FormatException('"payloads" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'entityType': entityType,
    'payloads': encodeList(payloads),
  };

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'WriteFeatureValuesRequest($contents)';
  }
}

/// Contains Feature values to be written for a specific entity.
final class WriteFeatureValuesPayload extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteFeatureValuesPayload';

  /// Required. The ID of the entity.
  final String entityId;

  /// Required. Feature values to be written, mapping from Feature ID to value.
  /// Up to 100,000 `feature_values` entries may be written across all payloads.
  /// The feature generation time, aligned by days, must be no older than five
  /// years (1825 days) and no later than one year (366 days) in the future.
  final Map<String, FeatureValue> featureValues;

  WriteFeatureValuesPayload({
    required this.entityId,
    required this.featureValues,
  }) : super(fullyQualifiedName);

  factory WriteFeatureValuesPayload.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return WriteFeatureValuesPayload(
      entityId: switch (json['entityId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureValues: switch (json['featureValues']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): FeatureValue.fromJson(e.value),
        },
        _ => throw const FormatException('"featureValues" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    'entityId': entityId,
    'featureValues': encodeMap(featureValues),
  };

  @override
  String toString() {
    final contents = ['entityId=$entityId'].join(',');
    return 'WriteFeatureValuesPayload($contents)';
  }
}

/// Response message for
/// `FeaturestoreOnlineServingService.WriteFeatureValues`.
final class WriteFeatureValuesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteFeatureValuesResponse';

  WriteFeatureValuesResponse() : super(fullyQualifiedName);

  factory WriteFeatureValuesResponse.fromJson(Object? j) =>
      WriteFeatureValuesResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'WriteFeatureValuesResponse()';
}

/// Request message for
/// `FeaturestoreOnlineServingService.ReadFeatureValues`.
final class ReadFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesRequest';

  /// Required. The resource name of the EntityType for the entity being read.
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an EntityType ID could be `user`.
  final String entityType;

  /// Required. ID for a specific entity. For example,
  /// for a machine learning model predicting user clicks on a website, an entity
  /// ID could be `user_123`.
  final String entityId;

  /// Required. Selector choosing Features of the target EntityType.
  final FeatureSelector? featureSelector;

  ReadFeatureValuesRequest({
    required this.entityType,
    required this.entityId,
    required this.featureSelector,
  }) : super(fullyQualifiedName);

  factory ReadFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadFeatureValuesRequest(
      entityType: switch (json['entityType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entityId: switch (json['entityId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureSelector: switch (json['featureSelector']) {
        null => null,
        Object $1 => FeatureSelector.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'entityType': entityType,
    'entityId': entityId,
    if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
  };

  @override
  String toString() {
    final contents = ['entityType=$entityType', 'entityId=$entityId'].join(',');
    return 'ReadFeatureValuesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreOnlineServingService.ReadFeatureValues`.
final class ReadFeatureValuesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse';

  /// Response header.
  final ReadFeatureValuesResponse_Header? header;

  /// Entity view with Feature values. This may be the entity in the
  /// Featurestore if values for all Features were requested, or a projection
  /// of the entity in the Featurestore if values for only some Features were
  /// requested.
  final ReadFeatureValuesResponse_EntityView? entityView;

  ReadFeatureValuesResponse({this.header, this.entityView})
    : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadFeatureValuesResponse(
      header: switch (json['header']) {
        null => null,
        Object $1 => ReadFeatureValuesResponse_Header.fromJson($1),
      },
      entityView: switch (json['entityView']) {
        null => null,
        Object $1 => ReadFeatureValuesResponse_EntityView.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (header != null) 'header': header!.toJson(),
    if (entityView != null) 'entityView': entityView!.toJson(),
  };

  @override
  String toString() => 'ReadFeatureValuesResponse()';
}

/// Metadata for requested Features.
final class ReadFeatureValuesResponse_FeatureDescriptor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse.FeatureDescriptor';

  /// Feature ID.
  final String id;

  ReadFeatureValuesResponse_FeatureDescriptor({this.id = ''})
    : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse_FeatureDescriptor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadFeatureValuesResponse_FeatureDescriptor(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (id.isNotDefault) 'id': id};

  @override
  String toString() {
    final contents = ['id=$id'].join(',');
    return 'FeatureDescriptor($contents)';
  }
}

/// Response header with metadata for the requested
/// `ReadFeatureValuesRequest.entity_type`
/// and Features.
final class ReadFeatureValuesResponse_Header extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse.Header';

  /// The resource name of the EntityType from the
  /// `ReadFeatureValuesRequest`.
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  final String entityType;

  /// List of Feature metadata corresponding to each piece of
  /// `ReadFeatureValuesResponse.EntityView.data`.
  final List<ReadFeatureValuesResponse_FeatureDescriptor> featureDescriptors;

  ReadFeatureValuesResponse_Header({
    this.entityType = '',
    this.featureDescriptors = const [],
  }) : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse_Header.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadFeatureValuesResponse_Header(
      entityType: switch (json['entityType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureDescriptors: switch (json['featureDescriptors']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ReadFeatureValuesResponse_FeatureDescriptor.fromJson(i),
        ],
        _ => throw const FormatException('"featureDescriptors" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (entityType.isNotDefault) 'entityType': entityType,
    if (featureDescriptors.isNotDefault)
      'featureDescriptors': encodeList(featureDescriptors),
  };

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'Header($contents)';
  }
}

/// Entity view with Feature values.
final class ReadFeatureValuesResponse_EntityView extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse.EntityView';

  /// ID of the requested entity.
  final String entityId;

  /// Each piece of data holds the k
  /// requested values for one requested Feature. If no values
  /// for the requested Feature exist, the corresponding cell will be empty.
  /// This has the same size and is in the same order as the features from the
  /// header
  /// `ReadFeatureValuesResponse.header`.
  final List<ReadFeatureValuesResponse_EntityView_Data> data;

  ReadFeatureValuesResponse_EntityView({
    this.entityId = '',
    this.data = const [],
  }) : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse_EntityView.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadFeatureValuesResponse_EntityView(
      entityId: switch (json['entityId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      data: switch (json['data']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ReadFeatureValuesResponse_EntityView_Data.fromJson(i),
        ],
        _ => throw const FormatException('"data" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (entityId.isNotDefault) 'entityId': entityId,
    if (data.isNotDefault) 'data': encodeList(data),
  };

  @override
  String toString() {
    final contents = ['entityId=$entityId'].join(',');
    return 'EntityView($contents)';
  }
}

/// Container to hold value(s), successive in time, for one Feature from the
/// request.
final class ReadFeatureValuesResponse_EntityView_Data extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse.EntityView.Data';

  /// Feature value if a single value is requested.
  final FeatureValue? value;

  /// Feature values list if values, successive in time, are requested.
  /// If the requested number of values is greater than the number of
  /// existing Feature values, nonexistent values are omitted instead of
  /// being returned as empty.
  final FeatureValueList? values;

  ReadFeatureValuesResponse_EntityView_Data({this.value, this.values})
    : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse_EntityView_Data.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadFeatureValuesResponse_EntityView_Data(
      value: switch (json['value']) {
        null => null,
        Object $1 => FeatureValue.fromJson($1),
      },
      values: switch (json['values']) {
        null => null,
        Object $1 => FeatureValueList.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (value != null) 'value': value!.toJson(),
    if (values != null) 'values': values!.toJson(),
  };

  @override
  String toString() => 'Data()';
}

/// Request message for
/// `FeaturestoreOnlineServingService.StreamingReadFeatureValues`.
final class StreamingReadFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingReadFeatureValuesRequest';

  /// Required. The resource name of the entities' type.
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example,
  /// for a machine learning model predicting user clicks on a website, an
  /// EntityType ID could be `user`.
  final String entityType;

  /// Required. IDs of entities to read Feature values of. The maximum number of
  /// IDs is 100. For example, for a machine learning model predicting user
  /// clicks on a website, an entity ID could be `user_123`.
  final List<String> entityIds;

  /// Required. Selector choosing Features of the target EntityType. Feature IDs
  /// will be deduplicated.
  final FeatureSelector? featureSelector;

  StreamingReadFeatureValuesRequest({
    required this.entityType,
    required this.entityIds,
    required this.featureSelector,
  }) : super(fullyQualifiedName);

  factory StreamingReadFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamingReadFeatureValuesRequest(
      entityType: switch (json['entityType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entityIds: switch (json['entityIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"entityIds" is not a list'),
      },
      featureSelector: switch (json['featureSelector']) {
        null => null,
        Object $1 => FeatureSelector.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'entityType': entityType,
    'entityIds': entityIds,
    if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
  };

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'StreamingReadFeatureValuesRequest($contents)';
  }
}

/// Value for a feature.
final class FeatureValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureValue';

  /// Bool type feature value.
  final bool? boolValue;

  /// Double type feature value.
  final double? doubleValue;

  /// Int64 feature value.
  final int? int64Value;

  /// String feature value.
  final String? stringValue;

  /// A list of bool type feature value.
  final BoolArray? boolArrayValue;

  /// A list of double type feature value.
  final DoubleArray? doubleArrayValue;

  /// A list of int64 type feature value.
  final Int64Array? int64ArrayValue;

  /// A list of string type feature value.
  final StringArray? stringArrayValue;

  /// Bytes feature value.
  final Uint8List? bytesValue;

  /// A struct type feature value.
  final StructValue? structValue;

  /// Metadata of feature value.
  final FeatureValue_Metadata? metadata;

  FeatureValue({
    this.boolValue,
    this.doubleValue,
    this.int64Value,
    this.stringValue,
    this.boolArrayValue,
    this.doubleArrayValue,
    this.int64ArrayValue,
    this.stringArrayValue,
    this.bytesValue,
    this.structValue,
    this.metadata,
  }) : super(fullyQualifiedName);

  factory FeatureValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureValue(
      boolValue: switch (json['boolValue']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      doubleValue: switch (json['doubleValue']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      int64Value: switch (json['int64Value']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      stringValue: switch (json['stringValue']) {
        null => null,
        Object $1 => decodeString($1),
      },
      boolArrayValue: switch (json['boolArrayValue']) {
        null => null,
        Object $1 => BoolArray.fromJson($1),
      },
      doubleArrayValue: switch (json['doubleArrayValue']) {
        null => null,
        Object $1 => DoubleArray.fromJson($1),
      },
      int64ArrayValue: switch (json['int64ArrayValue']) {
        null => null,
        Object $1 => Int64Array.fromJson($1),
      },
      stringArrayValue: switch (json['stringArrayValue']) {
        null => null,
        Object $1 => StringArray.fromJson($1),
      },
      bytesValue: switch (json['bytesValue']) {
        null => null,
        Object $1 => decodeBytes($1),
      },
      structValue: switch (json['structValue']) {
        null => null,
        Object $1 => StructValue.fromJson($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => FeatureValue_Metadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (boolValue != null) 'boolValue': boolValue,
    if (doubleValue != null) 'doubleValue': encodeDouble(doubleValue),
    if (int64Value != null) 'int64Value': encodeInt64(int64Value),
    if (stringValue != null) 'stringValue': stringValue,
    if (boolArrayValue != null) 'boolArrayValue': boolArrayValue!.toJson(),
    if (doubleArrayValue != null)
      'doubleArrayValue': doubleArrayValue!.toJson(),
    if (int64ArrayValue != null) 'int64ArrayValue': int64ArrayValue!.toJson(),
    if (stringArrayValue != null)
      'stringArrayValue': stringArrayValue!.toJson(),
    if (bytesValue != null) 'bytesValue': encodeBytes(bytesValue),
    if (structValue != null) 'structValue': structValue!.toJson(),
    if (metadata != null) 'metadata': metadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (boolValue != null) 'boolValue=$boolValue',
      if (doubleValue != null) 'doubleValue=$doubleValue',
      if (int64Value != null) 'int64Value=$int64Value',
      if (stringValue != null) 'stringValue=$stringValue',
      if (bytesValue != null) 'bytesValue=$bytesValue',
    ].join(',');
    return 'FeatureValue($contents)';
  }
}

/// Metadata of feature value.
final class FeatureValue_Metadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureValue.Metadata';

  /// Feature generation timestamp. Typically, it is provided by user at
  /// feature ingestion time. If not, feature store
  /// will use the system timestamp when the data is ingested into feature
  /// store.
  ///
  /// Legacy Feature Store: For streaming ingestion, the time, aligned by days,
  /// must be no older than five years (1825 days) and no later than one year
  /// (366 days) in the future.
  final protobuf.Timestamp? generateTime;

  FeatureValue_Metadata({this.generateTime}) : super(fullyQualifiedName);

  factory FeatureValue_Metadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureValue_Metadata(
      generateTime: switch (json['generateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (generateTime != null) 'generateTime': generateTime!.toJson(),
  };

  @override
  String toString() => 'Metadata()';
}

/// Struct (or object) type feature value.
final class StructValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StructValue';

  /// A list of field values.
  final List<StructFieldValue> values;

  StructValue({this.values = const []}) : super(fullyQualifiedName);

  factory StructValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StructValue(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) StructFieldValue.fromJson(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (values.isNotDefault) 'values': encodeList(values)};

  @override
  String toString() => 'StructValue()';
}

/// One field of a Struct (or object) type feature value.
final class StructFieldValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StructFieldValue';

  /// Name of the field in the struct feature.
  final String name;

  /// The value for this field.
  final FeatureValue? value;

  StructFieldValue({this.name = '', this.value}) : super(fullyQualifiedName);

  factory StructFieldValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StructFieldValue(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      value: switch (json['value']) {
        null => null,
        Object $1 => FeatureValue.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (value != null) 'value': value!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StructFieldValue($contents)';
  }
}

/// Container for list of values.
final class FeatureValueList extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureValueList';

  /// A list of feature values. All of them should be the same data type.
  final List<FeatureValue> values;

  FeatureValueList({this.values = const []}) : super(fullyQualifiedName);

  factory FeatureValueList.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureValueList(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) FeatureValue.fromJson(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (values.isNotDefault) 'values': encodeList(values)};

  @override
  String toString() => 'FeatureValueList()';
}

/// Request message for
/// `FeaturestoreService.CreateFeaturestore`.
final class CreateFeaturestoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeaturestoreRequest';

  /// Required. The resource name of the Location to create Featurestores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Featurestore to create.
  final Featurestore? featurestore;

  /// Required. The ID to use for this Featurestore, which will become the final
  /// component of the Featurestore's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the project and location.
  final String featurestoreId;

  CreateFeaturestoreRequest({
    required this.parent,
    required this.featurestore,
    required this.featurestoreId,
  }) : super(fullyQualifiedName);

  factory CreateFeaturestoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeaturestoreRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featurestore: switch (json['featurestore']) {
        null => null,
        Object $1 => Featurestore.fromJson($1),
      },
      featurestoreId: switch (json['featurestoreId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (featurestore != null) 'featurestore': featurestore!.toJson(),
    'featurestoreId': featurestoreId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'featurestoreId=$featurestoreId',
    ].join(',');
    return 'CreateFeaturestoreRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.GetFeaturestore`.
final class GetFeaturestoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeaturestoreRequest';

  /// Required. The name of the Featurestore resource.
  final String name;

  GetFeaturestoreRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeaturestoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFeaturestoreRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeaturestoreRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ListFeaturestores`.
final class ListFeaturestoresRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeaturestoresRequest';

  /// Required. The resource name of the Location to list Featurestores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the featurestores that match the filter expression. The following
  /// fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `online_serving_config.fixed_node_count`: Supports `=`, `!=`, `<`, `>`,
  /// `<=`, and `>=` comparisons.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    Featurestores created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    Featurestores with label "env" set to "prod".
  final String filter;

  /// The maximum number of Featurestores to return. The service may return fewer
  /// than this value. If unspecified, at most 100 Featurestores will be
  /// returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `FeaturestoreService.ListFeaturestores`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeaturestoreService.ListFeaturestores`
  /// must match the call that provided the page token.
  final String pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  ///   * `online_serving_config.fixed_node_count`
  final String orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListFeaturestoresRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListFeaturestoresRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeaturestoresRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListFeaturestoresRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.ListFeaturestores`.
final class ListFeaturestoresResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeaturestoresResponse';

  /// The Featurestores matching the request.
  final List<Featurestore> featurestores;

  /// A token, which can be sent as
  /// `ListFeaturestoresRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListFeaturestoresResponse({
    this.featurestores = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListFeaturestoresResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeaturestoresResponse(
      featurestores: switch (json['featurestores']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Featurestore.fromJson(i)],
        _ => throw const FormatException('"featurestores" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featurestores.isNotDefault) 'featurestores': encodeList(featurestores),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFeaturestoresResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.UpdateFeaturestore`.
final class UpdateFeaturestoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeaturestoreRequest';

  /// Required. The Featurestore's `name` field is used to identify the
  /// Featurestore to be updated. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final Featurestore? featurestore;

  /// Field mask is used to specify the fields to be overwritten in the
  /// Featurestore resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `online_serving_config.fixed_node_count`
  ///   * `online_serving_config.scaling`
  ///   * `online_storage_ttl_days`
  final protobuf.FieldMask? updateMask;

  UpdateFeaturestoreRequest({required this.featurestore, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeaturestoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeaturestoreRequest(
      featurestore: switch (json['featurestore']) {
        null => null,
        Object $1 => Featurestore.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featurestore != null) 'featurestore': featurestore!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateFeaturestoreRequest()';
}

/// Request message for
/// `FeaturestoreService.DeleteFeaturestore`.
final class DeleteFeaturestoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeaturestoreRequest';

  /// Required. The name of the Featurestore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String name;

  /// If set to true, any EntityTypes and Features for this Featurestore will
  /// also be deleted. (Otherwise, the request will only work if the Featurestore
  /// has no EntityTypes.)
  final bool force;

  DeleteFeaturestoreRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteFeaturestoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeaturestoreRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteFeaturestoreRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ImportFeatureValues`.
final class ImportFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportFeatureValuesRequest';

  final AvroSource? avroSource;

  final BigQuerySource? bigquerySource;

  final CsvSource? csvSource;

  /// Source column that holds the Feature timestamp for all Feature
  /// values in each entity.
  final String? featureTimeField;

  /// Single Feature timestamp for all entities being imported. The
  /// timestamp must not have higher than millisecond precision.
  final protobuf.Timestamp? featureTime;

  /// Required. The resource name of the EntityType grouping the Features for
  /// which values are being imported. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  final String entityType;

  /// Source column that holds entity IDs. If not provided, entity IDs are
  /// extracted from the column named entity_id.
  final String entityIdField;

  /// Required. Specifications defining which Feature values to import from the
  /// entity. The request fails if no feature_specs are provided, and having
  /// multiple feature_specs for one Feature is not allowed.
  final List<ImportFeatureValuesRequest_FeatureSpec> featureSpecs;

  /// If set, data will not be imported for online serving. This
  /// is typically used for backfilling, where Feature generation timestamps are
  /// not in the timestamp range needed for online serving.
  final bool disableOnlineServing;

  /// Specifies the number of workers that are used to write data to the
  /// Featurestore. Consider the online serving capacity that you require to
  /// achieve the desired import throughput without interfering with online
  /// serving. The value must be positive, and less than or equal to 100.
  /// If not set, defaults to using 1 worker. The low count ensures minimal
  /// impact on online serving performance.
  final int workerCount;

  /// If true, API doesn't start ingestion analysis pipeline.
  final bool disableIngestionAnalysis;

  ImportFeatureValuesRequest({
    this.avroSource,
    this.bigquerySource,
    this.csvSource,
    this.featureTimeField,
    this.featureTime,
    required this.entityType,
    this.entityIdField = '',
    required this.featureSpecs,
    this.disableOnlineServing = false,
    this.workerCount = 0,
    this.disableIngestionAnalysis = false,
  }) : super(fullyQualifiedName);

  factory ImportFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportFeatureValuesRequest(
      avroSource: switch (json['avroSource']) {
        null => null,
        Object $1 => AvroSource.fromJson($1),
      },
      bigquerySource: switch (json['bigquerySource']) {
        null => null,
        Object $1 => BigQuerySource.fromJson($1),
      },
      csvSource: switch (json['csvSource']) {
        null => null,
        Object $1 => CsvSource.fromJson($1),
      },
      featureTimeField: switch (json['featureTimeField']) {
        null => null,
        Object $1 => decodeString($1),
      },
      featureTime: switch (json['featureTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      entityType: switch (json['entityType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entityIdField: switch (json['entityIdField']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureSpecs: switch (json['featureSpecs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ImportFeatureValuesRequest_FeatureSpec.fromJson(i),
        ],
        _ => throw const FormatException('"featureSpecs" is not a list'),
      },
      disableOnlineServing: switch (json['disableOnlineServing']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      workerCount: switch (json['workerCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      disableIngestionAnalysis: switch (json['disableIngestionAnalysis']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (avroSource != null) 'avroSource': avroSource!.toJson(),
    if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
    if (csvSource != null) 'csvSource': csvSource!.toJson(),
    if (featureTimeField != null) 'featureTimeField': featureTimeField,
    if (featureTime != null) 'featureTime': featureTime!.toJson(),
    'entityType': entityType,
    if (entityIdField.isNotDefault) 'entityIdField': entityIdField,
    'featureSpecs': encodeList(featureSpecs),
    if (disableOnlineServing.isNotDefault)
      'disableOnlineServing': disableOnlineServing,
    if (workerCount.isNotDefault) 'workerCount': workerCount,
    if (disableIngestionAnalysis.isNotDefault)
      'disableIngestionAnalysis': disableIngestionAnalysis,
  };

  @override
  String toString() {
    final contents = [
      if (featureTimeField != null) 'featureTimeField=$featureTimeField',
      'entityType=$entityType',
      'entityIdField=$entityIdField',
      'disableOnlineServing=$disableOnlineServing',
      'workerCount=$workerCount',
      'disableIngestionAnalysis=$disableIngestionAnalysis',
    ].join(',');
    return 'ImportFeatureValuesRequest($contents)';
  }
}

/// Defines the Feature value(s) to import.
final class ImportFeatureValuesRequest_FeatureSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportFeatureValuesRequest.FeatureSpec';

  /// Required. ID of the Feature to import values of. This Feature must exist
  /// in the target EntityType, or the request will fail.
  final String id;

  /// Source column to get the Feature values from. If not set, uses the column
  /// with the same name as the Feature ID.
  final String sourceField;

  ImportFeatureValuesRequest_FeatureSpec({
    required this.id,
    this.sourceField = '',
  }) : super(fullyQualifiedName);

  factory ImportFeatureValuesRequest_FeatureSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportFeatureValuesRequest_FeatureSpec(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sourceField: switch (json['sourceField']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'id': id,
    if (sourceField.isNotDefault) 'sourceField': sourceField,
  };

  @override
  String toString() {
    final contents = ['id=$id', 'sourceField=$sourceField'].join(',');
    return 'FeatureSpec($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.ImportFeatureValues`.
final class ImportFeatureValuesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportFeatureValuesResponse';

  /// Number of entities that have been imported by the operation.
  final int importedEntityCount;

  /// Number of Feature values that have been imported by the operation.
  final int importedFeatureValueCount;

  /// The number of rows in input source that weren't imported due to either
  /// * Not having any featureValues.
  /// * Having a null entityId.
  /// * Having a null timestamp.
  /// * Not being parsable (applicable for CSV sources).
  final int invalidRowCount;

  /// The number rows that weren't ingested due to having feature timestamps
  /// outside the retention boundary.
  final int timestampOutsideRetentionRowsCount;

  ImportFeatureValuesResponse({
    this.importedEntityCount = 0,
    this.importedFeatureValueCount = 0,
    this.invalidRowCount = 0,
    this.timestampOutsideRetentionRowsCount = 0,
  }) : super(fullyQualifiedName);

  factory ImportFeatureValuesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportFeatureValuesResponse(
      importedEntityCount: switch (json['importedEntityCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      importedFeatureValueCount: switch (json['importedFeatureValueCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      invalidRowCount: switch (json['invalidRowCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      timestampOutsideRetentionRowsCount:
          switch (json['timestampOutsideRetentionRowsCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (importedEntityCount.isNotDefault)
      'importedEntityCount': encodeInt64(importedEntityCount),
    if (importedFeatureValueCount.isNotDefault)
      'importedFeatureValueCount': encodeInt64(importedFeatureValueCount),
    if (invalidRowCount.isNotDefault)
      'invalidRowCount': encodeInt64(invalidRowCount),
    if (timestampOutsideRetentionRowsCount.isNotDefault)
      'timestampOutsideRetentionRowsCount': encodeInt64(
        timestampOutsideRetentionRowsCount,
      ),
  };

  @override
  String toString() {
    final contents = [
      'importedEntityCount=$importedEntityCount',
      'importedFeatureValueCount=$importedFeatureValueCount',
      'invalidRowCount=$invalidRowCount',
      'timestampOutsideRetentionRowsCount=$timestampOutsideRetentionRowsCount',
    ].join(',');
    return 'ImportFeatureValuesResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.BatchReadFeatureValues`.
final class BatchReadFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesRequest';

  /// Each read instance consists of exactly one read timestamp and one or more
  /// entity IDs identifying entities of the corresponding EntityTypes whose
  /// Features are requested.
  ///
  /// Each output instance contains Feature values of requested entities
  /// concatenated together as of the read time.
  ///
  /// An example read instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z`.
  ///
  /// An example output instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
  /// bar_entity_feature2_value`.
  ///
  /// Timestamp in each read instance must be millisecond-aligned.
  ///
  /// `csv_read_instances` are read instances stored in a plain-text CSV file.
  /// The header should be:
  ///     [ENTITY_TYPE_ID1], [ENTITY_TYPE_ID2], ..., timestamp
  ///
  /// The columns can be in any order.
  ///
  /// Values in the timestamp column must use the RFC 3339 format, e.g.
  /// `2012-07-30T10:43:17.123Z`.
  final CsvSource? csvReadInstances;

  /// Similar to csv_read_instances, but from BigQuery source.
  final BigQuerySource? bigqueryReadInstances;

  /// Required. The resource name of the Featurestore from which to query Feature
  /// values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String featurestore;

  /// Required. Specifies output location and format.
  final FeatureValueDestination? destination;

  /// When not empty, the specified fields in the *_read_instances source will be
  /// joined as-is in the output, in addition to those fields from the
  /// Featurestore Entity.
  ///
  /// For BigQuery source, the type of the pass-through values will be
  /// automatically inferred. For CSV source, the pass-through values will be
  /// passed as opaque bytes.
  final List<BatchReadFeatureValuesRequest_PassThroughField> passThroughFields;

  /// Required. Specifies EntityType grouping Features to read values of and
  /// settings.
  final List<BatchReadFeatureValuesRequest_EntityTypeSpec> entityTypeSpecs;

  /// Optional. Excludes Feature values with feature generation timestamp before
  /// this timestamp. If not set, retrieve oldest values kept in Feature Store.
  /// Timestamp, if present, must not have higher than millisecond precision.
  final protobuf.Timestamp? startTime;

  BatchReadFeatureValuesRequest({
    this.csvReadInstances,
    this.bigqueryReadInstances,
    required this.featurestore,
    required this.destination,
    this.passThroughFields = const [],
    required this.entityTypeSpecs,
    this.startTime,
  }) : super(fullyQualifiedName);

  factory BatchReadFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchReadFeatureValuesRequest(
      csvReadInstances: switch (json['csvReadInstances']) {
        null => null,
        Object $1 => CsvSource.fromJson($1),
      },
      bigqueryReadInstances: switch (json['bigqueryReadInstances']) {
        null => null,
        Object $1 => BigQuerySource.fromJson($1),
      },
      featurestore: switch (json['featurestore']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destination: switch (json['destination']) {
        null => null,
        Object $1 => FeatureValueDestination.fromJson($1),
      },
      passThroughFields: switch (json['passThroughFields']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            BatchReadFeatureValuesRequest_PassThroughField.fromJson(i),
        ],
        _ => throw const FormatException('"passThroughFields" is not a list'),
      },
      entityTypeSpecs: switch (json['entityTypeSpecs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            BatchReadFeatureValuesRequest_EntityTypeSpec.fromJson(i),
        ],
        _ => throw const FormatException('"entityTypeSpecs" is not a list'),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (csvReadInstances != null)
      'csvReadInstances': csvReadInstances!.toJson(),
    if (bigqueryReadInstances != null)
      'bigqueryReadInstances': bigqueryReadInstances!.toJson(),
    'featurestore': featurestore,
    if (destination != null) 'destination': destination!.toJson(),
    if (passThroughFields.isNotDefault)
      'passThroughFields': encodeList(passThroughFields),
    'entityTypeSpecs': encodeList(entityTypeSpecs),
    if (startTime != null) 'startTime': startTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['featurestore=$featurestore'].join(',');
    return 'BatchReadFeatureValuesRequest($contents)';
  }
}

/// Describe pass-through fields in read_instance source.
final class BatchReadFeatureValuesRequest_PassThroughField
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesRequest.PassThroughField';

  /// Required. The name of the field in the CSV header or the name of the
  /// column in BigQuery table. The naming restriction is the same as
  /// `Feature.name`.
  final String fieldName;

  BatchReadFeatureValuesRequest_PassThroughField({required this.fieldName})
    : super(fullyQualifiedName);

  factory BatchReadFeatureValuesRequest_PassThroughField.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchReadFeatureValuesRequest_PassThroughField(
      fieldName: switch (json['fieldName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'fieldName': fieldName};

  @override
  String toString() {
    final contents = ['fieldName=$fieldName'].join(',');
    return 'PassThroughField($contents)';
  }
}

/// Selects Features of an EntityType to read values of and specifies read
/// settings.
final class BatchReadFeatureValuesRequest_EntityTypeSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesRequest.EntityTypeSpec';

  /// Required. ID of the EntityType to select Features. The EntityType id is
  /// the
  /// `entity_type_id`
  /// specified during EntityType creation.
  final String entityTypeId;

  /// Required. Selectors choosing which Feature values to read from the
  /// EntityType.
  final FeatureSelector? featureSelector;

  /// Per-Feature settings for the batch read.
  final List<DestinationFeatureSetting> settings;

  BatchReadFeatureValuesRequest_EntityTypeSpec({
    required this.entityTypeId,
    required this.featureSelector,
    this.settings = const [],
  }) : super(fullyQualifiedName);

  factory BatchReadFeatureValuesRequest_EntityTypeSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchReadFeatureValuesRequest_EntityTypeSpec(
      entityTypeId: switch (json['entityTypeId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureSelector: switch (json['featureSelector']) {
        null => null,
        Object $1 => FeatureSelector.fromJson($1),
      },
      settings: switch (json['settings']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) DestinationFeatureSetting.fromJson(i),
        ],
        _ => throw const FormatException('"settings" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'entityTypeId': entityTypeId,
    if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
    if (settings.isNotDefault) 'settings': encodeList(settings),
  };

  @override
  String toString() {
    final contents = ['entityTypeId=$entityTypeId'].join(',');
    return 'EntityTypeSpec($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ExportFeatureValues`.
final class ExportFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesRequest';

  /// Exports the latest Feature values of all entities of the EntityType
  /// within a time range.
  final ExportFeatureValuesRequest_SnapshotExport? snapshotExport;

  /// Exports all historical values of all entities of the EntityType within a
  /// time range
  final ExportFeatureValuesRequest_FullExport? fullExport;

  /// Required. The resource name of the EntityType from which to export Feature
  /// values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  final String entityType;

  /// Required. Specifies destination location and format.
  final FeatureValueDestination? destination;

  /// Required. Selects Features to export values of.
  final FeatureSelector? featureSelector;

  /// Per-Feature export settings.
  final List<DestinationFeatureSetting> settings;

  ExportFeatureValuesRequest({
    this.snapshotExport,
    this.fullExport,
    required this.entityType,
    required this.destination,
    required this.featureSelector,
    this.settings = const [],
  }) : super(fullyQualifiedName);

  factory ExportFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportFeatureValuesRequest(
      snapshotExport: switch (json['snapshotExport']) {
        null => null,
        Object $1 => ExportFeatureValuesRequest_SnapshotExport.fromJson($1),
      },
      fullExport: switch (json['fullExport']) {
        null => null,
        Object $1 => ExportFeatureValuesRequest_FullExport.fromJson($1),
      },
      entityType: switch (json['entityType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destination: switch (json['destination']) {
        null => null,
        Object $1 => FeatureValueDestination.fromJson($1),
      },
      featureSelector: switch (json['featureSelector']) {
        null => null,
        Object $1 => FeatureSelector.fromJson($1),
      },
      settings: switch (json['settings']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) DestinationFeatureSetting.fromJson(i),
        ],
        _ => throw const FormatException('"settings" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (snapshotExport != null) 'snapshotExport': snapshotExport!.toJson(),
    if (fullExport != null) 'fullExport': fullExport!.toJson(),
    'entityType': entityType,
    if (destination != null) 'destination': destination!.toJson(),
    if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
    if (settings.isNotDefault) 'settings': encodeList(settings),
  };

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'ExportFeatureValuesRequest($contents)';
  }
}

/// Describes exporting the latest Feature values of all entities of the
/// EntityType between [start_time, snapshot_time].
final class ExportFeatureValuesRequest_SnapshotExport extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesRequest.SnapshotExport';

  /// Exports Feature values as of this timestamp. If not set,
  /// retrieve values as of now. Timestamp, if present, must not have higher
  /// than millisecond precision.
  final protobuf.Timestamp? snapshotTime;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp. If not set, retrieve oldest values kept in Feature Store.
  /// Timestamp, if present, must not have higher than millisecond precision.
  final protobuf.Timestamp? startTime;

  ExportFeatureValuesRequest_SnapshotExport({this.snapshotTime, this.startTime})
    : super(fullyQualifiedName);

  factory ExportFeatureValuesRequest_SnapshotExport.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportFeatureValuesRequest_SnapshotExport(
      snapshotTime: switch (json['snapshotTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (snapshotTime != null) 'snapshotTime': snapshotTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
  };

  @override
  String toString() => 'SnapshotExport()';
}

/// Describes exporting all historical Feature values of all entities of the
/// EntityType between [start_time, end_time].
final class ExportFeatureValuesRequest_FullExport extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesRequest.FullExport';

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp. If not set, retrieve oldest values kept in Feature Store.
  /// Timestamp, if present, must not have higher than millisecond precision.
  final protobuf.Timestamp? startTime;

  /// Exports Feature values as of this timestamp. If not set,
  /// retrieve values as of now. Timestamp, if present, must not have higher
  /// than millisecond precision.
  final protobuf.Timestamp? endTime;

  ExportFeatureValuesRequest_FullExport({this.startTime, this.endTime})
    : super(fullyQualifiedName);

  factory ExportFeatureValuesRequest_FullExport.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportFeatureValuesRequest_FullExport(
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() => 'FullExport()';
}

final class DestinationFeatureSetting extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DestinationFeatureSetting';

  /// Required. The ID of the Feature to apply the setting to.
  final String featureId;

  /// Specify the field name in the export destination. If not specified,
  /// Feature ID is used.
  final String destinationField;

  DestinationFeatureSetting({
    required this.featureId,
    this.destinationField = '',
  }) : super(fullyQualifiedName);

  factory DestinationFeatureSetting.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DestinationFeatureSetting(
      featureId: switch (json['featureId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationField: switch (json['destinationField']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'featureId': featureId,
    if (destinationField.isNotDefault) 'destinationField': destinationField,
  };

  @override
  String toString() {
    final contents = [
      'featureId=$featureId',
      'destinationField=$destinationField',
    ].join(',');
    return 'DestinationFeatureSetting($contents)';
  }
}

/// A destination location for Feature values and format.
final class FeatureValueDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureValueDestination';

  /// Output in BigQuery format.
  /// `BigQueryDestination.output_uri`
  /// in
  /// `FeatureValueDestination.bigquery_destination`
  /// must refer to a table.
  final BigQueryDestination? bigqueryDestination;

  /// Output in TFRecord format.
  ///
  /// Below are the mapping from Feature value type
  /// in Featurestore to Feature value type in TFRecord:
  ///
  ///     Value type in Featurestore                 | Value type in TFRecord
  ///     DOUBLE, DOUBLE_ARRAY                       | FLOAT_LIST
  ///     INT64, INT64_ARRAY                         | INT64_LIST
  ///     STRING, STRING_ARRAY, BYTES                | BYTES_LIST
  ///     true -> byte_string("true"), false -> byte_string("false")
  ///     BOOL, BOOL_ARRAY (true, false)             | BYTES_LIST
  final TfrecordDestination? tfrecordDestination;

  /// Output in CSV format. Array Feature value types are not allowed in CSV
  /// format.
  final CsvDestination? csvDestination;

  FeatureValueDestination({
    this.bigqueryDestination,
    this.tfrecordDestination,
    this.csvDestination,
  }) : super(fullyQualifiedName);

  factory FeatureValueDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FeatureValueDestination(
      bigqueryDestination: switch (json['bigqueryDestination']) {
        null => null,
        Object $1 => BigQueryDestination.fromJson($1),
      },
      tfrecordDestination: switch (json['tfrecordDestination']) {
        null => null,
        Object $1 => TfrecordDestination.fromJson($1),
      },
      csvDestination: switch (json['csvDestination']) {
        null => null,
        Object $1 => CsvDestination.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!.toJson(),
    if (tfrecordDestination != null)
      'tfrecordDestination': tfrecordDestination!.toJson(),
    if (csvDestination != null) 'csvDestination': csvDestination!.toJson(),
  };

  @override
  String toString() => 'FeatureValueDestination()';
}

/// Response message for
/// `FeaturestoreService.ExportFeatureValues`.
final class ExportFeatureValuesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesResponse';

  ExportFeatureValuesResponse() : super(fullyQualifiedName);

  factory ExportFeatureValuesResponse.fromJson(Object? j) =>
      ExportFeatureValuesResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'ExportFeatureValuesResponse()';
}

/// Response message for
/// `FeaturestoreService.BatchReadFeatureValues`.
final class BatchReadFeatureValuesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesResponse';

  BatchReadFeatureValuesResponse() : super(fullyQualifiedName);

  factory BatchReadFeatureValuesResponse.fromJson(Object? j) =>
      BatchReadFeatureValuesResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'BatchReadFeatureValuesResponse()';
}

/// Request message for
/// `FeaturestoreService.CreateEntityType`.
final class CreateEntityTypeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateEntityTypeRequest';

  /// Required. The resource name of the Featurestore to create EntityTypes.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String parent;

  /// The EntityType to create.
  final EntityType? entityType;

  /// Required. The ID to use for the EntityType, which will become the final
  /// component of the EntityType's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within a featurestore.
  final String entityTypeId;

  CreateEntityTypeRequest({
    required this.parent,
    this.entityType,
    required this.entityTypeId,
  }) : super(fullyQualifiedName);

  factory CreateEntityTypeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateEntityTypeRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entityType: switch (json['entityType']) {
        null => null,
        Object $1 => EntityType.fromJson($1),
      },
      entityTypeId: switch (json['entityTypeId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (entityType != null) 'entityType': entityType!.toJson(),
    'entityTypeId': entityTypeId,
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'entityTypeId=$entityTypeId'].join(',');
    return 'CreateEntityTypeRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.GetEntityType`.
final class GetEntityTypeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetEntityTypeRequest';

  /// Required. The name of the EntityType resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  final String name;

  GetEntityTypeRequest({required this.name}) : super(fullyQualifiedName);

  factory GetEntityTypeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetEntityTypeRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetEntityTypeRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ListEntityTypes`.
final class ListEntityTypesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEntityTypesRequest';

  /// Required. The resource name of the Featurestore to list EntityTypes.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String parent;

  /// Lists the EntityTypes that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `labels`: Supports key-value equality as well as key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
  ///      update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
  ///      or updated after 2020-01-31T15:30:00.000000Z.
  /// * `labels.active = yes AND labels.env = prod` --> EntityTypes having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any EntityType which has a label with 'env' as the
  ///   key.
  final String filter;

  /// The maximum number of EntityTypes to return. The service may return fewer
  /// than this value. If unspecified, at most 1000 EntityTypes will be returned.
  /// The maximum value is 1000; any value greater than 1000 will be coerced to
  /// 1000.
  final int pageSize;

  /// A page token, received from a previous
  /// `FeaturestoreService.ListEntityTypes`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeaturestoreService.ListEntityTypes`
  /// must match the call that provided the page token.
  final String pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  ///
  /// Supported fields:
  ///
  ///   * `entity_type_id`
  ///   * `create_time`
  ///   * `update_time`
  final String orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListEntityTypesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListEntityTypesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListEntityTypesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListEntityTypesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.ListEntityTypes`.
final class ListEntityTypesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEntityTypesResponse';

  /// The EntityTypes matching the request.
  final List<EntityType> entityTypes;

  /// A token, which can be sent as
  /// `ListEntityTypesRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListEntityTypesResponse({
    this.entityTypes = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListEntityTypesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListEntityTypesResponse(
      entityTypes: switch (json['entityTypes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) EntityType.fromJson(i)],
        _ => throw const FormatException('"entityTypes" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (entityTypes.isNotDefault) 'entityTypes': encodeList(entityTypes),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListEntityTypesResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.UpdateEntityType`.
final class UpdateEntityTypeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateEntityTypeRequest';

  /// Required. The EntityType's `name` field is used to identify the EntityType
  /// to be updated. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  final EntityType? entityType;

  /// Field mask is used to specify the fields to be overwritten in the
  /// EntityType resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `description`
  ///   * `labels`
  ///   * `monitoring_config.snapshot_analysis.disabled`
  ///   * `monitoring_config.snapshot_analysis.monitoring_interval_days`
  ///   * `monitoring_config.snapshot_analysis.staleness_days`
  ///   * `monitoring_config.import_features_analysis.state`
  ///   * `monitoring_config.import_features_analysis.anomaly_detection_baseline`
  ///   * `monitoring_config.numerical_threshold_config.value`
  ///   * `monitoring_config.categorical_threshold_config.value`
  ///   * `offline_storage_ttl_days`
  final protobuf.FieldMask? updateMask;

  UpdateEntityTypeRequest({required this.entityType, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateEntityTypeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateEntityTypeRequest(
      entityType: switch (json['entityType']) {
        null => null,
        Object $1 => EntityType.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (entityType != null) 'entityType': entityType!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateEntityTypeRequest()';
}

/// Request message for `FeaturestoreService.DeleteEntityTypes`.
final class DeleteEntityTypeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteEntityTypeRequest';

  /// Required. The name of the EntityType to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  final String name;

  /// If set to true, any Features for this EntityType will also be deleted.
  /// (Otherwise, the request will only work if the EntityType has no Features.)
  final bool force;

  DeleteEntityTypeRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteEntityTypeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteEntityTypeRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteEntityTypeRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.CreateFeature`.
/// Request message for
/// `FeatureRegistryService.CreateFeature`.
final class CreateFeatureRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureRequest';

  /// Required. The resource name of the EntityType or FeatureGroup to create a
  /// Feature. Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String parent;

  /// Required. The Feature to create.
  final Feature? feature;

  /// Required. The ID to use for the Feature, which will become the final
  /// component of the Feature's resource name.
  ///
  /// This value may be up to 128 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within an EntityType/FeatureGroup.
  final String featureId;

  CreateFeatureRequest({
    required this.parent,
    required this.feature,
    required this.featureId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      feature: switch (json['feature']) {
        null => null,
        Object $1 => Feature.fromJson($1),
      },
      featureId: switch (json['featureId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (feature != null) 'feature': feature!.toJson(),
    'featureId': featureId,
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'featureId=$featureId'].join(',');
    return 'CreateFeatureRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.BatchCreateFeatures`.
/// Request message for
/// `FeatureRegistryService.BatchCreateFeatures`.
final class BatchCreateFeaturesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateFeaturesRequest';

  /// Required. The resource name of the EntityType/FeatureGroup to create the
  /// batch of Features under. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String parent;

  /// Required. The request message specifying the Features to create. All
  /// Features must be created under the same parent EntityType / FeatureGroup.
  /// The `parent` field in each child request message can be omitted. If
  /// `parent` is set in a child request, then the value must match the `parent`
  /// value in this request message.
  final List<CreateFeatureRequest> requests;

  BatchCreateFeaturesRequest({required this.parent, required this.requests})
    : super(fullyQualifiedName);

  factory BatchCreateFeaturesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCreateFeaturesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requests: switch (json['requests']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) CreateFeatureRequest.fromJson(i),
        ],
        _ => throw const FormatException('"requests" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent, 'requests': encodeList(requests)};

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchCreateFeaturesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.BatchCreateFeatures`.
final class BatchCreateFeaturesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateFeaturesResponse';

  /// The Features created.
  final List<Feature> features;

  BatchCreateFeaturesResponse({this.features = const []})
    : super(fullyQualifiedName);

  factory BatchCreateFeaturesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCreateFeaturesResponse(
      features: switch (json['features']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Feature.fromJson(i)],
        _ => throw const FormatException('"features" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (features.isNotDefault) 'features': encodeList(features),
  };

  @override
  String toString() => 'BatchCreateFeaturesResponse()';
}

/// Request message for
/// `FeaturestoreService.GetFeature`.
/// Request message for
/// `FeatureRegistryService.GetFeature`.
final class GetFeatureRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureRequest';

  /// Required. The name of the Feature resource.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String name;

  /// Optional. Only applicable for Vertex AI Feature Store.
  /// If set, retrieves FeatureStatsAndAnomaly generated by FeatureMonitors based
  /// on this spec.
  final FeatureStatsAndAnomalySpec? featureStatsAndAnomalySpec;

  GetFeatureRequest({required this.name, this.featureStatsAndAnomalySpec})
    : super(fullyQualifiedName);

  factory GetFeatureRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFeatureRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureStatsAndAnomalySpec: switch (json['featureStatsAndAnomalySpec']) {
        null => null,
        Object $1 => FeatureStatsAndAnomalySpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (featureStatsAndAnomalySpec != null)
      'featureStatsAndAnomalySpec': featureStatsAndAnomalySpec!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ListFeatures`.
/// Request message for
/// `FeatureRegistryService.ListFeatures`.
final class ListFeaturesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeaturesRequest';

  /// Required. The resource name of the Location to list Features.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String parent;

  /// Lists the Features that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `value_type`: Supports = and != comparisons.
  /// * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
  /// be in RFC 3339 format.
  /// * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
  /// be in RFC 3339 format.
  /// * `labels`: Supports key-value equality as well as key presence.
  ///
  /// Examples:
  ///
  /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
  ///      update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
  ///      or updated after 2020-01-31T15:30:00.000000Z.
  /// * `labels.active = yes AND labels.env = prod` --> Features having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any Feature which has a label with 'env' as the
  ///   key.
  final String filter;

  /// The maximum number of Features to return. The service may return fewer
  /// than this value. If unspecified, at most 1000 Features will be returned.
  /// The maximum value is 1000; any value greater than 1000 will be coerced to
  /// 1000.
  final int pageSize;

  /// A page token, received from a previous
  /// `FeaturestoreService.ListFeatures`
  /// call or
  /// `FeatureRegistryService.ListFeatures`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeaturestoreService.ListFeatures`
  /// or
  /// `FeatureRegistryService.ListFeatures`
  /// must match the call that provided the page token.
  final String pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported fields:
  ///
  ///   * `feature_id`
  ///   * `value_type` (Not supported for FeatureRegistry Feature)
  ///   * `create_time`
  ///   * `update_time`
  final String orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  /// If set, return the most recent
  /// `ListFeaturesRequest.latest_stats_count`
  /// of stats for each Feature in response. Valid value is [0, 10]. If number of
  /// stats exists <
  /// `ListFeaturesRequest.latest_stats_count`,
  /// return all existing stats.
  final int latestStatsCount;

  ListFeaturesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.readMask,
    this.latestStatsCount = 0,
  }) : super(fullyQualifiedName);

  factory ListFeaturesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeaturesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      latestStatsCount: switch (json['latestStatsCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (latestStatsCount.isNotDefault) 'latestStatsCount': latestStatsCount,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
      'latestStatsCount=$latestStatsCount',
    ].join(',');
    return 'ListFeaturesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.ListFeatures`.
/// Response message for
/// `FeatureRegistryService.ListFeatures`.
final class ListFeaturesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeaturesResponse';

  /// The Features matching the request.
  final List<Feature> features;

  /// A token, which can be sent as
  /// `ListFeaturesRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListFeaturesResponse({this.features = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListFeaturesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFeaturesResponse(
      features: switch (json['features']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Feature.fromJson(i)],
        _ => throw const FormatException('"features" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (features.isNotDefault) 'features': encodeList(features),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFeaturesResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.SearchFeatures`.
final class SearchFeaturesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchFeaturesRequest';

  /// Required. The resource name of the Location to search Features.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String location;

  /// Query string that is a conjunction of field-restricted queries and/or
  /// field-restricted filters.  Field-restricted queries and filters can be
  /// combined using `AND` to form a conjunction.
  ///
  /// A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
  /// exists as a substring within Feature's FIELD. The QUERY
  /// and the FIELD are converted to a sequence of words (i.e. tokens) for
  /// comparison. This is done by:
  ///
  ///   * Removing leading/trailing whitespace and tokenizing the search value.
  ///   Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
  ///   `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
  ///   as a wildcard that matches characters within a token.
  ///   * Ignoring case.
  ///   * Prepending an asterisk to the first and appending an asterisk to the
  ///   last token in QUERY.
  ///
  /// A QUERY must be either a singular token or a phrase. A phrase is one or
  /// multiple words enclosed in double quotation marks ("). With phrases, the
  /// order of the words is important. Words in the phrase must be matching in
  /// order and consecutively.
  ///
  /// Supported FIELDs for field-restricted queries:
  ///
  /// * `feature_id`
  /// * `description`
  /// * `entity_type_id`
  ///
  /// Examples:
  ///
  /// * `feature_id: foo` --> Matches a Feature with ID containing the substring
  /// `foo` (eg. `foo`, `foofeature`, `barfoo`).
  /// * `feature_id: foo*feature` --> Matches a Feature with ID containing the
  /// substring `foo*feature` (eg. `foobarfeature`).
  /// * `feature_id: foo AND description: bar` --> Matches a Feature with ID
  /// containing the substring `foo` and description containing the substring
  /// `bar`.
  ///
  ///
  /// Besides field queries, the following exact-match filters are
  /// supported. The exact-match filters do not support wildcards. Unlike
  /// field-restricted queries, exact-match filters are case-sensitive.
  ///
  /// * `feature_id`: Supports = comparisons.
  /// * `description`: Supports = comparisons. Multi-token filters should be
  /// enclosed in quotes.
  /// * `entity_type_id`: Supports = comparisons.
  /// * `value_type`: Supports = and != comparisons.
  /// * `labels`: Supports key-value equality as well as key presence.
  /// * `featurestore_id`: Supports = comparisons.
  ///
  /// Examples:
  ///
  /// * `description = "foo bar"` --> Any Feature with description exactly equal
  /// to `foo bar`
  /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
  /// * `labels.active = yes AND labels.env = prod` --> Features having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any Feature which has a label with `env` as the
  ///   key.
  final String query;

  /// The maximum number of Features to return. The service may return fewer
  /// than this value. If unspecified, at most 100 Features will be returned.
  /// The maximum value is 100; any value greater than 100 will be coerced to
  /// 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `FeaturestoreService.SearchFeatures`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeaturestoreService.SearchFeatures`,
  /// except `page_size`, must match the call that provided the page token.
  final String pageToken;

  SearchFeaturesRequest({
    required this.location,
    this.query = '',
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchFeaturesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchFeaturesRequest(
      location: switch (json['location']) {
        null => '',
        Object $1 => decodeString($1),
      },
      query: switch (json['query']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'location': location,
    if (query.isNotDefault) 'query': query,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'location=$location',
      'query=$query',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'SearchFeaturesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.SearchFeatures`.
final class SearchFeaturesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchFeaturesResponse';

  /// The Features matching the request.
  ///
  /// Fields returned:
  ///
  ///  * `name`
  ///  * `description`
  ///  * `labels`
  ///  * `create_time`
  ///  * `update_time`
  final List<Feature> features;

  /// A token, which can be sent as
  /// `SearchFeaturesRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  SearchFeaturesResponse({this.features = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory SearchFeaturesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchFeaturesResponse(
      features: switch (json['features']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Feature.fromJson(i)],
        _ => throw const FormatException('"features" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (features.isNotDefault) 'features': encodeList(features),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'SearchFeaturesResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.UpdateFeature`.
/// Request message for
/// `FeatureRegistryService.UpdateFeature`.
final class UpdateFeatureRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureRequest';

  /// Required. The Feature's `name` field is used to identify the Feature to be
  /// updated.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  final Feature? feature;

  /// Field mask is used to specify the fields to be overwritten in the
  /// Features resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `description`
  ///   * `labels`
  ///   * `disable_monitoring` (Not supported for FeatureRegistryService Feature)
  ///   * `point_of_contact` (Not supported for FeaturestoreService FeatureStore)
  final protobuf.FieldMask? updateMask;

  UpdateFeatureRequest({required this.feature, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeatureRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeatureRequest(
      feature: switch (json['feature']) {
        null => null,
        Object $1 => Feature.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (feature != null) 'feature': feature!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateFeatureRequest()';
}

/// Request message for
/// `FeaturestoreService.DeleteFeature`.
/// Request message for
/// `FeatureRegistryService.DeleteFeature`.
final class DeleteFeatureRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureRequest';

  /// Required. The name of the Features to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  final String name;

  DeleteFeatureRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteFeatureRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteFeatureRequest($contents)';
  }
}

/// Details of operations that perform create Featurestore.
final class CreateFeaturestoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeaturestoreOperationMetadata';

  /// Operation metadata for Featurestore.
  final GenericOperationMetadata? genericMetadata;

  CreateFeaturestoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeaturestoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeaturestoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateFeaturestoreOperationMetadata()';
}

/// Details of operations that perform update Featurestore.
final class UpdateFeaturestoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeaturestoreOperationMetadata';

  /// Operation metadata for Featurestore.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeaturestoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeaturestoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFeaturestoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateFeaturestoreOperationMetadata()';
}

/// Details of operations that perform import Feature values.
final class ImportFeatureValuesOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportFeatureValuesOperationMetadata';

  /// Operation metadata for Featurestore import Feature values.
  final GenericOperationMetadata? genericMetadata;

  /// Number of entities that have been imported by the operation.
  final int importedEntityCount;

  /// Number of Feature values that have been imported by the operation.
  final int importedFeatureValueCount;

  /// The source URI from where Feature values are imported.
  final List<String> sourceUris;

  /// The number of rows in input source that weren't imported due to either
  /// * Not having any featureValues.
  /// * Having a null entityId.
  /// * Having a null timestamp.
  /// * Not being parsable (applicable for CSV sources).
  final int invalidRowCount;

  /// The number rows that weren't ingested due to having timestamps outside the
  /// retention boundary.
  final int timestampOutsideRetentionRowsCount;

  /// List of ImportFeatureValues operations running under a single EntityType
  /// that are blocking this operation.
  final List<int> blockingOperationIds;

  ImportFeatureValuesOperationMetadata({
    this.genericMetadata,
    this.importedEntityCount = 0,
    this.importedFeatureValueCount = 0,
    this.sourceUris = const [],
    this.invalidRowCount = 0,
    this.timestampOutsideRetentionRowsCount = 0,
    this.blockingOperationIds = const [],
  }) : super(fullyQualifiedName);

  factory ImportFeatureValuesOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportFeatureValuesOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      importedEntityCount: switch (json['importedEntityCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      importedFeatureValueCount: switch (json['importedFeatureValueCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      sourceUris: switch (json['sourceUris']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"sourceUris" is not a list'),
      },
      invalidRowCount: switch (json['invalidRowCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      timestampOutsideRetentionRowsCount:
          switch (json['timestampOutsideRetentionRowsCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
      blockingOperationIds: switch (json['blockingOperationIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException(
          '"blockingOperationIds" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (importedEntityCount.isNotDefault)
      'importedEntityCount': encodeInt64(importedEntityCount),
    if (importedFeatureValueCount.isNotDefault)
      'importedFeatureValueCount': encodeInt64(importedFeatureValueCount),
    if (sourceUris.isNotDefault) 'sourceUris': sourceUris,
    if (invalidRowCount.isNotDefault)
      'invalidRowCount': encodeInt64(invalidRowCount),
    if (timestampOutsideRetentionRowsCount.isNotDefault)
      'timestampOutsideRetentionRowsCount': encodeInt64(
        timestampOutsideRetentionRowsCount,
      ),
    if (blockingOperationIds.isNotDefault)
      'blockingOperationIds': blockingOperationIds,
  };

  @override
  String toString() {
    final contents = [
      'importedEntityCount=$importedEntityCount',
      'importedFeatureValueCount=$importedFeatureValueCount',
      'invalidRowCount=$invalidRowCount',
      'timestampOutsideRetentionRowsCount=$timestampOutsideRetentionRowsCount',
    ].join(',');
    return 'ImportFeatureValuesOperationMetadata($contents)';
  }
}

/// Details of operations that exports Features values.
final class ExportFeatureValuesOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesOperationMetadata';

  /// Operation metadata for Featurestore export Feature values.
  final GenericOperationMetadata? genericMetadata;

  ExportFeatureValuesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ExportFeatureValuesOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportFeatureValuesOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'ExportFeatureValuesOperationMetadata()';
}

/// Details of operations that batch reads Feature values.
final class BatchReadFeatureValuesOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesOperationMetadata';

  /// Operation metadata for Featurestore batch read Features values.
  final GenericOperationMetadata? genericMetadata;

  BatchReadFeatureValuesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory BatchReadFeatureValuesOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchReadFeatureValuesOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'BatchReadFeatureValuesOperationMetadata()';
}

/// Details of operations that delete Feature values.
final class DeleteFeatureValuesOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesOperationMetadata';

  /// Operation metadata for Featurestore delete Features values.
  final GenericOperationMetadata? genericMetadata;

  DeleteFeatureValuesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory DeleteFeatureValuesOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureValuesOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'DeleteFeatureValuesOperationMetadata()';
}

/// Details of operations that perform create EntityType.
final class CreateEntityTypeOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateEntityTypeOperationMetadata';

  /// Operation metadata for EntityType.
  final GenericOperationMetadata? genericMetadata;

  CreateEntityTypeOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateEntityTypeOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateEntityTypeOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateEntityTypeOperationMetadata()';
}

/// Details of operations that perform create Feature.
final class CreateFeatureOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureOperationMetadata';

  /// Operation metadata for Feature.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFeatureOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateFeatureOperationMetadata()';
}

/// Details of operations that perform batch create Features.
final class BatchCreateFeaturesOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateFeaturesOperationMetadata';

  /// Operation metadata for Feature.
  final GenericOperationMetadata? genericMetadata;

  BatchCreateFeaturesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory BatchCreateFeaturesOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCreateFeaturesOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'BatchCreateFeaturesOperationMetadata()';
}

/// Request message for
/// `FeaturestoreService.DeleteFeatureValues`.
final class DeleteFeatureValuesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesRequest';

  /// Select feature values to be deleted by specifying entities.
  final DeleteFeatureValuesRequest_SelectEntity? selectEntity;

  /// Select feature values to be deleted by specifying time range and
  /// features.
  final DeleteFeatureValuesRequest_SelectTimeRangeAndFeature?
  selectTimeRangeAndFeature;

  /// Required. The resource name of the EntityType grouping the Features for
  /// which values are being deleted from. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  final String entityType;

  DeleteFeatureValuesRequest({
    this.selectEntity,
    this.selectTimeRangeAndFeature,
    required this.entityType,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureValuesRequest(
      selectEntity: switch (json['selectEntity']) {
        null => null,
        Object $1 => DeleteFeatureValuesRequest_SelectEntity.fromJson($1),
      },
      selectTimeRangeAndFeature: switch (json['selectTimeRangeAndFeature']) {
        null => null,
        Object $1 =>
          DeleteFeatureValuesRequest_SelectTimeRangeAndFeature.fromJson($1),
      },
      entityType: switch (json['entityType']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (selectEntity != null) 'selectEntity': selectEntity!.toJson(),
    if (selectTimeRangeAndFeature != null)
      'selectTimeRangeAndFeature': selectTimeRangeAndFeature!.toJson(),
    'entityType': entityType,
  };

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'DeleteFeatureValuesRequest($contents)';
  }
}

/// Message to select entity.
/// If an entity id is selected, all the feature values corresponding to the
/// entity id will be deleted, including the entityId.
final class DeleteFeatureValuesRequest_SelectEntity extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesRequest.SelectEntity';

  /// Required. Selectors choosing feature values of which entity id to be
  /// deleted from the EntityType.
  final EntityIdSelector? entityIdSelector;

  DeleteFeatureValuesRequest_SelectEntity({required this.entityIdSelector})
    : super(fullyQualifiedName);

  factory DeleteFeatureValuesRequest_SelectEntity.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureValuesRequest_SelectEntity(
      entityIdSelector: switch (json['entityIdSelector']) {
        null => null,
        Object $1 => EntityIdSelector.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (entityIdSelector != null)
      'entityIdSelector': entityIdSelector!.toJson(),
  };

  @override
  String toString() => 'SelectEntity()';
}

/// Message to select time range and feature.
/// Values of the selected feature generated within an inclusive time range
/// will be deleted. Using this option permanently deletes the feature values
/// from the specified feature IDs within the specified time range.
/// This might include data from the online storage. If you want to retain
/// any deleted historical data in the online storage, you must re-ingest it.
final class DeleteFeatureValuesRequest_SelectTimeRangeAndFeature
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesRequest.SelectTimeRangeAndFeature';

  /// Required. Select feature generated within a half-inclusive time range.
  /// The time range is lower inclusive and upper exclusive.
  final Interval? timeRange;

  /// Required. Selectors choosing which feature values to be deleted from the
  /// EntityType.
  final FeatureSelector? featureSelector;

  /// If set, data will not be deleted from online storage.
  /// When time range is older than the data in online storage, setting this to
  /// be true will make the deletion have no impact on online serving.
  final bool skipOnlineStorageDelete;

  DeleteFeatureValuesRequest_SelectTimeRangeAndFeature({
    required this.timeRange,
    required this.featureSelector,
    this.skipOnlineStorageDelete = false,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesRequest_SelectTimeRangeAndFeature.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureValuesRequest_SelectTimeRangeAndFeature(
      timeRange: switch (json['timeRange']) {
        null => null,
        Object $1 => Interval.fromJson($1),
      },
      featureSelector: switch (json['featureSelector']) {
        null => null,
        Object $1 => FeatureSelector.fromJson($1),
      },
      skipOnlineStorageDelete: switch (json['skipOnlineStorageDelete']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (timeRange != null) 'timeRange': timeRange!.toJson(),
    if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
    if (skipOnlineStorageDelete.isNotDefault)
      'skipOnlineStorageDelete': skipOnlineStorageDelete,
  };

  @override
  String toString() {
    final contents = [
      'skipOnlineStorageDelete=$skipOnlineStorageDelete',
    ].join(',');
    return 'SelectTimeRangeAndFeature($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.DeleteFeatureValues`.
final class DeleteFeatureValuesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesResponse';

  /// Response for request specifying the entities to delete
  final DeleteFeatureValuesResponse_SelectEntity? selectEntity;

  /// Response for request specifying time range and feature
  final DeleteFeatureValuesResponse_SelectTimeRangeAndFeature?
  selectTimeRangeAndFeature;

  DeleteFeatureValuesResponse({
    this.selectEntity,
    this.selectTimeRangeAndFeature,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureValuesResponse(
      selectEntity: switch (json['selectEntity']) {
        null => null,
        Object $1 => DeleteFeatureValuesResponse_SelectEntity.fromJson($1),
      },
      selectTimeRangeAndFeature: switch (json['selectTimeRangeAndFeature']) {
        null => null,
        Object $1 =>
          DeleteFeatureValuesResponse_SelectTimeRangeAndFeature.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (selectEntity != null) 'selectEntity': selectEntity!.toJson(),
    if (selectTimeRangeAndFeature != null)
      'selectTimeRangeAndFeature': selectTimeRangeAndFeature!.toJson(),
  };

  @override
  String toString() => 'DeleteFeatureValuesResponse()';
}

/// Response message if the request uses the SelectEntity option.
final class DeleteFeatureValuesResponse_SelectEntity extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesResponse.SelectEntity';

  /// The count of deleted entity rows in the offline storage.
  /// Each row corresponds to the combination of an entity ID and a timestamp.
  /// One entity ID can have multiple rows in the offline storage.
  final int offlineStorageDeletedEntityRowCount;

  /// The count of deleted entities in the online storage.
  /// Each entity ID corresponds to one entity.
  final int onlineStorageDeletedEntityCount;

  DeleteFeatureValuesResponse_SelectEntity({
    this.offlineStorageDeletedEntityRowCount = 0,
    this.onlineStorageDeletedEntityCount = 0,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesResponse_SelectEntity.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureValuesResponse_SelectEntity(
      offlineStorageDeletedEntityRowCount:
          switch (json['offlineStorageDeletedEntityRowCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
      onlineStorageDeletedEntityCount:
          switch (json['onlineStorageDeletedEntityCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (offlineStorageDeletedEntityRowCount.isNotDefault)
      'offlineStorageDeletedEntityRowCount': encodeInt64(
        offlineStorageDeletedEntityRowCount,
      ),
    if (onlineStorageDeletedEntityCount.isNotDefault)
      'onlineStorageDeletedEntityCount': encodeInt64(
        onlineStorageDeletedEntityCount,
      ),
  };

  @override
  String toString() {
    final contents = [
      'offlineStorageDeletedEntityRowCount=$offlineStorageDeletedEntityRowCount',
      'onlineStorageDeletedEntityCount=$onlineStorageDeletedEntityCount',
    ].join(',');
    return 'SelectEntity($contents)';
  }
}

/// Response message if the request uses the SelectTimeRangeAndFeature option.
final class DeleteFeatureValuesResponse_SelectTimeRangeAndFeature
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesResponse.SelectTimeRangeAndFeature';

  /// The count of the features or columns impacted.
  /// This is the same as the feature count in the request.
  final int impactedFeatureCount;

  /// The count of modified entity rows in the offline storage.
  /// Each row corresponds to the combination of an entity ID and a timestamp.
  /// One entity ID can have multiple rows in the offline storage.
  /// Within each row, only the features specified in the request are
  /// deleted.
  final int offlineStorageModifiedEntityRowCount;

  /// The count of modified entities in the online storage.
  /// Each entity ID corresponds to one entity.
  /// Within each entity, only the features specified in the request are
  /// deleted.
  final int onlineStorageModifiedEntityCount;

  DeleteFeatureValuesResponse_SelectTimeRangeAndFeature({
    this.impactedFeatureCount = 0,
    this.offlineStorageModifiedEntityRowCount = 0,
    this.onlineStorageModifiedEntityCount = 0,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesResponse_SelectTimeRangeAndFeature.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return DeleteFeatureValuesResponse_SelectTimeRangeAndFeature(
      impactedFeatureCount: switch (json['impactedFeatureCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      offlineStorageModifiedEntityRowCount:
          switch (json['offlineStorageModifiedEntityRowCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
      onlineStorageModifiedEntityCount:
          switch (json['onlineStorageModifiedEntityCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (impactedFeatureCount.isNotDefault)
      'impactedFeatureCount': encodeInt64(impactedFeatureCount),
    if (offlineStorageModifiedEntityRowCount.isNotDefault)
      'offlineStorageModifiedEntityRowCount': encodeInt64(
        offlineStorageModifiedEntityRowCount,
      ),
    if (onlineStorageModifiedEntityCount.isNotDefault)
      'onlineStorageModifiedEntityCount': encodeInt64(
        onlineStorageModifiedEntityCount,
      ),
  };

  @override
  String toString() {
    final contents = [
      'impactedFeatureCount=$impactedFeatureCount',
      'offlineStorageModifiedEntityRowCount=$offlineStorageModifiedEntityRowCount',
      'onlineStorageModifiedEntityCount=$onlineStorageModifiedEntityCount',
    ].join(',');
    return 'SelectTimeRangeAndFeature($contents)';
  }
}

/// Selector for entityId. Getting ids from the given source.
final class EntityIdSelector extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EntityIdSelector';

  /// Source of Csv
  final CsvSource? csvSource;

  /// Source column that holds entity IDs. If not provided, entity IDs are
  /// extracted from the column named entity_id.
  final String entityIdField;

  EntityIdSelector({this.csvSource, this.entityIdField = ''})
    : super(fullyQualifiedName);

  factory EntityIdSelector.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EntityIdSelector(
      csvSource: switch (json['csvSource']) {
        null => null,
        Object $1 => CsvSource.fromJson($1),
      },
      entityIdField: switch (json['entityIdField']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (csvSource != null) 'csvSource': csvSource!.toJson(),
    if (entityIdField.isNotDefault) 'entityIdField': entityIdField,
  };

  @override
  String toString() {
    final contents = ['entityIdField=$entityIdField'].join(',');
    return 'EntityIdSelector($contents)';
  }
}

/// Request message for
/// `GenAiCacheService.CreateCachedContent`.
final class CreateCachedContentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateCachedContentRequest';

  /// Required. The parent resource where the cached content will be created
  final String parent;

  /// Required. The cached content to create
  final CachedContent? cachedContent;

  CreateCachedContentRequest({
    required this.parent,
    required this.cachedContent,
  }) : super(fullyQualifiedName);

  factory CreateCachedContentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateCachedContentRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      cachedContent: switch (json['cachedContent']) {
        null => null,
        Object $1 => CachedContent.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (cachedContent != null) 'cachedContent': cachedContent!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateCachedContentRequest($contents)';
  }
}

/// Request message for
/// `GenAiCacheService.GetCachedContent`.
final class GetCachedContentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetCachedContentRequest';

  /// Required. The resource name referring to the cached content
  final String name;

  GetCachedContentRequest({required this.name}) : super(fullyQualifiedName);

  factory GetCachedContentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetCachedContentRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetCachedContentRequest($contents)';
  }
}

/// Request message for
/// `GenAiCacheService.UpdateCachedContent`.
/// Only expire_time or ttl can be updated.
final class UpdateCachedContentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateCachedContentRequest';

  /// Required. The cached content to update
  final CachedContent? cachedContent;

  /// Required. The list of fields to update.
  final protobuf.FieldMask? updateMask;

  UpdateCachedContentRequest({
    required this.cachedContent,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateCachedContentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateCachedContentRequest(
      cachedContent: switch (json['cachedContent']) {
        null => null,
        Object $1 => CachedContent.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (cachedContent != null) 'cachedContent': cachedContent!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateCachedContentRequest()';
}

/// Request message for
/// `GenAiCacheService.DeleteCachedContent`.
final class DeleteCachedContentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteCachedContentRequest';

  /// Required. The resource name referring to the cached content
  final String name;

  DeleteCachedContentRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteCachedContentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteCachedContentRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteCachedContentRequest($contents)';
  }
}

/// Request to list CachedContents.
final class ListCachedContentsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListCachedContentsRequest';

  /// Required. The parent, which owns this collection of cached contents.
  final String parent;

  /// Optional. The maximum number of cached contents to return. The service may
  /// return fewer than this value. If unspecified, some default (under maximum)
  /// number of items will be returned. The maximum value is 1000; values above
  /// 1000 will be coerced to 1000.
  final int pageSize;

  /// Optional. A page token, received from a previous `ListCachedContents` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to `ListCachedContents` must
  /// match the call that provided the page token.
  final String pageToken;

  ListCachedContentsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListCachedContentsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListCachedContentsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListCachedContentsRequest($contents)';
  }
}

/// Response with a list of CachedContents.
final class ListCachedContentsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListCachedContentsResponse';

  /// List of cached contents.
  final List<CachedContent> cachedContents;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  final String nextPageToken;

  ListCachedContentsResponse({
    this.cachedContents = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListCachedContentsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListCachedContentsResponse(
      cachedContents: switch (json['cachedContents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) CachedContent.fromJson(i)],
        _ => throw const FormatException('"cachedContents" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (cachedContents.isNotDefault)
      'cachedContents': encodeList(cachedContents),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListCachedContentsResponse($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.CreateTuningJob`.
final class CreateTuningJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTuningJobRequest';

  /// Required. The resource name of the Location to create the TuningJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The TuningJob to create.
  final TuningJob? tuningJob;

  CreateTuningJobRequest({required this.parent, required this.tuningJob})
    : super(fullyQualifiedName);

  factory CreateTuningJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateTuningJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tuningJob: switch (json['tuningJob']) {
        null => null,
        Object $1 => TuningJob.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (tuningJob != null) 'tuningJob': tuningJob!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateTuningJobRequest($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.GetTuningJob`.
final class GetTuningJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTuningJobRequest';

  /// Required. The name of the TuningJob resource. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  final String name;

  GetTuningJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTuningJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetTuningJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTuningJobRequest($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.ListTuningJobs`.
final class ListTuningJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTuningJobsRequest';

  /// Required. The resource name of the Location to list the TuningJobs from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list filter.
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via `ListTuningJob.next_page_token` of the
  /// previous GenAiTuningService.ListTuningJob][] call.
  final String pageToken;

  ListTuningJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListTuningJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTuningJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListTuningJobsRequest($contents)';
  }
}

/// Response message for
/// `GenAiTuningService.ListTuningJobs`
final class ListTuningJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTuningJobsResponse';

  /// List of TuningJobs in the requested page.
  final List<TuningJob> tuningJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListTuningJobsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListTuningJobsResponse({this.tuningJobs = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListTuningJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTuningJobsResponse(
      tuningJobs: switch (json['tuningJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TuningJob.fromJson(i)],
        _ => throw const FormatException('"tuningJobs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tuningJobs.isNotDefault) 'tuningJobs': encodeList(tuningJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListTuningJobsResponse($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.CancelTuningJob`.
final class CancelTuningJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelTuningJobRequest';

  /// Required. The name of the TuningJob to cancel. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  final String name;

  CancelTuningJobRequest({required this.name}) : super(fullyQualifiedName);

  factory CancelTuningJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelTuningJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelTuningJobRequest($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.RebaseTunedModel`.
final class RebaseTunedModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RebaseTunedModelRequest';

  /// Required. The resource name of the Location into which to rebase the Model.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. TunedModel reference to retrieve the legacy model information.
  final TunedModelRef? tunedModelRef;

  /// Optional. The TuningJob to be updated. Users can use this TuningJob field
  /// to overwrite tuning configs.
  final TuningJob? tuningJob;

  /// Optional. The Google Cloud Storage location to write the artifacts.
  final GcsDestination? artifactDestination;

  /// Optional. By default, bison to gemini migration will always create new
  /// model/endpoint, but for gemini-1.0 to gemini-1.5 migration, we default
  /// deploy to the same endpoint. See details in this Section.
  final bool deployToSameEndpoint;

  RebaseTunedModelRequest({
    required this.parent,
    required this.tunedModelRef,
    this.tuningJob,
    this.artifactDestination,
    this.deployToSameEndpoint = false,
  }) : super(fullyQualifiedName);

  factory RebaseTunedModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RebaseTunedModelRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tunedModelRef: switch (json['tunedModelRef']) {
        null => null,
        Object $1 => TunedModelRef.fromJson($1),
      },
      tuningJob: switch (json['tuningJob']) {
        null => null,
        Object $1 => TuningJob.fromJson($1),
      },
      artifactDestination: switch (json['artifactDestination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      deployToSameEndpoint: switch (json['deployToSameEndpoint']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (tunedModelRef != null) 'tunedModelRef': tunedModelRef!.toJson(),
    if (tuningJob != null) 'tuningJob': tuningJob!.toJson(),
    if (artifactDestination != null)
      'artifactDestination': artifactDestination!.toJson(),
    if (deployToSameEndpoint.isNotDefault)
      'deployToSameEndpoint': deployToSameEndpoint,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'deployToSameEndpoint=$deployToSameEndpoint',
    ].join(',');
    return 'RebaseTunedModelRequest($contents)';
  }
}

/// Runtime operation information for
/// `GenAiTuningService.RebaseTunedModel`.
final class RebaseTunedModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RebaseTunedModelOperationMetadata';

  /// The common part of the operation generic information.
  final GenericOperationMetadata? genericMetadata;

  RebaseTunedModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory RebaseTunedModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RebaseTunedModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'RebaseTunedModelOperationMetadata()';
}

/// Represents a HyperparameterTuningJob. A HyperparameterTuningJob
/// has a Study specification and multiple CustomJobs with identical
/// CustomJob specification.
final class HyperparameterTuningJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.HyperparameterTuningJob';

  /// Output only. Resource name of the HyperparameterTuningJob.
  final String name;

  /// Required. The display name of the HyperparameterTuningJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Required. Study configuration of the HyperparameterTuningJob.
  final StudySpec? studySpec;

  /// Required. The desired total number of Trials.
  final int maxTrialCount;

  /// Required. The desired number of Trials to run in parallel.
  final int parallelTrialCount;

  /// The number of failed Trials that need to be seen before failing
  /// the HyperparameterTuningJob.
  ///
  /// If set to 0, Vertex AI decides how many Trials must fail
  /// before the whole job fails.
  final int maxFailedTrialCount;

  /// Required. The spec of a trial job. The same spec applies to the CustomJobs
  /// created in all the trials.
  final CustomJobSpec? trialJobSpec;

  /// Output only. Trials of the HyperparameterTuningJob.
  final List<Trial> trials;

  /// Output only. The detailed state of the job.
  final JobState state;

  /// Output only. Time when the HyperparameterTuningJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the HyperparameterTuningJob for the first time
  /// entered the `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the HyperparameterTuningJob entered any of the
  /// following states: `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`,
  /// `JOB_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the HyperparameterTuningJob was most recently
  /// updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  final Status? error;

  /// The labels with user-defined metadata to organize HyperparameterTuningJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Customer-managed encryption key options for a HyperparameterTuningJob.
  /// If this is set, then all resources created by the HyperparameterTuningJob
  /// will be encrypted with the provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  HyperparameterTuningJob({
    this.name = '',
    required this.displayName,
    required this.studySpec,
    required this.maxTrialCount,
    required this.parallelTrialCount,
    this.maxFailedTrialCount = 0,
    required this.trialJobSpec,
    this.trials = const [],
    this.state = JobState.$default,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.error,
    this.labels = const {},
    this.encryptionSpec,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory HyperparameterTuningJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HyperparameterTuningJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      studySpec: switch (json['studySpec']) {
        null => null,
        Object $1 => StudySpec.fromJson($1),
      },
      maxTrialCount: switch (json['maxTrialCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      parallelTrialCount: switch (json['parallelTrialCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      maxFailedTrialCount: switch (json['maxFailedTrialCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      trialJobSpec: switch (json['trialJobSpec']) {
        null => null,
        Object $1 => CustomJobSpec.fromJson($1),
      },
      trials: switch (json['trials']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Trial.fromJson(i)],
        _ => throw const FormatException('"trials" is not a list'),
      },
      state: switch (json['state']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (studySpec != null) 'studySpec': studySpec!.toJson(),
    'maxTrialCount': maxTrialCount,
    'parallelTrialCount': parallelTrialCount,
    if (maxFailedTrialCount.isNotDefault)
      'maxFailedTrialCount': maxFailedTrialCount,
    if (trialJobSpec != null) 'trialJobSpec': trialJobSpec!.toJson(),
    if (trials.isNotDefault) 'trials': encodeList(trials),
    if (state.isNotDefault) 'state': state.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'maxTrialCount=$maxTrialCount',
      'parallelTrialCount=$parallelTrialCount',
      'maxFailedTrialCount=$maxFailedTrialCount',
      'state=$state',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'HyperparameterTuningJob($contents)';
  }
}

/// A representation of a collection of database items organized in a way that
/// allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
final class Index extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Index';

  /// Output only. The resource name of the Index.
  final String name;

  /// Required. The display name of the Index.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// The description of the Index.
  final String description;

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// additional information about the Index, that is specific to it. Unset if
  /// the Index does not have any additional information. The schema is defined
  /// as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String metadataSchemaUri;

  /// An additional information about the Index; the schema of the metadata can
  /// be found in
  /// `metadata_schema`.
  final protobuf.Value? metadata;

  /// Output only. The pointers to DeployedIndexes created from this Index.
  /// An Index can be only deleted if all its DeployedIndexes had been undeployed
  /// first.
  final List<DeployedIndexRef> deployedIndexes;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize your Indexes.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Output only. Timestamp when this Index was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Index was most recently updated.
  /// This also includes any update to the contents of the Index.
  /// Note that Operations working on this Index may have their
  /// [Operations.metadata.generic_metadata.update_time]
  /// [google.cloud.aiplatform.v1beta1.GenericOperationMetadata.update_time] a
  /// little after the value of this timestamp, yet that does not mean their
  /// results are not already reflected in the Index. Result of any successfully
  /// completed Operation on the Index is reflected in it.
  final protobuf.Timestamp? updateTime;

  /// Output only. Stats of the index resource.
  final IndexStats? indexStats;

  /// Immutable. The update method to use with this Index. If not set,
  /// BATCH_UPDATE will be used by default.
  final Index_IndexUpdateMethod indexUpdateMethod;

  /// Immutable. Customer-managed encryption key spec for an Index. If set, this
  /// Index and all sub-resources of this Index will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  Index({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.metadataSchemaUri = '',
    this.metadata,
    this.deployedIndexes = const [],
    this.etag = '',
    this.labels = const {},
    this.createTime,
    this.updateTime,
    this.indexStats,
    this.indexUpdateMethod = Index_IndexUpdateMethod.$default,
    this.encryptionSpec,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory Index.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Index(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadataSchemaUri: switch (json['metadataSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      deployedIndexes: switch (json['deployedIndexes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DeployedIndexRef.fromJson(i)],
        _ => throw const FormatException('"deployedIndexes" is not a list'),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      indexStats: switch (json['indexStats']) {
        null => null,
        Object $1 => IndexStats.fromJson($1),
      },
      indexUpdateMethod: switch (json['indexUpdateMethod']) {
        null => Index_IndexUpdateMethod.$default,
        Object $1 => Index_IndexUpdateMethod.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (metadataSchemaUri.isNotDefault) 'metadataSchemaUri': metadataSchemaUri,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (deployedIndexes.isNotDefault)
      'deployedIndexes': encodeList(deployedIndexes),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (indexStats != null) 'indexStats': indexStats!.toJson(),
    if (indexUpdateMethod.isNotDefault)
      'indexUpdateMethod': indexUpdateMethod.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'metadataSchemaUri=$metadataSchemaUri',
      'etag=$etag',
      'indexUpdateMethod=$indexUpdateMethod',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Index($contents)';
  }
}

/// The update method of an Index.
final class Index_IndexUpdateMethod extends ProtoEnum {
  /// Should not be used.
  static const indexUpdateMethodUnspecified = Index_IndexUpdateMethod(
    'INDEX_UPDATE_METHOD_UNSPECIFIED',
  );

  /// BatchUpdate: user can call UpdateIndex with files on Cloud Storage of
  /// Datapoints to update.
  static const batchUpdate = Index_IndexUpdateMethod('BATCH_UPDATE');

  /// StreamUpdate: user can call UpsertDatapoints/DeleteDatapoints to update
  /// the Index and the updates will be applied in corresponding
  /// DeployedIndexes in nearly real-time.
  static const streamUpdate = Index_IndexUpdateMethod('STREAM_UPDATE');

  /// The default value for [Index_IndexUpdateMethod].
  static const $default = indexUpdateMethodUnspecified;

  const Index_IndexUpdateMethod(super.value);

  factory Index_IndexUpdateMethod.fromJson(Object? json) =>
      Index_IndexUpdateMethod(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'IndexUpdateMethod.$value';
}

/// A datapoint of Index.
final class IndexDatapoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint';

  /// Required. Unique identifier of the datapoint.
  final String datapointId;

  /// Required. Feature embedding vector for dense index. An array of numbers
  /// with the length of [NearestNeighborSearchConfig.dimensions].
  final List<double> featureVector;

  /// Optional. Feature embedding vector for sparse index.
  final IndexDatapoint_SparseEmbedding? sparseEmbedding;

  /// Optional. List of Restrict of the datapoint, used to perform "restricted
  /// searches" where boolean rule are used to filter the subset of the database
  /// eligible for matching. This uses categorical tokens. See:
  /// https://cloud.google.com/vertex-ai/docs/matching-engine/filtering
  final List<IndexDatapoint_Restriction> restricts;

  /// Optional. List of Restrict of the datapoint, used to perform "restricted
  /// searches" where boolean rule are used to filter the subset of the database
  /// eligible for matching. This uses numeric comparisons.
  final List<IndexDatapoint_NumericRestriction> numericRestricts;

  /// Optional. CrowdingTag of the datapoint, the number of neighbors to return
  /// in each crowding can be configured during query.
  final IndexDatapoint_CrowdingTag? crowdingTag;

  /// Optional. The key-value map of additional metadata for the datapoint.
  final protobuf.Struct? embeddingMetadata;

  IndexDatapoint({
    required this.datapointId,
    required this.featureVector,
    this.sparseEmbedding,
    this.restricts = const [],
    this.numericRestricts = const [],
    this.crowdingTag,
    this.embeddingMetadata,
  }) : super(fullyQualifiedName);

  factory IndexDatapoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IndexDatapoint(
      datapointId: switch (json['datapointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureVector: switch (json['featureVector']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"featureVector" is not a list'),
      },
      sparseEmbedding: switch (json['sparseEmbedding']) {
        null => null,
        Object $1 => IndexDatapoint_SparseEmbedding.fromJson($1),
      },
      restricts: switch (json['restricts']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) IndexDatapoint_Restriction.fromJson(i),
        ],
        _ => throw const FormatException('"restricts" is not a list'),
      },
      numericRestricts: switch (json['numericRestricts']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) IndexDatapoint_NumericRestriction.fromJson(i),
        ],
        _ => throw const FormatException('"numericRestricts" is not a list'),
      },
      crowdingTag: switch (json['crowdingTag']) {
        null => null,
        Object $1 => IndexDatapoint_CrowdingTag.fromJson($1),
      },
      embeddingMetadata: switch (json['embeddingMetadata']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'datapointId': datapointId,
    'featureVector': featureVector,
    if (sparseEmbedding != null) 'sparseEmbedding': sparseEmbedding!.toJson(),
    if (restricts.isNotDefault) 'restricts': encodeList(restricts),
    if (numericRestricts.isNotDefault)
      'numericRestricts': encodeList(numericRestricts),
    if (crowdingTag != null) 'crowdingTag': crowdingTag!.toJson(),
    if (embeddingMetadata != null)
      'embeddingMetadata': embeddingMetadata!.toJson(),
  };

  @override
  String toString() {
    final contents = ['datapointId=$datapointId'].join(',');
    return 'IndexDatapoint($contents)';
  }
}

/// Feature embedding vector for sparse index. An array of numbers whose values
/// are located in the specified dimensions.
final class IndexDatapoint_SparseEmbedding extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint.SparseEmbedding';

  /// Required. The list of embedding values of the sparse vector.
  final List<double> values;

  /// Required. The list of indexes for the embedding values of the sparse
  /// vector.
  final List<int> dimensions;

  IndexDatapoint_SparseEmbedding({
    required this.values,
    required this.dimensions,
  }) : super(fullyQualifiedName);

  factory IndexDatapoint_SparseEmbedding.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IndexDatapoint_SparseEmbedding(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
      dimensions: switch (json['dimensions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException('"dimensions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'values': values, 'dimensions': dimensions};

  @override
  String toString() => 'SparseEmbedding()';
}

/// Restriction of a datapoint which describe its attributes(tokens) from each
/// of several attribute categories(namespaces).
final class IndexDatapoint_Restriction extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint.Restriction';

  /// The namespace of this restriction. e.g.: color.
  final String namespace;

  /// The attributes to allow in this namespace. e.g.: 'red'
  final List<String> allowList;

  /// The attributes to deny in this namespace. e.g.: 'blue'
  final List<String> denyList;

  IndexDatapoint_Restriction({
    this.namespace = '',
    this.allowList = const [],
    this.denyList = const [],
  }) : super(fullyQualifiedName);

  factory IndexDatapoint_Restriction.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IndexDatapoint_Restriction(
      namespace: switch (json['namespace']) {
        null => '',
        Object $1 => decodeString($1),
      },
      allowList: switch (json['allowList']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"allowList" is not a list'),
      },
      denyList: switch (json['denyList']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"denyList" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (namespace.isNotDefault) 'namespace': namespace,
    if (allowList.isNotDefault) 'allowList': allowList,
    if (denyList.isNotDefault) 'denyList': denyList,
  };

  @override
  String toString() {
    final contents = ['namespace=$namespace'].join(',');
    return 'Restriction($contents)';
  }
}

/// This field allows restricts to be based on numeric comparisons rather
/// than categorical tokens.
final class IndexDatapoint_NumericRestriction extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint.NumericRestriction';

  /// Represents 64 bit integer.
  final int? valueInt;

  /// Represents 32 bit float.
  final double? valueFloat;

  /// Represents 64 bit float.
  final double? valueDouble;

  /// The namespace of this restriction. e.g.: cost.
  final String namespace;

  /// This MUST be specified for queries and must NOT be specified for
  /// datapoints.
  final IndexDatapoint_NumericRestriction_Operator op;

  IndexDatapoint_NumericRestriction({
    this.valueInt,
    this.valueFloat,
    this.valueDouble,
    this.namespace = '',
    this.op = IndexDatapoint_NumericRestriction_Operator.$default,
  }) : super(fullyQualifiedName);

  factory IndexDatapoint_NumericRestriction.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IndexDatapoint_NumericRestriction(
      valueInt: switch (json['valueInt']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      valueFloat: switch (json['valueFloat']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      valueDouble: switch (json['valueDouble']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      namespace: switch (json['namespace']) {
        null => '',
        Object $1 => decodeString($1),
      },
      op: switch (json['op']) {
        null => IndexDatapoint_NumericRestriction_Operator.$default,
        Object $1 => IndexDatapoint_NumericRestriction_Operator.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (valueInt != null) 'valueInt': encodeInt64(valueInt),
    if (valueFloat != null) 'valueFloat': encodeDouble(valueFloat),
    if (valueDouble != null) 'valueDouble': encodeDouble(valueDouble),
    if (namespace.isNotDefault) 'namespace': namespace,
    if (op.isNotDefault) 'op': op.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (valueInt != null) 'valueInt=$valueInt',
      if (valueFloat != null) 'valueFloat=$valueFloat',
      if (valueDouble != null) 'valueDouble=$valueDouble',
      'namespace=$namespace',
      'op=$op',
    ].join(',');
    return 'NumericRestriction($contents)';
  }
}

/// Which comparison operator to use.  Should be specified for queries only;
/// specifying this for a datapoint is an error.
///
/// Datapoints for which Operator is true relative to the query's Value
/// field will be allowlisted.
final class IndexDatapoint_NumericRestriction_Operator extends ProtoEnum {
  /// Default value of the enum.
  static const operatorUnspecified = IndexDatapoint_NumericRestriction_Operator(
    'OPERATOR_UNSPECIFIED',
  );

  /// Datapoints are eligible iff their value is < the query's.
  static const less = IndexDatapoint_NumericRestriction_Operator('LESS');

  /// Datapoints are eligible iff their value is <= the query's.
  static const lessEqual = IndexDatapoint_NumericRestriction_Operator(
    'LESS_EQUAL',
  );

  /// Datapoints are eligible iff their value is == the query's.
  static const equal = IndexDatapoint_NumericRestriction_Operator('EQUAL');

  /// Datapoints are eligible iff their value is >= the query's.
  static const greaterEqual = IndexDatapoint_NumericRestriction_Operator(
    'GREATER_EQUAL',
  );

  /// Datapoints are eligible iff their value is > the query's.
  static const greater = IndexDatapoint_NumericRestriction_Operator('GREATER');

  /// Datapoints are eligible iff their value is != the query's.
  static const notEqual = IndexDatapoint_NumericRestriction_Operator(
    'NOT_EQUAL',
  );

  /// The default value for [IndexDatapoint_NumericRestriction_Operator].
  static const $default = operatorUnspecified;

  const IndexDatapoint_NumericRestriction_Operator(super.value);

  factory IndexDatapoint_NumericRestriction_Operator.fromJson(Object? json) =>
      IndexDatapoint_NumericRestriction_Operator(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Operator.$value';
}

/// Crowding tag is a constraint on a neighbor list produced by nearest
/// neighbor search requiring that no more than some value k' of the k
/// neighbors returned have the same value of crowding_attribute.
final class IndexDatapoint_CrowdingTag extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint.CrowdingTag';

  /// The attribute value used for crowding.  The maximum number of neighbors
  /// to return per crowding attribute value
  /// (per_crowding_attribute_num_neighbors) is configured per-query. This
  /// field is ignored if per_crowding_attribute_num_neighbors is larger than
  /// the total number of neighbors to return for a given query.
  final String crowdingAttribute;

  IndexDatapoint_CrowdingTag({this.crowdingAttribute = ''})
    : super(fullyQualifiedName);

  factory IndexDatapoint_CrowdingTag.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IndexDatapoint_CrowdingTag(
      crowdingAttribute: switch (json['crowdingAttribute']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (crowdingAttribute.isNotDefault) 'crowdingAttribute': crowdingAttribute,
  };

  @override
  String toString() {
    final contents = ['crowdingAttribute=$crowdingAttribute'].join(',');
    return 'CrowdingTag($contents)';
  }
}

/// Stats of the Index.
final class IndexStats extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexStats';

  /// Output only. The number of dense vectors in the Index.
  final int vectorsCount;

  /// Output only. The number of sparse vectors in the Index.
  final int sparseVectorsCount;

  /// Output only. The number of shards in the Index.
  final int shardsCount;

  IndexStats({
    this.vectorsCount = 0,
    this.sparseVectorsCount = 0,
    this.shardsCount = 0,
  }) : super(fullyQualifiedName);

  factory IndexStats.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IndexStats(
      vectorsCount: switch (json['vectorsCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      sparseVectorsCount: switch (json['sparseVectorsCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      shardsCount: switch (json['shardsCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vectorsCount.isNotDefault) 'vectorsCount': encodeInt64(vectorsCount),
    if (sparseVectorsCount.isNotDefault)
      'sparseVectorsCount': encodeInt64(sparseVectorsCount),
    if (shardsCount.isNotDefault) 'shardsCount': shardsCount,
  };

  @override
  String toString() {
    final contents = [
      'vectorsCount=$vectorsCount',
      'sparseVectorsCount=$sparseVectorsCount',
      'shardsCount=$shardsCount',
    ].join(',');
    return 'IndexStats($contents)';
  }
}

/// Indexes are deployed into it. An IndexEndpoint can have multiple
/// DeployedIndexes.
final class IndexEndpoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexEndpoint';

  /// Output only. The resource name of the IndexEndpoint.
  final String name;

  /// Required. The display name of the IndexEndpoint.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// The description of the IndexEndpoint.
  final String description;

  /// Output only. The indexes deployed in this endpoint.
  final List<DeployedIndex> deployedIndexes;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize your IndexEndpoints.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Output only. Timestamp when this IndexEndpoint was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this IndexEndpoint was last updated.
  /// This timestamp is not updated when the endpoint's DeployedIndexes are
  /// updated, e.g. due to updates of the original Indexes they are the
  /// deployments of.
  final protobuf.Timestamp? updateTime;

  /// Optional. The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
  /// to which the IndexEndpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If left
  /// unspecified, the Endpoint is not peered with any network.
  ///
  /// `network` and
  /// `private_service_connect_config`
  /// are mutually exclusive.
  ///
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in '12345', and {network} is
  /// network name.
  final String network;

  /// Optional. Deprecated: If true, expose the IndexEndpoint via private service
  /// connect.
  ///
  /// Only one of the fields,
  /// `network` or
  /// `enable_private_service_connect`,
  /// can be set.
  final bool enablePrivateServiceConnect;

  /// Optional. Configuration for private service connect.
  ///
  /// `network` and
  /// `private_service_connect_config`
  /// are mutually exclusive.
  final PrivateServiceConnectConfig? privateServiceConnectConfig;

  /// Optional. If true, the deployed index will be accessible through public
  /// endpoint.
  final bool publicEndpointEnabled;

  /// Output only. If
  /// `public_endpoint_enabled`
  /// is true, this field will be populated with the domain name to use for this
  /// index endpoint.
  final String publicEndpointDomainName;

  /// Immutable. Customer-managed encryption key spec for an IndexEndpoint. If
  /// set, this IndexEndpoint and all sub-resources of this IndexEndpoint will be
  /// secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  IndexEndpoint({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.deployedIndexes = const [],
    this.etag = '',
    this.labels = const {},
    this.createTime,
    this.updateTime,
    this.network = '',
    this.enablePrivateServiceConnect = false,
    this.privateServiceConnectConfig,
    this.publicEndpointEnabled = false,
    this.publicEndpointDomainName = '',
    this.encryptionSpec,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory IndexEndpoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IndexEndpoint(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedIndexes: switch (json['deployedIndexes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DeployedIndex.fromJson(i)],
        _ => throw const FormatException('"deployedIndexes" is not a list'),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      network: switch (json['network']) {
        null => '',
        Object $1 => decodeString($1),
      },
      enablePrivateServiceConnect:
          switch (json['enablePrivateServiceConnect']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      privateServiceConnectConfig:
          switch (json['privateServiceConnectConfig']) {
            null => null,
            Object $1 => PrivateServiceConnectConfig.fromJson($1),
          },
      publicEndpointEnabled: switch (json['publicEndpointEnabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      publicEndpointDomainName: switch (json['publicEndpointDomainName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (deployedIndexes.isNotDefault)
      'deployedIndexes': encodeList(deployedIndexes),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (network.isNotDefault) 'network': network,
    if (enablePrivateServiceConnect.isNotDefault)
      'enablePrivateServiceConnect': enablePrivateServiceConnect,
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
    if (publicEndpointEnabled.isNotDefault)
      'publicEndpointEnabled': publicEndpointEnabled,
    if (publicEndpointDomainName.isNotDefault)
      'publicEndpointDomainName': publicEndpointDomainName,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'etag=$etag',
      'network=$network',
      'enablePrivateServiceConnect=$enablePrivateServiceConnect',
      'publicEndpointEnabled=$publicEndpointEnabled',
      'publicEndpointDomainName=$publicEndpointDomainName',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'IndexEndpoint($contents)';
  }
}

/// A deployment of an Index. IndexEndpoints contain one or more DeployedIndexes.
final class DeployedIndex extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedIndex';

  /// Required. The user specified ID of the DeployedIndex.
  /// The ID can be up to 128 characters long and must start with a letter and
  /// only contain letters, numbers, and underscores.
  /// The ID must be unique within the project it is created in.
  final String id;

  /// Required. The name of the Index this is the deployment of.
  /// We may refer to this Index as the DeployedIndex's "original" Index.
  final String index;

  /// The display name of the DeployedIndex. If not provided upon creation,
  /// the Index's display_name is used.
  final String displayName;

  /// Output only. Timestamp when the DeployedIndex was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Provides paths for users to send requests directly to the
  /// deployed index services running on Cloud via private services access. This
  /// field is populated if
  /// `network` is
  /// configured.
  final IndexPrivateEndpoints? privateEndpoints;

  /// Output only. The DeployedIndex may depend on various data on its original
  /// Index. Additionally when certain changes to the original Index are being
  /// done (e.g. when what the Index contains is being changed) the DeployedIndex
  /// may be asynchronously updated in the background to reflect these changes.
  /// If this timestamp's value is at least the
  /// `Index.update_time` of
  /// the original Index, it means that this DeployedIndex and the original Index
  /// are in sync. If this timestamp is older, then to see which updates this
  /// DeployedIndex already contains (and which it does not), one must
  /// `list` the operations that
  /// are running on the original Index. Only the successfully completed
  /// Operations with
  /// `update_time`
  /// equal or before this sync time are contained in this DeployedIndex.
  final protobuf.Timestamp? indexSyncTime;

  /// Optional. A description of resources that the DeployedIndex uses, which to
  /// large degree are decided by Vertex AI, and optionally allows only a modest
  /// additional configuration.
  /// If min_replica_count is not set, the default value is 2 (we don't provide
  /// SLA when min_replica_count=1). If max_replica_count is not set, the
  /// default value is min_replica_count. The max allowed replica count is
  /// 1000.
  final AutomaticResources? automaticResources;

  /// Optional. A description of resources that are dedicated to the
  /// DeployedIndex, and that need a higher degree of manual configuration. The
  /// field min_replica_count must be set to a value strictly greater than 0, or
  /// else validation will fail. We don't provide SLA when min_replica_count=1.
  /// If max_replica_count is not set, the default value is min_replica_count.
  /// The max allowed replica count is 1000.
  ///
  /// Available machine types for SMALL shard:
  /// e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
  ///
  /// Available machine types for MEDIUM shard:
  /// e2-standard-16 and all machine types available for LARGE shard.
  ///
  /// Available machine types for LARGE shard:
  /// e2-highmem-16, n2d-standard-32.
  ///
  /// n1-standard-16 and n1-standard-32 are still available, but we recommend
  /// e2-standard-16 and e2-highmem-16 for cost efficiency.
  final DedicatedResources? dedicatedResources;

  /// Optional. If true, private endpoint's access logs are sent to Cloud
  /// Logging.
  ///
  /// These logs are like standard server access logs, containing
  /// information like timestamp and latency for each MatchRequest.
  ///
  /// Note that logs may incur a cost, especially if the deployed
  /// index receives a high queries per second rate (QPS).
  /// Estimate your costs before enabling this option.
  final bool enableAccessLogging;

  /// Optional. If true, logs to Cloud Logging errors relating to datapoint
  /// upserts.
  ///
  /// Under normal operation conditions, these log entries should be very rare.
  /// However, if incompatible datapoint updates are being uploaded to an index,
  /// a high volume of log entries may be generated in a short period of time.
  ///
  /// Note that logs may incur a cost, especially if the deployed index receives
  /// a high volume of datapoint upserts. Estimate your costs before enabling
  /// this option.
  final bool enableDatapointUpsertLogging;

  /// Optional. If set, the authentication is enabled for the private endpoint.
  final DeployedIndexAuthConfig? deployedIndexAuthConfig;

  /// Optional. A list of reserved ip ranges under the VPC network that can be
  /// used for this DeployedIndex.
  ///
  /// If set, we will deploy the index within the provided ip ranges. Otherwise,
  /// the index might be deployed to any ip ranges under the provided VPC
  /// network.
  ///
  /// The value should be the name of the address
  /// (https://cloud.google.com/compute/docs/reference/rest/v1/addresses)
  /// Example: ['vertex-ai-ip-range'].
  ///
  /// For more information about subnets and network IP ranges, please see
  /// https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
  final List<String> reservedIpRanges;

  /// Optional. The deployment group can be no longer than 64 characters (eg:
  /// 'test', 'prod'). If not set, we will use the 'default' deployment group.
  ///
  /// Creating `deployment_groups` with `reserved_ip_ranges` is a recommended
  /// practice when the peered network has multiple peering ranges. This creates
  /// your deployments from predictable IP spaces for easier traffic
  /// administration. Also, one deployment_group (except 'default') can only be
  /// used with the same reserved_ip_ranges which means if the deployment_group
  /// has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or
  /// [d, e] is disallowed.
  ///
  /// Note: we only support up to 5 deployment groups(not including 'default').
  final String deploymentGroup;

  /// Optional. If set for PSC deployed index, PSC connection will be
  /// automatically created after deployment is done and the endpoint information
  /// is populated in private_endpoints.psc_automated_endpoints.
  final List<PscautomationConfig> pscAutomationConfigs;

  DeployedIndex({
    required this.id,
    required this.index,
    this.displayName = '',
    this.createTime,
    this.privateEndpoints,
    this.indexSyncTime,
    this.automaticResources,
    this.dedicatedResources,
    this.enableAccessLogging = false,
    this.enableDatapointUpsertLogging = false,
    this.deployedIndexAuthConfig,
    this.reservedIpRanges = const [],
    this.deploymentGroup = '',
    this.pscAutomationConfigs = const [],
  }) : super(fullyQualifiedName);

  factory DeployedIndex.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployedIndex(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      index: switch (json['index']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      privateEndpoints: switch (json['privateEndpoints']) {
        null => null,
        Object $1 => IndexPrivateEndpoints.fromJson($1),
      },
      indexSyncTime: switch (json['indexSyncTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      automaticResources: switch (json['automaticResources']) {
        null => null,
        Object $1 => AutomaticResources.fromJson($1),
      },
      dedicatedResources: switch (json['dedicatedResources']) {
        null => null,
        Object $1 => DedicatedResources.fromJson($1),
      },
      enableAccessLogging: switch (json['enableAccessLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      enableDatapointUpsertLogging:
          switch (json['enableDatapointUpsertLogging']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      deployedIndexAuthConfig: switch (json['deployedIndexAuthConfig']) {
        null => null,
        Object $1 => DeployedIndexAuthConfig.fromJson($1),
      },
      reservedIpRanges: switch (json['reservedIpRanges']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"reservedIpRanges" is not a list'),
      },
      deploymentGroup: switch (json['deploymentGroup']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pscAutomationConfigs: switch (json['pscAutomationConfigs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PscautomationConfig.fromJson(i),
        ],
        _ => throw const FormatException(
          '"pscAutomationConfigs" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    'id': id,
    'index': index,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (privateEndpoints != null)
      'privateEndpoints': privateEndpoints!.toJson(),
    if (indexSyncTime != null) 'indexSyncTime': indexSyncTime!.toJson(),
    if (automaticResources != null)
      'automaticResources': automaticResources!.toJson(),
    if (dedicatedResources != null)
      'dedicatedResources': dedicatedResources!.toJson(),
    if (enableAccessLogging.isNotDefault)
      'enableAccessLogging': enableAccessLogging,
    if (enableDatapointUpsertLogging.isNotDefault)
      'enableDatapointUpsertLogging': enableDatapointUpsertLogging,
    if (deployedIndexAuthConfig != null)
      'deployedIndexAuthConfig': deployedIndexAuthConfig!.toJson(),
    if (reservedIpRanges.isNotDefault) 'reservedIpRanges': reservedIpRanges,
    if (deploymentGroup.isNotDefault) 'deploymentGroup': deploymentGroup,
    if (pscAutomationConfigs.isNotDefault)
      'pscAutomationConfigs': encodeList(pscAutomationConfigs),
  };

  @override
  String toString() {
    final contents = [
      'id=$id',
      'index=$index',
      'displayName=$displayName',
      'enableAccessLogging=$enableAccessLogging',
      'enableDatapointUpsertLogging=$enableDatapointUpsertLogging',
      'deploymentGroup=$deploymentGroup',
    ].join(',');
    return 'DeployedIndex($contents)';
  }
}

/// Used to set up the auth on the DeployedIndex's private endpoint.
final class DeployedIndexAuthConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedIndexAuthConfig';

  /// Defines the authentication provider that the DeployedIndex uses.
  final DeployedIndexAuthConfig_AuthProvider? authProvider;

  DeployedIndexAuthConfig({this.authProvider}) : super(fullyQualifiedName);

  factory DeployedIndexAuthConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployedIndexAuthConfig(
      authProvider: switch (json['authProvider']) {
        null => null,
        Object $1 => DeployedIndexAuthConfig_AuthProvider.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (authProvider != null) 'authProvider': authProvider!.toJson(),
  };

  @override
  String toString() => 'DeployedIndexAuthConfig()';
}

/// Configuration for an authentication provider, including support for
/// [JSON Web Token
/// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
final class DeployedIndexAuthConfig_AuthProvider extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedIndexAuthConfig.AuthProvider';

  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted.
  final List<String> audiences;

  /// A list of allowed JWT issuers. Each entry must be a valid Google
  /// service account, in the following format:
  ///
  /// `service-account-name@project-id.iam.gserviceaccount.com`
  final List<String> allowedIssuers;

  DeployedIndexAuthConfig_AuthProvider({
    this.audiences = const [],
    this.allowedIssuers = const [],
  }) : super(fullyQualifiedName);

  factory DeployedIndexAuthConfig_AuthProvider.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployedIndexAuthConfig_AuthProvider(
      audiences: switch (json['audiences']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"audiences" is not a list'),
      },
      allowedIssuers: switch (json['allowedIssuers']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"allowedIssuers" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (audiences.isNotDefault) 'audiences': audiences,
    if (allowedIssuers.isNotDefault) 'allowedIssuers': allowedIssuers,
  };

  @override
  String toString() => 'AuthProvider()';
}

/// IndexPrivateEndpoints proto is used to provide paths for users to send
/// requests via private endpoints (e.g. private service access, private service
/// connect).
/// To send request via private service access, use match_grpc_address.
/// To send request via private service connect, use service_attachment.
final class IndexPrivateEndpoints extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexPrivateEndpoints';

  /// Output only. The ip address used to send match gRPC requests.
  final String matchGrpcAddress;

  /// Output only. The name of the service attachment resource. Populated if
  /// private service connect is enabled.
  final String serviceAttachment;

  /// Output only. PscAutomatedEndpoints is populated if private service connect
  /// is enabled if PscAutomatedConfig is set.
  final List<PscAutomatedEndpoints> pscAutomatedEndpoints;

  IndexPrivateEndpoints({
    this.matchGrpcAddress = '',
    this.serviceAttachment = '',
    this.pscAutomatedEndpoints = const [],
  }) : super(fullyQualifiedName);

  factory IndexPrivateEndpoints.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return IndexPrivateEndpoints(
      matchGrpcAddress: switch (json['matchGrpcAddress']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAttachment: switch (json['serviceAttachment']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pscAutomatedEndpoints: switch (json['pscAutomatedEndpoints']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PscAutomatedEndpoints.fromJson(i),
        ],
        _ => throw const FormatException(
          '"pscAutomatedEndpoints" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (matchGrpcAddress.isNotDefault) 'matchGrpcAddress': matchGrpcAddress,
    if (serviceAttachment.isNotDefault) 'serviceAttachment': serviceAttachment,
    if (pscAutomatedEndpoints.isNotDefault)
      'pscAutomatedEndpoints': encodeList(pscAutomatedEndpoints),
  };

  @override
  String toString() {
    final contents = [
      'matchGrpcAddress=$matchGrpcAddress',
      'serviceAttachment=$serviceAttachment',
    ].join(',');
    return 'IndexPrivateEndpoints($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.CreateIndexEndpoint`.
final class CreateIndexEndpointRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateIndexEndpointRequest';

  /// Required. The resource name of the Location to create the IndexEndpoint in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The IndexEndpoint to create.
  final IndexEndpoint? indexEndpoint;

  CreateIndexEndpointRequest({
    required this.parent,
    required this.indexEndpoint,
  }) : super(fullyQualifiedName);

  factory CreateIndexEndpointRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateIndexEndpointRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      indexEndpoint: switch (json['indexEndpoint']) {
        null => null,
        Object $1 => IndexEndpoint.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (indexEndpoint != null) 'indexEndpoint': indexEndpoint!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateIndexEndpointRequest($contents)';
  }
}

/// Runtime operation information for
/// `IndexEndpointService.CreateIndexEndpoint`.
final class CreateIndexEndpointOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateIndexEndpointOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateIndexEndpointOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateIndexEndpointOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateIndexEndpointOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateIndexEndpointOperationMetadata()';
}

/// Request message for
/// `IndexEndpointService.GetIndexEndpoint`
final class GetIndexEndpointRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetIndexEndpointRequest';

  /// Required. The name of the IndexEndpoint resource.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String name;

  GetIndexEndpointRequest({required this.name}) : super(fullyQualifiedName);

  factory GetIndexEndpointRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetIndexEndpointRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetIndexEndpointRequest($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.ListIndexEndpoints`.
final class ListIndexEndpointsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListIndexEndpointsRequest';

  /// Required. The resource name of the Location from which to list the
  /// IndexEndpoints. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `index_endpoint` supports = and !=. `index_endpoint` represents the
  ///      IndexEndpoint ID, ie. the last segment of the IndexEndpoint's
  ///      `resourcename`.
  ///   * `display_name` supports =, != and regex()
  ///             (uses [re2](https://github.com/google/re2/wiki/Syntax) syntax)
  ///   * `labels` supports general map functions that is:
  ///             `labels.key=value` - key:value equality
  ///             `labels.key:* or labels:key - key existence
  ///              A key including a space must be quoted. `labels."a key"`.
  ///
  /// Some examples:
  ///   * `index_endpoint="1"`
  ///   * `display_name="myDisplayName"`
  ///   * `regex(display_name, "^A") -> The display name starts with an A.
  ///   * `labels.myKey="myValue"`
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListIndexEndpointsResponse.next_page_token`
  /// of the previous
  /// `IndexEndpointService.ListIndexEndpoints`
  /// call.
  final String pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListIndexEndpointsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListIndexEndpointsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListIndexEndpointsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListIndexEndpointsRequest($contents)';
  }
}

/// Response message for
/// `IndexEndpointService.ListIndexEndpoints`.
final class ListIndexEndpointsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListIndexEndpointsResponse';

  /// List of IndexEndpoints in the requested page.
  final List<IndexEndpoint> indexEndpoints;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListIndexEndpointsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListIndexEndpointsResponse({
    this.indexEndpoints = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListIndexEndpointsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListIndexEndpointsResponse(
      indexEndpoints: switch (json['indexEndpoints']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) IndexEndpoint.fromJson(i)],
        _ => throw const FormatException('"indexEndpoints" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (indexEndpoints.isNotDefault)
      'indexEndpoints': encodeList(indexEndpoints),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListIndexEndpointsResponse($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.UpdateIndexEndpoint`.
final class UpdateIndexEndpointRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateIndexEndpointRequest';

  /// Required. The IndexEndpoint which replaces the resource on the server.
  final IndexEndpoint? indexEndpoint;

  /// Required. The update mask applies to the resource. See
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateIndexEndpointRequest({
    required this.indexEndpoint,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateIndexEndpointRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateIndexEndpointRequest(
      indexEndpoint: switch (json['indexEndpoint']) {
        null => null,
        Object $1 => IndexEndpoint.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (indexEndpoint != null) 'indexEndpoint': indexEndpoint!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateIndexEndpointRequest()';
}

/// Request message for
/// `IndexEndpointService.DeleteIndexEndpoint`.
final class DeleteIndexEndpointRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteIndexEndpointRequest';

  /// Required. The name of the IndexEndpoint resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String name;

  DeleteIndexEndpointRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteIndexEndpointRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteIndexEndpointRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteIndexEndpointRequest($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.DeployIndex`.
final class DeployIndexRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployIndexRequest';

  /// Required. The name of the IndexEndpoint resource into which to deploy an
  /// Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// Required. The DeployedIndex to be created within the IndexEndpoint.
  final DeployedIndex? deployedIndex;

  DeployIndexRequest({required this.indexEndpoint, required this.deployedIndex})
    : super(fullyQualifiedName);

  factory DeployIndexRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployIndexRequest(
      indexEndpoint: switch (json['indexEndpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedIndex: switch (json['deployedIndex']) {
        null => null,
        Object $1 => DeployedIndex.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'indexEndpoint': indexEndpoint,
    if (deployedIndex != null) 'deployedIndex': deployedIndex!.toJson(),
  };

  @override
  String toString() {
    final contents = ['indexEndpoint=$indexEndpoint'].join(',');
    return 'DeployIndexRequest($contents)';
  }
}

/// Response message for
/// `IndexEndpointService.DeployIndex`.
final class DeployIndexResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployIndexResponse';

  /// The DeployedIndex that had been deployed in the IndexEndpoint.
  final DeployedIndex? deployedIndex;

  DeployIndexResponse({this.deployedIndex}) : super(fullyQualifiedName);

  factory DeployIndexResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployIndexResponse(
      deployedIndex: switch (json['deployedIndex']) {
        null => null,
        Object $1 => DeployedIndex.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (deployedIndex != null) 'deployedIndex': deployedIndex!.toJson(),
  };

  @override
  String toString() => 'DeployIndexResponse()';
}

/// Runtime operation information for
/// `IndexEndpointService.DeployIndex`.
final class DeployIndexOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The unique index id specified by user
  final String deployedIndexId;

  DeployIndexOperationMetadata({
    this.genericMetadata,
    this.deployedIndexId = '',
  }) : super(fullyQualifiedName);

  factory DeployIndexOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployIndexOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      deployedIndexId: switch (json['deployedIndexId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (deployedIndexId.isNotDefault) 'deployedIndexId': deployedIndexId,
  };

  @override
  String toString() {
    final contents = ['deployedIndexId=$deployedIndexId'].join(',');
    return 'DeployIndexOperationMetadata($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.UndeployIndex`.
final class UndeployIndexRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployIndexRequest';

  /// Required. The name of the IndexEndpoint resource from which to undeploy an
  /// Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// Required. The ID of the DeployedIndex to be undeployed from the
  /// IndexEndpoint.
  final String deployedIndexId;

  UndeployIndexRequest({
    required this.indexEndpoint,
    required this.deployedIndexId,
  }) : super(fullyQualifiedName);

  factory UndeployIndexRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UndeployIndexRequest(
      indexEndpoint: switch (json['indexEndpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedIndexId: switch (json['deployedIndexId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'indexEndpoint': indexEndpoint,
    'deployedIndexId': deployedIndexId,
  };

  @override
  String toString() {
    final contents = [
      'indexEndpoint=$indexEndpoint',
      'deployedIndexId=$deployedIndexId',
    ].join(',');
    return 'UndeployIndexRequest($contents)';
  }
}

/// Response message for
/// `IndexEndpointService.UndeployIndex`.
final class UndeployIndexResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployIndexResponse';

  UndeployIndexResponse() : super(fullyQualifiedName);

  factory UndeployIndexResponse.fromJson(Object? j) => UndeployIndexResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'UndeployIndexResponse()';
}

/// Runtime operation information for
/// `IndexEndpointService.UndeployIndex`.
final class UndeployIndexOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UndeployIndexOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UndeployIndexOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UndeployIndexOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UndeployIndexOperationMetadata()';
}

/// Request message for
/// `IndexEndpointService.MutateDeployedIndex`.
final class MutateDeployedIndexRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedIndexRequest';

  /// Required. The name of the IndexEndpoint resource into which to deploy an
  /// Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// Required. The DeployedIndex to be updated within the IndexEndpoint.
  /// Currently, the updatable fields are `DeployedIndex`
  /// and `DeployedIndex`
  final DeployedIndex? deployedIndex;

  MutateDeployedIndexRequest({
    required this.indexEndpoint,
    required this.deployedIndex,
  }) : super(fullyQualifiedName);

  factory MutateDeployedIndexRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MutateDeployedIndexRequest(
      indexEndpoint: switch (json['indexEndpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedIndex: switch (json['deployedIndex']) {
        null => null,
        Object $1 => DeployedIndex.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'indexEndpoint': indexEndpoint,
    if (deployedIndex != null) 'deployedIndex': deployedIndex!.toJson(),
  };

  @override
  String toString() {
    final contents = ['indexEndpoint=$indexEndpoint'].join(',');
    return 'MutateDeployedIndexRequest($contents)';
  }
}

/// Response message for
/// `IndexEndpointService.MutateDeployedIndex`.
final class MutateDeployedIndexResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedIndexResponse';

  /// The DeployedIndex that had been updated in the IndexEndpoint.
  final DeployedIndex? deployedIndex;

  MutateDeployedIndexResponse({this.deployedIndex}) : super(fullyQualifiedName);

  factory MutateDeployedIndexResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MutateDeployedIndexResponse(
      deployedIndex: switch (json['deployedIndex']) {
        null => null,
        Object $1 => DeployedIndex.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (deployedIndex != null) 'deployedIndex': deployedIndex!.toJson(),
  };

  @override
  String toString() => 'MutateDeployedIndexResponse()';
}

/// Runtime operation information for
/// `IndexEndpointService.MutateDeployedIndex`.
final class MutateDeployedIndexOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The unique index id specified by user
  final String deployedIndexId;

  MutateDeployedIndexOperationMetadata({
    this.genericMetadata,
    this.deployedIndexId = '',
  }) : super(fullyQualifiedName);

  factory MutateDeployedIndexOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MutateDeployedIndexOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      deployedIndexId: switch (json['deployedIndexId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (deployedIndexId.isNotDefault) 'deployedIndexId': deployedIndexId,
  };

  @override
  String toString() {
    final contents = ['deployedIndexId=$deployedIndexId'].join(',');
    return 'MutateDeployedIndexOperationMetadata($contents)';
  }
}

/// Request message for
/// `IndexService.CreateIndex`.
final class CreateIndexRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateIndexRequest';

  /// Required. The resource name of the Location to create the Index in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Index to create.
  final Index? index;

  CreateIndexRequest({required this.parent, required this.index})
    : super(fullyQualifiedName);

  factory CreateIndexRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateIndexRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      index: switch (json['index']) {
        null => null,
        Object $1 => Index.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (index != null) 'index': index!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateIndexRequest($contents)';
  }
}

/// Runtime operation information for
/// `IndexService.CreateIndex`.
final class CreateIndexOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The operation metadata with regard to Matching Engine Index operation.
  final NearestNeighborSearchOperationMetadata?
  nearestNeighborSearchOperationMetadata;

  CreateIndexOperationMetadata({
    this.genericMetadata,
    this.nearestNeighborSearchOperationMetadata,
  }) : super(fullyQualifiedName);

  factory CreateIndexOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateIndexOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      nearestNeighborSearchOperationMetadata:
          switch (json['nearestNeighborSearchOperationMetadata']) {
            null => null,
            Object $1 => NearestNeighborSearchOperationMetadata.fromJson($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (nearestNeighborSearchOperationMetadata != null)
      'nearestNeighborSearchOperationMetadata':
          nearestNeighborSearchOperationMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateIndexOperationMetadata()';
}

/// Request message for
/// `IndexService.GetIndex`
final class GetIndexRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetIndexRequest';

  /// Required. The name of the Index resource.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String name;

  GetIndexRequest({required this.name}) : super(fullyQualifiedName);

  factory GetIndexRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetIndexRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetIndexRequest($contents)';
  }
}

/// Request message for
/// `IndexService.ListIndexes`.
final class ListIndexesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListIndexesRequest';

  /// Required. The resource name of the Location from which to list the Indexes.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListIndexesResponse.next_page_token`
  /// of the previous
  /// `IndexService.ListIndexes`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListIndexesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListIndexesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListIndexesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListIndexesRequest($contents)';
  }
}

/// Response message for
/// `IndexService.ListIndexes`.
final class ListIndexesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListIndexesResponse';

  /// List of indexes in the requested page.
  final List<Index> indexes;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListIndexesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListIndexesResponse({this.indexes = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListIndexesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListIndexesResponse(
      indexes: switch (json['indexes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Index.fromJson(i)],
        _ => throw const FormatException('"indexes" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (indexes.isNotDefault) 'indexes': encodeList(indexes),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListIndexesResponse($contents)';
  }
}

/// Request message for
/// `IndexService.UpdateIndex`.
final class UpdateIndexRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateIndexRequest';

  /// Required. The Index which updates the resource on the server.
  final Index? index;

  /// The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateIndexRequest({required this.index, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateIndexRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateIndexRequest(
      index: switch (json['index']) {
        null => null,
        Object $1 => Index.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (index != null) 'index': index!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateIndexRequest()';
}

/// Runtime operation information for
/// `IndexService.UpdateIndex`.
final class UpdateIndexOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The operation metadata with regard to Matching Engine Index operation.
  final NearestNeighborSearchOperationMetadata?
  nearestNeighborSearchOperationMetadata;

  UpdateIndexOperationMetadata({
    this.genericMetadata,
    this.nearestNeighborSearchOperationMetadata,
  }) : super(fullyQualifiedName);

  factory UpdateIndexOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateIndexOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      nearestNeighborSearchOperationMetadata:
          switch (json['nearestNeighborSearchOperationMetadata']) {
            null => null,
            Object $1 => NearestNeighborSearchOperationMetadata.fromJson($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (nearestNeighborSearchOperationMetadata != null)
      'nearestNeighborSearchOperationMetadata':
          nearestNeighborSearchOperationMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateIndexOperationMetadata()';
}

/// Request message for
/// `IndexService.ImportIndex`.
final class ImportIndexRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest';

  /// Required. The name of the Index resource to import data to.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String name;

  /// Optional. If true, completely replace existing index data. Must be true for
  /// streaming update indexes.
  final bool isCompleteOverwrite;

  /// Required. Configuration for importing data from an external source.
  final ImportIndexRequest_ConnectorConfig? config;

  ImportIndexRequest({
    required this.name,
    this.isCompleteOverwrite = false,
    required this.config,
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportIndexRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      isCompleteOverwrite: switch (json['isCompleteOverwrite']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      config: switch (json['config']) {
        null => null,
        Object $1 => ImportIndexRequest_ConnectorConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (isCompleteOverwrite.isNotDefault)
      'isCompleteOverwrite': isCompleteOverwrite,
    if (config != null) 'config': config!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'isCompleteOverwrite=$isCompleteOverwrite',
    ].join(',');
    return 'ImportIndexRequest($contents)';
  }
}

/// Configuration for importing data from an external source.
final class ImportIndexRequest_ConnectorConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig';

  /// Configuration for importing data from a BigQuery table.
  final ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig?
  bigQuerySourceConfig;

  ImportIndexRequest_ConnectorConfig({this.bigQuerySourceConfig})
    : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportIndexRequest_ConnectorConfig(
      bigQuerySourceConfig: switch (json['bigQuerySourceConfig']) {
        null => null,
        Object $1 =>
          ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bigQuerySourceConfig != null)
      'bigQuerySourceConfig': bigQuerySourceConfig!.toJson(),
  };

  @override
  String toString() => 'ConnectorConfig()';
}

/// Mapping of datapoint fields to column names for columnar data sources.
final class ImportIndexRequest_ConnectorConfig_DatapointFieldMapping
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig.DatapointFieldMapping';

  /// Required. The column with unique identifiers for each data point.
  final String idColumn;

  /// Required. The column with the vector embeddings for each data point.
  final String embeddingColumn;

  /// Optional. List of restricts for string values.
  final List<ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict>
  restricts;

  /// Optional. List of restricts for numeric values.
  final List<
    ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict
  >
  numericRestricts;

  /// Optional. List of columns containing metadata to be included in the
  /// index.
  final List<String> metadataColumns;

  ImportIndexRequest_ConnectorConfig_DatapointFieldMapping({
    required this.idColumn,
    required this.embeddingColumn,
    this.restricts = const [],
    this.numericRestricts = const [],
    this.metadataColumns = const [],
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig_DatapointFieldMapping.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ImportIndexRequest_ConnectorConfig_DatapointFieldMapping(
      idColumn: switch (json['idColumn']) {
        null => '',
        Object $1 => decodeString($1),
      },
      embeddingColumn: switch (json['embeddingColumn']) {
        null => '',
        Object $1 => decodeString($1),
      },
      restricts: switch (json['restricts']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException('"restricts" is not a list'),
      },
      numericRestricts: switch (json['numericRestricts']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException('"numericRestricts" is not a list'),
      },
      metadataColumns: switch (json['metadataColumns']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"metadataColumns" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'idColumn': idColumn,
    'embeddingColumn': embeddingColumn,
    if (restricts.isNotDefault) 'restricts': encodeList(restricts),
    if (numericRestricts.isNotDefault)
      'numericRestricts': encodeList(numericRestricts),
    if (metadataColumns.isNotDefault) 'metadataColumns': metadataColumns,
  };

  @override
  String toString() {
    final contents = [
      'idColumn=$idColumn',
      'embeddingColumn=$embeddingColumn',
    ].join(',');
    return 'DatapointFieldMapping($contents)';
  }
}

/// Restrictions on string values.
final class ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig.DatapointFieldMapping.Restrict';

  /// Required. The namespace of the restrict in the index.
  final String namespace;

  /// Optional. The columns containing the allow values.
  final List<String> allowColumn;

  /// Optional. The columns containing the deny values.
  final List<String> denyColumn;

  ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict({
    required this.namespace,
    this.allowColumn = const [],
    this.denyColumn = const [],
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict(
      namespace: switch (json['namespace']) {
        null => '',
        Object $1 => decodeString($1),
      },
      allowColumn: switch (json['allowColumn']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"allowColumn" is not a list'),
      },
      denyColumn: switch (json['denyColumn']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"denyColumn" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'namespace': namespace,
    if (allowColumn.isNotDefault) 'allowColumn': allowColumn,
    if (denyColumn.isNotDefault) 'denyColumn': denyColumn,
  };

  @override
  String toString() {
    final contents = ['namespace=$namespace'].join(',');
    return 'Restrict($contents)';
  }
}

/// Restrictions on numeric values.
final class ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig.DatapointFieldMapping.NumericRestrict';

  /// Required. The namespace of the restrict.
  final String namespace;

  /// Optional. The column containing the numeric value.
  final String valueColumn;

  /// Required. Numeric type of the restrict. Must be consistent for
  /// all datapoints within the namespace.
  final ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType
  valueType;

  ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict({
    required this.namespace,
    this.valueColumn = '',
    required this.valueType,
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict(
      namespace: switch (json['namespace']) {
        null => '',
        Object $1 => decodeString($1),
      },
      valueColumn: switch (json['valueColumn']) {
        null => '',
        Object $1 => decodeString($1),
      },
      valueType: switch (json['valueType']) {
        null =>
          ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType
              .$default,
        Object $1 =>
          ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    'namespace': namespace,
    if (valueColumn.isNotDefault) 'valueColumn': valueColumn,
    'valueType': valueType.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'namespace=$namespace',
      'valueColumn=$valueColumn',
      'valueType=$valueType',
    ].join(',');
    return 'NumericRestrict($contents)';
  }
}

/// The type of numeric value for the restrict.
final class ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType
    extends ProtoEnum {
  /// Should not be used.
  static const valueTypeUnspecified =
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        'VALUE_TYPE_UNSPECIFIED',
      );

  /// Represents 64 bit integer.
  static const int =
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        'INT',
      );

  /// Represents 32 bit float.
  static const float =
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        'FLOAT',
      );

  /// Represents 64 bit float.
  static const double$ =
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        'DOUBLE',
      );

  /// The default value for [ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType].
  static const $default = valueTypeUnspecified;

  const ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
    super.value,
  );

  factory ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType.fromJson(
    Object? json,
  ) =>
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        json as String,
      );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ValueType.$value';
}

/// Configuration for importing data from a BigQuery table.
final class ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig.BigQuerySourceConfig';

  /// Required. The path to the BigQuery table containing the index data, in
  /// the format of `bq://<project_id>.<dataset_id>.<table>`.
  final String tablePath;

  /// Required. Mapping of datapoint fields to BigQuery column names.
  final ImportIndexRequest_ConnectorConfig_DatapointFieldMapping?
  datapointFieldMapping;

  ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig({
    required this.tablePath,
    required this.datapointFieldMapping,
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig(
      tablePath: switch (json['tablePath']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datapointFieldMapping: switch (json['datapointFieldMapping']) {
        null => null,
        Object $1 =>
          ImportIndexRequest_ConnectorConfig_DatapointFieldMapping.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'tablePath': tablePath,
    if (datapointFieldMapping != null)
      'datapointFieldMapping': datapointFieldMapping!.toJson(),
  };

  @override
  String toString() {
    final contents = ['tablePath=$tablePath'].join(',');
    return 'BigQuerySourceConfig($contents)';
  }
}

/// Runtime operation information for
/// `IndexService.ImportIndex`.
final class ImportIndexOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  ImportIndexOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ImportIndexOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportIndexOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'ImportIndexOperationMetadata()';
}

/// Request message for
/// `IndexService.DeleteIndex`.
final class DeleteIndexRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteIndexRequest';

  /// Required. The name of the Index resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String name;

  DeleteIndexRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteIndexRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteIndexRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteIndexRequest($contents)';
  }
}

/// Request message for
/// `IndexService.UpsertDatapoints`
final class UpsertDatapointsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertDatapointsRequest';

  /// Required. The name of the Index resource to be updated.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String index;

  /// A list of datapoints to be created/updated.
  final List<IndexDatapoint> datapoints;

  /// Optional. Update mask is used to specify the fields to be overwritten in
  /// the datapoints by the update. The fields specified in the update_mask are
  /// relative to each IndexDatapoint inside datapoints, not the full request.
  ///
  /// Updatable fields:
  ///
  ///   * Use `all_restricts` to update both restricts and numeric_restricts.
  final protobuf.FieldMask? updateMask;

  UpsertDatapointsRequest({
    required this.index,
    this.datapoints = const [],
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpsertDatapointsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpsertDatapointsRequest(
      index: switch (json['index']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datapoints: switch (json['datapoints']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) IndexDatapoint.fromJson(i)],
        _ => throw const FormatException('"datapoints" is not a list'),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'index': index,
    if (datapoints.isNotDefault) 'datapoints': encodeList(datapoints),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() {
    final contents = ['index=$index'].join(',');
    return 'UpsertDatapointsRequest($contents)';
  }
}

/// Response message for
/// `IndexService.UpsertDatapoints`
final class UpsertDatapointsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertDatapointsResponse';

  UpsertDatapointsResponse() : super(fullyQualifiedName);

  factory UpsertDatapointsResponse.fromJson(Object? j) =>
      UpsertDatapointsResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'UpsertDatapointsResponse()';
}

/// Request message for
/// `IndexService.RemoveDatapoints`
final class RemoveDatapointsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveDatapointsRequest';

  /// Required. The name of the Index resource to be updated.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String index;

  /// A list of datapoint ids to be deleted.
  final List<String> datapointIds;

  RemoveDatapointsRequest({required this.index, this.datapointIds = const []})
    : super(fullyQualifiedName);

  factory RemoveDatapointsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RemoveDatapointsRequest(
      index: switch (json['index']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datapointIds: switch (json['datapointIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"datapointIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'index': index,
    if (datapointIds.isNotDefault) 'datapointIds': datapointIds,
  };

  @override
  String toString() {
    final contents = ['index=$index'].join(',');
    return 'RemoveDatapointsRequest($contents)';
  }
}

/// Response message for
/// `IndexService.RemoveDatapoints`
final class RemoveDatapointsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveDatapointsResponse';

  RemoveDatapointsResponse() : super(fullyQualifiedName);

  factory RemoveDatapointsResponse.fromJson(Object? j) =>
      RemoveDatapointsResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'RemoveDatapointsResponse()';
}

/// Runtime operation metadata with regard to Matching Engine Index.
final class NearestNeighborSearchOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborSearchOperationMetadata';

  /// The validation stats of the content (per file) to be inserted or
  /// updated on the Matching Engine Index resource. Populated if
  /// contentsDeltaUri is provided as part of
  /// `Index.metadata`. Please
  /// note that, currently for those files that are broken or has unsupported
  /// file format, we will not have the stats for those files.
  final List<NearestNeighborSearchOperationMetadata_ContentValidationStats>
  contentValidationStats;

  /// The ingested data size in bytes.
  final int dataBytesCount;

  NearestNeighborSearchOperationMetadata({
    this.contentValidationStats = const [],
    this.dataBytesCount = 0,
  }) : super(fullyQualifiedName);

  factory NearestNeighborSearchOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NearestNeighborSearchOperationMetadata(
      contentValidationStats: switch (json['contentValidationStats']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            NearestNeighborSearchOperationMetadata_ContentValidationStats.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException(
          '"contentValidationStats" is not a list',
        ),
      },
      dataBytesCount: switch (json['dataBytesCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (contentValidationStats.isNotDefault)
      'contentValidationStats': encodeList(contentValidationStats),
    if (dataBytesCount.isNotDefault)
      'dataBytesCount': encodeInt64(dataBytesCount),
  };

  @override
  String toString() {
    final contents = ['dataBytesCount=$dataBytesCount'].join(',');
    return 'NearestNeighborSearchOperationMetadata($contents)';
  }
}

final class NearestNeighborSearchOperationMetadata_RecordError
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborSearchOperationMetadata.RecordError';

  /// The error type of this record.
  final NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType
  errorType;

  /// A human-readable message that is shown to the user to help them fix the
  /// error. Note that this message may change from time to time, your code
  /// should check against error_type as the source of truth.
  final String errorMessage;

  /// Cloud Storage URI pointing to the original file in user's bucket.
  final String sourceGcsUri;

  /// Empty if the embedding id is failed to parse.
  final String embeddingId;

  /// The original content of this record.
  final String rawRecord;

  NearestNeighborSearchOperationMetadata_RecordError({
    this.errorType =
        NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType
            .$default,
    this.errorMessage = '',
    this.sourceGcsUri = '',
    this.embeddingId = '',
    this.rawRecord = '',
  }) : super(fullyQualifiedName);

  factory NearestNeighborSearchOperationMetadata_RecordError.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return NearestNeighborSearchOperationMetadata_RecordError(
      errorType: switch (json['errorType']) {
        null =>
          NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType
              .$default,
        Object $1 =>
          NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.fromJson(
            $1,
          ),
      },
      errorMessage: switch (json['errorMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sourceGcsUri: switch (json['sourceGcsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      embeddingId: switch (json['embeddingId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      rawRecord: switch (json['rawRecord']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (errorType.isNotDefault) 'errorType': errorType.toJson(),
    if (errorMessage.isNotDefault) 'errorMessage': errorMessage,
    if (sourceGcsUri.isNotDefault) 'sourceGcsUri': sourceGcsUri,
    if (embeddingId.isNotDefault) 'embeddingId': embeddingId,
    if (rawRecord.isNotDefault) 'rawRecord': rawRecord,
  };

  @override
  String toString() {
    final contents = [
      'errorType=$errorType',
      'errorMessage=$errorMessage',
      'sourceGcsUri=$sourceGcsUri',
      'embeddingId=$embeddingId',
      'rawRecord=$rawRecord',
    ].join(',');
    return 'RecordError($contents)';
  }
}

final class NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType
    extends ProtoEnum {
  /// Default, shall not be used.
  static const errorTypeUnspecified =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'ERROR_TYPE_UNSPECIFIED',
      );

  /// The record is empty.
  static const emptyLine =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'EMPTY_LINE',
      );

  /// Invalid json format.
  static const invalidJsonSyntax =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_JSON_SYNTAX',
      );

  /// Invalid csv format.
  static const invalidCsvSyntax =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_CSV_SYNTAX',
      );

  /// Invalid avro format.
  static const invalidAvroSyntax =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_AVRO_SYNTAX',
      );

  /// The embedding id is not valid.
  static const invalidEmbeddingId =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_EMBEDDING_ID',
      );

  /// The size of the dense embedding vectors does not match with the
  /// specified dimension.
  static const embeddingSizeMismatch =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'EMBEDDING_SIZE_MISMATCH',
      );

  /// The `namespace` field is missing.
  static const namespaceMissing =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'NAMESPACE_MISSING',
      );

  /// Generic catch-all error. Only used for validation failure where the
  /// root cause cannot be easily retrieved programmatically.
  static const parsingError =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'PARSING_ERROR',
      );

  /// There are multiple restricts with the same `namespace` value.
  static const duplicateNamespace =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'DUPLICATE_NAMESPACE',
      );

  /// Numeric restrict has operator specified in datapoint.
  static const opInDatapoint =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'OP_IN_DATAPOINT',
      );

  /// Numeric restrict has multiple values specified.
  static const multipleValues =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'MULTIPLE_VALUES',
      );

  /// Numeric restrict has invalid numeric value specified.
  static const invalidNumericValue =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_NUMERIC_VALUE',
      );

  /// File is not in UTF_8 format.
  static const invalidEncoding =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_ENCODING',
      );

  /// Error parsing sparse dimensions field.
  static const invalidSparseDimensions =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_SPARSE_DIMENSIONS',
      );

  /// Token restrict value is invalid.
  static const invalidTokenValue =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_TOKEN_VALUE',
      );

  /// Invalid sparse embedding.
  static const invalidSparseEmbedding =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_SPARSE_EMBEDDING',
      );

  /// Invalid dense embedding.
  static const invalidEmbedding =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_EMBEDDING',
      );

  /// Invalid embedding metadata.
  static const invalidEmbeddingMetadata =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_EMBEDDING_METADATA',
      );

  /// Embedding metadata exceeds size limit.
  static const embeddingMetadataExceedsSizeLimit =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'EMBEDDING_METADATA_EXCEEDS_SIZE_LIMIT',
      );

  /// The default value for [NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType].
  static const $default = errorTypeUnspecified;

  const NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
    super.value,
  );

  factory NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.fromJson(
    Object? json,
  ) => NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
    json as String,
  );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'RecordErrorType.$value';
}

final class NearestNeighborSearchOperationMetadata_ContentValidationStats
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborSearchOperationMetadata.ContentValidationStats';

  /// Cloud Storage URI pointing to the original file in user's bucket.
  final String sourceGcsUri;

  /// Number of records in this file that were successfully processed.
  final int validRecordCount;

  /// Number of records in this file we skipped due to validate errors.
  final int invalidRecordCount;

  /// The detail information of the partial failures encountered for those
  /// invalid records that couldn't be parsed.
  /// Up to 50 partial errors will be reported.
  final List<NearestNeighborSearchOperationMetadata_RecordError> partialErrors;

  /// Number of sparse records in this file that were successfully processed.
  final int validSparseRecordCount;

  /// Number of sparse records in this file we skipped due to validate errors.
  final int invalidSparseRecordCount;

  NearestNeighborSearchOperationMetadata_ContentValidationStats({
    this.sourceGcsUri = '',
    this.validRecordCount = 0,
    this.invalidRecordCount = 0,
    this.partialErrors = const [],
    this.validSparseRecordCount = 0,
    this.invalidSparseRecordCount = 0,
  }) : super(fullyQualifiedName);

  factory NearestNeighborSearchOperationMetadata_ContentValidationStats.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return NearestNeighborSearchOperationMetadata_ContentValidationStats(
      sourceGcsUri: switch (json['sourceGcsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      validRecordCount: switch (json['validRecordCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      invalidRecordCount: switch (json['invalidRecordCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      partialErrors: switch (json['partialErrors']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            NearestNeighborSearchOperationMetadata_RecordError.fromJson(i),
        ],
        _ => throw const FormatException('"partialErrors" is not a list'),
      },
      validSparseRecordCount: switch (json['validSparseRecordCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      invalidSparseRecordCount: switch (json['invalidSparseRecordCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sourceGcsUri.isNotDefault) 'sourceGcsUri': sourceGcsUri,
    if (validRecordCount.isNotDefault)
      'validRecordCount': encodeInt64(validRecordCount),
    if (invalidRecordCount.isNotDefault)
      'invalidRecordCount': encodeInt64(invalidRecordCount),
    if (partialErrors.isNotDefault) 'partialErrors': encodeList(partialErrors),
    if (validSparseRecordCount.isNotDefault)
      'validSparseRecordCount': encodeInt64(validSparseRecordCount),
    if (invalidSparseRecordCount.isNotDefault)
      'invalidSparseRecordCount': encodeInt64(invalidSparseRecordCount),
  };

  @override
  String toString() {
    final contents = [
      'sourceGcsUri=$sourceGcsUri',
      'validRecordCount=$validRecordCount',
      'invalidRecordCount=$invalidRecordCount',
      'validSparseRecordCount=$validSparseRecordCount',
      'invalidSparseRecordCount=$invalidSparseRecordCount',
    ].join(',');
    return 'ContentValidationStats($contents)';
  }
}

/// The storage details for Avro input content.
final class AvroSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AvroSource';

  /// Required. Google Cloud Storage location.
  final GcsSource? gcsSource;

  AvroSource({required this.gcsSource}) : super(fullyQualifiedName);

  factory AvroSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AvroSource(
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (gcsSource != null) 'gcsSource': gcsSource!.toJson()};

  @override
  String toString() => 'AvroSource()';
}

/// The storage details for CSV input content.
final class CsvSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CsvSource';

  /// Required. Google Cloud Storage location.
  final GcsSource? gcsSource;

  CsvSource({required this.gcsSource}) : super(fullyQualifiedName);

  factory CsvSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CsvSource(
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (gcsSource != null) 'gcsSource': gcsSource!.toJson()};

  @override
  String toString() => 'CsvSource()';
}

/// The Google Cloud Storage location for the input content.
final class GcsSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GcsSource';

  /// Required. Google Cloud Storage URI(-s) to the input file(s). May contain
  /// wildcards. For more information on wildcards, see
  /// https://cloud.google.com/storage/docs/wildcards.
  final List<String> uris;

  GcsSource({required this.uris}) : super(fullyQualifiedName);

  factory GcsSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GcsSource(
      uris: switch (json['uris']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"uris" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'uris': uris};

  @override
  String toString() => 'GcsSource()';
}

/// The Google Cloud Storage location where the output is to be written to.
final class GcsDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GcsDestination';

  /// Required. Google Cloud Storage URI to output directory. If the uri doesn't
  /// end with
  /// '/', a '/' will be automatically appended. The directory is created if it
  /// doesn't exist.
  final String outputUriPrefix;

  GcsDestination({required this.outputUriPrefix}) : super(fullyQualifiedName);

  factory GcsDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GcsDestination(
      outputUriPrefix: switch (json['outputUriPrefix']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'outputUriPrefix': outputUriPrefix};

  @override
  String toString() {
    final contents = ['outputUriPrefix=$outputUriPrefix'].join(',');
    return 'GcsDestination($contents)';
  }
}

/// The BigQuery location for the input content.
final class BigQuerySource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BigQuerySource';

  /// Required. BigQuery URI to a table, up to 2000 characters long.
  /// Accepted forms:
  ///
  /// *  BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
  final String inputUri;

  BigQuerySource({required this.inputUri}) : super(fullyQualifiedName);

  factory BigQuerySource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BigQuerySource(
      inputUri: switch (json['inputUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'inputUri': inputUri};

  @override
  String toString() {
    final contents = ['inputUri=$inputUri'].join(',');
    return 'BigQuerySource($contents)';
  }
}

/// The BigQuery location for the output content.
final class BigQueryDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BigQueryDestination';

  /// Required. BigQuery URI to a project or table, up to 2000 characters long.
  ///
  /// When only the project is specified, the Dataset and Table is created.
  /// When the full table reference is specified, the Dataset must exist and
  /// table must not exist.
  ///
  /// Accepted forms:
  ///
  /// *  BigQuery path. For example:
  /// `bq://projectId` or `bq://projectId.bqDatasetId` or
  /// `bq://projectId.bqDatasetId.bqTableId`.
  final String outputUri;

  BigQueryDestination({required this.outputUri}) : super(fullyQualifiedName);

  factory BigQueryDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BigQueryDestination(
      outputUri: switch (json['outputUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'outputUri': outputUri};

  @override
  String toString() {
    final contents = ['outputUri=$outputUri'].join(',');
    return 'BigQueryDestination($contents)';
  }
}

/// The storage details for CSV output content.
final class CsvDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CsvDestination';

  /// Required. Google Cloud Storage location.
  final GcsDestination? gcsDestination;

  CsvDestination({required this.gcsDestination}) : super(fullyQualifiedName);

  factory CsvDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CsvDestination(
      gcsDestination: switch (json['gcsDestination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
  };

  @override
  String toString() => 'CsvDestination()';
}

/// The storage details for TFRecord output content.
final class TfrecordDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TFRecordDestination';

  /// Required. Google Cloud Storage location.
  final GcsDestination? gcsDestination;

  TfrecordDestination({required this.gcsDestination})
    : super(fullyQualifiedName);

  factory TfrecordDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TfrecordDestination(
      gcsDestination: switch (json['gcsDestination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
  };

  @override
  String toString() => 'TFRecordDestination()';
}

/// The Container Registry location for the container image.
final class ContainerRegistryDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContainerRegistryDestination';

  /// Required. Container Registry URI of a container image.
  /// Only Google Container Registry and Artifact Registry are supported now.
  /// Accepted forms:
  ///
  /// *  Google Container Registry path. For example:
  ///    `gcr.io/projectId/imageName:tag`.
  ///
  /// *  Artifact Registry path. For example:
  ///    `us-central1-docker.pkg.dev/projectId/repoName/imageName:tag`.
  ///
  /// If a tag is not specified, "latest" will be used as the default tag.
  final String outputUri;

  ContainerRegistryDestination({required this.outputUri})
    : super(fullyQualifiedName);

  factory ContainerRegistryDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ContainerRegistryDestination(
      outputUri: switch (json['outputUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'outputUri': outputUri};

  @override
  String toString() {
    final contents = ['outputUri=$outputUri'].join(',');
    return 'ContainerRegistryDestination($contents)';
  }
}

/// The Google Drive location for the input content.
final class GoogleDriveSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GoogleDriveSource';

  /// Required. Google Drive resource IDs.
  final List<GoogleDriveSource_ResourceId> resourceIds;

  GoogleDriveSource({required this.resourceIds}) : super(fullyQualifiedName);

  factory GoogleDriveSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GoogleDriveSource(
      resourceIds: switch (json['resourceIds']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) GoogleDriveSource_ResourceId.fromJson(i),
        ],
        _ => throw const FormatException('"resourceIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'resourceIds': encodeList(resourceIds)};

  @override
  String toString() => 'GoogleDriveSource()';
}

/// The type and ID of the Google Drive resource.
final class GoogleDriveSource_ResourceId extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GoogleDriveSource.ResourceId';

  /// Required. The type of the Google Drive resource.
  final GoogleDriveSource_ResourceId_ResourceType resourceType;

  /// Required. The ID of the Google Drive resource.
  final String resourceId;

  GoogleDriveSource_ResourceId({
    required this.resourceType,
    required this.resourceId,
  }) : super(fullyQualifiedName);

  factory GoogleDriveSource_ResourceId.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GoogleDriveSource_ResourceId(
      resourceType: switch (json['resourceType']) {
        null => GoogleDriveSource_ResourceId_ResourceType.$default,
        Object $1 => GoogleDriveSource_ResourceId_ResourceType.fromJson($1),
      },
      resourceId: switch (json['resourceId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'resourceType': resourceType.toJson(),
    'resourceId': resourceId,
  };

  @override
  String toString() {
    final contents = [
      'resourceType=$resourceType',
      'resourceId=$resourceId',
    ].join(',');
    return 'ResourceId($contents)';
  }
}

/// The type of the Google Drive resource.
final class GoogleDriveSource_ResourceId_ResourceType extends ProtoEnum {
  /// Unspecified resource type.
  static const resourceTypeUnspecified =
      GoogleDriveSource_ResourceId_ResourceType('RESOURCE_TYPE_UNSPECIFIED');

  /// File resource type.
  static const resourceTypeFile = GoogleDriveSource_ResourceId_ResourceType(
    'RESOURCE_TYPE_FILE',
  );

  /// Folder resource type.
  static const resourceTypeFolder = GoogleDriveSource_ResourceId_ResourceType(
    'RESOURCE_TYPE_FOLDER',
  );

  /// The default value for [GoogleDriveSource_ResourceId_ResourceType].
  static const $default = resourceTypeUnspecified;

  const GoogleDriveSource_ResourceId_ResourceType(super.value);

  factory GoogleDriveSource_ResourceId_ResourceType.fromJson(Object? json) =>
      GoogleDriveSource_ResourceId_ResourceType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ResourceType.$value';
}

/// The input content is encapsulated and uploaded in the request.
final class DirectUploadSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectUploadSource';

  DirectUploadSource() : super(fullyQualifiedName);

  factory DirectUploadSource.fromJson(Object? j) => DirectUploadSource();

  @override
  Object toJson() => {};

  @override
  String toString() => 'DirectUploadSource()';
}

/// The Slack source for the ImportRagFilesRequest.
final class SlackSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SlackSource';

  /// Required. The Slack channels.
  final List<SlackSource_SlackChannels> channels;

  SlackSource({required this.channels}) : super(fullyQualifiedName);

  factory SlackSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SlackSource(
      channels: switch (json['channels']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) SlackSource_SlackChannels.fromJson(i),
        ],
        _ => throw const FormatException('"channels" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'channels': encodeList(channels)};

  @override
  String toString() => 'SlackSource()';
}

/// SlackChannels contains the Slack channels and corresponding access token.
final class SlackSource_SlackChannels extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SlackSource.SlackChannels';

  /// Required. The Slack channel IDs.
  final List<SlackSource_SlackChannels_SlackChannel> channels;

  /// Required. The SecretManager secret version resource name (e.g.
  /// projects/{project}/secrets/{secret}/versions/{version}) storing the
  /// Slack channel access token that has access to the slack channel IDs.
  /// See: https://api.slack.com/tutorials/tracks/getting-a-token.
  final ApiAuth_ApiKeyConfig? apiKeyConfig;

  SlackSource_SlackChannels({
    required this.channels,
    required this.apiKeyConfig,
  }) : super(fullyQualifiedName);

  factory SlackSource_SlackChannels.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SlackSource_SlackChannels(
      channels: switch (json['channels']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            SlackSource_SlackChannels_SlackChannel.fromJson(i),
        ],
        _ => throw const FormatException('"channels" is not a list'),
      },
      apiKeyConfig: switch (json['apiKeyConfig']) {
        null => null,
        Object $1 => ApiAuth_ApiKeyConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'channels': encodeList(channels),
    if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!.toJson(),
  };

  @override
  String toString() => 'SlackChannels()';
}

/// SlackChannel contains the Slack channel ID and the time range to import.
final class SlackSource_SlackChannels_SlackChannel extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SlackSource.SlackChannels.SlackChannel';

  /// Required. The Slack channel ID.
  final String channelId;

  /// Optional. The starting timestamp for messages to import.
  final protobuf.Timestamp? startTime;

  /// Optional. The ending timestamp for messages to import.
  final protobuf.Timestamp? endTime;

  SlackSource_SlackChannels_SlackChannel({
    required this.channelId,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory SlackSource_SlackChannels_SlackChannel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SlackSource_SlackChannels_SlackChannel(
      channelId: switch (json['channelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'channelId': channelId,
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['channelId=$channelId'].join(',');
    return 'SlackChannel($contents)';
  }
}

/// The Jira source for the ImportRagFilesRequest.
final class JiraSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.JiraSource';

  /// Required. The Jira queries.
  final List<JiraSource_JiraQueries> jiraQueries;

  JiraSource({required this.jiraQueries}) : super(fullyQualifiedName);

  factory JiraSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return JiraSource(
      jiraQueries: switch (json['jiraQueries']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) JiraSource_JiraQueries.fromJson(i),
        ],
        _ => throw const FormatException('"jiraQueries" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'jiraQueries': encodeList(jiraQueries)};

  @override
  String toString() => 'JiraSource()';
}

/// JiraQueries contains the Jira queries and corresponding authentication.
final class JiraSource_JiraQueries extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.JiraSource.JiraQueries';

  /// A list of Jira projects to import in their entirety.
  final List<String> projects;

  /// A list of custom Jira queries to import. For information about JQL (Jira
  /// Query Language), see
  /// https://support.atlassian.com/jira-service-management-cloud/docs/use-advanced-search-with-jira-query-language-jql/
  final List<String> customQueries;

  /// Required. The Jira email address.
  final String email;

  /// Required. The Jira server URI.
  final String serverUri;

  /// Required. The SecretManager secret version resource name (e.g.
  /// projects/{project}/secrets/{secret}/versions/{version}) storing the
  /// Jira API key. See [Manage API tokens for your Atlassian
  /// account](https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/).
  final ApiAuth_ApiKeyConfig? apiKeyConfig;

  JiraSource_JiraQueries({
    this.projects = const [],
    this.customQueries = const [],
    required this.email,
    required this.serverUri,
    required this.apiKeyConfig,
  }) : super(fullyQualifiedName);

  factory JiraSource_JiraQueries.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return JiraSource_JiraQueries(
      projects: switch (json['projects']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"projects" is not a list'),
      },
      customQueries: switch (json['customQueries']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"customQueries" is not a list'),
      },
      email: switch (json['email']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serverUri: switch (json['serverUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      apiKeyConfig: switch (json['apiKeyConfig']) {
        null => null,
        Object $1 => ApiAuth_ApiKeyConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (projects.isNotDefault) 'projects': projects,
    if (customQueries.isNotDefault) 'customQueries': customQueries,
    'email': email,
    'serverUri': serverUri,
    if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['email=$email', 'serverUri=$serverUri'].join(',');
    return 'JiraQueries($contents)';
  }
}

/// The SharePointSources to pass to ImportRagFiles.
final class SharePointSources extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SharePointSources';

  /// The SharePoint sources.
  final List<SharePointSources_SharePointSource> sharePointSources;

  SharePointSources({this.sharePointSources = const []})
    : super(fullyQualifiedName);

  factory SharePointSources.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SharePointSources(
      sharePointSources: switch (json['sharePointSources']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) SharePointSources_SharePointSource.fromJson(i),
        ],
        _ => throw const FormatException('"sharePointSources" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (sharePointSources.isNotDefault)
      'sharePointSources': encodeList(sharePointSources),
  };

  @override
  String toString() => 'SharePointSources()';
}

/// An individual SharePointSource.
final class SharePointSources_SharePointSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SharePointSources.SharePointSource';

  /// The path of the SharePoint folder to download from.
  final String? sharepointFolderPath;

  /// The ID of the SharePoint folder to download from.
  final String? sharepointFolderId;

  /// The name of the drive to download from.
  final String? driveName;

  /// The ID of the drive to download from.
  final String? driveId;

  /// The Application ID for the app registered in Microsoft Azure Portal.
  /// The application must also be configured with MS Graph permissions
  /// "Files.ReadAll", "Sites.ReadAll" and BrowserSiteLists.Read.All.
  final String clientId;

  /// The application secret for the app registered in Azure.
  final ApiAuth_ApiKeyConfig? clientSecret;

  /// Unique identifier of the Azure Active Directory Instance.
  final String tenantId;

  /// The name of the SharePoint site to download from. This can be the site
  /// name or the site id.
  final String sharepointSiteName;

  /// Output only. The SharePoint file id. Output only.
  final String fileId;

  SharePointSources_SharePointSource({
    this.sharepointFolderPath,
    this.sharepointFolderId,
    this.driveName,
    this.driveId,
    this.clientId = '',
    this.clientSecret,
    this.tenantId = '',
    this.sharepointSiteName = '',
    this.fileId = '',
  }) : super(fullyQualifiedName);

  factory SharePointSources_SharePointSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SharePointSources_SharePointSource(
      sharepointFolderPath: switch (json['sharepointFolderPath']) {
        null => null,
        Object $1 => decodeString($1),
      },
      sharepointFolderId: switch (json['sharepointFolderId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      driveName: switch (json['driveName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      driveId: switch (json['driveId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      clientId: switch (json['clientId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      clientSecret: switch (json['clientSecret']) {
        null => null,
        Object $1 => ApiAuth_ApiKeyConfig.fromJson($1),
      },
      tenantId: switch (json['tenantId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sharepointSiteName: switch (json['sharepointSiteName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      fileId: switch (json['fileId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sharepointFolderPath != null)
      'sharepointFolderPath': sharepointFolderPath,
    if (sharepointFolderId != null) 'sharepointFolderId': sharepointFolderId,
    if (driveName != null) 'driveName': driveName,
    if (driveId != null) 'driveId': driveId,
    if (clientId.isNotDefault) 'clientId': clientId,
    if (clientSecret != null) 'clientSecret': clientSecret!.toJson(),
    if (tenantId.isNotDefault) 'tenantId': tenantId,
    if (sharepointSiteName.isNotDefault)
      'sharepointSiteName': sharepointSiteName,
    if (fileId.isNotDefault) 'fileId': fileId,
  };

  @override
  String toString() {
    final contents = [
      if (sharepointFolderPath != null)
        'sharepointFolderPath=$sharepointFolderPath',
      if (sharepointFolderId != null) 'sharepointFolderId=$sharepointFolderId',
      if (driveName != null) 'driveName=$driveName',
      if (driveId != null) 'driveId=$driveId',
      'clientId=$clientId',
      'tenantId=$tenantId',
      'sharepointSiteName=$sharepointSiteName',
      'fileId=$fileId',
    ].join(',');
    return 'SharePointSource($contents)';
  }
}

/// Request message for
/// `JobService.CreateCustomJob`.
final class CreateCustomJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateCustomJobRequest';

  /// Required. The resource name of the Location to create the CustomJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The CustomJob to create.
  final CustomJob? customJob;

  CreateCustomJobRequest({required this.parent, required this.customJob})
    : super(fullyQualifiedName);

  factory CreateCustomJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateCustomJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      customJob: switch (json['customJob']) {
        null => null,
        Object $1 => CustomJob.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (customJob != null) 'customJob': customJob!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateCustomJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetCustomJob`.
final class GetCustomJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetCustomJobRequest';

  /// Required. The name of the CustomJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  final String name;

  GetCustomJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetCustomJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetCustomJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetCustomJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListCustomJobs`.
final class ListCustomJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListCustomJobsRequest';

  /// Required. The resource name of the Location to list the CustomJobs from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListCustomJobsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListCustomJobs`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListCustomJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListCustomJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListCustomJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListCustomJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListCustomJobs`
final class ListCustomJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListCustomJobsResponse';

  /// List of CustomJobs in the requested page.
  final List<CustomJob> customJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListCustomJobsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListCustomJobsResponse({this.customJobs = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListCustomJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListCustomJobsResponse(
      customJobs: switch (json['customJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) CustomJob.fromJson(i)],
        _ => throw const FormatException('"customJobs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (customJobs.isNotDefault) 'customJobs': encodeList(customJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListCustomJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteCustomJob`.
final class DeleteCustomJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteCustomJobRequest';

  /// Required. The name of the CustomJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  final String name;

  DeleteCustomJobRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteCustomJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteCustomJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteCustomJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelCustomJob`.
final class CancelCustomJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelCustomJobRequest';

  /// Required. The name of the CustomJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  final String name;

  CancelCustomJobRequest({required this.name}) : super(fullyQualifiedName);

  factory CancelCustomJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelCustomJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelCustomJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CreateDataLabelingJob`.
final class CreateDataLabelingJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDataLabelingJobRequest';

  /// Required. The parent of the DataLabelingJob.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The DataLabelingJob to create.
  final DataLabelingJob? dataLabelingJob;

  CreateDataLabelingJobRequest({
    required this.parent,
    required this.dataLabelingJob,
  }) : super(fullyQualifiedName);

  factory CreateDataLabelingJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateDataLabelingJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataLabelingJob: switch (json['dataLabelingJob']) {
        null => null,
        Object $1 => DataLabelingJob.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (dataLabelingJob != null) 'dataLabelingJob': dataLabelingJob!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateDataLabelingJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetDataLabelingJob`.
final class GetDataLabelingJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetDataLabelingJobRequest';

  /// Required. The name of the DataLabelingJob.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  final String name;

  GetDataLabelingJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetDataLabelingJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetDataLabelingJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetDataLabelingJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListDataLabelingJobs`.
final class ListDataLabelingJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDataLabelingJobsRequest';

  /// Required. The parent of the DataLabelingJob.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// Mask specifying which fields to read. FieldMask represents a set of
  /// symbolic field paths. For example, the mask can be `paths: "name"`. The
  /// "name" here is a field in DataLabelingJob.
  /// If this field is not set, all fields of the DataLabelingJob are returned.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order by
  /// default.
  /// Use `desc` after a field name for descending.
  final String orderBy;

  ListDataLabelingJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListDataLabelingJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDataLabelingJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListDataLabelingJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListDataLabelingJobs`.
final class ListDataLabelingJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDataLabelingJobsResponse';

  /// A list of DataLabelingJobs that matches the specified filter in the
  /// request.
  final List<DataLabelingJob> dataLabelingJobs;

  /// The standard List next-page token.
  final String nextPageToken;

  ListDataLabelingJobsResponse({
    this.dataLabelingJobs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListDataLabelingJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListDataLabelingJobsResponse(
      dataLabelingJobs: switch (json['dataLabelingJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DataLabelingJob.fromJson(i)],
        _ => throw const FormatException('"dataLabelingJobs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataLabelingJobs.isNotDefault)
      'dataLabelingJobs': encodeList(dataLabelingJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListDataLabelingJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteDataLabelingJob`.
final class DeleteDataLabelingJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteDataLabelingJobRequest';

  /// Required. The name of the DataLabelingJob to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  final String name;

  DeleteDataLabelingJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteDataLabelingJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteDataLabelingJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteDataLabelingJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelDataLabelingJob`.
final class CancelDataLabelingJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelDataLabelingJobRequest';

  /// Required. The name of the DataLabelingJob.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  final String name;

  CancelDataLabelingJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory CancelDataLabelingJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelDataLabelingJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelDataLabelingJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CreateHyperparameterTuningJob`.
final class CreateHyperparameterTuningJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateHyperparameterTuningJobRequest';

  /// Required. The resource name of the Location to create the
  /// HyperparameterTuningJob in. Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The HyperparameterTuningJob to create.
  final HyperparameterTuningJob? hyperparameterTuningJob;

  CreateHyperparameterTuningJobRequest({
    required this.parent,
    required this.hyperparameterTuningJob,
  }) : super(fullyQualifiedName);

  factory CreateHyperparameterTuningJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateHyperparameterTuningJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      hyperparameterTuningJob: switch (json['hyperparameterTuningJob']) {
        null => null,
        Object $1 => HyperparameterTuningJob.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (hyperparameterTuningJob != null)
      'hyperparameterTuningJob': hyperparameterTuningJob!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateHyperparameterTuningJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetHyperparameterTuningJob`.
final class GetHyperparameterTuningJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetHyperparameterTuningJobRequest';

  /// Required. The name of the HyperparameterTuningJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  final String name;

  GetHyperparameterTuningJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetHyperparameterTuningJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetHyperparameterTuningJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetHyperparameterTuningJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListHyperparameterTuningJobs`.
final class ListHyperparameterTuningJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListHyperparameterTuningJobsRequest';

  /// Required. The resource name of the Location to list the
  /// HyperparameterTuningJobs from. Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListHyperparameterTuningJobsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListHyperparameterTuningJobs`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListHyperparameterTuningJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListHyperparameterTuningJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListHyperparameterTuningJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListHyperparameterTuningJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListHyperparameterTuningJobs`
final class ListHyperparameterTuningJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListHyperparameterTuningJobsResponse';

  /// List of HyperparameterTuningJobs in the requested page.
  /// `HyperparameterTuningJob.trials`
  /// of the jobs will be not be returned.
  final List<HyperparameterTuningJob> hyperparameterTuningJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListHyperparameterTuningJobsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListHyperparameterTuningJobsResponse({
    this.hyperparameterTuningJobs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListHyperparameterTuningJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListHyperparameterTuningJobsResponse(
      hyperparameterTuningJobs: switch (json['hyperparameterTuningJobs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) HyperparameterTuningJob.fromJson(i),
        ],
        _ => throw const FormatException(
          '"hyperparameterTuningJobs" is not a list',
        ),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (hyperparameterTuningJobs.isNotDefault)
      'hyperparameterTuningJobs': encodeList(hyperparameterTuningJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListHyperparameterTuningJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteHyperparameterTuningJob`.
final class DeleteHyperparameterTuningJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteHyperparameterTuningJobRequest';

  /// Required. The name of the HyperparameterTuningJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  final String name;

  DeleteHyperparameterTuningJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteHyperparameterTuningJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteHyperparameterTuningJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteHyperparameterTuningJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelHyperparameterTuningJob`.
final class CancelHyperparameterTuningJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelHyperparameterTuningJobRequest';

  /// Required. The name of the HyperparameterTuningJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  final String name;

  CancelHyperparameterTuningJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory CancelHyperparameterTuningJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelHyperparameterTuningJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelHyperparameterTuningJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CreateNasJob`.
final class CreateNasJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNasJobRequest';

  /// Required. The resource name of the Location to create the NasJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The NasJob to create.
  final NasJob? nasJob;

  CreateNasJobRequest({required this.parent, required this.nasJob})
    : super(fullyQualifiedName);

  factory CreateNasJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateNasJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      nasJob: switch (json['nasJob']) {
        null => null,
        Object $1 => NasJob.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (nasJob != null) 'nasJob': nasJob!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateNasJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetNasJob`.
final class GetNasJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNasJobRequest';

  /// Required. The name of the NasJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  final String name;

  GetNasJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetNasJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetNasJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetNasJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListNasJobs`.
final class ListNasJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNasJobsRequest';

  /// Required. The resource name of the Location to list the NasJobs
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListNasJobsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListNasJobs`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListNasJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListNasJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNasJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListNasJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListNasJobs`
final class ListNasJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNasJobsResponse';

  /// List of NasJobs in the requested page.
  /// `NasJob.nas_job_output`
  /// of the jobs will not be returned.
  final List<NasJob> nasJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListNasJobsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListNasJobsResponse({this.nasJobs = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListNasJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNasJobsResponse(
      nasJobs: switch (json['nasJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) NasJob.fromJson(i)],
        _ => throw const FormatException('"nasJobs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (nasJobs.isNotDefault) 'nasJobs': encodeList(nasJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListNasJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteNasJob`.
final class DeleteNasJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteNasJobRequest';

  /// Required. The name of the NasJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  final String name;

  DeleteNasJobRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteNasJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteNasJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteNasJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelNasJob`.
final class CancelNasJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelNasJobRequest';

  /// Required. The name of the NasJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  final String name;

  CancelNasJobRequest({required this.name}) : super(fullyQualifiedName);

  factory CancelNasJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelNasJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelNasJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetNasTrialDetail`.
final class GetNasTrialDetailRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNasTrialDetailRequest';

  /// Required. The name of the NasTrialDetail resource.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}/nasTrialDetails/{nas_trial_detail}`
  final String name;

  GetNasTrialDetailRequest({required this.name}) : super(fullyQualifiedName);

  factory GetNasTrialDetailRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetNasTrialDetailRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetNasTrialDetailRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListNasTrialDetails`.
final class ListNasTrialDetailsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNasTrialDetailsRequest';

  /// Required. The name of the NasJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  final String parent;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListNasTrialDetailsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListNasTrialDetails`
  /// call.
  final String pageToken;

  ListNasTrialDetailsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListNasTrialDetailsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNasTrialDetailsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListNasTrialDetailsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListNasTrialDetails`
final class ListNasTrialDetailsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNasTrialDetailsResponse';

  /// List of top NasTrials in the requested page.
  final List<NasTrialDetail> nasTrialDetails;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListNasTrialDetailsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListNasTrialDetailsResponse({
    this.nasTrialDetails = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListNasTrialDetailsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNasTrialDetailsResponse(
      nasTrialDetails: switch (json['nasTrialDetails']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) NasTrialDetail.fromJson(i)],
        _ => throw const FormatException('"nasTrialDetails" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (nasTrialDetails.isNotDefault)
      'nasTrialDetails': encodeList(nasTrialDetails),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListNasTrialDetailsResponse($contents)';
  }
}

/// Request message for
/// `JobService.CreateBatchPredictionJob`.
final class CreateBatchPredictionJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateBatchPredictionJobRequest';

  /// Required. The resource name of the Location to create the
  /// BatchPredictionJob in. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The BatchPredictionJob to create.
  final BatchPredictionJob? batchPredictionJob;

  CreateBatchPredictionJobRequest({
    required this.parent,
    required this.batchPredictionJob,
  }) : super(fullyQualifiedName);

  factory CreateBatchPredictionJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateBatchPredictionJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      batchPredictionJob: switch (json['batchPredictionJob']) {
        null => null,
        Object $1 => BatchPredictionJob.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (batchPredictionJob != null)
      'batchPredictionJob': batchPredictionJob!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateBatchPredictionJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetBatchPredictionJob`.
final class GetBatchPredictionJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetBatchPredictionJobRequest';

  /// Required. The name of the BatchPredictionJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  final String name;

  GetBatchPredictionJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetBatchPredictionJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetBatchPredictionJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetBatchPredictionJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListBatchPredictionJobs`.
final class ListBatchPredictionJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListBatchPredictionJobsRequest';

  /// Required. The resource name of the Location to list the BatchPredictionJobs
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `model_display_name` supports `=`, `!=` comparisons.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListBatchPredictionJobsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListBatchPredictionJobs`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListBatchPredictionJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListBatchPredictionJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListBatchPredictionJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListBatchPredictionJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListBatchPredictionJobs`
final class ListBatchPredictionJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListBatchPredictionJobsResponse';

  /// List of BatchPredictionJobs in the requested page.
  final List<BatchPredictionJob> batchPredictionJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListBatchPredictionJobsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListBatchPredictionJobsResponse({
    this.batchPredictionJobs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListBatchPredictionJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListBatchPredictionJobsResponse(
      batchPredictionJobs: switch (json['batchPredictionJobs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) BatchPredictionJob.fromJson(i),
        ],
        _ => throw const FormatException('"batchPredictionJobs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (batchPredictionJobs.isNotDefault)
      'batchPredictionJobs': encodeList(batchPredictionJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListBatchPredictionJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteBatchPredictionJob`.
final class DeleteBatchPredictionJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteBatchPredictionJobRequest';

  /// Required. The name of the BatchPredictionJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  final String name;

  DeleteBatchPredictionJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteBatchPredictionJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteBatchPredictionJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteBatchPredictionJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelBatchPredictionJob`.
final class CancelBatchPredictionJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelBatchPredictionJobRequest';

  /// Required. The name of the BatchPredictionJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  final String name;

  CancelBatchPredictionJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory CancelBatchPredictionJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelBatchPredictionJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelBatchPredictionJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CreateModelDeploymentMonitoringJob`.
final class CreateModelDeploymentMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateModelDeploymentMonitoringJobRequest';

  /// Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The ModelDeploymentMonitoringJob to create
  final ModelDeploymentMonitoringJob? modelDeploymentMonitoringJob;

  CreateModelDeploymentMonitoringJobRequest({
    required this.parent,
    required this.modelDeploymentMonitoringJob,
  }) : super(fullyQualifiedName);

  factory CreateModelDeploymentMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateModelDeploymentMonitoringJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelDeploymentMonitoringJob:
          switch (json['modelDeploymentMonitoringJob']) {
            null => null,
            Object $1 => ModelDeploymentMonitoringJob.fromJson($1),
          },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (modelDeploymentMonitoringJob != null)
      'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.SearchModelDeploymentMonitoringStatsAnomalies`.
final class SearchModelDeploymentMonitoringStatsAnomaliesRequest
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelDeploymentMonitoringStatsAnomaliesRequest';

  /// Required. ModelDeploymentMonitoring Job resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String modelDeploymentMonitoringJob;

  /// Required. The DeployedModel ID of the
  /// [ModelDeploymentMonitoringObjectiveConfig.deployed_model_id].
  final String deployedModelId;

  /// The feature display name. If specified, only return the stats belonging to
  /// this feature. Format:
  /// `ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name`,
  /// example: "user_destination".
  final String featureDisplayName;

  /// Required. Objectives of the stats to retrieve.
  final List<
    SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective
  >
  objectives;

  /// The standard list page size.
  final int pageSize;

  /// A page token received from a previous
  /// `JobService.SearchModelDeploymentMonitoringStatsAnomalies`
  /// call.
  final String pageToken;

  /// The earliest timestamp of stats being generated.
  /// If not set, indicates fetching stats till the earliest possible one.
  final protobuf.Timestamp? startTime;

  /// The latest timestamp of stats being generated.
  /// If not set, indicates feching stats till the latest possible one.
  final protobuf.Timestamp? endTime;

  SearchModelDeploymentMonitoringStatsAnomaliesRequest({
    required this.modelDeploymentMonitoringJob,
    required this.deployedModelId,
    this.featureDisplayName = '',
    required this.objectives,
    this.pageSize = 0,
    this.pageToken = '',
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory SearchModelDeploymentMonitoringStatsAnomaliesRequest.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return SearchModelDeploymentMonitoringStatsAnomaliesRequest(
      modelDeploymentMonitoringJob:
          switch (json['modelDeploymentMonitoringJob']) {
            null => '',
            Object $1 => decodeString($1),
          },
      deployedModelId: switch (json['deployedModelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      featureDisplayName: switch (json['featureDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      objectives: switch (json['objectives']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException('"objectives" is not a list'),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob,
    'deployedModelId': deployedModelId,
    if (featureDisplayName.isNotDefault)
      'featureDisplayName': featureDisplayName,
    'objectives': encodeList(objectives),
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'modelDeploymentMonitoringJob=$modelDeploymentMonitoringJob',
      'deployedModelId=$deployedModelId',
      'featureDisplayName=$featureDisplayName',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'SearchModelDeploymentMonitoringStatsAnomaliesRequest($contents)';
  }
}

/// Stats requested for specific objective.
final class SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.StatsAnomaliesObjective';

  final ModelDeploymentMonitoringObjectiveType type;

  /// If set, all attribution scores between
  /// `SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time`
  /// and
  /// `SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time`
  /// are fetched, and page token doesn't take effect in this case. Only used
  /// to retrieve attribution score for the top Features which has the highest
  /// attribution score in the latest monitoring run.
  final int topFeatureCount;

  SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective({
    this.type = ModelDeploymentMonitoringObjectiveType.$default,
    this.topFeatureCount = 0,
  }) : super(fullyQualifiedName);

  factory SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective(
      type: switch (json['type']) {
        null => ModelDeploymentMonitoringObjectiveType.$default,
        Object $1 => ModelDeploymentMonitoringObjectiveType.fromJson($1),
      },
      topFeatureCount: switch (json['topFeatureCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type.toJson(),
    if (topFeatureCount.isNotDefault) 'topFeatureCount': topFeatureCount,
  };

  @override
  String toString() {
    final contents = [
      'type=$type',
      'topFeatureCount=$topFeatureCount',
    ].join(',');
    return 'StatsAnomaliesObjective($contents)';
  }
}

/// Response message for
/// `JobService.SearchModelDeploymentMonitoringStatsAnomalies`.
final class SearchModelDeploymentMonitoringStatsAnomaliesResponse
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelDeploymentMonitoringStatsAnomaliesResponse';

  /// Stats retrieved for requested objectives.
  /// There are at most 1000
  /// `ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats`
  /// in the response.
  final List<ModelMonitoringStatsAnomalies> monitoringStats;

  /// The page token that can be used by the next
  /// `JobService.SearchModelDeploymentMonitoringStatsAnomalies`
  /// call.
  final String nextPageToken;

  SearchModelDeploymentMonitoringStatsAnomaliesResponse({
    this.monitoringStats = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchModelDeploymentMonitoringStatsAnomaliesResponse.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return SearchModelDeploymentMonitoringStatsAnomaliesResponse(
      monitoringStats: switch (json['monitoringStats']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringStatsAnomalies.fromJson(i),
        ],
        _ => throw const FormatException('"monitoringStats" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (monitoringStats.isNotDefault)
      'monitoringStats': encodeList(monitoringStats),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'SearchModelDeploymentMonitoringStatsAnomaliesResponse($contents)';
  }
}

/// Request message for
/// `JobService.GetModelDeploymentMonitoringJob`.
final class GetModelDeploymentMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelDeploymentMonitoringJobRequest';

  /// Required. The resource name of the ModelDeploymentMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String name;

  GetModelDeploymentMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetModelDeploymentMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetModelDeploymentMonitoringJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListModelDeploymentMonitoringJobs`.
final class ListModelDeploymentMonitoringJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelDeploymentMonitoringJobsRequest';

  /// Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// Mask specifying which fields to read
  final protobuf.FieldMask? readMask;

  ListModelDeploymentMonitoringJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelDeploymentMonitoringJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelDeploymentMonitoringJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListModelDeploymentMonitoringJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListModelDeploymentMonitoringJobs`.
final class ListModelDeploymentMonitoringJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelDeploymentMonitoringJobsResponse';

  /// A list of ModelDeploymentMonitoringJobs that matches the specified filter
  /// in the request.
  final List<ModelDeploymentMonitoringJob> modelDeploymentMonitoringJobs;

  /// The standard List next-page token.
  final String nextPageToken;

  ListModelDeploymentMonitoringJobsResponse({
    this.modelDeploymentMonitoringJobs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListModelDeploymentMonitoringJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelDeploymentMonitoringJobsResponse(
      modelDeploymentMonitoringJobs:
          switch (json['modelDeploymentMonitoringJobs']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) ModelDeploymentMonitoringJob.fromJson(i),
            ],
            _ => throw const FormatException(
              '"modelDeploymentMonitoringJobs" is not a list',
            ),
          },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelDeploymentMonitoringJobs.isNotDefault)
      'modelDeploymentMonitoringJobs': encodeList(
        modelDeploymentMonitoringJobs,
      ),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListModelDeploymentMonitoringJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.UpdateModelDeploymentMonitoringJob`.
final class UpdateModelDeploymentMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelDeploymentMonitoringJobRequest';

  /// Required. The model monitoring configuration which replaces the resource on
  /// the server.
  final ModelDeploymentMonitoringJob? modelDeploymentMonitoringJob;

  /// Required. The update mask is used to specify the fields to be overwritten
  /// in the ModelDeploymentMonitoringJob resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field will be overwritten if it is in the mask. If the user does
  /// not provide a mask then only the non-empty fields present in the request
  /// will be overwritten. Set the update_mask to `*` to override all fields. For
  /// the objective config, the user can either provide the update mask for
  /// model_deployment_monitoring_objective_configs or any combination of its
  /// nested fields, such as:
  /// model_deployment_monitoring_objective_configs.objective_config.training_dataset.
  ///
  /// Updatable fields:
  ///
  ///   * `display_name`
  ///   * `model_deployment_monitoring_schedule_config`
  ///   * `model_monitoring_alert_config`
  ///   * `logging_sampling_strategy`
  ///   * `labels`
  ///   * `log_ttl`
  ///   * `enable_monitoring_pipeline_logs`
  /// .  and
  ///   * `model_deployment_monitoring_objective_configs`
  /// .  or
  ///   * `model_deployment_monitoring_objective_configs.objective_config.training_dataset`
  ///   * `model_deployment_monitoring_objective_configs.objective_config.training_prediction_skew_detection_config`
  ///   * `model_deployment_monitoring_objective_configs.objective_config.prediction_drift_detection_config`
  final protobuf.FieldMask? updateMask;

  UpdateModelDeploymentMonitoringJobRequest({
    required this.modelDeploymentMonitoringJob,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateModelDeploymentMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateModelDeploymentMonitoringJobRequest(
      modelDeploymentMonitoringJob:
          switch (json['modelDeploymentMonitoringJob']) {
            null => null,
            Object $1 => ModelDeploymentMonitoringJob.fromJson($1),
          },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelDeploymentMonitoringJob != null)
      'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateModelDeploymentMonitoringJobRequest()';
}

/// Request message for
/// `JobService.DeleteModelDeploymentMonitoringJob`.
final class DeleteModelDeploymentMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelDeploymentMonitoringJobRequest';

  /// Required. The resource name of the model monitoring job to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String name;

  DeleteModelDeploymentMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteModelDeploymentMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteModelDeploymentMonitoringJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.PauseModelDeploymentMonitoringJob`.
final class PauseModelDeploymentMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PauseModelDeploymentMonitoringJobRequest';

  /// Required. The resource name of the ModelDeploymentMonitoringJob to pause.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String name;

  PauseModelDeploymentMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory PauseModelDeploymentMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PauseModelDeploymentMonitoringJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'PauseModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ResumeModelDeploymentMonitoringJob`.
final class ResumeModelDeploymentMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResumeModelDeploymentMonitoringJobRequest';

  /// Required. The resource name of the ModelDeploymentMonitoringJob to resume.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String name;

  ResumeModelDeploymentMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory ResumeModelDeploymentMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResumeModelDeploymentMonitoringJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ResumeModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Runtime operation information for
/// `JobService.UpdateModelDeploymentMonitoringJob`.
final class UpdateModelDeploymentMonitoringJobOperationMetadata
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelDeploymentMonitoringJobOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateModelDeploymentMonitoringJobOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateModelDeploymentMonitoringJobOperationMetadata.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return UpdateModelDeploymentMonitoringJobOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateModelDeploymentMonitoringJobOperationMetadata()';
}

/// A subgraph of the overall lineage graph. Event edges connect Artifact and
/// Execution nodes.
final class LineageSubgraph extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LineageSubgraph';

  /// The Artifact nodes in the subgraph.
  final List<Artifact> artifacts;

  /// The Execution nodes in the subgraph.
  final List<Execution> executions;

  /// The Event edges between Artifacts and Executions in the subgraph.
  final List<Event> events;

  LineageSubgraph({
    this.artifacts = const [],
    this.executions = const [],
    this.events = const [],
  }) : super(fullyQualifiedName);

  factory LineageSubgraph.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LineageSubgraph(
      artifacts: switch (json['artifacts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Artifact.fromJson(i)],
        _ => throw const FormatException('"artifacts" is not a list'),
      },
      executions: switch (json['executions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Execution.fromJson(i)],
        _ => throw const FormatException('"executions" is not a list'),
      },
      events: switch (json['events']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Event.fromJson(i)],
        _ => throw const FormatException('"events" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (artifacts.isNotDefault) 'artifacts': encodeList(artifacts),
    if (executions.isNotDefault) 'executions': encodeList(executions),
    if (events.isNotDefault) 'events': encodeList(events),
  };

  @override
  String toString() => 'LineageSubgraph()';
}

/// Request message for ComputeTokens RPC call.
final class ComputeTokensRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ComputeTokensRequest';

  /// Required. The name of the Endpoint requested to get lists of tokens and
  /// token ids.
  final String endpoint;

  /// Optional. The instances that are the input to token computing API call.
  /// Schema is identical to the prediction schema of the text model, even for
  /// the non-text models, like chat models, or Codey models.
  final List<protobuf.Value> instances;

  /// Optional. The name of the publisher model requested to serve the
  /// prediction. Format:
  /// projects/{project}/locations/{location}/publishers/*/models/*
  final String model;

  /// Optional. Input content.
  final List<Content> contents;

  ComputeTokensRequest({
    required this.endpoint,
    this.instances = const [],
    this.model = '',
    this.contents = const [],
  }) : super(fullyQualifiedName);

  factory ComputeTokensRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ComputeTokensRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"instances" is not a list'),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (instances.isNotDefault) 'instances': encodeList(instances),
    if (model.isNotDefault) 'model': model,
    if (contents.isNotDefault) 'contents': encodeList(contents),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint', 'model=$model'].join(',');
    return 'ComputeTokensRequest($contents)';
  }
}

/// Tokens info with a list of tokens and the corresponding list of token ids.
final class TokensInfo extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TokensInfo';

  /// A list of tokens from the input.
  final List<Uint8List> tokens;

  /// A list of token ids from the input.
  final List<int> tokenIds;

  /// Optional. Optional fields for the role from the corresponding Content.
  final String role;

  TokensInfo({this.tokens = const [], this.tokenIds = const [], this.role = ''})
    : super(fullyQualifiedName);

  factory TokensInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TokensInfo(
      tokens: switch (json['tokens']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeBytes(i)],
        _ => throw const FormatException('"tokens" is not a list'),
      },
      tokenIds: switch (json['tokenIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException('"tokenIds" is not a list'),
      },
      role: switch (json['role']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tokens.isNotDefault) 'tokens': encodeListBytes(tokens),
    if (tokenIds.isNotDefault) 'tokenIds': tokenIds,
    if (role.isNotDefault) 'role': role,
  };

  @override
  String toString() {
    final contents = ['role=$role'].join(',');
    return 'TokensInfo($contents)';
  }
}

/// Response message for ComputeTokens RPC call.
final class ComputeTokensResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ComputeTokensResponse';

  /// Lists of tokens info from the input. A ComputeTokensRequest could have
  /// multiple instances with a prompt in each instance. We also need to return
  /// lists of tokens info for the request with multiple instances.
  final List<TokensInfo> tokensInfo;

  ComputeTokensResponse({this.tokensInfo = const []})
    : super(fullyQualifiedName);

  factory ComputeTokensResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ComputeTokensResponse(
      tokensInfo: switch (json['tokensInfo']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TokensInfo.fromJson(i)],
        _ => throw const FormatException('"tokensInfo" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (tokensInfo.isNotDefault) 'tokensInfo': encodeList(tokensInfo),
  };

  @override
  String toString() => 'ComputeTokensResponse()';
}

/// Specification of a single machine.
final class MachineSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MachineSpec';

  /// Immutable. The type of the machine.
  ///
  /// See the [list of machine types supported for
  /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
  ///
  /// See the [list of machine types supported for custom
  /// training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
  ///
  /// For `DeployedModel` this
  /// field is optional, and the default value is `n1-standard-2`. For
  /// `BatchPredictionJob` or
  /// as part of `WorkerPoolSpec`
  /// this field is required.
  final String machineType;

  /// Immutable. The type of accelerator(s) that may be attached to the machine
  /// as per
  /// `accelerator_count`.
  final AcceleratorType acceleratorType;

  /// The number of accelerators to attach to the machine.
  final int acceleratorCount;

  /// Optional. Immutable. The Nvidia GPU partition size.
  ///
  /// When specified, the requested accelerators will be partitioned into
  /// smaller GPU partitions. For example, if the request is for 8 units of
  /// NVIDIA A100 GPUs, and gpu_partition_size="1g.10gb", the service will
  /// create 8 * 7 = 56 partitioned MIG instances.
  ///
  /// The partition size must be a value supported by the requested accelerator.
  /// Refer to
  /// [Nvidia GPU
  /// Partitioning](https://cloud.google.com/kubernetes-engine/docs/how-to/gpus-multi#multi-instance_gpu_partitions)
  /// for the available partition sizes.
  ///
  /// If set, the accelerator_count should be set to 1.
  final String gpuPartitionSize;

  /// Immutable. The topology of the TPUs. Corresponds to the TPU topologies
  /// available from GKE. (Example: tpu_topology: "2x2x1").
  final String tpuTopology;

  /// Optional. Immutable. The number of nodes per replica for multihost GPU
  /// deployments.
  final int multihostGpuNodeCount;

  /// Optional. Immutable. Configuration controlling how this resource pool
  /// consumes reservation.
  final ReservationAffinity? reservationAffinity;

  MachineSpec({
    this.machineType = '',
    this.acceleratorType = AcceleratorType.$default,
    this.acceleratorCount = 0,
    this.gpuPartitionSize = '',
    this.tpuTopology = '',
    this.multihostGpuNodeCount = 0,
    this.reservationAffinity,
  }) : super(fullyQualifiedName);

  factory MachineSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MachineSpec(
      machineType: switch (json['machineType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      acceleratorType: switch (json['acceleratorType']) {
        null => AcceleratorType.$default,
        Object $1 => AcceleratorType.fromJson($1),
      },
      acceleratorCount: switch (json['acceleratorCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      gpuPartitionSize: switch (json['gpuPartitionSize']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tpuTopology: switch (json['tpuTopology']) {
        null => '',
        Object $1 => decodeString($1),
      },
      multihostGpuNodeCount: switch (json['multihostGpuNodeCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      reservationAffinity: switch (json['reservationAffinity']) {
        null => null,
        Object $1 => ReservationAffinity.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (machineType.isNotDefault) 'machineType': machineType,
    if (acceleratorType.isNotDefault)
      'acceleratorType': acceleratorType.toJson(),
    if (acceleratorCount.isNotDefault) 'acceleratorCount': acceleratorCount,
    if (gpuPartitionSize.isNotDefault) 'gpuPartitionSize': gpuPartitionSize,
    if (tpuTopology.isNotDefault) 'tpuTopology': tpuTopology,
    if (multihostGpuNodeCount.isNotDefault)
      'multihostGpuNodeCount': multihostGpuNodeCount,
    if (reservationAffinity != null)
      'reservationAffinity': reservationAffinity!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'machineType=$machineType',
      'acceleratorType=$acceleratorType',
      'acceleratorCount=$acceleratorCount',
      'gpuPartitionSize=$gpuPartitionSize',
      'tpuTopology=$tpuTopology',
      'multihostGpuNodeCount=$multihostGpuNodeCount',
    ].join(',');
    return 'MachineSpec($contents)';
  }
}

/// A description of resources that are dedicated to a DeployedModel or
/// DeployedIndex, and that need a higher degree of manual configuration.
final class DedicatedResources extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DedicatedResources';

  /// Required. Immutable. The specification of a single machine being used.
  final MachineSpec? machineSpec;

  /// Required. Immutable. The minimum number of machine replicas that will be
  /// always deployed on. This value must be greater than or equal to 1.
  ///
  /// If traffic increases, it may dynamically be deployed onto more replicas,
  /// and as traffic decreases, some of these extra replicas may be freed.
  final int minReplicaCount;

  /// Immutable. The maximum number of replicas that may be deployed on when the
  /// traffic against it increases. If the requested value is too large, the
  /// deployment will error, but if deployment succeeds then the ability to scale
  /// to that many replicas is guaranteed (barring service outages). If traffic
  /// increases beyond what its replicas at maximum may handle, a portion of the
  /// traffic will be dropped. If this value is not provided, will use
  /// `min_replica_count`
  /// as the default value.
  ///
  /// The value of this field impacts the charge against Vertex CPU and GPU
  /// quotas. Specifically, you will be charged for (max_replica_count *
  /// number of cores in the selected machine type) and (max_replica_count *
  /// number of GPUs per replica in the selected machine type).
  final int maxReplicaCount;

  /// Optional. Number of required available replicas for the deployment to
  /// succeed. This field is only needed when partial deployment/mutation is
  /// desired. If set, the deploy/mutate operation will succeed once
  /// available_replica_count reaches required_replica_count, and the rest of
  /// the replicas will be retried. If not set, the default
  /// required_replica_count will be min_replica_count.
  final int requiredReplicaCount;

  /// Immutable. Number of initial replicas being deployed on when scaling the
  /// workload up from zero or when creating the workload in case
  /// `min_replica_count`
  /// = 0. When
  /// `min_replica_count`
  /// > 0 (meaning that the scale-to-zero feature is not enabled),
  /// `initial_replica_count`
  /// should not be set. When
  /// `min_replica_count`
  /// = 0 (meaning that the scale-to-zero feature is enabled),
  /// `initial_replica_count`
  /// should be larger than zero, but no greater than
  /// `max_replica_count`.
  final int initialReplicaCount;

  /// Immutable. The metric specifications that overrides a resource
  /// utilization metric (CPU utilization, accelerator's duty cycle, and so on)
  /// target value (default to 60 if not set). At most one entry is allowed per
  /// metric.
  ///
  /// If
  /// `machine_spec.accelerator_count`
  /// is above 0, the autoscaling will be based on both CPU utilization and
  /// accelerator's duty cycle metrics and scale up when either metrics exceeds
  /// its target value while scale down if both metrics are under their target
  /// value. The default target value is 60 for both metrics.
  ///
  /// If
  /// `machine_spec.accelerator_count`
  /// is 0, the autoscaling will be based on CPU utilization metric only with
  /// default target value 60 if not explicitly set.
  ///
  /// For example, in the case of Online Prediction, if you want to override
  /// target CPU utilization to 80, you should set
  /// `autoscaling_metric_specs.metric_name`
  /// to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
  /// `autoscaling_metric_specs.target`
  /// to `80`.
  final List<AutoscalingMetricSpec> autoscalingMetricSpecs;

  /// Optional. If true, schedule the deployment workload on [spot
  /// VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
  final bool spot;

  /// Optional. Immutable. If set, use DWS resource to schedule the deployment
  /// workload. reference:
  /// (https://cloud.google.com/blog/products/compute/introducing-dynamic-workload-scheduler)
  final FlexStart? flexStart;

  /// Optional. Specification for scale-to-zero feature.
  final DedicatedResources_ScaleToZeroSpec? scaleToZeroSpec;

  DedicatedResources({
    required this.machineSpec,
    required this.minReplicaCount,
    this.maxReplicaCount = 0,
    this.requiredReplicaCount = 0,
    this.initialReplicaCount = 0,
    this.autoscalingMetricSpecs = const [],
    this.spot = false,
    this.flexStart,
    this.scaleToZeroSpec,
  }) : super(fullyQualifiedName);

  factory DedicatedResources.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DedicatedResources(
      machineSpec: switch (json['machineSpec']) {
        null => null,
        Object $1 => MachineSpec.fromJson($1),
      },
      minReplicaCount: switch (json['minReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      maxReplicaCount: switch (json['maxReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      requiredReplicaCount: switch (json['requiredReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      initialReplicaCount: switch (json['initialReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      autoscalingMetricSpecs: switch (json['autoscalingMetricSpecs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) AutoscalingMetricSpec.fromJson(i),
        ],
        _ => throw const FormatException(
          '"autoscalingMetricSpecs" is not a list',
        ),
      },
      spot: switch (json['spot']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      flexStart: switch (json['flexStart']) {
        null => null,
        Object $1 => FlexStart.fromJson($1),
      },
      scaleToZeroSpec: switch (json['scaleToZeroSpec']) {
        null => null,
        Object $1 => DedicatedResources_ScaleToZeroSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
    'minReplicaCount': minReplicaCount,
    if (maxReplicaCount.isNotDefault) 'maxReplicaCount': maxReplicaCount,
    if (requiredReplicaCount.isNotDefault)
      'requiredReplicaCount': requiredReplicaCount,
    if (initialReplicaCount.isNotDefault)
      'initialReplicaCount': initialReplicaCount,
    if (autoscalingMetricSpecs.isNotDefault)
      'autoscalingMetricSpecs': encodeList(autoscalingMetricSpecs),
    if (spot.isNotDefault) 'spot': spot,
    if (flexStart != null) 'flexStart': flexStart!.toJson(),
    if (scaleToZeroSpec != null) 'scaleToZeroSpec': scaleToZeroSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'minReplicaCount=$minReplicaCount',
      'maxReplicaCount=$maxReplicaCount',
      'requiredReplicaCount=$requiredReplicaCount',
      'initialReplicaCount=$initialReplicaCount',
      'spot=$spot',
    ].join(',');
    return 'DedicatedResources($contents)';
  }
}

/// Specification for scale-to-zero feature.
final class DedicatedResources_ScaleToZeroSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DedicatedResources.ScaleToZeroSpec';

  /// Optional. Minimum duration that a deployment will be scaled up before
  /// traffic is evaluated for potential scale-down. [MinValue=300] (5 minutes)
  /// [MaxValue=28800] (8 hours)
  final protobuf.Duration? minScaleupPeriod;

  /// Optional. Duration of no traffic before scaling to zero.
  /// [MinValue=3600] (5 minutes)
  /// [MaxValue=28800] (8 hours)
  final protobuf.Duration? idleScaledownPeriod;

  DedicatedResources_ScaleToZeroSpec({
    this.minScaleupPeriod,
    this.idleScaledownPeriod,
  }) : super(fullyQualifiedName);

  factory DedicatedResources_ScaleToZeroSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DedicatedResources_ScaleToZeroSpec(
      minScaleupPeriod: switch (json['minScaleupPeriod']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      idleScaledownPeriod: switch (json['idleScaledownPeriod']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (minScaleupPeriod != null)
      'minScaleupPeriod': minScaleupPeriod!.toJson(),
    if (idleScaledownPeriod != null)
      'idleScaledownPeriod': idleScaledownPeriod!.toJson(),
  };

  @override
  String toString() => 'ScaleToZeroSpec()';
}

/// A description of resources that to large degree are decided by Vertex AI,
/// and require only a modest additional configuration.
/// Each Model supporting these resources documents its specific guidelines.
final class AutomaticResources extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AutomaticResources';

  /// Immutable. The minimum number of replicas that will be always deployed on.
  /// If traffic against it increases, it may dynamically be deployed onto more
  /// replicas up to
  /// `max_replica_count`,
  /// and as traffic decreases, some of these extra replicas may be freed. If the
  /// requested value is too large, the deployment will error.
  final int minReplicaCount;

  /// Immutable. The maximum number of replicas that may be deployed on when the
  /// traffic against it increases. If the requested value is too large, the
  /// deployment will error, but if deployment succeeds then the ability to scale
  /// to that many replicas is guaranteed (barring service outages). If traffic
  /// increases beyond what its replicas at maximum may handle, a portion of the
  /// traffic will be dropped. If this value is not provided, a no upper bound
  /// for scaling under heavy traffic will be assume, though Vertex AI may be
  /// unable to scale beyond certain replica number.
  final int maxReplicaCount;

  AutomaticResources({this.minReplicaCount = 0, this.maxReplicaCount = 0})
    : super(fullyQualifiedName);

  factory AutomaticResources.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AutomaticResources(
      minReplicaCount: switch (json['minReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      maxReplicaCount: switch (json['maxReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (minReplicaCount.isNotDefault) 'minReplicaCount': minReplicaCount,
    if (maxReplicaCount.isNotDefault) 'maxReplicaCount': maxReplicaCount,
  };

  @override
  String toString() {
    final contents = [
      'minReplicaCount=$minReplicaCount',
      'maxReplicaCount=$maxReplicaCount',
    ].join(',');
    return 'AutomaticResources($contents)';
  }
}

/// A description of resources that are used for performing batch operations, are
/// dedicated to a Model, and need manual configuration.
final class BatchDedicatedResources extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchDedicatedResources';

  /// Required. Immutable. The specification of a single machine.
  final MachineSpec? machineSpec;

  /// Immutable. The number of machine replicas used at the start of the batch
  /// operation. If not set, Vertex AI decides starting number, not greater than
  /// `max_replica_count`
  final int startingReplicaCount;

  /// Immutable. The maximum number of machine replicas the batch operation may
  /// be scaled to. The default value is 10.
  final int maxReplicaCount;

  /// Optional. Immutable. If set, use DWS resource to schedule the deployment
  /// workload. reference:
  /// (https://cloud.google.com/blog/products/compute/introducing-dynamic-workload-scheduler)
  final FlexStart? flexStart;

  /// Optional. If true, schedule the deployment workload on [spot
  /// VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
  final bool spot;

  BatchDedicatedResources({
    required this.machineSpec,
    this.startingReplicaCount = 0,
    this.maxReplicaCount = 0,
    this.flexStart,
    this.spot = false,
  }) : super(fullyQualifiedName);

  factory BatchDedicatedResources.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchDedicatedResources(
      machineSpec: switch (json['machineSpec']) {
        null => null,
        Object $1 => MachineSpec.fromJson($1),
      },
      startingReplicaCount: switch (json['startingReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      maxReplicaCount: switch (json['maxReplicaCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      flexStart: switch (json['flexStart']) {
        null => null,
        Object $1 => FlexStart.fromJson($1),
      },
      spot: switch (json['spot']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
    if (startingReplicaCount.isNotDefault)
      'startingReplicaCount': startingReplicaCount,
    if (maxReplicaCount.isNotDefault) 'maxReplicaCount': maxReplicaCount,
    if (flexStart != null) 'flexStart': flexStart!.toJson(),
    if (spot.isNotDefault) 'spot': spot,
  };

  @override
  String toString() {
    final contents = [
      'startingReplicaCount=$startingReplicaCount',
      'maxReplicaCount=$maxReplicaCount',
      'spot=$spot',
    ].join(',');
    return 'BatchDedicatedResources($contents)';
  }
}

/// Statistics information about resource consumption.
final class ResourcesConsumed extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourcesConsumed';

  /// Output only. The number of replica hours used. Note that many replicas may
  /// run in parallel, and additionally any given work may be queued for some
  /// time. Therefore this value is not strictly related to wall time.
  final double replicaHours;

  ResourcesConsumed({this.replicaHours = 0}) : super(fullyQualifiedName);

  factory ResourcesConsumed.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourcesConsumed(
      replicaHours: switch (json['replicaHours']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (replicaHours.isNotDefault) 'replicaHours': encodeDouble(replicaHours),
  };

  @override
  String toString() {
    final contents = ['replicaHours=$replicaHours'].join(',');
    return 'ResourcesConsumed($contents)';
  }
}

/// Represents the spec of disk options.
final class DiskSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DiskSpec';

  /// Type of the boot disk. For non-A3U machines, the default value is
  /// "pd-ssd", for A3U machines, the default value is "hyperdisk-balanced".
  /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive),
  /// "pd-standard" (Persistent Disk Hard Disk Drive) or "hyperdisk-balanced".
  final String bootDiskType;

  /// Size in GB of the boot disk (default is 100GB).
  final int bootDiskSizeGb;

  DiskSpec({this.bootDiskType = '', this.bootDiskSizeGb = 0})
    : super(fullyQualifiedName);

  factory DiskSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DiskSpec(
      bootDiskType: switch (json['bootDiskType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      bootDiskSizeGb: switch (json['bootDiskSizeGb']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bootDiskType.isNotDefault) 'bootDiskType': bootDiskType,
    if (bootDiskSizeGb.isNotDefault) 'bootDiskSizeGb': bootDiskSizeGb,
  };

  @override
  String toString() {
    final contents = [
      'bootDiskType=$bootDiskType',
      'bootDiskSizeGb=$bootDiskSizeGb',
    ].join(',');
    return 'DiskSpec($contents)';
  }
}

/// Represents the spec of [persistent
/// disk][https://cloud.google.com/compute/docs/disks/persistent-disks] options.
final class PersistentDiskSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PersistentDiskSpec';

  /// Type of the disk (default is "pd-standard").
  /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive)
  /// "pd-standard" (Persistent Disk Hard Disk Drive)
  /// "pd-balanced" (Balanced Persistent Disk)
  /// "pd-extreme" (Extreme Persistent Disk)
  final String diskType;

  /// Size in GB of the disk (default is 100GB).
  final int diskSizeGb;

  PersistentDiskSpec({this.diskType = '', this.diskSizeGb = 0})
    : super(fullyQualifiedName);

  factory PersistentDiskSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PersistentDiskSpec(
      diskType: switch (json['diskType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      diskSizeGb: switch (json['diskSizeGb']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (diskType.isNotDefault) 'diskType': diskType,
    if (diskSizeGb.isNotDefault) 'diskSizeGb': encodeInt64(diskSizeGb),
  };

  @override
  String toString() {
    final contents = ['diskType=$diskType', 'diskSizeGb=$diskSizeGb'].join(',');
    return 'PersistentDiskSpec($contents)';
  }
}

/// Represents a mount configuration for Network File System (NFS) to mount.
final class NfsMount extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NfsMount';

  /// Required. IP address of the NFS server.
  final String server;

  /// Required. Source path exported from NFS server.
  /// Has to start with '/', and combined with the ip address, it indicates
  /// the source mount path in the form of `server:path`
  final String path;

  /// Required. Destination mount path. The NFS will be mounted for the user
  /// under /mnt/nfs/<mount_point>
  final String mountPoint;

  NfsMount({required this.server, required this.path, required this.mountPoint})
    : super(fullyQualifiedName);

  factory NfsMount.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NfsMount(
      server: switch (json['server']) {
        null => '',
        Object $1 => decodeString($1),
      },
      path: switch (json['path']) {
        null => '',
        Object $1 => decodeString($1),
      },
      mountPoint: switch (json['mountPoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'server': server, 'path': path, 'mountPoint': mountPoint};

  @override
  String toString() {
    final contents = [
      'server=$server',
      'path=$path',
      'mountPoint=$mountPoint',
    ].join(',');
    return 'NfsMount($contents)';
  }
}

/// The metric specification that defines the target resource utilization
/// (CPU utilization, accelerator's duty cycle, and so on) for calculating the
/// desired replica count.
final class AutoscalingMetricSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AutoscalingMetricSpec';

  /// Required. The resource metric name.
  /// Supported metrics:
  ///
  /// * For Online Prediction:
  /// * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle`
  /// * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
  /// * `aiplatform.googleapis.com/prediction/online/request_count`
  final String metricName;

  /// The target resource utilization in percentage (1% - 100%) for the given
  /// metric; once the real usage deviates from the target by a certain
  /// percentage, the machine replicas change. The default value is 60
  /// (representing 60%) if not provided.
  final int target;

  /// Optional. The Cloud Monitoring monitored resource labels as key value pairs
  /// used for metrics filtering. See Cloud Monitoring Labels
  /// https://cloud.google.com/monitoring/api/v3/metric-model#generic-label-info
  final Map<String, String> monitoredResourceLabels;

  AutoscalingMetricSpec({
    required this.metricName,
    this.target = 0,
    this.monitoredResourceLabels = const {},
  }) : super(fullyQualifiedName);

  factory AutoscalingMetricSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AutoscalingMetricSpec(
      metricName: switch (json['metricName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      target: switch (json['target']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      monitoredResourceLabels: switch (json['monitoredResourceLabels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException(
          '"monitoredResourceLabels" is not an object',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    'metricName': metricName,
    if (target.isNotDefault) 'target': target,
    if (monitoredResourceLabels.isNotDefault)
      'monitoredResourceLabels': monitoredResourceLabels,
  };

  @override
  String toString() {
    final contents = ['metricName=$metricName', 'target=$target'].join(',');
    return 'AutoscalingMetricSpec($contents)';
  }
}

/// A set of Shielded Instance options.
/// See [Images using supported Shielded VM
/// features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
final class ShieldedVmConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ShieldedVmConfig';

  /// Defines whether the instance has [Secure
  /// Boot](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot)
  /// enabled.
  ///
  /// Secure Boot helps ensure that the system only runs authentic software by
  /// verifying the digital signature of all boot components, and halting the
  /// boot process if signature verification fails.
  final bool enableSecureBoot;

  ShieldedVmConfig({this.enableSecureBoot = false}) : super(fullyQualifiedName);

  factory ShieldedVmConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ShieldedVmConfig(
      enableSecureBoot: switch (json['enableSecureBoot']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enableSecureBoot.isNotDefault) 'enableSecureBoot': enableSecureBoot,
  };

  @override
  String toString() {
    final contents = ['enableSecureBoot=$enableSecureBoot'].join(',');
    return 'ShieldedVmConfig($contents)';
  }
}

/// FlexStart is used to schedule the deployment workload on DWS resource. It
/// contains the max duration of the deployment.
final class FlexStart extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FlexStart';

  /// The max duration of the deployment is max_runtime_duration. The
  /// deployment will be terminated after the duration. The
  /// max_runtime_duration can be set up to 7 days.
  final protobuf.Duration? maxRuntimeDuration;

  FlexStart({this.maxRuntimeDuration}) : super(fullyQualifiedName);

  factory FlexStart.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FlexStart(
      maxRuntimeDuration: switch (json['maxRuntimeDuration']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxRuntimeDuration != null)
      'maxRuntimeDuration': maxRuntimeDuration!.toJson(),
  };

  @override
  String toString() => 'FlexStart()';
}

/// Manual batch tuning parameters.
final class ManualBatchTuningParameters extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ManualBatchTuningParameters';

  /// Immutable. The number of the records (e.g. instances) of the operation
  /// given in each batch to a machine replica. Machine type, and size of a
  /// single record should be considered when setting this parameter, higher
  /// value speeds up the batch operation's execution, but too high value will
  /// result in a whole batch not fitting in a machine's memory, and the whole
  /// operation will fail.
  /// The default value is 64.
  final int batchSize;

  ManualBatchTuningParameters({this.batchSize = 0}) : super(fullyQualifiedName);

  factory ManualBatchTuningParameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ManualBatchTuningParameters(
      batchSize: switch (json['batchSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {if (batchSize.isNotDefault) 'batchSize': batchSize};

  @override
  String toString() {
    final contents = ['batchSize=$batchSize'].join(',');
    return 'ManualBatchTuningParameters($contents)';
  }
}

/// The request message for
/// `MatchService.FindNeighbors`.
final class FindNeighborsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsRequest';

  /// Required. The name of the index endpoint.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// The ID of the DeployedIndex that will serve the request. This request is
  /// sent to a specific IndexEndpoint, as per the IndexEndpoint.network. That
  /// IndexEndpoint also has IndexEndpoint.deployed_indexes, and each such index
  /// has a DeployedIndex.id field.
  /// The value of the field below must equal one of the DeployedIndex.id
  /// fields of the IndexEndpoint that is being called for this request.
  final String deployedIndexId;

  /// The list of queries.
  final List<FindNeighborsRequest_Query> queries;

  /// If set to true, the full datapoints (including all vector values and
  /// restricts) of the nearest neighbors are returned.
  /// Note that returning full datapoint will significantly increase the
  /// latency and cost of the query.
  final bool returnFullDatapoint;

  FindNeighborsRequest({
    required this.indexEndpoint,
    this.deployedIndexId = '',
    this.queries = const [],
    this.returnFullDatapoint = false,
  }) : super(fullyQualifiedName);

  factory FindNeighborsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FindNeighborsRequest(
      indexEndpoint: switch (json['indexEndpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedIndexId: switch (json['deployedIndexId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      queries: switch (json['queries']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FindNeighborsRequest_Query.fromJson(i),
        ],
        _ => throw const FormatException('"queries" is not a list'),
      },
      returnFullDatapoint: switch (json['returnFullDatapoint']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'indexEndpoint': indexEndpoint,
    if (deployedIndexId.isNotDefault) 'deployedIndexId': deployedIndexId,
    if (queries.isNotDefault) 'queries': encodeList(queries),
    if (returnFullDatapoint.isNotDefault)
      'returnFullDatapoint': returnFullDatapoint,
  };

  @override
  String toString() {
    final contents = [
      'indexEndpoint=$indexEndpoint',
      'deployedIndexId=$deployedIndexId',
      'returnFullDatapoint=$returnFullDatapoint',
    ].join(',');
    return 'FindNeighborsRequest($contents)';
  }
}

/// A query to find a number of the nearest neighbors (most similar vectors)
/// of a vector.
final class FindNeighborsRequest_Query extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsRequest.Query';

  /// Optional. Represents RRF algorithm that combines search results.
  final FindNeighborsRequest_Query_Rrf? rrf;

  /// Required. The datapoint/vector whose nearest neighbors should be searched
  /// for.
  final IndexDatapoint? datapoint;

  /// The number of nearest neighbors to be retrieved from database for each
  /// query. If not set, will use the default from the service configuration
  /// (https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config).
  final int neighborCount;

  /// Crowding is a constraint on a neighbor list produced by nearest neighbor
  /// search requiring that no more than some value k' of the k neighbors
  /// returned have the same value of crowding_attribute.
  /// It's used for improving result diversity.
  /// This field is the maximum number of matches with the same crowding tag.
  final int perCrowdingAttributeNeighborCount;

  /// The number of neighbors to find via approximate search before
  /// exact reordering is performed. If not set, the default value from scam
  /// config is used; if set, this value must be > 0.
  final int approximateNeighborCount;

  /// The fraction of the number of leaves to search, set at query time allows
  /// user to tune search performance. This value increase result in both
  /// search accuracy and latency increase. The value should be between 0.0
  /// and 1.0. If not set or set to 0.0, query uses the default value specified
  /// in
  /// NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
  final double fractionLeafNodesToSearchOverride;

  FindNeighborsRequest_Query({
    this.rrf,
    required this.datapoint,
    this.neighborCount = 0,
    this.perCrowdingAttributeNeighborCount = 0,
    this.approximateNeighborCount = 0,
    this.fractionLeafNodesToSearchOverride = 0,
  }) : super(fullyQualifiedName);

  factory FindNeighborsRequest_Query.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FindNeighborsRequest_Query(
      rrf: switch (json['rrf']) {
        null => null,
        Object $1 => FindNeighborsRequest_Query_Rrf.fromJson($1),
      },
      datapoint: switch (json['datapoint']) {
        null => null,
        Object $1 => IndexDatapoint.fromJson($1),
      },
      neighborCount: switch (json['neighborCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      perCrowdingAttributeNeighborCount:
          switch (json['perCrowdingAttributeNeighborCount']) {
            null => 0,
            Object $1 => decodeInt($1),
          },
      approximateNeighborCount: switch (json['approximateNeighborCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      fractionLeafNodesToSearchOverride:
          switch (json['fractionLeafNodesToSearchOverride']) {
            null => 0,
            Object $1 => decodeDouble($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (rrf != null) 'rrf': rrf!.toJson(),
    if (datapoint != null) 'datapoint': datapoint!.toJson(),
    if (neighborCount.isNotDefault) 'neighborCount': neighborCount,
    if (perCrowdingAttributeNeighborCount.isNotDefault)
      'perCrowdingAttributeNeighborCount': perCrowdingAttributeNeighborCount,
    if (approximateNeighborCount.isNotDefault)
      'approximateNeighborCount': approximateNeighborCount,
    if (fractionLeafNodesToSearchOverride.isNotDefault)
      'fractionLeafNodesToSearchOverride': encodeDouble(
        fractionLeafNodesToSearchOverride,
      ),
  };

  @override
  String toString() {
    final contents = [
      'neighborCount=$neighborCount',
      'perCrowdingAttributeNeighborCount=$perCrowdingAttributeNeighborCount',
      'approximateNeighborCount=$approximateNeighborCount',
      'fractionLeafNodesToSearchOverride=$fractionLeafNodesToSearchOverride',
    ].join(',');
    return 'Query($contents)';
  }
}

/// Parameters for RRF algorithm that combines search results.
final class FindNeighborsRequest_Query_Rrf extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsRequest.Query.RRF';

  /// Required. Users can provide an alpha value to give more weight to dense
  /// vs sparse results. For example, if the alpha is 0, we only return
  /// sparse and if the alpha is 1, we only return dense.
  final double alpha;

  FindNeighborsRequest_Query_Rrf({required this.alpha})
    : super(fullyQualifiedName);

  factory FindNeighborsRequest_Query_Rrf.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FindNeighborsRequest_Query_Rrf(
      alpha: switch (json['alpha']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {'alpha': encodeDouble(alpha)};

  @override
  String toString() {
    final contents = ['alpha=$alpha'].join(',');
    return 'RRF($contents)';
  }
}

/// The response message for
/// `MatchService.FindNeighbors`.
final class FindNeighborsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsResponse';

  /// The nearest neighbors of the query datapoints.
  final List<FindNeighborsResponse_NearestNeighbors> nearestNeighbors;

  FindNeighborsResponse({this.nearestNeighbors = const []})
    : super(fullyQualifiedName);

  factory FindNeighborsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FindNeighborsResponse(
      nearestNeighbors: switch (json['nearestNeighbors']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            FindNeighborsResponse_NearestNeighbors.fromJson(i),
        ],
        _ => throw const FormatException('"nearestNeighbors" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (nearestNeighbors.isNotDefault)
      'nearestNeighbors': encodeList(nearestNeighbors),
  };

  @override
  String toString() => 'FindNeighborsResponse()';
}

/// A neighbor of the query vector.
final class FindNeighborsResponse_Neighbor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsResponse.Neighbor';

  /// The datapoint of the neighbor.
  /// Note that full datapoints are returned only when "return_full_datapoint"
  /// is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
  /// fields are populated.
  final IndexDatapoint? datapoint;

  /// The distance between the neighbor and the dense embedding query.
  final double distance;

  /// The distance between the neighbor and the query sparse_embedding.
  final double sparseDistance;

  FindNeighborsResponse_Neighbor({
    this.datapoint,
    this.distance = 0,
    this.sparseDistance = 0,
  }) : super(fullyQualifiedName);

  factory FindNeighborsResponse_Neighbor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FindNeighborsResponse_Neighbor(
      datapoint: switch (json['datapoint']) {
        null => null,
        Object $1 => IndexDatapoint.fromJson($1),
      },
      distance: switch (json['distance']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      sparseDistance: switch (json['sparseDistance']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (datapoint != null) 'datapoint': datapoint!.toJson(),
    if (distance.isNotDefault) 'distance': encodeDouble(distance),
    if (sparseDistance.isNotDefault)
      'sparseDistance': encodeDouble(sparseDistance),
  };

  @override
  String toString() {
    final contents = [
      'distance=$distance',
      'sparseDistance=$sparseDistance',
    ].join(',');
    return 'Neighbor($contents)';
  }
}

/// Nearest neighbors for one query.
final class FindNeighborsResponse_NearestNeighbors extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsResponse.NearestNeighbors';

  /// The ID of the query datapoint.
  final String id;

  /// All its neighbors.
  final List<FindNeighborsResponse_Neighbor> neighbors;

  FindNeighborsResponse_NearestNeighbors({
    this.id = '',
    this.neighbors = const [],
  }) : super(fullyQualifiedName);

  factory FindNeighborsResponse_NearestNeighbors.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FindNeighborsResponse_NearestNeighbors(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      neighbors: switch (json['neighbors']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FindNeighborsResponse_Neighbor.fromJson(i),
        ],
        _ => throw const FormatException('"neighbors" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    if (neighbors.isNotDefault) 'neighbors': encodeList(neighbors),
  };

  @override
  String toString() {
    final contents = ['id=$id'].join(',');
    return 'NearestNeighbors($contents)';
  }
}

/// The request message for
/// `MatchService.ReadIndexDatapoints`.
final class ReadIndexDatapointsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadIndexDatapointsRequest';

  /// Required. The name of the index endpoint.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// The ID of the DeployedIndex that will serve the request.
  final String deployedIndexId;

  /// IDs of the datapoints to be searched for.
  final List<String> ids;

  ReadIndexDatapointsRequest({
    required this.indexEndpoint,
    this.deployedIndexId = '',
    this.ids = const [],
  }) : super(fullyQualifiedName);

  factory ReadIndexDatapointsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadIndexDatapointsRequest(
      indexEndpoint: switch (json['indexEndpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployedIndexId: switch (json['deployedIndexId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ids: switch (json['ids']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"ids" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'indexEndpoint': indexEndpoint,
    if (deployedIndexId.isNotDefault) 'deployedIndexId': deployedIndexId,
    if (ids.isNotDefault) 'ids': ids,
  };

  @override
  String toString() {
    final contents = [
      'indexEndpoint=$indexEndpoint',
      'deployedIndexId=$deployedIndexId',
    ].join(',');
    return 'ReadIndexDatapointsRequest($contents)';
  }
}

/// The response message for
/// `MatchService.ReadIndexDatapoints`.
final class ReadIndexDatapointsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadIndexDatapointsResponse';

  /// The result list of datapoints.
  final List<IndexDatapoint> datapoints;

  ReadIndexDatapointsResponse({this.datapoints = const []})
    : super(fullyQualifiedName);

  factory ReadIndexDatapointsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadIndexDatapointsResponse(
      datapoints: switch (json['datapoints']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) IndexDatapoint.fromJson(i)],
        _ => throw const FormatException('"datapoints" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (datapoints.isNotDefault) 'datapoints': encodeList(datapoints),
  };

  @override
  String toString() => 'ReadIndexDatapointsResponse()';
}

/// A memory.
final class Memory extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Memory';

  /// Optional. Timestamp of when this resource is considered expired.
  /// This is *always* provided on output, regardless of what `expiration` was
  /// sent on input.
  final protobuf.Timestamp? expireTime;

  /// Optional. Input only. The TTL for this resource. The expiration time is
  /// computed: now + TTL.
  final protobuf.Duration? ttl;

  /// Identifier. The resource name of the Memory.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  final String name;

  /// Optional. Display name of the Memory.
  final String displayName;

  /// Optional. Description of the Memory.
  final String description;

  /// Output only. Timestamp when this Memory was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Memory was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Required. Semantic knowledge extracted from the source content.
  final String fact;

  /// Required. Immutable. The scope of the Memory. Memories are isolated
  /// within their scope. The scope is defined when creating or generating
  /// memories. Scope values cannot contain the wildcard character '*'.
  final Map<String, String> scope;

  Memory({
    this.expireTime,
    this.ttl,
    this.name = '',
    this.displayName = '',
    this.description = '',
    this.createTime,
    this.updateTime,
    required this.fact,
    required this.scope,
  }) : super(fullyQualifiedName);

  factory Memory.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Memory(
      expireTime: switch (json['expireTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      ttl: switch (json['ttl']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      fact: switch (json['fact']) {
        null => '',
        Object $1 => decodeString($1),
      },
      scope: switch (json['scope']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"scope" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (expireTime != null) 'expireTime': expireTime!.toJson(),
    if (ttl != null) 'ttl': ttl!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    'fact': fact,
    'scope': scope,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'fact=$fact',
    ].join(',');
    return 'Memory($contents)';
  }
}

/// Request message for
/// `MemoryBankService.CreateMemory`.
final class CreateMemoryRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMemoryRequest';

  /// Required. The resource name of the ReasoningEngine to create the Memory
  /// under. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Required. The Memory to be created.
  final Memory? memory;

  CreateMemoryRequest({required this.parent, required this.memory})
    : super(fullyQualifiedName);

  factory CreateMemoryRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateMemoryRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      memory: switch (json['memory']) {
        null => null,
        Object $1 => Memory.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (memory != null) 'memory': memory!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateMemoryRequest($contents)';
  }
}

/// Details of
/// `MemoryBankService.CreateMemory`
/// operation.
final class CreateMemoryOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMemoryOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateMemoryOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateMemoryOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateMemoryOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateMemoryOperationMetadata()';
}

/// Request message for
/// `MemoryBankService.GetMemory`.
final class GetMemoryRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetMemoryRequest';

  /// Required. The resource name of the Memory.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  final String name;

  GetMemoryRequest({required this.name}) : super(fullyQualifiedName);

  factory GetMemoryRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetMemoryRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetMemoryRequest($contents)';
  }
}

/// Request message for
/// `MemoryBankService.UpdateMemory`.
final class UpdateMemoryRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateMemoryRequest';

  /// Required. The Memory which replaces the resource on the server.
  final Memory? memory;

  /// Optional. Mask specifying which fields to update.
  /// Supported fields:
  ///
  ///    * `display_name`
  ///    * `description`
  ///    * `fact`
  final protobuf.FieldMask? updateMask;

  UpdateMemoryRequest({required this.memory, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateMemoryRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateMemoryRequest(
      memory: switch (json['memory']) {
        null => null,
        Object $1 => Memory.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (memory != null) 'memory': memory!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateMemoryRequest()';
}

/// Details of
/// `MemoryBankService.UpdateMemory`
/// operation.
final class UpdateMemoryOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateMemoryOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UpdateMemoryOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateMemoryOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateMemoryOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateMemoryOperationMetadata()';
}

/// Request message for
/// `MemoryBankService.ListMemories`.
final class ListMemoriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMemoriesRequest';

  /// Required. The resource name of the ReasoningEngine to list the Memories
  /// under. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Optional. The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  ///
  /// Supported fields (equality match only):
  ///   * `scope` (as a JSON string)
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  final String pageToken;

  ListMemoriesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListMemoriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListMemoriesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListMemoriesRequest($contents)';
  }
}

/// Response message for
/// `MemoryBankService.ListMemories`.
final class ListMemoriesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMemoriesResponse';

  /// List of Memories in the requested page.
  final List<Memory> memories;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListMemoriesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListMemoriesResponse({this.memories = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListMemoriesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListMemoriesResponse(
      memories: switch (json['memories']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Memory.fromJson(i)],
        _ => throw const FormatException('"memories" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (memories.isNotDefault) 'memories': encodeList(memories),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListMemoriesResponse($contents)';
  }
}

/// Request message for
/// `MemoryBankService.DeleteMemory`.
final class DeleteMemoryRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteMemoryRequest';

  /// Required. The resource name of the Memory to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  final String name;

  DeleteMemoryRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteMemoryRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteMemoryRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteMemoryRequest($contents)';
  }
}

/// Details of
/// `MemoryBankService.DeleteMemory`
/// operation.
final class DeleteMemoryOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteMemoryOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  DeleteMemoryOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory DeleteMemoryOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteMemoryOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'DeleteMemoryOperationMetadata()';
}

/// Request message for
/// `MemoryBankService.GenerateMemories`.
final class GenerateMemoriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest';

  /// Defines a Vertex Session as the source content from which to generate
  /// memories.
  final GenerateMemoriesRequest_VertexSessionSource? vertexSessionSource;

  /// Defines a direct source of content as the source content from which to
  /// generate memories.
  final GenerateMemoriesRequest_DirectContentsSource? directContentsSource;

  /// Defines a direct source of memories that should be uploaded to Memory
  /// Bank. This is similar to `CreateMemory`, but it allows for consolidation
  /// between these new memories and existing memories for the same scope.
  final GenerateMemoriesRequest_DirectMemoriesSource? directMemoriesSource;

  /// Required. The resource name of the ReasoningEngine to generate memories
  /// for. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Optional. If true, generated memories will not be consolidated with
  /// existing memories; all generated memories will be added as new memories
  /// regardless of whether they are duplicates of or contradictory to existing
  /// memories. By default, memory consolidation is enabled.
  final bool disableConsolidation;

  /// Optional. The scope of the memories that should be generated. Memories will
  /// be consolidated across memories with the same scope. Must be provided
  /// unless the scope is defined in the source content. If `scope` is provided,
  /// it will override the scope defined in the source content. Scope values
  /// cannot contain the wildcard character '*'.
  final Map<String, String> scope;

  GenerateMemoriesRequest({
    this.vertexSessionSource,
    this.directContentsSource,
    this.directMemoriesSource,
    required this.parent,
    this.disableConsolidation = false,
    this.scope = const {},
  }) : super(fullyQualifiedName);

  factory GenerateMemoriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesRequest(
      vertexSessionSource: switch (json['vertexSessionSource']) {
        null => null,
        Object $1 => GenerateMemoriesRequest_VertexSessionSource.fromJson($1),
      },
      directContentsSource: switch (json['directContentsSource']) {
        null => null,
        Object $1 => GenerateMemoriesRequest_DirectContentsSource.fromJson($1),
      },
      directMemoriesSource: switch (json['directMemoriesSource']) {
        null => null,
        Object $1 => GenerateMemoriesRequest_DirectMemoriesSource.fromJson($1),
      },
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      disableConsolidation: switch (json['disableConsolidation']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      scope: switch (json['scope']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"scope" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (vertexSessionSource != null)
      'vertexSessionSource': vertexSessionSource!.toJson(),
    if (directContentsSource != null)
      'directContentsSource': directContentsSource!.toJson(),
    if (directMemoriesSource != null)
      'directMemoriesSource': directMemoriesSource!.toJson(),
    'parent': parent,
    if (disableConsolidation.isNotDefault)
      'disableConsolidation': disableConsolidation,
    if (scope.isNotDefault) 'scope': scope,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'disableConsolidation=$disableConsolidation',
    ].join(',');
    return 'GenerateMemoriesRequest($contents)';
  }
}

/// Defines an Agent Engine Session from which to generate the memories. If
/// `scope` is not provided, the scope will be extracted from the Session
/// (i.e. {"user_id": sesison.user_id}).
final class GenerateMemoriesRequest_VertexSessionSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.VertexSessionSource';

  /// Required. The resource name of the Session to generate memories for.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String session;

  /// Optional. Time range to define which session events should be used to
  /// generate memories. Start time (inclusive) of the time range. If not set,
  /// the start time is unbounded.
  final protobuf.Timestamp? startTime;

  /// Optional. End time (exclusive) of the time range. If not set, the end
  /// time is unbounded.
  final protobuf.Timestamp? endTime;

  GenerateMemoriesRequest_VertexSessionSource({
    required this.session,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_VertexSessionSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesRequest_VertexSessionSource(
      session: switch (json['session']) {
        null => '',
        Object $1 => decodeString($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'session': session,
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['session=$session'].join(',');
    return 'VertexSessionSource($contents)';
  }
}

/// Defines a direct source of content from which to generate the memories.
final class GenerateMemoriesRequest_DirectContentsSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.DirectContentsSource';

  /// Required. The source content (i.e. chat history) to generate memories
  /// from.
  final List<GenerateMemoriesRequest_DirectContentsSource_Event> events;

  GenerateMemoriesRequest_DirectContentsSource({required this.events})
    : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_DirectContentsSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesRequest_DirectContentsSource(
      events: switch (json['events']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            GenerateMemoriesRequest_DirectContentsSource_Event.fromJson(i),
        ],
        _ => throw const FormatException('"events" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'events': encodeList(events)};

  @override
  String toString() => 'DirectContentsSource()';
}

/// A single piece of conversation from which to generate memories.
final class GenerateMemoriesRequest_DirectContentsSource_Event
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.DirectContentsSource.Event';

  /// Required. A single piece of content from which to generate memories.
  final Content? content;

  GenerateMemoriesRequest_DirectContentsSource_Event({required this.content})
    : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_DirectContentsSource_Event.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesRequest_DirectContentsSource_Event(
      content: switch (json['content']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (content != null) 'content': content!.toJson()};

  @override
  String toString() => 'Event()';
}

/// Defines a direct source of memories that should be uploaded to Memory Bank
/// with consolidation.
final class GenerateMemoriesRequest_DirectMemoriesSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.DirectMemoriesSource';

  /// Required. The direct memories to upload to Memory Bank. At most 5 direct
  /// memories are allowed per request.
  final List<GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory>
  directMemories;

  GenerateMemoriesRequest_DirectMemoriesSource({required this.directMemories})
    : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_DirectMemoriesSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesRequest_DirectMemoriesSource(
      directMemories: switch (json['directMemories']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException('"directMemories" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'directMemories': encodeList(directMemories)};

  @override
  String toString() => 'DirectMemoriesSource()';
}

/// A direct memory to upload to Memory Bank.
final class GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.DirectMemoriesSource.DirectMemory';

  /// Required. The fact to consolidate with existing memories.
  final String fact;

  GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory({
    required this.fact,
  }) : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory(
      fact: switch (json['fact']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'fact': fact};

  @override
  String toString() {
    final contents = ['fact=$fact'].join(',');
    return 'DirectMemory($contents)';
  }
}

/// Response message for
/// `MemoryBankService.GenerateMemories`.
final class GenerateMemoriesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesResponse';

  /// The generated memories.
  final List<GenerateMemoriesResponse_GeneratedMemory> generatedMemories;

  GenerateMemoriesResponse({this.generatedMemories = const []})
    : super(fullyQualifiedName);

  factory GenerateMemoriesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesResponse(
      generatedMemories: switch (json['generatedMemories']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            GenerateMemoriesResponse_GeneratedMemory.fromJson(i),
        ],
        _ => throw const FormatException('"generatedMemories" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (generatedMemories.isNotDefault)
      'generatedMemories': encodeList(generatedMemories),
  };

  @override
  String toString() => 'GenerateMemoriesResponse()';
}

/// A memory generated by the operation.
final class GenerateMemoriesResponse_GeneratedMemory extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesResponse.GeneratedMemory';

  /// The generated Memory.
  final Memory? memory;

  /// The action that was performed on the Memory.
  final GenerateMemoriesResponse_GeneratedMemory_Action action;

  GenerateMemoriesResponse_GeneratedMemory({
    this.memory,
    this.action = GenerateMemoriesResponse_GeneratedMemory_Action.$default,
  }) : super(fullyQualifiedName);

  factory GenerateMemoriesResponse_GeneratedMemory.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesResponse_GeneratedMemory(
      memory: switch (json['memory']) {
        null => null,
        Object $1 => Memory.fromJson($1),
      },
      action: switch (json['action']) {
        null => GenerateMemoriesResponse_GeneratedMemory_Action.$default,
        Object $1 => GenerateMemoriesResponse_GeneratedMemory_Action.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (memory != null) 'memory': memory!.toJson(),
    if (action.isNotDefault) 'action': action.toJson(),
  };

  @override
  String toString() {
    final contents = ['action=$action'].join(',');
    return 'GeneratedMemory($contents)';
  }
}

/// Actions that can be performed on a Memory.
final class GenerateMemoriesResponse_GeneratedMemory_Action extends ProtoEnum {
  /// Action is unspecified.
  static const actionUnspecified =
      GenerateMemoriesResponse_GeneratedMemory_Action('ACTION_UNSPECIFIED');

  /// The memory was created.
  static const created = GenerateMemoriesResponse_GeneratedMemory_Action(
    'CREATED',
  );

  /// The memory was updated. The `fact` field may not be updated if the
  /// existing fact is still accurate.
  static const updated = GenerateMemoriesResponse_GeneratedMemory_Action(
    'UPDATED',
  );

  /// The memory was deleted.
  static const deleted = GenerateMemoriesResponse_GeneratedMemory_Action(
    'DELETED',
  );

  /// The default value for [GenerateMemoriesResponse_GeneratedMemory_Action].
  static const $default = actionUnspecified;

  const GenerateMemoriesResponse_GeneratedMemory_Action(super.value);

  factory GenerateMemoriesResponse_GeneratedMemory_Action.fromJson(
    Object? json,
  ) => GenerateMemoriesResponse_GeneratedMemory_Action(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Action.$value';
}

/// Details of
/// `MemoryBankService.GenerateMemories`
/// operation.
final class GenerateMemoriesOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  GenerateMemoriesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory GenerateMemoriesOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateMemoriesOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'GenerateMemoriesOperationMetadata()';
}

/// Request message for
/// `MemoryBankService.RetrieveMemories`.
final class RetrieveMemoriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesRequest';

  /// Parameters for semantic similarity search based retrieval.
  final RetrieveMemoriesRequest_SimilaritySearchParams? similaritySearchParams;

  /// Parameters for simple (non-similarity search) retrieval.
  final RetrieveMemoriesRequest_SimpleRetrievalParams? simpleRetrievalParams;

  /// Required. The resource name of the ReasoningEngine to retrieve memories
  /// from. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Required. The scope of the memories to retrieve. A memory must have
  /// exactly the same scope (`Memory.scope`) as the scope provided here to be
  /// retrieved (same keys and values). Order does not matter, but it is
  /// case-sensitive.
  final Map<String, String> scope;

  RetrieveMemoriesRequest({
    this.similaritySearchParams,
    this.simpleRetrievalParams,
    required this.parent,
    required this.scope,
  }) : super(fullyQualifiedName);

  factory RetrieveMemoriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrieveMemoriesRequest(
      similaritySearchParams: switch (json['similaritySearchParams']) {
        null => null,
        Object $1 => RetrieveMemoriesRequest_SimilaritySearchParams.fromJson(
          $1,
        ),
      },
      simpleRetrievalParams: switch (json['simpleRetrievalParams']) {
        null => null,
        Object $1 => RetrieveMemoriesRequest_SimpleRetrievalParams.fromJson($1),
      },
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      scope: switch (json['scope']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"scope" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (similaritySearchParams != null)
      'similaritySearchParams': similaritySearchParams!.toJson(),
    if (simpleRetrievalParams != null)
      'simpleRetrievalParams': simpleRetrievalParams!.toJson(),
    'parent': parent,
    'scope': scope,
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'RetrieveMemoriesRequest($contents)';
  }
}

/// Parameters for semantic similarity search based retrieval.
final class RetrieveMemoriesRequest_SimilaritySearchParams
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesRequest.SimilaritySearchParams';

  /// Required. Query to use for similarity search retrieval. If provided, then
  /// the parent ReasoningEngine must have
  /// `ReasoningEngineContextSpec.MemoryBankConfig.SimilaritySearchConfig`
  /// set.
  final String searchQuery;

  /// Optional. The maximum number of memories to return.
  /// The service may return fewer than this value. If unspecified, at most 3
  /// memories will be returned. The maximum value is 100; values above 100
  /// will be coerced to 100.
  final int topK;

  RetrieveMemoriesRequest_SimilaritySearchParams({
    required this.searchQuery,
    this.topK = 0,
  }) : super(fullyQualifiedName);

  factory RetrieveMemoriesRequest_SimilaritySearchParams.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrieveMemoriesRequest_SimilaritySearchParams(
      searchQuery: switch (json['searchQuery']) {
        null => '',
        Object $1 => decodeString($1),
      },
      topK: switch (json['topK']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    'searchQuery': searchQuery,
    if (topK.isNotDefault) 'topK': topK,
  };

  @override
  String toString() {
    final contents = ['searchQuery=$searchQuery', 'topK=$topK'].join(',');
    return 'SimilaritySearchParams($contents)';
  }
}

/// Parameters for simple (non-similarity search) retrieval.
final class RetrieveMemoriesRequest_SimpleRetrievalParams extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesRequest.SimpleRetrievalParams';

  /// Optional. The maximum number of memories to return.
  /// The service may return fewer than this value. If unspecified, at most 3
  /// memories will be returned. The maximum value is 100; values above 100
  /// will be coerced to 100.
  final int pageSize;

  /// Optional. A page token, received from a previous `RetrieveMemories` call.
  /// Provide this to retrieve the subsequent page.
  final String pageToken;

  RetrieveMemoriesRequest_SimpleRetrievalParams({
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory RetrieveMemoriesRequest_SimpleRetrievalParams.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrieveMemoriesRequest_SimpleRetrievalParams(
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = ['pageSize=$pageSize', 'pageToken=$pageToken'].join(',');
    return 'SimpleRetrievalParams($contents)';
  }
}

/// Response message for
/// `MemoryBankService.RetrieveMemories`.
final class RetrieveMemoriesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesResponse';

  /// The retrieved memories.
  final List<RetrieveMemoriesResponse_RetrievedMemory> retrievedMemories;

  /// A token that can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  /// This token is not set if similarity search was used for retrieval.
  final String nextPageToken;

  RetrieveMemoriesResponse({
    this.retrievedMemories = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory RetrieveMemoriesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrieveMemoriesResponse(
      retrievedMemories: switch (json['retrievedMemories']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            RetrieveMemoriesResponse_RetrievedMemory.fromJson(i),
        ],
        _ => throw const FormatException('"retrievedMemories" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (retrievedMemories.isNotDefault)
      'retrievedMemories': encodeList(retrievedMemories),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'RetrieveMemoriesResponse($contents)';
  }
}

/// A retrieved memory.
final class RetrieveMemoriesResponse_RetrievedMemory extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesResponse.RetrievedMemory';

  /// The retrieved Memory.
  final Memory? memory;

  /// The distance between the query and the retrieved Memory. Smaller values
  /// indicate more similar memories. This is only set if similarity search was
  /// used for retrieval.
  final double distance;

  RetrieveMemoriesResponse_RetrievedMemory({this.memory, this.distance = 0})
    : super(fullyQualifiedName);

  factory RetrieveMemoriesResponse_RetrievedMemory.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrieveMemoriesResponse_RetrievedMemory(
      memory: switch (json['memory']) {
        null => null,
        Object $1 => Memory.fromJson($1),
      },
      distance: switch (json['distance']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (memory != null) 'memory': memory!.toJson(),
    if (distance.isNotDefault) 'distance': encodeDouble(distance),
  };

  @override
  String toString() {
    final contents = ['distance=$distance'].join(',');
    return 'RetrievedMemory($contents)';
  }
}

/// Instance of a general MetadataSchema.
final class MetadataSchema extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetadataSchema';

  /// Output only. The resource name of the MetadataSchema.
  final String name;

  /// The version of the MetadataSchema. The version's format must match
  /// the following regular expression: `^[0-9]+[.][0-9]+[.][0-9]+$`, which would
  /// allow to order/compare different versions. Example: 1.0.0, 1.0.1, etc.
  final String schemaVersion;

  /// Required. The raw YAML string representation of the MetadataSchema. The
  /// combination of [MetadataSchema.version] and the schema name given by
  /// `title` in [MetadataSchema.schema] must be unique within a MetadataStore.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [MetadataSchema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#schemaObject)
  final String schema;

  /// The type of the MetadataSchema. This is a property that identifies which
  /// metadata types will use the MetadataSchema.
  final MetadataSchema_MetadataSchemaType schemaType;

  /// Output only. Timestamp when this MetadataSchema was created.
  final protobuf.Timestamp? createTime;

  /// Description of the Metadata Schema
  final String description;

  MetadataSchema({
    this.name = '',
    this.schemaVersion = '',
    required this.schema,
    this.schemaType = MetadataSchema_MetadataSchemaType.$default,
    this.createTime,
    this.description = '',
  }) : super(fullyQualifiedName);

  factory MetadataSchema.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetadataSchema(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      schemaVersion: switch (json['schemaVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
      schema: switch (json['schema']) {
        null => '',
        Object $1 => decodeString($1),
      },
      schemaType: switch (json['schemaType']) {
        null => MetadataSchema_MetadataSchemaType.$default,
        Object $1 => MetadataSchema_MetadataSchemaType.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (schemaVersion.isNotDefault) 'schemaVersion': schemaVersion,
    'schema': schema,
    if (schemaType.isNotDefault) 'schemaType': schemaType.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'schemaVersion=$schemaVersion',
      'schema=$schema',
      'schemaType=$schemaType',
      'description=$description',
    ].join(',');
    return 'MetadataSchema($contents)';
  }
}

/// Describes the type of the MetadataSchema.
final class MetadataSchema_MetadataSchemaType extends ProtoEnum {
  /// Unspecified type for the MetadataSchema.
  static const metadataSchemaTypeUnspecified =
      MetadataSchema_MetadataSchemaType('METADATA_SCHEMA_TYPE_UNSPECIFIED');

  /// A type indicating that the MetadataSchema will be used by Artifacts.
  static const artifactType = MetadataSchema_MetadataSchemaType(
    'ARTIFACT_TYPE',
  );

  /// A typee indicating that the MetadataSchema will be used by Executions.
  static const executionType = MetadataSchema_MetadataSchemaType(
    'EXECUTION_TYPE',
  );

  /// A state indicating that the MetadataSchema will be used by Contexts.
  static const contextType = MetadataSchema_MetadataSchemaType('CONTEXT_TYPE');

  /// The default value for [MetadataSchema_MetadataSchemaType].
  static const $default = metadataSchemaTypeUnspecified;

  const MetadataSchema_MetadataSchemaType(super.value);

  factory MetadataSchema_MetadataSchemaType.fromJson(Object? json) =>
      MetadataSchema_MetadataSchemaType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'MetadataSchemaType.$value';
}

/// Request message for
/// `MetadataService.CreateMetadataStore`.
final class CreateMetadataStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMetadataStoreRequest';

  /// Required. The resource name of the Location where the MetadataStore should
  /// be created.
  /// Format: `projects/{project}/locations/{location}/`
  final String parent;

  /// Required. The MetadataStore to create.
  final MetadataStore? metadataStore;

  /// The {metadatastore} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all MetadataStores in the parent Location.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting MetadataStore.)
  final String metadataStoreId;

  CreateMetadataStoreRequest({
    required this.parent,
    required this.metadataStore,
    this.metadataStoreId = '',
  }) : super(fullyQualifiedName);

  factory CreateMetadataStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateMetadataStoreRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadataStore: switch (json['metadataStore']) {
        null => null,
        Object $1 => MetadataStore.fromJson($1),
      },
      metadataStoreId: switch (json['metadataStoreId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (metadataStore != null) 'metadataStore': metadataStore!.toJson(),
    if (metadataStoreId.isNotDefault) 'metadataStoreId': metadataStoreId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'metadataStoreId=$metadataStoreId',
    ].join(',');
    return 'CreateMetadataStoreRequest($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.CreateMetadataStore`.
final class CreateMetadataStoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMetadataStoreOperationMetadata';

  /// Operation metadata for creating a MetadataStore.
  final GenericOperationMetadata? genericMetadata;

  CreateMetadataStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateMetadataStoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateMetadataStoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateMetadataStoreOperationMetadata()';
}

/// Request message for
/// `MetadataService.GetMetadataStore`.
final class GetMetadataStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetMetadataStoreRequest';

  /// Required. The resource name of the MetadataStore to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String name;

  GetMetadataStoreRequest({required this.name}) : super(fullyQualifiedName);

  factory GetMetadataStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetMetadataStoreRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetMetadataStoreRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListMetadataStores`.
final class ListMetadataStoresRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMetadataStoresRequest';

  /// Required. The Location whose MetadataStores should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// The maximum number of Metadata Stores to return. The service may return
  /// fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListMetadataStores`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  final String pageToken;

  ListMetadataStoresRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListMetadataStoresRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListMetadataStoresRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListMetadataStoresRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListMetadataStores`.
final class ListMetadataStoresResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMetadataStoresResponse';

  /// The MetadataStores found for the Location.
  final List<MetadataStore> metadataStores;

  /// A token, which can be sent as
  /// `ListMetadataStoresRequest.page_token`
  /// to retrieve the next page. If this field is not populated, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListMetadataStoresResponse({
    this.metadataStores = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListMetadataStoresResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListMetadataStoresResponse(
      metadataStores: switch (json['metadataStores']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) MetadataStore.fromJson(i)],
        _ => throw const FormatException('"metadataStores" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metadataStores.isNotDefault)
      'metadataStores': encodeList(metadataStores),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListMetadataStoresResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.DeleteMetadataStore`.
final class DeleteMetadataStoreRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteMetadataStoreRequest';

  /// Required. The resource name of the MetadataStore to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String name;

  /// Deprecated: Field is no longer supported.
  final bool force;

  DeleteMetadataStoreRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteMetadataStoreRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteMetadataStoreRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteMetadataStoreRequest($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.DeleteMetadataStore`.
final class DeleteMetadataStoreOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteMetadataStoreOperationMetadata';

  /// Operation metadata for deleting a MetadataStore.
  final GenericOperationMetadata? genericMetadata;

  DeleteMetadataStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory DeleteMetadataStoreOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteMetadataStoreOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'DeleteMetadataStoreOperationMetadata()';
}

/// Request message for
/// `MetadataService.CreateArtifact`.
final class CreateArtifactRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateArtifactRequest';

  /// Required. The resource name of the MetadataStore where the Artifact should
  /// be created.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. The Artifact to create.
  final Artifact? artifact;

  /// The {artifact} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// If not provided, the Artifact's ID will be a UUID generated by the service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all Artifacts in the parent MetadataStore. (Otherwise
  /// the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the
  /// caller can't view the preexisting Artifact.)
  final String artifactId;

  CreateArtifactRequest({
    required this.parent,
    required this.artifact,
    this.artifactId = '',
  }) : super(fullyQualifiedName);

  factory CreateArtifactRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateArtifactRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      artifact: switch (json['artifact']) {
        null => null,
        Object $1 => Artifact.fromJson($1),
      },
      artifactId: switch (json['artifactId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (artifact != null) 'artifact': artifact!.toJson(),
    if (artifactId.isNotDefault) 'artifactId': artifactId,
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'artifactId=$artifactId'].join(',');
    return 'CreateArtifactRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.GetArtifact`.
final class GetArtifactRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetArtifactRequest';

  /// Required. The resource name of the Artifact to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  final String name;

  GetArtifactRequest({required this.name}) : super(fullyQualifiedName);

  factory GetArtifactRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetArtifactRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetArtifactRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListArtifacts`.
final class ListArtifactsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListArtifactsRequest';

  /// Required. The MetadataStore whose Artifacts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// The maximum number of Artifacts to return. The service may return fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListArtifacts`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  final String pageToken;

  /// Filter specifying the boolean condition for the Artifacts to satisfy in
  /// order to be part of the result set.
  /// The syntax to define filter query is based on https://google.aip.dev/160.
  /// The supported set of filters include the following:
  ///
  /// *   **Attribute filtering**:
  ///     For example: `display_name = "test"`.
  ///     Supported fields include: `name`, `display_name`, `uri`, `state`,
  ///     `schema_title`, `create_time`, and `update_time`.
  ///     Time fields, such as `create_time` and `update_time`, require values
  ///     specified in RFC-3339 format.
  ///     For example: `create_time = "2020-11-19T11:30:00-04:00"`
  /// *   **Metadata field**:
  ///     To filter on metadata fields use traversal operation as follows:
  ///     `metadata.<field_name>.<type_value>`.
  ///     For example: `metadata.field_1.number_value = 10.0`
  ///     In case the field name contains special characters (such as colon), one
  ///     can embed it inside double quote.
  ///     For example: `metadata."field:1".number_value = 10.0`
  /// *   **Context based filtering**:
  ///     To filter Artifacts based on the contexts to which they belong, use the
  ///     function operator with the full resource name
  ///     `in_context(<context-name>)`.
  ///     For example:
  ///     `in_context("projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context-id>")`
  ///
  /// Each of the above supported filter types can be combined together using
  /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
  /// is 5.
  ///
  /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
  final String filter;

  /// How the list of messages is ordered. Specify the values to order by and an
  /// ordering operation. The default sorting order is ascending. To specify
  /// descending order for a field, users append a " desc" suffix; for example:
  /// "foo desc, bar".
  /// Subfields are specified with a `.` character, such as foo.bar.
  /// see https://google.aip.dev/132#ordering for more details.
  final String orderBy;

  ListArtifactsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListArtifactsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListArtifactsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListArtifactsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListArtifacts`.
final class ListArtifactsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListArtifactsResponse';

  /// The Artifacts retrieved from the MetadataStore.
  final List<Artifact> artifacts;

  /// A token, which can be sent as
  /// `ListArtifactsRequest.page_token`
  /// to retrieve the next page.
  /// If this field is not populated, there are no subsequent pages.
  final String nextPageToken;

  ListArtifactsResponse({this.artifacts = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListArtifactsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListArtifactsResponse(
      artifacts: switch (json['artifacts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Artifact.fromJson(i)],
        _ => throw const FormatException('"artifacts" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (artifacts.isNotDefault) 'artifacts': encodeList(artifacts),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListArtifactsResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.UpdateArtifact`.
final class UpdateArtifactRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateArtifactRequest';

  /// Required. The Artifact containing updates.
  /// The Artifact's
  /// `Artifact.name` field is
  /// used to identify the Artifact to be updated. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  final Artifact? artifact;

  /// Optional. A FieldMask indicating which fields should be updated.
  final protobuf.FieldMask? updateMask;

  /// If set to true, and the
  /// `Artifact` is not found, a new
  /// `Artifact` is created.
  final bool allowMissing;

  UpdateArtifactRequest({
    required this.artifact,
    this.updateMask,
    this.allowMissing = false,
  }) : super(fullyQualifiedName);

  factory UpdateArtifactRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateArtifactRequest(
      artifact: switch (json['artifact']) {
        null => null,
        Object $1 => Artifact.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      allowMissing: switch (json['allowMissing']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (artifact != null) 'artifact': artifact!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
    if (allowMissing.isNotDefault) 'allowMissing': allowMissing,
  };

  @override
  String toString() {
    final contents = ['allowMissing=$allowMissing'].join(',');
    return 'UpdateArtifactRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.DeleteArtifact`.
final class DeleteArtifactRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteArtifactRequest';

  /// Required. The resource name of the Artifact to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  final String name;

  /// Optional. The etag of the Artifact to delete.
  /// If this is provided, it must match the server's etag. Otherwise, the
  /// request will fail with a FAILED_PRECONDITION.
  final String etag;

  DeleteArtifactRequest({required this.name, this.etag = ''})
    : super(fullyQualifiedName);

  factory DeleteArtifactRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteArtifactRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (etag.isNotDefault) 'etag': etag};

  @override
  String toString() {
    final contents = ['name=$name', 'etag=$etag'].join(',');
    return 'DeleteArtifactRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.PurgeArtifacts`.
final class PurgeArtifactsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeArtifactsRequest';

  /// Required. The metadata store to purge Artifacts from.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. A required filter matching the Artifacts to be purged.
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  final String filter;

  /// Optional. Flag to indicate to actually perform the purge.
  /// If `force` is set to false, the method will return a sample of
  /// Artifact names that would be deleted.
  final bool force;

  PurgeArtifactsRequest({
    required this.parent,
    required this.filter,
    this.force = false,
  }) : super(fullyQualifiedName);

  factory PurgeArtifactsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeArtifactsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'filter': filter,
    if (force.isNotDefault) 'force': force,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'force=$force',
    ].join(',');
    return 'PurgeArtifactsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.PurgeArtifacts`.
final class PurgeArtifactsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeArtifactsResponse';

  /// The number of Artifacts that this request deleted (or, if `force` is false,
  /// the number of Artifacts that will be deleted). This can be an estimate.
  final int purgeCount;

  /// A sample of the Artifact names that will be deleted.
  /// Only populated if `force` is set to false. The maximum number of samples is
  /// 100 (it is possible to return fewer).
  final List<String> purgeSample;

  PurgeArtifactsResponse({this.purgeCount = 0, this.purgeSample = const []})
    : super(fullyQualifiedName);

  factory PurgeArtifactsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeArtifactsResponse(
      purgeCount: switch (json['purgeCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      purgeSample: switch (json['purgeSample']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"purgeSample" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (purgeCount.isNotDefault) 'purgeCount': encodeInt64(purgeCount),
    if (purgeSample.isNotDefault) 'purgeSample': purgeSample,
  };

  @override
  String toString() {
    final contents = ['purgeCount=$purgeCount'].join(',');
    return 'PurgeArtifactsResponse($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.PurgeArtifacts`.
final class PurgeArtifactsMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeArtifactsMetadata';

  /// Operation metadata for purging Artifacts.
  final GenericOperationMetadata? genericMetadata;

  PurgeArtifactsMetadata({this.genericMetadata}) : super(fullyQualifiedName);

  factory PurgeArtifactsMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeArtifactsMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'PurgeArtifactsMetadata()';
}

/// Request message for
/// `MetadataService.CreateContext`.
final class CreateContextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateContextRequest';

  /// Required. The resource name of the MetadataStore where the Context should
  /// be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. The Context to create.
  final Context? context;

  /// The {context} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`.
  /// If not provided, the Context's ID will be a UUID generated by the service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all Contexts in the parent MetadataStore. (Otherwise
  /// the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the
  /// caller can't view the preexisting Context.)
  final String contextId;

  CreateContextRequest({
    required this.parent,
    required this.context,
    this.contextId = '',
  }) : super(fullyQualifiedName);

  factory CreateContextRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateContextRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => Context.fromJson($1),
      },
      contextId: switch (json['contextId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (context != null) 'context': context!.toJson(),
    if (contextId.isNotDefault) 'contextId': contextId,
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'contextId=$contextId'].join(',');
    return 'CreateContextRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.GetContext`.
final class GetContextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetContextRequest';

  /// Required. The resource name of the Context to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String name;

  GetContextRequest({required this.name}) : super(fullyQualifiedName);

  factory GetContextRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetContextRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetContextRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListContexts`
final class ListContextsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListContextsRequest';

  /// Required. The MetadataStore whose Contexts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// The maximum number of Contexts to return. The service may return fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListContexts`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  final String pageToken;

  /// Filter specifying the boolean condition for the Contexts to satisfy in
  /// order to be part of the result set.
  /// The syntax to define filter query is based on https://google.aip.dev/160.
  /// Following are the supported set of filters:
  ///
  /// *  **Attribute filtering**:
  ///    For example: `display_name = "test"`.
  ///    Supported fields include: `name`, `display_name`, `schema_title`,
  ///    `create_time`, and `update_time`.
  ///    Time fields, such as `create_time` and `update_time`, require values
  ///    specified in RFC-3339 format.
  ///    For example: `create_time = "2020-11-19T11:30:00-04:00"`.
  /// *  **Metadata field**:
  ///    To filter on metadata fields use traversal operation as follows:
  ///    `metadata.<field_name>.<type_value>`.
  ///    For example: `metadata.field_1.number_value = 10.0`.
  ///    In case the field name contains special characters (such as colon), one
  ///    can embed it inside double quote.
  ///    For example: `metadata."field:1".number_value = 10.0`
  /// *  **Parent Child filtering**:
  ///    To filter Contexts based on parent-child relationship use the HAS
  ///    operator as follows:
  ///
  ///    ```
  ///    parent_contexts:
  ///    "projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context_id>"
  ///    child_contexts:
  ///    "projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context_id>"
  ///    ```
  ///
  /// Each of the above supported filters can be combined together using
  /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
  /// is 5.
  ///
  /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
  final String filter;

  /// How the list of messages is ordered. Specify the values to order by and an
  /// ordering operation. The default sorting order is ascending. To specify
  /// descending order for a field, users append a " desc" suffix; for example:
  /// "foo desc, bar".
  /// Subfields are specified with a `.` character, such as foo.bar.
  /// see https://google.aip.dev/132#ordering for more details.
  final String orderBy;

  ListContextsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListContextsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListContextsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListContextsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListContexts`.
final class ListContextsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListContextsResponse';

  /// The Contexts retrieved from the MetadataStore.
  final List<Context> contexts;

  /// A token, which can be sent as
  /// `ListContextsRequest.page_token`
  /// to retrieve the next page.
  /// If this field is not populated, there are no subsequent pages.
  final String nextPageToken;

  ListContextsResponse({this.contexts = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListContextsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListContextsResponse(
      contexts: switch (json['contexts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Context.fromJson(i)],
        _ => throw const FormatException('"contexts" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (contexts.isNotDefault) 'contexts': encodeList(contexts),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListContextsResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.UpdateContext`.
final class UpdateContextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateContextRequest';

  /// Required. The Context containing updates.
  /// The Context's `Context.name`
  /// field is used to identify the Context to be updated. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final Context? context;

  /// Optional. A FieldMask indicating which fields should be updated.
  final protobuf.FieldMask? updateMask;

  /// If set to true, and the `Context`
  /// is not found, a new `Context` is
  /// created.
  final bool allowMissing;

  UpdateContextRequest({
    required this.context,
    this.updateMask,
    this.allowMissing = false,
  }) : super(fullyQualifiedName);

  factory UpdateContextRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateContextRequest(
      context: switch (json['context']) {
        null => null,
        Object $1 => Context.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      allowMissing: switch (json['allowMissing']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (context != null) 'context': context!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
    if (allowMissing.isNotDefault) 'allowMissing': allowMissing,
  };

  @override
  String toString() {
    final contents = ['allowMissing=$allowMissing'].join(',');
    return 'UpdateContextRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.DeleteContext`.
final class DeleteContextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteContextRequest';

  /// Required. The resource name of the Context to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String name;

  /// The force deletion semantics is still undefined.
  /// Users should not use this field.
  final bool force;

  /// Optional. The etag of the Context to delete.
  /// If this is provided, it must match the server's etag. Otherwise, the
  /// request will fail with a FAILED_PRECONDITION.
  final String etag;

  DeleteContextRequest({required this.name, this.force = false, this.etag = ''})
    : super(fullyQualifiedName);

  factory DeleteContextRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteContextRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (force.isNotDefault) 'force': force,
    if (etag.isNotDefault) 'etag': etag,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force', 'etag=$etag'].join(',');
    return 'DeleteContextRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.PurgeContexts`.
final class PurgeContextsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeContextsRequest';

  /// Required. The metadata store to purge Contexts from.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. A required filter matching the Contexts to be purged.
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  final String filter;

  /// Optional. Flag to indicate to actually perform the purge.
  /// If `force` is set to false, the method will return a sample of
  /// Context names that would be deleted.
  final bool force;

  PurgeContextsRequest({
    required this.parent,
    required this.filter,
    this.force = false,
  }) : super(fullyQualifiedName);

  factory PurgeContextsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeContextsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'filter': filter,
    if (force.isNotDefault) 'force': force,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'force=$force',
    ].join(',');
    return 'PurgeContextsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.PurgeContexts`.
final class PurgeContextsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeContextsResponse';

  /// The number of Contexts that this request deleted (or, if `force` is false,
  /// the number of Contexts that will be deleted). This can be an estimate.
  final int purgeCount;

  /// A sample of the Context names that will be deleted.
  /// Only populated if `force` is set to false. The maximum number of samples is
  /// 100 (it is possible to return fewer).
  final List<String> purgeSample;

  PurgeContextsResponse({this.purgeCount = 0, this.purgeSample = const []})
    : super(fullyQualifiedName);

  factory PurgeContextsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeContextsResponse(
      purgeCount: switch (json['purgeCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      purgeSample: switch (json['purgeSample']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"purgeSample" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (purgeCount.isNotDefault) 'purgeCount': encodeInt64(purgeCount),
    if (purgeSample.isNotDefault) 'purgeSample': purgeSample,
  };

  @override
  String toString() {
    final contents = ['purgeCount=$purgeCount'].join(',');
    return 'PurgeContextsResponse($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.PurgeContexts`.
final class PurgeContextsMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeContextsMetadata';

  /// Operation metadata for purging Contexts.
  final GenericOperationMetadata? genericMetadata;

  PurgeContextsMetadata({this.genericMetadata}) : super(fullyQualifiedName);

  factory PurgeContextsMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeContextsMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'PurgeContextsMetadata()';
}

/// Request message for
/// `MetadataService.AddContextArtifactsAndExecutions`.
final class AddContextArtifactsAndExecutionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddContextArtifactsAndExecutionsRequest';

  /// Required. The resource name of the Context that the Artifacts and
  /// Executions belong to. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String context;

  /// The resource names of the Artifacts to attribute to the Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  final List<String> artifacts;

  /// The resource names of the Executions to associate with the
  /// Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final List<String> executions;

  AddContextArtifactsAndExecutionsRequest({
    required this.context,
    this.artifacts = const [],
    this.executions = const [],
  }) : super(fullyQualifiedName);

  factory AddContextArtifactsAndExecutionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AddContextArtifactsAndExecutionsRequest(
      context: switch (json['context']) {
        null => '',
        Object $1 => decodeString($1),
      },
      artifacts: switch (json['artifacts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"artifacts" is not a list'),
      },
      executions: switch (json['executions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"executions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'context': context,
    if (artifacts.isNotDefault) 'artifacts': artifacts,
    if (executions.isNotDefault) 'executions': executions,
  };

  @override
  String toString() {
    final contents = ['context=$context'].join(',');
    return 'AddContextArtifactsAndExecutionsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.AddContextArtifactsAndExecutions`.
final class AddContextArtifactsAndExecutionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddContextArtifactsAndExecutionsResponse';

  AddContextArtifactsAndExecutionsResponse() : super(fullyQualifiedName);

  factory AddContextArtifactsAndExecutionsResponse.fromJson(Object? j) =>
      AddContextArtifactsAndExecutionsResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'AddContextArtifactsAndExecutionsResponse()';
}

/// Request message for
/// `MetadataService.AddContextChildren`.
final class AddContextChildrenRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddContextChildrenRequest';

  /// Required. The resource name of the parent Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String context;

  /// The resource names of the child Contexts.
  final List<String> childContexts;

  AddContextChildrenRequest({
    required this.context,
    this.childContexts = const [],
  }) : super(fullyQualifiedName);

  factory AddContextChildrenRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AddContextChildrenRequest(
      context: switch (json['context']) {
        null => '',
        Object $1 => decodeString($1),
      },
      childContexts: switch (json['childContexts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"childContexts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'context': context,
    if (childContexts.isNotDefault) 'childContexts': childContexts,
  };

  @override
  String toString() {
    final contents = ['context=$context'].join(',');
    return 'AddContextChildrenRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.AddContextChildren`.
final class AddContextChildrenResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddContextChildrenResponse';

  AddContextChildrenResponse() : super(fullyQualifiedName);

  factory AddContextChildrenResponse.fromJson(Object? j) =>
      AddContextChildrenResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'AddContextChildrenResponse()';
}

/// Request message for
/// `MetadataService.DeleteContextChildrenRequest`.
final class RemoveContextChildrenRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveContextChildrenRequest';

  /// Required. The resource name of the parent Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String context;

  /// The resource names of the child Contexts.
  final List<String> childContexts;

  RemoveContextChildrenRequest({
    required this.context,
    this.childContexts = const [],
  }) : super(fullyQualifiedName);

  factory RemoveContextChildrenRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RemoveContextChildrenRequest(
      context: switch (json['context']) {
        null => '',
        Object $1 => decodeString($1),
      },
      childContexts: switch (json['childContexts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"childContexts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'context': context,
    if (childContexts.isNotDefault) 'childContexts': childContexts,
  };

  @override
  String toString() {
    final contents = ['context=$context'].join(',');
    return 'RemoveContextChildrenRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.RemoveContextChildren`.
final class RemoveContextChildrenResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveContextChildrenResponse';

  RemoveContextChildrenResponse() : super(fullyQualifiedName);

  factory RemoveContextChildrenResponse.fromJson(Object? j) =>
      RemoveContextChildrenResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'RemoveContextChildrenResponse()';
}

/// Request message for
/// `MetadataService.QueryContextLineageSubgraph`.
final class QueryContextLineageSubgraphRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryContextLineageSubgraphRequest';

  /// Required. The resource name of the Context whose Artifacts and Executions
  /// should be retrieved as a LineageSubgraph.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  ///
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  final String context;

  QueryContextLineageSubgraphRequest({required this.context})
    : super(fullyQualifiedName);

  factory QueryContextLineageSubgraphRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryContextLineageSubgraphRequest(
      context: switch (json['context']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'context': context};

  @override
  String toString() {
    final contents = ['context=$context'].join(',');
    return 'QueryContextLineageSubgraphRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.CreateExecution`.
final class CreateExecutionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateExecutionRequest';

  /// Required. The resource name of the MetadataStore where the Execution should
  /// be created.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. The Execution to create.
  final Execution? execution;

  /// The {execution} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// If not provided, the Execution's ID will be a UUID generated by the
  /// service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all Executions in the parent MetadataStore.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting Execution.)
  final String executionId;

  CreateExecutionRequest({
    required this.parent,
    required this.execution,
    this.executionId = '',
  }) : super(fullyQualifiedName);

  factory CreateExecutionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateExecutionRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      execution: switch (json['execution']) {
        null => null,
        Object $1 => Execution.fromJson($1),
      },
      executionId: switch (json['executionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (execution != null) 'execution': execution!.toJson(),
    if (executionId.isNotDefault) 'executionId': executionId,
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'executionId=$executionId'].join(',');
    return 'CreateExecutionRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.GetExecution`.
final class GetExecutionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetExecutionRequest';

  /// Required. The resource name of the Execution to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final String name;

  GetExecutionRequest({required this.name}) : super(fullyQualifiedName);

  factory GetExecutionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetExecutionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetExecutionRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListExecutions`.
final class ListExecutionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExecutionsRequest';

  /// Required. The MetadataStore whose Executions should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// The maximum number of Executions to return. The service may return fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListExecutions`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with an
  /// INVALID_ARGUMENT error.)
  final String pageToken;

  /// Filter specifying the boolean condition for the Executions to satisfy in
  /// order to be part of the result set.
  /// The syntax to define filter query is based on https://google.aip.dev/160.
  /// Following are the supported set of filters:
  ///
  /// *  **Attribute filtering**:
  ///    For example: `display_name = "test"`.
  ///    Supported fields include: `name`, `display_name`, `state`,
  ///    `schema_title`, `create_time`, and `update_time`.
  ///    Time fields, such as `create_time` and `update_time`, require values
  ///    specified in RFC-3339 format.
  ///    For example: `create_time = "2020-11-19T11:30:00-04:00"`.
  /// *  **Metadata field**:
  ///    To filter on metadata fields use traversal operation as follows:
  ///    `metadata.<field_name>.<type_value>`
  ///    For example: `metadata.field_1.number_value = 10.0`
  ///    In case the field name contains special characters (such as colon), one
  ///    can embed it inside double quote.
  ///    For example: `metadata."field:1".number_value = 10.0`
  /// *  **Context based filtering**:
  ///    To filter Executions based on the contexts to which they belong use
  ///    the function operator with the full resource name:
  ///    `in_context(<context-name>)`.
  ///    For example:
  ///    `in_context("projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context-id>")`
  ///
  /// Each of the above supported filters can be combined together using
  /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
  /// is 5.
  ///
  /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
  final String filter;

  /// How the list of messages is ordered. Specify the values to order by and an
  /// ordering operation. The default sorting order is ascending. To specify
  /// descending order for a field, users append a " desc" suffix; for example:
  /// "foo desc, bar".
  /// Subfields are specified with a `.` character, such as foo.bar.
  /// see https://google.aip.dev/132#ordering for more details.
  final String orderBy;

  ListExecutionsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListExecutionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListExecutionsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListExecutionsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListExecutions`.
final class ListExecutionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExecutionsResponse';

  /// The Executions retrieved from the MetadataStore.
  final List<Execution> executions;

  /// A token, which can be sent as
  /// `ListExecutionsRequest.page_token`
  /// to retrieve the next page.
  /// If this field is not populated, there are no subsequent pages.
  final String nextPageToken;

  ListExecutionsResponse({this.executions = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListExecutionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListExecutionsResponse(
      executions: switch (json['executions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Execution.fromJson(i)],
        _ => throw const FormatException('"executions" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (executions.isNotDefault) 'executions': encodeList(executions),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListExecutionsResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.UpdateExecution`.
final class UpdateExecutionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExecutionRequest';

  /// Required. The Execution containing updates.
  /// The Execution's
  /// `Execution.name` field is
  /// used to identify the Execution to be updated. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final Execution? execution;

  /// Optional. A FieldMask indicating which fields should be updated.
  final protobuf.FieldMask? updateMask;

  /// If set to true, and the
  /// `Execution` is not found, a new
  /// `Execution` is created.
  final bool allowMissing;

  UpdateExecutionRequest({
    required this.execution,
    this.updateMask,
    this.allowMissing = false,
  }) : super(fullyQualifiedName);

  factory UpdateExecutionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateExecutionRequest(
      execution: switch (json['execution']) {
        null => null,
        Object $1 => Execution.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      allowMissing: switch (json['allowMissing']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (execution != null) 'execution': execution!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
    if (allowMissing.isNotDefault) 'allowMissing': allowMissing,
  };

  @override
  String toString() {
    final contents = ['allowMissing=$allowMissing'].join(',');
    return 'UpdateExecutionRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.DeleteExecution`.
final class DeleteExecutionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteExecutionRequest';

  /// Required. The resource name of the Execution to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final String name;

  /// Optional. The etag of the Execution to delete.
  /// If this is provided, it must match the server's etag. Otherwise, the
  /// request will fail with a FAILED_PRECONDITION.
  final String etag;

  DeleteExecutionRequest({required this.name, this.etag = ''})
    : super(fullyQualifiedName);

  factory DeleteExecutionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteExecutionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (etag.isNotDefault) 'etag': etag};

  @override
  String toString() {
    final contents = ['name=$name', 'etag=$etag'].join(',');
    return 'DeleteExecutionRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.PurgeExecutions`.
final class PurgeExecutionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeExecutionsRequest';

  /// Required. The metadata store to purge Executions from.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. A required filter matching the Executions to be purged.
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  final String filter;

  /// Optional. Flag to indicate to actually perform the purge.
  /// If `force` is set to false, the method will return a sample of
  /// Execution names that would be deleted.
  final bool force;

  PurgeExecutionsRequest({
    required this.parent,
    required this.filter,
    this.force = false,
  }) : super(fullyQualifiedName);

  factory PurgeExecutionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeExecutionsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'filter': filter,
    if (force.isNotDefault) 'force': force,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'force=$force',
    ].join(',');
    return 'PurgeExecutionsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.PurgeExecutions`.
final class PurgeExecutionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeExecutionsResponse';

  /// The number of Executions that this request deleted (or, if `force` is
  /// false, the number of Executions that will be deleted). This can be an
  /// estimate.
  final int purgeCount;

  /// A sample of the Execution names that will be deleted.
  /// Only populated if `force` is set to false. The maximum number of samples is
  /// 100 (it is possible to return fewer).
  final List<String> purgeSample;

  PurgeExecutionsResponse({this.purgeCount = 0, this.purgeSample = const []})
    : super(fullyQualifiedName);

  factory PurgeExecutionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeExecutionsResponse(
      purgeCount: switch (json['purgeCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      purgeSample: switch (json['purgeSample']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"purgeSample" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (purgeCount.isNotDefault) 'purgeCount': encodeInt64(purgeCount),
    if (purgeSample.isNotDefault) 'purgeSample': purgeSample,
  };

  @override
  String toString() {
    final contents = ['purgeCount=$purgeCount'].join(',');
    return 'PurgeExecutionsResponse($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.PurgeExecutions`.
final class PurgeExecutionsMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeExecutionsMetadata';

  /// Operation metadata for purging Executions.
  final GenericOperationMetadata? genericMetadata;

  PurgeExecutionsMetadata({this.genericMetadata}) : super(fullyQualifiedName);

  factory PurgeExecutionsMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PurgeExecutionsMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'PurgeExecutionsMetadata()';
}

/// Request message for
/// `MetadataService.AddExecutionEvents`.
final class AddExecutionEventsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddExecutionEventsRequest';

  /// Required. The resource name of the Execution that the Events connect
  /// Artifacts with.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final String execution;

  /// The Events to create and add.
  final List<Event> events;

  AddExecutionEventsRequest({required this.execution, this.events = const []})
    : super(fullyQualifiedName);

  factory AddExecutionEventsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AddExecutionEventsRequest(
      execution: switch (json['execution']) {
        null => '',
        Object $1 => decodeString($1),
      },
      events: switch (json['events']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Event.fromJson(i)],
        _ => throw const FormatException('"events" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'execution': execution,
    if (events.isNotDefault) 'events': encodeList(events),
  };

  @override
  String toString() {
    final contents = ['execution=$execution'].join(',');
    return 'AddExecutionEventsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.AddExecutionEvents`.
final class AddExecutionEventsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddExecutionEventsResponse';

  AddExecutionEventsResponse() : super(fullyQualifiedName);

  factory AddExecutionEventsResponse.fromJson(Object? j) =>
      AddExecutionEventsResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'AddExecutionEventsResponse()';
}

/// Request message for
/// `MetadataService.QueryExecutionInputsAndOutputs`.
final class QueryExecutionInputsAndOutputsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryExecutionInputsAndOutputsRequest';

  /// Required. The resource name of the Execution whose input and output
  /// Artifacts should be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final String execution;

  QueryExecutionInputsAndOutputsRequest({required this.execution})
    : super(fullyQualifiedName);

  factory QueryExecutionInputsAndOutputsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryExecutionInputsAndOutputsRequest(
      execution: switch (json['execution']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'execution': execution};

  @override
  String toString() {
    final contents = ['execution=$execution'].join(',');
    return 'QueryExecutionInputsAndOutputsRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.CreateMetadataSchema`.
final class CreateMetadataSchemaRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMetadataSchemaRequest';

  /// Required. The resource name of the MetadataStore where the MetadataSchema
  /// should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. The MetadataSchema to create.
  final MetadataSchema? metadataSchema;

  /// The {metadata_schema} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all MetadataSchemas in the parent Location.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting MetadataSchema.)
  final String metadataSchemaId;

  CreateMetadataSchemaRequest({
    required this.parent,
    required this.metadataSchema,
    this.metadataSchemaId = '',
  }) : super(fullyQualifiedName);

  factory CreateMetadataSchemaRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateMetadataSchemaRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadataSchema: switch (json['metadataSchema']) {
        null => null,
        Object $1 => MetadataSchema.fromJson($1),
      },
      metadataSchemaId: switch (json['metadataSchemaId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (metadataSchema != null) 'metadataSchema': metadataSchema!.toJson(),
    if (metadataSchemaId.isNotDefault) 'metadataSchemaId': metadataSchemaId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'metadataSchemaId=$metadataSchemaId',
    ].join(',');
    return 'CreateMetadataSchemaRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.GetMetadataSchema`.
final class GetMetadataSchemaRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetMetadataSchemaRequest';

  /// Required. The resource name of the MetadataSchema to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  final String name;

  GetMetadataSchemaRequest({required this.name}) : super(fullyQualifiedName);

  factory GetMetadataSchemaRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetMetadataSchemaRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetMetadataSchemaRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListMetadataSchemas`.
final class ListMetadataSchemasRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMetadataSchemasRequest';

  /// Required. The MetadataStore whose MetadataSchemas should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// The maximum number of MetadataSchemas to return. The service may return
  /// fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListMetadataSchemas`
  /// call. Provide this to retrieve the next page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  final String pageToken;

  /// A query to filter available MetadataSchemas for matching results.
  final String filter;

  ListMetadataSchemasRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
  }) : super(fullyQualifiedName);

  factory ListMetadataSchemasRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListMetadataSchemasRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
    ].join(',');
    return 'ListMetadataSchemasRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListMetadataSchemas`.
final class ListMetadataSchemasResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMetadataSchemasResponse';

  /// The MetadataSchemas found for the MetadataStore.
  final List<MetadataSchema> metadataSchemas;

  /// A token, which can be sent as
  /// `ListMetadataSchemasRequest.page_token`
  /// to retrieve the next page. If this field is not populated, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListMetadataSchemasResponse({
    this.metadataSchemas = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListMetadataSchemasResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListMetadataSchemasResponse(
      metadataSchemas: switch (json['metadataSchemas']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) MetadataSchema.fromJson(i)],
        _ => throw const FormatException('"metadataSchemas" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metadataSchemas.isNotDefault)
      'metadataSchemas': encodeList(metadataSchemas),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListMetadataSchemasResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.QueryArtifactLineageSubgraph`.
final class QueryArtifactLineageSubgraphRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryArtifactLineageSubgraphRequest';

  /// Required. The resource name of the Artifact whose Lineage needs to be
  /// retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  ///
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  final String artifact;

  /// Specifies the size of the lineage graph in terms of number of hops from the
  /// specified artifact.
  /// Negative Value: INVALID_ARGUMENT error is returned
  /// 0: Only input artifact is returned.
  /// No value: Transitive closure is performed to return the complete graph.
  final int maxHops;

  /// Filter specifying the boolean condition for the Artifacts to satisfy in
  /// order to be part of the Lineage Subgraph.
  /// The syntax to define filter query is based on https://google.aip.dev/160.
  /// The supported set of filters include the following:
  ///
  /// *  **Attribute filtering**:
  ///    For example: `display_name = "test"`
  ///    Supported fields include: `name`, `display_name`, `uri`, `state`,
  ///    `schema_title`, `create_time`, and `update_time`.
  ///    Time fields, such as `create_time` and `update_time`, require values
  ///    specified in RFC-3339 format.
  ///    For example: `create_time = "2020-11-19T11:30:00-04:00"`
  /// *  **Metadata field**:
  ///    To filter on metadata fields use traversal operation as follows:
  ///    `metadata.<field_name>.<type_value>`.
  ///    For example: `metadata.field_1.number_value = 10.0`
  ///    In case the field name contains special characters (such as colon), one
  ///    can embed it inside double quote.
  ///    For example: `metadata."field:1".number_value = 10.0`
  ///
  /// Each of the above supported filter types can be combined together using
  /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
  /// is 5.
  ///
  /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
  final String filter;

  QueryArtifactLineageSubgraphRequest({
    required this.artifact,
    this.maxHops = 0,
    this.filter = '',
  }) : super(fullyQualifiedName);

  factory QueryArtifactLineageSubgraphRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryArtifactLineageSubgraphRequest(
      artifact: switch (json['artifact']) {
        null => '',
        Object $1 => decodeString($1),
      },
      maxHops: switch (json['maxHops']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'artifact': artifact,
    if (maxHops.isNotDefault) 'maxHops': maxHops,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = [
      'artifact=$artifact',
      'maxHops=$maxHops',
      'filter=$filter',
    ].join(',');
    return 'QueryArtifactLineageSubgraphRequest($contents)';
  }
}

/// Instance of a metadata store. Contains a set of metadata that can be
/// queried.
final class MetadataStore extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetadataStore';

  /// Output only. The resource name of the MetadataStore instance.
  final String name;

  /// Output only. Timestamp when this MetadataStore was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this MetadataStore was last updated.
  final protobuf.Timestamp? updateTime;

  /// Customer-managed encryption key spec for a Metadata Store. If set, this
  /// Metadata Store and all sub-resources of this Metadata Store are secured
  /// using this key.
  final EncryptionSpec? encryptionSpec;

  /// Description of the MetadataStore.
  final String description;

  /// Output only. State information of the MetadataStore.
  final MetadataStore_MetadataStoreState? state;

  /// Optional. Dataplex integration settings.
  final MetadataStore_DataplexConfig? dataplexConfig;

  MetadataStore({
    this.name = '',
    this.createTime,
    this.updateTime,
    this.encryptionSpec,
    this.description = '',
    this.state,
    this.dataplexConfig,
  }) : super(fullyQualifiedName);

  factory MetadataStore.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetadataStore(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => null,
        Object $1 => MetadataStore_MetadataStoreState.fromJson($1),
      },
      dataplexConfig: switch (json['dataplexConfig']) {
        null => null,
        Object $1 => MetadataStore_DataplexConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (description.isNotDefault) 'description': description,
    if (state != null) 'state': state!.toJson(),
    if (dataplexConfig != null) 'dataplexConfig': dataplexConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'description=$description'].join(',');
    return 'MetadataStore($contents)';
  }
}

/// Represents state information for a MetadataStore.
final class MetadataStore_MetadataStoreState extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetadataStore.MetadataStoreState';

  /// The disk utilization of the MetadataStore in bytes.
  final int diskUtilizationBytes;

  MetadataStore_MetadataStoreState({this.diskUtilizationBytes = 0})
    : super(fullyQualifiedName);

  factory MetadataStore_MetadataStoreState.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetadataStore_MetadataStoreState(
      diskUtilizationBytes: switch (json['diskUtilizationBytes']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (diskUtilizationBytes.isNotDefault)
      'diskUtilizationBytes': encodeInt64(diskUtilizationBytes),
  };

  @override
  String toString() {
    final contents = ['diskUtilizationBytes=$diskUtilizationBytes'].join(',');
    return 'MetadataStoreState($contents)';
  }
}

/// Represents Dataplex integration settings.
final class MetadataStore_DataplexConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetadataStore.DataplexConfig';

  /// Optional. Whether or not Data Lineage synchronization is enabled for
  /// Vertex Pipelines.
  final bool enabledPipelinesLineage;

  MetadataStore_DataplexConfig({this.enabledPipelinesLineage = false})
    : super(fullyQualifiedName);

  factory MetadataStore_DataplexConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetadataStore_DataplexConfig(
      enabledPipelinesLineage: switch (json['enabledPipelinesLineage']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enabledPipelinesLineage.isNotDefault)
      'enabledPipelinesLineage': enabledPipelinesLineage,
  };

  @override
  String toString() {
    final contents = [
      'enabledPipelinesLineage=$enabledPipelinesLineage',
    ].join(',');
    return 'DataplexConfig($contents)';
  }
}

/// Represents one resource that exists in automl.googleapis.com,
/// datalabeling.googleapis.com or ml.googleapis.com.
final class MigratableResource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource';

  /// Output only. Represents one Version in ml.googleapis.com.
  final MigratableResource_MlEngineModelVersion? mlEngineModelVersion;

  /// Output only. Represents one Model in automl.googleapis.com.
  final MigratableResource_AutomlModel? automlModel;

  /// Output only. Represents one Dataset in automl.googleapis.com.
  final MigratableResource_AutomlDataset? automlDataset;

  /// Output only. Represents one Dataset in datalabeling.googleapis.com.
  final MigratableResource_DataLabelingDataset? dataLabelingDataset;

  /// Output only. Timestamp when the last migration attempt on this
  /// MigratableResource started. Will not be set if there's no migration attempt
  /// on this MigratableResource.
  final protobuf.Timestamp? lastMigrateTime;

  /// Output only. Timestamp when this MigratableResource was last updated.
  final protobuf.Timestamp? lastUpdateTime;

  MigratableResource({
    this.mlEngineModelVersion,
    this.automlModel,
    this.automlDataset,
    this.dataLabelingDataset,
    this.lastMigrateTime,
    this.lastUpdateTime,
  }) : super(fullyQualifiedName);

  factory MigratableResource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MigratableResource(
      mlEngineModelVersion: switch (json['mlEngineModelVersion']) {
        null => null,
        Object $1 => MigratableResource_MlEngineModelVersion.fromJson($1),
      },
      automlModel: switch (json['automlModel']) {
        null => null,
        Object $1 => MigratableResource_AutomlModel.fromJson($1),
      },
      automlDataset: switch (json['automlDataset']) {
        null => null,
        Object $1 => MigratableResource_AutomlDataset.fromJson($1),
      },
      dataLabelingDataset: switch (json['dataLabelingDataset']) {
        null => null,
        Object $1 => MigratableResource_DataLabelingDataset.fromJson($1),
      },
      lastMigrateTime: switch (json['lastMigrateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      lastUpdateTime: switch (json['lastUpdateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (mlEngineModelVersion != null)
      'mlEngineModelVersion': mlEngineModelVersion!.toJson(),
    if (automlModel != null) 'automlModel': automlModel!.toJson(),
    if (automlDataset != null) 'automlDataset': automlDataset!.toJson(),
    if (dataLabelingDataset != null)
      'dataLabelingDataset': dataLabelingDataset!.toJson(),
    if (lastMigrateTime != null) 'lastMigrateTime': lastMigrateTime!.toJson(),
    if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!.toJson(),
  };

  @override
  String toString() => 'MigratableResource()';
}

/// Represents one model Version in ml.googleapis.com.
final class MigratableResource_MlEngineModelVersion extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.MlEngineModelVersion';

  /// The ml.googleapis.com endpoint that this model Version currently lives
  /// in.
  /// Example values:
  ///
  /// * ml.googleapis.com
  /// * us-centrall-ml.googleapis.com
  /// * europe-west4-ml.googleapis.com
  /// * asia-east1-ml.googleapis.com
  final String endpoint;

  /// Full resource name of ml engine model Version.
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  final String version;

  MigratableResource_MlEngineModelVersion({
    this.endpoint = '',
    this.version = '',
  }) : super(fullyQualifiedName);

  factory MigratableResource_MlEngineModelVersion.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MigratableResource_MlEngineModelVersion(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (endpoint.isNotDefault) 'endpoint': endpoint,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint', 'version=$version'].join(',');
    return 'MlEngineModelVersion($contents)';
  }
}

/// Represents one Model in automl.googleapis.com.
final class MigratableResource_AutomlModel extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.AutomlModel';

  /// Full resource name of automl Model.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}`.
  final String model;

  /// The Model's display name in automl.googleapis.com.
  final String modelDisplayName;

  MigratableResource_AutomlModel({this.model = '', this.modelDisplayName = ''})
    : super(fullyQualifiedName);

  factory MigratableResource_AutomlModel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MigratableResource_AutomlModel(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelDisplayName: switch (json['modelDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (model.isNotDefault) 'model': model,
    if (modelDisplayName.isNotDefault) 'modelDisplayName': modelDisplayName,
  };

  @override
  String toString() {
    final contents = [
      'model=$model',
      'modelDisplayName=$modelDisplayName',
    ].join(',');
    return 'AutomlModel($contents)';
  }
}

/// Represents one Dataset in automl.googleapis.com.
final class MigratableResource_AutomlDataset extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.AutomlDataset';

  /// Full resource name of automl Dataset.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`.
  final String dataset;

  /// The Dataset's display name in automl.googleapis.com.
  final String datasetDisplayName;

  MigratableResource_AutomlDataset({
    this.dataset = '',
    this.datasetDisplayName = '',
  }) : super(fullyQualifiedName);

  factory MigratableResource_AutomlDataset.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MigratableResource_AutomlDataset(
      dataset: switch (json['dataset']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datasetDisplayName: switch (json['datasetDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataset.isNotDefault) 'dataset': dataset,
    if (datasetDisplayName.isNotDefault)
      'datasetDisplayName': datasetDisplayName,
  };

  @override
  String toString() {
    final contents = [
      'dataset=$dataset',
      'datasetDisplayName=$datasetDisplayName',
    ].join(',');
    return 'AutomlDataset($contents)';
  }
}

/// Represents one Dataset in datalabeling.googleapis.com.
final class MigratableResource_DataLabelingDataset extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.DataLabelingDataset';

  /// Full resource name of data labeling Dataset.
  /// Format:
  /// `projects/{project}/datasets/{dataset}`.
  final String dataset;

  /// The Dataset's display name in datalabeling.googleapis.com.
  final String datasetDisplayName;

  /// The migratable AnnotatedDataset in datalabeling.googleapis.com belongs to
  /// the data labeling Dataset.
  final List<
    MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset
  >
  dataLabelingAnnotatedDatasets;

  MigratableResource_DataLabelingDataset({
    this.dataset = '',
    this.datasetDisplayName = '',
    this.dataLabelingAnnotatedDatasets = const [],
  }) : super(fullyQualifiedName);

  factory MigratableResource_DataLabelingDataset.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MigratableResource_DataLabelingDataset(
      dataset: switch (json['dataset']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datasetDisplayName: switch (json['datasetDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataLabelingAnnotatedDatasets:
          switch (json['dataLabelingAnnotatedDatasets']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1)
                MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset.fromJson(
                  i,
                ),
            ],
            _ => throw const FormatException(
              '"dataLabelingAnnotatedDatasets" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (dataset.isNotDefault) 'dataset': dataset,
    if (datasetDisplayName.isNotDefault)
      'datasetDisplayName': datasetDisplayName,
    if (dataLabelingAnnotatedDatasets.isNotDefault)
      'dataLabelingAnnotatedDatasets': encodeList(
        dataLabelingAnnotatedDatasets,
      ),
  };

  @override
  String toString() {
    final contents = [
      'dataset=$dataset',
      'datasetDisplayName=$datasetDisplayName',
    ].join(',');
    return 'DataLabelingDataset($contents)';
  }
}

/// Represents one AnnotatedDataset in datalabeling.googleapis.com.
final class MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.DataLabelingDataset.DataLabelingAnnotatedDataset';

  /// Full resource name of data labeling AnnotatedDataset.
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  final String annotatedDataset;

  /// The AnnotatedDataset's display name in datalabeling.googleapis.com.
  final String annotatedDatasetDisplayName;

  MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset({
    this.annotatedDataset = '',
    this.annotatedDatasetDisplayName = '',
  }) : super(fullyQualifiedName);

  factory MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset(
      annotatedDataset: switch (json['annotatedDataset']) {
        null => '',
        Object $1 => decodeString($1),
      },
      annotatedDatasetDisplayName:
          switch (json['annotatedDatasetDisplayName']) {
            null => '',
            Object $1 => decodeString($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (annotatedDataset.isNotDefault) 'annotatedDataset': annotatedDataset,
    if (annotatedDatasetDisplayName.isNotDefault)
      'annotatedDatasetDisplayName': annotatedDatasetDisplayName,
  };

  @override
  String toString() {
    final contents = [
      'annotatedDataset=$annotatedDataset',
      'annotatedDatasetDisplayName=$annotatedDatasetDisplayName',
    ].join(',');
    return 'DataLabelingAnnotatedDataset($contents)';
  }
}

/// Request message for
/// `MigrationService.SearchMigratableResources`.
final class SearchMigratableResourcesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchMigratableResourcesRequest';

  /// Required. The location that the migratable resources should be searched
  /// from. It's the Vertex AI location that the resources can be migrated to,
  /// not the resources' original location. Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// The standard page size.
  /// The default and maximum value is 100.
  final int pageSize;

  /// The standard page token.
  final String pageToken;

  /// A filter for your search. You can use the following types of filters:
  ///
  /// *   Resource type filters. The following strings filter for a specific type
  ///     of
  ///     `MigratableResource`:
  ///     *   `ml_engine_model_version:*`
  ///     *   `automl_model:*`
  ///     *   `automl_dataset:*`
  ///     *   `data_labeling_dataset:*`
  /// *   "Migrated or not" filters. The following strings filter for resources
  ///     that either have or have not already been migrated:
  ///     *   `last_migrate_time:*` filters for migrated resources.
  ///     *   `NOT last_migrate_time:*` filters for not yet migrated resources.
  final String filter;

  SearchMigratableResourcesRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
  }) : super(fullyQualifiedName);

  factory SearchMigratableResourcesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchMigratableResourcesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
    ].join(',');
    return 'SearchMigratableResourcesRequest($contents)';
  }
}

/// Response message for
/// `MigrationService.SearchMigratableResources`.
final class SearchMigratableResourcesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchMigratableResourcesResponse';

  /// All migratable resources that can be migrated to the
  /// location specified in the request.
  final List<MigratableResource> migratableResources;

  /// The standard next-page token.
  /// The migratable_resources may not fill page_size in
  /// SearchMigratableResourcesRequest even when there are subsequent pages.
  final String nextPageToken;

  SearchMigratableResourcesResponse({
    this.migratableResources = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchMigratableResourcesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchMigratableResourcesResponse(
      migratableResources: switch (json['migratableResources']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) MigratableResource.fromJson(i),
        ],
        _ => throw const FormatException('"migratableResources" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (migratableResources.isNotDefault)
      'migratableResources': encodeList(migratableResources),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'SearchMigratableResourcesResponse($contents)';
  }
}

/// Request message for
/// `MigrationService.BatchMigrateResources`.
final class BatchMigrateResourcesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchMigrateResourcesRequest';

  /// Required. The location of the migrated resource will live in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The request messages specifying the resources to migrate.
  /// They must be in the same location as the destination.
  /// Up to 50 resources can be migrated in one batch.
  final List<MigrateResourceRequest> migrateResourceRequests;

  BatchMigrateResourcesRequest({
    required this.parent,
    required this.migrateResourceRequests,
  }) : super(fullyQualifiedName);

  factory BatchMigrateResourcesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchMigrateResourcesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      migrateResourceRequests: switch (json['migrateResourceRequests']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) MigrateResourceRequest.fromJson(i),
        ],
        _ => throw const FormatException(
          '"migrateResourceRequests" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'migrateResourceRequests': encodeList(migrateResourceRequests),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchMigrateResourcesRequest($contents)';
  }
}

/// Config of migrating one resource from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
final class MigrateResourceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest';

  /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
  final MigrateResourceRequest_MigrateMlEngineModelVersionConfig?
  migrateMlEngineModelVersionConfig;

  /// Config for migrating Model in automl.googleapis.com to Vertex AI's
  /// Model.
  final MigrateResourceRequest_MigrateAutomlModelConfig?
  migrateAutomlModelConfig;

  /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
  /// Dataset.
  final MigrateResourceRequest_MigrateAutomlDatasetConfig?
  migrateAutomlDatasetConfig;

  /// Config for migrating Dataset in datalabeling.googleapis.com to
  /// Vertex AI's Dataset.
  final MigrateResourceRequest_MigrateDataLabelingDatasetConfig?
  migrateDataLabelingDatasetConfig;

  MigrateResourceRequest({
    this.migrateMlEngineModelVersionConfig,
    this.migrateAutomlModelConfig,
    this.migrateAutomlDatasetConfig,
    this.migrateDataLabelingDatasetConfig,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MigrateResourceRequest(
      migrateMlEngineModelVersionConfig:
          switch (json['migrateMlEngineModelVersionConfig']) {
            null => null,
            Object $1 =>
              MigrateResourceRequest_MigrateMlEngineModelVersionConfig.fromJson(
                $1,
              ),
          },
      migrateAutomlModelConfig: switch (json['migrateAutomlModelConfig']) {
        null => null,
        Object $1 => MigrateResourceRequest_MigrateAutomlModelConfig.fromJson(
          $1,
        ),
      },
      migrateAutomlDatasetConfig: switch (json['migrateAutomlDatasetConfig']) {
        null => null,
        Object $1 => MigrateResourceRequest_MigrateAutomlDatasetConfig.fromJson(
          $1,
        ),
      },
      migrateDataLabelingDatasetConfig:
          switch (json['migrateDataLabelingDatasetConfig']) {
            null => null,
            Object $1 =>
              MigrateResourceRequest_MigrateDataLabelingDatasetConfig.fromJson(
                $1,
              ),
          },
    );
  }

  @override
  Object toJson() => {
    if (migrateMlEngineModelVersionConfig != null)
      'migrateMlEngineModelVersionConfig': migrateMlEngineModelVersionConfig!
          .toJson(),
    if (migrateAutomlModelConfig != null)
      'migrateAutomlModelConfig': migrateAutomlModelConfig!.toJson(),
    if (migrateAutomlDatasetConfig != null)
      'migrateAutomlDatasetConfig': migrateAutomlDatasetConfig!.toJson(),
    if (migrateDataLabelingDatasetConfig != null)
      'migrateDataLabelingDatasetConfig': migrateDataLabelingDatasetConfig!
          .toJson(),
  };

  @override
  String toString() => 'MigrateResourceRequest()';
}

/// Config for migrating version in ml.googleapis.com to Vertex AI's Model.
final class MigrateResourceRequest_MigrateMlEngineModelVersionConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateMlEngineModelVersionConfig';

  /// Required. The ml.googleapis.com endpoint that this model version should
  /// be migrated from. Example values:
  ///
  /// * ml.googleapis.com
  ///
  /// * us-centrall-ml.googleapis.com
  ///
  /// * europe-west4-ml.googleapis.com
  ///
  /// * asia-east1-ml.googleapis.com
  final String endpoint;

  /// Required. Full resource name of ml engine model version.
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  final String modelVersion;

  /// Required. Display name of the model in Vertex AI.
  /// System will pick a display name if unspecified.
  final String modelDisplayName;

  MigrateResourceRequest_MigrateMlEngineModelVersionConfig({
    required this.endpoint,
    required this.modelVersion,
    required this.modelDisplayName,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateMlEngineModelVersionConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return MigrateResourceRequest_MigrateMlEngineModelVersionConfig(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersion: switch (json['modelVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelDisplayName: switch (json['modelDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    'modelVersion': modelVersion,
    'modelDisplayName': modelDisplayName,
  };

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      'modelVersion=$modelVersion',
      'modelDisplayName=$modelDisplayName',
    ].join(',');
    return 'MigrateMlEngineModelVersionConfig($contents)';
  }
}

/// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
final class MigrateResourceRequest_MigrateAutomlModelConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateAutomlModelConfig';

  /// Required. Full resource name of automl Model.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}`.
  final String model;

  /// Optional. Display name of the model in Vertex AI.
  /// System will pick a display name if unspecified.
  final String modelDisplayName;

  MigrateResourceRequest_MigrateAutomlModelConfig({
    required this.model,
    this.modelDisplayName = '',
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateAutomlModelConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MigrateResourceRequest_MigrateAutomlModelConfig(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelDisplayName: switch (json['modelDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'model': model,
    if (modelDisplayName.isNotDefault) 'modelDisplayName': modelDisplayName,
  };

  @override
  String toString() {
    final contents = [
      'model=$model',
      'modelDisplayName=$modelDisplayName',
    ].join(',');
    return 'MigrateAutomlModelConfig($contents)';
  }
}

/// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
/// Dataset.
final class MigrateResourceRequest_MigrateAutomlDatasetConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateAutomlDatasetConfig';

  /// Required. Full resource name of automl Dataset.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`.
  final String dataset;

  /// Required. Display name of the Dataset in Vertex AI.
  /// System will pick a display name if unspecified.
  final String datasetDisplayName;

  MigrateResourceRequest_MigrateAutomlDatasetConfig({
    required this.dataset,
    required this.datasetDisplayName,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateAutomlDatasetConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return MigrateResourceRequest_MigrateAutomlDatasetConfig(
      dataset: switch (json['dataset']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datasetDisplayName: switch (json['datasetDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'dataset': dataset,
    'datasetDisplayName': datasetDisplayName,
  };

  @override
  String toString() {
    final contents = [
      'dataset=$dataset',
      'datasetDisplayName=$datasetDisplayName',
    ].join(',');
    return 'MigrateAutomlDatasetConfig($contents)';
  }
}

/// Config for migrating Dataset in datalabeling.googleapis.com to Vertex
/// AI's Dataset.
final class MigrateResourceRequest_MigrateDataLabelingDatasetConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig';

  /// Required. Full resource name of data labeling Dataset.
  /// Format:
  /// `projects/{project}/datasets/{dataset}`.
  final String dataset;

  /// Optional. Display name of the Dataset in Vertex AI.
  /// System will pick a display name if unspecified.
  final String datasetDisplayName;

  /// Optional. Configs for migrating AnnotatedDataset in
  /// datalabeling.googleapis.com to Vertex AI's SavedQuery. The specified
  /// AnnotatedDatasets have to belong to the datalabeling Dataset.
  final List<
    MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig
  >
  migrateDataLabelingAnnotatedDatasetConfigs;

  MigrateResourceRequest_MigrateDataLabelingDatasetConfig({
    required this.dataset,
    this.datasetDisplayName = '',
    this.migrateDataLabelingAnnotatedDatasetConfigs = const [],
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateDataLabelingDatasetConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return MigrateResourceRequest_MigrateDataLabelingDatasetConfig(
      dataset: switch (json['dataset']) {
        null => '',
        Object $1 => decodeString($1),
      },
      datasetDisplayName: switch (json['datasetDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      migrateDataLabelingAnnotatedDatasetConfigs:
          switch (json['migrateDataLabelingAnnotatedDatasetConfigs']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1)
                MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig.fromJson(
                  i,
                ),
            ],
            _ => throw const FormatException(
              '"migrateDataLabelingAnnotatedDatasetConfigs" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    'dataset': dataset,
    if (datasetDisplayName.isNotDefault)
      'datasetDisplayName': datasetDisplayName,
    if (migrateDataLabelingAnnotatedDatasetConfigs.isNotDefault)
      'migrateDataLabelingAnnotatedDatasetConfigs': encodeList(
        migrateDataLabelingAnnotatedDatasetConfigs,
      ),
  };

  @override
  String toString() {
    final contents = [
      'dataset=$dataset',
      'datasetDisplayName=$datasetDisplayName',
    ].join(',');
    return 'MigrateDataLabelingDatasetConfig($contents)';
  }
}

/// Config for migrating AnnotatedDataset in datalabeling.googleapis.com to
/// Vertex AI's SavedQuery.
final class MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig';

  /// Required. Full resource name of data labeling AnnotatedDataset.
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  final String annotatedDataset;

  MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig({
    required this.annotatedDataset,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig(
      annotatedDataset: switch (json['annotatedDataset']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'annotatedDataset': annotatedDataset};

  @override
  String toString() {
    final contents = ['annotatedDataset=$annotatedDataset'].join(',');
    return 'MigrateDataLabelingAnnotatedDatasetConfig($contents)';
  }
}

/// Response message for
/// `MigrationService.BatchMigrateResources`.
final class BatchMigrateResourcesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchMigrateResourcesResponse';

  /// Successfully migrated resources.
  final List<MigrateResourceResponse> migrateResourceResponses;

  BatchMigrateResourcesResponse({this.migrateResourceResponses = const []})
    : super(fullyQualifiedName);

  factory BatchMigrateResourcesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchMigrateResourcesResponse(
      migrateResourceResponses: switch (json['migrateResourceResponses']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) MigrateResourceResponse.fromJson(i),
        ],
        _ => throw const FormatException(
          '"migrateResourceResponses" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (migrateResourceResponses.isNotDefault)
      'migrateResourceResponses': encodeList(migrateResourceResponses),
  };

  @override
  String toString() => 'BatchMigrateResourcesResponse()';
}

/// Describes a successfully migrated resource.
final class MigrateResourceResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceResponse';

  /// Migrated Dataset's resource name.
  final String? dataset;

  /// Migrated Model's resource name.
  final String? model;

  /// Before migration, the identifier in ml.googleapis.com,
  /// automl.googleapis.com or datalabeling.googleapis.com.
  final MigratableResource? migratableResource;

  MigrateResourceResponse({this.dataset, this.model, this.migratableResource})
    : super(fullyQualifiedName);

  factory MigrateResourceResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MigrateResourceResponse(
      dataset: switch (json['dataset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => null,
        Object $1 => decodeString($1),
      },
      migratableResource: switch (json['migratableResource']) {
        null => null,
        Object $1 => MigratableResource.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataset != null) 'dataset': dataset,
    if (model != null) 'model': model,
    if (migratableResource != null)
      'migratableResource': migratableResource!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (dataset != null) 'dataset=$dataset',
      if (model != null) 'model=$model',
    ].join(',');
    return 'MigrateResourceResponse($contents)';
  }
}

/// Runtime operation information for
/// `MigrationService.BatchMigrateResources`.
final class BatchMigrateResourcesOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchMigrateResourcesOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  /// Partial results that reflect the latest migration operation progress.
  final List<BatchMigrateResourcesOperationMetadata_PartialResult>
  partialResults;

  BatchMigrateResourcesOperationMetadata({
    this.genericMetadata,
    this.partialResults = const [],
  }) : super(fullyQualifiedName);

  factory BatchMigrateResourcesOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchMigrateResourcesOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      partialResults: switch (json['partialResults']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            BatchMigrateResourcesOperationMetadata_PartialResult.fromJson(i),
        ],
        _ => throw const FormatException('"partialResults" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (partialResults.isNotDefault)
      'partialResults': encodeList(partialResults),
  };

  @override
  String toString() => 'BatchMigrateResourcesOperationMetadata()';
}

/// Represents a partial result in batch migration operation for one
/// `MigrateResourceRequest`.
final class BatchMigrateResourcesOperationMetadata_PartialResult
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchMigrateResourcesOperationMetadata.PartialResult';

  /// The error result of the migration request in case of failure.
  final Status? error;

  /// Migrated model resource name.
  final String? model;

  /// Migrated dataset resource name.
  final String? dataset;

  /// It's the same as the value in
  /// `MigrateResourceRequest.migrate_resource_requests`.
  final MigrateResourceRequest? request;

  BatchMigrateResourcesOperationMetadata_PartialResult({
    this.error,
    this.model,
    this.dataset,
    this.request,
  }) : super(fullyQualifiedName);

  factory BatchMigrateResourcesOperationMetadata_PartialResult.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return BatchMigrateResourcesOperationMetadata_PartialResult(
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      model: switch (json['model']) {
        null => null,
        Object $1 => decodeString($1),
      },
      dataset: switch (json['dataset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      request: switch (json['request']) {
        null => null,
        Object $1 => MigrateResourceRequest.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (error != null) 'error': error!.toJson(),
    if (model != null) 'model': model,
    if (dataset != null) 'dataset': dataset,
    if (request != null) 'request': request!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (dataset != null) 'dataset=$dataset',
    ].join(',');
    return 'PartialResult($contents)';
  }
}

/// A trained machine learning Model.
final class Model extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Model';

  /// The resource name of the Model.
  final String name;

  /// Output only. Immutable. The version ID of the model.
  /// A new version is committed when a new model version is uploaded or
  /// trained under an existing model id. It is an auto-incrementing decimal
  /// number in string representation.
  final String versionId;

  /// User provided version aliases so that a model version can be referenced via
  /// alias (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_alias}`
  /// instead of auto-generated version id (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id})`.
  /// The format is [a-z][a-zA-Z0-9-]{0,126}[a-z0-9] to distinguish from
  /// version_id. A default version alias will be created for the first version
  /// of the model, and there must be exactly one default version alias for a
  /// model.
  final List<String> versionAliases;

  /// Output only. Timestamp when this version was created.
  final protobuf.Timestamp? versionCreateTime;

  /// Output only. Timestamp when this version was most recently updated.
  final protobuf.Timestamp? versionUpdateTime;

  /// Required. The display name of the Model.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// The description of the Model.
  final String description;

  /// The description of this version.
  final String versionDescription;

  /// The default checkpoint id of a model version.
  final String defaultCheckpointId;

  /// The schemata that describe formats of the Model's predictions and
  /// explanations as given and returned via
  /// `PredictionService.Predict`
  /// and
  /// `PredictionService.Explain`.
  final PredictSchemata? predictSchemata;

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// additional information about the Model, that is specific to it. Unset if
  /// the Model does not have any additional information. The schema is defined
  /// as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// additional metadata is needed, this field is set to an empty string.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String metadataSchemaUri;

  /// Immutable. An additional information about the Model; the schema of the
  /// metadata can be found in
  /// `metadata_schema`.
  /// Unset if the Model does not have any additional information.
  final protobuf.Value? metadata;

  /// Output only. The formats in which this Model may be exported. If empty,
  /// this Model is not available for export.
  final List<Model_ExportFormat> supportedExportFormats;

  /// Output only. The resource name of the TrainingPipeline that uploaded this
  /// Model, if any.
  final String trainingPipeline;

  /// Input only. The specification of the container that is to be used when
  /// deploying this Model. The specification is ingested upon
  /// `ModelService.UploadModel`,
  /// and all binaries it contains are copied and stored internally by Vertex AI.
  /// Not required for AutoML Models.
  final ModelContainerSpec? containerSpec;

  /// Immutable. The path to the directory containing the Model artifact and any
  /// of its supporting files. Not required for AutoML Models.
  final String artifactUri;

  /// Output only. When this Model is deployed, its prediction resources are
  /// described by the `prediction_resources` field of the
  /// `Endpoint.deployed_models`
  /// object. Because not all Models support all resource configuration types,
  /// the configuration types this Model supports are listed here. If no
  /// configuration types are listed, the Model cannot be deployed to an
  /// `Endpoint` and does not support
  /// online predictions
  /// (`PredictionService.Predict`
  /// or
  /// `PredictionService.Explain`).
  /// Such a Model can serve predictions by using a
  /// `BatchPredictionJob`,
  /// if it has at least one entry each in
  /// `supported_input_storage_formats`
  /// and
  /// `supported_output_storage_formats`.
  final List<Model_DeploymentResourcesType> supportedDeploymentResourcesTypes;

  /// Output only. The formats this Model supports in
  /// `BatchPredictionJob.input_config`.
  /// If
  /// `PredictSchemata.instance_schema_uri`
  /// exists, the instances should be given as per that schema.
  ///
  /// The possible formats are:
  ///
  /// * `jsonl`
  /// The JSON Lines format, where each instance is a single line. Uses
  /// `GcsSource`.
  ///
  /// * `csv`
  /// The CSV format, where each instance is a single comma-separated line.
  /// The first line in the file is the header, containing comma-separated field
  /// names. Uses
  /// `GcsSource`.
  ///
  /// * `tf-record`
  /// The TFRecord format, where each instance is a single record in tfrecord
  /// syntax. Uses
  /// `GcsSource`.
  ///
  /// * `tf-record-gzip`
  /// Similar to `tf-record`, but the file is gzipped. Uses
  /// `GcsSource`.
  ///
  /// * `bigquery`
  /// Each instance is a single row in BigQuery. Uses
  /// `BigQuerySource`.
  ///
  /// * `file-list`
  /// Each line of the file is the location of an instance to process, uses
  /// `gcs_source` field of the
  /// `InputConfig`
  /// object.
  ///
  ///
  /// If this Model doesn't support any of these formats it means it cannot be
  /// used with a
  /// `BatchPredictionJob`.
  /// However, if it has
  /// `supported_deployment_resources_types`,
  /// it could serve online predictions by using
  /// `PredictionService.Predict`
  /// or
  /// `PredictionService.Explain`.
  final List<String> supportedInputStorageFormats;

  /// Output only. The formats this Model supports in
  /// `BatchPredictionJob.output_config`.
  /// If both
  /// `PredictSchemata.instance_schema_uri`
  /// and
  /// `PredictSchemata.prediction_schema_uri`
  /// exist, the predictions are returned together with their instances. In other
  /// words, the prediction has the original instance data first, followed by the
  /// actual prediction content (as per the schema).
  ///
  /// The possible formats are:
  ///
  /// * `jsonl`
  /// The JSON Lines format, where each prediction is a single line. Uses
  /// `GcsDestination`.
  ///
  /// * `csv`
  /// The CSV format, where each prediction is a single comma-separated line.
  /// The first line in the file is the header, containing comma-separated field
  /// names. Uses
  /// `GcsDestination`.
  ///
  /// * `bigquery`
  /// Each prediction is a single row in a BigQuery table, uses
  /// `BigQueryDestination`
  /// .
  ///
  ///
  /// If this Model doesn't support any of these formats it means it cannot be
  /// used with a
  /// `BatchPredictionJob`.
  /// However, if it has
  /// `supported_deployment_resources_types`,
  /// it could serve online predictions by using
  /// `PredictionService.Predict`
  /// or
  /// `PredictionService.Explain`.
  final List<String> supportedOutputStorageFormats;

  /// Output only. Timestamp when this Model was uploaded into Vertex AI.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Model was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. The pointers to DeployedModels created from this Model. Note
  /// that Model could have been deployed to Endpoints in different Locations.
  final List<DeployedModelRef> deployedModels;

  /// The default explanation specification for this Model.
  ///
  /// The Model can be used for
  /// [requesting
  /// explanation][google.cloud.aiplatform.v1beta1.PredictionService.Explain]
  /// after being
  /// `deployed` if
  /// it is populated. The Model can be used for [batch
  /// explanation][google.cloud.aiplatform.v1beta1.BatchPredictionJob.generate_explanation]
  /// if it is populated.
  ///
  /// All fields of the explanation_spec can be overridden by
  /// `explanation_spec`
  /// of
  /// `DeployModelRequest.deployed_model`,
  /// or
  /// `explanation_spec`
  /// of
  /// `BatchPredictionJob`.
  ///
  /// If the default explanation specification is not set for this Model, this
  /// Model can still be used for
  /// [requesting
  /// explanation][google.cloud.aiplatform.v1beta1.PredictionService.Explain] by
  /// setting
  /// `explanation_spec`
  /// of
  /// `DeployModelRequest.deployed_model`
  /// and for [batch
  /// explanation][google.cloud.aiplatform.v1beta1.BatchPredictionJob.generate_explanation]
  /// by setting
  /// `explanation_spec`
  /// of
  /// `BatchPredictionJob`.
  final ExplanationSpec? explanationSpec;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize your Models.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Customer-managed encryption key spec for a Model. If set, this
  /// Model and all sub-resources of this Model will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Source of a model. It can either be automl training pipeline,
  /// custom training pipeline, BigQuery ML, or saved and tuned from Genie or
  /// Model Garden.
  final ModelSourceInfo? modelSourceInfo;

  /// Output only. If this Model is a copy of another Model, this contains info
  /// about the original.
  final Model_OriginalModelInfo? originalModelInfo;

  /// Output only. The resource name of the Artifact that was created in
  /// MetadataStore when creating the Model. The Artifact resource name pattern
  /// is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  final String metadataArtifact;

  /// Optional. User input field to specify the base model source. Currently it
  /// only supports specifing the Model Garden models and Genie models.
  final Model_BaseModelSource? baseModelSource;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  /// Optional. Output only. The checkpoints of the model.
  final List<Checkpoint> checkpoints;

  Model({
    this.name = '',
    this.versionId = '',
    this.versionAliases = const [],
    this.versionCreateTime,
    this.versionUpdateTime,
    required this.displayName,
    this.description = '',
    this.versionDescription = '',
    this.defaultCheckpointId = '',
    this.predictSchemata,
    this.metadataSchemaUri = '',
    this.metadata,
    this.supportedExportFormats = const [],
    this.trainingPipeline = '',
    this.containerSpec,
    this.artifactUri = '',
    this.supportedDeploymentResourcesTypes = const [],
    this.supportedInputStorageFormats = const [],
    this.supportedOutputStorageFormats = const [],
    this.createTime,
    this.updateTime,
    this.deployedModels = const [],
    this.explanationSpec,
    this.etag = '',
    this.labels = const {},
    this.encryptionSpec,
    this.modelSourceInfo,
    this.originalModelInfo,
    this.metadataArtifact = '',
    this.baseModelSource,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
    this.checkpoints = const [],
  }) : super(fullyQualifiedName);

  factory Model.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Model(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      versionId: switch (json['versionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      versionAliases: switch (json['versionAliases']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"versionAliases" is not a list'),
      },
      versionCreateTime: switch (json['versionCreateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      versionUpdateTime: switch (json['versionUpdateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      versionDescription: switch (json['versionDescription']) {
        null => '',
        Object $1 => decodeString($1),
      },
      defaultCheckpointId: switch (json['defaultCheckpointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      predictSchemata: switch (json['predictSchemata']) {
        null => null,
        Object $1 => PredictSchemata.fromJson($1),
      },
      metadataSchemaUri: switch (json['metadataSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      supportedExportFormats: switch (json['supportedExportFormats']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Model_ExportFormat.fromJson(i),
        ],
        _ => throw const FormatException(
          '"supportedExportFormats" is not a list',
        ),
      },
      trainingPipeline: switch (json['trainingPipeline']) {
        null => '',
        Object $1 => decodeString($1),
      },
      containerSpec: switch (json['containerSpec']) {
        null => null,
        Object $1 => ModelContainerSpec.fromJson($1),
      },
      artifactUri: switch (json['artifactUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      supportedDeploymentResourcesTypes:
          switch (json['supportedDeploymentResourcesTypes']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1) Model_DeploymentResourcesType.fromJson(i),
            ],
            _ => throw const FormatException(
              '"supportedDeploymentResourcesTypes" is not a list',
            ),
          },
      supportedInputStorageFormats:
          switch (json['supportedInputStorageFormats']) {
            null => [],
            List<Object?> $1 => [for (final i in $1) decodeString(i)],
            _ => throw const FormatException(
              '"supportedInputStorageFormats" is not a list',
            ),
          },
      supportedOutputStorageFormats:
          switch (json['supportedOutputStorageFormats']) {
            null => [],
            List<Object?> $1 => [for (final i in $1) decodeString(i)],
            _ => throw const FormatException(
              '"supportedOutputStorageFormats" is not a list',
            ),
          },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      deployedModels: switch (json['deployedModels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DeployedModelRef.fromJson(i)],
        _ => throw const FormatException('"deployedModels" is not a list'),
      },
      explanationSpec: switch (json['explanationSpec']) {
        null => null,
        Object $1 => ExplanationSpec.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      modelSourceInfo: switch (json['modelSourceInfo']) {
        null => null,
        Object $1 => ModelSourceInfo.fromJson($1),
      },
      originalModelInfo: switch (json['originalModelInfo']) {
        null => null,
        Object $1 => Model_OriginalModelInfo.fromJson($1),
      },
      metadataArtifact: switch (json['metadataArtifact']) {
        null => '',
        Object $1 => decodeString($1),
      },
      baseModelSource: switch (json['baseModelSource']) {
        null => null,
        Object $1 => Model_BaseModelSource.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      checkpoints: switch (json['checkpoints']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Checkpoint.fromJson(i)],
        _ => throw const FormatException('"checkpoints" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (versionId.isNotDefault) 'versionId': versionId,
    if (versionAliases.isNotDefault) 'versionAliases': versionAliases,
    if (versionCreateTime != null)
      'versionCreateTime': versionCreateTime!.toJson(),
    if (versionUpdateTime != null)
      'versionUpdateTime': versionUpdateTime!.toJson(),
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (versionDescription.isNotDefault)
      'versionDescription': versionDescription,
    if (defaultCheckpointId.isNotDefault)
      'defaultCheckpointId': defaultCheckpointId,
    if (predictSchemata != null) 'predictSchemata': predictSchemata!.toJson(),
    if (metadataSchemaUri.isNotDefault) 'metadataSchemaUri': metadataSchemaUri,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (supportedExportFormats.isNotDefault)
      'supportedExportFormats': encodeList(supportedExportFormats),
    if (trainingPipeline.isNotDefault) 'trainingPipeline': trainingPipeline,
    if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
    if (artifactUri.isNotDefault) 'artifactUri': artifactUri,
    if (supportedDeploymentResourcesTypes.isNotDefault)
      'supportedDeploymentResourcesTypes': encodeList(
        supportedDeploymentResourcesTypes,
      ),
    if (supportedInputStorageFormats.isNotDefault)
      'supportedInputStorageFormats': supportedInputStorageFormats,
    if (supportedOutputStorageFormats.isNotDefault)
      'supportedOutputStorageFormats': supportedOutputStorageFormats,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (deployedModels.isNotDefault)
      'deployedModels': encodeList(deployedModels),
    if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (modelSourceInfo != null) 'modelSourceInfo': modelSourceInfo!.toJson(),
    if (originalModelInfo != null)
      'originalModelInfo': originalModelInfo!.toJson(),
    if (metadataArtifact.isNotDefault) 'metadataArtifact': metadataArtifact,
    if (baseModelSource != null) 'baseModelSource': baseModelSource!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
    if (checkpoints.isNotDefault) 'checkpoints': encodeList(checkpoints),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'versionId=$versionId',
      'displayName=$displayName',
      'description=$description',
      'versionDescription=$versionDescription',
      'defaultCheckpointId=$defaultCheckpointId',
      'metadataSchemaUri=$metadataSchemaUri',
      'trainingPipeline=$trainingPipeline',
      'artifactUri=$artifactUri',
      'etag=$etag',
      'metadataArtifact=$metadataArtifact',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Model($contents)';
  }
}

/// Represents export format supported by the Model.
/// All formats export to Google Cloud Storage.
final class Model_ExportFormat extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Model.ExportFormat';

  /// Output only. The ID of the export format.
  /// The possible format IDs are:
  ///
  /// * `tflite`
  /// Used for Android mobile devices.
  ///
  /// * `edgetpu-tflite`
  /// Used for [Edge TPU](https://cloud.google.com/edge-tpu/) devices.
  ///
  /// * `tf-saved-model`
  /// A tensorflow model in SavedModel format.
  ///
  /// * `tf-js`
  /// A [TensorFlow.js](https://www.tensorflow.org/js) model that can be used
  /// in the browser and in Node.js using JavaScript.
  ///
  /// * `core-ml`
  /// Used for iOS mobile devices.
  ///
  /// * `custom-trained`
  /// A Model that was uploaded or trained by custom code.
  final String id;

  /// Output only. The content of this Model that may be exported.
  final List<Model_ExportFormat_ExportableContent> exportableContents;

  Model_ExportFormat({this.id = '', this.exportableContents = const []})
    : super(fullyQualifiedName);

  factory Model_ExportFormat.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Model_ExportFormat(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      exportableContents: switch (json['exportableContents']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Model_ExportFormat_ExportableContent.fromJson(i),
        ],
        _ => throw const FormatException('"exportableContents" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    if (exportableContents.isNotDefault)
      'exportableContents': encodeList(exportableContents),
  };

  @override
  String toString() {
    final contents = ['id=$id'].join(',');
    return 'ExportFormat($contents)';
  }
}

/// The Model content that can be exported.
final class Model_ExportFormat_ExportableContent extends ProtoEnum {
  /// Should not be used.
  static const exportableContentUnspecified =
      Model_ExportFormat_ExportableContent('EXPORTABLE_CONTENT_UNSPECIFIED');

  /// Model artifact and any of its supported files. Will be exported to the
  /// location specified by the `artifactDestination` field of the
  /// `ExportModelRequest.output_config`
  /// object.
  static const artifact = Model_ExportFormat_ExportableContent('ARTIFACT');

  /// The container image that is to be used when deploying this Model. Will
  /// be exported to the location specified by the `imageDestination` field
  /// of the
  /// `ExportModelRequest.output_config`
  /// object.
  static const image = Model_ExportFormat_ExportableContent('IMAGE');

  /// The default value for [Model_ExportFormat_ExportableContent].
  static const $default = exportableContentUnspecified;

  const Model_ExportFormat_ExportableContent(super.value);

  factory Model_ExportFormat_ExportableContent.fromJson(Object? json) =>
      Model_ExportFormat_ExportableContent(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ExportableContent.$value';
}

/// Contains information about the original Model if this Model is a copy.
final class Model_OriginalModelInfo extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Model.OriginalModelInfo';

  /// Output only. The resource name of the Model this Model is a copy of,
  /// including the revision. Format:
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id}`
  final String model;

  Model_OriginalModelInfo({this.model = ''}) : super(fullyQualifiedName);

  factory Model_OriginalModelInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Model_OriginalModelInfo(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (model.isNotDefault) 'model': model};

  @override
  String toString() {
    final contents = ['model=$model'].join(',');
    return 'OriginalModelInfo($contents)';
  }
}

/// User input field to specify the base model source. Currently it only
/// supports specifing the Model Garden models and Genie models.
final class Model_BaseModelSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Model.BaseModelSource';

  /// Source information of Model Garden models.
  final ModelGardenSource? modelGardenSource;

  /// Information about the base model of Genie models.
  final GenieSource? genieSource;

  Model_BaseModelSource({this.modelGardenSource, this.genieSource})
    : super(fullyQualifiedName);

  factory Model_BaseModelSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Model_BaseModelSource(
      modelGardenSource: switch (json['modelGardenSource']) {
        null => null,
        Object $1 => ModelGardenSource.fromJson($1),
      },
      genieSource: switch (json['genieSource']) {
        null => null,
        Object $1 => GenieSource.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelGardenSource != null)
      'modelGardenSource': modelGardenSource!.toJson(),
    if (genieSource != null) 'genieSource': genieSource!.toJson(),
  };

  @override
  String toString() => 'BaseModelSource()';
}

/// Identifies a type of Model's prediction resources.
final class Model_DeploymentResourcesType extends ProtoEnum {
  /// Should not be used.
  static const deploymentResourcesTypeUnspecified =
      Model_DeploymentResourcesType('DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED');

  /// Resources that are dedicated to the
  /// `DeployedModel`, and that
  /// need a higher degree of manual configuration.
  static const dedicatedResources = Model_DeploymentResourcesType(
    'DEDICATED_RESOURCES',
  );

  /// Resources that to large degree are decided by Vertex AI, and require
  /// only a modest additional configuration.
  static const automaticResources = Model_DeploymentResourcesType(
    'AUTOMATIC_RESOURCES',
  );

  /// Resources that can be shared by multiple
  /// `DeployedModels`. A
  /// pre-configured
  /// `DeploymentResourcePool`
  /// is required.
  static const sharedResources = Model_DeploymentResourcesType(
    'SHARED_RESOURCES',
  );

  /// The default value for [Model_DeploymentResourcesType].
  static const $default = deploymentResourcesTypeUnspecified;

  const Model_DeploymentResourcesType(super.value);

  factory Model_DeploymentResourcesType.fromJson(Object? json) =>
      Model_DeploymentResourcesType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DeploymentResourcesType.$value';
}

/// Contains information about the Large Model.
final class LargeModelReference extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LargeModelReference';

  /// Required. The unique name of the large Foundation or pre-built model. Like
  /// "chat-bison", "text-bison". Or model name with version ID, like
  /// "chat-bison@001", "text-bison@005", etc.
  final String name;

  LargeModelReference({required this.name}) : super(fullyQualifiedName);

  factory LargeModelReference.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LargeModelReference(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'LargeModelReference($contents)';
  }
}

/// Contains information about the source of the models generated from Model
/// Garden.
final class ModelGardenSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelGardenSource';

  /// Required. The model garden source model resource name.
  final String publicModelName;

  /// Optional. The model garden source model version ID.
  final String versionId;

  /// Optional. Whether to avoid pulling the model from the HF cache.
  final bool skipHfModelCache;

  ModelGardenSource({
    required this.publicModelName,
    this.versionId = '',
    this.skipHfModelCache = false,
  }) : super(fullyQualifiedName);

  factory ModelGardenSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelGardenSource(
      publicModelName: switch (json['publicModelName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      versionId: switch (json['versionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      skipHfModelCache: switch (json['skipHfModelCache']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'publicModelName': publicModelName,
    if (versionId.isNotDefault) 'versionId': versionId,
    if (skipHfModelCache.isNotDefault) 'skipHfModelCache': skipHfModelCache,
  };

  @override
  String toString() {
    final contents = [
      'publicModelName=$publicModelName',
      'versionId=$versionId',
      'skipHfModelCache=$skipHfModelCache',
    ].join(',');
    return 'ModelGardenSource($contents)';
  }
}

/// Contains information about the source of the models generated from Generative
/// AI Studio.
final class GenieSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenieSource';

  /// Required. The public base model URI.
  final String baseModelUri;

  GenieSource({required this.baseModelUri}) : super(fullyQualifiedName);

  factory GenieSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenieSource(
      baseModelUri: switch (json['baseModelUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'baseModelUri': baseModelUri};

  @override
  String toString() {
    final contents = ['baseModelUri=$baseModelUri'].join(',');
    return 'GenieSource($contents)';
  }
}

/// Contains the schemata used in Model's predictions and explanations via
/// `PredictionService.Predict`,
/// `PredictionService.Explain`
/// and `BatchPredictionJob`.
final class PredictSchemata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictSchemata';

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the format of a single instance, which are used in
  /// `PredictRequest.instances`,
  /// `ExplainRequest.instances`
  /// and
  /// `BatchPredictionJob.input_config`.
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String instanceSchemaUri;

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the parameters of prediction and explanation via
  /// `PredictRequest.parameters`,
  /// `ExplainRequest.parameters`
  /// and
  /// `BatchPredictionJob.model_parameters`.
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// parameters are supported, then it is set to an empty string.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String parametersSchemaUri;

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the format of a single prediction produced by this Model, which are
  /// returned via
  /// `PredictResponse.predictions`,
  /// `ExplainResponse.explanations`,
  /// and
  /// `BatchPredictionJob.output_config`.
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String predictionSchemaUri;

  PredictSchemata({
    this.instanceSchemaUri = '',
    this.parametersSchemaUri = '',
    this.predictionSchemaUri = '',
  }) : super(fullyQualifiedName);

  factory PredictSchemata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PredictSchemata(
      instanceSchemaUri: switch (json['instanceSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parametersSchemaUri: switch (json['parametersSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      predictionSchemaUri: switch (json['predictionSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (instanceSchemaUri.isNotDefault) 'instanceSchemaUri': instanceSchemaUri,
    if (parametersSchemaUri.isNotDefault)
      'parametersSchemaUri': parametersSchemaUri,
    if (predictionSchemaUri.isNotDefault)
      'predictionSchemaUri': predictionSchemaUri,
  };

  @override
  String toString() {
    final contents = [
      'instanceSchemaUri=$instanceSchemaUri',
      'parametersSchemaUri=$parametersSchemaUri',
      'predictionSchemaUri=$predictionSchemaUri',
    ].join(',');
    return 'PredictSchemata($contents)';
  }
}

/// Specification of a container for serving predictions. Some fields in this
/// message correspond to fields in the [Kubernetes Container v1 core
/// specification](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
final class ModelContainerSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelContainerSpec';

  /// Required. Immutable. URI of the Docker image to be used as the custom
  /// container for serving predictions. This URI must identify an image in
  /// Artifact Registry or Container Registry. Learn more about the [container
  /// publishing
  /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
  /// including permissions requirements for the Vertex AI Service Agent.
  ///
  /// The container image is ingested upon
  /// `ModelService.UploadModel`,
  /// stored internally, and this original path is afterwards not used.
  ///
  /// To learn about the requirements for the Docker image itself, see
  /// [Custom container
  /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
  ///
  /// You can use the URI to one of Vertex AI's [pre-built container images for
  /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
  /// in this field.
  final String imageUri;

  /// Immutable. Specifies the command that runs when the container starts. This
  /// overrides the container's
  /// [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
  /// Specify this field as an array of executable and arguments, similar to a
  /// Docker `ENTRYPOINT`'s "exec" form, not its "shell" form.
  ///
  /// If you do not specify this field, then the container's `ENTRYPOINT` runs,
  /// in conjunction with the
  /// `args` field or
  /// the container's
  /// [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd), if either
  /// exists. If this field is not specified and the container does not have an
  /// `ENTRYPOINT`, then refer to the Docker documentation about [how `CMD` and
  /// `ENTRYPOINT`
  /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  ///
  /// If you specify this field, then you can also specify the `args` field to
  /// provide additional arguments for this command. However, if you specify this
  /// field, then the container's `CMD` is ignored. See the
  /// [Kubernetes documentation about how the
  /// `command` and `args` fields interact with a container's `ENTRYPOINT` and
  /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  ///
  /// In this field, you can reference [environment variables set by Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the
  /// `env` field. You
  /// cannot reference environment variables set in the Docker image. In order
  /// for environment variables to be expanded, reference them by using the
  /// following syntax:
  /// <code>$(<var>VARIABLE_NAME</var>)</code>
  /// Note that this differs from Bash variable expansion, which does not use
  /// parentheses. If a variable cannot be resolved, the reference in the input
  /// string is used unchanged. To avoid variable expansion, you can escape this
  /// syntax with `$$`; for example:
  /// <code>$$(<var>VARIABLE_NAME</var>)</code>
  /// This field corresponds to the `command` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  final List<String> command;

  /// Immutable. Specifies arguments for the command that runs when the container
  /// starts. This overrides the container's
  /// [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
  /// this field as an array of executable and arguments, similar to a Docker
  /// `CMD`'s "default parameters" form.
  ///
  /// If you don't specify this field but do specify the
  /// `command`
  /// field, then the command from the `command` field runs without any
  /// additional arguments. See the [Kubernetes documentation about how the
  /// `command` and `args` fields interact with a container's `ENTRYPOINT` and
  /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  ///
  /// If you don't specify this field and don't specify the `command` field,
  /// then the container's
  /// [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
  /// `CMD` determine what runs based on their default behavior. See the Docker
  /// documentation about [how `CMD` and `ENTRYPOINT`
  /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  ///
  /// In this field, you can reference [environment variables
  /// set by Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the
  /// `env` field. You
  /// cannot reference environment variables set in the Docker image. In order
  /// for environment variables to be expanded, reference them by using the
  /// following syntax:
  /// <code>$(<var>VARIABLE_NAME</var>)</code>
  /// Note that this differs from Bash variable expansion, which does not use
  /// parentheses. If a variable cannot be resolved, the reference in the input
  /// string is used unchanged. To avoid variable expansion, you can escape this
  /// syntax with `$$`; for example:
  /// <code>$$(<var>VARIABLE_NAME</var>)</code>
  /// This field corresponds to the `args` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  final List<String> args;

  /// Immutable. List of environment variables to set in the container. After the
  /// container starts running, code running in the container can read these
  /// environment variables.
  ///
  /// Additionally, the
  /// `command` and
  /// `args` fields can
  /// reference these variables. Later entries in this list can also reference
  /// earlier entries. For example, the following example sets the variable
  /// `VAR_2` to have the value `foo bar`:
  ///
  /// ```json
  /// [
  ///   {
  ///     "name": "VAR_1",
  ///     "value": "foo"
  ///   },
  ///   {
  ///     "name": "VAR_2",
  ///     "value": "$(VAR_1) bar"
  ///   }
  /// ]
  /// ```
  ///
  /// If you switch the order of the variables in the example, then the expansion
  /// does not occur.
  ///
  /// This field corresponds to the `env` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  final List<EnvVar> env;

  /// Immutable. List of ports to expose from the container. Vertex AI sends any
  /// prediction requests that it receives to the first port on this list. Vertex
  /// AI also sends
  /// [liveness and health
  /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
  /// to this port.
  ///
  /// If you do not specify this field, it defaults to following value:
  ///
  /// ```json
  /// [
  ///   {
  ///     "containerPort": 8080
  ///   }
  /// ]
  /// ```
  ///
  /// Vertex AI does not use ports other than the first one listed. This field
  /// corresponds to the `ports` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  final List<Port> ports;

  /// Immutable. HTTP path on the container to send prediction requests to.
  /// Vertex AI forwards requests sent using
  /// `projects.locations.endpoints.predict`
  /// to this path on the container's IP address and port. Vertex AI then returns
  /// the container's response in the API response.
  ///
  /// For example, if you set this field to `/foo`, then when Vertex AI
  /// receives a prediction request, it forwards the request body in a POST
  /// request to the `/foo` path on the port of your container specified by the
  /// first value of this `ModelContainerSpec`'s
  /// `ports` field.
  ///
  /// If you don't specify this field, it defaults to the following value when
  /// you [deploy this Model to an
  /// Endpoint][google.cloud.aiplatform.v1beta1.EndpointService.DeployModel]:
  /// <code>/v1/endpoints/<var>ENDPOINT</var>/deployedModels/<var>DEPLOYED_MODEL</var>:predict</code>
  /// The placeholders in this value are replaced as follows:
  ///
  /// * <var>ENDPOINT</var>: The last segment (following `endpoints/`)of the
  ///   Endpoint.name][] field of the Endpoint where this Model has been
  ///   deployed. (Vertex AI makes this value available to your container code
  ///   as the [`AIP_ENDPOINT_ID` environment
  ///  variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// * <var>DEPLOYED_MODEL</var>:
  /// `DeployedModel.id` of the
  /// `DeployedModel`.
  ///   (Vertex AI makes this value available to your container code
  ///   as the [`AIP_DEPLOYED_MODEL_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  final String predictRoute;

  /// Immutable. HTTP path on the container to send health checks to. Vertex AI
  /// intermittently sends GET requests to this path on the container's IP
  /// address and port to check that the container is healthy. Read more about
  /// [health
  /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
  ///
  /// For example, if you set this field to `/bar`, then Vertex AI
  /// intermittently sends a GET request to the `/bar` path on the port of your
  /// container specified by the first value of this `ModelContainerSpec`'s
  /// `ports` field.
  ///
  /// If you don't specify this field, it defaults to the following value when
  /// you [deploy this Model to an
  /// Endpoint][google.cloud.aiplatform.v1beta1.EndpointService.DeployModel]:
  /// <code>/v1/endpoints/<var>ENDPOINT</var>/deployedModels/<var>DEPLOYED_MODEL</var>:predict</code>
  /// The placeholders in this value are replaced as follows:
  ///
  /// * <var>ENDPOINT</var>: The last segment (following `endpoints/`)of the
  ///   Endpoint.name][] field of the Endpoint where this Model has been
  ///   deployed. (Vertex AI makes this value available to your container code
  ///   as the [`AIP_ENDPOINT_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// * <var>DEPLOYED_MODEL</var>:
  /// `DeployedModel.id` of the
  /// `DeployedModel`.
  ///   (Vertex AI makes this value available to your container code as the
  ///   [`AIP_DEPLOYED_MODEL_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  final String healthRoute;

  /// Immutable. Invoke route prefix for the custom container. "/*" is the only
  /// supported value right now. By setting this field, any non-root route on
  /// this model will be accessible with [PredictionService.Invoke] eg:
  /// "/invoke/foo/bar".
  ///
  /// Only one of `predict_route` or `invoke_route_prefix` can be set, and we
  /// default to using `predict_route` if this field is not set. If this field
  /// is set, the Model can only be deployed to dedicated endpoint.
  final String invokeRoutePrefix;

  /// Immutable. List of ports to expose from the container. Vertex AI sends gRPC
  /// prediction requests that it receives to the first port on this list. Vertex
  /// AI also sends liveness and health checks to this port.
  ///
  /// If you do not specify this field, gRPC requests to the container will be
  /// disabled.
  ///
  /// Vertex AI does not use ports other than the first one listed. This field
  /// corresponds to the `ports` field of the Kubernetes Containers v1 core API.
  final List<Port> grpcPorts;

  /// Immutable. Deployment timeout.
  /// Limit for deployment timeout is 2 hours.
  final protobuf.Duration? deploymentTimeout;

  /// Immutable. The amount of the VM memory to reserve as the shared memory for
  /// the model in megabytes.
  final int sharedMemorySizeMb;

  /// Immutable. Specification for Kubernetes startup probe.
  final Probe? startupProbe;

  /// Immutable. Specification for Kubernetes readiness probe.
  final Probe? healthProbe;

  /// Immutable. Specification for Kubernetes liveness probe.
  final Probe? livenessProbe;

  ModelContainerSpec({
    required this.imageUri,
    this.command = const [],
    this.args = const [],
    this.env = const [],
    this.ports = const [],
    this.predictRoute = '',
    this.healthRoute = '',
    this.invokeRoutePrefix = '',
    this.grpcPorts = const [],
    this.deploymentTimeout,
    this.sharedMemorySizeMb = 0,
    this.startupProbe,
    this.healthProbe,
    this.livenessProbe,
  }) : super(fullyQualifiedName);

  factory ModelContainerSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelContainerSpec(
      imageUri: switch (json['imageUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      command: switch (json['command']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"command" is not a list'),
      },
      args: switch (json['args']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"args" is not a list'),
      },
      env: switch (json['env']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) EnvVar.fromJson(i)],
        _ => throw const FormatException('"env" is not a list'),
      },
      ports: switch (json['ports']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Port.fromJson(i)],
        _ => throw const FormatException('"ports" is not a list'),
      },
      predictRoute: switch (json['predictRoute']) {
        null => '',
        Object $1 => decodeString($1),
      },
      healthRoute: switch (json['healthRoute']) {
        null => '',
        Object $1 => decodeString($1),
      },
      invokeRoutePrefix: switch (json['invokeRoutePrefix']) {
        null => '',
        Object $1 => decodeString($1),
      },
      grpcPorts: switch (json['grpcPorts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Port.fromJson(i)],
        _ => throw const FormatException('"grpcPorts" is not a list'),
      },
      deploymentTimeout: switch (json['deploymentTimeout']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      sharedMemorySizeMb: switch (json['sharedMemorySizeMb']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      startupProbe: switch (json['startupProbe']) {
        null => null,
        Object $1 => Probe.fromJson($1),
      },
      healthProbe: switch (json['healthProbe']) {
        null => null,
        Object $1 => Probe.fromJson($1),
      },
      livenessProbe: switch (json['livenessProbe']) {
        null => null,
        Object $1 => Probe.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'imageUri': imageUri,
    if (command.isNotDefault) 'command': command,
    if (args.isNotDefault) 'args': args,
    if (env.isNotDefault) 'env': encodeList(env),
    if (ports.isNotDefault) 'ports': encodeList(ports),
    if (predictRoute.isNotDefault) 'predictRoute': predictRoute,
    if (healthRoute.isNotDefault) 'healthRoute': healthRoute,
    if (invokeRoutePrefix.isNotDefault) 'invokeRoutePrefix': invokeRoutePrefix,
    if (grpcPorts.isNotDefault) 'grpcPorts': encodeList(grpcPorts),
    if (deploymentTimeout != null)
      'deploymentTimeout': deploymentTimeout!.toJson(),
    if (sharedMemorySizeMb.isNotDefault)
      'sharedMemorySizeMb': encodeInt64(sharedMemorySizeMb),
    if (startupProbe != null) 'startupProbe': startupProbe!.toJson(),
    if (healthProbe != null) 'healthProbe': healthProbe!.toJson(),
    if (livenessProbe != null) 'livenessProbe': livenessProbe!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'imageUri=$imageUri',
      'predictRoute=$predictRoute',
      'healthRoute=$healthRoute',
      'invokeRoutePrefix=$invokeRoutePrefix',
      'sharedMemorySizeMb=$sharedMemorySizeMb',
    ].join(',');
    return 'ModelContainerSpec($contents)';
  }
}

/// Represents a network port in a container.
final class Port extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Port';

  /// The number of the port to expose on the pod's IP address.
  /// Must be a valid port number, between 1 and 65535 inclusive.
  final int containerPort;

  Port({this.containerPort = 0}) : super(fullyQualifiedName);

  factory Port.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Port(
      containerPort: switch (json['containerPort']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (containerPort.isNotDefault) 'containerPort': containerPort,
  };

  @override
  String toString() {
    final contents = ['containerPort=$containerPort'].join(',');
    return 'Port($contents)';
  }
}

/// Detail description of the source information of the model.
final class ModelSourceInfo extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelSourceInfo';

  /// Type of the model source.
  final ModelSourceInfo_ModelSourceType sourceType;

  /// If this Model is copy of another Model. If true then
  /// `source_type`
  /// pertains to the original.
  final bool copy;

  ModelSourceInfo({
    this.sourceType = ModelSourceInfo_ModelSourceType.$default,
    this.copy = false,
  }) : super(fullyQualifiedName);

  factory ModelSourceInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelSourceInfo(
      sourceType: switch (json['sourceType']) {
        null => ModelSourceInfo_ModelSourceType.$default,
        Object $1 => ModelSourceInfo_ModelSourceType.fromJson($1),
      },
      copy: switch (json['copy']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sourceType.isNotDefault) 'sourceType': sourceType.toJson(),
    if (copy.isNotDefault) 'copy': copy,
  };

  @override
  String toString() {
    final contents = ['sourceType=$sourceType', 'copy=$copy'].join(',');
    return 'ModelSourceInfo($contents)';
  }
}

/// Source of the model.
/// Different from `objective` field, this `ModelSourceType` enum
/// indicates the source from which the model was accessed or obtained,
/// whereas the `objective` indicates the overall aim or function of this
/// model.
final class ModelSourceInfo_ModelSourceType extends ProtoEnum {
  /// Should not be used.
  static const modelSourceTypeUnspecified = ModelSourceInfo_ModelSourceType(
    'MODEL_SOURCE_TYPE_UNSPECIFIED',
  );

  /// The Model is uploaded by automl training pipeline.
  static const automl = ModelSourceInfo_ModelSourceType('AUTOML');

  /// The Model is uploaded by user or custom training pipeline.
  static const custom = ModelSourceInfo_ModelSourceType('CUSTOM');

  /// The Model is registered and sync'ed from BigQuery ML.
  static const bqml = ModelSourceInfo_ModelSourceType('BQML');

  /// The Model is saved or tuned from Model Garden.
  static const modelGarden = ModelSourceInfo_ModelSourceType('MODEL_GARDEN');

  /// The Model is saved or tuned from Genie.
  static const genie = ModelSourceInfo_ModelSourceType('GENIE');

  /// The Model is uploaded by text embedding finetuning pipeline.
  static const customTextEmbedding = ModelSourceInfo_ModelSourceType(
    'CUSTOM_TEXT_EMBEDDING',
  );

  /// The Model is saved or tuned from Marketplace.
  static const marketplace = ModelSourceInfo_ModelSourceType('MARKETPLACE');

  /// The default value for [ModelSourceInfo_ModelSourceType].
  static const $default = modelSourceTypeUnspecified;

  const ModelSourceInfo_ModelSourceType(super.value);

  factory ModelSourceInfo_ModelSourceType.fromJson(Object? json) =>
      ModelSourceInfo_ModelSourceType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ModelSourceType.$value';
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
final class Probe extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe';

  /// ExecAction probes the health of a container by executing a command.
  final Probe_ExecAction? exec;

  /// HttpGetAction probes the health of a container by sending an HTTP GET
  /// request.
  final Probe_HttpGetAction? httpGet;

  /// GrpcAction probes the health of a container by sending a gRPC request.
  final Probe_GrpcAction? grpc;

  /// TcpSocketAction probes the health of a container by opening a TCP socket
  /// connection.
  final Probe_TcpSocketAction? tcpSocket;

  /// How often (in seconds) to perform the probe. Default to 10 seconds.
  /// Minimum value is 1. Must be less than timeout_seconds.
  ///
  /// Maps to Kubernetes probe argument 'periodSeconds'.
  final int periodSeconds;

  /// Number of seconds after which the probe times out. Defaults to 1 second.
  /// Minimum value is 1. Must be greater or equal to period_seconds.
  ///
  /// Maps to Kubernetes probe argument 'timeoutSeconds'.
  final int timeoutSeconds;

  /// Number of consecutive failures before the probe is considered failed.
  /// Defaults to 3. Minimum value is 1.
  ///
  /// Maps to Kubernetes probe argument 'failureThreshold'.
  final int failureThreshold;

  /// Number of consecutive successes before the probe is considered successful.
  /// Defaults to 1. Minimum value is 1.
  ///
  /// Maps to Kubernetes probe argument 'successThreshold'.
  final int successThreshold;

  /// Number of seconds to wait before starting the probe. Defaults to 0.
  /// Minimum value is 0.
  ///
  /// Maps to Kubernetes probe argument 'initialDelaySeconds'.
  final int initialDelaySeconds;

  Probe({
    this.exec,
    this.httpGet,
    this.grpc,
    this.tcpSocket,
    this.periodSeconds = 0,
    this.timeoutSeconds = 0,
    this.failureThreshold = 0,
    this.successThreshold = 0,
    this.initialDelaySeconds = 0,
  }) : super(fullyQualifiedName);

  factory Probe.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Probe(
      exec: switch (json['exec']) {
        null => null,
        Object $1 => Probe_ExecAction.fromJson($1),
      },
      httpGet: switch (json['httpGet']) {
        null => null,
        Object $1 => Probe_HttpGetAction.fromJson($1),
      },
      grpc: switch (json['grpc']) {
        null => null,
        Object $1 => Probe_GrpcAction.fromJson($1),
      },
      tcpSocket: switch (json['tcpSocket']) {
        null => null,
        Object $1 => Probe_TcpSocketAction.fromJson($1),
      },
      periodSeconds: switch (json['periodSeconds']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      timeoutSeconds: switch (json['timeoutSeconds']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      failureThreshold: switch (json['failureThreshold']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      successThreshold: switch (json['successThreshold']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      initialDelaySeconds: switch (json['initialDelaySeconds']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (exec != null) 'exec': exec!.toJson(),
    if (httpGet != null) 'httpGet': httpGet!.toJson(),
    if (grpc != null) 'grpc': grpc!.toJson(),
    if (tcpSocket != null) 'tcpSocket': tcpSocket!.toJson(),
    if (periodSeconds.isNotDefault) 'periodSeconds': periodSeconds,
    if (timeoutSeconds.isNotDefault) 'timeoutSeconds': timeoutSeconds,
    if (failureThreshold.isNotDefault) 'failureThreshold': failureThreshold,
    if (successThreshold.isNotDefault) 'successThreshold': successThreshold,
    if (initialDelaySeconds.isNotDefault)
      'initialDelaySeconds': initialDelaySeconds,
  };

  @override
  String toString() {
    final contents = [
      'periodSeconds=$periodSeconds',
      'timeoutSeconds=$timeoutSeconds',
      'failureThreshold=$failureThreshold',
      'successThreshold=$successThreshold',
      'initialDelaySeconds=$initialDelaySeconds',
    ].join(',');
    return 'Probe($contents)';
  }
}

/// ExecAction specifies a command to execute.
final class Probe_ExecAction extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.ExecAction';

  /// Command is the command line to execute inside the container, the working
  /// directory for the command is root ('/') in the container's filesystem.
  /// The command is simply exec'd, it is not run inside a shell, so
  /// traditional shell instructions ('|', etc) won't work. To use a shell, you
  /// need to explicitly call out to that shell. Exit status of 0 is treated as
  /// live/healthy and non-zero is unhealthy.
  final List<String> command;

  Probe_ExecAction({this.command = const []}) : super(fullyQualifiedName);

  factory Probe_ExecAction.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Probe_ExecAction(
      command: switch (json['command']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"command" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (command.isNotDefault) 'command': command};

  @override
  String toString() => 'ExecAction()';
}

/// HttpGetAction describes an action based on HTTP Get requests.
final class Probe_HttpGetAction extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.HttpGetAction';

  /// Path to access on the HTTP server.
  final String path;

  /// Number of the port to access on the container.
  /// Number must be in the range 1 to 65535.
  final int port;

  /// Host name to connect to, defaults to the model serving container's IP.
  /// You probably want to set "Host" in httpHeaders instead.
  final String host;

  /// Scheme to use for connecting to the host.
  /// Defaults to HTTP. Acceptable values are "HTTP" or "HTTPS".
  final String scheme;

  /// Custom headers to set in the request. HTTP allows repeated headers.
  final List<Probe_HttpHeader> httpHeaders;

  Probe_HttpGetAction({
    this.path = '',
    this.port = 0,
    this.host = '',
    this.scheme = '',
    this.httpHeaders = const [],
  }) : super(fullyQualifiedName);

  factory Probe_HttpGetAction.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Probe_HttpGetAction(
      path: switch (json['path']) {
        null => '',
        Object $1 => decodeString($1),
      },
      port: switch (json['port']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      host: switch (json['host']) {
        null => '',
        Object $1 => decodeString($1),
      },
      scheme: switch (json['scheme']) {
        null => '',
        Object $1 => decodeString($1),
      },
      httpHeaders: switch (json['httpHeaders']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Probe_HttpHeader.fromJson(i)],
        _ => throw const FormatException('"httpHeaders" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (path.isNotDefault) 'path': path,
    if (port.isNotDefault) 'port': port,
    if (host.isNotDefault) 'host': host,
    if (scheme.isNotDefault) 'scheme': scheme,
    if (httpHeaders.isNotDefault) 'httpHeaders': encodeList(httpHeaders),
  };

  @override
  String toString() {
    final contents = [
      'path=$path',
      'port=$port',
      'host=$host',
      'scheme=$scheme',
    ].join(',');
    return 'HttpGetAction($contents)';
  }
}

/// GrpcAction checks the health of a container using a gRPC service.
final class Probe_GrpcAction extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.GrpcAction';

  /// Port number of the gRPC service. Number must be in the range 1 to 65535.
  final int port;

  /// Service is the name of the service to place in the gRPC
  /// HealthCheckRequest (see
  /// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
  ///
  /// If this is not specified, the default behavior is defined by gRPC.
  final String service;

  Probe_GrpcAction({this.port = 0, this.service = ''})
    : super(fullyQualifiedName);

  factory Probe_GrpcAction.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Probe_GrpcAction(
      port: switch (json['port']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      service: switch (json['service']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (port.isNotDefault) 'port': port,
    if (service.isNotDefault) 'service': service,
  };

  @override
  String toString() {
    final contents = ['port=$port', 'service=$service'].join(',');
    return 'GrpcAction($contents)';
  }
}

/// TcpSocketAction probes the health of a container by opening a TCP socket
/// connection.
final class Probe_TcpSocketAction extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.TcpSocketAction';

  /// Number of the port to access on the container.
  /// Number must be in the range 1 to 65535.
  final int port;

  /// Optional: Host name to connect to, defaults to the model serving
  /// container's IP.
  final String host;

  Probe_TcpSocketAction({this.port = 0, this.host = ''})
    : super(fullyQualifiedName);

  factory Probe_TcpSocketAction.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Probe_TcpSocketAction(
      port: switch (json['port']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      host: switch (json['host']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (port.isNotDefault) 'port': port,
    if (host.isNotDefault) 'host': host,
  };

  @override
  String toString() {
    final contents = ['port=$port', 'host=$host'].join(',');
    return 'TcpSocketAction($contents)';
  }
}

/// HttpHeader describes a custom header to be used in HTTP probes
final class Probe_HttpHeader extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.HttpHeader';

  /// The header field name.
  /// This will be canonicalized upon output, so case-variant names will be
  /// understood as the same header.
  final String name;

  /// The header field value
  final String value;

  Probe_HttpHeader({this.name = '', this.value = ''})
    : super(fullyQualifiedName);

  factory Probe_HttpHeader.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Probe_HttpHeader(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      value: switch (json['value']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (value.isNotDefault) 'value': value,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'value=$value'].join(',');
    return 'HttpHeader($contents)';
  }
}

/// Describes the machine learning model version checkpoint.
final class Checkpoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Checkpoint';

  /// The ID of the checkpoint.
  final String checkpointId;

  /// The epoch of the checkpoint.
  final int epoch;

  /// The step of the checkpoint.
  final int step;

  Checkpoint({this.checkpointId = '', this.epoch = 0, this.step = 0})
    : super(fullyQualifiedName);

  factory Checkpoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Checkpoint(
      checkpointId: switch (json['checkpointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      epoch: switch (json['epoch']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      step: switch (json['step']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (checkpointId.isNotDefault) 'checkpointId': checkpointId,
    if (epoch.isNotDefault) 'epoch': encodeInt64(epoch),
    if (step.isNotDefault) 'step': encodeInt64(step),
  };

  @override
  String toString() {
    final contents = [
      'checkpointId=$checkpointId',
      'epoch=$epoch',
      'step=$step',
    ].join(',');
    return 'Checkpoint($contents)';
  }
}

/// Represents a job that runs periodically to monitor the deployed models in an
/// endpoint. It will analyze the logged training & prediction data to detect any
/// abnormal behaviors.
final class ModelDeploymentMonitoringJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringJob';

  /// Output only. Resource name of a ModelDeploymentMonitoringJob.
  final String name;

  /// Required. The user-defined name of the ModelDeploymentMonitoringJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  /// Display name of a ModelDeploymentMonitoringJob.
  final String displayName;

  /// Required. Endpoint resource name.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Output only. The detailed state of the monitoring job.
  /// When the job is still creating, the state will be 'PENDING'.
  /// Once the job is successfully created, the state will be 'RUNNING'.
  /// Pause the job, the state will be 'PAUSED'.
  /// Resume the job, the state will return to 'RUNNING'.
  final JobState state;

  /// Output only. Schedule state when the monitoring job is in Running state.
  final ModelDeploymentMonitoringJob_MonitoringScheduleState scheduleState;

  /// Output only. Latest triggered monitoring pipeline metadata.
  final ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata?
  latestMonitoringPipelineMetadata;

  /// Required. The config for monitoring objectives. This is a per DeployedModel
  /// config. Each DeployedModel needs to be configured separately.
  final List<ModelDeploymentMonitoringObjectiveConfig>
  modelDeploymentMonitoringObjectiveConfigs;

  /// Required. Schedule config for running the monitoring job.
  final ModelDeploymentMonitoringScheduleConfig?
  modelDeploymentMonitoringScheduleConfig;

  /// Required. Sample Strategy for logging.
  final SamplingStrategy? loggingSamplingStrategy;

  /// Alert config for model monitoring.
  final ModelMonitoringAlertConfig? modelMonitoringAlertConfig;

  /// YAML schema file uri describing the format of a single instance,
  /// which are given to format this Endpoint's prediction (and explanation).
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  final String predictInstanceSchemaUri;

  /// Sample Predict instance, same format as
  /// `PredictRequest.instances`,
  /// this can be set as a replacement of
  /// `ModelDeploymentMonitoringJob.predict_instance_schema_uri`.
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  final protobuf.Value? samplePredictInstance;

  /// YAML schema file uri describing the format of a single instance that you
  /// want Tensorflow Data Validation (TFDV) to analyze.
  ///
  /// If this field is empty, all the feature data types are inferred from
  /// `predict_instance_schema_uri`,
  /// meaning that TFDV will use the data in the exact format(data type) as
  /// prediction request/response.
  /// If there are any data type differences between predict instance and TFDV
  /// instance, this field can be used to override the schema.
  /// For models trained with Vertex AI, this field must be set as all the
  /// fields in predict instance formatted as string.
  final String analysisInstanceSchemaUri;

  /// Output only. The created bigquery tables for the job under customer
  /// project. Customer could do their own query & analysis. There could be 4 log
  /// tables in maximum:
  /// 1. Training data logging predict request/response
  /// 2. Serving data logging predict request/response
  final List<ModelDeploymentMonitoringBigQueryTable> bigqueryTables;

  /// The TTL of BigQuery tables in user projects which stores logs.
  /// A day is the basic unit of the TTL and we take the ceil of TTL/86400(a
  /// day). e.g. { second: 3600} indicates ttl = 1 day.
  final protobuf.Duration? logTtl;

  /// The labels with user-defined metadata to organize your
  /// ModelDeploymentMonitoringJob.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ModelDeploymentMonitoringJob was updated
  /// most recently.
  final protobuf.Timestamp? updateTime;

  /// Output only. Timestamp when this monitoring pipeline will be scheduled to
  /// run for the next round.
  final protobuf.Timestamp? nextScheduleTime;

  /// Stats anomalies base folder path.
  final GcsDestination? statsAnomaliesBaseDirectory;

  /// Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If
  /// set, this ModelDeploymentMonitoringJob and all sub-resources of this
  /// ModelDeploymentMonitoringJob will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// If true, the scheduled monitoring pipeline logs are sent to
  /// Google Cloud Logging, including pipeline status and anomalies detected.
  /// Please note the logs incur cost, which are subject to [Cloud Logging
  /// pricing](https://cloud.google.com/logging#pricing).
  final bool enableMonitoringPipelineLogs;

  /// Output only. Only populated when the job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  final Status? error;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  ModelDeploymentMonitoringJob({
    this.name = '',
    required this.displayName,
    required this.endpoint,
    this.state = JobState.$default,
    this.scheduleState =
        ModelDeploymentMonitoringJob_MonitoringScheduleState.$default,
    this.latestMonitoringPipelineMetadata,
    required this.modelDeploymentMonitoringObjectiveConfigs,
    required this.modelDeploymentMonitoringScheduleConfig,
    required this.loggingSamplingStrategy,
    this.modelMonitoringAlertConfig,
    this.predictInstanceSchemaUri = '',
    this.samplePredictInstance,
    this.analysisInstanceSchemaUri = '',
    this.bigqueryTables = const [],
    this.logTtl,
    this.labels = const {},
    this.createTime,
    this.updateTime,
    this.nextScheduleTime,
    this.statsAnomaliesBaseDirectory,
    this.encryptionSpec,
    this.enableMonitoringPipelineLogs = false,
    this.error,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelDeploymentMonitoringJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      scheduleState: switch (json['scheduleState']) {
        null => ModelDeploymentMonitoringJob_MonitoringScheduleState.$default,
        Object $1 =>
          ModelDeploymentMonitoringJob_MonitoringScheduleState.fromJson($1),
      },
      latestMonitoringPipelineMetadata:
          switch (json['latestMonitoringPipelineMetadata']) {
            null => null,
            Object $1 =>
              ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata.fromJson(
                $1,
              ),
          },
      modelDeploymentMonitoringObjectiveConfigs:
          switch (json['modelDeploymentMonitoringObjectiveConfigs']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1)
                ModelDeploymentMonitoringObjectiveConfig.fromJson(i),
            ],
            _ => throw const FormatException(
              '"modelDeploymentMonitoringObjectiveConfigs" is not a list',
            ),
          },
      modelDeploymentMonitoringScheduleConfig:
          switch (json['modelDeploymentMonitoringScheduleConfig']) {
            null => null,
            Object $1 => ModelDeploymentMonitoringScheduleConfig.fromJson($1),
          },
      loggingSamplingStrategy: switch (json['loggingSamplingStrategy']) {
        null => null,
        Object $1 => SamplingStrategy.fromJson($1),
      },
      modelMonitoringAlertConfig: switch (json['modelMonitoringAlertConfig']) {
        null => null,
        Object $1 => ModelMonitoringAlertConfig.fromJson($1),
      },
      predictInstanceSchemaUri: switch (json['predictInstanceSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      samplePredictInstance: switch (json['samplePredictInstance']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      analysisInstanceSchemaUri: switch (json['analysisInstanceSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      bigqueryTables: switch (json['bigqueryTables']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ModelDeploymentMonitoringBigQueryTable.fromJson(i),
        ],
        _ => throw const FormatException('"bigqueryTables" is not a list'),
      },
      logTtl: switch (json['logTtl']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      nextScheduleTime: switch (json['nextScheduleTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      statsAnomaliesBaseDirectory:
          switch (json['statsAnomaliesBaseDirectory']) {
            null => null,
            Object $1 => GcsDestination.fromJson($1),
          },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      enableMonitoringPipelineLogs:
          switch (json['enableMonitoringPipelineLogs']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    'endpoint': endpoint,
    if (state.isNotDefault) 'state': state.toJson(),
    if (scheduleState.isNotDefault) 'scheduleState': scheduleState.toJson(),
    if (latestMonitoringPipelineMetadata != null)
      'latestMonitoringPipelineMetadata': latestMonitoringPipelineMetadata!
          .toJson(),
    'modelDeploymentMonitoringObjectiveConfigs': encodeList(
      modelDeploymentMonitoringObjectiveConfigs,
    ),
    if (modelDeploymentMonitoringScheduleConfig != null)
      'modelDeploymentMonitoringScheduleConfig':
          modelDeploymentMonitoringScheduleConfig!.toJson(),
    if (loggingSamplingStrategy != null)
      'loggingSamplingStrategy': loggingSamplingStrategy!.toJson(),
    if (modelMonitoringAlertConfig != null)
      'modelMonitoringAlertConfig': modelMonitoringAlertConfig!.toJson(),
    if (predictInstanceSchemaUri.isNotDefault)
      'predictInstanceSchemaUri': predictInstanceSchemaUri,
    if (samplePredictInstance != null)
      'samplePredictInstance': samplePredictInstance!.toJson(),
    if (analysisInstanceSchemaUri.isNotDefault)
      'analysisInstanceSchemaUri': analysisInstanceSchemaUri,
    if (bigqueryTables.isNotDefault)
      'bigqueryTables': encodeList(bigqueryTables),
    if (logTtl != null) 'logTtl': logTtl!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (nextScheduleTime != null)
      'nextScheduleTime': nextScheduleTime!.toJson(),
    if (statsAnomaliesBaseDirectory != null)
      'statsAnomaliesBaseDirectory': statsAnomaliesBaseDirectory!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (enableMonitoringPipelineLogs.isNotDefault)
      'enableMonitoringPipelineLogs': enableMonitoringPipelineLogs,
    if (error != null) 'error': error!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'endpoint=$endpoint',
      'state=$state',
      'scheduleState=$scheduleState',
      'predictInstanceSchemaUri=$predictInstanceSchemaUri',
      'analysisInstanceSchemaUri=$analysisInstanceSchemaUri',
      'enableMonitoringPipelineLogs=$enableMonitoringPipelineLogs',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'ModelDeploymentMonitoringJob($contents)';
  }
}

/// All metadata of most recent monitoring pipelines.
final class ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringJob.LatestMonitoringPipelineMetadata';

  /// The time that most recent monitoring pipelines that is related to this
  /// run.
  final protobuf.Timestamp? runTime;

  /// The status of the most recent monitoring pipeline.
  final Status? status;

  ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata({
    this.runTime,
    this.status,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata(
      runTime: switch (json['runTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      status: switch (json['status']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (runTime != null) 'runTime': runTime!.toJson(),
    if (status != null) 'status': status!.toJson(),
  };

  @override
  String toString() => 'LatestMonitoringPipelineMetadata()';
}

/// The state to Specify the monitoring pipeline.
final class ModelDeploymentMonitoringJob_MonitoringScheduleState
    extends ProtoEnum {
  /// Unspecified state.
  static const monitoringScheduleStateUnspecified =
      ModelDeploymentMonitoringJob_MonitoringScheduleState(
        'MONITORING_SCHEDULE_STATE_UNSPECIFIED',
      );

  /// The pipeline is picked up and wait to run.
  static const pending = ModelDeploymentMonitoringJob_MonitoringScheduleState(
    'PENDING',
  );

  /// The pipeline is offline and will be scheduled for next run.
  static const offline = ModelDeploymentMonitoringJob_MonitoringScheduleState(
    'OFFLINE',
  );

  /// The pipeline is running.
  static const running = ModelDeploymentMonitoringJob_MonitoringScheduleState(
    'RUNNING',
  );

  /// The default value for [ModelDeploymentMonitoringJob_MonitoringScheduleState].
  static const $default = monitoringScheduleStateUnspecified;

  const ModelDeploymentMonitoringJob_MonitoringScheduleState(super.value);

  factory ModelDeploymentMonitoringJob_MonitoringScheduleState.fromJson(
    Object? json,
  ) => ModelDeploymentMonitoringJob_MonitoringScheduleState(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'MonitoringScheduleState.$value';
}

/// ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name
/// as well as some information of the logs stored in this table.
final class ModelDeploymentMonitoringBigQueryTable extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringBigQueryTable';

  /// The source of log.
  final ModelDeploymentMonitoringBigQueryTable_LogSource logSource;

  /// The type of log.
  final ModelDeploymentMonitoringBigQueryTable_LogType logType;

  /// The created BigQuery table to store logs. Customer could do their own query
  /// & analysis. Format:
  /// `bq://<project_id>.model_deployment_monitoring_<endpoint_id>.<tolower(log_source)>_<tolower(log_type)>`
  final String bigqueryTablePath;

  /// Output only. The schema version of the request/response logging BigQuery
  /// table. Default to v1 if unset.
  final String requestResponseLoggingSchemaVersion;

  ModelDeploymentMonitoringBigQueryTable({
    this.logSource = ModelDeploymentMonitoringBigQueryTable_LogSource.$default,
    this.logType = ModelDeploymentMonitoringBigQueryTable_LogType.$default,
    this.bigqueryTablePath = '',
    this.requestResponseLoggingSchemaVersion = '',
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringBigQueryTable.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelDeploymentMonitoringBigQueryTable(
      logSource: switch (json['logSource']) {
        null => ModelDeploymentMonitoringBigQueryTable_LogSource.$default,
        Object $1 => ModelDeploymentMonitoringBigQueryTable_LogSource.fromJson(
          $1,
        ),
      },
      logType: switch (json['logType']) {
        null => ModelDeploymentMonitoringBigQueryTable_LogType.$default,
        Object $1 => ModelDeploymentMonitoringBigQueryTable_LogType.fromJson(
          $1,
        ),
      },
      bigqueryTablePath: switch (json['bigqueryTablePath']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requestResponseLoggingSchemaVersion:
          switch (json['requestResponseLoggingSchemaVersion']) {
            null => '',
            Object $1 => decodeString($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (logSource.isNotDefault) 'logSource': logSource.toJson(),
    if (logType.isNotDefault) 'logType': logType.toJson(),
    if (bigqueryTablePath.isNotDefault) 'bigqueryTablePath': bigqueryTablePath,
    if (requestResponseLoggingSchemaVersion.isNotDefault)
      'requestResponseLoggingSchemaVersion':
          requestResponseLoggingSchemaVersion,
  };

  @override
  String toString() {
    final contents = [
      'logSource=$logSource',
      'logType=$logType',
      'bigqueryTablePath=$bigqueryTablePath',
      'requestResponseLoggingSchemaVersion=$requestResponseLoggingSchemaVersion',
    ].join(',');
    return 'ModelDeploymentMonitoringBigQueryTable($contents)';
  }
}

/// Indicates where does the log come from.
final class ModelDeploymentMonitoringBigQueryTable_LogSource extends ProtoEnum {
  /// Unspecified source.
  static const logSourceUnspecified =
      ModelDeploymentMonitoringBigQueryTable_LogSource(
        'LOG_SOURCE_UNSPECIFIED',
      );

  /// Logs coming from Training dataset.
  static const training = ModelDeploymentMonitoringBigQueryTable_LogSource(
    'TRAINING',
  );

  /// Logs coming from Serving traffic.
  static const serving = ModelDeploymentMonitoringBigQueryTable_LogSource(
    'SERVING',
  );

  /// The default value for [ModelDeploymentMonitoringBigQueryTable_LogSource].
  static const $default = logSourceUnspecified;

  const ModelDeploymentMonitoringBigQueryTable_LogSource(super.value);

  factory ModelDeploymentMonitoringBigQueryTable_LogSource.fromJson(
    Object? json,
  ) => ModelDeploymentMonitoringBigQueryTable_LogSource(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'LogSource.$value';
}

/// Indicates what type of traffic does the log belong to.
final class ModelDeploymentMonitoringBigQueryTable_LogType extends ProtoEnum {
  /// Unspecified type.
  static const logTypeUnspecified =
      ModelDeploymentMonitoringBigQueryTable_LogType('LOG_TYPE_UNSPECIFIED');

  /// Predict logs.
  static const predict = ModelDeploymentMonitoringBigQueryTable_LogType(
    'PREDICT',
  );

  /// Explain logs.
  static const explain = ModelDeploymentMonitoringBigQueryTable_LogType(
    'EXPLAIN',
  );

  /// The default value for [ModelDeploymentMonitoringBigQueryTable_LogType].
  static const $default = logTypeUnspecified;

  const ModelDeploymentMonitoringBigQueryTable_LogType(super.value);

  factory ModelDeploymentMonitoringBigQueryTable_LogType.fromJson(
    Object? json,
  ) => ModelDeploymentMonitoringBigQueryTable_LogType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'LogType.$value';
}

/// ModelDeploymentMonitoringObjectiveConfig contains the pair of
/// deployed_model_id to ModelMonitoringObjectiveConfig.
final class ModelDeploymentMonitoringObjectiveConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringObjectiveConfig';

  /// The DeployedModel ID of the objective config.
  final String deployedModelId;

  /// The objective config of for the modelmonitoring job of this deployed model.
  final ModelMonitoringObjectiveConfig? objectiveConfig;

  ModelDeploymentMonitoringObjectiveConfig({
    this.deployedModelId = '',
    this.objectiveConfig,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringObjectiveConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelDeploymentMonitoringObjectiveConfig(
      deployedModelId: switch (json['deployedModelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      objectiveConfig: switch (json['objectiveConfig']) {
        null => null,
        Object $1 => ModelMonitoringObjectiveConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (deployedModelId.isNotDefault) 'deployedModelId': deployedModelId,
    if (objectiveConfig != null) 'objectiveConfig': objectiveConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['deployedModelId=$deployedModelId'].join(',');
    return 'ModelDeploymentMonitoringObjectiveConfig($contents)';
  }
}

/// The config for scheduling monitoring job.
final class ModelDeploymentMonitoringScheduleConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringScheduleConfig';

  /// Required. The model monitoring job scheduling interval. It will be rounded
  /// up to next full hour. This defines how often the monitoring jobs are
  /// triggered.
  final protobuf.Duration? monitorInterval;

  /// The time window of the prediction data being included in each prediction
  /// dataset. This window specifies how long the data should be collected from
  /// historical model results for each run. If not set,
  /// `ModelDeploymentMonitoringScheduleConfig.monitor_interval`
  /// will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and
  /// the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to
  /// 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the
  /// monitoring statistics.
  final protobuf.Duration? monitorWindow;

  ModelDeploymentMonitoringScheduleConfig({
    required this.monitorInterval,
    this.monitorWindow,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringScheduleConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelDeploymentMonitoringScheduleConfig(
      monitorInterval: switch (json['monitorInterval']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      monitorWindow: switch (json['monitorWindow']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (monitorInterval != null) 'monitorInterval': monitorInterval!.toJson(),
    if (monitorWindow != null) 'monitorWindow': monitorWindow!.toJson(),
  };

  @override
  String toString() => 'ModelDeploymentMonitoringScheduleConfig()';
}

/// Statistics and anomalies generated by Model Monitoring.
final class ModelMonitoringStatsAnomalies extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsAnomalies';

  /// Model Monitoring Objective those stats and anomalies belonging to.
  final ModelDeploymentMonitoringObjectiveType objective;

  /// Deployed Model ID.
  final String deployedModelId;

  /// Number of anomalies within all stats.
  final int anomalyCount;

  /// A list of historical Stats and Anomalies generated for all Features.
  final List<ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies>
  featureStats;

  ModelMonitoringStatsAnomalies({
    this.objective = ModelDeploymentMonitoringObjectiveType.$default,
    this.deployedModelId = '',
    this.anomalyCount = 0,
    this.featureStats = const [],
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsAnomalies.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringStatsAnomalies(
      objective: switch (json['objective']) {
        null => ModelDeploymentMonitoringObjectiveType.$default,
        Object $1 => ModelDeploymentMonitoringObjectiveType.fromJson($1),
      },
      deployedModelId: switch (json['deployedModelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      anomalyCount: switch (json['anomalyCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      featureStats: switch (json['featureStats']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException('"featureStats" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (objective.isNotDefault) 'objective': objective.toJson(),
    if (deployedModelId.isNotDefault) 'deployedModelId': deployedModelId,
    if (anomalyCount.isNotDefault) 'anomalyCount': anomalyCount,
    if (featureStats.isNotDefault) 'featureStats': encodeList(featureStats),
  };

  @override
  String toString() {
    final contents = [
      'objective=$objective',
      'deployedModelId=$deployedModelId',
      'anomalyCount=$anomalyCount',
    ].join(',');
    return 'ModelMonitoringStatsAnomalies($contents)';
  }
}

/// Historical Stats (and Anomalies) for a specific Feature.
final class ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies';

  /// Display Name of the Feature.
  final String featureDisplayName;

  /// Threshold for anomaly detection.
  final ThresholdConfig? threshold;

  /// Stats calculated for the Training Dataset.
  final FeatureStatsAnomaly? trainingStats;

  /// A list of historical stats generated by different time window's
  /// Prediction Dataset.
  final List<FeatureStatsAnomaly> predictionStats;

  ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies({
    this.featureDisplayName = '',
    this.threshold,
    this.trainingStats,
    this.predictionStats = const [],
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies(
      featureDisplayName: switch (json['featureDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      threshold: switch (json['threshold']) {
        null => null,
        Object $1 => ThresholdConfig.fromJson($1),
      },
      trainingStats: switch (json['trainingStats']) {
        null => null,
        Object $1 => FeatureStatsAnomaly.fromJson($1),
      },
      predictionStats: switch (json['predictionStats']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FeatureStatsAnomaly.fromJson(i),
        ],
        _ => throw const FormatException('"predictionStats" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureDisplayName.isNotDefault)
      'featureDisplayName': featureDisplayName,
    if (threshold != null) 'threshold': threshold!.toJson(),
    if (trainingStats != null) 'trainingStats': trainingStats!.toJson(),
    if (predictionStats.isNotDefault)
      'predictionStats': encodeList(predictionStats),
  };

  @override
  String toString() {
    final contents = ['featureDisplayName=$featureDisplayName'].join(',');
    return 'FeatureHistoricStatsAnomalies($contents)';
  }
}

/// A collection of metrics calculated by comparing Model's predictions on all of
/// the test data against annotations from the test data.
final class ModelEvaluation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluation';

  /// Output only. The resource name of the ModelEvaluation.
  final String name;

  /// The display name of the ModelEvaluation.
  final String displayName;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// `metrics` of this
  /// ModelEvaluation. The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  final String metricsSchemaUri;

  /// Evaluation metrics of the Model. The schema of the metrics is stored in
  /// `metrics_schema_uri`
  final protobuf.Value? metrics;

  /// Output only. Timestamp when this ModelEvaluation was created.
  final protobuf.Timestamp? createTime;

  /// All possible
  /// `dimensions`
  /// of ModelEvaluationSlices. The dimensions can be used as the filter of the
  /// `ModelService.ListModelEvaluationSlices`
  /// request, in the form of `slice.dimension = <dimension>`.
  final List<String> sliceDimensions;

  /// Aggregated explanation metrics for the Model's prediction output over the
  /// data this ModelEvaluation uses. This field is populated only if the Model
  /// is evaluated with explanations, and only for AutoML tabular Models.
  final ModelExplanation? modelExplanation;

  /// Describes the values of
  /// `ExplanationSpec` that are
  /// used for explaining the predicted values on the evaluated data.
  final List<ModelEvaluation_ModelEvaluationExplanationSpec> explanationSpecs;

  /// The metadata of the ModelEvaluation.
  /// For the ModelEvaluation uploaded from Managed Pipeline, metadata contains a
  /// structured value with keys of "pipeline_job_id", "evaluation_dataset_type",
  /// "evaluation_dataset_path", "row_based_metrics_path".
  final protobuf.Value? metadata;

  /// Specify the configuration for bias detection.
  final ModelEvaluation_BiasConfig? biasConfigs;

  ModelEvaluation({
    this.name = '',
    this.displayName = '',
    this.metricsSchemaUri = '',
    this.metrics,
    this.createTime,
    this.sliceDimensions = const [],
    this.modelExplanation,
    this.explanationSpecs = const [],
    this.metadata,
    this.biasConfigs,
  }) : super(fullyQualifiedName);

  factory ModelEvaluation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluation(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metricsSchemaUri: switch (json['metricsSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metrics: switch (json['metrics']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      sliceDimensions: switch (json['sliceDimensions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"sliceDimensions" is not a list'),
      },
      modelExplanation: switch (json['modelExplanation']) {
        null => null,
        Object $1 => ModelExplanation.fromJson($1),
      },
      explanationSpecs: switch (json['explanationSpecs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ModelEvaluation_ModelEvaluationExplanationSpec.fromJson(i),
        ],
        _ => throw const FormatException('"explanationSpecs" is not a list'),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      biasConfigs: switch (json['biasConfigs']) {
        null => null,
        Object $1 => ModelEvaluation_BiasConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (metricsSchemaUri.isNotDefault) 'metricsSchemaUri': metricsSchemaUri,
    if (metrics != null) 'metrics': metrics!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (sliceDimensions.isNotDefault) 'sliceDimensions': sliceDimensions,
    if (modelExplanation != null)
      'modelExplanation': modelExplanation!.toJson(),
    if (explanationSpecs.isNotDefault)
      'explanationSpecs': encodeList(explanationSpecs),
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (biasConfigs != null) 'biasConfigs': biasConfigs!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'metricsSchemaUri=$metricsSchemaUri',
    ].join(',');
    return 'ModelEvaluation($contents)';
  }
}

final class ModelEvaluation_ModelEvaluationExplanationSpec
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluation.ModelEvaluationExplanationSpec';

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are:
  ///
  ///   * `image-integrated-gradients`
  ///   * `image-xrai`
  final String explanationType;

  /// Explanation spec details.
  final ExplanationSpec? explanationSpec;

  ModelEvaluation_ModelEvaluationExplanationSpec({
    this.explanationType = '',
    this.explanationSpec,
  }) : super(fullyQualifiedName);

  factory ModelEvaluation_ModelEvaluationExplanationSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluation_ModelEvaluationExplanationSpec(
      explanationType: switch (json['explanationType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      explanationSpec: switch (json['explanationSpec']) {
        null => null,
        Object $1 => ExplanationSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (explanationType.isNotDefault) 'explanationType': explanationType,
    if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = ['explanationType=$explanationType'].join(',');
    return 'ModelEvaluationExplanationSpec($contents)';
  }
}

/// Configuration for bias detection.
final class ModelEvaluation_BiasConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluation.BiasConfig';

  /// Specification for how the data should be sliced for bias. It contains a
  /// list of slices, with limitation of two slices. The first slice of data
  /// will be the slice_a. The second slice in the list (slice_b) will be
  /// compared against the first slice. If only a single slice is provided,
  /// then slice_a will be compared against "not slice_a".
  /// Below are examples with feature "education" with value "low", "medium",
  /// "high" in the dataset:
  ///
  /// Example 1:
  ///
  ///     bias_slices = [{'education': 'low'}]
  ///
  /// A single slice provided. In this case, slice_a is the collection of data
  /// with 'education' equals 'low', and slice_b is the collection of data with
  /// 'education' equals 'medium' or 'high'.
  ///
  /// Example 2:
  ///
  ///     bias_slices = [{'education': 'low'},
  ///                    {'education': 'high'}]
  ///
  /// Two slices provided. In this case, slice_a is the collection of data
  /// with 'education' equals 'low', and slice_b is the collection of data with
  /// 'education' equals 'high'.
  final ModelEvaluationSlice_Slice_SliceSpec? biasSlices;

  /// Positive labels selection on the target field.
  final List<String> labels;

  ModelEvaluation_BiasConfig({this.biasSlices, this.labels = const []})
    : super(fullyQualifiedName);

  factory ModelEvaluation_BiasConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluation_BiasConfig(
      biasSlices: switch (json['biasSlices']) {
        null => null,
        Object $1 => ModelEvaluationSlice_Slice_SliceSpec.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"labels" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (biasSlices != null) 'biasSlices': biasSlices!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
  };

  @override
  String toString() => 'BiasConfig()';
}

/// A collection of metrics calculated by comparing Model's predictions on a
/// slice of the test data against ground truth annotations.
final class ModelEvaluationSlice extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice';

  /// Output only. The resource name of the ModelEvaluationSlice.
  final String name;

  /// Output only. The slice of the test data that is used to evaluate the Model.
  final ModelEvaluationSlice_Slice? slice;

  /// Output only. Points to a YAML file stored on Google Cloud Storage
  /// describing the
  /// `metrics` of
  /// this ModelEvaluationSlice. The schema is defined as an OpenAPI 3.0.2
  /// [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  final String metricsSchemaUri;

  /// Output only. Sliced evaluation metrics of the Model. The schema of the
  /// metrics is stored in
  /// `metrics_schema_uri`
  final protobuf.Value? metrics;

  /// Output only. Timestamp when this ModelEvaluationSlice was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Aggregated explanation metrics for the Model's prediction
  /// output over the data this ModelEvaluation uses. This field is populated
  /// only if the Model is evaluated with explanations, and only for tabular
  /// Models.
  final ModelExplanation? modelExplanation;

  ModelEvaluationSlice({
    this.name = '',
    this.slice,
    this.metricsSchemaUri = '',
    this.metrics,
    this.createTime,
    this.modelExplanation,
  }) : super(fullyQualifiedName);

  factory ModelEvaluationSlice.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluationSlice(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      slice: switch (json['slice']) {
        null => null,
        Object $1 => ModelEvaluationSlice_Slice.fromJson($1),
      },
      metricsSchemaUri: switch (json['metricsSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metrics: switch (json['metrics']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      modelExplanation: switch (json['modelExplanation']) {
        null => null,
        Object $1 => ModelExplanation.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (slice != null) 'slice': slice!.toJson(),
    if (metricsSchemaUri.isNotDefault) 'metricsSchemaUri': metricsSchemaUri,
    if (metrics != null) 'metrics': metrics!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (modelExplanation != null)
      'modelExplanation': modelExplanation!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'metricsSchemaUri=$metricsSchemaUri',
    ].join(',');
    return 'ModelEvaluationSlice($contents)';
  }
}

/// Definition of a slice.
final class ModelEvaluationSlice_Slice extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice';

  /// Output only. The dimension of the slice.
  /// Well-known dimensions are:
  ///   * `annotationSpec`: This slice is on the test data that has either
  ///     ground truth or prediction with
  ///     `AnnotationSpec.display_name`
  ///     equals to
  ///     `value`.
  ///   * `slice`: This slice is a user customized slice defined by its
  ///     SliceSpec.
  final String dimension;

  /// Output only. The value of the dimension in this slice.
  final String value;

  /// Output only. Specification for how the data was sliced.
  final ModelEvaluationSlice_Slice_SliceSpec? sliceSpec;

  ModelEvaluationSlice_Slice({
    this.dimension = '',
    this.value = '',
    this.sliceSpec,
  }) : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluationSlice_Slice(
      dimension: switch (json['dimension']) {
        null => '',
        Object $1 => decodeString($1),
      },
      value: switch (json['value']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sliceSpec: switch (json['sliceSpec']) {
        null => null,
        Object $1 => ModelEvaluationSlice_Slice_SliceSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dimension.isNotDefault) 'dimension': dimension,
    if (value.isNotDefault) 'value': value,
    if (sliceSpec != null) 'sliceSpec': sliceSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = ['dimension=$dimension', 'value=$value'].join(',');
    return 'Slice($contents)';
  }
}

/// Specification for how the data should be sliced.
final class ModelEvaluationSlice_Slice_SliceSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice.SliceSpec';

  /// Mapping configuration for this SliceSpec.
  /// The key is the name of the feature.
  /// By default, the key will be prefixed by "instance" as a dictionary
  /// prefix for Vertex Batch Predictions output format.
  final Map<String, ModelEvaluationSlice_Slice_SliceSpec_SliceConfig> configs;

  ModelEvaluationSlice_Slice_SliceSpec({this.configs = const {}})
    : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice_SliceSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluationSlice_Slice_SliceSpec(
      configs: switch (json['configs']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(
              e.key,
            ): ModelEvaluationSlice_Slice_SliceSpec_SliceConfig.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"configs" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {if (configs.isNotDefault) 'configs': encodeMap(configs)};

  @override
  String toString() => 'SliceSpec()';
}

/// Specification message containing the config for this SliceSpec.
/// When `kind` is selected as `value` and/or `range`, only a single slice
/// will be computed.
/// When `all_values` is present, a separate slice will be computed for
/// each possible label/value for the corresponding key in `config`.
/// Examples, with feature zip_code with values 12345, 23334, 88888 and
/// feature country with values "US", "Canada", "Mexico" in the dataset:
///
/// Example 1:
///
///     {
///       "zip_code": { "value": { "float_value": 12345.0 } }
///     }
///
/// A single slice for any data with zip_code 12345 in the dataset.
///
/// Example 2:
///
///     {
///       "zip_code": { "range": { "low": 12345, "high": 20000 } }
///     }
///
/// A single slice containing data where the zip_codes between 12345 and
/// 20000 For this example, data with the zip_code of 12345 will be in this
/// slice.
///
/// Example 3:
///
///     {
///       "zip_code": { "range": { "low": 10000, "high": 20000 } },
///       "country": { "value": { "string_value": "US" } }
///     }
///
/// A single slice containing data where the zip_codes between 10000 and
/// 20000 has the country "US". For this example, data with the zip_code of
/// 12345 and country "US" will be in this slice.
///
/// Example 4:
///
///     { "country": {"all_values": { "value": true } } }
///
/// Three slices are computed, one for each unique country in the dataset.
///
/// Example 5:
///
///     {
///       "country": { "all_values": { "value": true } },
///       "zip_code": { "value": { "float_value": 12345.0 } }
///     }
///
/// Three slices are computed, one for each unique country in the dataset
/// where the zip_code is also 12345. For this example, data with zip_code
/// 12345 and country "US" will be in one slice, zip_code 12345 and country
/// "Canada" in another slice, and zip_code 12345 and country "Mexico" in
/// another slice, totaling 3 slices.
final class ModelEvaluationSlice_Slice_SliceSpec_SliceConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice.SliceSpec.SliceConfig';

  /// A unique specific value for a given feature.
  /// Example: `{ "value": { "string_value": "12345" } }`
  final ModelEvaluationSlice_Slice_SliceSpec_Value? value;

  /// A range of values for a numerical feature.
  /// Example: `{"range":{"low":10000.0,"high":50000.0}}`
  /// will capture 12345 and 23334 in the slice.
  final ModelEvaluationSlice_Slice_SliceSpec_Range? range;

  /// If all_values is set to true, then all possible labels of the keyed
  /// feature will have another slice computed.
  /// Example: `{"all_values":{"value":true}}`
  final protobuf.BoolValue? allValues;

  ModelEvaluationSlice_Slice_SliceSpec_SliceConfig({
    this.value,
    this.range,
    this.allValues,
  }) : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice_SliceSpec_SliceConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluationSlice_Slice_SliceSpec_SliceConfig(
      value: switch (json['value']) {
        null => null,
        Object $1 => ModelEvaluationSlice_Slice_SliceSpec_Value.fromJson($1),
      },
      range: switch (json['range']) {
        null => null,
        Object $1 => ModelEvaluationSlice_Slice_SliceSpec_Range.fromJson($1),
      },
      allValues: switch (json['allValues']) {
        null => null,
        Object $1 => protobuf.BoolValue.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (value != null) 'value': value!.toJson(),
    if (range != null) 'range': range!.toJson(),
    if (allValues != null) 'allValues': allValues!.toJson(),
  };

  @override
  String toString() => 'SliceConfig()';
}

/// A range of values for slice(s).
/// `low` is inclusive, `high` is exclusive.
final class ModelEvaluationSlice_Slice_SliceSpec_Range extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice.SliceSpec.Range';

  /// Inclusive low value for the range.
  final double low;

  /// Exclusive high value for the range.
  final double high;

  ModelEvaluationSlice_Slice_SliceSpec_Range({this.low = 0, this.high = 0})
    : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice_SliceSpec_Range.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluationSlice_Slice_SliceSpec_Range(
      low: switch (json['low']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      high: switch (json['high']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (low.isNotDefault) 'low': encodeDouble(low),
    if (high.isNotDefault) 'high': encodeDouble(high),
  };

  @override
  String toString() {
    final contents = ['low=$low', 'high=$high'].join(',');
    return 'Range($contents)';
  }
}

/// Single value that supports strings and floats.
final class ModelEvaluationSlice_Slice_SliceSpec_Value extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice.SliceSpec.Value';

  /// String type.
  final String? stringValue;

  /// Float type.
  final double? floatValue;

  ModelEvaluationSlice_Slice_SliceSpec_Value({
    this.stringValue,
    this.floatValue,
  }) : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice_SliceSpec_Value.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelEvaluationSlice_Slice_SliceSpec_Value(
      stringValue: switch (json['stringValue']) {
        null => null,
        Object $1 => decodeString($1),
      },
      floatValue: switch (json['floatValue']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (stringValue != null) 'stringValue': stringValue,
    if (floatValue != null) 'floatValue': encodeDouble(floatValue),
  };

  @override
  String toString() {
    final contents = [
      if (stringValue != null) 'stringValue=$stringValue',
      if (floatValue != null) 'floatValue=$floatValue',
    ].join(',');
    return 'Value($contents)';
  }
}

/// Request message for
/// `ModelGardenService.GetPublisherModel`
final class GetPublisherModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetPublisherModelRequest';

  /// Required. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}`
  final String name;

  /// Optional. The IETF BCP-47 language code representing the language in which
  /// the publisher model's text information should be written in.
  final String languageCode;

  /// Optional. PublisherModel view specifying which fields to read.
  final PublisherModelView view;

  /// Optional. Boolean indicates whether the requested model is a Hugging Face
  /// model.
  final bool isHuggingFaceModel;

  /// Optional. Token used to access Hugging Face gated models.
  final String huggingFaceToken;

  /// Optional. Whether to cnclude the deployment configs from the equivalent
  /// Model Garden model if the requested model is a Hugging Face model.
  final bool includeEquivalentModelGardenModelDeploymentConfigs;

  GetPublisherModelRequest({
    required this.name,
    this.languageCode = '',
    this.view = PublisherModelView.$default,
    this.isHuggingFaceModel = false,
    this.huggingFaceToken = '',
    this.includeEquivalentModelGardenModelDeploymentConfigs = false,
  }) : super(fullyQualifiedName);

  factory GetPublisherModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetPublisherModelRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      view: switch (json['view']) {
        null => PublisherModelView.$default,
        Object $1 => PublisherModelView.fromJson($1),
      },
      isHuggingFaceModel: switch (json['isHuggingFaceModel']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      huggingFaceToken: switch (json['huggingFaceToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      includeEquivalentModelGardenModelDeploymentConfigs:
          switch (json['includeEquivalentModelGardenModelDeploymentConfigs']) {
            null => false,
            Object $1 => decodeBool($1),
          },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (languageCode.isNotDefault) 'languageCode': languageCode,
    if (view.isNotDefault) 'view': view.toJson(),
    if (isHuggingFaceModel.isNotDefault)
      'isHuggingFaceModel': isHuggingFaceModel,
    if (huggingFaceToken.isNotDefault) 'huggingFaceToken': huggingFaceToken,
    if (includeEquivalentModelGardenModelDeploymentConfigs.isNotDefault)
      'includeEquivalentModelGardenModelDeploymentConfigs':
          includeEquivalentModelGardenModelDeploymentConfigs,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'languageCode=$languageCode',
      'view=$view',
      'isHuggingFaceModel=$isHuggingFaceModel',
      'huggingFaceToken=$huggingFaceToken',
      'includeEquivalentModelGardenModelDeploymentConfigs=$includeEquivalentModelGardenModelDeploymentConfigs',
    ].join(',');
    return 'GetPublisherModelRequest($contents)';
  }
}

/// Request message for
/// `ModelGardenService.ListPublisherModels`.
final class ListPublisherModelsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPublisherModelsRequest';

  /// Required. The name of the Publisher from which to list the PublisherModels.
  /// Format: `publishers/{publisher}`
  final String parent;

  /// Optional. The standard list filter.
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListPublisherModelsResponse.next_page_token`
  /// of the previous
  /// `ModelGardenService.ListPublisherModels`
  /// call.
  final String pageToken;

  /// Optional. PublisherModel view specifying which fields to read.
  final PublisherModelView view;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending.
  final String orderBy;

  /// Optional. The IETF BCP-47 language code representing the language in which
  /// the publisher models' text information should be written in. If not set, by
  /// default English (en).
  final String languageCode;

  /// Optional. List all publisher model versions if the flag is set to true.
  final bool listAllVersions;

  ListPublisherModelsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.view = PublisherModelView.$default,
    this.orderBy = '',
    this.languageCode = '',
    this.listAllVersions = false,
  }) : super(fullyQualifiedName);

  factory ListPublisherModelsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListPublisherModelsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      view: switch (json['view']) {
        null => PublisherModelView.$default,
        Object $1 => PublisherModelView.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      listAllVersions: switch (json['listAllVersions']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (view.isNotDefault) 'view': view.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (languageCode.isNotDefault) 'languageCode': languageCode,
    if (listAllVersions.isNotDefault) 'listAllVersions': listAllVersions,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'view=$view',
      'orderBy=$orderBy',
      'languageCode=$languageCode',
      'listAllVersions=$listAllVersions',
    ].join(',');
    return 'ListPublisherModelsRequest($contents)';
  }
}

/// Response message for
/// `ModelGardenService.ListPublisherModels`.
final class ListPublisherModelsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPublisherModelsResponse';

  /// List of PublisherModels in the requested page.
  final List<PublisherModel> publisherModels;

  /// A token to retrieve next page of results.
  /// Pass to `ListPublisherModels.page_token` to obtain that page.
  final String nextPageToken;

  ListPublisherModelsResponse({
    this.publisherModels = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListPublisherModelsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListPublisherModelsResponse(
      publisherModels: switch (json['publisherModels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) PublisherModel.fromJson(i)],
        _ => throw const FormatException('"publisherModels" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (publisherModels.isNotDefault)
      'publisherModels': encodeList(publisherModels),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListPublisherModelsResponse($contents)';
  }
}

/// Request message for
/// `ModelGardenService.Deploy`.
final class DeployRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest';

  /// The Model Garden model to deploy.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`.
  final String? publisherModelName;

  /// The Hugging Face model to deploy.
  /// Format: Hugging Face model ID like `google/gemma-2-2b-it`.
  final String? huggingFaceModelId;

  /// The custom model to deploy from a Google Cloud Storage URI.
  final DeployRequest_CustomModel? customModel;

  /// Required. The resource name of the Location to deploy the model in.
  /// Format: `projects/{project}/locations/{location}`
  final String destination;

  /// Optional. The model config to use for the deployment.
  /// If not specified, the default model config will be used.
  final DeployRequest_ModelConfig? modelConfig;

  /// Optional. The endpoint config to use for the deployment.
  /// If not specified, the default endpoint config will be used.
  final DeployRequest_EndpointConfig? endpointConfig;

  /// Optional. The deploy config to use for the deployment.
  /// If not specified, the default deploy config will be used.
  final DeployRequest_DeployConfig? deployConfig;

  DeployRequest({
    this.publisherModelName,
    this.huggingFaceModelId,
    this.customModel,
    required this.destination,
    this.modelConfig,
    this.endpointConfig,
    this.deployConfig,
  }) : super(fullyQualifiedName);

  factory DeployRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployRequest(
      publisherModelName: switch (json['publisherModelName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      huggingFaceModelId: switch (json['huggingFaceModelId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      customModel: switch (json['customModel']) {
        null => null,
        Object $1 => DeployRequest_CustomModel.fromJson($1),
      },
      destination: switch (json['destination']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelConfig: switch (json['modelConfig']) {
        null => null,
        Object $1 => DeployRequest_ModelConfig.fromJson($1),
      },
      endpointConfig: switch (json['endpointConfig']) {
        null => null,
        Object $1 => DeployRequest_EndpointConfig.fromJson($1),
      },
      deployConfig: switch (json['deployConfig']) {
        null => null,
        Object $1 => DeployRequest_DeployConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (publisherModelName != null) 'publisherModelName': publisherModelName,
    if (huggingFaceModelId != null) 'huggingFaceModelId': huggingFaceModelId,
    if (customModel != null) 'customModel': customModel!.toJson(),
    'destination': destination,
    if (modelConfig != null) 'modelConfig': modelConfig!.toJson(),
    if (endpointConfig != null) 'endpointConfig': endpointConfig!.toJson(),
    if (deployConfig != null) 'deployConfig': deployConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (publisherModelName != null) 'publisherModelName=$publisherModelName',
      if (huggingFaceModelId != null) 'huggingFaceModelId=$huggingFaceModelId',
      'destination=$destination',
    ].join(',');
    return 'DeployRequest($contents)';
  }
}

/// The custom model to deploy from model weights in a Google Cloud Storage URI
/// or Model Registry model.
final class DeployRequest_CustomModel extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest.CustomModel';

  /// Immutable. The Google Cloud Storage URI of the custom model, storing
  /// weights and config files (which can be used to infer the base model).
  final String? gcsUri;

  DeployRequest_CustomModel({this.gcsUri}) : super(fullyQualifiedName);

  factory DeployRequest_CustomModel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployRequest_CustomModel(
      gcsUri: switch (json['gcsUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (gcsUri != null) 'gcsUri': gcsUri};

  @override
  String toString() {
    final contents = [if (gcsUri != null) 'gcsUri=$gcsUri'].join(',');
    return 'CustomModel($contents)';
  }
}

/// The model config to use for the deployment.
final class DeployRequest_ModelConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest.ModelConfig';

  /// Optional. Whether the user accepts the End User License Agreement (EULA)
  /// for the model.
  final bool acceptEula;

  /// Optional. The Hugging Face read access token used to access the model
  /// artifacts of gated models.
  final String huggingFaceAccessToken;

  /// Optional. If true, the model will deploy with a cached version instead of
  /// directly downloading the model artifacts from Hugging Face. This is
  /// suitable for VPC-SC users with limited internet access.
  final bool huggingFaceCacheEnabled;

  /// Optional. The user-specified display name of the uploaded model. If not
  /// set, a default name will be used.
  final String modelDisplayName;

  /// Optional. The specification of the container that is to be used when
  /// deploying. If not set, the default container spec will be used.
  final ModelContainerSpec? containerSpec;

  /// Optional. The ID to use for the uploaded Model, which will become the
  /// final component of the model resource name. When not provided, Vertex AI
  /// will generate a value for this ID. When Model Registry model is provided,
  /// this field will be ignored.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  final String modelUserId;

  DeployRequest_ModelConfig({
    this.acceptEula = false,
    this.huggingFaceAccessToken = '',
    this.huggingFaceCacheEnabled = false,
    this.modelDisplayName = '',
    this.containerSpec,
    this.modelUserId = '',
  }) : super(fullyQualifiedName);

  factory DeployRequest_ModelConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployRequest_ModelConfig(
      acceptEula: switch (json['acceptEula']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      huggingFaceAccessToken: switch (json['huggingFaceAccessToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      huggingFaceCacheEnabled: switch (json['huggingFaceCacheEnabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      modelDisplayName: switch (json['modelDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      containerSpec: switch (json['containerSpec']) {
        null => null,
        Object $1 => ModelContainerSpec.fromJson($1),
      },
      modelUserId: switch (json['modelUserId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (acceptEula.isNotDefault) 'acceptEula': acceptEula,
    if (huggingFaceAccessToken.isNotDefault)
      'huggingFaceAccessToken': huggingFaceAccessToken,
    if (huggingFaceCacheEnabled.isNotDefault)
      'huggingFaceCacheEnabled': huggingFaceCacheEnabled,
    if (modelDisplayName.isNotDefault) 'modelDisplayName': modelDisplayName,
    if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
    if (modelUserId.isNotDefault) 'modelUserId': modelUserId,
  };

  @override
  String toString() {
    final contents = [
      'acceptEula=$acceptEula',
      'huggingFaceAccessToken=$huggingFaceAccessToken',
      'huggingFaceCacheEnabled=$huggingFaceCacheEnabled',
      'modelDisplayName=$modelDisplayName',
      'modelUserId=$modelUserId',
    ].join(',');
    return 'ModelConfig($contents)';
  }
}

/// The endpoint config to use for the deployment.
final class DeployRequest_EndpointConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest.EndpointConfig';

  /// Optional. The user-specified display name of the endpoint. If not set, a
  /// default name will be used.
  final String endpointDisplayName;

  /// Optional. Deprecated. Use dedicated_endpoint_disabled instead.
  /// If true, the endpoint will be exposed through a
  /// dedicated DNS [Endpoint.dedicated_endpoint_dns]. Your request to the
  /// dedicated DNS will be isolated from other users' traffic and will have
  /// better performance and reliability. Note: Once you enabled dedicated
  /// endpoint, you won't be able to send request to the shared DNS
  /// {region}-aiplatform.googleapis.com. The limitations will be removed soon.
  final bool dedicatedEndpointEnabled;

  /// Optional. By default, if dedicated endpoint is enabled and private
  /// service connect config is not set, the endpoint will be exposed through a
  /// dedicated DNS [Endpoint.dedicated_endpoint_dns]. If private service
  /// connect config is set, the endpoint will be exposed through private
  /// service connect. Your request to the dedicated DNS will be isolated from
  /// other users' traffic and will have better performance and reliability.
  /// Note: Once you enabled dedicated endpoint, you won't be able to send
  /// request to the shared DNS {region}-aiplatform.googleapis.com. The
  /// limitations will be removed soon.
  ///
  /// If this field is set to true, the dedicated endpoint will be disabled
  /// and the deployed model will be exposed through the shared DNS
  /// {region}-aiplatform.googleapis.com.
  final bool dedicatedEndpointDisabled;

  /// Optional. Configuration for private service connect. If set, the endpoint
  /// will be exposed through private service connect.
  final PrivateServiceConnectConfig? privateServiceConnectConfig;

  /// Optional. Immutable. The ID to use for endpoint, which will become the
  /// final component of the endpoint resource name. If not provided, Vertex AI
  /// will generate a value for this ID.
  ///
  /// If the first character is a letter, this value may be up to 63
  /// characters, and valid characters are `[a-z0-9-]`. The last character must
  /// be a letter or number.
  ///
  /// If the first character is a number, this value may be up to 9 characters,
  /// and valid characters are `[0-9]` with no leading zeros.
  ///
  /// When using HTTP/JSON, this field is populated
  /// based on a query string argument, such as `?endpoint_id=12345`. This is
  /// the fallback for fields that are not included in either the URI or the
  /// body.
  final String endpointUserId;

  DeployRequest_EndpointConfig({
    this.endpointDisplayName = '',
    this.dedicatedEndpointEnabled = false,
    this.dedicatedEndpointDisabled = false,
    this.privateServiceConnectConfig,
    this.endpointUserId = '',
  }) : super(fullyQualifiedName);

  factory DeployRequest_EndpointConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployRequest_EndpointConfig(
      endpointDisplayName: switch (json['endpointDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dedicatedEndpointEnabled: switch (json['dedicatedEndpointEnabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      dedicatedEndpointDisabled: switch (json['dedicatedEndpointDisabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      privateServiceConnectConfig:
          switch (json['privateServiceConnectConfig']) {
            null => null,
            Object $1 => PrivateServiceConnectConfig.fromJson($1),
          },
      endpointUserId: switch (json['endpointUserId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (endpointDisplayName.isNotDefault)
      'endpointDisplayName': endpointDisplayName,
    if (dedicatedEndpointEnabled.isNotDefault)
      'dedicatedEndpointEnabled': dedicatedEndpointEnabled,
    if (dedicatedEndpointDisabled.isNotDefault)
      'dedicatedEndpointDisabled': dedicatedEndpointDisabled,
    if (privateServiceConnectConfig != null)
      'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
    if (endpointUserId.isNotDefault) 'endpointUserId': endpointUserId,
  };

  @override
  String toString() {
    final contents = [
      'endpointDisplayName=$endpointDisplayName',
      'dedicatedEndpointEnabled=$dedicatedEndpointEnabled',
      'dedicatedEndpointDisabled=$dedicatedEndpointDisabled',
      'endpointUserId=$endpointUserId',
    ].join(',');
    return 'EndpointConfig($contents)';
  }
}

/// The deploy config to use for the deployment.
final class DeployRequest_DeployConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest.DeployConfig';

  /// Optional. The dedicated resources to use for the endpoint. If not set,
  /// the default resources will be used.
  final DedicatedResources? dedicatedResources;

  /// Optional. If true, enable the QMT fast tryout feature for this model if
  /// possible.
  final bool fastTryoutEnabled;

  /// Optional. System labels for Model Garden deployments.
  /// These labels are managed by Google and for tracking purposes only.
  final Map<String, String> systemLabels;

  DeployRequest_DeployConfig({
    this.dedicatedResources,
    this.fastTryoutEnabled = false,
    this.systemLabels = const {},
  }) : super(fullyQualifiedName);

  factory DeployRequest_DeployConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployRequest_DeployConfig(
      dedicatedResources: switch (json['dedicatedResources']) {
        null => null,
        Object $1 => DedicatedResources.fromJson($1),
      },
      fastTryoutEnabled: switch (json['fastTryoutEnabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      systemLabels: switch (json['systemLabels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"systemLabels" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (dedicatedResources != null)
      'dedicatedResources': dedicatedResources!.toJson(),
    if (fastTryoutEnabled.isNotDefault) 'fastTryoutEnabled': fastTryoutEnabled,
    if (systemLabels.isNotDefault) 'systemLabels': systemLabels,
  };

  @override
  String toString() {
    final contents = ['fastTryoutEnabled=$fastTryoutEnabled'].join(',');
    return 'DeployConfig($contents)';
  }
}

/// Request message for
/// `ModelGardenService.DeployPublisherModel`.
final class DeployPublisherModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployPublisherModelRequest';

  /// Required. The model to deploy.
  /// Format:
  /// 1. `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`.
  /// 2. Hugging Face model ID like `google/gemma-2-2b-it`.
  /// 3. Custom model Google Cloud Storage URI like `gs://bucket`.
  /// 4. Custom model zip file like `https://example.com/a.zip`.
  final String model;

  /// Required. The resource name of the Location to deploy the model in.
  /// Format: `projects/{project}/locations/{location}`
  final String destination;

  /// Optional. The user-specified display name of the endpoint. If not set, a
  /// default name will be used.
  final String endpointDisplayName;

  /// Optional. The dedicated resources to use for the endpoint. If not set, the
  /// default resources will be used.
  final DedicatedResources? dedicatedResources;

  /// Optional. The user-specified display name of the uploaded model. If not
  /// set, a default name will be used.
  final String modelDisplayName;

  /// Optional. The Hugging Face read access token used to access the model
  /// artifacts of gated models.
  final String huggingFaceAccessToken;

  /// Optional. Whether the user accepts the End User License Agreement (EULA)
  /// for the model.
  final bool acceptEula;

  DeployPublisherModelRequest({
    required this.model,
    required this.destination,
    this.endpointDisplayName = '',
    this.dedicatedResources,
    this.modelDisplayName = '',
    this.huggingFaceAccessToken = '',
    this.acceptEula = false,
  }) : super(fullyQualifiedName);

  factory DeployPublisherModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployPublisherModelRequest(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destination: switch (json['destination']) {
        null => '',
        Object $1 => decodeString($1),
      },
      endpointDisplayName: switch (json['endpointDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dedicatedResources: switch (json['dedicatedResources']) {
        null => null,
        Object $1 => DedicatedResources.fromJson($1),
      },
      modelDisplayName: switch (json['modelDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      huggingFaceAccessToken: switch (json['huggingFaceAccessToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      acceptEula: switch (json['acceptEula']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'model': model,
    'destination': destination,
    if (endpointDisplayName.isNotDefault)
      'endpointDisplayName': endpointDisplayName,
    if (dedicatedResources != null)
      'dedicatedResources': dedicatedResources!.toJson(),
    if (modelDisplayName.isNotDefault) 'modelDisplayName': modelDisplayName,
    if (huggingFaceAccessToken.isNotDefault)
      'huggingFaceAccessToken': huggingFaceAccessToken,
    if (acceptEula.isNotDefault) 'acceptEula': acceptEula,
  };

  @override
  String toString() {
    final contents = [
      'model=$model',
      'destination=$destination',
      'endpointDisplayName=$endpointDisplayName',
      'modelDisplayName=$modelDisplayName',
      'huggingFaceAccessToken=$huggingFaceAccessToken',
      'acceptEula=$acceptEula',
    ].join(',');
    return 'DeployPublisherModelRequest($contents)';
  }
}

/// Response message for
/// `ModelGardenService.Deploy`.
final class DeployResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployResponse';

  /// Output only. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  final String publisherModel;

  /// Output only. The name of the Endpoint created.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Output only. The name of the Model created.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String model;

  DeployResponse({
    this.publisherModel = '',
    this.endpoint = '',
    this.model = '',
  }) : super(fullyQualifiedName);

  factory DeployResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployResponse(
      publisherModel: switch (json['publisherModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (publisherModel.isNotDefault) 'publisherModel': publisherModel,
    if (endpoint.isNotDefault) 'endpoint': endpoint,
    if (model.isNotDefault) 'model': model,
  };

  @override
  String toString() {
    final contents = [
      'publisherModel=$publisherModel',
      'endpoint=$endpoint',
      'model=$model',
    ].join(',');
    return 'DeployResponse($contents)';
  }
}

/// Response message for
/// `ModelGardenService.DeployPublisherModel`.
final class DeployPublisherModelResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployPublisherModelResponse';

  /// Output only. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  final String publisherModel;

  /// Output only. The name of the Endpoint created.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Output only. The name of the Model created.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String model;

  DeployPublisherModelResponse({
    this.publisherModel = '',
    this.endpoint = '',
    this.model = '',
  }) : super(fullyQualifiedName);

  factory DeployPublisherModelResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployPublisherModelResponse(
      publisherModel: switch (json['publisherModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (publisherModel.isNotDefault) 'publisherModel': publisherModel,
    if (endpoint.isNotDefault) 'endpoint': endpoint,
    if (model.isNotDefault) 'model': model,
  };

  @override
  String toString() {
    final contents = [
      'publisherModel=$publisherModel',
      'endpoint=$endpoint',
      'model=$model',
    ].join(',');
    return 'DeployPublisherModelResponse($contents)';
  }
}

/// Runtime operation information for
/// `ModelGardenService.Deploy`.
final class DeployOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. The name of the model resource.
  final String publisherModel;

  /// Output only. The resource name of the Location to deploy the model in.
  /// Format: `projects/{project}/locations/{location}`
  final String destination;

  /// Output only. The project number where the deploy model request is sent.
  final int projectNumber;

  /// Output only. The model id to be used at query time.
  final String modelId;

  DeployOperationMetadata({
    this.genericMetadata,
    this.publisherModel = '',
    this.destination = '',
    this.projectNumber = 0,
    this.modelId = '',
  }) : super(fullyQualifiedName);

  factory DeployOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      publisherModel: switch (json['publisherModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destination: switch (json['destination']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projectNumber: switch (json['projectNumber']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      modelId: switch (json['modelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (publisherModel.isNotDefault) 'publisherModel': publisherModel,
    if (destination.isNotDefault) 'destination': destination,
    if (projectNumber.isNotDefault) 'projectNumber': encodeInt64(projectNumber),
    if (modelId.isNotDefault) 'modelId': modelId,
  };

  @override
  String toString() {
    final contents = [
      'publisherModel=$publisherModel',
      'destination=$destination',
      'projectNumber=$projectNumber',
      'modelId=$modelId',
    ].join(',');
    return 'DeployOperationMetadata($contents)';
  }
}

/// Runtime operation information for
/// `ModelGardenService.DeployPublisherModel`.
final class DeployPublisherModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployPublisherModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  final String publisherModel;

  /// Output only. The resource name of the Location to deploy the model in.
  /// Format: `projects/{project}/locations/{location}`
  final String destination;

  /// Output only. The project number where the deploy model request is sent.
  final int projectNumber;

  DeployPublisherModelOperationMetadata({
    this.genericMetadata,
    this.publisherModel = '',
    this.destination = '',
    this.projectNumber = 0,
  }) : super(fullyQualifiedName);

  factory DeployPublisherModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeployPublisherModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      publisherModel: switch (json['publisherModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destination: switch (json['destination']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projectNumber: switch (json['projectNumber']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (publisherModel.isNotDefault) 'publisherModel': publisherModel,
    if (destination.isNotDefault) 'destination': destination,
    if (projectNumber.isNotDefault) 'projectNumber': encodeInt64(projectNumber),
  };

  @override
  String toString() {
    final contents = [
      'publisherModel=$publisherModel',
      'destination=$destination',
      'projectNumber=$projectNumber',
    ].join(',');
    return 'DeployPublisherModelOperationMetadata($contents)';
  }
}

/// Response message for
/// `ModelGardenService.ExportPublisherModel`.
final class ExportPublisherModelResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportPublisherModelResponse';

  /// The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`
  final String publisherModel;

  /// The destination uri of the model weights.
  final String destinationUri;

  ExportPublisherModelResponse({
    this.publisherModel = '',
    this.destinationUri = '',
  }) : super(fullyQualifiedName);

  factory ExportPublisherModelResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportPublisherModelResponse(
      publisherModel: switch (json['publisherModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinationUri: switch (json['destinationUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (publisherModel.isNotDefault) 'publisherModel': publisherModel,
    if (destinationUri.isNotDefault) 'destinationUri': destinationUri,
  };

  @override
  String toString() {
    final contents = [
      'publisherModel=$publisherModel',
      'destinationUri=$destinationUri',
    ].join(',');
    return 'ExportPublisherModelResponse($contents)';
  }
}

/// Runtime operation information for
/// `ModelGardenService.ExportPublisherModel`.
final class ExportPublisherModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportPublisherModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  ExportPublisherModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ExportPublisherModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportPublisherModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'ExportPublisherModelOperationMetadata()';
}

/// Request message for
/// `ModelGardenService.ExportPublisherModel`.
final class ExportPublisherModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportPublisherModelRequest';

  /// Required. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  final String name;

  /// Required. The target where we are exporting the model weights to
  final GcsDestination? destination;

  /// Required. The Location to export the model weights from
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  ExportPublisherModelRequest({
    required this.name,
    required this.destination,
    required this.parent,
  }) : super(fullyQualifiedName);

  factory ExportPublisherModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportPublisherModelRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destination: switch (json['destination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (destination != null) 'destination': destination!.toJson(),
    'parent': parent,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'parent=$parent'].join(',');
    return 'ExportPublisherModelRequest($contents)';
  }
}

/// Request message for
/// `ModelGardenService.CheckPublisherModelEula`.
final class CheckPublisherModelEulaAcceptanceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CheckPublisherModelEulaAcceptanceRequest';

  /// Required. The project requesting access for named model. The format is
  /// `projects/{project}`.
  final String parent;

  /// Required. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}`
  final String publisherModel;

  CheckPublisherModelEulaAcceptanceRequest({
    required this.parent,
    required this.publisherModel,
  }) : super(fullyQualifiedName);

  factory CheckPublisherModelEulaAcceptanceRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CheckPublisherModelEulaAcceptanceRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      publisherModel: switch (json['publisherModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent, 'publisherModel': publisherModel};

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'publisherModel=$publisherModel',
    ].join(',');
    return 'CheckPublisherModelEulaAcceptanceRequest($contents)';
  }
}

/// Request message for
/// `ModelGardenService.AcceptPublisherModelEula`.
final class AcceptPublisherModelEulaRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AcceptPublisherModelEulaRequest';

  /// Required. The project requesting access for named model. The format is
  /// `projects/{project}`.
  final String parent;

  /// Required. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}`
  final String publisherModel;

  AcceptPublisherModelEulaRequest({
    required this.parent,
    required this.publisherModel,
  }) : super(fullyQualifiedName);

  factory AcceptPublisherModelEulaRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AcceptPublisherModelEulaRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      publisherModel: switch (json['publisherModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent, 'publisherModel': publisherModel};

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'publisherModel=$publisherModel',
    ].join(',');
    return 'AcceptPublisherModelEulaRequest($contents)';
  }
}

/// Response message for
/// `ModelGardenService.UpdatePublisherModelEula`.
final class PublisherModelEulaAcceptance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModelEulaAcceptance';

  /// The project number requesting access for named model.
  final int projectNumber;

  /// The publisher model resource name.
  final String publisherModel;

  /// The EULA content acceptance status.
  final bool publisherModelEulaAcked;

  PublisherModelEulaAcceptance({
    this.projectNumber = 0,
    this.publisherModel = '',
    this.publisherModelEulaAcked = false,
  }) : super(fullyQualifiedName);

  factory PublisherModelEulaAcceptance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModelEulaAcceptance(
      projectNumber: switch (json['projectNumber']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      publisherModel: switch (json['publisherModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      publisherModelEulaAcked: switch (json['publisherModelEulaAcked']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (projectNumber.isNotDefault) 'projectNumber': encodeInt64(projectNumber),
    if (publisherModel.isNotDefault) 'publisherModel': publisherModel,
    if (publisherModelEulaAcked.isNotDefault)
      'publisherModelEulaAcked': publisherModelEulaAcked,
  };

  @override
  String toString() {
    final contents = [
      'projectNumber=$projectNumber',
      'publisherModel=$publisherModel',
      'publisherModelEulaAcked=$publisherModelEulaAcked',
    ].join(',');
    return 'PublisherModelEulaAcceptance($contents)';
  }
}

/// Vertex AI Model Monitoring Service serves as a central hub for the analysis
/// and visualization of data quality and performance related to models.
/// ModelMonitor stands as a top level resource for overseeing your model
/// monitoring tasks.
final class ModelMonitor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitor';

  /// Optional default tabular model monitoring objective.
  final ModelMonitoringObjectiveSpec_TabularObjective? tabularObjective;

  /// Immutable. Resource name of the ModelMonitor. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`.
  final String name;

  /// The display name of the ModelMonitor.
  /// The name can be up to 128 characters long and can consist of any UTF-8.
  final String displayName;

  /// The entity that is subject to analysis.
  /// Currently only models in Vertex AI Model Registry are supported. If you
  /// want to analyze the model which is outside the Vertex AI, you could
  /// register a model in Vertex AI Model Registry using just a display name.
  final ModelMonitor_ModelMonitoringTarget? modelMonitoringTarget;

  /// Optional training dataset used to train the model.
  /// It can serve as a reference dataset to identify changes in production.
  final ModelMonitoringInput? trainingDataset;

  /// Optional default notification spec, it can be overridden in the
  /// ModelMonitoringJob notification spec.
  final ModelMonitoringNotificationSpec? notificationSpec;

  /// Optional default monitoring metrics/logs export spec, it can be overridden
  /// in the ModelMonitoringJob output spec.
  /// If not specified, a default Google Cloud Storage bucket will be created
  /// under your project.
  final ModelMonitoringOutputSpec? outputSpec;

  /// Optional model explanation spec. It is used for feature attribution
  /// monitoring.
  final ExplanationSpec? explanationSpec;

  /// Monitoring Schema is to specify the model's features, prediction outputs
  /// and ground truth properties. It is used to extract pertinent data from the
  /// dataset and to process features based on their properties.
  /// Make sure that the schema aligns with your dataset, if it does not, we will
  /// be unable to extract data from the dataset.
  /// It is required for most models, but optional for Vertex AI AutoML Tables
  /// unless the schem information is not available.
  final ModelMonitoringSchema? modelMonitoringSchema;

  /// Customer-managed encryption key spec for a ModelMonitor. If
  /// set, this ModelMonitor and all sub-resources of this
  /// ModelMonitor will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Timestamp when this ModelMonitor was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ModelMonitor was updated most recently.
  final protobuf.Timestamp? updateTime;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  ModelMonitor({
    this.tabularObjective,
    this.name = '',
    this.displayName = '',
    this.modelMonitoringTarget,
    this.trainingDataset,
    this.notificationSpec,
    this.outputSpec,
    this.explanationSpec,
    this.modelMonitoringSchema,
    this.encryptionSpec,
    this.createTime,
    this.updateTime,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory ModelMonitor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitor(
      tabularObjective: switch (json['tabularObjective']) {
        null => null,
        Object $1 => ModelMonitoringObjectiveSpec_TabularObjective.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelMonitoringTarget: switch (json['modelMonitoringTarget']) {
        null => null,
        Object $1 => ModelMonitor_ModelMonitoringTarget.fromJson($1),
      },
      trainingDataset: switch (json['trainingDataset']) {
        null => null,
        Object $1 => ModelMonitoringInput.fromJson($1),
      },
      notificationSpec: switch (json['notificationSpec']) {
        null => null,
        Object $1 => ModelMonitoringNotificationSpec.fromJson($1),
      },
      outputSpec: switch (json['outputSpec']) {
        null => null,
        Object $1 => ModelMonitoringOutputSpec.fromJson($1),
      },
      explanationSpec: switch (json['explanationSpec']) {
        null => null,
        Object $1 => ExplanationSpec.fromJson($1),
      },
      modelMonitoringSchema: switch (json['modelMonitoringSchema']) {
        null => null,
        Object $1 => ModelMonitoringSchema.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tabularObjective != null)
      'tabularObjective': tabularObjective!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (modelMonitoringTarget != null)
      'modelMonitoringTarget': modelMonitoringTarget!.toJson(),
    if (trainingDataset != null) 'trainingDataset': trainingDataset!.toJson(),
    if (notificationSpec != null)
      'notificationSpec': notificationSpec!.toJson(),
    if (outputSpec != null) 'outputSpec': outputSpec!.toJson(),
    if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
    if (modelMonitoringSchema != null)
      'modelMonitoringSchema': modelMonitoringSchema!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'ModelMonitor($contents)';
  }
}

/// The monitoring target refers to the entity that is subject to analysis.
/// e.g. Vertex AI Model version.
final class ModelMonitor_ModelMonitoringTarget extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitor.ModelMonitoringTarget';

  /// Model in Vertex AI Model Registry.
  final ModelMonitor_ModelMonitoringTarget_VertexModelSource? vertexModel;

  ModelMonitor_ModelMonitoringTarget({this.vertexModel})
    : super(fullyQualifiedName);

  factory ModelMonitor_ModelMonitoringTarget.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitor_ModelMonitoringTarget(
      vertexModel: switch (json['vertexModel']) {
        null => null,
        Object $1 =>
          ModelMonitor_ModelMonitoringTarget_VertexModelSource.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vertexModel != null) 'vertexModel': vertexModel!.toJson(),
  };

  @override
  String toString() => 'ModelMonitoringTarget()';
}

/// Model in Vertex AI Model Registry.
final class ModelMonitor_ModelMonitoringTarget_VertexModelSource
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitor.ModelMonitoringTarget.VertexModelSource';

  /// Model resource name. Format:
  /// projects/{project}/locations/{location}/models/{model}.
  final String model;

  /// Model version id.
  final String modelVersionId;

  ModelMonitor_ModelMonitoringTarget_VertexModelSource({
    this.model = '',
    this.modelVersionId = '',
  }) : super(fullyQualifiedName);

  factory ModelMonitor_ModelMonitoringTarget_VertexModelSource.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitor_ModelMonitoringTarget_VertexModelSource(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersionId: switch (json['modelVersionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (model.isNotDefault) 'model': model,
    if (modelVersionId.isNotDefault) 'modelVersionId': modelVersionId,
  };

  @override
  String toString() {
    final contents = [
      'model=$model',
      'modelVersionId=$modelVersionId',
    ].join(',');
    return 'VertexModelSource($contents)';
  }
}

/// The Model Monitoring Schema definition.
final class ModelMonitoringSchema extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringSchema';

  /// Feature names of the model. Vertex AI will try to match the features from
  /// your dataset as follows:
  ///  * For 'csv' files, the header names are required, and we will extract the
  ///    corresponding feature values when the header names align with the
  ///    feature names.
  ///  * For 'jsonl' files, we will extract the corresponding feature values if
  ///    the key names match the feature names.
  ///    Note: Nested features are not supported, so please ensure your features
  ///    are flattened. Ensure the feature values are scalar or an array of
  ///    scalars.
  ///  * For 'bigquery' dataset, we will extract the corresponding feature values
  ///    if the column names match the feature names.
  ///    Note: The column type can be a scalar or an array of scalars. STRUCT or
  ///    JSON types are not supported. You may use SQL queries to select or
  ///    aggregate the relevant features from your original table. However,
  ///    ensure that the 'schema' of the query results meets our requirements.
  ///  * For the Vertex AI Endpoint Request Response Logging table or Vertex AI
  ///    Batch Prediction Job results. If the
  ///    `instance_type`
  ///    is an array, ensure that the sequence in
  ///    `feature_fields`
  ///    matches the order of features in the prediction instance. We will match
  ///    the feature with the array in the order specified in [feature_fields].
  final List<ModelMonitoringSchema_FieldSchema> featureFields;

  /// Prediction output names of the model. The requirements are the same as the
  /// `feature_fields`.
  /// For AutoML Tables, the prediction output name presented in schema will be:
  /// `predicted_{target_column}`, the `target_column` is the one you specified
  /// when you train the model.
  /// For Prediction output drift analysis:
  ///  * AutoML Classification, the distribution of the argmax label will be
  ///    analyzed.
  ///  * AutoML Regression, the distribution of the value will be analyzed.
  final List<ModelMonitoringSchema_FieldSchema> predictionFields;

  /// Target /ground truth names of the model.
  final List<ModelMonitoringSchema_FieldSchema> groundTruthFields;

  ModelMonitoringSchema({
    this.featureFields = const [],
    this.predictionFields = const [],
    this.groundTruthFields = const [],
  }) : super(fullyQualifiedName);

  factory ModelMonitoringSchema.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringSchema(
      featureFields: switch (json['featureFields']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringSchema_FieldSchema.fromJson(i),
        ],
        _ => throw const FormatException('"featureFields" is not a list'),
      },
      predictionFields: switch (json['predictionFields']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringSchema_FieldSchema.fromJson(i),
        ],
        _ => throw const FormatException('"predictionFields" is not a list'),
      },
      groundTruthFields: switch (json['groundTruthFields']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringSchema_FieldSchema.fromJson(i),
        ],
        _ => throw const FormatException('"groundTruthFields" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureFields.isNotDefault) 'featureFields': encodeList(featureFields),
    if (predictionFields.isNotDefault)
      'predictionFields': encodeList(predictionFields),
    if (groundTruthFields.isNotDefault)
      'groundTruthFields': encodeList(groundTruthFields),
  };

  @override
  String toString() => 'ModelMonitoringSchema()';
}

/// Schema field definition.
final class ModelMonitoringSchema_FieldSchema extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringSchema.FieldSchema';

  /// Field name.
  final String name;

  /// Supported data types are:
  /// `float`
  /// `integer`
  /// `boolean`
  /// `string`
  /// `categorical`
  final String dataType;

  /// Describes if the schema field is an array of given data type.
  final bool repeated;

  ModelMonitoringSchema_FieldSchema({
    this.name = '',
    this.dataType = '',
    this.repeated = false,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringSchema_FieldSchema.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringSchema_FieldSchema(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataType: switch (json['dataType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      repeated: switch (json['repeated']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (dataType.isNotDefault) 'dataType': dataType,
    if (repeated.isNotDefault) 'repeated': repeated,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'dataType=$dataType',
      'repeated=$repeated',
    ].join(',');
    return 'FieldSchema($contents)';
  }
}

/// The model monitoring configuration used for Batch Prediction Job.
final class ModelMonitoringConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringConfig';

  /// Model monitoring objective config.
  final List<ModelMonitoringObjectiveConfig> objectiveConfigs;

  /// Model monitoring alert config.
  final ModelMonitoringAlertConfig? alertConfig;

  /// YAML schema file uri in Cloud Storage describing the format of a single
  /// instance that you want Tensorflow Data Validation (TFDV) to analyze.
  ///
  /// If there are any data type differences between predict instance and TFDV
  /// instance, this field can be used to override the schema.
  /// For models trained with Vertex AI, this field must be set as all the
  /// fields in predict instance formatted as string.
  final String analysisInstanceSchemaUri;

  /// A Google Cloud Storage location for batch prediction model monitoring to
  /// dump statistics and anomalies.
  /// If not provided, a folder will be created in customer project to hold
  /// statistics and anomalies.
  final GcsDestination? statsAnomaliesBaseDirectory;

  ModelMonitoringConfig({
    this.objectiveConfigs = const [],
    this.alertConfig,
    this.analysisInstanceSchemaUri = '',
    this.statsAnomaliesBaseDirectory,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringConfig(
      objectiveConfigs: switch (json['objectiveConfigs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringObjectiveConfig.fromJson(i),
        ],
        _ => throw const FormatException('"objectiveConfigs" is not a list'),
      },
      alertConfig: switch (json['alertConfig']) {
        null => null,
        Object $1 => ModelMonitoringAlertConfig.fromJson($1),
      },
      analysisInstanceSchemaUri: switch (json['analysisInstanceSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      statsAnomaliesBaseDirectory:
          switch (json['statsAnomaliesBaseDirectory']) {
            null => null,
            Object $1 => GcsDestination.fromJson($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (objectiveConfigs.isNotDefault)
      'objectiveConfigs': encodeList(objectiveConfigs),
    if (alertConfig != null) 'alertConfig': alertConfig!.toJson(),
    if (analysisInstanceSchemaUri.isNotDefault)
      'analysisInstanceSchemaUri': analysisInstanceSchemaUri,
    if (statsAnomaliesBaseDirectory != null)
      'statsAnomaliesBaseDirectory': statsAnomaliesBaseDirectory!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'analysisInstanceSchemaUri=$analysisInstanceSchemaUri',
    ].join(',');
    return 'ModelMonitoringConfig($contents)';
  }
}

/// The objective configuration for model monitoring, including the information
/// needed to detect anomalies for one particular model.
final class ModelMonitoringObjectiveConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig';

  /// Training dataset for models. This field has to be set only if
  /// TrainingPredictionSkewDetectionConfig is specified.
  final ModelMonitoringObjectiveConfig_TrainingDataset? trainingDataset;

  /// The config for skew between training data and prediction data.
  final ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig?
  trainingPredictionSkewDetectionConfig;

  /// The config for drift of prediction data.
  final ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig?
  predictionDriftDetectionConfig;

  /// The config for integrating with Vertex Explainable AI.
  final ModelMonitoringObjectiveConfig_ExplanationConfig? explanationConfig;

  ModelMonitoringObjectiveConfig({
    this.trainingDataset,
    this.trainingPredictionSkewDetectionConfig,
    this.predictionDriftDetectionConfig,
    this.explanationConfig,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveConfig(
      trainingDataset: switch (json['trainingDataset']) {
        null => null,
        Object $1 => ModelMonitoringObjectiveConfig_TrainingDataset.fromJson(
          $1,
        ),
      },
      trainingPredictionSkewDetectionConfig:
          switch (json['trainingPredictionSkewDetectionConfig']) {
            null => null,
            Object $1 =>
              ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig.fromJson(
                $1,
              ),
          },
      predictionDriftDetectionConfig:
          switch (json['predictionDriftDetectionConfig']) {
            null => null,
            Object $1 =>
              ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.fromJson(
                $1,
              ),
          },
      explanationConfig: switch (json['explanationConfig']) {
        null => null,
        Object $1 => ModelMonitoringObjectiveConfig_ExplanationConfig.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (trainingDataset != null) 'trainingDataset': trainingDataset!.toJson(),
    if (trainingPredictionSkewDetectionConfig != null)
      'trainingPredictionSkewDetectionConfig':
          trainingPredictionSkewDetectionConfig!.toJson(),
    if (predictionDriftDetectionConfig != null)
      'predictionDriftDetectionConfig': predictionDriftDetectionConfig!
          .toJson(),
    if (explanationConfig != null)
      'explanationConfig': explanationConfig!.toJson(),
  };

  @override
  String toString() => 'ModelMonitoringObjectiveConfig()';
}

/// Training Dataset information.
final class ModelMonitoringObjectiveConfig_TrainingDataset
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.TrainingDataset';

  /// The resource name of the Dataset used to train this Model.
  final String? dataset;

  /// The Google Cloud Storage uri of the unmanaged Dataset used to train
  /// this Model.
  final GcsSource? gcsSource;

  /// The BigQuery table of the unmanaged Dataset used to train this
  /// Model.
  final BigQuerySource? bigquerySource;

  /// Data format of the dataset, only applicable if the input is from
  /// Google Cloud Storage.
  /// The possible formats are:
  ///
  /// "tf-record"
  /// The source file is a TFRecord file.
  ///
  /// "csv"
  /// The source file is a CSV file.
  /// "jsonl"
  /// The source file is a JSONL file.
  final String dataFormat;

  /// The target field name the model is to predict.
  /// This field will be excluded when doing Predict and (or) Explain for the
  /// training data.
  final String targetField;

  /// Strategy to sample data from Training Dataset.
  /// If not set, we process the whole dataset.
  final SamplingStrategy? loggingSamplingStrategy;

  ModelMonitoringObjectiveConfig_TrainingDataset({
    this.dataset,
    this.gcsSource,
    this.bigquerySource,
    this.dataFormat = '',
    this.targetField = '',
    this.loggingSamplingStrategy,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_TrainingDataset.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveConfig_TrainingDataset(
      dataset: switch (json['dataset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      bigquerySource: switch (json['bigquerySource']) {
        null => null,
        Object $1 => BigQuerySource.fromJson($1),
      },
      dataFormat: switch (json['dataFormat']) {
        null => '',
        Object $1 => decodeString($1),
      },
      targetField: switch (json['targetField']) {
        null => '',
        Object $1 => decodeString($1),
      },
      loggingSamplingStrategy: switch (json['loggingSamplingStrategy']) {
        null => null,
        Object $1 => SamplingStrategy.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataset != null) 'dataset': dataset,
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
    if (dataFormat.isNotDefault) 'dataFormat': dataFormat,
    if (targetField.isNotDefault) 'targetField': targetField,
    if (loggingSamplingStrategy != null)
      'loggingSamplingStrategy': loggingSamplingStrategy!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (dataset != null) 'dataset=$dataset',
      'dataFormat=$dataFormat',
      'targetField=$targetField',
    ].join(',');
    return 'TrainingDataset($contents)';
  }
}

/// The config for Training & Prediction data skew detection. It specifies the
/// training dataset sources and the skew detection parameters.
final class ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig';

  /// Key is the feature name and value is the threshold. If a feature needs to
  /// be monitored for skew, a value threshold must be configured for that
  /// feature. The threshold here is against feature distribution distance
  /// between the training and prediction feature.
  final Map<String, ThresholdConfig> skewThresholds;

  /// Key is the feature name and value is the threshold. The threshold here is
  /// against attribution score distance between the training and prediction
  /// feature.
  final Map<String, ThresholdConfig> attributionScoreSkewThresholds;

  /// Skew anomaly detection threshold used by all features.
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  final ThresholdConfig? defaultSkewThreshold;

  ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig({
    this.skewThresholds = const {},
    this.attributionScoreSkewThresholds = const {},
    this.defaultSkewThreshold,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig(
      skewThresholds: switch (json['skewThresholds']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ThresholdConfig.fromJson(e.value),
        },
        _ => throw const FormatException('"skewThresholds" is not an object'),
      },
      attributionScoreSkewThresholds:
          switch (json['attributionScoreSkewThresholds']) {
            null => {},
            Map<String, Object?> $1 => {
              for (final e in $1.entries)
                decodeString(e.key): ThresholdConfig.fromJson(e.value),
            },
            _ => throw const FormatException(
              '"attributionScoreSkewThresholds" is not an object',
            ),
          },
      defaultSkewThreshold: switch (json['defaultSkewThreshold']) {
        null => null,
        Object $1 => ThresholdConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (skewThresholds.isNotDefault)
      'skewThresholds': encodeMap(skewThresholds),
    if (attributionScoreSkewThresholds.isNotDefault)
      'attributionScoreSkewThresholds': encodeMap(
        attributionScoreSkewThresholds,
      ),
    if (defaultSkewThreshold != null)
      'defaultSkewThreshold': defaultSkewThreshold!.toJson(),
  };

  @override
  String toString() => 'TrainingPredictionSkewDetectionConfig()';
}

/// The config for Prediction data drift detection.
final class ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig';

  /// Key is the feature name and value is the threshold. If a feature needs to
  /// be monitored for drift, a value threshold must be configured for that
  /// feature. The threshold here is against feature distribution distance
  /// between different time windws.
  final Map<String, ThresholdConfig> driftThresholds;

  /// Key is the feature name and value is the threshold. The threshold here is
  /// against attribution score distance between different time windows.
  final Map<String, ThresholdConfig> attributionScoreDriftThresholds;

  /// Drift anomaly detection threshold used by all features.
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  final ThresholdConfig? defaultDriftThreshold;

  ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig({
    this.driftThresholds = const {},
    this.attributionScoreDriftThresholds = const {},
    this.defaultDriftThreshold,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig(
      driftThresholds: switch (json['driftThresholds']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ThresholdConfig.fromJson(e.value),
        },
        _ => throw const FormatException('"driftThresholds" is not an object'),
      },
      attributionScoreDriftThresholds:
          switch (json['attributionScoreDriftThresholds']) {
            null => {},
            Map<String, Object?> $1 => {
              for (final e in $1.entries)
                decodeString(e.key): ThresholdConfig.fromJson(e.value),
            },
            _ => throw const FormatException(
              '"attributionScoreDriftThresholds" is not an object',
            ),
          },
      defaultDriftThreshold: switch (json['defaultDriftThreshold']) {
        null => null,
        Object $1 => ThresholdConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (driftThresholds.isNotDefault)
      'driftThresholds': encodeMap(driftThresholds),
    if (attributionScoreDriftThresholds.isNotDefault)
      'attributionScoreDriftThresholds': encodeMap(
        attributionScoreDriftThresholds,
      ),
    if (defaultDriftThreshold != null)
      'defaultDriftThreshold': defaultDriftThreshold!.toJson(),
  };

  @override
  String toString() => 'PredictionDriftDetectionConfig()';
}

/// The config for integrating with Vertex Explainable AI. Only applicable if
/// the Model has explanation_spec populated.
final class ModelMonitoringObjectiveConfig_ExplanationConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.ExplanationConfig';

  /// If want to analyze the Vertex Explainable AI feature attribute scores or
  /// not. If set to true, Vertex AI will log the feature attributions from
  /// explain response and do the skew/drift detection for them.
  final bool enableFeatureAttributes;

  /// Predictions generated by the BatchPredictionJob using baseline dataset.
  final ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline?
  explanationBaseline;

  ModelMonitoringObjectiveConfig_ExplanationConfig({
    this.enableFeatureAttributes = false,
    this.explanationBaseline,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_ExplanationConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveConfig_ExplanationConfig(
      enableFeatureAttributes: switch (json['enableFeatureAttributes']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      explanationBaseline: switch (json['explanationBaseline']) {
        null => null,
        Object $1 =>
          ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (enableFeatureAttributes.isNotDefault)
      'enableFeatureAttributes': enableFeatureAttributes,
    if (explanationBaseline != null)
      'explanationBaseline': explanationBaseline!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'enableFeatureAttributes=$enableFeatureAttributes',
    ].join(',');
    return 'ExplanationConfig($contents)';
  }
}

/// Output from
/// `BatchPredictionJob`
/// for Model Monitoring baseline dataset, which can be used to generate
/// baseline attribution scores.
final class ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline';

  /// Cloud Storage location for BatchExplain output.
  final GcsDestination? gcs;

  /// BigQuery location for BatchExplain output.
  final BigQueryDestination? bigquery;

  /// The storage format of the predictions generated BatchPrediction job.
  final ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat
  predictionFormat;

  ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline({
    this.gcs,
    this.bigquery,
    this.predictionFormat =
        ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat
            .$default,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline(
      gcs: switch (json['gcs']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      bigquery: switch (json['bigquery']) {
        null => null,
        Object $1 => BigQueryDestination.fromJson($1),
      },
      predictionFormat: switch (json['predictionFormat']) {
        null =>
          ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat
              .$default,
        Object $1 =>
          ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcs != null) 'gcs': gcs!.toJson(),
    if (bigquery != null) 'bigquery': bigquery!.toJson(),
    if (predictionFormat.isNotDefault)
      'predictionFormat': predictionFormat.toJson(),
  };

  @override
  String toString() {
    final contents = ['predictionFormat=$predictionFormat'].join(',');
    return 'ExplanationBaseline($contents)';
  }
}

/// The storage format of the predictions generated BatchPrediction job.
final class ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat
    extends ProtoEnum {
  /// Should not be set.
  static const predictionFormatUnspecified =
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
        'PREDICTION_FORMAT_UNSPECIFIED',
      );

  /// Predictions are in JSONL files.
  static const jsonl =
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
        'JSONL',
      );

  /// Predictions are in BigQuery.
  static const bigquery =
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
        'BIGQUERY',
      );

  /// The default value for [ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat].
  static const $default = predictionFormatUnspecified;

  const ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
    super.value,
  );

  factory ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.fromJson(
    Object? json,
  ) =>
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
        json as String,
      );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PredictionFormat.$value';
}

/// The alert config for model monitoring.
final class ModelMonitoringAlertConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAlertConfig';

  /// Email alert config.
  final ModelMonitoringAlertConfig_EmailAlertConfig? emailAlertConfig;

  /// Dump the anomalies to Cloud Logging. The anomalies will be put to json
  /// payload encoded from proto
  /// `google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry`.
  /// This can be further sinked to Pub/Sub or any other services supported
  /// by Cloud Logging.
  final bool enableLogging;

  /// Resource names of the NotificationChannels to send alert.
  /// Must be of the format
  /// `projects/<project_id_or_number>/notificationChannels/<channel_id>`
  final List<String> notificationChannels;

  ModelMonitoringAlertConfig({
    this.emailAlertConfig,
    this.enableLogging = false,
    this.notificationChannels = const [],
  }) : super(fullyQualifiedName);

  factory ModelMonitoringAlertConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringAlertConfig(
      emailAlertConfig: switch (json['emailAlertConfig']) {
        null => null,
        Object $1 => ModelMonitoringAlertConfig_EmailAlertConfig.fromJson($1),
      },
      enableLogging: switch (json['enableLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      notificationChannels: switch (json['notificationChannels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"notificationChannels" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (emailAlertConfig != null)
      'emailAlertConfig': emailAlertConfig!.toJson(),
    if (enableLogging.isNotDefault) 'enableLogging': enableLogging,
    if (notificationChannels.isNotDefault)
      'notificationChannels': notificationChannels,
  };

  @override
  String toString() {
    final contents = ['enableLogging=$enableLogging'].join(',');
    return 'ModelMonitoringAlertConfig($contents)';
  }
}

/// The config for email alert.
final class ModelMonitoringAlertConfig_EmailAlertConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAlertConfig.EmailAlertConfig';

  /// The email addresses to send the alert.
  final List<String> userEmails;

  ModelMonitoringAlertConfig_EmailAlertConfig({this.userEmails = const []})
    : super(fullyQualifiedName);

  factory ModelMonitoringAlertConfig_EmailAlertConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringAlertConfig_EmailAlertConfig(
      userEmails: switch (json['userEmails']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"userEmails" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (userEmails.isNotDefault) 'userEmails': userEmails};

  @override
  String toString() => 'EmailAlertConfig()';
}

/// The config for feature monitoring threshold.
final class ThresholdConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ThresholdConfig';

  /// Specify a threshold value that can trigger the alert.
  /// If this threshold config is for feature distribution distance:
  ///   1. For categorical feature, the distribution distance is calculated by
  ///      L-inifinity norm.
  ///   2. For numerical feature, the distribution distance is calculated by
  ///      JensenShannon divergence.
  /// Each feature must have a non-zero threshold if they need to be monitored.
  /// Otherwise no alert will be triggered for that feature.
  final double? value;

  ThresholdConfig({this.value}) : super(fullyQualifiedName);

  factory ThresholdConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ThresholdConfig(
      value: switch (json['value']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (value != null) 'value': encodeDouble(value)};

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'ThresholdConfig($contents)';
  }
}

/// Sampling Strategy for logging, can be for both training and prediction
/// dataset.
final class SamplingStrategy extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SamplingStrategy';

  /// Random sample config. Will support more sampling strategies later.
  final SamplingStrategy_RandomSampleConfig? randomSampleConfig;

  SamplingStrategy({this.randomSampleConfig}) : super(fullyQualifiedName);

  factory SamplingStrategy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SamplingStrategy(
      randomSampleConfig: switch (json['randomSampleConfig']) {
        null => null,
        Object $1 => SamplingStrategy_RandomSampleConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (randomSampleConfig != null)
      'randomSampleConfig': randomSampleConfig!.toJson(),
  };

  @override
  String toString() => 'SamplingStrategy()';
}

/// Requests are randomly selected.
final class SamplingStrategy_RandomSampleConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SamplingStrategy.RandomSampleConfig';

  /// Sample rate (0, 1]
  final double sampleRate;

  SamplingStrategy_RandomSampleConfig({this.sampleRate = 0})
    : super(fullyQualifiedName);

  factory SamplingStrategy_RandomSampleConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SamplingStrategy_RandomSampleConfig(
      sampleRate: switch (json['sampleRate']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sampleRate.isNotDefault) 'sampleRate': encodeDouble(sampleRate),
  };

  @override
  String toString() {
    final contents = ['sampleRate=$sampleRate'].join(',');
    return 'RandomSampleConfig($contents)';
  }
}

/// Monitoring alert triggered condition.
final class ModelMonitoringAlertCondition extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAlertCondition';

  /// A condition that compares a stats value against a threshold. Alert will
  /// be triggered if value above the threshold.
  final double? threshold;

  ModelMonitoringAlertCondition({this.threshold}) : super(fullyQualifiedName);

  factory ModelMonitoringAlertCondition.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringAlertCondition(
      threshold: switch (json['threshold']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (threshold != null) 'threshold': encodeDouble(threshold),
  };

  @override
  String toString() {
    final contents = [if (threshold != null) 'threshold=$threshold'].join(',');
    return 'ModelMonitoringAlertCondition($contents)';
  }
}

/// Represents a single model monitoring anomaly.
final class ModelMonitoringAnomaly extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAnomaly';

  /// Tabular anomaly.
  final ModelMonitoringAnomaly_TabularAnomaly? tabularAnomaly;

  /// Model monitoring job resource name.
  final String modelMonitoringJob;

  /// Algorithm used to calculated the metrics, eg: jensen_shannon_divergence,
  /// l_infinity.
  final String algorithm;

  ModelMonitoringAnomaly({
    this.tabularAnomaly,
    this.modelMonitoringJob = '',
    this.algorithm = '',
  }) : super(fullyQualifiedName);

  factory ModelMonitoringAnomaly.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringAnomaly(
      tabularAnomaly: switch (json['tabularAnomaly']) {
        null => null,
        Object $1 => ModelMonitoringAnomaly_TabularAnomaly.fromJson($1),
      },
      modelMonitoringJob: switch (json['modelMonitoringJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      algorithm: switch (json['algorithm']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tabularAnomaly != null) 'tabularAnomaly': tabularAnomaly!.toJson(),
    if (modelMonitoringJob.isNotDefault)
      'modelMonitoringJob': modelMonitoringJob,
    if (algorithm.isNotDefault) 'algorithm': algorithm,
  };

  @override
  String toString() {
    final contents = [
      'modelMonitoringJob=$modelMonitoringJob',
      'algorithm=$algorithm',
    ].join(',');
    return 'ModelMonitoringAnomaly($contents)';
  }
}

/// Tabular anomaly details.
final class ModelMonitoringAnomaly_TabularAnomaly extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAnomaly.TabularAnomaly';

  /// Additional anomaly information. e.g. Google Cloud Storage uri.
  final String anomalyUri;

  /// Overview of this anomaly.
  final String summary;

  /// Anomaly body.
  final protobuf.Value? anomaly;

  /// The time the anomaly was triggered.
  final protobuf.Timestamp? triggerTime;

  /// The alert condition associated with this anomaly.
  final ModelMonitoringAlertCondition? condition;

  ModelMonitoringAnomaly_TabularAnomaly({
    this.anomalyUri = '',
    this.summary = '',
    this.anomaly,
    this.triggerTime,
    this.condition,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringAnomaly_TabularAnomaly.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringAnomaly_TabularAnomaly(
      anomalyUri: switch (json['anomalyUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      summary: switch (json['summary']) {
        null => '',
        Object $1 => decodeString($1),
      },
      anomaly: switch (json['anomaly']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      triggerTime: switch (json['triggerTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      condition: switch (json['condition']) {
        null => null,
        Object $1 => ModelMonitoringAlertCondition.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (anomalyUri.isNotDefault) 'anomalyUri': anomalyUri,
    if (summary.isNotDefault) 'summary': summary,
    if (anomaly != null) 'anomaly': anomaly!.toJson(),
    if (triggerTime != null) 'triggerTime': triggerTime!.toJson(),
    if (condition != null) 'condition': condition!.toJson(),
  };

  @override
  String toString() {
    final contents = ['anomalyUri=$anomalyUri', 'summary=$summary'].join(',');
    return 'TabularAnomaly($contents)';
  }
}

/// Represents a single monitoring alert. This is currently used in the
/// SearchModelMonitoringAlerts api, thus the alert wrapped in this message
/// belongs to the resource asked in the request.
final class ModelMonitoringAlert extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAlert';

  /// The stats name.
  final String statsName;

  /// One of the supported monitoring objectives:
  /// `raw-feature-drift`
  /// `prediction-output-drift`
  /// `feature-attribution`
  final String objectiveType;

  /// Alert creation time.
  final protobuf.Timestamp? alertTime;

  /// Anomaly details.
  final ModelMonitoringAnomaly? anomaly;

  ModelMonitoringAlert({
    this.statsName = '',
    this.objectiveType = '',
    this.alertTime,
    this.anomaly,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringAlert.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringAlert(
      statsName: switch (json['statsName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      objectiveType: switch (json['objectiveType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      alertTime: switch (json['alertTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      anomaly: switch (json['anomaly']) {
        null => null,
        Object $1 => ModelMonitoringAnomaly.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (statsName.isNotDefault) 'statsName': statsName,
    if (objectiveType.isNotDefault) 'objectiveType': objectiveType,
    if (alertTime != null) 'alertTime': alertTime!.toJson(),
    if (anomaly != null) 'anomaly': anomaly!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'statsName=$statsName',
      'objectiveType=$objectiveType',
    ].join(',');
    return 'ModelMonitoringAlert($contents)';
  }
}

/// Represents a model monitoring job that analyze dataset using different
/// monitoring algorithm.
final class ModelMonitoringJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringJob';

  /// Output only. Resource name of a ModelMonitoringJob. Format:
  /// `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
  final String name;

  /// The display name of the ModelMonitoringJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8.
  final String displayName;

  /// Monitoring monitoring job spec. It outlines the specifications for
  /// monitoring objectives, notifications, and result exports. If left blank,
  /// the default monitoring specifications from the top-level resource
  /// 'ModelMonitor' will be applied. If provided, we will use the specification
  /// defined here rather than the default one.
  final ModelMonitoringSpec? modelMonitoringSpec;

  /// Output only. Timestamp when this ModelMonitoringJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ModelMonitoringJob was updated most
  /// recently.
  final protobuf.Timestamp? updateTime;

  /// Output only. The state of the monitoring job.
  ///  * When the job is still creating, the state will be 'JOB_STATE_PENDING'.
  ///  * Once the job is successfully created, the state will be
  ///    'JOB_STATE_RUNNING'.
  ///  * Once the job is finished, the state will be one of
  ///    'JOB_STATE_FAILED', 'JOB_STATE_SUCCEEDED',
  ///    'JOB_STATE_PARTIALLY_SUCCEEDED'.
  final JobState state;

  /// Output only. Schedule resource name. It will only appear when this job is
  /// triggered by a schedule.
  final String schedule;

  /// Output only. Execution results for all the monitoring objectives.
  final ModelMonitoringJobExecutionDetail? jobExecutionDetail;

  /// Output only. Timestamp when this ModelMonitoringJob was scheduled. It will
  /// only appear when this job is triggered by a schedule.
  final protobuf.Timestamp? scheduleTime;

  ModelMonitoringJob({
    this.name = '',
    this.displayName = '',
    this.modelMonitoringSpec,
    this.createTime,
    this.updateTime,
    this.state = JobState.$default,
    this.schedule = '',
    this.jobExecutionDetail,
    this.scheduleTime,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelMonitoringSpec: switch (json['modelMonitoringSpec']) {
        null => null,
        Object $1 => ModelMonitoringSpec.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      state: switch (json['state']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      schedule: switch (json['schedule']) {
        null => '',
        Object $1 => decodeString($1),
      },
      jobExecutionDetail: switch (json['jobExecutionDetail']) {
        null => null,
        Object $1 => ModelMonitoringJobExecutionDetail.fromJson($1),
      },
      scheduleTime: switch (json['scheduleTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (modelMonitoringSpec != null)
      'modelMonitoringSpec': modelMonitoringSpec!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (schedule.isNotDefault) 'schedule': schedule,
    if (jobExecutionDetail != null)
      'jobExecutionDetail': jobExecutionDetail!.toJson(),
    if (scheduleTime != null) 'scheduleTime': scheduleTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'state=$state',
      'schedule=$schedule',
    ].join(',');
    return 'ModelMonitoringJob($contents)';
  }
}

/// Represent the execution details of the job.
final class ModelMonitoringJobExecutionDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringJobExecutionDetail';

  /// Processed baseline datasets.
  final List<ModelMonitoringJobExecutionDetail_ProcessedDataset>
  baselineDatasets;

  /// Processed target datasets.
  final List<ModelMonitoringJobExecutionDetail_ProcessedDataset> targetDatasets;

  /// Status of data processing for each monitoring objective.
  /// Key is the objective.
  final Map<String, Status> objectiveStatus;

  /// Additional job error status.
  final Status? error;

  ModelMonitoringJobExecutionDetail({
    this.baselineDatasets = const [],
    this.targetDatasets = const [],
    this.objectiveStatus = const {},
    this.error,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringJobExecutionDetail.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringJobExecutionDetail(
      baselineDatasets: switch (json['baselineDatasets']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ModelMonitoringJobExecutionDetail_ProcessedDataset.fromJson(i),
        ],
        _ => throw const FormatException('"baselineDatasets" is not a list'),
      },
      targetDatasets: switch (json['targetDatasets']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ModelMonitoringJobExecutionDetail_ProcessedDataset.fromJson(i),
        ],
        _ => throw const FormatException('"targetDatasets" is not a list'),
      },
      objectiveStatus: switch (json['objectiveStatus']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Status.fromJson(e.value),
        },
        _ => throw const FormatException('"objectiveStatus" is not an object'),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (baselineDatasets.isNotDefault)
      'baselineDatasets': encodeList(baselineDatasets),
    if (targetDatasets.isNotDefault)
      'targetDatasets': encodeList(targetDatasets),
    if (objectiveStatus.isNotDefault)
      'objectiveStatus': encodeMap(objectiveStatus),
    if (error != null) 'error': error!.toJson(),
  };

  @override
  String toString() => 'ModelMonitoringJobExecutionDetail()';
}

/// Processed dataset information.
final class ModelMonitoringJobExecutionDetail_ProcessedDataset
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringJobExecutionDetail.ProcessedDataset';

  /// Actual data location of the processed dataset.
  final String location;

  /// Dataset time range information if any.
  final Interval? timeRange;

  ModelMonitoringJobExecutionDetail_ProcessedDataset({
    this.location = '',
    this.timeRange,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringJobExecutionDetail_ProcessedDataset.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringJobExecutionDetail_ProcessedDataset(
      location: switch (json['location']) {
        null => '',
        Object $1 => decodeString($1),
      },
      timeRange: switch (json['timeRange']) {
        null => null,
        Object $1 => Interval.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (location.isNotDefault) 'location': location,
    if (timeRange != null) 'timeRange': timeRange!.toJson(),
  };

  @override
  String toString() {
    final contents = ['location=$location'].join(',');
    return 'ProcessedDataset($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.CreateModelMonitor`.
final class CreateModelMonitorRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateModelMonitorRequest';

  /// Required. The resource name of the Location to create the ModelMonitor in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The ModelMonitor to create.
  final ModelMonitor? modelMonitor;

  /// Optional. The ID to use for the Model Monitor, which will become the final
  /// component of the model monitor resource name.
  ///
  /// The maximum length is 63 characters, and valid characters are
  /// `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  final String modelMonitorId;

  CreateModelMonitorRequest({
    required this.parent,
    required this.modelMonitor,
    this.modelMonitorId = '',
  }) : super(fullyQualifiedName);

  factory CreateModelMonitorRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateModelMonitorRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelMonitor: switch (json['modelMonitor']) {
        null => null,
        Object $1 => ModelMonitor.fromJson($1),
      },
      modelMonitorId: switch (json['modelMonitorId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (modelMonitor != null) 'modelMonitor': modelMonitor!.toJson(),
    if (modelMonitorId.isNotDefault) 'modelMonitorId': modelMonitorId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'modelMonitorId=$modelMonitorId',
    ].join(',');
    return 'CreateModelMonitorRequest($contents)';
  }
}

/// Runtime operation information for
/// `ModelMonitoringService.CreateModelMonitor`.
final class CreateModelMonitorOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateModelMonitorOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateModelMonitorOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateModelMonitorOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateModelMonitorOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateModelMonitorOperationMetadata()';
}

/// Request message for
/// `ModelMonitoringService.UpdateModelMonitor`.
final class UpdateModelMonitorRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelMonitorRequest';

  /// Required. The model monitoring configuration which replaces the resource on
  /// the server.
  final ModelMonitor? modelMonitor;

  /// Required. Mask specifying which fields to update.
  final protobuf.FieldMask? updateMask;

  UpdateModelMonitorRequest({
    required this.modelMonitor,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateModelMonitorRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateModelMonitorRequest(
      modelMonitor: switch (json['modelMonitor']) {
        null => null,
        Object $1 => ModelMonitor.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelMonitor != null) 'modelMonitor': modelMonitor!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateModelMonitorRequest()';
}

/// Runtime operation information for
/// `ModelMonitoringService.UpdateModelMonitor`.
final class UpdateModelMonitorOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelMonitorOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateModelMonitorOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateModelMonitorOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateModelMonitorOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateModelMonitorOperationMetadata()';
}

/// Request message for
/// `ModelMonitoringService.GetModelMonitor`.
final class GetModelMonitorRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelMonitorRequest';

  /// Required. The name of the ModelMonitor resource.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  final String name;

  GetModelMonitorRequest({required this.name}) : super(fullyQualifiedName);

  factory GetModelMonitorRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetModelMonitorRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelMonitorRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.ListModelMonitors`.
final class ListModelMonitorsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelMonitorsRequest';

  /// Required. The resource name of the Location to list the ModelMonitors from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListModelMonitorsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelMonitorsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelMonitorsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListModelMonitorsRequest($contents)';
  }
}

/// Response message for
/// `ModelMonitoringService.ListModelMonitors`
final class ListModelMonitorsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelMonitorsResponse';

  /// List of ModelMonitor in the requested page.
  final List<ModelMonitor> modelMonitors;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListModelMonitorsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListModelMonitorsResponse({
    this.modelMonitors = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListModelMonitorsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelMonitorsResponse(
      modelMonitors: switch (json['modelMonitors']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ModelMonitor.fromJson(i)],
        _ => throw const FormatException('"modelMonitors" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelMonitors.isNotDefault) 'modelMonitors': encodeList(modelMonitors),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListModelMonitorsResponse($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.DeleteModelMonitor`.
final class DeleteModelMonitorRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelMonitorRequest';

  /// Required. The name of the ModelMonitor resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitords/{model_monitor}`
  final String name;

  /// Optional. Force delete the model monitor with schedules.
  final bool force;

  DeleteModelMonitorRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteModelMonitorRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteModelMonitorRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteModelMonitorRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.CreateModelMonitoringJob`.
final class CreateModelMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateModelMonitoringJobRequest';

  /// Required. The parent of the ModelMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  final String parent;

  /// Required. The ModelMonitoringJob to create
  final ModelMonitoringJob? modelMonitoringJob;

  /// Optional. The ID to use for the Model Monitoring Job, which will become the
  /// final component of the model monitoring job resource name.
  ///
  /// The maximum length is 63 characters, and valid characters are
  /// `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  final String modelMonitoringJobId;

  CreateModelMonitoringJobRequest({
    required this.parent,
    required this.modelMonitoringJob,
    this.modelMonitoringJobId = '',
  }) : super(fullyQualifiedName);

  factory CreateModelMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateModelMonitoringJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelMonitoringJob: switch (json['modelMonitoringJob']) {
        null => null,
        Object $1 => ModelMonitoringJob.fromJson($1),
      },
      modelMonitoringJobId: switch (json['modelMonitoringJobId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (modelMonitoringJob != null)
      'modelMonitoringJob': modelMonitoringJob!.toJson(),
    if (modelMonitoringJobId.isNotDefault)
      'modelMonitoringJobId': modelMonitoringJobId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'modelMonitoringJobId=$modelMonitoringJobId',
    ].join(',');
    return 'CreateModelMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.GetModelMonitoringJob`.
final class GetModelMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelMonitoringJobRequest';

  /// Required. The resource name of the ModelMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}/modelMonitoringJobs/{model_monitoring_job}`
  final String name;

  GetModelMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetModelMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetModelMonitoringJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.ListModelMonitoringJobs`.
final class ListModelMonitoringJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelMonitoringJobsRequest';

  /// Required. The parent of the ModelMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  final String parent;

  /// The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// Mask specifying which fields to read
  final protobuf.FieldMask? readMask;

  ListModelMonitoringJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelMonitoringJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelMonitoringJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListModelMonitoringJobsRequest($contents)';
  }
}

/// Response message for
/// `ModelMonitoringService.ListModelMonitoringJobs`.
final class ListModelMonitoringJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelMonitoringJobsResponse';

  /// A list of ModelMonitoringJobs that matches the specified filter
  /// in the request.
  final List<ModelMonitoringJob> modelMonitoringJobs;

  /// The standard List next-page token.
  final String nextPageToken;

  ListModelMonitoringJobsResponse({
    this.modelMonitoringJobs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListModelMonitoringJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelMonitoringJobsResponse(
      modelMonitoringJobs: switch (json['modelMonitoringJobs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringJob.fromJson(i),
        ],
        _ => throw const FormatException('"modelMonitoringJobs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelMonitoringJobs.isNotDefault)
      'modelMonitoringJobs': encodeList(modelMonitoringJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListModelMonitoringJobsResponse($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.DeleteModelMonitoringJob`.
final class DeleteModelMonitoringJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelMonitoringJobRequest';

  /// Required. The resource name of the model monitoring job to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}/modelMonitoringJobs/{model_monitoring_job}`
  final String name;

  DeleteModelMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteModelMonitoringJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteModelMonitoringJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteModelMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.SearchModelMonitoringStats`.
final class SearchModelMonitoringStatsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringStatsRequest';

  /// Required. ModelMonitor resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  final String modelMonitor;

  /// Filter for search different stats.
  final SearchModelMonitoringStatsFilter? statsFilter;

  /// The time interval for which results should be returned.
  final Interval? timeInterval;

  /// The standard list page size.
  final int pageSize;

  /// A page token received from a previous
  /// `ModelMonitoringService.SearchModelMonitoringStats`
  /// call.
  final String pageToken;

  SearchModelMonitoringStatsRequest({
    required this.modelMonitor,
    this.statsFilter,
    this.timeInterval,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringStatsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchModelMonitoringStatsRequest(
      modelMonitor: switch (json['modelMonitor']) {
        null => '',
        Object $1 => decodeString($1),
      },
      statsFilter: switch (json['statsFilter']) {
        null => null,
        Object $1 => SearchModelMonitoringStatsFilter.fromJson($1),
      },
      timeInterval: switch (json['timeInterval']) {
        null => null,
        Object $1 => Interval.fromJson($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'modelMonitor': modelMonitor,
    if (statsFilter != null) 'statsFilter': statsFilter!.toJson(),
    if (timeInterval != null) 'timeInterval': timeInterval!.toJson(),
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'modelMonitor=$modelMonitor',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'SearchModelMonitoringStatsRequest($contents)';
  }
}

/// Response message for
/// `ModelMonitoringService.SearchModelMonitoringStats`.
final class SearchModelMonitoringStatsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringStatsResponse';

  /// Stats retrieved for requested objectives.
  final List<ModelMonitoringStats> monitoringStats;

  /// The page token that can be used by the next
  /// `ModelMonitoringService.SearchModelMonitoringStats`
  /// call.
  final String nextPageToken;

  SearchModelMonitoringStatsResponse({
    this.monitoringStats = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringStatsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchModelMonitoringStatsResponse(
      monitoringStats: switch (json['monitoringStats']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringStats.fromJson(i),
        ],
        _ => throw const FormatException('"monitoringStats" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (monitoringStats.isNotDefault)
      'monitoringStats': encodeList(monitoringStats),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'SearchModelMonitoringStatsResponse($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.SearchModelMonitoringAlerts`.
final class SearchModelMonitoringAlertsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringAlertsRequest';

  /// Required. ModelMonitor resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  final String modelMonitor;

  /// If non-empty, returns the alerts of this model monitoring job.
  final String modelMonitoringJob;

  /// If non-empty, returns the alerts in this time interval.
  final Interval? alertTimeInterval;

  /// If non-empty, returns the alerts of this stats_name.
  final String statsName;

  /// If non-empty, returns the alerts of this objective type.
  /// Supported monitoring objectives:
  /// `raw-feature-drift`
  /// `prediction-output-drift`
  /// `feature-attribution`
  final String objectiveType;

  /// The standard list page size.
  final int pageSize;

  /// A page token received from a previous
  /// `ModelMonitoringService.SearchModelMonitoringAlerts`
  /// call.
  final String pageToken;

  SearchModelMonitoringAlertsRequest({
    required this.modelMonitor,
    this.modelMonitoringJob = '',
    this.alertTimeInterval,
    this.statsName = '',
    this.objectiveType = '',
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringAlertsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchModelMonitoringAlertsRequest(
      modelMonitor: switch (json['modelMonitor']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelMonitoringJob: switch (json['modelMonitoringJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      alertTimeInterval: switch (json['alertTimeInterval']) {
        null => null,
        Object $1 => Interval.fromJson($1),
      },
      statsName: switch (json['statsName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      objectiveType: switch (json['objectiveType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'modelMonitor': modelMonitor,
    if (modelMonitoringJob.isNotDefault)
      'modelMonitoringJob': modelMonitoringJob,
    if (alertTimeInterval != null)
      'alertTimeInterval': alertTimeInterval!.toJson(),
    if (statsName.isNotDefault) 'statsName': statsName,
    if (objectiveType.isNotDefault) 'objectiveType': objectiveType,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'modelMonitor=$modelMonitor',
      'modelMonitoringJob=$modelMonitoringJob',
      'statsName=$statsName',
      'objectiveType=$objectiveType',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'SearchModelMonitoringAlertsRequest($contents)';
  }
}

/// Response message for
/// `ModelMonitoringService.SearchModelMonitoringAlerts`.
final class SearchModelMonitoringAlertsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringAlertsResponse';

  /// Alerts retrieved for the requested objectives. Sorted by alert time
  /// descendingly.
  final List<ModelMonitoringAlert> modelMonitoringAlerts;

  /// The total number of alerts retrieved by the requested objectives.
  final int totalNumberAlerts;

  /// The page token that can be used by the next
  /// `ModelMonitoringService.SearchModelMonitoringAlerts`
  /// call.
  final String nextPageToken;

  SearchModelMonitoringAlertsResponse({
    this.modelMonitoringAlerts = const [],
    this.totalNumberAlerts = 0,
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringAlertsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchModelMonitoringAlertsResponse(
      modelMonitoringAlerts: switch (json['modelMonitoringAlerts']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringAlert.fromJson(i),
        ],
        _ => throw const FormatException(
          '"modelMonitoringAlerts" is not a list',
        ),
      },
      totalNumberAlerts: switch (json['totalNumberAlerts']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelMonitoringAlerts.isNotDefault)
      'modelMonitoringAlerts': encodeList(modelMonitoringAlerts),
    if (totalNumberAlerts.isNotDefault)
      'totalNumberAlerts': encodeInt64(totalNumberAlerts),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = [
      'totalNumberAlerts=$totalNumberAlerts',
      'nextPageToken=$nextPageToken',
    ].join(',');
    return 'SearchModelMonitoringAlertsResponse($contents)';
  }
}

/// Monitoring monitoring job spec. It outlines the specifications for monitoring
/// objectives, notifications, and result exports.
final class ModelMonitoringSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringSpec';

  /// The monitoring objective spec.
  final ModelMonitoringObjectiveSpec? objectiveSpec;

  /// The model monitoring notification spec.
  final ModelMonitoringNotificationSpec? notificationSpec;

  /// The Output destination spec for metrics, error logs, etc.
  final ModelMonitoringOutputSpec? outputSpec;

  ModelMonitoringSpec({
    this.objectiveSpec,
    this.notificationSpec,
    this.outputSpec,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringSpec(
      objectiveSpec: switch (json['objectiveSpec']) {
        null => null,
        Object $1 => ModelMonitoringObjectiveSpec.fromJson($1),
      },
      notificationSpec: switch (json['notificationSpec']) {
        null => null,
        Object $1 => ModelMonitoringNotificationSpec.fromJson($1),
      },
      outputSpec: switch (json['outputSpec']) {
        null => null,
        Object $1 => ModelMonitoringOutputSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (objectiveSpec != null) 'objectiveSpec': objectiveSpec!.toJson(),
    if (notificationSpec != null)
      'notificationSpec': notificationSpec!.toJson(),
    if (outputSpec != null) 'outputSpec': outputSpec!.toJson(),
  };

  @override
  String toString() => 'ModelMonitoringSpec()';
}

/// Monitoring objectives spec.
final class ModelMonitoringObjectiveSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveSpec';

  /// Tabular monitoring objective.
  final ModelMonitoringObjectiveSpec_TabularObjective? tabularObjective;

  /// The explanation spec.
  /// This spec is required when the objectives spec includes feature attribution
  /// objectives.
  final ExplanationSpec? explanationSpec;

  /// Baseline dataset.
  /// It could be the training dataset or production serving dataset from a
  /// previous period.
  final ModelMonitoringInput? baselineDataset;

  /// Target dataset.
  final ModelMonitoringInput? targetDataset;

  ModelMonitoringObjectiveSpec({
    this.tabularObjective,
    this.explanationSpec,
    this.baselineDataset,
    this.targetDataset,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveSpec(
      tabularObjective: switch (json['tabularObjective']) {
        null => null,
        Object $1 => ModelMonitoringObjectiveSpec_TabularObjective.fromJson($1),
      },
      explanationSpec: switch (json['explanationSpec']) {
        null => null,
        Object $1 => ExplanationSpec.fromJson($1),
      },
      baselineDataset: switch (json['baselineDataset']) {
        null => null,
        Object $1 => ModelMonitoringInput.fromJson($1),
      },
      targetDataset: switch (json['targetDataset']) {
        null => null,
        Object $1 => ModelMonitoringInput.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tabularObjective != null)
      'tabularObjective': tabularObjective!.toJson(),
    if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
    if (baselineDataset != null) 'baselineDataset': baselineDataset!.toJson(),
    if (targetDataset != null) 'targetDataset': targetDataset!.toJson(),
  };

  @override
  String toString() => 'ModelMonitoringObjectiveSpec()';
}

/// Data drift monitoring spec.
/// Data drift measures the distribution distance between the current dataset
/// and a baseline dataset. A typical use case is to detect data drift between
/// the recent production serving dataset and the training dataset, or to
/// compare the recent production dataset with a dataset from a previous
/// period.
final class ModelMonitoringObjectiveSpec_DataDriftSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveSpec.DataDriftSpec';

  /// Feature names / Prediction output names interested in monitoring.
  /// These should be a subset of the input feature names or prediction output
  /// names specified in the monitoring schema.
  /// If the field is not specified all features / prediction outputs outlied
  /// in the monitoring schema will be used.
  final List<String> features;

  /// Supported metrics type:
  ///  * l_infinity
  ///  * jensen_shannon_divergence
  final String categoricalMetricType;

  /// Supported metrics type:
  ///  * jensen_shannon_divergence
  final String numericMetricType;

  /// Default alert condition for all the categorical features.
  final ModelMonitoringAlertCondition? defaultCategoricalAlertCondition;

  /// Default alert condition for all the numeric features.
  final ModelMonitoringAlertCondition? defaultNumericAlertCondition;

  /// Per feature alert condition will override default alert condition.
  final Map<String, ModelMonitoringAlertCondition> featureAlertConditions;

  ModelMonitoringObjectiveSpec_DataDriftSpec({
    this.features = const [],
    this.categoricalMetricType = '',
    this.numericMetricType = '',
    this.defaultCategoricalAlertCondition,
    this.defaultNumericAlertCondition,
    this.featureAlertConditions = const {},
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveSpec_DataDriftSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveSpec_DataDriftSpec(
      features: switch (json['features']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"features" is not a list'),
      },
      categoricalMetricType: switch (json['categoricalMetricType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      numericMetricType: switch (json['numericMetricType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      defaultCategoricalAlertCondition:
          switch (json['defaultCategoricalAlertCondition']) {
            null => null,
            Object $1 => ModelMonitoringAlertCondition.fromJson($1),
          },
      defaultNumericAlertCondition:
          switch (json['defaultNumericAlertCondition']) {
            null => null,
            Object $1 => ModelMonitoringAlertCondition.fromJson($1),
          },
      featureAlertConditions: switch (json['featureAlertConditions']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ModelMonitoringAlertCondition.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException(
          '"featureAlertConditions" is not an object',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (features.isNotDefault) 'features': features,
    if (categoricalMetricType.isNotDefault)
      'categoricalMetricType': categoricalMetricType,
    if (numericMetricType.isNotDefault) 'numericMetricType': numericMetricType,
    if (defaultCategoricalAlertCondition != null)
      'defaultCategoricalAlertCondition': defaultCategoricalAlertCondition!
          .toJson(),
    if (defaultNumericAlertCondition != null)
      'defaultNumericAlertCondition': defaultNumericAlertCondition!.toJson(),
    if (featureAlertConditions.isNotDefault)
      'featureAlertConditions': encodeMap(featureAlertConditions),
  };

  @override
  String toString() {
    final contents = [
      'categoricalMetricType=$categoricalMetricType',
      'numericMetricType=$numericMetricType',
    ].join(',');
    return 'DataDriftSpec($contents)';
  }
}

/// Feature attribution monitoring spec.
final class ModelMonitoringObjectiveSpec_FeatureAttributionSpec
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveSpec.FeatureAttributionSpec';

  /// Feature names interested in monitoring.
  /// These should be a subset of the input feature names specified in the
  /// monitoring schema. If the field is not specified all features outlied in
  /// the monitoring schema will be used.
  final List<String> features;

  /// Default alert condition for all the features.
  final ModelMonitoringAlertCondition? defaultAlertCondition;

  /// Per feature alert condition will override default alert condition.
  final Map<String, ModelMonitoringAlertCondition> featureAlertConditions;

  /// The config of resources used by the Model Monitoring during the batch
  /// explanation for non-AutoML models. If not set, `n1-standard-2` machine
  /// type will be used by default.
  final BatchDedicatedResources? batchExplanationDedicatedResources;

  ModelMonitoringObjectiveSpec_FeatureAttributionSpec({
    this.features = const [],
    this.defaultAlertCondition,
    this.featureAlertConditions = const {},
    this.batchExplanationDedicatedResources,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveSpec_FeatureAttributionSpec.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveSpec_FeatureAttributionSpec(
      features: switch (json['features']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"features" is not a list'),
      },
      defaultAlertCondition: switch (json['defaultAlertCondition']) {
        null => null,
        Object $1 => ModelMonitoringAlertCondition.fromJson($1),
      },
      featureAlertConditions: switch (json['featureAlertConditions']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ModelMonitoringAlertCondition.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException(
          '"featureAlertConditions" is not an object',
        ),
      },
      batchExplanationDedicatedResources:
          switch (json['batchExplanationDedicatedResources']) {
            null => null,
            Object $1 => BatchDedicatedResources.fromJson($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (features.isNotDefault) 'features': features,
    if (defaultAlertCondition != null)
      'defaultAlertCondition': defaultAlertCondition!.toJson(),
    if (featureAlertConditions.isNotDefault)
      'featureAlertConditions': encodeMap(featureAlertConditions),
    if (batchExplanationDedicatedResources != null)
      'batchExplanationDedicatedResources': batchExplanationDedicatedResources!
          .toJson(),
  };

  @override
  String toString() => 'FeatureAttributionSpec()';
}

/// Tabular monitoring objective.
final class ModelMonitoringObjectiveSpec_TabularObjective extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveSpec.TabularObjective';

  /// Input feature distribution drift monitoring spec.
  final ModelMonitoringObjectiveSpec_DataDriftSpec? featureDriftSpec;

  /// Prediction output distribution drift monitoring spec.
  final ModelMonitoringObjectiveSpec_DataDriftSpec? predictionOutputDriftSpec;

  /// Feature attribution monitoring spec.
  final ModelMonitoringObjectiveSpec_FeatureAttributionSpec?
  featureAttributionSpec;

  ModelMonitoringObjectiveSpec_TabularObjective({
    this.featureDriftSpec,
    this.predictionOutputDriftSpec,
    this.featureAttributionSpec,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveSpec_TabularObjective.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringObjectiveSpec_TabularObjective(
      featureDriftSpec: switch (json['featureDriftSpec']) {
        null => null,
        Object $1 => ModelMonitoringObjectiveSpec_DataDriftSpec.fromJson($1),
      },
      predictionOutputDriftSpec: switch (json['predictionOutputDriftSpec']) {
        null => null,
        Object $1 => ModelMonitoringObjectiveSpec_DataDriftSpec.fromJson($1),
      },
      featureAttributionSpec: switch (json['featureAttributionSpec']) {
        null => null,
        Object $1 =>
          ModelMonitoringObjectiveSpec_FeatureAttributionSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureDriftSpec != null)
      'featureDriftSpec': featureDriftSpec!.toJson(),
    if (predictionOutputDriftSpec != null)
      'predictionOutputDriftSpec': predictionOutputDriftSpec!.toJson(),
    if (featureAttributionSpec != null)
      'featureAttributionSpec': featureAttributionSpec!.toJson(),
  };

  @override
  String toString() => 'TabularObjective()';
}

/// Specification for the export destination of monitoring results, including
/// metrics, logs, etc.
final class ModelMonitoringOutputSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringOutputSpec';

  /// Google Cloud Storage base folder path for metrics, error logs, etc.
  final GcsDestination? gcsBaseDirectory;

  ModelMonitoringOutputSpec({this.gcsBaseDirectory})
    : super(fullyQualifiedName);

  factory ModelMonitoringOutputSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringOutputSpec(
      gcsBaseDirectory: switch (json['gcsBaseDirectory']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsBaseDirectory != null)
      'gcsBaseDirectory': gcsBaseDirectory!.toJson(),
  };

  @override
  String toString() => 'ModelMonitoringOutputSpec()';
}

/// Model monitoring data input spec.
final class ModelMonitoringInput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput';

  /// Columnized dataset.
  final ModelMonitoringInput_ModelMonitoringDataset? columnizedDataset;

  /// Vertex AI Batch prediction Job.
  final ModelMonitoringInput_BatchPredictionOutput? batchPredictionOutput;

  /// Vertex AI Endpoint request & response logging.
  final ModelMonitoringInput_VertexEndpointLogs? vertexEndpointLogs;

  /// The time interval (pair of start_time and end_time) for which results
  /// should be returned.
  final Interval? timeInterval;

  /// The time offset setting for which results should be returned.
  final ModelMonitoringInput_TimeOffset? timeOffset;

  ModelMonitoringInput({
    this.columnizedDataset,
    this.batchPredictionOutput,
    this.vertexEndpointLogs,
    this.timeInterval,
    this.timeOffset,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringInput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringInput(
      columnizedDataset: switch (json['columnizedDataset']) {
        null => null,
        Object $1 => ModelMonitoringInput_ModelMonitoringDataset.fromJson($1),
      },
      batchPredictionOutput: switch (json['batchPredictionOutput']) {
        null => null,
        Object $1 => ModelMonitoringInput_BatchPredictionOutput.fromJson($1),
      },
      vertexEndpointLogs: switch (json['vertexEndpointLogs']) {
        null => null,
        Object $1 => ModelMonitoringInput_VertexEndpointLogs.fromJson($1),
      },
      timeInterval: switch (json['timeInterval']) {
        null => null,
        Object $1 => Interval.fromJson($1),
      },
      timeOffset: switch (json['timeOffset']) {
        null => null,
        Object $1 => ModelMonitoringInput_TimeOffset.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (columnizedDataset != null)
      'columnizedDataset': columnizedDataset!.toJson(),
    if (batchPredictionOutput != null)
      'batchPredictionOutput': batchPredictionOutput!.toJson(),
    if (vertexEndpointLogs != null)
      'vertexEndpointLogs': vertexEndpointLogs!.toJson(),
    if (timeInterval != null) 'timeInterval': timeInterval!.toJson(),
    if (timeOffset != null) 'timeOffset': timeOffset!.toJson(),
  };

  @override
  String toString() => 'ModelMonitoringInput()';
}

/// Input dataset spec.
final class ModelMonitoringInput_ModelMonitoringDataset extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.ModelMonitoringDataset';

  /// Resource name of the Vertex AI managed dataset.
  final String? vertexDataset;

  /// Google Cloud Storage data source.
  final ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource?
  gcsSource;

  /// BigQuery data source.
  final ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource?
  bigquerySource;

  /// The timestamp field. Usually for serving data.
  final String timestampField;

  ModelMonitoringInput_ModelMonitoringDataset({
    this.vertexDataset,
    this.gcsSource,
    this.bigquerySource,
    this.timestampField = '',
  }) : super(fullyQualifiedName);

  factory ModelMonitoringInput_ModelMonitoringDataset.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringInput_ModelMonitoringDataset(
      vertexDataset: switch (json['vertexDataset']) {
        null => null,
        Object $1 => decodeString($1),
      },
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 =>
          ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.fromJson(
            $1,
          ),
      },
      bigquerySource: switch (json['bigquerySource']) {
        null => null,
        Object $1 =>
          ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.fromJson(
            $1,
          ),
      },
      timestampField: switch (json['timestampField']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vertexDataset != null) 'vertexDataset': vertexDataset,
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
    if (timestampField.isNotDefault) 'timestampField': timestampField,
  };

  @override
  String toString() {
    final contents = [
      if (vertexDataset != null) 'vertexDataset=$vertexDataset',
      'timestampField=$timestampField',
    ].join(',');
    return 'ModelMonitoringDataset($contents)';
  }
}

/// Dataset spec for data stored in Google Cloud Storage.
final class ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.ModelMonitoringDataset.ModelMonitoringGcsSource';

  /// Google Cloud Storage URI to the input file(s). May contain
  /// wildcards. For more information on wildcards, see
  /// https://cloud.google.com/storage/docs/wildcards.
  final String gcsUri;

  /// Data format of the dataset.
  final ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat
  format;

  ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource({
    this.gcsUri = '',
    this.format =
        ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat
            .$default,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource(
      gcsUri: switch (json['gcsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      format: switch (json['format']) {
        null =>
          ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat
              .$default,
        Object $1 =>
          ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsUri.isNotDefault) 'gcsUri': gcsUri,
    if (format.isNotDefault) 'format': format.toJson(),
  };

  @override
  String toString() {
    final contents = ['gcsUri=$gcsUri', 'format=$format'].join(',');
    return 'ModelMonitoringGcsSource($contents)';
  }
}

/// Supported data format.
final class ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat
    extends ProtoEnum {
  /// Data format unspecified, used when this field is unset.
  static const dataFormatUnspecified =
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        'DATA_FORMAT_UNSPECIFIED',
      );

  /// CSV files.
  static const csv =
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        'CSV',
      );

  /// TfRecord files
  static const tfRecord =
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        'TF_RECORD',
      );

  /// JsonL files.
  static const jsonl =
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        'JSONL',
      );

  /// The default value for [ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat].
  static const $default = dataFormatUnspecified;

  const ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
    super.value,
  );

  factory ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.fromJson(
    Object? json,
  ) =>
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        json as String,
      );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DataFormat.$value';
}

/// Dataset spec for data sotred in BigQuery.
final class ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.ModelMonitoringDataset.ModelMonitoringBigQuerySource';

  /// BigQuery URI to a table, up to 2000 characters long. All the columns
  /// in the table will be selected. Accepted forms:
  ///
  /// *  BigQuery path. For example:
  /// `bq://projectId.bqDatasetId.bqTableId`.
  final String? tableUri;

  /// Standard SQL to be used instead of the `table_uri`.
  final String? query;

  ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource({
    this.tableUri,
    this.query,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource(
      tableUri: switch (json['tableUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      query: switch (json['query']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tableUri != null) 'tableUri': tableUri,
    if (query != null) 'query': query,
  };

  @override
  String toString() {
    final contents = [
      if (tableUri != null) 'tableUri=$tableUri',
      if (query != null) 'query=$query',
    ].join(',');
    return 'ModelMonitoringBigQuerySource($contents)';
  }
}

/// Data from Vertex AI Batch prediction job output.
final class ModelMonitoringInput_BatchPredictionOutput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.BatchPredictionOutput';

  /// Vertex AI Batch prediction job resource name. The job must match the
  /// model version specified in [ModelMonitor].[model_monitoring_target].
  final String batchPredictionJob;

  ModelMonitoringInput_BatchPredictionOutput({this.batchPredictionJob = ''})
    : super(fullyQualifiedName);

  factory ModelMonitoringInput_BatchPredictionOutput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringInput_BatchPredictionOutput(
      batchPredictionJob: switch (json['batchPredictionJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (batchPredictionJob.isNotDefault)
      'batchPredictionJob': batchPredictionJob,
  };

  @override
  String toString() {
    final contents = ['batchPredictionJob=$batchPredictionJob'].join(',');
    return 'BatchPredictionOutput($contents)';
  }
}

/// Data from Vertex AI Endpoint request response logging.
final class ModelMonitoringInput_VertexEndpointLogs extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.VertexEndpointLogs';

  /// List of endpoint resource names. The endpoints must enable the logging
  /// with the [Endpoint].[request_response_logging_config], and must contain
  /// the deployed model corresponding to the model version specified in
  /// [ModelMonitor].[model_monitoring_target].
  final List<String> endpoints;

  ModelMonitoringInput_VertexEndpointLogs({this.endpoints = const []})
    : super(fullyQualifiedName);

  factory ModelMonitoringInput_VertexEndpointLogs.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringInput_VertexEndpointLogs(
      endpoints: switch (json['endpoints']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"endpoints" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (endpoints.isNotDefault) 'endpoints': endpoints};

  @override
  String toString() => 'VertexEndpointLogs()';
}

/// Time offset setting.
final class ModelMonitoringInput_TimeOffset extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.TimeOffset';

  /// [offset] is the time difference from the cut-off time.
  /// For scheduled jobs, the cut-off time is the scheduled time.
  /// For non-scheduled jobs, it's the time when the job was created.
  /// Currently we support the following format:
  /// 'w|W': Week, 'd|D': Day, 'h|H': Hour
  /// E.g. '1h' stands for 1 hour, '2d' stands for 2 days.
  final String offset;

  /// [window] refers to the scope of data selected for analysis.
  /// It allows you to specify the quantity of data you wish to examine.
  /// Currently we support the following format:
  /// 'w|W': Week, 'd|D': Day, 'h|H': Hour
  /// E.g. '1h' stands for 1 hour, '2d' stands for 2 days.
  final String window;

  ModelMonitoringInput_TimeOffset({this.offset = '', this.window = ''})
    : super(fullyQualifiedName);

  factory ModelMonitoringInput_TimeOffset.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringInput_TimeOffset(
      offset: switch (json['offset']) {
        null => '',
        Object $1 => decodeString($1),
      },
      window: switch (json['window']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (offset.isNotDefault) 'offset': offset,
    if (window.isNotDefault) 'window': window,
  };

  @override
  String toString() {
    final contents = ['offset=$offset', 'window=$window'].join(',');
    return 'TimeOffset($contents)';
  }
}

/// Notification spec(email, notification channel) for model monitoring
/// statistics/alerts.
final class ModelMonitoringNotificationSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringNotificationSpec';

  /// Email alert config.
  final ModelMonitoringNotificationSpec_EmailConfig? emailConfig;

  /// Dump the anomalies to Cloud Logging. The anomalies will be put to json
  /// payload encoded from proto
  /// `google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry`.
  /// This can be further sinked to Pub/Sub or any other services supported
  /// by Cloud Logging.
  final bool enableCloudLogging;

  /// Notification channel config.
  final List<ModelMonitoringNotificationSpec_NotificationChannelConfig>
  notificationChannelConfigs;

  ModelMonitoringNotificationSpec({
    this.emailConfig,
    this.enableCloudLogging = false,
    this.notificationChannelConfigs = const [],
  }) : super(fullyQualifiedName);

  factory ModelMonitoringNotificationSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringNotificationSpec(
      emailConfig: switch (json['emailConfig']) {
        null => null,
        Object $1 => ModelMonitoringNotificationSpec_EmailConfig.fromJson($1),
      },
      enableCloudLogging: switch (json['enableCloudLogging']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      notificationChannelConfigs: switch (json['notificationChannelConfigs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ModelMonitoringNotificationSpec_NotificationChannelConfig.fromJson(
              i,
            ),
        ],
        _ => throw const FormatException(
          '"notificationChannelConfigs" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (emailConfig != null) 'emailConfig': emailConfig!.toJson(),
    if (enableCloudLogging.isNotDefault)
      'enableCloudLogging': enableCloudLogging,
    if (notificationChannelConfigs.isNotDefault)
      'notificationChannelConfigs': encodeList(notificationChannelConfigs),
  };

  @override
  String toString() {
    final contents = ['enableCloudLogging=$enableCloudLogging'].join(',');
    return 'ModelMonitoringNotificationSpec($contents)';
  }
}

/// The config for email alerts.
final class ModelMonitoringNotificationSpec_EmailConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringNotificationSpec.EmailConfig';

  /// The email addresses to send the alerts.
  final List<String> userEmails;

  ModelMonitoringNotificationSpec_EmailConfig({this.userEmails = const []})
    : super(fullyQualifiedName);

  factory ModelMonitoringNotificationSpec_EmailConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringNotificationSpec_EmailConfig(
      userEmails: switch (json['userEmails']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"userEmails" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (userEmails.isNotDefault) 'userEmails': userEmails};

  @override
  String toString() => 'EmailConfig()';
}

/// Google Cloud Notification Channel config.
final class ModelMonitoringNotificationSpec_NotificationChannelConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringNotificationSpec.NotificationChannelConfig';

  /// Resource names of the NotificationChannels.
  /// Must be of the format
  /// `projects/<project_id_or_number>/notificationChannels/<channel_id>`
  final String notificationChannel;

  ModelMonitoringNotificationSpec_NotificationChannelConfig({
    this.notificationChannel = '',
  }) : super(fullyQualifiedName);

  factory ModelMonitoringNotificationSpec_NotificationChannelConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringNotificationSpec_NotificationChannelConfig(
      notificationChannel: switch (json['notificationChannel']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (notificationChannel.isNotDefault)
      'notificationChannel': notificationChannel,
  };

  @override
  String toString() {
    final contents = ['notificationChannel=$notificationChannel'].join(',');
    return 'NotificationChannelConfig($contents)';
  }
}

/// Represents the collection of statistics for a metric.
final class ModelMonitoringStats extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStats';

  /// Generated tabular statistics.
  final ModelMonitoringTabularStats? tabularStats;

  ModelMonitoringStats({this.tabularStats}) : super(fullyQualifiedName);

  factory ModelMonitoringStats.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringStats(
      tabularStats: switch (json['tabularStats']) {
        null => null,
        Object $1 => ModelMonitoringTabularStats.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tabularStats != null) 'tabularStats': tabularStats!.toJson(),
  };

  @override
  String toString() => 'ModelMonitoringStats()';
}

/// Represents a single statistics data point.
final class ModelMonitoringStatsDataPoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsDataPoint';

  /// Statistics from current dataset.
  final ModelMonitoringStatsDataPoint_TypedValue? currentStats;

  /// Statistics from baseline dataset.
  final ModelMonitoringStatsDataPoint_TypedValue? baselineStats;

  /// Threshold value.
  final double thresholdValue;

  /// Indicate if the statistics has anomaly.
  final bool hasAnomaly;

  /// Model monitoring job resource name.
  final String modelMonitoringJob;

  /// Schedule resource name.
  final String schedule;

  /// Statistics create time.
  final protobuf.Timestamp? createTime;

  /// Algorithm used to calculated the metrics, eg: jensen_shannon_divergence,
  /// l_infinity.
  final String algorithm;

  ModelMonitoringStatsDataPoint({
    this.currentStats,
    this.baselineStats,
    this.thresholdValue = 0,
    this.hasAnomaly = false,
    this.modelMonitoringJob = '',
    this.schedule = '',
    this.createTime,
    this.algorithm = '',
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsDataPoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringStatsDataPoint(
      currentStats: switch (json['currentStats']) {
        null => null,
        Object $1 => ModelMonitoringStatsDataPoint_TypedValue.fromJson($1),
      },
      baselineStats: switch (json['baselineStats']) {
        null => null,
        Object $1 => ModelMonitoringStatsDataPoint_TypedValue.fromJson($1),
      },
      thresholdValue: switch (json['thresholdValue']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      hasAnomaly: switch (json['hasAnomaly']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      modelMonitoringJob: switch (json['modelMonitoringJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      schedule: switch (json['schedule']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      algorithm: switch (json['algorithm']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (currentStats != null) 'currentStats': currentStats!.toJson(),
    if (baselineStats != null) 'baselineStats': baselineStats!.toJson(),
    if (thresholdValue.isNotDefault)
      'thresholdValue': encodeDouble(thresholdValue),
    if (hasAnomaly.isNotDefault) 'hasAnomaly': hasAnomaly,
    if (modelMonitoringJob.isNotDefault)
      'modelMonitoringJob': modelMonitoringJob,
    if (schedule.isNotDefault) 'schedule': schedule,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (algorithm.isNotDefault) 'algorithm': algorithm,
  };

  @override
  String toString() {
    final contents = [
      'thresholdValue=$thresholdValue',
      'hasAnomaly=$hasAnomaly',
      'modelMonitoringJob=$modelMonitoringJob',
      'schedule=$schedule',
      'algorithm=$algorithm',
    ].join(',');
    return 'ModelMonitoringStatsDataPoint($contents)';
  }
}

/// Typed value of the statistics.
final class ModelMonitoringStatsDataPoint_TypedValue extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsDataPoint.TypedValue';

  /// Double.
  final double? doubleValue;

  /// Distribution.
  final ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue?
  distributionValue;

  ModelMonitoringStatsDataPoint_TypedValue({
    this.doubleValue,
    this.distributionValue,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsDataPoint_TypedValue.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringStatsDataPoint_TypedValue(
      doubleValue: switch (json['doubleValue']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      distributionValue: switch (json['distributionValue']) {
        null => null,
        Object $1 =>
          ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (doubleValue != null) 'doubleValue': encodeDouble(doubleValue),
    if (distributionValue != null)
      'distributionValue': distributionValue!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (doubleValue != null) 'doubleValue=$doubleValue',
    ].join(',');
    return 'TypedValue($contents)';
  }
}

/// Summary statistics for a population of values.
final class ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsDataPoint.TypedValue.DistributionDataValue';

  /// Predictive monitoring drift distribution in
  /// `tensorflow.metadata.v0.DatasetFeatureStatistics` format.
  final protobuf.Value? distribution;

  /// Distribution distance deviation from the current dataset's statistics
  /// to baseline dataset's statistics.
  ///   * For categorical feature, the distribution distance is calculated
  ///     by L-inifinity norm or JensenShannon divergence.
  ///   * For numerical feature, the distribution distance is calculated by
  ///     JensenShannon divergence.
  final double distributionDeviation;

  ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue({
    this.distribution,
    this.distributionDeviation = 0,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue(
      distribution: switch (json['distribution']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      distributionDeviation: switch (json['distributionDeviation']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (distribution != null) 'distribution': distribution!.toJson(),
    if (distributionDeviation.isNotDefault)
      'distributionDeviation': encodeDouble(distributionDeviation),
  };

  @override
  String toString() {
    final contents = ['distributionDeviation=$distributionDeviation'].join(',');
    return 'DistributionDataValue($contents)';
  }
}

/// A collection of data points that describes the time-varying values of a
/// tabular metric.
final class ModelMonitoringTabularStats extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringTabularStats';

  /// The stats name.
  final String statsName;

  /// One of the supported monitoring objectives:
  /// `raw-feature-drift`
  /// `prediction-output-drift`
  /// `feature-attribution`
  final String objectiveType;

  /// The data points of this time series. When listing time series, points are
  /// returned in reverse time order.
  final List<ModelMonitoringStatsDataPoint> dataPoints;

  ModelMonitoringTabularStats({
    this.statsName = '',
    this.objectiveType = '',
    this.dataPoints = const [],
  }) : super(fullyQualifiedName);

  factory ModelMonitoringTabularStats.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelMonitoringTabularStats(
      statsName: switch (json['statsName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      objectiveType: switch (json['objectiveType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataPoints: switch (json['dataPoints']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelMonitoringStatsDataPoint.fromJson(i),
        ],
        _ => throw const FormatException('"dataPoints" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (statsName.isNotDefault) 'statsName': statsName,
    if (objectiveType.isNotDefault) 'objectiveType': objectiveType,
    if (dataPoints.isNotDefault) 'dataPoints': encodeList(dataPoints),
  };

  @override
  String toString() {
    final contents = [
      'statsName=$statsName',
      'objectiveType=$objectiveType',
    ].join(',');
    return 'ModelMonitoringTabularStats($contents)';
  }
}

/// Filter for searching ModelMonitoringStats.
final class SearchModelMonitoringStatsFilter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringStatsFilter';

  /// Tabular statistics filter.
  final SearchModelMonitoringStatsFilter_TabularStatsFilter? tabularStatsFilter;

  SearchModelMonitoringStatsFilter({this.tabularStatsFilter})
    : super(fullyQualifiedName);

  factory SearchModelMonitoringStatsFilter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SearchModelMonitoringStatsFilter(
      tabularStatsFilter: switch (json['tabularStatsFilter']) {
        null => null,
        Object $1 =>
          SearchModelMonitoringStatsFilter_TabularStatsFilter.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tabularStatsFilter != null)
      'tabularStatsFilter': tabularStatsFilter!.toJson(),
  };

  @override
  String toString() => 'SearchModelMonitoringStatsFilter()';
}

/// Tabular statistics filter.
final class SearchModelMonitoringStatsFilter_TabularStatsFilter
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringStatsFilter.TabularStatsFilter';

  /// If not specified, will return all the stats_names.
  final String statsName;

  /// One of the supported monitoring objectives:
  /// `raw-feature-drift`
  /// `prediction-output-drift`
  /// `feature-attribution`
  final String objectiveType;

  /// From a particular monitoring job.
  final String modelMonitoringJob;

  /// From a particular monitoring schedule.
  final String modelMonitoringSchedule;

  /// Specify the algorithm type used for distance calculation, eg:
  /// jensen_shannon_divergence, l_infinity.
  final String algorithm;

  SearchModelMonitoringStatsFilter_TabularStatsFilter({
    this.statsName = '',
    this.objectiveType = '',
    this.modelMonitoringJob = '',
    this.modelMonitoringSchedule = '',
    this.algorithm = '',
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringStatsFilter_TabularStatsFilter.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return SearchModelMonitoringStatsFilter_TabularStatsFilter(
      statsName: switch (json['statsName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      objectiveType: switch (json['objectiveType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelMonitoringJob: switch (json['modelMonitoringJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelMonitoringSchedule: switch (json['modelMonitoringSchedule']) {
        null => '',
        Object $1 => decodeString($1),
      },
      algorithm: switch (json['algorithm']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (statsName.isNotDefault) 'statsName': statsName,
    if (objectiveType.isNotDefault) 'objectiveType': objectiveType,
    if (modelMonitoringJob.isNotDefault)
      'modelMonitoringJob': modelMonitoringJob,
    if (modelMonitoringSchedule.isNotDefault)
      'modelMonitoringSchedule': modelMonitoringSchedule,
    if (algorithm.isNotDefault) 'algorithm': algorithm,
  };

  @override
  String toString() {
    final contents = [
      'statsName=$statsName',
      'objectiveType=$objectiveType',
      'modelMonitoringJob=$modelMonitoringJob',
      'modelMonitoringSchedule=$modelMonitoringSchedule',
      'algorithm=$algorithm',
    ].join(',');
    return 'TabularStatsFilter($contents)';
  }
}

/// Request message for
/// `ModelService.UploadModel`.
final class UploadModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadModelRequest';

  /// Required. The resource name of the Location into which to upload the Model.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The resource name of the model into which to upload the version.
  /// Only specify this field when uploading a new version.
  final String parentModel;

  /// Optional. The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  final String modelId;

  /// Required. The Model to create.
  final Model? model;

  /// Optional. The user-provided custom service account to use to do the model
  /// upload. If empty, [Vertex AI Service
  /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used to access resources needed to upload the model. This account
  /// must belong to the target project where the model is uploaded to, i.e., the
  /// project specified in the `parent` field of this request and have necessary
  /// read permissions (to Google Cloud Storage, Artifact Registry, etc.).
  final String serviceAccount;

  UploadModelRequest({
    required this.parent,
    this.parentModel = '',
    this.modelId = '',
    required this.model,
    this.serviceAccount = '',
  }) : super(fullyQualifiedName);

  factory UploadModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UploadModelRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parentModel: switch (json['parentModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelId: switch (json['modelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => null,
        Object $1 => Model.fromJson($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (parentModel.isNotDefault) 'parentModel': parentModel,
    if (modelId.isNotDefault) 'modelId': modelId,
    if (model != null) 'model': model!.toJson(),
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'parentModel=$parentModel',
      'modelId=$modelId',
      'serviceAccount=$serviceAccount',
    ].join(',');
    return 'UploadModelRequest($contents)';
  }
}

/// Details of
/// `ModelService.UploadModel`
/// operation.
final class UploadModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadModelOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UploadModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UploadModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UploadModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UploadModelOperationMetadata()';
}

/// Response message of
/// `ModelService.UploadModel`
/// operation.
final class UploadModelResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadModelResponse';

  /// The name of the uploaded Model resource.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String model;

  /// Output only. The version ID of the model that is uploaded.
  final String modelVersionId;

  UploadModelResponse({this.model = '', this.modelVersionId = ''})
    : super(fullyQualifiedName);

  factory UploadModelResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UploadModelResponse(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersionId: switch (json['modelVersionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (model.isNotDefault) 'model': model,
    if (modelVersionId.isNotDefault) 'modelVersionId': modelVersionId,
  };

  @override
  String toString() {
    final contents = [
      'model=$model',
      'modelVersionId=$modelVersionId',
    ].join(',');
    return 'UploadModelResponse($contents)';
  }
}

/// Request message for
/// `ModelService.GetModel`.
final class GetModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelRequest';

  /// Required. The name of the Model resource.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  ///
  /// In order to retrieve a specific version of the model, also provide
  /// the version ID or version alias.
  ///   Example: `projects/{project}/locations/{location}/models/{model}@2`
  ///              or
  ///            `projects/{project}/locations/{location}/models/{model}@golden`
  /// If no version ID or alias is specified, the "default" version will be
  /// returned. The "default" version alias is created for the first version of
  /// the model, and can be moved to other versions later on. There will be
  /// exactly one default version.
  final String name;

  GetModelRequest({required this.name}) : super(fullyQualifiedName);

  factory GetModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetModelRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelRequest($contents)';
  }
}

/// Request message for
/// `ModelService.ListModels`.
final class ListModelsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelsRequest';

  /// Required. The resource name of the Location to list the Models from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// An expression for filtering the results of the request. For field names
  /// both snake_case and camelCase are supported.
  ///
  ///   * `model` supports = and !=. `model` represents the Model ID,
  ///     i.e. the last segment of the Model's [resource
  ///     name][google.cloud.aiplatform.v1beta1.Model.name].
  ///   * `display_name` supports = and !=
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:* or labels:key - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///   * `base_model_name` only supports =
  ///
  /// Some examples:
  ///
  ///   * `model=1234`
  ///   * `displayName="myDisplayName"`
  ///   * `labels.myKey="myValue"`
  ///   * `baseModelName="text-bison"`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListModelsResponse.next_page_token`
  /// of the previous
  /// `ModelService.ListModels`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListModelsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListModelsRequest($contents)';
  }
}

/// Response message for
/// `ModelService.ListModels`
final class ListModelsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelsResponse';

  /// List of Models in the requested page.
  final List<Model> models;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListModelsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListModelsResponse({this.models = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListModelsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelsResponse(
      models: switch (json['models']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Model.fromJson(i)],
        _ => throw const FormatException('"models" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (models.isNotDefault) 'models': encodeList(models),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListModelsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.ListModelVersions`.
final class ListModelVersionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelVersionsRequest';

  /// Required. The name of the model to list versions for.
  final String name;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `next_page_token`
  /// of the previous
  /// `ListModelVersions`
  /// call.
  final String pageToken;

  /// An expression for filtering the results of the request. For field names
  /// both snake_case and camelCase are supported.
  ///
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:* or labels:key - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///
  /// Some examples:
  ///
  ///   * `labels.myKey="myValue"`
  final String filter;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `update_time asc, create_time desc`.
  final String orderBy;

  ListModelVersionsRequest({
    required this.name,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListModelVersionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelVersionsRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListModelVersionsRequest($contents)';
  }
}

/// Response message for
/// `ModelService.ListModelVersions`
final class ListModelVersionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelVersionsResponse';

  /// List of Model versions in the requested page.
  /// In the returned Model name field, version ID instead of regvision tag will
  /// be included.
  final List<Model> models;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListModelVersionsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListModelVersionsResponse({this.models = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListModelVersionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelVersionsResponse(
      models: switch (json['models']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Model.fromJson(i)],
        _ => throw const FormatException('"models" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (models.isNotDefault) 'models': encodeList(models),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListModelVersionsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.ListModelVersionCheckpoints`.
final class ListModelVersionCheckpointsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelVersionCheckpointsRequest';

  /// Required. The name of the model version to list checkpoints for.
  /// `projects/{project}/locations/{location}/models/{model}@{version}`
  /// Example: `projects/{project}/locations/{location}/models/{model}@2`
  /// or
  /// `projects/{project}/locations/{location}/models/{model}@golden`
  /// If no version ID or alias is specified, the latest version will be
  /// used.
  final String name;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `next_page_token`
  /// of the previous
  /// `ListModelVersionCheckpoints`
  /// call.
  final String pageToken;

  ListModelVersionCheckpointsRequest({
    required this.name,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListModelVersionCheckpointsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelVersionCheckpointsRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListModelVersionCheckpointsRequest($contents)';
  }
}

/// A proto representation of a Spanner-stored ModelVersionCheckpoint.
/// The meaning of the fields is equivalent to their in-Spanner counterparts.
final class ModelVersionCheckpoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelVersionCheckpoint';

  /// The ID of the checkpoint.
  final String checkpointId;

  /// The epoch of the checkpoint.
  final int epoch;

  /// The step of the checkpoint.
  final int step;

  ModelVersionCheckpoint({
    this.checkpointId = '',
    this.epoch = 0,
    this.step = 0,
  }) : super(fullyQualifiedName);

  factory ModelVersionCheckpoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModelVersionCheckpoint(
      checkpointId: switch (json['checkpointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      epoch: switch (json['epoch']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      step: switch (json['step']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (checkpointId.isNotDefault) 'checkpointId': checkpointId,
    if (epoch.isNotDefault) 'epoch': encodeInt64(epoch),
    if (step.isNotDefault) 'step': encodeInt64(step),
  };

  @override
  String toString() {
    final contents = [
      'checkpointId=$checkpointId',
      'epoch=$epoch',
      'step=$step',
    ].join(',');
    return 'ModelVersionCheckpoint($contents)';
  }
}

/// Response message for
/// `ModelService.ListModelVersionCheckpoints`
final class ListModelVersionCheckpointsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelVersionCheckpointsResponse';

  /// List of Model Version checkpoints.
  final List<ModelVersionCheckpoint> checkpoints;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListModelVersionCheckpointsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListModelVersionCheckpointsResponse({
    this.checkpoints = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListModelVersionCheckpointsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelVersionCheckpointsResponse(
      checkpoints: switch (json['checkpoints']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelVersionCheckpoint.fromJson(i),
        ],
        _ => throw const FormatException('"checkpoints" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (checkpoints.isNotDefault) 'checkpoints': encodeList(checkpoints),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListModelVersionCheckpointsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.UpdateModel`.
final class UpdateModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelRequest';

  /// Required. The Model which replaces the resource on the server.
  /// When Model Versioning is enabled, the model.name will be used to determine
  /// whether to update the model or model version.
  /// 1. model.name with the @ value, e.g. models/123@1, refers to a version
  /// specific update.
  /// 2. model.name without the @ value, e.g. models/123, refers to a model
  /// update.
  /// 3. model.name with @-, e.g. models/123@-, refers to a model update.
  /// 4. Supported model fields: display_name, description; supported
  /// version-specific fields: version_description. Labels are supported in both
  /// scenarios. Both the model labels and the version labels are merged when a
  /// model is returned. When updating labels, if the request is for
  /// model-specific update, model label gets updated. Otherwise, version labels
  /// get updated.
  /// 5. A model name or model version name fields update mismatch will cause a
  /// precondition error.
  /// 6. One request cannot update both the model and the version fields. You
  /// must update them separately.
  final Model? model;

  /// Required. The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateModelRequest({required this.model, required this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateModelRequest(
      model: switch (json['model']) {
        null => null,
        Object $1 => Model.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (model != null) 'model': model!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateModelRequest()';
}

/// Request message for
/// `ModelService.UpdateExplanationDataset`.
final class UpdateExplanationDatasetRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExplanationDatasetRequest';

  /// Required. The resource name of the Model to update.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String model;

  /// The example config containing the location of the dataset.
  final Examples? examples;

  UpdateExplanationDatasetRequest({required this.model, this.examples})
    : super(fullyQualifiedName);

  factory UpdateExplanationDatasetRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateExplanationDatasetRequest(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      examples: switch (json['examples']) {
        null => null,
        Object $1 => Examples.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'model': model,
    if (examples != null) 'examples': examples!.toJson(),
  };

  @override
  String toString() {
    final contents = ['model=$model'].join(',');
    return 'UpdateExplanationDatasetRequest($contents)';
  }
}

/// Runtime operation information for
/// `ModelService.UpdateExplanationDataset`.
final class UpdateExplanationDatasetOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExplanationDatasetOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UpdateExplanationDatasetOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateExplanationDatasetOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateExplanationDatasetOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateExplanationDatasetOperationMetadata()';
}

/// Request message for
/// `ModelService.DeleteModel`.
final class DeleteModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelRequest';

  /// Required. The name of the Model resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String name;

  DeleteModelRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteModelRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteModelRequest($contents)';
  }
}

/// Request message for
/// `ModelService.DeleteModelVersion`.
final class DeleteModelVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelVersionRequest';

  /// Required. The name of the model version to be deleted, with a version ID
  /// explicitly included.
  ///
  /// Example: `projects/{project}/locations/{location}/models/{model}@1234`
  final String name;

  DeleteModelVersionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteModelVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteModelVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteModelVersionRequest($contents)';
  }
}

/// Request message for
/// `ModelService.MergeVersionAliases`.
final class MergeVersionAliasesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MergeVersionAliasesRequest';

  /// Required. The name of the model version to merge aliases, with a version ID
  /// explicitly included.
  ///
  /// Example: `projects/{project}/locations/{location}/models/{model}@1234`
  final String name;

  /// Required. The set of version aliases to merge.
  /// The alias should be at most 128 characters, and match
  /// `[a-z][a-zA-Z0-9-]{0,126}[a-z-0-9]`.
  /// Add the `-` prefix to an alias means removing that alias from the version.
  /// `-` is NOT counted in the 128 characters. Example: `-golden` means removing
  /// the `golden` alias from the version.
  ///
  /// There is NO ordering in aliases, which means
  /// 1) The aliases returned from GetModel API might not have the exactly same
  /// order from this MergeVersionAliases API. 2) Adding and deleting the same
  /// alias in the request is not recommended, and the 2 operations will be
  /// cancelled out.
  final List<String> versionAliases;

  MergeVersionAliasesRequest({required this.name, required this.versionAliases})
    : super(fullyQualifiedName);

  factory MergeVersionAliasesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MergeVersionAliasesRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      versionAliases: switch (json['versionAliases']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"versionAliases" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'name': name, 'versionAliases': versionAliases};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'MergeVersionAliasesRequest($contents)';
  }
}

/// Request message for
/// `ModelService.ExportModel`.
final class ExportModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelRequest';

  /// Required. The resource name of the Model to export.
  /// The resource name may contain version id or version alias to specify the
  /// version, if no version is specified, the default version will be exported.
  final String name;

  /// Required. The desired output location and configuration.
  final ExportModelRequest_OutputConfig? outputConfig;

  ExportModelRequest({required this.name, required this.outputConfig})
    : super(fullyQualifiedName);

  factory ExportModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportModelRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      outputConfig: switch (json['outputConfig']) {
        null => null,
        Object $1 => ExportModelRequest_OutputConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (outputConfig != null) 'outputConfig': outputConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ExportModelRequest($contents)';
  }
}

/// Output configuration for the Model export.
final class ExportModelRequest_OutputConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelRequest.OutputConfig';

  /// The ID of the format in which the Model must be exported. Each Model
  /// lists the [export formats it
  /// supports][google.cloud.aiplatform.v1beta1.Model.supported_export_formats].
  /// If no value is provided here, then the first from the list of the Model's
  /// supported formats is used by default.
  final String exportFormatId;

  /// The Cloud Storage location where the Model artifact is to be
  /// written to. Under the directory given as the destination a new one with
  /// name "`model-export-<model-display-name>-<timestamp-of-export-call>`",
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format,
  /// will be created. Inside, the Model and any of its supporting files
  /// will be written.
  /// This field should only be set when the `exportableContent` field of the
  /// [Model.supported_export_formats] object contains `ARTIFACT`.
  final GcsDestination? artifactDestination;

  /// The Google Container Registry or Artifact Registry uri where the
  /// Model container image will be copied to.
  /// This field should only be set when the `exportableContent` field of the
  /// [Model.supported_export_formats] object contains `IMAGE`.
  final ContainerRegistryDestination? imageDestination;

  ExportModelRequest_OutputConfig({
    this.exportFormatId = '',
    this.artifactDestination,
    this.imageDestination,
  }) : super(fullyQualifiedName);

  factory ExportModelRequest_OutputConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportModelRequest_OutputConfig(
      exportFormatId: switch (json['exportFormatId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      artifactDestination: switch (json['artifactDestination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      imageDestination: switch (json['imageDestination']) {
        null => null,
        Object $1 => ContainerRegistryDestination.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (exportFormatId.isNotDefault) 'exportFormatId': exportFormatId,
    if (artifactDestination != null)
      'artifactDestination': artifactDestination!.toJson(),
    if (imageDestination != null)
      'imageDestination': imageDestination!.toJson(),
  };

  @override
  String toString() {
    final contents = ['exportFormatId=$exportFormatId'].join(',');
    return 'OutputConfig($contents)';
  }
}

/// Details of
/// `ModelService.ExportModel`
/// operation.
final class ExportModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. Information further describing the output of this Model
  /// export.
  final ExportModelOperationMetadata_OutputInfo? outputInfo;

  ExportModelOperationMetadata({this.genericMetadata, this.outputInfo})
    : super(fullyQualifiedName);

  factory ExportModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      outputInfo: switch (json['outputInfo']) {
        null => null,
        Object $1 => ExportModelOperationMetadata_OutputInfo.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (outputInfo != null) 'outputInfo': outputInfo!.toJson(),
  };

  @override
  String toString() => 'ExportModelOperationMetadata()';
}

/// Further describes the output of the ExportModel. Supplements
/// `ExportModelRequest.OutputConfig`.
final class ExportModelOperationMetadata_OutputInfo extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelOperationMetadata.OutputInfo';

  /// Output only. If the Model artifact is being exported to Google Cloud
  /// Storage this is the full path of the directory created, into which the
  /// Model files are being written to.
  final String artifactOutputUri;

  /// Output only. If the Model image is being exported to Google Container
  /// Registry or Artifact Registry this is the full path of the image created.
  final String imageOutputUri;

  ExportModelOperationMetadata_OutputInfo({
    this.artifactOutputUri = '',
    this.imageOutputUri = '',
  }) : super(fullyQualifiedName);

  factory ExportModelOperationMetadata_OutputInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportModelOperationMetadata_OutputInfo(
      artifactOutputUri: switch (json['artifactOutputUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      imageOutputUri: switch (json['imageOutputUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (artifactOutputUri.isNotDefault) 'artifactOutputUri': artifactOutputUri,
    if (imageOutputUri.isNotDefault) 'imageOutputUri': imageOutputUri,
  };

  @override
  String toString() {
    final contents = [
      'artifactOutputUri=$artifactOutputUri',
      'imageOutputUri=$imageOutputUri',
    ].join(',');
    return 'OutputInfo($contents)';
  }
}

/// Response message of
/// `ModelService.UpdateExplanationDataset`
/// operation.
final class UpdateExplanationDatasetResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExplanationDatasetResponse';

  UpdateExplanationDatasetResponse() : super(fullyQualifiedName);

  factory UpdateExplanationDatasetResponse.fromJson(Object? j) =>
      UpdateExplanationDatasetResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'UpdateExplanationDatasetResponse()';
}

/// Response message of
/// `ModelService.ExportModel`
/// operation.
final class ExportModelResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelResponse';

  ExportModelResponse() : super(fullyQualifiedName);

  factory ExportModelResponse.fromJson(Object? j) => ExportModelResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'ExportModelResponse()';
}

/// Request message for
/// `ModelService.CopyModel`.
final class CopyModelRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CopyModelRequest';

  /// Optional. Copy source_model into a new Model with this ID. The ID will
  /// become the final component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  final String? modelId;

  /// Optional. Specify this field to copy source_model into this existing
  /// Model as a new version. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  final String? parentModel;

  /// Required. The resource name of the Location into which to copy the Model.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The resource name of the Model to copy. That Model must be in the
  /// same Project. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  final String sourceModel;

  /// Customer-managed encryption key options. If this is set,
  /// then the Model copy will be encrypted with the provided encryption key.
  final EncryptionSpec? encryptionSpec;

  CopyModelRequest({
    this.modelId,
    this.parentModel,
    required this.parent,
    required this.sourceModel,
    this.encryptionSpec,
  }) : super(fullyQualifiedName);

  factory CopyModelRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CopyModelRequest(
      modelId: switch (json['modelId']) {
        null => null,
        Object $1 => decodeString($1),
      },
      parentModel: switch (json['parentModel']) {
        null => null,
        Object $1 => decodeString($1),
      },
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sourceModel: switch (json['sourceModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelId != null) 'modelId': modelId,
    if (parentModel != null) 'parentModel': parentModel,
    'parent': parent,
    'sourceModel': sourceModel,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (modelId != null) 'modelId=$modelId',
      if (parentModel != null) 'parentModel=$parentModel',
      'parent=$parent',
      'sourceModel=$sourceModel',
    ].join(',');
    return 'CopyModelRequest($contents)';
  }
}

/// Details of
/// `ModelService.CopyModel`
/// operation.
final class CopyModelOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CopyModelOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CopyModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CopyModelOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CopyModelOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CopyModelOperationMetadata()';
}

/// Response message of
/// `ModelService.CopyModel`
/// operation.
final class CopyModelResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CopyModelResponse';

  /// The name of the copied Model resource.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String model;

  /// Output only. The version ID of the model that is copied.
  final String modelVersionId;

  CopyModelResponse({this.model = '', this.modelVersionId = ''})
    : super(fullyQualifiedName);

  factory CopyModelResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CopyModelResponse(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersionId: switch (json['modelVersionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (model.isNotDefault) 'model': model,
    if (modelVersionId.isNotDefault) 'modelVersionId': modelVersionId,
  };

  @override
  String toString() {
    final contents = [
      'model=$model',
      'modelVersionId=$modelVersionId',
    ].join(',');
    return 'CopyModelResponse($contents)';
  }
}

/// Request message for
/// `ModelService.ImportModelEvaluation`
final class ImportModelEvaluationRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportModelEvaluationRequest';

  /// Required. The name of the parent model resource.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String parent;

  /// Required. Model evaluation resource to be imported.
  final ModelEvaluation? modelEvaluation;

  ImportModelEvaluationRequest({
    required this.parent,
    required this.modelEvaluation,
  }) : super(fullyQualifiedName);

  factory ImportModelEvaluationRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportModelEvaluationRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelEvaluation: switch (json['modelEvaluation']) {
        null => null,
        Object $1 => ModelEvaluation.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (modelEvaluation != null) 'modelEvaluation': modelEvaluation!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ImportModelEvaluationRequest($contents)';
  }
}

/// Request message for
/// `ModelService.BatchImportModelEvaluationSlices`
final class BatchImportModelEvaluationSlicesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchImportModelEvaluationSlicesRequest';

  /// Required. The name of the parent ModelEvaluation resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  final String parent;

  /// Required. Model evaluation slice resource to be imported.
  final List<ModelEvaluationSlice> modelEvaluationSlices;

  BatchImportModelEvaluationSlicesRequest({
    required this.parent,
    required this.modelEvaluationSlices,
  }) : super(fullyQualifiedName);

  factory BatchImportModelEvaluationSlicesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchImportModelEvaluationSlicesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelEvaluationSlices: switch (json['modelEvaluationSlices']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelEvaluationSlice.fromJson(i),
        ],
        _ => throw const FormatException(
          '"modelEvaluationSlices" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'modelEvaluationSlices': encodeList(modelEvaluationSlices),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchImportModelEvaluationSlicesRequest($contents)';
  }
}

/// Response message for
/// `ModelService.BatchImportModelEvaluationSlices`
final class BatchImportModelEvaluationSlicesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchImportModelEvaluationSlicesResponse';

  /// Output only. List of imported
  /// `ModelEvaluationSlice.name`.
  final List<String> importedModelEvaluationSlices;

  BatchImportModelEvaluationSlicesResponse({
    this.importedModelEvaluationSlices = const [],
  }) : super(fullyQualifiedName);

  factory BatchImportModelEvaluationSlicesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchImportModelEvaluationSlicesResponse(
      importedModelEvaluationSlices:
          switch (json['importedModelEvaluationSlices']) {
            null => [],
            List<Object?> $1 => [for (final i in $1) decodeString(i)],
            _ => throw const FormatException(
              '"importedModelEvaluationSlices" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (importedModelEvaluationSlices.isNotDefault)
      'importedModelEvaluationSlices': importedModelEvaluationSlices,
  };

  @override
  String toString() => 'BatchImportModelEvaluationSlicesResponse()';
}

/// Request message for
/// `ModelService.BatchImportEvaluatedAnnotations`
final class BatchImportEvaluatedAnnotationsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchImportEvaluatedAnnotationsRequest';

  /// Required. The name of the parent ModelEvaluationSlice resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  final String parent;

  /// Required. Evaluated annotations resource to be imported.
  final List<EvaluatedAnnotation> evaluatedAnnotations;

  BatchImportEvaluatedAnnotationsRequest({
    required this.parent,
    required this.evaluatedAnnotations,
  }) : super(fullyQualifiedName);

  factory BatchImportEvaluatedAnnotationsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchImportEvaluatedAnnotationsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      evaluatedAnnotations: switch (json['evaluatedAnnotations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) EvaluatedAnnotation.fromJson(i),
        ],
        _ => throw const FormatException(
          '"evaluatedAnnotations" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'evaluatedAnnotations': encodeList(evaluatedAnnotations),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchImportEvaluatedAnnotationsRequest($contents)';
  }
}

/// Response message for
/// `ModelService.BatchImportEvaluatedAnnotations`
final class BatchImportEvaluatedAnnotationsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchImportEvaluatedAnnotationsResponse';

  /// Output only. Number of EvaluatedAnnotations imported.
  final int importedEvaluatedAnnotationsCount;

  BatchImportEvaluatedAnnotationsResponse({
    this.importedEvaluatedAnnotationsCount = 0,
  }) : super(fullyQualifiedName);

  factory BatchImportEvaluatedAnnotationsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchImportEvaluatedAnnotationsResponse(
      importedEvaluatedAnnotationsCount:
          switch (json['importedEvaluatedAnnotationsCount']) {
            null => 0,
            Object $1 => decodeInt($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (importedEvaluatedAnnotationsCount.isNotDefault)
      'importedEvaluatedAnnotationsCount': importedEvaluatedAnnotationsCount,
  };

  @override
  String toString() {
    final contents = [
      'importedEvaluatedAnnotationsCount=$importedEvaluatedAnnotationsCount',
    ].join(',');
    return 'BatchImportEvaluatedAnnotationsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.GetModelEvaluation`.
final class GetModelEvaluationRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelEvaluationRequest';

  /// Required. The name of the ModelEvaluation resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  final String name;

  GetModelEvaluationRequest({required this.name}) : super(fullyQualifiedName);

  factory GetModelEvaluationRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetModelEvaluationRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelEvaluationRequest($contents)';
  }
}

/// Request message for
/// `ModelService.ListModelEvaluations`.
final class ListModelEvaluationsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelEvaluationsRequest';

  /// Required. The resource name of the Model to list the ModelEvaluations from.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String parent;

  /// The standard list filter.
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListModelEvaluationsResponse.next_page_token`
  /// of the previous
  /// `ModelService.ListModelEvaluations`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListModelEvaluationsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelEvaluationsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelEvaluationsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListModelEvaluationsRequest($contents)';
  }
}

/// Response message for
/// `ModelService.ListModelEvaluations`.
final class ListModelEvaluationsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelEvaluationsResponse';

  /// List of ModelEvaluations in the requested page.
  final List<ModelEvaluation> modelEvaluations;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListModelEvaluationsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListModelEvaluationsResponse({
    this.modelEvaluations = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListModelEvaluationsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelEvaluationsResponse(
      modelEvaluations: switch (json['modelEvaluations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ModelEvaluation.fromJson(i)],
        _ => throw const FormatException('"modelEvaluations" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelEvaluations.isNotDefault)
      'modelEvaluations': encodeList(modelEvaluations),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListModelEvaluationsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.GetModelEvaluationSlice`.
final class GetModelEvaluationSliceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelEvaluationSliceRequest';

  /// Required. The name of the ModelEvaluationSlice resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  final String name;

  GetModelEvaluationSliceRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetModelEvaluationSliceRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetModelEvaluationSliceRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelEvaluationSliceRequest($contents)';
  }
}

/// Request message for
/// `ModelService.ListModelEvaluationSlices`.
final class ListModelEvaluationSlicesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelEvaluationSlicesRequest';

  /// Required. The resource name of the ModelEvaluation to list the
  /// ModelEvaluationSlices from. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  final String parent;

  /// The standard list filter.
  ///
  ///   * `slice.dimension` - for =.
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListModelEvaluationSlicesResponse.next_page_token`
  /// of the previous
  /// `ModelService.ListModelEvaluationSlices`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListModelEvaluationSlicesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelEvaluationSlicesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelEvaluationSlicesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListModelEvaluationSlicesRequest($contents)';
  }
}

/// Response message for
/// `ModelService.ListModelEvaluationSlices`.
final class ListModelEvaluationSlicesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelEvaluationSlicesResponse';

  /// List of ModelEvaluations in the requested page.
  final List<ModelEvaluationSlice> modelEvaluationSlices;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListModelEvaluationSlicesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListModelEvaluationSlicesResponse({
    this.modelEvaluationSlices = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListModelEvaluationSlicesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListModelEvaluationSlicesResponse(
      modelEvaluationSlices: switch (json['modelEvaluationSlices']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModelEvaluationSlice.fromJson(i),
        ],
        _ => throw const FormatException(
          '"modelEvaluationSlices" is not a list',
        ),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelEvaluationSlices.isNotDefault)
      'modelEvaluationSlices': encodeList(modelEvaluationSlices),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListModelEvaluationSlicesResponse($contents)';
  }
}

/// Request message for
/// `ModelService.RecommendSpec`.
final class RecommendSpecRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RecommendSpecRequest';

  /// Required. The resource name of the Location from which to recommend specs.
  /// The users must have permission to make a call in the project.
  /// Format:
  /// `projects/{project}/locations/{location}`.
  final String parent;

  /// Required. The Google Cloud Storage URI of the custom model, storing weights
  /// and config files (which can be used to infer the base model).
  final String gcsUri;

  /// Optional. If true, check machine availability for the recommended regions.
  /// Only return the machine spec in regions where the machine is available.
  final bool checkMachineAvailability;

  /// Optional. If true, check user quota for the recommended regions.
  /// Returns all the machine spec in regions they are available, and also the
  /// user quota state for each machine type in each region.
  final bool checkUserQuota;

  RecommendSpecRequest({
    required this.parent,
    required this.gcsUri,
    this.checkMachineAvailability = false,
    this.checkUserQuota = false,
  }) : super(fullyQualifiedName);

  factory RecommendSpecRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RecommendSpecRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      gcsUri: switch (json['gcsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      checkMachineAvailability: switch (json['checkMachineAvailability']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      checkUserQuota: switch (json['checkUserQuota']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'gcsUri': gcsUri,
    if (checkMachineAvailability.isNotDefault)
      'checkMachineAvailability': checkMachineAvailability,
    if (checkUserQuota.isNotDefault) 'checkUserQuota': checkUserQuota,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'gcsUri=$gcsUri',
      'checkMachineAvailability=$checkMachineAvailability',
      'checkUserQuota=$checkUserQuota',
    ].join(',');
    return 'RecommendSpecRequest($contents)';
  }
}

/// Response message for
/// `ModelService.RecommendSpec`.
final class RecommendSpecResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RecommendSpecResponse';

  /// Output only. The base model used to finetune the custom model.
  final String baseModel;

  /// Output only. Recommendations of deployment options for the given custom
  /// weights model.
  final List<RecommendSpecResponse_Recommendation> recommendations;

  /// Output only. The machine and model container specs.
  final List<RecommendSpecResponse_MachineAndModelContainerSpec> specs;

  RecommendSpecResponse({
    this.baseModel = '',
    this.recommendations = const [],
    this.specs = const [],
  }) : super(fullyQualifiedName);

  factory RecommendSpecResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RecommendSpecResponse(
      baseModel: switch (json['baseModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      recommendations: switch (json['recommendations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) RecommendSpecResponse_Recommendation.fromJson(i),
        ],
        _ => throw const FormatException('"recommendations" is not a list'),
      },
      specs: switch (json['specs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            RecommendSpecResponse_MachineAndModelContainerSpec.fromJson(i),
        ],
        _ => throw const FormatException('"specs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (baseModel.isNotDefault) 'baseModel': baseModel,
    if (recommendations.isNotDefault)
      'recommendations': encodeList(recommendations),
    if (specs.isNotDefault) 'specs': encodeList(specs),
  };

  @override
  String toString() {
    final contents = ['baseModel=$baseModel'].join(',');
    return 'RecommendSpecResponse($contents)';
  }
}

/// A machine and model container spec.
final class RecommendSpecResponse_MachineAndModelContainerSpec
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RecommendSpecResponse.MachineAndModelContainerSpec';

  /// Output only. The machine spec.
  final MachineSpec? machineSpec;

  /// Output only. The model container spec.
  final ModelContainerSpec? containerSpec;

  RecommendSpecResponse_MachineAndModelContainerSpec({
    this.machineSpec,
    this.containerSpec,
  }) : super(fullyQualifiedName);

  factory RecommendSpecResponse_MachineAndModelContainerSpec.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return RecommendSpecResponse_MachineAndModelContainerSpec(
      machineSpec: switch (json['machineSpec']) {
        null => null,
        Object $1 => MachineSpec.fromJson($1),
      },
      containerSpec: switch (json['containerSpec']) {
        null => null,
        Object $1 => ModelContainerSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
    if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
  };

  @override
  String toString() => 'MachineAndModelContainerSpec()';
}

/// Recommendation of one deployment option for the given custom weights model
/// in one region.
/// Contains the machine and container spec, and user accelerator quota state.
final class RecommendSpecResponse_Recommendation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RecommendSpecResponse.Recommendation';

  /// The region for the deployment spec (machine).
  final String region;

  /// Output only. The machine and model container specs.
  final RecommendSpecResponse_MachineAndModelContainerSpec? spec;

  /// Output only. The user accelerator quota state.
  final RecommendSpecResponse_Recommendation_QuotaState userQuotaState;

  RecommendSpecResponse_Recommendation({
    this.region = '',
    this.spec,
    this.userQuotaState =
        RecommendSpecResponse_Recommendation_QuotaState.$default,
  }) : super(fullyQualifiedName);

  factory RecommendSpecResponse_Recommendation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RecommendSpecResponse_Recommendation(
      region: switch (json['region']) {
        null => '',
        Object $1 => decodeString($1),
      },
      spec: switch (json['spec']) {
        null => null,
        Object $1 =>
          RecommendSpecResponse_MachineAndModelContainerSpec.fromJson($1),
      },
      userQuotaState: switch (json['userQuotaState']) {
        null => RecommendSpecResponse_Recommendation_QuotaState.$default,
        Object $1 => RecommendSpecResponse_Recommendation_QuotaState.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (region.isNotDefault) 'region': region,
    if (spec != null) 'spec': spec!.toJson(),
    if (userQuotaState.isNotDefault) 'userQuotaState': userQuotaState.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'region=$region',
      'userQuotaState=$userQuotaState',
    ].join(',');
    return 'Recommendation($contents)';
  }
}

/// The user accelerator quota state.
final class RecommendSpecResponse_Recommendation_QuotaState extends ProtoEnum {
  /// Unspecified quota state. Quota information not available.
  static const quotaStateUnspecified =
      RecommendSpecResponse_Recommendation_QuotaState(
        'QUOTA_STATE_UNSPECIFIED',
      );

  /// User has enough accelerator quota for the machine type.
  static const quotaStateUserHasQuota =
      RecommendSpecResponse_Recommendation_QuotaState(
        'QUOTA_STATE_USER_HAS_QUOTA',
      );

  /// User does not have enough accelerator quota for the machine type.
  static const quotaStateNoUserQuota =
      RecommendSpecResponse_Recommendation_QuotaState(
        'QUOTA_STATE_NO_USER_QUOTA',
      );

  /// The default value for [RecommendSpecResponse_Recommendation_QuotaState].
  static const $default = quotaStateUnspecified;

  const RecommendSpecResponse_Recommendation_QuotaState(super.value);

  factory RecommendSpecResponse_Recommendation_QuotaState.fromJson(
    Object? json,
  ) => RecommendSpecResponse_Recommendation_QuotaState(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'QuotaState.$value';
}

/// Represents a Neural Architecture Search (NAS) job.
final class NasJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJob';

  /// Output only. Resource name of the NasJob.
  final String name;

  /// Required. The display name of the NasJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Required. The specification of a NasJob.
  final NasJobSpec? nasJobSpec;

  /// Output only. Output of the NasJob.
  final NasJobOutput? nasJobOutput;

  /// Output only. The detailed state of the job.
  final JobState state;

  /// Output only. Time when the NasJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the NasJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the NasJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the NasJob was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  final Status? error;

  /// The labels with user-defined metadata to organize NasJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Customer-managed encryption key options for a NasJob.
  /// If this is set, then all resources created by the NasJob
  /// will be encrypted with the provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// Optional. Enable a separation of Custom model training
  /// and restricted image training for tenant project.
  final bool enableRestrictedImageTraining;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  NasJob({
    this.name = '',
    required this.displayName,
    required this.nasJobSpec,
    this.nasJobOutput,
    this.state = JobState.$default,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.error,
    this.labels = const {},
    this.encryptionSpec,
    this.enableRestrictedImageTraining = false,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory NasJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NasJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      nasJobSpec: switch (json['nasJobSpec']) {
        null => null,
        Object $1 => NasJobSpec.fromJson($1),
      },
      nasJobOutput: switch (json['nasJobOutput']) {
        null => null,
        Object $1 => NasJobOutput.fromJson($1),
      },
      state: switch (json['state']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      enableRestrictedImageTraining:
          switch (json['enableRestrictedImageTraining']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (nasJobSpec != null) 'nasJobSpec': nasJobSpec!.toJson(),
    if (nasJobOutput != null) 'nasJobOutput': nasJobOutput!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (enableRestrictedImageTraining.isNotDefault)
      'enableRestrictedImageTraining': enableRestrictedImageTraining,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'state=$state',
      'enableRestrictedImageTraining=$enableRestrictedImageTraining',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'NasJob($contents)';
  }
}

/// Represents a NasTrial details along with its parameters. If there is a
/// corresponding train NasTrial, the train NasTrial is also returned.
final class NasTrialDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasTrialDetail';

  /// Output only. Resource name of the NasTrialDetail.
  final String name;

  /// The parameters for the NasJob NasTrial.
  final String parameters;

  /// The requested search NasTrial.
  final NasTrial? searchTrial;

  /// The train NasTrial corresponding to
  /// `search_trial`.
  /// Only populated if
  /// `search_trial`
  /// is used for training.
  final NasTrial? trainTrial;

  NasTrialDetail({
    this.name = '',
    this.parameters = '',
    this.searchTrial,
    this.trainTrial,
  }) : super(fullyQualifiedName);

  factory NasTrialDetail.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NasTrialDetail(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parameters: switch (json['parameters']) {
        null => '',
        Object $1 => decodeString($1),
      },
      searchTrial: switch (json['searchTrial']) {
        null => null,
        Object $1 => NasTrial.fromJson($1),
      },
      trainTrial: switch (json['trainTrial']) {
        null => null,
        Object $1 => NasTrial.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (parameters.isNotDefault) 'parameters': parameters,
    if (searchTrial != null) 'searchTrial': searchTrial!.toJson(),
    if (trainTrial != null) 'trainTrial': trainTrial!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'parameters=$parameters'].join(',');
    return 'NasTrialDetail($contents)';
  }
}

/// Represents the spec of a NasJob.
final class NasJobSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec';

  /// The spec of multi-trial algorithms.
  final NasJobSpec_MultiTrialAlgorithmSpec? multiTrialAlgorithmSpec;

  /// The ID of the existing NasJob in the same Project and Location
  /// which will be used to resume search. search_space_spec and
  /// nas_algorithm_spec are obtained from previous NasJob hence should not
  /// provide them again for this NasJob.
  final String resumeNasJobId;

  /// It defines the search space for Neural Architecture Search (NAS).
  final String searchSpaceSpec;

  NasJobSpec({
    this.multiTrialAlgorithmSpec,
    this.resumeNasJobId = '',
    this.searchSpaceSpec = '',
  }) : super(fullyQualifiedName);

  factory NasJobSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NasJobSpec(
      multiTrialAlgorithmSpec: switch (json['multiTrialAlgorithmSpec']) {
        null => null,
        Object $1 => NasJobSpec_MultiTrialAlgorithmSpec.fromJson($1),
      },
      resumeNasJobId: switch (json['resumeNasJobId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      searchSpaceSpec: switch (json['searchSpaceSpec']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (multiTrialAlgorithmSpec != null)
      'multiTrialAlgorithmSpec': multiTrialAlgorithmSpec!.toJson(),
    if (resumeNasJobId.isNotDefault) 'resumeNasJobId': resumeNasJobId,
    if (searchSpaceSpec.isNotDefault) 'searchSpaceSpec': searchSpaceSpec,
  };

  @override
  String toString() {
    final contents = [
      'resumeNasJobId=$resumeNasJobId',
      'searchSpaceSpec=$searchSpaceSpec',
    ].join(',');
    return 'NasJobSpec($contents)';
  }
}

/// The spec of multi-trial Neural Architecture Search (NAS).
final class NasJobSpec_MultiTrialAlgorithmSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec.MultiTrialAlgorithmSpec';

  /// The multi-trial Neural Architecture Search (NAS) algorithm
  /// type. Defaults to `REINFORCEMENT_LEARNING`.
  final NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm
  multiTrialAlgorithm;

  /// Metric specs for the NAS job.
  /// Validation for this field is done at `multi_trial_algorithm_spec` field.
  final NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec? metric;

  /// Required. Spec for search trials.
  final NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec? searchTrialSpec;

  /// Spec for train trials. Top N [TrainTrialSpec.max_parallel_trial_count]
  /// search trials will be trained for every M
  /// [TrainTrialSpec.frequency] trials searched.
  final NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec? trainTrialSpec;

  NasJobSpec_MultiTrialAlgorithmSpec({
    this.multiTrialAlgorithm =
        NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.$default,
    this.metric,
    required this.searchTrialSpec,
    this.trainTrialSpec,
  }) : super(fullyQualifiedName);

  factory NasJobSpec_MultiTrialAlgorithmSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NasJobSpec_MultiTrialAlgorithmSpec(
      multiTrialAlgorithm: switch (json['multiTrialAlgorithm']) {
        null => NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.$default,
        Object $1 =>
          NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.fromJson($1),
      },
      metric: switch (json['metric']) {
        null => null,
        Object $1 => NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.fromJson($1),
      },
      searchTrialSpec: switch (json['searchTrialSpec']) {
        null => null,
        Object $1 =>
          NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.fromJson($1),
      },
      trainTrialSpec: switch (json['trainTrialSpec']) {
        null => null,
        Object $1 => NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (multiTrialAlgorithm.isNotDefault)
      'multiTrialAlgorithm': multiTrialAlgorithm.toJson(),
    if (metric != null) 'metric': metric!.toJson(),
    if (searchTrialSpec != null) 'searchTrialSpec': searchTrialSpec!.toJson(),
    if (trainTrialSpec != null) 'trainTrialSpec': trainTrialSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = ['multiTrialAlgorithm=$multiTrialAlgorithm'].join(',');
    return 'MultiTrialAlgorithmSpec($contents)';
  }
}

/// Represents a metric to optimize.
final class NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec';

  /// Required. The ID of the metric. Must not contain whitespaces.
  final String metricId;

  /// Required. The optimization goal of the metric.
  final NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType goal;

  NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec({
    required this.metricId,
    required this.goal,
  }) : super(fullyQualifiedName);

  factory NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec(
      metricId: switch (json['metricId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      goal: switch (json['goal']) {
        null => NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.$default,
        Object $1 =>
          NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {'metricId': metricId, 'goal': goal.toJson()};

  @override
  String toString() {
    final contents = ['metricId=$metricId', 'goal=$goal'].join(',');
    return 'MetricSpec($contents)';
  }
}

/// The available types of optimization goals.
final class NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType
    extends ProtoEnum {
  /// Goal Type will default to maximize.
  static const goalTypeUnspecified =
      NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType(
        'GOAL_TYPE_UNSPECIFIED',
      );

  /// Maximize the goal metric.
  static const maximize =
      NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType('MAXIMIZE');

  /// Minimize the goal metric.
  static const minimize =
      NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType('MINIMIZE');

  /// The default value for [NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType].
  static const $default = goalTypeUnspecified;

  const NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType(super.value);

  factory NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.fromJson(
    Object? json,
  ) => NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'GoalType.$value';
}

/// Represent spec for search trials.
final class NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec';

  /// Required. The spec of a search trial job. The same spec applies to
  /// all search trials.
  final CustomJobSpec? searchTrialJobSpec;

  /// Required. The maximum number of Neural Architecture Search (NAS) trials
  /// to run.
  final int maxTrialCount;

  /// Required. The maximum number of trials to run in parallel.
  final int maxParallelTrialCount;

  /// The number of failed trials that need to be seen before failing
  /// the NasJob.
  ///
  /// If set to 0, Vertex AI decides how many trials must fail
  /// before the whole job fails.
  final int maxFailedTrialCount;

  NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec({
    required this.searchTrialJobSpec,
    required this.maxTrialCount,
    required this.maxParallelTrialCount,
    this.maxFailedTrialCount = 0,
  }) : super(fullyQualifiedName);

  factory NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec(
      searchTrialJobSpec: switch (json['searchTrialJobSpec']) {
        null => null,
        Object $1 => CustomJobSpec.fromJson($1),
      },
      maxTrialCount: switch (json['maxTrialCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      maxParallelTrialCount: switch (json['maxParallelTrialCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      maxFailedTrialCount: switch (json['maxFailedTrialCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (searchTrialJobSpec != null)
      'searchTrialJobSpec': searchTrialJobSpec!.toJson(),
    'maxTrialCount': maxTrialCount,
    'maxParallelTrialCount': maxParallelTrialCount,
    if (maxFailedTrialCount.isNotDefault)
      'maxFailedTrialCount': maxFailedTrialCount,
  };

  @override
  String toString() {
    final contents = [
      'maxTrialCount=$maxTrialCount',
      'maxParallelTrialCount=$maxParallelTrialCount',
      'maxFailedTrialCount=$maxFailedTrialCount',
    ].join(',');
    return 'SearchTrialSpec($contents)';
  }
}

/// Represent spec for train trials.
final class NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec';

  /// Required. The spec of a train trial job. The same spec applies to
  /// all train trials.
  final CustomJobSpec? trainTrialJobSpec;

  /// Required. The maximum number of trials to run in parallel.
  final int maxParallelTrialCount;

  /// Required. Frequency of search trials to start train stage. Top N
  /// [TrainTrialSpec.max_parallel_trial_count]
  /// search trials will be trained for every M
  /// [TrainTrialSpec.frequency] trials searched.
  final int frequency;

  NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec({
    required this.trainTrialJobSpec,
    required this.maxParallelTrialCount,
    required this.frequency,
  }) : super(fullyQualifiedName);

  factory NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec(
      trainTrialJobSpec: switch (json['trainTrialJobSpec']) {
        null => null,
        Object $1 => CustomJobSpec.fromJson($1),
      },
      maxParallelTrialCount: switch (json['maxParallelTrialCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      frequency: switch (json['frequency']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trainTrialJobSpec != null)
      'trainTrialJobSpec': trainTrialJobSpec!.toJson(),
    'maxParallelTrialCount': maxParallelTrialCount,
    'frequency': frequency,
  };

  @override
  String toString() {
    final contents = [
      'maxParallelTrialCount=$maxParallelTrialCount',
      'frequency=$frequency',
    ].join(',');
    return 'TrainTrialSpec($contents)';
  }
}

/// The available types of multi-trial algorithms.
final class NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm
    extends ProtoEnum {
  /// Defaults to `REINFORCEMENT_LEARNING`.
  static const multiTrialAlgorithmUnspecified =
      NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm(
        'MULTI_TRIAL_ALGORITHM_UNSPECIFIED',
      );

  /// The Reinforcement Learning Algorithm for Multi-trial Neural
  /// Architecture Search (NAS).
  static const reinforcementLearning =
      NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm(
        'REINFORCEMENT_LEARNING',
      );

  /// The Grid Search Algorithm for Multi-trial Neural
  /// Architecture Search (NAS).
  static const gridSearch =
      NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm('GRID_SEARCH');

  /// The default value for [NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm].
  static const $default = multiTrialAlgorithmUnspecified;

  const NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm(super.value);

  factory NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.fromJson(
    Object? json,
  ) => NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'MultiTrialAlgorithm.$value';
}

/// Represents a uCAIP NasJob output.
final class NasJobOutput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobOutput';

  /// Output only. The output of this multi-trial Neural Architecture Search
  /// (NAS) job.
  final NasJobOutput_MultiTrialJobOutput? multiTrialJobOutput;

  NasJobOutput({this.multiTrialJobOutput}) : super(fullyQualifiedName);

  factory NasJobOutput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NasJobOutput(
      multiTrialJobOutput: switch (json['multiTrialJobOutput']) {
        null => null,
        Object $1 => NasJobOutput_MultiTrialJobOutput.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (multiTrialJobOutput != null)
      'multiTrialJobOutput': multiTrialJobOutput!.toJson(),
  };

  @override
  String toString() => 'NasJobOutput()';
}

/// The output of a multi-trial Neural Architecture Search (NAS) jobs.
final class NasJobOutput_MultiTrialJobOutput extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobOutput.MultiTrialJobOutput';

  /// Output only. List of NasTrials that were started as part of search stage.
  final List<NasTrial> searchTrials;

  /// Output only. List of NasTrials that were started as part of train stage.
  final List<NasTrial> trainTrials;

  NasJobOutput_MultiTrialJobOutput({
    this.searchTrials = const [],
    this.trainTrials = const [],
  }) : super(fullyQualifiedName);

  factory NasJobOutput_MultiTrialJobOutput.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NasJobOutput_MultiTrialJobOutput(
      searchTrials: switch (json['searchTrials']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) NasTrial.fromJson(i)],
        _ => throw const FormatException('"searchTrials" is not a list'),
      },
      trainTrials: switch (json['trainTrials']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) NasTrial.fromJson(i)],
        _ => throw const FormatException('"trainTrials" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (searchTrials.isNotDefault) 'searchTrials': encodeList(searchTrials),
    if (trainTrials.isNotDefault) 'trainTrials': encodeList(trainTrials),
  };

  @override
  String toString() => 'MultiTrialJobOutput()';
}

/// Represents a uCAIP NasJob trial.
final class NasTrial extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasTrial';

  /// Output only. The identifier of the NasTrial assigned by the service.
  final String id;

  /// Output only. The detailed state of the NasTrial.
  final NasTrial_State state;

  /// Output only. The final measurement containing the objective value.
  final Measurement? finalMeasurement;

  /// Output only. Time when the NasTrial was started.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the NasTrial's status changed to `SUCCEEDED` or
  /// `INFEASIBLE`.
  final protobuf.Timestamp? endTime;

  NasTrial({
    this.id = '',
    this.state = NasTrial_State.$default,
    this.finalMeasurement,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory NasTrial.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NasTrial(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => NasTrial_State.$default,
        Object $1 => NasTrial_State.fromJson($1),
      },
      finalMeasurement: switch (json['finalMeasurement']) {
        null => null,
        Object $1 => Measurement.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    if (state.isNotDefault) 'state': state.toJson(),
    if (finalMeasurement != null)
      'finalMeasurement': finalMeasurement!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['id=$id', 'state=$state'].join(',');
    return 'NasTrial($contents)';
  }
}

/// Describes a NasTrial state.
final class NasTrial_State extends ProtoEnum {
  /// The NasTrial state is unspecified.
  static const stateUnspecified = NasTrial_State('STATE_UNSPECIFIED');

  /// Indicates that a specific NasTrial has been requested, but it has not yet
  /// been suggested by the service.
  static const requested = NasTrial_State('REQUESTED');

  /// Indicates that the NasTrial has been suggested.
  static const active = NasTrial_State('ACTIVE');

  /// Indicates that the NasTrial should stop according to the service.
  static const stopping = NasTrial_State('STOPPING');

  /// Indicates that the NasTrial is completed successfully.
  static const succeeded = NasTrial_State('SUCCEEDED');

  /// Indicates that the NasTrial should not be attempted again.
  /// The service will set a NasTrial to INFEASIBLE when it's done but missing
  /// the final_measurement.
  static const infeasible = NasTrial_State('INFEASIBLE');

  /// The default value for [NasTrial_State].
  static const $default = stateUnspecified;

  const NasTrial_State(super.value);

  factory NasTrial_State.fromJson(Object? json) =>
      NasTrial_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Network spec.
final class NetworkSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NetworkSpec';

  /// Whether to enable public internet access. Default false.
  final bool enableInternetAccess;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  final String network;

  /// The name of the subnet that this instance is in.
  /// Format:
  /// `projects/{project_id_or_number}/regions/{region}/subnetworks/{subnetwork_id}`
  final String subnetwork;

  NetworkSpec({
    this.enableInternetAccess = false,
    this.network = '',
    this.subnetwork = '',
  }) : super(fullyQualifiedName);

  factory NetworkSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NetworkSpec(
      enableInternetAccess: switch (json['enableInternetAccess']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      network: switch (json['network']) {
        null => '',
        Object $1 => decodeString($1),
      },
      subnetwork: switch (json['subnetwork']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enableInternetAccess.isNotDefault)
      'enableInternetAccess': enableInternetAccess,
    if (network.isNotDefault) 'network': network,
    if (subnetwork.isNotDefault) 'subnetwork': subnetwork,
  };

  @override
  String toString() {
    final contents = [
      'enableInternetAccess=$enableInternetAccess',
      'network=$network',
      'subnetwork=$subnetwork',
    ].join(',');
    return 'NetworkSpec($contents)';
  }
}

/// The euc configuration of NotebookRuntimeTemplate.
final class NotebookEucConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookEucConfig';

  /// Input only. Whether EUC is disabled in this NotebookRuntimeTemplate.
  /// In proto3, the default value of a boolean is false. In this way, by default
  /// EUC will be enabled for NotebookRuntimeTemplate.
  final bool eucDisabled;

  /// Output only. Whether ActAs check is bypassed for service account attached
  /// to the VM. If false, we need ActAs check for the default Compute Engine
  /// Service account. When a Runtime is created, a VM is allocated using Default
  /// Compute Engine Service Account. Any user requesting to use this Runtime
  /// requires Service Account User (ActAs) permission over this SA. If true,
  /// Runtime owner is using EUC and does not require the above permission as VM
  /// no longer use default Compute Engine SA, but a P4SA.
  final bool bypassActasCheck;

  NotebookEucConfig({this.eucDisabled = false, this.bypassActasCheck = false})
    : super(fullyQualifiedName);

  factory NotebookEucConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookEucConfig(
      eucDisabled: switch (json['eucDisabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      bypassActasCheck: switch (json['bypassActasCheck']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (eucDisabled.isNotDefault) 'eucDisabled': eucDisabled,
    if (bypassActasCheck.isNotDefault) 'bypassActasCheck': bypassActasCheck,
  };

  @override
  String toString() {
    final contents = [
      'eucDisabled=$eucDisabled',
      'bypassActasCheck=$bypassActasCheck',
    ].join(',');
    return 'NotebookEucConfig($contents)';
  }
}

/// NotebookExecutionJob represents an instance of a notebook execution.
final class NotebookExecutionJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob';

  /// The Dataform Repository pointing to a single file notebook repository.
  final NotebookExecutionJob_DataformRepositorySource? dataformRepositorySource;

  /// The Cloud Storage url pointing to the ipynb file. Format:
  /// `gs://bucket/notebook_file.ipynb`
  final NotebookExecutionJob_GcsNotebookSource? gcsNotebookSource;

  /// The contents of an input notebook file.
  final NotebookExecutionJob_DirectNotebookSource? directNotebookSource;

  /// The NotebookRuntimeTemplate to source compute configuration from.
  final String? notebookRuntimeTemplateResourceName;

  /// The custom compute configuration for an execution job.
  final NotebookExecutionJob_CustomEnvironmentSpec? customEnvironmentSpec;

  /// The Cloud Storage location to upload the result to. Format:
  /// `gs://bucket-name`
  final String? gcsOutputUri;

  /// The user email to run the execution as. Only supported by Colab runtimes.
  final String? executionUser;

  /// The service account to run the execution as.
  final String? serviceAccount;

  /// The Workbench runtime configuration to use for the notebook execution.
  final NotebookExecutionJob_WorkbenchRuntime? workbenchRuntime;

  /// Output only. The resource name of this NotebookExecutionJob. Format:
  /// `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
  final String name;

  /// The display name of the NotebookExecutionJob. The name can be up to 128
  /// characters long and can consist of any UTF-8 characters.
  final String displayName;

  /// Max running time of the execution job in seconds (default 86400s / 24 hrs).
  final protobuf.Duration? executionTimeout;

  /// The Schedule resource name if this job is triggered by one. Format:
  /// `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
  final String scheduleResourceName;

  /// Output only. The state of the NotebookExecutionJob.
  final JobState jobState;

  /// Output only. Populated when the NotebookExecutionJob is completed. When
  /// there is an error during notebook execution, the error details are
  /// populated.
  final Status? status;

  /// Output only. Timestamp when this NotebookExecutionJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this NotebookExecutionJob was most recently
  /// updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize NotebookExecutionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> labels;

  /// The name of the kernel to use during notebook execution. If unset, the
  /// default kernel is used.
  final String kernelName;

  /// Customer-managed encryption key spec for the notebook execution job.
  /// This field is auto-populated if the
  /// `NotebookRuntimeTemplate`
  /// has an encryption spec.
  final EncryptionSpec? encryptionSpec;

  NotebookExecutionJob({
    this.dataformRepositorySource,
    this.gcsNotebookSource,
    this.directNotebookSource,
    this.notebookRuntimeTemplateResourceName,
    this.customEnvironmentSpec,
    this.gcsOutputUri,
    this.executionUser,
    this.serviceAccount,
    this.workbenchRuntime,
    this.name = '',
    this.displayName = '',
    this.executionTimeout,
    this.scheduleResourceName = '',
    this.jobState = JobState.$default,
    this.status,
    this.createTime,
    this.updateTime,
    this.labels = const {},
    this.kernelName = '',
    this.encryptionSpec,
  }) : super(fullyQualifiedName);

  factory NotebookExecutionJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookExecutionJob(
      dataformRepositorySource: switch (json['dataformRepositorySource']) {
        null => null,
        Object $1 => NotebookExecutionJob_DataformRepositorySource.fromJson($1),
      },
      gcsNotebookSource: switch (json['gcsNotebookSource']) {
        null => null,
        Object $1 => NotebookExecutionJob_GcsNotebookSource.fromJson($1),
      },
      directNotebookSource: switch (json['directNotebookSource']) {
        null => null,
        Object $1 => NotebookExecutionJob_DirectNotebookSource.fromJson($1),
      },
      notebookRuntimeTemplateResourceName:
          switch (json['notebookRuntimeTemplateResourceName']) {
            null => null,
            Object $1 => decodeString($1),
          },
      customEnvironmentSpec: switch (json['customEnvironmentSpec']) {
        null => null,
        Object $1 => NotebookExecutionJob_CustomEnvironmentSpec.fromJson($1),
      },
      gcsOutputUri: switch (json['gcsOutputUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      executionUser: switch (json['executionUser']) {
        null => null,
        Object $1 => decodeString($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => null,
        Object $1 => decodeString($1),
      },
      workbenchRuntime: switch (json['workbenchRuntime']) {
        null => null,
        Object $1 => NotebookExecutionJob_WorkbenchRuntime.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      executionTimeout: switch (json['executionTimeout']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      scheduleResourceName: switch (json['scheduleResourceName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      jobState: switch (json['jobState']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      status: switch (json['status']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      kernelName: switch (json['kernelName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataformRepositorySource != null)
      'dataformRepositorySource': dataformRepositorySource!.toJson(),
    if (gcsNotebookSource != null)
      'gcsNotebookSource': gcsNotebookSource!.toJson(),
    if (directNotebookSource != null)
      'directNotebookSource': directNotebookSource!.toJson(),
    if (notebookRuntimeTemplateResourceName != null)
      'notebookRuntimeTemplateResourceName':
          notebookRuntimeTemplateResourceName,
    if (customEnvironmentSpec != null)
      'customEnvironmentSpec': customEnvironmentSpec!.toJson(),
    if (gcsOutputUri != null) 'gcsOutputUri': gcsOutputUri,
    if (executionUser != null) 'executionUser': executionUser,
    if (serviceAccount != null) 'serviceAccount': serviceAccount,
    if (workbenchRuntime != null)
      'workbenchRuntime': workbenchRuntime!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (executionTimeout != null)
      'executionTimeout': executionTimeout!.toJson(),
    if (scheduleResourceName.isNotDefault)
      'scheduleResourceName': scheduleResourceName,
    if (jobState.isNotDefault) 'jobState': jobState.toJson(),
    if (status != null) 'status': status!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (kernelName.isNotDefault) 'kernelName': kernelName,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (notebookRuntimeTemplateResourceName != null)
        'notebookRuntimeTemplateResourceName=$notebookRuntimeTemplateResourceName',
      if (gcsOutputUri != null) 'gcsOutputUri=$gcsOutputUri',
      if (executionUser != null) 'executionUser=$executionUser',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      'name=$name',
      'displayName=$displayName',
      'scheduleResourceName=$scheduleResourceName',
      'jobState=$jobState',
      'kernelName=$kernelName',
    ].join(',');
    return 'NotebookExecutionJob($contents)';
  }
}

/// The Dataform Repository containing the input notebook.
final class NotebookExecutionJob_DataformRepositorySource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.DataformRepositorySource';

  /// The resource name of the Dataform Repository. Format:
  /// `projects/{project_id}/locations/{location}/repositories/{repository_id}`
  final String dataformRepositoryResourceName;

  /// The commit SHA to read repository with. If unset, the file will be read
  /// at HEAD.
  final String commitSha;

  NotebookExecutionJob_DataformRepositorySource({
    this.dataformRepositoryResourceName = '',
    this.commitSha = '',
  }) : super(fullyQualifiedName);

  factory NotebookExecutionJob_DataformRepositorySource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookExecutionJob_DataformRepositorySource(
      dataformRepositoryResourceName:
          switch (json['dataformRepositoryResourceName']) {
            null => '',
            Object $1 => decodeString($1),
          },
      commitSha: switch (json['commitSha']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataformRepositoryResourceName.isNotDefault)
      'dataformRepositoryResourceName': dataformRepositoryResourceName,
    if (commitSha.isNotDefault) 'commitSha': commitSha,
  };

  @override
  String toString() {
    final contents = [
      'dataformRepositoryResourceName=$dataformRepositoryResourceName',
      'commitSha=$commitSha',
    ].join(',');
    return 'DataformRepositorySource($contents)';
  }
}

/// The Cloud Storage uri for the input notebook.
final class NotebookExecutionJob_GcsNotebookSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.GcsNotebookSource';

  /// The Cloud Storage uri pointing to the ipynb file. Format:
  /// `gs://bucket/notebook_file.ipynb`
  final String uri;

  /// The version of the Cloud Storage object to read. If unset, the current
  /// version of the object is read. See
  /// https://cloud.google.com/storage/docs/metadata#generation-number.
  final String generation;

  NotebookExecutionJob_GcsNotebookSource({this.uri = '', this.generation = ''})
    : super(fullyQualifiedName);

  factory NotebookExecutionJob_GcsNotebookSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookExecutionJob_GcsNotebookSource(
      uri: switch (json['uri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (uri.isNotDefault) 'uri': uri,
    if (generation.isNotDefault) 'generation': generation,
  };

  @override
  String toString() {
    final contents = ['uri=$uri', 'generation=$generation'].join(',');
    return 'GcsNotebookSource($contents)';
  }
}

/// The content of the input notebook in ipynb format.
final class NotebookExecutionJob_DirectNotebookSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.DirectNotebookSource';

  /// The base64-encoded contents of the input notebook file.
  final Uint8List content;

  NotebookExecutionJob_DirectNotebookSource({Uint8List? content})
    : content = content ?? Uint8List(0),
      super(fullyQualifiedName);

  factory NotebookExecutionJob_DirectNotebookSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookExecutionJob_DirectNotebookSource(
      content: switch (json['content']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (content.isNotDefault) 'content': encodeBytes(content),
  };

  @override
  String toString() {
    final contents = ['content=$content'].join(',');
    return 'DirectNotebookSource($contents)';
  }
}

/// Compute configuration to use for an execution job.
final class NotebookExecutionJob_CustomEnvironmentSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.CustomEnvironmentSpec';

  /// The specification of a single machine for the execution job.
  final MachineSpec? machineSpec;

  /// The specification of a persistent disk to attach for the execution job.
  final PersistentDiskSpec? persistentDiskSpec;

  /// The network configuration to use for the execution job.
  final NetworkSpec? networkSpec;

  NotebookExecutionJob_CustomEnvironmentSpec({
    this.machineSpec,
    this.persistentDiskSpec,
    this.networkSpec,
  }) : super(fullyQualifiedName);

  factory NotebookExecutionJob_CustomEnvironmentSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookExecutionJob_CustomEnvironmentSpec(
      machineSpec: switch (json['machineSpec']) {
        null => null,
        Object $1 => MachineSpec.fromJson($1),
      },
      persistentDiskSpec: switch (json['persistentDiskSpec']) {
        null => null,
        Object $1 => PersistentDiskSpec.fromJson($1),
      },
      networkSpec: switch (json['networkSpec']) {
        null => null,
        Object $1 => NetworkSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
    if (persistentDiskSpec != null)
      'persistentDiskSpec': persistentDiskSpec!.toJson(),
    if (networkSpec != null) 'networkSpec': networkSpec!.toJson(),
  };

  @override
  String toString() => 'CustomEnvironmentSpec()';
}

/// Configuration for a Workbench Instances-based environment.
final class NotebookExecutionJob_WorkbenchRuntime extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.WorkbenchRuntime';

  NotebookExecutionJob_WorkbenchRuntime() : super(fullyQualifiedName);

  factory NotebookExecutionJob_WorkbenchRuntime.fromJson(Object? j) =>
      NotebookExecutionJob_WorkbenchRuntime();

  @override
  Object toJson() => {};

  @override
  String toString() => 'WorkbenchRuntime()';
}

/// The idle shutdown configuration of NotebookRuntimeTemplate, which contains
/// the idle_timeout as required field.
final class NotebookIdleShutdownConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookIdleShutdownConfig';

  /// Required. Duration is accurate to the second. In Notebook, Idle Timeout is
  /// accurate to minute so the range of idle_timeout (second) is: 10 * 60 ~ 1440
  /// * 60.
  final protobuf.Duration? idleTimeout;

  /// Whether Idle Shutdown is disabled in this NotebookRuntimeTemplate.
  final bool idleShutdownDisabled;

  NotebookIdleShutdownConfig({
    required this.idleTimeout,
    this.idleShutdownDisabled = false,
  }) : super(fullyQualifiedName);

  factory NotebookIdleShutdownConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookIdleShutdownConfig(
      idleTimeout: switch (json['idleTimeout']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      idleShutdownDisabled: switch (json['idleShutdownDisabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (idleTimeout != null) 'idleTimeout': idleTimeout!.toJson(),
    if (idleShutdownDisabled.isNotDefault)
      'idleShutdownDisabled': idleShutdownDisabled,
  };

  @override
  String toString() {
    final contents = ['idleShutdownDisabled=$idleShutdownDisabled'].join(',');
    return 'NotebookIdleShutdownConfig($contents)';
  }
}

/// A template that specifies runtime configurations such as machine type,
/// runtime version, network configurations, etc.
/// Multiple runtimes can be created from a runtime template.
final class NotebookRuntimeTemplate extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookRuntimeTemplate';

  /// The resource name of the NotebookRuntimeTemplate.
  final String name;

  /// Required. The display name of the NotebookRuntimeTemplate.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// The description of the NotebookRuntimeTemplate.
  final String description;

  /// Output only. Deprecated: This field has no behavior. Use
  /// notebook_runtime_type = 'ONE_CLICK' instead.
  ///
  /// The default template to use if not specified.
  final bool isDefault;

  /// Optional. Immutable. The specification of a single machine for the
  /// template.
  final MachineSpec? machineSpec;

  /// Optional. The specification of [persistent
  /// disk][https://cloud.google.com/compute/docs/disks/persistent-disks]
  /// attached to the runtime as data disk storage.
  final PersistentDiskSpec? dataPersistentDiskSpec;

  /// Optional. Network spec.
  final NetworkSpec? networkSpec;

  /// Deprecated: This field is ignored and the "Vertex AI Notebook Service
  /// Account"
  /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
  /// used for the runtime workload identity.
  /// See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account
  /// for more details.
  /// For NotebookExecutionJob, use NotebookExecutionJob.service_account instead.
  ///
  /// The service account that the runtime workload runs as.
  /// You can use any service account within the same project, but you
  /// must have the service account user permission to use the instance.
  ///
  /// If not specified, the [Compute Engine default service
  /// account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
  /// is used.
  final String serviceAccount;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// The labels with user-defined metadata to organize the
  /// NotebookRuntimeTemplates.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// The idle shutdown configuration of NotebookRuntimeTemplate. This config
  /// will only be set when idle shutdown is enabled.
  final NotebookIdleShutdownConfig? idleShutdownConfig;

  /// EUC configuration of the NotebookRuntimeTemplate.
  final NotebookEucConfig? eucConfig;

  /// Output only. Timestamp when this NotebookRuntimeTemplate was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this NotebookRuntimeTemplate was most recently
  /// updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Immutable. The type of the notebook runtime template.
  final NotebookRuntimeType notebookRuntimeType;

  /// Optional. Immutable. Runtime Shielded VM spec.
  final ShieldedVmConfig? shieldedVmConfig;

  /// Optional. The Compute Engine tags to add to runtime (see [Tagging
  /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
  final List<String> networkTags;

  /// Customer-managed encryption key spec for the notebook runtime.
  final EncryptionSpec? encryptionSpec;

  /// Optional. The notebook software configuration of the notebook runtime.
  final NotebookSoftwareConfig? softwareConfig;

  NotebookRuntimeTemplate({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.isDefault = false,
    this.machineSpec,
    this.dataPersistentDiskSpec,
    this.networkSpec,
    this.serviceAccount = '',
    this.etag = '',
    this.labels = const {},
    this.idleShutdownConfig,
    this.eucConfig,
    this.createTime,
    this.updateTime,
    this.notebookRuntimeType = NotebookRuntimeType.$default,
    this.shieldedVmConfig,
    this.networkTags = const [],
    this.encryptionSpec,
    this.softwareConfig,
  }) : super(fullyQualifiedName);

  factory NotebookRuntimeTemplate.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookRuntimeTemplate(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      isDefault: switch (json['isDefault']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      machineSpec: switch (json['machineSpec']) {
        null => null,
        Object $1 => MachineSpec.fromJson($1),
      },
      dataPersistentDiskSpec: switch (json['dataPersistentDiskSpec']) {
        null => null,
        Object $1 => PersistentDiskSpec.fromJson($1),
      },
      networkSpec: switch (json['networkSpec']) {
        null => null,
        Object $1 => NetworkSpec.fromJson($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      idleShutdownConfig: switch (json['idleShutdownConfig']) {
        null => null,
        Object $1 => NotebookIdleShutdownConfig.fromJson($1),
      },
      eucConfig: switch (json['eucConfig']) {
        null => null,
        Object $1 => NotebookEucConfig.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      notebookRuntimeType: switch (json['notebookRuntimeType']) {
        null => NotebookRuntimeType.$default,
        Object $1 => NotebookRuntimeType.fromJson($1),
      },
      shieldedVmConfig: switch (json['shieldedVmConfig']) {
        null => null,
        Object $1 => ShieldedVmConfig.fromJson($1),
      },
      networkTags: switch (json['networkTags']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"networkTags" is not a list'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      softwareConfig: switch (json['softwareConfig']) {
        null => null,
        Object $1 => NotebookSoftwareConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (isDefault.isNotDefault) 'isDefault': isDefault,
    if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
    if (dataPersistentDiskSpec != null)
      'dataPersistentDiskSpec': dataPersistentDiskSpec!.toJson(),
    if (networkSpec != null) 'networkSpec': networkSpec!.toJson(),
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
    if (etag.isNotDefault) 'etag': etag,
    if (labels.isNotDefault) 'labels': labels,
    if (idleShutdownConfig != null)
      'idleShutdownConfig': idleShutdownConfig!.toJson(),
    if (eucConfig != null) 'eucConfig': eucConfig!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (notebookRuntimeType.isNotDefault)
      'notebookRuntimeType': notebookRuntimeType.toJson(),
    if (shieldedVmConfig != null)
      'shieldedVmConfig': shieldedVmConfig!.toJson(),
    if (networkTags.isNotDefault) 'networkTags': networkTags,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (softwareConfig != null) 'softwareConfig': softwareConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'isDefault=$isDefault',
      'serviceAccount=$serviceAccount',
      'etag=$etag',
      'notebookRuntimeType=$notebookRuntimeType',
    ].join(',');
    return 'NotebookRuntimeTemplate($contents)';
  }
}

/// A runtime is a virtual machine allocated to a particular user for a
/// particular Notebook file on temporary basis with lifetime. Default runtimes
/// have a lifetime of 18 hours, while custom runtimes last for 6 months from
/// their creation or last upgrade.
final class NotebookRuntime extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookRuntime';

  /// Output only. The resource name of the NotebookRuntime.
  final String name;

  /// Required. The user email of the NotebookRuntime.
  final String runtimeUser;

  /// Output only. The pointer to NotebookRuntimeTemplate this NotebookRuntime is
  /// created from.
  final NotebookRuntimeTemplateRef? notebookRuntimeTemplateRef;

  /// Output only. The proxy endpoint used to access the NotebookRuntime.
  final String proxyUri;

  /// Output only. Timestamp when this NotebookRuntime was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this NotebookRuntime was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. The health state of the NotebookRuntime.
  final NotebookRuntime_HealthState healthState;

  /// Required. The display name of the NotebookRuntime.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// The description of the NotebookRuntime.
  final String description;

  /// Output only. Deprecated: This field is no longer used and the "Vertex AI
  /// Notebook Service Account"
  /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
  /// used for the runtime workload identity.
  /// See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account
  /// for more details.
  ///
  /// The service account that the NotebookRuntime workload runs as.
  final String serviceAccount;

  /// Output only. The runtime (instance) state of the NotebookRuntime.
  final NotebookRuntime_RuntimeState runtimeState;

  /// Output only. Whether NotebookRuntime is upgradable.
  final bool isUpgradable;

  /// The labels with user-defined metadata to organize your
  /// NotebookRuntime.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one NotebookRuntime
  /// (System labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable. Following system labels exist for NotebookRuntime:
  ///
  /// * "aiplatform.googleapis.com/notebook_runtime_gce_instance_id": output
  /// only, its value is the Compute Engine instance id.
  /// * "aiplatform.googleapis.com/colab_enterprise_entry_service": its value is
  /// either "bigquery" or "vertex"; if absent, it should be "vertex". This is to
  /// describe the entry service, either BigQuery or Vertex.
  final Map<String, String> labels;

  /// Output only. Timestamp when this NotebookRuntime will be expired:
  /// 1. System Predefined NotebookRuntime: 24 hours after creation. After
  /// expiration, system predifined runtime will be deleted.
  /// 2. User created NotebookRuntime: 6 months after last upgrade. After
  /// expiration, user created runtime will be stopped and allowed for upgrade.
  final protobuf.Timestamp? expirationTime;

  /// Output only. The VM os image version of NotebookRuntime.
  final String version;

  /// Output only. The type of the notebook runtime.
  final NotebookRuntimeType notebookRuntimeType;

  /// Output only. The specification of a single machine used by the notebook
  /// runtime.
  final MachineSpec? machineSpec;

  /// Output only. The specification of [persistent
  /// disk][https://cloud.google.com/compute/docs/disks/persistent-disks]
  /// attached to the notebook runtime as data disk storage.
  final PersistentDiskSpec? dataPersistentDiskSpec;

  /// Output only. Network spec of the notebook runtime.
  final NetworkSpec? networkSpec;

  /// Output only. The idle shutdown configuration of the notebook runtime.
  final NotebookIdleShutdownConfig? idleShutdownConfig;

  /// Output only. EUC configuration of the notebook runtime.
  final NotebookEucConfig? eucConfig;

  /// Output only. Runtime Shielded VM spec.
  final ShieldedVmConfig? shieldedVmConfig;

  /// Optional. The Compute Engine tags to add to runtime (see [Tagging
  /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
  final List<String> networkTags;

  /// Output only. Software config of the notebook runtime.
  final NotebookSoftwareConfig? softwareConfig;

  /// Output only. Customer-managed encryption key spec for the notebook runtime.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  NotebookRuntime({
    this.name = '',
    required this.runtimeUser,
    this.notebookRuntimeTemplateRef,
    this.proxyUri = '',
    this.createTime,
    this.updateTime,
    this.healthState = NotebookRuntime_HealthState.$default,
    required this.displayName,
    this.description = '',
    this.serviceAccount = '',
    this.runtimeState = NotebookRuntime_RuntimeState.$default,
    this.isUpgradable = false,
    this.labels = const {},
    this.expirationTime,
    this.version = '',
    this.notebookRuntimeType = NotebookRuntimeType.$default,
    this.machineSpec,
    this.dataPersistentDiskSpec,
    this.networkSpec,
    this.idleShutdownConfig,
    this.eucConfig,
    this.shieldedVmConfig,
    this.networkTags = const [],
    this.softwareConfig,
    this.encryptionSpec,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory NotebookRuntime.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookRuntime(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      runtimeUser: switch (json['runtimeUser']) {
        null => '',
        Object $1 => decodeString($1),
      },
      notebookRuntimeTemplateRef: switch (json['notebookRuntimeTemplateRef']) {
        null => null,
        Object $1 => NotebookRuntimeTemplateRef.fromJson($1),
      },
      proxyUri: switch (json['proxyUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      healthState: switch (json['healthState']) {
        null => NotebookRuntime_HealthState.$default,
        Object $1 => NotebookRuntime_HealthState.fromJson($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
      runtimeState: switch (json['runtimeState']) {
        null => NotebookRuntime_RuntimeState.$default,
        Object $1 => NotebookRuntime_RuntimeState.fromJson($1),
      },
      isUpgradable: switch (json['isUpgradable']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      expirationTime: switch (json['expirationTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
      notebookRuntimeType: switch (json['notebookRuntimeType']) {
        null => NotebookRuntimeType.$default,
        Object $1 => NotebookRuntimeType.fromJson($1),
      },
      machineSpec: switch (json['machineSpec']) {
        null => null,
        Object $1 => MachineSpec.fromJson($1),
      },
      dataPersistentDiskSpec: switch (json['dataPersistentDiskSpec']) {
        null => null,
        Object $1 => PersistentDiskSpec.fromJson($1),
      },
      networkSpec: switch (json['networkSpec']) {
        null => null,
        Object $1 => NetworkSpec.fromJson($1),
      },
      idleShutdownConfig: switch (json['idleShutdownConfig']) {
        null => null,
        Object $1 => NotebookIdleShutdownConfig.fromJson($1),
      },
      eucConfig: switch (json['eucConfig']) {
        null => null,
        Object $1 => NotebookEucConfig.fromJson($1),
      },
      shieldedVmConfig: switch (json['shieldedVmConfig']) {
        null => null,
        Object $1 => ShieldedVmConfig.fromJson($1),
      },
      networkTags: switch (json['networkTags']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"networkTags" is not a list'),
      },
      softwareConfig: switch (json['softwareConfig']) {
        null => null,
        Object $1 => NotebookSoftwareConfig.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'runtimeUser': runtimeUser,
    if (notebookRuntimeTemplateRef != null)
      'notebookRuntimeTemplateRef': notebookRuntimeTemplateRef!.toJson(),
    if (proxyUri.isNotDefault) 'proxyUri': proxyUri,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (healthState.isNotDefault) 'healthState': healthState.toJson(),
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
    if (runtimeState.isNotDefault) 'runtimeState': runtimeState.toJson(),
    if (isUpgradable.isNotDefault) 'isUpgradable': isUpgradable,
    if (labels.isNotDefault) 'labels': labels,
    if (expirationTime != null) 'expirationTime': expirationTime!.toJson(),
    if (version.isNotDefault) 'version': version,
    if (notebookRuntimeType.isNotDefault)
      'notebookRuntimeType': notebookRuntimeType.toJson(),
    if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
    if (dataPersistentDiskSpec != null)
      'dataPersistentDiskSpec': dataPersistentDiskSpec!.toJson(),
    if (networkSpec != null) 'networkSpec': networkSpec!.toJson(),
    if (idleShutdownConfig != null)
      'idleShutdownConfig': idleShutdownConfig!.toJson(),
    if (eucConfig != null) 'eucConfig': eucConfig!.toJson(),
    if (shieldedVmConfig != null)
      'shieldedVmConfig': shieldedVmConfig!.toJson(),
    if (networkTags.isNotDefault) 'networkTags': networkTags,
    if (softwareConfig != null) 'softwareConfig': softwareConfig!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'runtimeUser=$runtimeUser',
      'proxyUri=$proxyUri',
      'healthState=$healthState',
      'displayName=$displayName',
      'description=$description',
      'serviceAccount=$serviceAccount',
      'runtimeState=$runtimeState',
      'isUpgradable=$isUpgradable',
      'version=$version',
      'notebookRuntimeType=$notebookRuntimeType',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'NotebookRuntime($contents)';
  }
}

/// The substate of the NotebookRuntime to display health information.
final class NotebookRuntime_HealthState extends ProtoEnum {
  /// Unspecified health state.
  static const healthStateUnspecified = NotebookRuntime_HealthState(
    'HEALTH_STATE_UNSPECIFIED',
  );

  /// NotebookRuntime is in healthy state. Applies to ACTIVE state.
  static const healthy = NotebookRuntime_HealthState('HEALTHY');

  /// NotebookRuntime is in unhealthy state. Applies to ACTIVE state.
  static const unhealthy = NotebookRuntime_HealthState('UNHEALTHY');

  /// The default value for [NotebookRuntime_HealthState].
  static const $default = healthStateUnspecified;

  const NotebookRuntime_HealthState(super.value);

  factory NotebookRuntime_HealthState.fromJson(Object? json) =>
      NotebookRuntime_HealthState(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'HealthState.$value';
}

/// The substate of the NotebookRuntime to display state of runtime.
/// The resource of NotebookRuntime is in ACTIVE state for these sub state.
final class NotebookRuntime_RuntimeState extends ProtoEnum {
  /// Unspecified runtime state.
  static const runtimeStateUnspecified = NotebookRuntime_RuntimeState(
    'RUNTIME_STATE_UNSPECIFIED',
  );

  /// NotebookRuntime is in running state.
  static const running = NotebookRuntime_RuntimeState('RUNNING');

  /// NotebookRuntime is in starting state. This is when the runtime is being
  /// started from a stopped state.
  static const beingStarted = NotebookRuntime_RuntimeState('BEING_STARTED');

  /// NotebookRuntime is in stopping state.
  static const beingStopped = NotebookRuntime_RuntimeState('BEING_STOPPED');

  /// NotebookRuntime is in stopped state.
  static const stopped = NotebookRuntime_RuntimeState('STOPPED');

  /// NotebookRuntime is in upgrading state. It is in the middle of upgrading
  /// process.
  static const beingUpgraded = NotebookRuntime_RuntimeState('BEING_UPGRADED');

  /// NotebookRuntime was unable to start/stop properly.
  static const error = NotebookRuntime_RuntimeState('ERROR');

  /// NotebookRuntime is in invalid state. Cannot be recovered.
  static const invalid = NotebookRuntime_RuntimeState('INVALID');

  /// The default value for [NotebookRuntime_RuntimeState].
  static const $default = runtimeStateUnspecified;

  const NotebookRuntime_RuntimeState(super.value);

  factory NotebookRuntime_RuntimeState.fromJson(Object? json) =>
      NotebookRuntime_RuntimeState(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'RuntimeState.$value';
}

/// Points to a NotebookRuntimeTemplateRef.
final class NotebookRuntimeTemplateRef extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookRuntimeTemplateRef';

  /// Immutable. A resource name of the NotebookRuntimeTemplate.
  final String notebookRuntimeTemplate;

  NotebookRuntimeTemplateRef({this.notebookRuntimeTemplate = ''})
    : super(fullyQualifiedName);

  factory NotebookRuntimeTemplateRef.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookRuntimeTemplateRef(
      notebookRuntimeTemplate: switch (json['notebookRuntimeTemplate']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (notebookRuntimeTemplate.isNotDefault)
      'notebookRuntimeTemplate': notebookRuntimeTemplate,
  };

  @override
  String toString() {
    final contents = [
      'notebookRuntimeTemplate=$notebookRuntimeTemplate',
    ].join(',');
    return 'NotebookRuntimeTemplateRef($contents)';
  }
}

/// Request message for
/// `NotebookService.CreateNotebookRuntimeTemplate`.
final class CreateNotebookRuntimeTemplateRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNotebookRuntimeTemplateRequest';

  /// Required. The resource name of the Location to create the
  /// NotebookRuntimeTemplate. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The NotebookRuntimeTemplate to create.
  final NotebookRuntimeTemplate? notebookRuntimeTemplate;

  /// Optional. User specified ID for the notebook runtime template.
  final String notebookRuntimeTemplateId;

  CreateNotebookRuntimeTemplateRequest({
    required this.parent,
    required this.notebookRuntimeTemplate,
    this.notebookRuntimeTemplateId = '',
  }) : super(fullyQualifiedName);

  factory CreateNotebookRuntimeTemplateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateNotebookRuntimeTemplateRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      notebookRuntimeTemplate: switch (json['notebookRuntimeTemplate']) {
        null => null,
        Object $1 => NotebookRuntimeTemplate.fromJson($1),
      },
      notebookRuntimeTemplateId: switch (json['notebookRuntimeTemplateId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (notebookRuntimeTemplate != null)
      'notebookRuntimeTemplate': notebookRuntimeTemplate!.toJson(),
    if (notebookRuntimeTemplateId.isNotDefault)
      'notebookRuntimeTemplateId': notebookRuntimeTemplateId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'notebookRuntimeTemplateId=$notebookRuntimeTemplateId',
    ].join(',');
    return 'CreateNotebookRuntimeTemplateRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.CreateNotebookRuntimeTemplate`.
final class CreateNotebookRuntimeTemplateOperationMetadata
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNotebookRuntimeTemplateOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateNotebookRuntimeTemplateOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateNotebookRuntimeTemplateOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateNotebookRuntimeTemplateOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateNotebookRuntimeTemplateOperationMetadata()';
}

/// Request message for
/// `NotebookService.GetNotebookRuntimeTemplate`
final class GetNotebookRuntimeTemplateRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNotebookRuntimeTemplateRequest';

  /// Required. The name of the NotebookRuntimeTemplate resource.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  final String name;

  GetNotebookRuntimeTemplateRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetNotebookRuntimeTemplateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetNotebookRuntimeTemplateRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetNotebookRuntimeTemplateRequest($contents)';
  }
}

/// Request message for
/// `NotebookService.ListNotebookRuntimeTemplates`.
final class ListNotebookRuntimeTemplatesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookRuntimeTemplatesRequest';

  /// Required. The resource name of the Location from which to list the
  /// NotebookRuntimeTemplates.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
  ///     represents the NotebookRuntimeTemplate ID,
  ///     i.e. the last segment of the NotebookRuntimeTemplate's [resource name]
  ///     [google.cloud.aiplatform.v1beta1.NotebookRuntimeTemplate.name].
  ///   * `display_name` supports = and !=
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:* or labels:key - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///   * `notebookRuntimeType` supports = and !=. notebookRuntimeType enum:
  ///   [USER_DEFINED, ONE_CLICK].
  ///   * `machineType` supports = and !=.
  ///   * `acceleratorType` supports = and !=.
  ///
  /// Some examples:
  ///
  ///   * `notebookRuntimeTemplate=notebookRuntimeTemplate123`
  ///   * `displayName="myDisplayName"`
  ///   * `labels.myKey="myValue"`
  ///   * `notebookRuntimeType=USER_DEFINED`
  ///   * `machineType=e2-standard-4`
  ///   * `acceleratorType=NVIDIA_TESLA_T4`
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListNotebookRuntimeTemplatesResponse.next_page_token`
  /// of the previous
  /// `NotebookService.ListNotebookRuntimeTemplates`
  /// call.
  final String pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `display_name, create_time desc`.
  final String orderBy;

  ListNotebookRuntimeTemplatesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListNotebookRuntimeTemplatesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNotebookRuntimeTemplatesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListNotebookRuntimeTemplatesRequest($contents)';
  }
}

/// Response message for
/// `NotebookService.ListNotebookRuntimeTemplates`.
final class ListNotebookRuntimeTemplatesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookRuntimeTemplatesResponse';

  /// List of NotebookRuntimeTemplates in the requested page.
  final List<NotebookRuntimeTemplate> notebookRuntimeTemplates;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListNotebookRuntimeTemplatesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListNotebookRuntimeTemplatesResponse({
    this.notebookRuntimeTemplates = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListNotebookRuntimeTemplatesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNotebookRuntimeTemplatesResponse(
      notebookRuntimeTemplates: switch (json['notebookRuntimeTemplates']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) NotebookRuntimeTemplate.fromJson(i),
        ],
        _ => throw const FormatException(
          '"notebookRuntimeTemplates" is not a list',
        ),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (notebookRuntimeTemplates.isNotDefault)
      'notebookRuntimeTemplates': encodeList(notebookRuntimeTemplates),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListNotebookRuntimeTemplatesResponse($contents)';
  }
}

/// Request message for
/// `NotebookService.DeleteNotebookRuntimeTemplate`.
final class DeleteNotebookRuntimeTemplateRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteNotebookRuntimeTemplateRequest';

  /// Required. The name of the NotebookRuntimeTemplate resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  final String name;

  DeleteNotebookRuntimeTemplateRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteNotebookRuntimeTemplateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteNotebookRuntimeTemplateRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteNotebookRuntimeTemplateRequest($contents)';
  }
}

/// Request message for
/// `NotebookService.UpdateNotebookRuntimeTemplate`.
final class UpdateNotebookRuntimeTemplateRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateNotebookRuntimeTemplateRequest';

  /// Required. The NotebookRuntimeTemplate to update.
  final NotebookRuntimeTemplate? notebookRuntimeTemplate;

  /// Required. The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`. Input format:
  /// `{paths: "${updated_filed}"}` Updatable fields:
  ///
  ///   * `encryption_spec.kms_key_name`
  final protobuf.FieldMask? updateMask;

  UpdateNotebookRuntimeTemplateRequest({
    required this.notebookRuntimeTemplate,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateNotebookRuntimeTemplateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateNotebookRuntimeTemplateRequest(
      notebookRuntimeTemplate: switch (json['notebookRuntimeTemplate']) {
        null => null,
        Object $1 => NotebookRuntimeTemplate.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (notebookRuntimeTemplate != null)
      'notebookRuntimeTemplate': notebookRuntimeTemplate!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateNotebookRuntimeTemplateRequest()';
}

/// Request message for
/// `NotebookService.AssignNotebookRuntime`.
final class AssignNotebookRuntimeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssignNotebookRuntimeRequest';

  /// Required. The resource name of the Location to get the NotebookRuntime
  /// assignment. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The resource name of the NotebookRuntimeTemplate based on which a
  /// NotebookRuntime will be assigned (reuse or create a new one).
  final String notebookRuntimeTemplate;

  /// Required. Provide runtime specific information (e.g. runtime owner,
  /// notebook id) used for NotebookRuntime assignment.
  final NotebookRuntime? notebookRuntime;

  /// Optional. User specified ID for the notebook runtime.
  final String notebookRuntimeId;

  AssignNotebookRuntimeRequest({
    required this.parent,
    required this.notebookRuntimeTemplate,
    required this.notebookRuntime,
    this.notebookRuntimeId = '',
  }) : super(fullyQualifiedName);

  factory AssignNotebookRuntimeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AssignNotebookRuntimeRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      notebookRuntimeTemplate: switch (json['notebookRuntimeTemplate']) {
        null => '',
        Object $1 => decodeString($1),
      },
      notebookRuntime: switch (json['notebookRuntime']) {
        null => null,
        Object $1 => NotebookRuntime.fromJson($1),
      },
      notebookRuntimeId: switch (json['notebookRuntimeId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'notebookRuntimeTemplate': notebookRuntimeTemplate,
    if (notebookRuntime != null) 'notebookRuntime': notebookRuntime!.toJson(),
    if (notebookRuntimeId.isNotDefault) 'notebookRuntimeId': notebookRuntimeId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'notebookRuntimeTemplate=$notebookRuntimeTemplate',
      'notebookRuntimeId=$notebookRuntimeId',
    ].join(',');
    return 'AssignNotebookRuntimeRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.AssignNotebookRuntime`.
final class AssignNotebookRuntimeOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssignNotebookRuntimeOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// A human-readable message that shows the intermediate progress details of
  /// NotebookRuntime.
  final String progressMessage;

  AssignNotebookRuntimeOperationMetadata({
    this.genericMetadata,
    this.progressMessage = '',
  }) : super(fullyQualifiedName);

  factory AssignNotebookRuntimeOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AssignNotebookRuntimeOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      progressMessage: switch (json['progressMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (progressMessage.isNotDefault) 'progressMessage': progressMessage,
  };

  @override
  String toString() {
    final contents = ['progressMessage=$progressMessage'].join(',');
    return 'AssignNotebookRuntimeOperationMetadata($contents)';
  }
}

/// Request message for
/// `NotebookService.GetNotebookRuntime`
final class GetNotebookRuntimeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  GetNotebookRuntimeRequest({required this.name}) : super(fullyQualifiedName);

  factory GetNotebookRuntimeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetNotebookRuntimeRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetNotebookRuntimeRequest($contents)';
  }
}

/// Request message for
/// `NotebookService.ListNotebookRuntimes`.
final class ListNotebookRuntimesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookRuntimesRequest';

  /// Required. The resource name of the Location from which to list the
  /// NotebookRuntimes.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `notebookRuntime` supports = and !=. `notebookRuntime` represents the
  ///     NotebookRuntime ID,
  ///     i.e. the last segment of the NotebookRuntime's [resource name]
  ///     [google.cloud.aiplatform.v1beta1.NotebookRuntime.name].
  ///   * `displayName` supports = and != and regex.
  ///   * `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
  ///     represents the NotebookRuntimeTemplate ID,
  ///     i.e. the last segment of the NotebookRuntimeTemplate's [resource name]
  ///     [google.cloud.aiplatform.v1beta1.NotebookRuntimeTemplate.name].
  ///   * `healthState` supports = and !=. healthState enum: [HEALTHY, UNHEALTHY,
  ///   HEALTH_STATE_UNSPECIFIED].
  ///   * `runtimeState` supports = and !=. runtimeState enum:
  ///   [RUNTIME_STATE_UNSPECIFIED, RUNNING, BEING_STARTED, BEING_STOPPED,
  ///   STOPPED, BEING_UPGRADED, ERROR, INVALID].
  ///   * `runtimeUser` supports = and !=.
  ///   * API version is UI only: `uiState` supports = and !=. uiState enum:
  ///   [UI_RESOURCE_STATE_UNSPECIFIED, UI_RESOURCE_STATE_BEING_CREATED,
  ///   UI_RESOURCE_STATE_ACTIVE, UI_RESOURCE_STATE_BEING_DELETED,
  ///   UI_RESOURCE_STATE_CREATION_FAILED].
  ///   * `notebookRuntimeType` supports = and !=. notebookRuntimeType enum:
  ///   [USER_DEFINED, ONE_CLICK].
  ///   * `machineType` supports = and !=.
  ///   * `acceleratorType` supports = and !=.
  ///
  /// Some examples:
  ///
  ///   * `notebookRuntime="notebookRuntime123"`
  ///   * `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
  ///   * `notebookRuntimeTemplate="notebookRuntimeTemplate321"`
  ///   * `healthState=HEALTHY`
  ///   * `runtimeState=RUNNING`
  ///   * `runtimeUser="test@google.com"`
  ///   * `uiState=UI_RESOURCE_STATE_BEING_DELETED`
  ///   * `notebookRuntimeType=USER_DEFINED`
  ///   * `machineType=e2-standard-4`
  ///   * `acceleratorType=NVIDIA_TESLA_T4`
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListNotebookRuntimesResponse.next_page_token`
  /// of the previous
  /// `NotebookService.ListNotebookRuntimes`
  /// call.
  final String pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `display_name, create_time desc`.
  final String orderBy;

  ListNotebookRuntimesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListNotebookRuntimesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNotebookRuntimesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListNotebookRuntimesRequest($contents)';
  }
}

/// Response message for
/// `NotebookService.ListNotebookRuntimes`.
final class ListNotebookRuntimesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookRuntimesResponse';

  /// List of NotebookRuntimes in the requested page.
  final List<NotebookRuntime> notebookRuntimes;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListNotebookRuntimesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListNotebookRuntimesResponse({
    this.notebookRuntimes = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListNotebookRuntimesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNotebookRuntimesResponse(
      notebookRuntimes: switch (json['notebookRuntimes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) NotebookRuntime.fromJson(i)],
        _ => throw const FormatException('"notebookRuntimes" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (notebookRuntimes.isNotDefault)
      'notebookRuntimes': encodeList(notebookRuntimes),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListNotebookRuntimesResponse($contents)';
  }
}

/// Request message for
/// `NotebookService.DeleteNotebookRuntime`.
final class DeleteNotebookRuntimeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource to be deleted.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  DeleteNotebookRuntimeRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteNotebookRuntimeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteNotebookRuntimeRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteNotebookRuntimeRequest($contents)';
  }
}

/// Request message for
/// `NotebookService.UpgradeNotebookRuntime`.
final class UpgradeNotebookRuntimeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpgradeNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource to be upgrade.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  UpgradeNotebookRuntimeRequest({required this.name})
    : super(fullyQualifiedName);

  factory UpgradeNotebookRuntimeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpgradeNotebookRuntimeRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'UpgradeNotebookRuntimeRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.UpgradeNotebookRuntime`.
final class UpgradeNotebookRuntimeOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpgradeNotebookRuntimeOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// A human-readable message that shows the intermediate progress details of
  /// NotebookRuntime.
  final String progressMessage;

  UpgradeNotebookRuntimeOperationMetadata({
    this.genericMetadata,
    this.progressMessage = '',
  }) : super(fullyQualifiedName);

  factory UpgradeNotebookRuntimeOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpgradeNotebookRuntimeOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      progressMessage: switch (json['progressMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (progressMessage.isNotDefault) 'progressMessage': progressMessage,
  };

  @override
  String toString() {
    final contents = ['progressMessage=$progressMessage'].join(',');
    return 'UpgradeNotebookRuntimeOperationMetadata($contents)';
  }
}

/// Response message for
/// `NotebookService.UpgradeNotebookRuntime`.
final class UpgradeNotebookRuntimeResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpgradeNotebookRuntimeResponse';

  UpgradeNotebookRuntimeResponse() : super(fullyQualifiedName);

  factory UpgradeNotebookRuntimeResponse.fromJson(Object? j) =>
      UpgradeNotebookRuntimeResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'UpgradeNotebookRuntimeResponse()';
}

/// Request message for
/// `NotebookService.StartNotebookRuntime`.
final class StartNotebookRuntimeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StartNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource to be started.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  StartNotebookRuntimeRequest({required this.name}) : super(fullyQualifiedName);

  factory StartNotebookRuntimeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StartNotebookRuntimeRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StartNotebookRuntimeRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.StartNotebookRuntime`.
final class StartNotebookRuntimeOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StartNotebookRuntimeOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// A human-readable message that shows the intermediate progress details of
  /// NotebookRuntime.
  final String progressMessage;

  StartNotebookRuntimeOperationMetadata({
    this.genericMetadata,
    this.progressMessage = '',
  }) : super(fullyQualifiedName);

  factory StartNotebookRuntimeOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StartNotebookRuntimeOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      progressMessage: switch (json['progressMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (progressMessage.isNotDefault) 'progressMessage': progressMessage,
  };

  @override
  String toString() {
    final contents = ['progressMessage=$progressMessage'].join(',');
    return 'StartNotebookRuntimeOperationMetadata($contents)';
  }
}

/// Response message for
/// `NotebookService.StartNotebookRuntime`.
final class StartNotebookRuntimeResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StartNotebookRuntimeResponse';

  StartNotebookRuntimeResponse() : super(fullyQualifiedName);

  factory StartNotebookRuntimeResponse.fromJson(Object? j) =>
      StartNotebookRuntimeResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'StartNotebookRuntimeResponse()';
}

/// Request message for
/// `NotebookService.StopNotebookRuntime`.
final class StopNotebookRuntimeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StopNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource to be stopped.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  StopNotebookRuntimeRequest({required this.name}) : super(fullyQualifiedName);

  factory StopNotebookRuntimeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StopNotebookRuntimeRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StopNotebookRuntimeRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.StopNotebookRuntime`.
final class StopNotebookRuntimeOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StopNotebookRuntimeOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  StopNotebookRuntimeOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory StopNotebookRuntimeOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StopNotebookRuntimeOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'StopNotebookRuntimeOperationMetadata()';
}

/// Response message for
/// `NotebookService.StopNotebookRuntime`.
final class StopNotebookRuntimeResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StopNotebookRuntimeResponse';

  StopNotebookRuntimeResponse() : super(fullyQualifiedName);

  factory StopNotebookRuntimeResponse.fromJson(Object? j) =>
      StopNotebookRuntimeResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'StopNotebookRuntimeResponse()';
}

/// Request message for [NotebookService.CreateNotebookExecutionJob]
final class CreateNotebookExecutionJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNotebookExecutionJobRequest';

  /// Required. The resource name of the Location to create the
  /// NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The NotebookExecutionJob to create.
  final NotebookExecutionJob? notebookExecutionJob;

  /// Optional. User specified ID for the NotebookExecutionJob.
  final String notebookExecutionJobId;

  CreateNotebookExecutionJobRequest({
    required this.parent,
    required this.notebookExecutionJob,
    this.notebookExecutionJobId = '',
  }) : super(fullyQualifiedName);

  factory CreateNotebookExecutionJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateNotebookExecutionJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      notebookExecutionJob: switch (json['notebookExecutionJob']) {
        null => null,
        Object $1 => NotebookExecutionJob.fromJson($1),
      },
      notebookExecutionJobId: switch (json['notebookExecutionJobId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (notebookExecutionJob != null)
      'notebookExecutionJob': notebookExecutionJob!.toJson(),
    if (notebookExecutionJobId.isNotDefault)
      'notebookExecutionJobId': notebookExecutionJobId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'notebookExecutionJobId=$notebookExecutionJobId',
    ].join(',');
    return 'CreateNotebookExecutionJobRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.CreateNotebookExecutionJob`.
final class CreateNotebookExecutionJobOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNotebookExecutionJobOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// A human-readable message that shows the intermediate progress details of
  /// NotebookRuntime.
  final String progressMessage;

  CreateNotebookExecutionJobOperationMetadata({
    this.genericMetadata,
    this.progressMessage = '',
  }) : super(fullyQualifiedName);

  factory CreateNotebookExecutionJobOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateNotebookExecutionJobOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      progressMessage: switch (json['progressMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (progressMessage.isNotDefault) 'progressMessage': progressMessage,
  };

  @override
  String toString() {
    final contents = ['progressMessage=$progressMessage'].join(',');
    return 'CreateNotebookExecutionJobOperationMetadata($contents)';
  }
}

/// Request message for [NotebookService.GetNotebookExecutionJob]
final class GetNotebookExecutionJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNotebookExecutionJobRequest';

  /// Required. The name of the NotebookExecutionJob resource.
  final String name;

  /// Optional. The NotebookExecutionJob view. Defaults to BASIC.
  final NotebookExecutionJobView view;

  GetNotebookExecutionJobRequest({
    required this.name,
    this.view = NotebookExecutionJobView.$default,
  }) : super(fullyQualifiedName);

  factory GetNotebookExecutionJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetNotebookExecutionJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      view: switch (json['view']) {
        null => NotebookExecutionJobView.$default,
        Object $1 => NotebookExecutionJobView.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (view.isNotDefault) 'view': view.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'view=$view'].join(',');
    return 'GetNotebookExecutionJobRequest($contents)';
  }
}

/// Request message for [NotebookService.ListNotebookExecutionJobs]
final class ListNotebookExecutionJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookExecutionJobsRequest';

  /// Required. The resource name of the Location from which to list the
  /// NotebookExecutionJobs.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `notebookExecutionJob` supports = and !=. `notebookExecutionJob`
  ///   represents the NotebookExecutionJob ID.
  ///   * `displayName` supports = and != and regex.
  ///   * `schedule` supports = and != and regex.
  ///
  /// Some examples:
  ///   * `notebookExecutionJob="123"`
  ///   * `notebookExecutionJob="my-execution-job"`
  ///   * `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListNotebookExecutionJobsResponse.next_page_token`
  /// of the previous
  /// `NotebookService.ListNotebookExecutionJobs`
  /// call.
  final String pageToken;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `display_name, create_time desc`.
  final String orderBy;

  /// Optional. The NotebookExecutionJob view. Defaults to BASIC.
  final NotebookExecutionJobView view;

  ListNotebookExecutionJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.view = NotebookExecutionJobView.$default,
  }) : super(fullyQualifiedName);

  factory ListNotebookExecutionJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNotebookExecutionJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      view: switch (json['view']) {
        null => NotebookExecutionJobView.$default,
        Object $1 => NotebookExecutionJobView.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (view.isNotDefault) 'view': view.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
      'view=$view',
    ].join(',');
    return 'ListNotebookExecutionJobsRequest($contents)';
  }
}

/// Response message for [NotebookService.CreateNotebookExecutionJob]
final class ListNotebookExecutionJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookExecutionJobsResponse';

  /// List of NotebookExecutionJobs in the requested page.
  final List<NotebookExecutionJob> notebookExecutionJobs;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListNotebookExecutionJobsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListNotebookExecutionJobsResponse({
    this.notebookExecutionJobs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListNotebookExecutionJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListNotebookExecutionJobsResponse(
      notebookExecutionJobs: switch (json['notebookExecutionJobs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) NotebookExecutionJob.fromJson(i),
        ],
        _ => throw const FormatException(
          '"notebookExecutionJobs" is not a list',
        ),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (notebookExecutionJobs.isNotDefault)
      'notebookExecutionJobs': encodeList(notebookExecutionJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListNotebookExecutionJobsResponse($contents)';
  }
}

/// Request message for [NotebookService.DeleteNotebookExecutionJob]
final class DeleteNotebookExecutionJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteNotebookExecutionJobRequest';

  /// Required. The name of the NotebookExecutionJob resource to be deleted.
  final String name;

  DeleteNotebookExecutionJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteNotebookExecutionJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteNotebookExecutionJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteNotebookExecutionJobRequest($contents)';
  }
}

final class PostStartupScriptConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PostStartupScriptConfig';

  final String postStartupScript;

  final String postStartupScriptUrl;

  final PostStartupScriptConfig_PostStartupScriptBehavior
  postStartupScriptBehavior;

  PostStartupScriptConfig({
    this.postStartupScript = '',
    this.postStartupScriptUrl = '',
    this.postStartupScriptBehavior =
        PostStartupScriptConfig_PostStartupScriptBehavior.$default,
  }) : super(fullyQualifiedName);

  factory PostStartupScriptConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PostStartupScriptConfig(
      postStartupScript: switch (json['postStartupScript']) {
        null => '',
        Object $1 => decodeString($1),
      },
      postStartupScriptUrl: switch (json['postStartupScriptUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
      postStartupScriptBehavior: switch (json['postStartupScriptBehavior']) {
        null => PostStartupScriptConfig_PostStartupScriptBehavior.$default,
        Object $1 => PostStartupScriptConfig_PostStartupScriptBehavior.fromJson(
          $1,
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (postStartupScript.isNotDefault) 'postStartupScript': postStartupScript,
    if (postStartupScriptUrl.isNotDefault)
      'postStartupScriptUrl': postStartupScriptUrl,
    if (postStartupScriptBehavior.isNotDefault)
      'postStartupScriptBehavior': postStartupScriptBehavior.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'postStartupScript=$postStartupScript',
      'postStartupScriptUrl=$postStartupScriptUrl',
      'postStartupScriptBehavior=$postStartupScriptBehavior',
    ].join(',');
    return 'PostStartupScriptConfig($contents)';
  }
}

final class PostStartupScriptConfig_PostStartupScriptBehavior
    extends ProtoEnum {
  static const postStartupScriptBehaviorUnspecified =
      PostStartupScriptConfig_PostStartupScriptBehavior(
        'POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED',
      );

  static const runOnce = PostStartupScriptConfig_PostStartupScriptBehavior(
    'RUN_ONCE',
  );

  static const runEveryStart =
      PostStartupScriptConfig_PostStartupScriptBehavior('RUN_EVERY_START');

  static const downloadAndRunEveryStart =
      PostStartupScriptConfig_PostStartupScriptBehavior(
        'DOWNLOAD_AND_RUN_EVERY_START',
      );

  /// The default value for [PostStartupScriptConfig_PostStartupScriptBehavior].
  static const $default = postStartupScriptBehaviorUnspecified;

  const PostStartupScriptConfig_PostStartupScriptBehavior(super.value);

  factory PostStartupScriptConfig_PostStartupScriptBehavior.fromJson(
    Object? json,
  ) => PostStartupScriptConfig_PostStartupScriptBehavior(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PostStartupScriptBehavior.$value';
}

/// Colab image of the runtime.
final class ColabImage extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ColabImage';

  /// Optional. The release name of the NotebookRuntime Colab image, e.g.
  /// "py310". If not specified, detault to the latest release.
  final String releaseName;

  /// Output only. A human-readable description of the specified colab image
  /// release, populated by the system. Example: "Python 3.10", "Latest - current
  /// Python 3.11"
  final String description;

  ColabImage({this.releaseName = '', this.description = ''})
    : super(fullyQualifiedName);

  factory ColabImage.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ColabImage(
      releaseName: switch (json['releaseName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (releaseName.isNotDefault) 'releaseName': releaseName,
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'releaseName=$releaseName',
      'description=$description',
    ].join(',');
    return 'ColabImage($contents)';
  }
}

/// Notebook Software Config. This is passed to the backend when user
/// makes software configurations in UI.
final class NotebookSoftwareConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookSoftwareConfig';

  /// Optional. Google-managed NotebookRuntime colab image.
  final ColabImage? colabImage;

  /// Optional. Environment variables to be passed to the container.
  /// Maximum limit is 100.
  final List<EnvVar> env;

  final PostStartupScriptConfig? postStartupScriptConfig;

  NotebookSoftwareConfig({
    this.colabImage,
    this.env = const [],
    this.postStartupScriptConfig,
  }) : super(fullyQualifiedName);

  factory NotebookSoftwareConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NotebookSoftwareConfig(
      colabImage: switch (json['colabImage']) {
        null => null,
        Object $1 => ColabImage.fromJson($1),
      },
      env: switch (json['env']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) EnvVar.fromJson(i)],
        _ => throw const FormatException('"env" is not a list'),
      },
      postStartupScriptConfig: switch (json['postStartupScriptConfig']) {
        null => null,
        Object $1 => PostStartupScriptConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (colabImage != null) 'colabImage': colabImage!.toJson(),
    if (env.isNotDefault) 'env': encodeList(env),
    if (postStartupScriptConfig != null)
      'postStartupScriptConfig': postStartupScriptConfig!.toJson(),
  };

  @override
  String toString() => 'NotebookSoftwareConfig()';
}

/// Schema is used to define the format of input/output data. Represents a select
/// subset of an [OpenAPI 3.0 schema
/// object](https://spec.openapis.org/oas/v3.0.3#schema-object). More fields may
/// be added in the future as needed.
final class Schema extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Schema';

  /// Optional. The type of the data.
  final Type type;

  /// Optional. The format of the data.
  /// Supported formats:
  ///  for NUMBER type: "float", "double"
  ///  for INTEGER type: "int32", "int64"
  ///  for STRING type: "email", "byte", etc
  final String format;

  /// Optional. The title of the Schema.
  final String title;

  /// Optional. The description of the data.
  final String description;

  /// Optional. Indicates if the value may be null.
  final bool nullable;

  /// Optional. Default value of the data.
  final protobuf.Value? default$;

  /// Optional. SCHEMA FIELDS FOR TYPE ARRAY
  /// Schema of the elements of Type.ARRAY.
  final Schema? items;

  /// Optional. Minimum number of the elements for Type.ARRAY.
  final int minItems;

  /// Optional. Maximum number of the elements for Type.ARRAY.
  final int maxItems;

  /// Optional. Possible values of the element of Type.STRING with enum format.
  /// For example we can define an Enum Direction as :
  /// {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
  final List<String> enum$;

  /// Optional. SCHEMA FIELDS FOR TYPE OBJECT
  /// Properties of Type.OBJECT.
  final Map<String, Schema> properties;

  /// Optional. The order of the properties.
  /// Not a standard field in open api spec. Only used to support the order of
  /// the properties.
  final List<String> propertyOrdering;

  /// Optional. Required properties of Type.OBJECT.
  final List<String> required;

  /// Optional. Minimum number of the properties for Type.OBJECT.
  final int minProperties;

  /// Optional. Maximum number of the properties for Type.OBJECT.
  final int maxProperties;

  /// Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER
  /// Minimum value of the Type.INTEGER and Type.NUMBER
  final double minimum;

  /// Optional. Maximum value of the Type.INTEGER and Type.NUMBER
  final double maximum;

  /// Optional. SCHEMA FIELDS FOR TYPE STRING
  /// Minimum length of the Type.STRING
  final int minLength;

  /// Optional. Maximum length of the Type.STRING
  final int maxLength;

  /// Optional. Pattern of the Type.STRING to restrict a string to a regular
  /// expression.
  final String pattern;

  /// Optional. Example of the object. Will only populated when the object is the
  /// root.
  final protobuf.Value? example;

  /// Optional. The value should be validated against any (one or more) of the
  /// subschemas in the list.
  final List<Schema> anyOf;

  /// Optional. Can either be a boolean or an object; controls the presence of
  /// additional properties.
  final protobuf.Value? additionalProperties;

  /// Optional. Allows indirect references between schema nodes. The value should
  /// be a valid reference to a child of the root `defs`.
  ///
  /// For example, the following schema defines a reference to a schema node
  /// named "Pet":
  ///
  /// type: object
  /// properties:
  ///   pet:
  ///     ref: #/defs/Pet
  /// defs:
  ///   Pet:
  ///     type: object
  ///     properties:
  ///       name:
  ///         type: string
  ///
  /// The value of the "pet" property is a reference to the schema node
  /// named "Pet".
  /// See details in
  /// https://json-schema.org/understanding-json-schema/structuring
  final String ref;

  /// Optional. A map of definitions for use by `ref`
  /// Only allowed at the root of the schema.
  final Map<String, Schema> defs;

  Schema({
    this.type = Type.$default,
    this.format = '',
    this.title = '',
    this.description = '',
    this.nullable = false,
    this.default$,
    this.items,
    this.minItems = 0,
    this.maxItems = 0,
    this.enum$ = const [],
    this.properties = const {},
    this.propertyOrdering = const [],
    this.required = const [],
    this.minProperties = 0,
    this.maxProperties = 0,
    this.minimum = 0,
    this.maximum = 0,
    this.minLength = 0,
    this.maxLength = 0,
    this.pattern = '',
    this.example,
    this.anyOf = const [],
    this.additionalProperties,
    this.ref = '',
    this.defs = const {},
  }) : super(fullyQualifiedName);

  factory Schema.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Schema(
      type: switch (json['type']) {
        null => Type.$default,
        Object $1 => Type.fromJson($1),
      },
      format: switch (json['format']) {
        null => '',
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      nullable: switch (json['nullable']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      default$: switch (json['default']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      items: switch (json['items']) {
        null => null,
        Object $1 => Schema.fromJson($1),
      },
      minItems: switch (json['minItems']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      maxItems: switch (json['maxItems']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      enum$: switch (json['enum']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"enum" is not a list'),
      },
      properties: switch (json['properties']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Schema.fromJson(e.value),
        },
        _ => throw const FormatException('"properties" is not an object'),
      },
      propertyOrdering: switch (json['propertyOrdering']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"propertyOrdering" is not a list'),
      },
      required: switch (json['required']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"required" is not a list'),
      },
      minProperties: switch (json['minProperties']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      maxProperties: switch (json['maxProperties']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      minimum: switch (json['minimum']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      maximum: switch (json['maximum']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      minLength: switch (json['minLength']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      maxLength: switch (json['maxLength']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      pattern: switch (json['pattern']) {
        null => '',
        Object $1 => decodeString($1),
      },
      example: switch (json['example']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      anyOf: switch (json['anyOf']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Schema.fromJson(i)],
        _ => throw const FormatException('"anyOf" is not a list'),
      },
      additionalProperties: switch (json['additionalProperties']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      ref: switch (json['ref']) {
        null => '',
        Object $1 => decodeString($1),
      },
      defs: switch (json['defs']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Schema.fromJson(e.value),
        },
        _ => throw const FormatException('"defs" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type.toJson(),
    if (format.isNotDefault) 'format': format,
    if (title.isNotDefault) 'title': title,
    if (description.isNotDefault) 'description': description,
    if (nullable.isNotDefault) 'nullable': nullable,
    if (default$ != null) 'default': default$!.toJson(),
    if (items != null) 'items': items!.toJson(),
    if (minItems.isNotDefault) 'minItems': encodeInt64(minItems),
    if (maxItems.isNotDefault) 'maxItems': encodeInt64(maxItems),
    if (enum$.isNotDefault) 'enum': enum$,
    if (properties.isNotDefault) 'properties': encodeMap(properties),
    if (propertyOrdering.isNotDefault) 'propertyOrdering': propertyOrdering,
    if (required.isNotDefault) 'required': required,
    if (minProperties.isNotDefault) 'minProperties': encodeInt64(minProperties),
    if (maxProperties.isNotDefault) 'maxProperties': encodeInt64(maxProperties),
    if (minimum.isNotDefault) 'minimum': encodeDouble(minimum),
    if (maximum.isNotDefault) 'maximum': encodeDouble(maximum),
    if (minLength.isNotDefault) 'minLength': encodeInt64(minLength),
    if (maxLength.isNotDefault) 'maxLength': encodeInt64(maxLength),
    if (pattern.isNotDefault) 'pattern': pattern,
    if (example != null) 'example': example!.toJson(),
    if (anyOf.isNotDefault) 'anyOf': encodeList(anyOf),
    if (additionalProperties != null)
      'additionalProperties': additionalProperties!.toJson(),
    if (ref.isNotDefault) 'ref': ref,
    if (defs.isNotDefault) 'defs': encodeMap(defs),
  };

  @override
  String toString() {
    final contents = [
      'type=$type',
      'format=$format',
      'title=$title',
      'description=$description',
      'nullable=$nullable',
      'minItems=$minItems',
      'maxItems=$maxItems',
      'minProperties=$minProperties',
      'maxProperties=$maxProperties',
      'minimum=$minimum',
      'maximum=$maximum',
      'minLength=$minLength',
      'maxLength=$maxLength',
      'pattern=$pattern',
      'ref=$ref',
    ].join(',');
    return 'Schema($contents)';
  }
}

/// Generic Metadata shared by all operations.
final class GenericOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenericOperationMetadata';

  /// Output only. Partial failures encountered.
  /// E.g. single files that couldn't be read.
  /// This field should never exceed 20 entries.
  /// Status details field will contain standard Google Cloud error details.
  final List<Status> partialFailures;

  /// Output only. Time when the operation was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the operation was updated for the last time.
  /// If the operation has finished (successfully or not), this is the finish
  /// time.
  final protobuf.Timestamp? updateTime;

  GenericOperationMetadata({
    this.partialFailures = const [],
    this.createTime,
    this.updateTime,
  }) : super(fullyQualifiedName);

  factory GenericOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenericOperationMetadata(
      partialFailures: switch (json['partialFailures']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Status.fromJson(i)],
        _ => throw const FormatException('"partialFailures" is not a list'),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (partialFailures.isNotDefault)
      'partialFailures': encodeList(partialFailures),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
  };

  @override
  String toString() => 'GenericOperationMetadata()';
}

/// Details of operations that perform deletes of any entities.
final class DeleteOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  DeleteOperationMetadata({this.genericMetadata}) : super(fullyQualifiedName);

  factory DeleteOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'DeleteOperationMetadata()';
}

/// Represents long-lasting resources that are dedicated to users to runs custom
/// workloads.
/// A PersistentResource can have multiple node pools and each node
/// pool can have its own machine spec.
final class PersistentResource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PersistentResource';

  /// Immutable. Resource name of a PersistentResource.
  final String name;

  /// Optional. The display name of the PersistentResource.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Required. The spec of the pools of different resources.
  final List<ResourcePool> resourcePools;

  /// Output only. The detailed state of a Study.
  final PersistentResource_State state;

  /// Output only. Only populated when persistent resource's state is `STOPPING`
  /// or `ERROR`.
  final Status? error;

  /// Output only. Time when the PersistentResource was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the PersistentResource for the first time entered
  /// the `RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the PersistentResource was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The labels with user-defined metadata to organize
  /// PersistentResource.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Optional. The full name of the Compute Engine
  /// [network](/compute/docs/networks-and-firewalls#networks) to peered with
  /// Vertex AI to host the persistent resources.
  /// For example, `projects/12345/global/networks/myVPC`.
  /// [Format](/compute/docs/reference/rest/v1/networks/insert)
  /// is of the form `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in `12345`, and {network} is a
  /// network name.
  ///
  /// To specify this field, you must have already [configured VPC Network
  /// Peering for Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  ///
  /// If this field is left unspecified, the resources aren't peered with any
  /// network.
  final String network;

  /// Optional. Configuration for PSC-I for PersistentResource.
  final PscInterfaceConfig? pscInterfaceConfig;

  /// Optional. Customer-managed encryption key spec for a PersistentResource.
  /// If set, this PersistentResource and all sub-resources of this
  /// PersistentResource will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Optional. Persistent Resource runtime spec.
  /// For example, used for Ray cluster configuration.
  final ResourceRuntimeSpec? resourceRuntimeSpec;

  /// Output only. Runtime information of the Persistent Resource.
  final ResourceRuntime? resourceRuntime;

  /// Optional. A list of names for the reserved IP ranges under the VPC network
  /// that can be used for this persistent resource.
  ///
  /// If set, we will deploy the persistent resource within the provided IP
  /// ranges. Otherwise, the persistent resource is deployed to any IP
  /// ranges under the provided VPC network.
  ///
  /// Example: ['vertex-ai-ip-range'].
  final List<String> reservedIpRanges;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  PersistentResource({
    this.name = '',
    this.displayName = '',
    required this.resourcePools,
    this.state = PersistentResource_State.$default,
    this.error,
    this.createTime,
    this.startTime,
    this.updateTime,
    this.labels = const {},
    this.network = '',
    this.pscInterfaceConfig,
    this.encryptionSpec,
    this.resourceRuntimeSpec,
    this.resourceRuntime,
    this.reservedIpRanges = const [],
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory PersistentResource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PersistentResource(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      resourcePools: switch (json['resourcePools']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ResourcePool.fromJson(i)],
        _ => throw const FormatException('"resourcePools" is not a list'),
      },
      state: switch (json['state']) {
        null => PersistentResource_State.$default,
        Object $1 => PersistentResource_State.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      network: switch (json['network']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pscInterfaceConfig: switch (json['pscInterfaceConfig']) {
        null => null,
        Object $1 => PscInterfaceConfig.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      resourceRuntimeSpec: switch (json['resourceRuntimeSpec']) {
        null => null,
        Object $1 => ResourceRuntimeSpec.fromJson($1),
      },
      resourceRuntime: switch (json['resourceRuntime']) {
        null => null,
        Object $1 => ResourceRuntime.fromJson($1),
      },
      reservedIpRanges: switch (json['reservedIpRanges']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"reservedIpRanges" is not a list'),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    'resourcePools': encodeList(resourcePools),
    if (state.isNotDefault) 'state': state.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (network.isNotDefault) 'network': network,
    if (pscInterfaceConfig != null)
      'pscInterfaceConfig': pscInterfaceConfig!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (resourceRuntimeSpec != null)
      'resourceRuntimeSpec': resourceRuntimeSpec!.toJson(),
    if (resourceRuntime != null) 'resourceRuntime': resourceRuntime!.toJson(),
    if (reservedIpRanges.isNotDefault) 'reservedIpRanges': reservedIpRanges,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'state=$state',
      'network=$network',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'PersistentResource($contents)';
  }
}

/// Describes the PersistentResource state.
final class PersistentResource_State extends ProtoEnum {
  /// Not set.
  static const stateUnspecified = PersistentResource_State('STATE_UNSPECIFIED');

  /// The PROVISIONING state indicates the persistent resources is being
  /// created.
  static const provisioning = PersistentResource_State('PROVISIONING');

  /// The RUNNING state indicates the persistent resource is healthy and fully
  /// usable.
  static const running = PersistentResource_State('RUNNING');

  /// The STOPPING state indicates the persistent resource is being deleted.
  static const stopping = PersistentResource_State('STOPPING');

  /// The ERROR state indicates the persistent resource may be unusable.
  /// Details can be found in the `error` field.
  static const error = PersistentResource_State('ERROR');

  /// The REBOOTING state indicates the persistent resource is being rebooted
  /// (PR is not available right now but is expected to be ready again later).
  static const rebooting = PersistentResource_State('REBOOTING');

  /// The UPDATING state indicates the persistent resource is being updated.
  static const updating = PersistentResource_State('UPDATING');

  /// The default value for [PersistentResource_State].
  static const $default = stateUnspecified;

  const PersistentResource_State(super.value);

  factory PersistentResource_State.fromJson(Object? json) =>
      PersistentResource_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Represents the spec of a group of resources of the same type,
/// for example machine type, disk, and accelerators, in a PersistentResource.
final class ResourcePool extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourcePool';

  /// Immutable. The unique ID in a PersistentResource for referring to this
  /// resource pool. User can specify it if necessary. Otherwise, it's generated
  /// automatically.
  final String id;

  /// Required. Immutable. The specification of a single machine.
  final MachineSpec? machineSpec;

  /// Optional. The total number of machines to use for this resource pool.
  final int? replicaCount;

  /// Optional. Disk spec for the machine in this node pool.
  final DiskSpec? diskSpec;

  /// Output only. The number of machines currently in use by training jobs for
  /// this resource pool. Will replace idle_replica_count.
  final int usedReplicaCount;

  /// Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
  final ResourcePool_AutoscalingSpec? autoscalingSpec;

  ResourcePool({
    this.id = '',
    required this.machineSpec,
    this.replicaCount,
    this.diskSpec,
    this.usedReplicaCount = 0,
    this.autoscalingSpec,
  }) : super(fullyQualifiedName);

  factory ResourcePool.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourcePool(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      machineSpec: switch (json['machineSpec']) {
        null => null,
        Object $1 => MachineSpec.fromJson($1),
      },
      replicaCount: switch (json['replicaCount']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      diskSpec: switch (json['diskSpec']) {
        null => null,
        Object $1 => DiskSpec.fromJson($1),
      },
      usedReplicaCount: switch (json['usedReplicaCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      autoscalingSpec: switch (json['autoscalingSpec']) {
        null => null,
        Object $1 => ResourcePool_AutoscalingSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
    if (replicaCount != null) 'replicaCount': encodeInt64(replicaCount),
    if (diskSpec != null) 'diskSpec': diskSpec!.toJson(),
    if (usedReplicaCount.isNotDefault)
      'usedReplicaCount': encodeInt64(usedReplicaCount),
    if (autoscalingSpec != null) 'autoscalingSpec': autoscalingSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'id=$id',
      if (replicaCount != null) 'replicaCount=$replicaCount',
      'usedReplicaCount=$usedReplicaCount',
    ].join(',');
    return 'ResourcePool($contents)';
  }
}

/// The min/max number of replicas allowed if enabling autoscaling
final class ResourcePool_AutoscalingSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourcePool.AutoscalingSpec';

  /// Optional. min replicas in the node pool,
  /// must be  replica_count and < max_replica_count or will throw error.
  /// For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a
  /// resource_pool to be 0 to match the OSS Ray
  /// behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters).
  /// As for Persistent Resource, the min_replica_count must be > 0, we added
  /// a corresponding validation inside
  /// CreatePersistentResourceRequestValidator.java.
  final int? minReplicaCount;

  /// Optional. max replicas in the node pool,
  /// must be  replica_count and > min_replica_count or will throw error
  final int? maxReplicaCount;

  ResourcePool_AutoscalingSpec({this.minReplicaCount, this.maxReplicaCount})
    : super(fullyQualifiedName);

  factory ResourcePool_AutoscalingSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourcePool_AutoscalingSpec(
      minReplicaCount: switch (json['minReplicaCount']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      maxReplicaCount: switch (json['maxReplicaCount']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (minReplicaCount != null)
      'minReplicaCount': encodeInt64(minReplicaCount),
    if (maxReplicaCount != null)
      'maxReplicaCount': encodeInt64(maxReplicaCount),
  };

  @override
  String toString() {
    final contents = [
      if (minReplicaCount != null) 'minReplicaCount=$minReplicaCount',
      if (maxReplicaCount != null) 'maxReplicaCount=$maxReplicaCount',
    ].join(',');
    return 'AutoscalingSpec($contents)';
  }
}

/// Configuration for the runtime on a PersistentResource instance, including
/// but not limited to:
///
/// * Service accounts used to run the workloads.
/// * Whether to make it a dedicated Ray Cluster.
final class ResourceRuntimeSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourceRuntimeSpec';

  /// Optional. Configure the use of workload identity on the PersistentResource
  final ServiceAccountSpec? serviceAccountSpec;

  /// Optional. Ray cluster configuration.
  /// Required when creating a dedicated RayCluster on the PersistentResource.
  final RaySpec? raySpec;

  ResourceRuntimeSpec({this.serviceAccountSpec, this.raySpec})
    : super(fullyQualifiedName);

  factory ResourceRuntimeSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourceRuntimeSpec(
      serviceAccountSpec: switch (json['serviceAccountSpec']) {
        null => null,
        Object $1 => ServiceAccountSpec.fromJson($1),
      },
      raySpec: switch (json['raySpec']) {
        null => null,
        Object $1 => RaySpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (serviceAccountSpec != null)
      'serviceAccountSpec': serviceAccountSpec!.toJson(),
    if (raySpec != null) 'raySpec': raySpec!.toJson(),
  };

  @override
  String toString() => 'ResourceRuntimeSpec()';
}

/// Configuration information for the Ray cluster.
/// For experimental launch, Ray cluster creation and Persistent
/// cluster creation are 1:1 mapping: We will provision all the nodes within the
/// Persistent cluster as Ray nodes.
final class RaySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RaySpec';

  /// Optional. Default image for user to choose a preferred ML framework
  /// (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt
  /// images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  /// Either this or the resource_pool_images is required. Use this field if
  /// you need all the resource pools to have the same Ray image. Otherwise, use
  /// the {@code resource_pool_images} field.
  final String imageUri;

  /// Optional. Use if you want to mount to any NFS storages.
  final List<NfsMount> nfsMounts;

  /// Optional. Required if image_uri isn't set. A map of resource_pool_id to
  /// prebuild Ray image if user need to use different images for different
  /// head/worker pools. This map needs to cover all the resource pool ids.
  /// Example:
  /// {
  ///   "ray_head_node_pool": "head image"
  ///   "ray_worker_node_pool1": "worker image"
  ///   "ray_worker_node_pool2": "another worker image"
  /// }
  final Map<String, String> resourcePoolImages;

  /// Optional. This will be used to indicate which resource pool will serve as
  /// the Ray head node(the first node within that pool). Will use the machine
  /// from the first workerpool as the head node by default if this field isn't
  /// set.
  final String headNodeResourcePoolId;

  /// Optional. Ray metrics configurations.
  final RayMetricSpec? rayMetricSpec;

  /// Optional. OSS Ray logging configurations.
  final RayLogsSpec? rayLogsSpec;

  RaySpec({
    this.imageUri = '',
    this.nfsMounts = const [],
    this.resourcePoolImages = const {},
    this.headNodeResourcePoolId = '',
    this.rayMetricSpec,
    this.rayLogsSpec,
  }) : super(fullyQualifiedName);

  factory RaySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RaySpec(
      imageUri: switch (json['imageUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      nfsMounts: switch (json['nfsMounts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) NfsMount.fromJson(i)],
        _ => throw const FormatException('"nfsMounts" is not a list'),
      },
      resourcePoolImages: switch (json['resourcePoolImages']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException(
          '"resourcePoolImages" is not an object',
        ),
      },
      headNodeResourcePoolId: switch (json['headNodeResourcePoolId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      rayMetricSpec: switch (json['rayMetricSpec']) {
        null => null,
        Object $1 => RayMetricSpec.fromJson($1),
      },
      rayLogsSpec: switch (json['rayLogsSpec']) {
        null => null,
        Object $1 => RayLogsSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (imageUri.isNotDefault) 'imageUri': imageUri,
    if (nfsMounts.isNotDefault) 'nfsMounts': encodeList(nfsMounts),
    if (resourcePoolImages.isNotDefault)
      'resourcePoolImages': resourcePoolImages,
    if (headNodeResourcePoolId.isNotDefault)
      'headNodeResourcePoolId': headNodeResourcePoolId,
    if (rayMetricSpec != null) 'rayMetricSpec': rayMetricSpec!.toJson(),
    if (rayLogsSpec != null) 'rayLogsSpec': rayLogsSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'imageUri=$imageUri',
      'headNodeResourcePoolId=$headNodeResourcePoolId',
    ].join(',');
    return 'RaySpec($contents)';
  }
}

/// Persistent Cluster runtime information as output
final class ResourceRuntime extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourceRuntime';

  /// Output only. URIs for user to connect to the Cluster.
  /// Example:
  /// {
  ///   "RAY_HEAD_NODE_INTERNAL_IP": "head-node-IP:10001"
  ///   "RAY_DASHBOARD_URI": "ray-dashboard-address:8888"
  /// }
  final Map<String, String> accessUris;

  /// Output only. The resource name of NotebookRuntimeTemplate for the RoV
  /// Persistent Cluster The NotebokRuntimeTemplate is created in the same VPC
  /// (if set), and with the same Ray and Python version as the Persistent
  /// Cluster. Example:
  ///   "projects/1000/locations/us-central1/notebookRuntimeTemplates/abc123"
  final String notebookRuntimeTemplate;

  ResourceRuntime({
    this.accessUris = const {},
    this.notebookRuntimeTemplate = '',
  }) : super(fullyQualifiedName);

  factory ResourceRuntime.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourceRuntime(
      accessUris: switch (json['accessUris']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"accessUris" is not an object'),
      },
      notebookRuntimeTemplate: switch (json['notebookRuntimeTemplate']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (accessUris.isNotDefault) 'accessUris': accessUris,
    if (notebookRuntimeTemplate.isNotDefault)
      'notebookRuntimeTemplate': notebookRuntimeTemplate,
  };

  @override
  String toString() {
    final contents = [
      'notebookRuntimeTemplate=$notebookRuntimeTemplate',
    ].join(',');
    return 'ResourceRuntime($contents)';
  }
}

/// Configuration for the use of custom service account to run the workloads.
final class ServiceAccountSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ServiceAccountSpec';

  /// Required. If true, custom user-managed service account is enforced to run
  /// any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses
  /// the [Vertex AI Custom Code Service
  /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  final bool enableCustomServiceAccount;

  /// Optional. Required when all below conditions are met
  ///  * `enable_custom_service_account` is true;
  ///  * any runtime is specified via `ResourceRuntimeSpec` on creation time,
  ///    for example, Ray
  ///
  /// The users must have `iam.serviceAccounts.actAs` permission on this service
  /// account and then the specified runtime containers will run as it.
  ///
  /// Do not set this field if you want to submit jobs using custom service
  /// account to this PersistentResource after creation, but only specify the
  /// `service_account` inside the job.
  final String serviceAccount;

  ServiceAccountSpec({
    required this.enableCustomServiceAccount,
    this.serviceAccount = '',
  }) : super(fullyQualifiedName);

  factory ServiceAccountSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ServiceAccountSpec(
      enableCustomServiceAccount: switch (json['enableCustomServiceAccount']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'enableCustomServiceAccount': enableCustomServiceAccount,
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
  };

  @override
  String toString() {
    final contents = [
      'enableCustomServiceAccount=$enableCustomServiceAccount',
      'serviceAccount=$serviceAccount',
    ].join(',');
    return 'ServiceAccountSpec($contents)';
  }
}

/// Configuration for the Ray metrics.
final class RayMetricSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RayMetricSpec';

  /// Optional. Flag to disable the Ray metrics collection.
  final bool disabled;

  RayMetricSpec({this.disabled = false}) : super(fullyQualifiedName);

  factory RayMetricSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RayMetricSpec(
      disabled: switch (json['disabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {if (disabled.isNotDefault) 'disabled': disabled};

  @override
  String toString() {
    final contents = ['disabled=$disabled'].join(',');
    return 'RayMetricSpec($contents)';
  }
}

/// Configuration for the Ray OSS Logs.
final class RayLogsSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RayLogsSpec';

  /// Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
  final bool disabled;

  RayLogsSpec({this.disabled = false}) : super(fullyQualifiedName);

  factory RayLogsSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RayLogsSpec(
      disabled: switch (json['disabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {if (disabled.isNotDefault) 'disabled': disabled};

  @override
  String toString() {
    final contents = ['disabled=$disabled'].join(',');
    return 'RayLogsSpec($contents)';
  }
}

/// Request message for
/// `PersistentResourceService.CreatePersistentResource`.
final class CreatePersistentResourceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreatePersistentResourceRequest';

  /// Required. The resource name of the Location to create the
  /// PersistentResource in. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The PersistentResource to create.
  final PersistentResource? persistentResource;

  /// Required. The ID to use for the PersistentResource, which become the final
  /// component of the PersistentResource's resource name.
  ///
  /// The maximum length is 63 characters, and valid characters
  /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  final String persistentResourceId;

  CreatePersistentResourceRequest({
    required this.parent,
    required this.persistentResource,
    required this.persistentResourceId,
  }) : super(fullyQualifiedName);

  factory CreatePersistentResourceRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreatePersistentResourceRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      persistentResource: switch (json['persistentResource']) {
        null => null,
        Object $1 => PersistentResource.fromJson($1),
      },
      persistentResourceId: switch (json['persistentResourceId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (persistentResource != null)
      'persistentResource': persistentResource!.toJson(),
    'persistentResourceId': persistentResourceId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'persistentResourceId=$persistentResourceId',
    ].join(',');
    return 'CreatePersistentResourceRequest($contents)';
  }
}

/// Details of operations that perform create PersistentResource.
final class CreatePersistentResourceOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreatePersistentResourceOperationMetadata';

  /// Operation metadata for PersistentResource.
  final GenericOperationMetadata? genericMetadata;

  /// Progress Message for Create LRO
  final String progressMessage;

  CreatePersistentResourceOperationMetadata({
    this.genericMetadata,
    this.progressMessage = '',
  }) : super(fullyQualifiedName);

  factory CreatePersistentResourceOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreatePersistentResourceOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      progressMessage: switch (json['progressMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (progressMessage.isNotDefault) 'progressMessage': progressMessage,
  };

  @override
  String toString() {
    final contents = ['progressMessage=$progressMessage'].join(',');
    return 'CreatePersistentResourceOperationMetadata($contents)';
  }
}

/// Details of operations that perform update PersistentResource.
final class UpdatePersistentResourceOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdatePersistentResourceOperationMetadata';

  /// Operation metadata for PersistentResource.
  final GenericOperationMetadata? genericMetadata;

  /// Progress Message for Update LRO
  final String progressMessage;

  UpdatePersistentResourceOperationMetadata({
    this.genericMetadata,
    this.progressMessage = '',
  }) : super(fullyQualifiedName);

  factory UpdatePersistentResourceOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdatePersistentResourceOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      progressMessage: switch (json['progressMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (progressMessage.isNotDefault) 'progressMessage': progressMessage,
  };

  @override
  String toString() {
    final contents = ['progressMessage=$progressMessage'].join(',');
    return 'UpdatePersistentResourceOperationMetadata($contents)';
  }
}

/// Details of operations that perform reboot PersistentResource.
final class RebootPersistentResourceOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RebootPersistentResourceOperationMetadata';

  /// Operation metadata for PersistentResource.
  final GenericOperationMetadata? genericMetadata;

  /// Progress Message for Reboot LRO
  final String progressMessage;

  RebootPersistentResourceOperationMetadata({
    this.genericMetadata,
    this.progressMessage = '',
  }) : super(fullyQualifiedName);

  factory RebootPersistentResourceOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RebootPersistentResourceOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      progressMessage: switch (json['progressMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (progressMessage.isNotDefault) 'progressMessage': progressMessage,
  };

  @override
  String toString() {
    final contents = ['progressMessage=$progressMessage'].join(',');
    return 'RebootPersistentResourceOperationMetadata($contents)';
  }
}

/// Request message for
/// `PersistentResourceService.GetPersistentResource`.
final class GetPersistentResourceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetPersistentResourceRequest';

  /// Required. The name of the PersistentResource resource.
  /// Format:
  /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
  final String name;

  GetPersistentResourceRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetPersistentResourceRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetPersistentResourceRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetPersistentResourceRequest($contents)';
  }
}

/// Request message for `PersistentResourceService.ListPersistentResource`.
final class ListPersistentResourcesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPersistentResourcesRequest';

  /// Required. The resource name of the Location to list the PersistentResources
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListPersistentResourceResponse.next_page_token` of the previous
  /// `PersistentResourceService.ListPersistentResource` call.
  final String pageToken;

  ListPersistentResourcesRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListPersistentResourcesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListPersistentResourcesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListPersistentResourcesRequest($contents)';
  }
}

/// Response message for
/// `PersistentResourceService.ListPersistentResources`
final class ListPersistentResourcesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPersistentResourcesResponse';

  final List<PersistentResource> persistentResources;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListPersistentResourcesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListPersistentResourcesResponse({
    this.persistentResources = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListPersistentResourcesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListPersistentResourcesResponse(
      persistentResources: switch (json['persistentResources']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PersistentResource.fromJson(i),
        ],
        _ => throw const FormatException('"persistentResources" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (persistentResources.isNotDefault)
      'persistentResources': encodeList(persistentResources),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListPersistentResourcesResponse($contents)';
  }
}

/// Request message for
/// `PersistentResourceService.DeletePersistentResource`.
final class DeletePersistentResourceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeletePersistentResourceRequest';

  /// Required. The name of the PersistentResource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  final String name;

  DeletePersistentResourceRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeletePersistentResourceRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeletePersistentResourceRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeletePersistentResourceRequest($contents)';
  }
}

/// Request message for UpdatePersistentResource method.
final class UpdatePersistentResourceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdatePersistentResourceRequest';

  /// Required. The PersistentResource to update.
  ///
  /// The PersistentResource's `name` field is used to identify the
  /// PersistentResource to update. Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  final PersistentResource? persistentResource;

  /// Required. Specify the fields to be overwritten in the PersistentResource by
  /// the update method.
  final protobuf.FieldMask? updateMask;

  UpdatePersistentResourceRequest({
    required this.persistentResource,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdatePersistentResourceRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdatePersistentResourceRequest(
      persistentResource: switch (json['persistentResource']) {
        null => null,
        Object $1 => PersistentResource.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (persistentResource != null)
      'persistentResource': persistentResource!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdatePersistentResourceRequest()';
}

/// Request message for
/// `PersistentResourceService.RebootPersistentResource`.
final class RebootPersistentResourceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RebootPersistentResourceRequest';

  /// Required. The name of the PersistentResource resource.
  /// Format:
  /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
  final String name;

  RebootPersistentResourceRequest({required this.name})
    : super(fullyQualifiedName);

  factory RebootPersistentResourceRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RebootPersistentResourceRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'RebootPersistentResourceRequest($contents)';
  }
}

/// An instance of a machine learning PipelineJob.
final class PipelineJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob';

  /// Output only. The resource name of the PipelineJob.
  final String name;

  /// The display name of the Pipeline.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Output only. Pipeline creation time.
  final protobuf.Timestamp? createTime;

  /// Output only. Pipeline start time.
  final protobuf.Timestamp? startTime;

  /// Output only. Pipeline end time.
  final protobuf.Timestamp? endTime;

  /// Output only. Timestamp when this PipelineJob was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// The spec of the pipeline.
  final protobuf.Struct? pipelineSpec;

  /// Output only. The detailed state of the job.
  final PipelineState state;

  /// Output only. The details of pipeline run. Not available in the list view.
  final PipelineJobDetail? jobDetail;

  /// Output only. The error that occurred during pipeline execution.
  /// Only populated when the pipeline's state is FAILED or CANCELLED.
  final Status? error;

  /// The labels with user-defined metadata to organize PipelineJob.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  ///
  /// Note there is some reserved label key for Vertex AI Pipelines.
  /// - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
  final Map<String, String> labels;

  /// Runtime config of the pipeline.
  final PipelineJob_RuntimeConfig? runtimeConfig;

  /// Customer-managed encryption key spec for a pipelineJob. If set, this
  /// PipelineJob and all of its sub-resources will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// The service account that the pipeline workload runs as.
  /// If not specified, the Compute Engine default service account in the project
  /// will be used.
  /// See
  /// https://cloud.google.com/compute/docs/access/service-accounts#default_service_account
  ///
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  final String serviceAccount;

  /// The full name of the Compute Engine
  /// [network](/compute/docs/networks-and-firewalls#networks) to which the
  /// Pipeline Job's workload should be peered. For example,
  /// `projects/12345/global/networks/myVPC`.
  /// [Format](/compute/docs/reference/rest/v1/networks/insert)
  /// is of the form `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in `12345`, and {network} is a
  /// network name.
  ///
  /// Private services access must already be configured for the network.
  /// Pipeline job will apply the network configuration to the Google Cloud
  /// resources being launched, if applied, such as Vertex AI
  /// Training or Dataflow job. If left unspecified, the workload is not peered
  /// with any network.
  final String network;

  /// A list of names for the reserved ip ranges under the VPC network
  /// that can be used for this Pipeline Job's workload.
  ///
  /// If set, we will deploy the Pipeline Job's workload within the provided ip
  /// ranges. Otherwise, the job will be deployed to any ip ranges under the
  /// provided VPC network.
  ///
  /// Example: ['vertex-ai-ip-range'].
  final List<String> reservedIpRanges;

  /// Optional. Configuration for PSC-I for PipelineJob.
  final PscInterfaceConfig? pscInterfaceConfig;

  /// A template uri from where the
  /// `PipelineJob.pipeline_spec`,
  /// if empty, will be downloaded. Currently, only uri from Vertex Template
  /// Registry & Gallery is supported. Reference to
  /// https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
  final String templateUri;

  /// Output only. Pipeline template metadata. Will fill up fields if
  /// `PipelineJob.template_uri`
  /// is from supported template registry.
  final PipelineTemplateMetadata? templateMetadata;

  /// Output only. The schedule resource name.
  /// Only returned if the Pipeline is created by Schedule API.
  final String scheduleName;

  /// Optional. Whether to do component level validations before job creation.
  final bool preflightValidations;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  /// Optional. The original pipeline job id if this pipeline job is a rerun of a
  /// previous pipeline job.
  final int originalPipelineJobId;

  /// Optional. The rerun configs for each task in the pipeline job.
  /// By default, the rerun will:
  /// 1. Use the same input artifacts as the original run.
  /// 2. Use the same input parameters as the original run.
  /// 3. Skip all the tasks that are already succeeded in the original run.
  /// 4. Rerun all the tasks that are not succeeded in the original run.
  /// By providing this field, users can override the default behavior and
  /// specify the rerun config for each task.
  final List<PipelineTaskRerunConfig> pipelineTaskRerunConfigs;

  PipelineJob({
    this.name = '',
    this.displayName = '',
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.pipelineSpec,
    this.state = PipelineState.$default,
    this.jobDetail,
    this.error,
    this.labels = const {},
    this.runtimeConfig,
    this.encryptionSpec,
    this.serviceAccount = '',
    this.network = '',
    this.reservedIpRanges = const [],
    this.pscInterfaceConfig,
    this.templateUri = '',
    this.templateMetadata,
    this.scheduleName = '',
    this.preflightValidations = false,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
    this.originalPipelineJobId = 0,
    this.pipelineTaskRerunConfigs = const [],
  }) : super(fullyQualifiedName);

  factory PipelineJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineJob(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      pipelineSpec: switch (json['pipelineSpec']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      state: switch (json['state']) {
        null => PipelineState.$default,
        Object $1 => PipelineState.fromJson($1),
      },
      jobDetail: switch (json['jobDetail']) {
        null => null,
        Object $1 => PipelineJobDetail.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      runtimeConfig: switch (json['runtimeConfig']) {
        null => null,
        Object $1 => PipelineJob_RuntimeConfig.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
      network: switch (json['network']) {
        null => '',
        Object $1 => decodeString($1),
      },
      reservedIpRanges: switch (json['reservedIpRanges']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"reservedIpRanges" is not a list'),
      },
      pscInterfaceConfig: switch (json['pscInterfaceConfig']) {
        null => null,
        Object $1 => PscInterfaceConfig.fromJson($1),
      },
      templateUri: switch (json['templateUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      templateMetadata: switch (json['templateMetadata']) {
        null => null,
        Object $1 => PipelineTemplateMetadata.fromJson($1),
      },
      scheduleName: switch (json['scheduleName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      preflightValidations: switch (json['preflightValidations']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      originalPipelineJobId: switch (json['originalPipelineJobId']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      pipelineTaskRerunConfigs: switch (json['pipelineTaskRerunConfigs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PipelineTaskRerunConfig.fromJson(i),
        ],
        _ => throw const FormatException(
          '"pipelineTaskRerunConfigs" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (pipelineSpec != null) 'pipelineSpec': pipelineSpec!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (jobDetail != null) 'jobDetail': jobDetail!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (runtimeConfig != null) 'runtimeConfig': runtimeConfig!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
    if (network.isNotDefault) 'network': network,
    if (reservedIpRanges.isNotDefault) 'reservedIpRanges': reservedIpRanges,
    if (pscInterfaceConfig != null)
      'pscInterfaceConfig': pscInterfaceConfig!.toJson(),
    if (templateUri.isNotDefault) 'templateUri': templateUri,
    if (templateMetadata != null)
      'templateMetadata': templateMetadata!.toJson(),
    if (scheduleName.isNotDefault) 'scheduleName': scheduleName,
    if (preflightValidations.isNotDefault)
      'preflightValidations': preflightValidations,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
    if (originalPipelineJobId.isNotDefault)
      'originalPipelineJobId': encodeInt64(originalPipelineJobId),
    if (pipelineTaskRerunConfigs.isNotDefault)
      'pipelineTaskRerunConfigs': encodeList(pipelineTaskRerunConfigs),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'state=$state',
      'serviceAccount=$serviceAccount',
      'network=$network',
      'templateUri=$templateUri',
      'scheduleName=$scheduleName',
      'preflightValidations=$preflightValidations',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
      'originalPipelineJobId=$originalPipelineJobId',
    ].join(',');
    return 'PipelineJob($contents)';
  }
}

/// The runtime config of a PipelineJob.
final class PipelineJob_RuntimeConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob.RuntimeConfig';

  /// Deprecated. Use
  /// `RuntimeConfig.parameter_values`
  /// instead. The runtime parameters of the PipelineJob. The parameters will
  /// be passed into
  /// `PipelineJob.pipeline_spec`
  /// to replace the placeholders at runtime. This field is used by pipelines
  /// built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower,
  /// such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
  final Map<String, Value> parameters;

  /// Required. A path in a Cloud Storage bucket, which will be treated as the
  /// root output directory of the pipeline. It is used by the system to
  /// generate the paths of output artifacts. The artifact paths are generated
  /// with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the
  /// specified output directory. The service account specified in this
  /// pipeline must have the `storage.objects.get` and `storage.objects.create`
  /// permissions for this bucket.
  final String gcsOutputDirectory;

  /// The runtime parameters of the PipelineJob. The parameters will be
  /// passed into
  /// `PipelineJob.pipeline_spec`
  /// to replace the placeholders at runtime. This field is used by pipelines
  /// built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as
  /// pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2
  /// DSL.
  final Map<String, protobuf.Value> parameterValues;

  /// Represents the failure policy of a pipeline. Currently, the default of a
  /// pipeline is that the pipeline will continue to run until no more tasks
  /// can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW.
  /// However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it
  /// will stop scheduling any new tasks when a task has failed. Any scheduled
  /// tasks will continue to completion.
  final PipelineFailurePolicy failurePolicy;

  /// The runtime artifacts of the PipelineJob. The key will be the input
  /// artifact name and the value would be one of the InputArtifact.
  final Map<String, PipelineJob_RuntimeConfig_InputArtifact> inputArtifacts;

  /// Optional. The default runtime for the PipelineJob. If not provided,
  /// Vertex Custom Job(on demand) is used as the runtime. For Vertex Custom
  /// Job, please refer to
  /// https://cloud.google.com/vertex-ai/docs/training/overview.
  final PipelineJob_RuntimeConfig_DefaultRuntime? defaultRuntime;

  PipelineJob_RuntimeConfig({
    this.parameters = const {},
    required this.gcsOutputDirectory,
    this.parameterValues = const {},
    this.failurePolicy = PipelineFailurePolicy.$default,
    this.inputArtifacts = const {},
    this.defaultRuntime,
  }) : super(fullyQualifiedName);

  factory PipelineJob_RuntimeConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineJob_RuntimeConfig(
      parameters: switch (json['parameters']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Value.fromJson(e.value),
        },
        _ => throw const FormatException('"parameters" is not an object'),
      },
      gcsOutputDirectory: switch (json['gcsOutputDirectory']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parameterValues: switch (json['parameterValues']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): protobuf.Value.fromJson(e.value),
        },
        _ => throw const FormatException('"parameterValues" is not an object'),
      },
      failurePolicy: switch (json['failurePolicy']) {
        null => PipelineFailurePolicy.$default,
        Object $1 => PipelineFailurePolicy.fromJson($1),
      },
      inputArtifacts: switch (json['inputArtifacts']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key):
                PipelineJob_RuntimeConfig_InputArtifact.fromJson(e.value),
        },
        _ => throw const FormatException('"inputArtifacts" is not an object'),
      },
      defaultRuntime: switch (json['defaultRuntime']) {
        null => null,
        Object $1 => PipelineJob_RuntimeConfig_DefaultRuntime.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (parameters.isNotDefault) 'parameters': encodeMap(parameters),
    'gcsOutputDirectory': gcsOutputDirectory,
    if (parameterValues.isNotDefault)
      'parameterValues': encodeMap(parameterValues),
    if (failurePolicy.isNotDefault) 'failurePolicy': failurePolicy.toJson(),
    if (inputArtifacts.isNotDefault)
      'inputArtifacts': encodeMap(inputArtifacts),
    if (defaultRuntime != null) 'defaultRuntime': defaultRuntime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'gcsOutputDirectory=$gcsOutputDirectory',
      'failurePolicy=$failurePolicy',
    ].join(',');
    return 'RuntimeConfig($contents)';
  }
}

/// The type of an input artifact.
final class PipelineJob_RuntimeConfig_InputArtifact extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob.RuntimeConfig.InputArtifact';

  /// Artifact resource id from MLMD. Which is the last portion of an
  /// artifact resource name:
  /// `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`.
  /// The artifact must stay within the same project, location and default
  /// metadatastore as the pipeline.
  final String? artifactId;

  PipelineJob_RuntimeConfig_InputArtifact({this.artifactId})
    : super(fullyQualifiedName);

  factory PipelineJob_RuntimeConfig_InputArtifact.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineJob_RuntimeConfig_InputArtifact(
      artifactId: switch (json['artifactId']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (artifactId != null) 'artifactId': artifactId};

  @override
  String toString() {
    final contents = [
      if (artifactId != null) 'artifactId=$artifactId',
    ].join(',');
    return 'InputArtifact($contents)';
  }
}

/// Persistent resource based runtime detail. For more information, refer to
/// https://cloud.google.com/vertex-ai/docs/training/persistent-resource-overview
final class PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob.RuntimeConfig.PersistentResourceRuntimeDetail';

  /// Persistent resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  final String persistentResourceName;

  /// The max time a pipeline task waits for the required CPU, memory, or
  /// accelerator resource to become available from the specified persistent
  /// resource. Default wait time is 0.
  final int taskResourceUnavailableWaitTimeMs;

  /// Specifies the behavior to take if the timeout is reached.
  final PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior
  taskResourceUnavailableTimeoutBehavior;

  PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail({
    this.persistentResourceName = '',
    this.taskResourceUnavailableWaitTimeMs = 0,
    this.taskResourceUnavailableTimeoutBehavior =
        PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior
            .$default,
  }) : super(fullyQualifiedName);

  factory PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail(
      persistentResourceName: switch (json['persistentResourceName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      taskResourceUnavailableWaitTimeMs:
          switch (json['taskResourceUnavailableWaitTimeMs']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
      taskResourceUnavailableTimeoutBehavior:
          switch (json['taskResourceUnavailableTimeoutBehavior']) {
            null =>
              PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior
                  .$default,
            Object $1 =>
              PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior.fromJson(
                $1,
              ),
          },
    );
  }

  @override
  Object toJson() => {
    if (persistentResourceName.isNotDefault)
      'persistentResourceName': persistentResourceName,
    if (taskResourceUnavailableWaitTimeMs.isNotDefault)
      'taskResourceUnavailableWaitTimeMs': encodeInt64(
        taskResourceUnavailableWaitTimeMs,
      ),
    if (taskResourceUnavailableTimeoutBehavior.isNotDefault)
      'taskResourceUnavailableTimeoutBehavior':
          taskResourceUnavailableTimeoutBehavior.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'persistentResourceName=$persistentResourceName',
      'taskResourceUnavailableWaitTimeMs=$taskResourceUnavailableWaitTimeMs',
      'taskResourceUnavailableTimeoutBehavior=$taskResourceUnavailableTimeoutBehavior',
    ].join(',');
    return 'PersistentResourceRuntimeDetail($contents)';
  }
}

/// An enum that specifies the behavior to take if the timeout is reached.
final class PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior
    extends ProtoEnum {
  /// Unspecified. Behavior is same as `FAIL`.
  static const taskResourceUnavailableTimeoutBehaviorUnspecified =
      PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
        'TASK_RESOURCE_UNAVAILABLE_TIMEOUT_BEHAVIOR_UNSPECIFIED',
      );

  /// Fail the task if the timeout is reached.
  static const fail =
      PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
        'FAIL',
      );

  /// Fall back to on-demand execution if the timeout is reached.
  static const fallBackToOnDemand =
      PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
        'FALL_BACK_TO_ON_DEMAND',
      );

  /// The default value for [PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior].
  static const $default = taskResourceUnavailableTimeoutBehaviorUnspecified;

  const PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
    super.value,
  );

  factory PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior.fromJson(
    Object? json,
  ) =>
      PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
        json as String,
      );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'TaskResourceUnavailableTimeoutBehavior.$value';
}

/// The default runtime for the PipelineJob.
final class PipelineJob_RuntimeConfig_DefaultRuntime extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob.RuntimeConfig.DefaultRuntime';

  /// Persistent resource based runtime detail.
  final PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail?
  persistentResourceRuntimeDetail;

  PipelineJob_RuntimeConfig_DefaultRuntime({
    this.persistentResourceRuntimeDetail,
  }) : super(fullyQualifiedName);

  factory PipelineJob_RuntimeConfig_DefaultRuntime.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineJob_RuntimeConfig_DefaultRuntime(
      persistentResourceRuntimeDetail:
          switch (json['persistentResourceRuntimeDetail']) {
            null => null,
            Object $1 =>
              PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail.fromJson(
                $1,
              ),
          },
    );
  }

  @override
  Object toJson() => {
    if (persistentResourceRuntimeDetail != null)
      'persistentResourceRuntimeDetail': persistentResourceRuntimeDetail!
          .toJson(),
  };

  @override
  String toString() => 'DefaultRuntime()';
}

/// Pipeline template metadata if
/// `PipelineJob.template_uri`
/// is from supported template registry. Currently, the only supported registry
/// is Artifact Registry.
final class PipelineTemplateMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTemplateMetadata';

  /// The version_name in artifact registry.
  ///
  /// Will always be presented in output if the
  /// `PipelineJob.template_uri`
  /// is from supported template registry.
  ///
  /// Format is "sha256:abcdef123456...".
  final String version;

  PipelineTemplateMetadata({this.version = ''}) : super(fullyQualifiedName);

  factory PipelineTemplateMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTemplateMetadata(
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (version.isNotDefault) 'version': version};

  @override
  String toString() {
    final contents = ['version=$version'].join(',');
    return 'PipelineTemplateMetadata($contents)';
  }
}

/// The runtime detail of PipelineJob.
final class PipelineJobDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJobDetail';

  /// Output only. The context of the pipeline.
  final Context? pipelineContext;

  /// Output only. The context of the current pipeline run.
  final Context? pipelineRunContext;

  /// Output only. The runtime details of the tasks under the pipeline.
  final List<PipelineTaskDetail> taskDetails;

  PipelineJobDetail({
    this.pipelineContext,
    this.pipelineRunContext,
    this.taskDetails = const [],
  }) : super(fullyQualifiedName);

  factory PipelineJobDetail.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineJobDetail(
      pipelineContext: switch (json['pipelineContext']) {
        null => null,
        Object $1 => Context.fromJson($1),
      },
      pipelineRunContext: switch (json['pipelineRunContext']) {
        null => null,
        Object $1 => Context.fromJson($1),
      },
      taskDetails: switch (json['taskDetails']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PipelineTaskDetail.fromJson(i),
        ],
        _ => throw const FormatException('"taskDetails" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (pipelineContext != null) 'pipelineContext': pipelineContext!.toJson(),
    if (pipelineRunContext != null)
      'pipelineRunContext': pipelineRunContext!.toJson(),
    if (taskDetails.isNotDefault) 'taskDetails': encodeList(taskDetails),
  };

  @override
  String toString() => 'PipelineJobDetail()';
}

/// The runtime detail of a task execution.
final class PipelineTaskDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskDetail';

  /// Output only. The system generated ID of the task.
  final int taskId;

  /// Output only. The id of the parent task if the task is within a component
  /// scope. Empty if the task is at the root level.
  final int parentTaskId;

  /// Output only. The user specified name of the task that is defined in
  /// `pipeline_spec`.
  final String taskName;

  /// Output only. Task create time.
  final protobuf.Timestamp? createTime;

  /// Output only. Task start time.
  final protobuf.Timestamp? startTime;

  /// Output only. Task end time.
  final protobuf.Timestamp? endTime;

  /// Output only. The detailed execution info.
  final PipelineTaskExecutorDetail? executorDetail;

  /// Output only. State of the task.
  final PipelineTaskDetail_State state;

  /// Output only. The execution metadata of the task.
  final Execution? execution;

  /// Output only. The error that occurred during task execution.
  /// Only populated when the task's state is FAILED or CANCELLED.
  final Status? error;

  /// Output only. A list of task status. This field keeps a record of task
  /// status evolving over time.
  final List<PipelineTaskDetail_PipelineTaskStatus> pipelineTaskStatus;

  /// Output only. The runtime input artifacts of the task.
  final Map<String, PipelineTaskDetail_ArtifactList> inputs;

  /// Output only. The runtime output artifacts of the task.
  final Map<String, PipelineTaskDetail_ArtifactList> outputs;

  /// Output only. The unique name of a task.
  /// This field is used by pipeline job reruns.
  /// Console UI and Vertex AI SDK will support triggering pipeline job reruns.
  /// The name is constructed by concatenating all the parent tasks' names with
  /// the task name. For example, if a task named "child_task" has a parent task
  /// named "parent_task_1" and parent task 1 has a parent task named
  /// "parent_task_2", the task unique name will be
  /// "parent_task_2.parent_task_1.child_task".
  final String taskUniqueName;

  PipelineTaskDetail({
    this.taskId = 0,
    this.parentTaskId = 0,
    this.taskName = '',
    this.createTime,
    this.startTime,
    this.endTime,
    this.executorDetail,
    this.state = PipelineTaskDetail_State.$default,
    this.execution,
    this.error,
    this.pipelineTaskStatus = const [],
    this.inputs = const {},
    this.outputs = const {},
    this.taskUniqueName = '',
  }) : super(fullyQualifiedName);

  factory PipelineTaskDetail.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskDetail(
      taskId: switch (json['taskId']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      parentTaskId: switch (json['parentTaskId']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      taskName: switch (json['taskName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      executorDetail: switch (json['executorDetail']) {
        null => null,
        Object $1 => PipelineTaskExecutorDetail.fromJson($1),
      },
      state: switch (json['state']) {
        null => PipelineTaskDetail_State.$default,
        Object $1 => PipelineTaskDetail_State.fromJson($1),
      },
      execution: switch (json['execution']) {
        null => null,
        Object $1 => Execution.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      pipelineTaskStatus: switch (json['pipelineTaskStatus']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PipelineTaskDetail_PipelineTaskStatus.fromJson(i),
        ],
        _ => throw const FormatException('"pipelineTaskStatus" is not a list'),
      },
      inputs: switch (json['inputs']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): PipelineTaskDetail_ArtifactList.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"inputs" is not an object'),
      },
      outputs: switch (json['outputs']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): PipelineTaskDetail_ArtifactList.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"outputs" is not an object'),
      },
      taskUniqueName: switch (json['taskUniqueName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (taskId.isNotDefault) 'taskId': encodeInt64(taskId),
    if (parentTaskId.isNotDefault) 'parentTaskId': encodeInt64(parentTaskId),
    if (taskName.isNotDefault) 'taskName': taskName,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (executorDetail != null) 'executorDetail': executorDetail!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (execution != null) 'execution': execution!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (pipelineTaskStatus.isNotDefault)
      'pipelineTaskStatus': encodeList(pipelineTaskStatus),
    if (inputs.isNotDefault) 'inputs': encodeMap(inputs),
    if (outputs.isNotDefault) 'outputs': encodeMap(outputs),
    if (taskUniqueName.isNotDefault) 'taskUniqueName': taskUniqueName,
  };

  @override
  String toString() {
    final contents = [
      'taskId=$taskId',
      'parentTaskId=$parentTaskId',
      'taskName=$taskName',
      'state=$state',
      'taskUniqueName=$taskUniqueName',
    ].join(',');
    return 'PipelineTaskDetail($contents)';
  }
}

/// A single record of the task status.
final class PipelineTaskDetail_PipelineTaskStatus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskDetail.PipelineTaskStatus';

  /// Output only. Update time of this status.
  final protobuf.Timestamp? updateTime;

  /// Output only. The state of the task.
  final PipelineTaskDetail_State state;

  /// Output only. The error that occurred during the state. May be set when
  /// the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or
  /// FAILED state. If the state is FAILED, the error here is final and not
  /// going to be retried. If the state is a non-final state, the error
  /// indicates a system-error being retried.
  final Status? error;

  PipelineTaskDetail_PipelineTaskStatus({
    this.updateTime,
    this.state = PipelineTaskDetail_State.$default,
    this.error,
  }) : super(fullyQualifiedName);

  factory PipelineTaskDetail_PipelineTaskStatus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskDetail_PipelineTaskStatus(
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      state: switch (json['state']) {
        null => PipelineTaskDetail_State.$default,
        Object $1 => PipelineTaskDetail_State.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (error != null) 'error': error!.toJson(),
  };

  @override
  String toString() {
    final contents = ['state=$state'].join(',');
    return 'PipelineTaskStatus($contents)';
  }
}

/// A list of artifact metadata.
final class PipelineTaskDetail_ArtifactList extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskDetail.ArtifactList';

  /// Output only. A list of artifact metadata.
  final List<Artifact> artifacts;

  PipelineTaskDetail_ArtifactList({this.artifacts = const []})
    : super(fullyQualifiedName);

  factory PipelineTaskDetail_ArtifactList.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskDetail_ArtifactList(
      artifacts: switch (json['artifacts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Artifact.fromJson(i)],
        _ => throw const FormatException('"artifacts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (artifacts.isNotDefault) 'artifacts': encodeList(artifacts),
  };

  @override
  String toString() => 'ArtifactList()';
}

/// Specifies state of TaskExecution
final class PipelineTaskDetail_State extends ProtoEnum {
  /// Unspecified.
  static const stateUnspecified = PipelineTaskDetail_State('STATE_UNSPECIFIED');

  /// Specifies pending state for the task.
  static const pending = PipelineTaskDetail_State('PENDING');

  /// Specifies task is being executed.
  static const running = PipelineTaskDetail_State('RUNNING');

  /// Specifies task completed successfully.
  static const succeeded = PipelineTaskDetail_State('SUCCEEDED');

  /// Specifies Task cancel is in pending state.
  static const cancelPending = PipelineTaskDetail_State('CANCEL_PENDING');

  /// Specifies task is being cancelled.
  static const cancelling = PipelineTaskDetail_State('CANCELLING');

  /// Specifies task was cancelled.
  static const cancelled = PipelineTaskDetail_State('CANCELLED');

  /// Specifies task failed.
  static const failed = PipelineTaskDetail_State('FAILED');

  /// Specifies task was skipped due to cache hit.
  static const skipped = PipelineTaskDetail_State('SKIPPED');

  /// Specifies that the task was not triggered because the task's trigger
  /// policy is not satisfied. The trigger policy is specified in the
  /// `condition` field of
  /// `PipelineJob.pipeline_spec`.
  static const notTriggered = PipelineTaskDetail_State('NOT_TRIGGERED');

  /// The default value for [PipelineTaskDetail_State].
  static const $default = stateUnspecified;

  const PipelineTaskDetail_State(super.value);

  factory PipelineTaskDetail_State.fromJson(Object? json) =>
      PipelineTaskDetail_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// The runtime detail of a pipeline executor.
final class PipelineTaskExecutorDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskExecutorDetail';

  /// Output only. The detailed info for a container executor.
  final PipelineTaskExecutorDetail_ContainerDetail? containerDetail;

  /// Output only. The detailed info for a custom job executor.
  final PipelineTaskExecutorDetail_CustomJobDetail? customJobDetail;

  PipelineTaskExecutorDetail({this.containerDetail, this.customJobDetail})
    : super(fullyQualifiedName);

  factory PipelineTaskExecutorDetail.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskExecutorDetail(
      containerDetail: switch (json['containerDetail']) {
        null => null,
        Object $1 => PipelineTaskExecutorDetail_ContainerDetail.fromJson($1),
      },
      customJobDetail: switch (json['customJobDetail']) {
        null => null,
        Object $1 => PipelineTaskExecutorDetail_CustomJobDetail.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (containerDetail != null) 'containerDetail': containerDetail!.toJson(),
    if (customJobDetail != null) 'customJobDetail': customJobDetail!.toJson(),
  };

  @override
  String toString() => 'PipelineTaskExecutorDetail()';
}

/// The detail of a container execution. It contains the job names of the
/// lifecycle of a container execution.
final class PipelineTaskExecutorDetail_ContainerDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskExecutorDetail.ContainerDetail';

  /// Output only. The name of the
  /// `CustomJob` for the main
  /// container execution.
  final String mainJob;

  /// Output only. The name of the
  /// `CustomJob` for the
  /// pre-caching-check container execution. This job will be available if the
  /// `PipelineJob.pipeline_spec`
  /// specifies the `pre_caching_check` hook in the lifecycle events.
  final String preCachingCheckJob;

  /// Output only. The names of the previously failed
  /// `CustomJob` for the main
  /// container executions. The list includes the all attempts in chronological
  /// order.
  final List<String> failedMainJobs;

  /// Output only. The names of the previously failed
  /// `CustomJob` for the
  /// pre-caching-check container executions. This job will be available if the
  /// `PipelineJob.pipeline_spec`
  /// specifies the `pre_caching_check` hook in the lifecycle events. The list
  /// includes the all attempts in chronological order.
  final List<String> failedPreCachingCheckJobs;

  PipelineTaskExecutorDetail_ContainerDetail({
    this.mainJob = '',
    this.preCachingCheckJob = '',
    this.failedMainJobs = const [],
    this.failedPreCachingCheckJobs = const [],
  }) : super(fullyQualifiedName);

  factory PipelineTaskExecutorDetail_ContainerDetail.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskExecutorDetail_ContainerDetail(
      mainJob: switch (json['mainJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      preCachingCheckJob: switch (json['preCachingCheckJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      failedMainJobs: switch (json['failedMainJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"failedMainJobs" is not a list'),
      },
      failedPreCachingCheckJobs: switch (json['failedPreCachingCheckJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"failedPreCachingCheckJobs" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (mainJob.isNotDefault) 'mainJob': mainJob,
    if (preCachingCheckJob.isNotDefault)
      'preCachingCheckJob': preCachingCheckJob,
    if (failedMainJobs.isNotDefault) 'failedMainJobs': failedMainJobs,
    if (failedPreCachingCheckJobs.isNotDefault)
      'failedPreCachingCheckJobs': failedPreCachingCheckJobs,
  };

  @override
  String toString() {
    final contents = [
      'mainJob=$mainJob',
      'preCachingCheckJob=$preCachingCheckJob',
    ].join(',');
    return 'ContainerDetail($contents)';
  }
}

/// The detailed info for a custom job executor.
final class PipelineTaskExecutorDetail_CustomJobDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskExecutorDetail.CustomJobDetail';

  /// Output only. The name of the
  /// `CustomJob`.
  final String job;

  /// Output only. The names of the previously failed
  /// `CustomJob`. The list includes
  /// the all attempts in chronological order.
  final List<String> failedJobs;

  PipelineTaskExecutorDetail_CustomJobDetail({
    this.job = '',
    this.failedJobs = const [],
  }) : super(fullyQualifiedName);

  factory PipelineTaskExecutorDetail_CustomJobDetail.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskExecutorDetail_CustomJobDetail(
      job: switch (json['job']) {
        null => '',
        Object $1 => decodeString($1),
      },
      failedJobs: switch (json['failedJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"failedJobs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (job.isNotDefault) 'job': job,
    if (failedJobs.isNotDefault) 'failedJobs': failedJobs,
  };

  @override
  String toString() {
    final contents = ['job=$job'].join(',');
    return 'CustomJobDetail($contents)';
  }
}

/// User provided rerun config to submit a rerun pipelinejob. This includes
/// 1. Which task to rerun
/// 2. User override input parameters and artifacts.
final class PipelineTaskRerunConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskRerunConfig';

  /// Optional. The system generated ID of the task. Retrieved from original run.
  final int taskId;

  /// Optional. The name of the task.
  final String taskName;

  /// Optional. The runtime input of the task overridden by the user.
  final PipelineTaskRerunConfig_Inputs? inputs;

  /// Optional. Whether to skip this task. Default value is False.
  final bool skipTask;

  /// Optional. Whether to skip downstream tasks. Default value is False.
  final bool skipDownstreamTasks;

  PipelineTaskRerunConfig({
    this.taskId = 0,
    this.taskName = '',
    this.inputs,
    this.skipTask = false,
    this.skipDownstreamTasks = false,
  }) : super(fullyQualifiedName);

  factory PipelineTaskRerunConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskRerunConfig(
      taskId: switch (json['taskId']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      taskName: switch (json['taskName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      inputs: switch (json['inputs']) {
        null => null,
        Object $1 => PipelineTaskRerunConfig_Inputs.fromJson($1),
      },
      skipTask: switch (json['skipTask']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      skipDownstreamTasks: switch (json['skipDownstreamTasks']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (taskId.isNotDefault) 'taskId': encodeInt64(taskId),
    if (taskName.isNotDefault) 'taskName': taskName,
    if (inputs != null) 'inputs': inputs!.toJson(),
    if (skipTask.isNotDefault) 'skipTask': skipTask,
    if (skipDownstreamTasks.isNotDefault)
      'skipDownstreamTasks': skipDownstreamTasks,
  };

  @override
  String toString() {
    final contents = [
      'taskId=$taskId',
      'taskName=$taskName',
      'skipTask=$skipTask',
      'skipDownstreamTasks=$skipDownstreamTasks',
    ].join(',');
    return 'PipelineTaskRerunConfig($contents)';
  }
}

/// A list of artifact metadata.
final class PipelineTaskRerunConfig_ArtifactList extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskRerunConfig.ArtifactList';

  /// Optional. A list of artifact metadata.
  final List<RuntimeArtifact> artifacts;

  PipelineTaskRerunConfig_ArtifactList({this.artifacts = const []})
    : super(fullyQualifiedName);

  factory PipelineTaskRerunConfig_ArtifactList.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskRerunConfig_ArtifactList(
      artifacts: switch (json['artifacts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) RuntimeArtifact.fromJson(i)],
        _ => throw const FormatException('"artifacts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (artifacts.isNotDefault) 'artifacts': encodeList(artifacts),
  };

  @override
  String toString() => 'ArtifactList()';
}

/// Runtime inputs data of the task.
final class PipelineTaskRerunConfig_Inputs extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskRerunConfig.Inputs';

  /// Optional. Input artifacts.
  final Map<String, PipelineTaskRerunConfig_ArtifactList> artifacts;

  /// Optional. Input parameters.
  final Map<String, protobuf.Value> parameterValues;

  PipelineTaskRerunConfig_Inputs({
    this.artifacts = const {},
    this.parameterValues = const {},
  }) : super(fullyQualifiedName);

  factory PipelineTaskRerunConfig_Inputs.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PipelineTaskRerunConfig_Inputs(
      artifacts: switch (json['artifacts']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): PipelineTaskRerunConfig_ArtifactList.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"artifacts" is not an object'),
      },
      parameterValues: switch (json['parameterValues']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): protobuf.Value.fromJson(e.value),
        },
        _ => throw const FormatException('"parameterValues" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (artifacts.isNotDefault) 'artifacts': encodeMap(artifacts),
    if (parameterValues.isNotDefault)
      'parameterValues': encodeMap(parameterValues),
  };

  @override
  String toString() => 'Inputs()';
}

/// Runtime operation information for
/// `PipelineService.BatchCancelPipelineJobs`.
final class BatchCancelPipelineJobsOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCancelPipelineJobsOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  BatchCancelPipelineJobsOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory BatchCancelPipelineJobsOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCancelPipelineJobsOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'BatchCancelPipelineJobsOperationMetadata()';
}

/// Request message for
/// `PipelineService.CreateTrainingPipeline`.
final class CreateTrainingPipelineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTrainingPipelineRequest';

  /// Required. The resource name of the Location to create the TrainingPipeline
  /// in. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The TrainingPipeline to create.
  final TrainingPipeline? trainingPipeline;

  CreateTrainingPipelineRequest({
    required this.parent,
    required this.trainingPipeline,
  }) : super(fullyQualifiedName);

  factory CreateTrainingPipelineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateTrainingPipelineRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      trainingPipeline: switch (json['trainingPipeline']) {
        null => null,
        Object $1 => TrainingPipeline.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (trainingPipeline != null)
      'trainingPipeline': trainingPipeline!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateTrainingPipelineRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.GetTrainingPipeline`.
final class GetTrainingPipelineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTrainingPipelineRequest';

  /// Required. The name of the TrainingPipeline resource.
  /// Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  final String name;

  GetTrainingPipelineRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTrainingPipelineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetTrainingPipelineRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTrainingPipelineRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.ListTrainingPipelines`.
final class ListTrainingPipelinesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTrainingPipelinesRequest';

  /// Required. The resource name of the Location to list the TrainingPipelines
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `training_task_definition` `=`, `!=` comparisons, and `:` wildcard.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="PIPELINE_STATE_SUCCEEDED" AND display_name:"my_pipeline_*"`
  ///   * `state!="PIPELINE_STATE_FAILED" OR display_name="my_pipeline"`
  ///   * `NOT display_name="my_pipeline"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `training_task_definition:"*automl_text_classification*"`
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListTrainingPipelinesResponse.next_page_token`
  /// of the previous
  /// `PipelineService.ListTrainingPipelines`
  /// call.
  final String pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTrainingPipelinesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTrainingPipelinesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTrainingPipelinesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListTrainingPipelinesRequest($contents)';
  }
}

/// Response message for
/// `PipelineService.ListTrainingPipelines`
final class ListTrainingPipelinesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTrainingPipelinesResponse';

  /// List of TrainingPipelines in the requested page.
  final List<TrainingPipeline> trainingPipelines;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListTrainingPipelinesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListTrainingPipelinesResponse({
    this.trainingPipelines = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListTrainingPipelinesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTrainingPipelinesResponse(
      trainingPipelines: switch (json['trainingPipelines']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TrainingPipeline.fromJson(i)],
        _ => throw const FormatException('"trainingPipelines" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trainingPipelines.isNotDefault)
      'trainingPipelines': encodeList(trainingPipelines),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListTrainingPipelinesResponse($contents)';
  }
}

/// Request message for
/// `PipelineService.DeleteTrainingPipeline`.
final class DeleteTrainingPipelineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTrainingPipelineRequest';

  /// Required. The name of the TrainingPipeline resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  final String name;

  DeleteTrainingPipelineRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteTrainingPipelineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteTrainingPipelineRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTrainingPipelineRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.CancelTrainingPipeline`.
final class CancelTrainingPipelineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelTrainingPipelineRequest';

  /// Required. The name of the TrainingPipeline to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  final String name;

  CancelTrainingPipelineRequest({required this.name})
    : super(fullyQualifiedName);

  factory CancelTrainingPipelineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelTrainingPipelineRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelTrainingPipelineRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.CreatePipelineJob`.
final class CreatePipelineJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreatePipelineJobRequest';

  /// Required. The resource name of the Location to create the PipelineJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The PipelineJob to create.
  final PipelineJob? pipelineJob;

  /// The ID to use for the PipelineJob, which will become the final component of
  /// the PipelineJob name. If not provided, an ID will be automatically
  /// generated.
  ///
  /// This value should be less than 128 characters, and valid characters
  /// are `/[a-z][0-9]-/`.
  final String pipelineJobId;

  CreatePipelineJobRequest({
    required this.parent,
    required this.pipelineJob,
    this.pipelineJobId = '',
  }) : super(fullyQualifiedName);

  factory CreatePipelineJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreatePipelineJobRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pipelineJob: switch (json['pipelineJob']) {
        null => null,
        Object $1 => PipelineJob.fromJson($1),
      },
      pipelineJobId: switch (json['pipelineJobId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pipelineJob != null) 'pipelineJob': pipelineJob!.toJson(),
    if (pipelineJobId.isNotDefault) 'pipelineJobId': pipelineJobId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pipelineJobId=$pipelineJobId',
    ].join(',');
    return 'CreatePipelineJobRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.GetPipelineJob`.
final class GetPipelineJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetPipelineJobRequest';

  /// Required. The name of the PipelineJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  final String name;

  GetPipelineJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetPipelineJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetPipelineJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetPipelineJobRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.ListPipelineJobs`.
final class ListPipelineJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPipelineJobsRequest';

  /// Required. The resource name of the Location to list the PipelineJobs from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the PipelineJobs that match the filter expression. The following
  /// fields are supported:
  ///
  /// * `pipeline_name`: Supports `=` and `!=` comparisons.
  /// * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard.
  /// * `pipeline_job_user_id`: Supports `=`, `!=` comparisons, and `:` wildcard.
  ///   for example, can check if pipeline's display_name contains *step* by
  ///   doing display_name:\"*step*\"
  /// * `state`: Supports `=` and `!=` comparisons.
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///   Values must be in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///   Values must be in RFC 3339 format.
  /// * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///   Values must be in RFC 3339 format.
  /// * `labels`: Supports key-value equality and key presence.
  /// * `template_uri`: Supports `=`, `!=` comparisons, and `:` wildcard.
  /// * `template_metadata.version`: Supports `=`, `!=` comparisons, and `:`
  ///   wildcard.
  ///
  /// Filter expressions can be combined together using logical operators
  /// (`AND` & `OR`).
  /// For example: `pipeline_name="test" AND create_time>"2020-05-18T13:30:00Z"`.
  ///
  /// The syntax to define filter expression is based on
  /// https://google.aip.dev/160.
  ///
  /// Examples:
  ///
  /// * `create_time>"2021-05-18T00:00:00Z" OR
  ///   update_time>"2020-05-18T00:00:00Z"` PipelineJobs created or updated
  ///   after 2020-05-18 00:00:00 UTC.
  /// * `labels.env = "prod"`
  ///   PipelineJobs with label "env" set to "prod".
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListPipelineJobsResponse.next_page_token`
  /// of the previous
  /// `PipelineService.ListPipelineJobs`
  /// call.
  final String pageToken;

  /// A comma-separated list of fields to order by. The default sort order is in
  /// ascending order. Use "desc" after a field name for descending. You can have
  /// multiple order_by fields provided e.g. "create_time desc, end_time",
  /// "end_time, start_time, update_time" For example, using "create_time desc,
  /// end_time" will order results by create time in descending order, and if
  /// there are multiple jobs having the same create time, order them by the end
  /// time in ascending order. if order_by is not specified, it will order by
  /// default order is create time in descending order. Supported fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  ///   * `end_time`
  ///   * `start_time`
  final String orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListPipelineJobsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListPipelineJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListPipelineJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListPipelineJobsRequest($contents)';
  }
}

/// Response message for
/// `PipelineService.ListPipelineJobs`
final class ListPipelineJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPipelineJobsResponse';

  /// List of PipelineJobs in the requested page.
  final List<PipelineJob> pipelineJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListPipelineJobsRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListPipelineJobsResponse({
    this.pipelineJobs = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListPipelineJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListPipelineJobsResponse(
      pipelineJobs: switch (json['pipelineJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) PipelineJob.fromJson(i)],
        _ => throw const FormatException('"pipelineJobs" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (pipelineJobs.isNotDefault) 'pipelineJobs': encodeList(pipelineJobs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListPipelineJobsResponse($contents)';
  }
}

/// Request message for
/// `PipelineService.DeletePipelineJob`.
final class DeletePipelineJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeletePipelineJobRequest';

  /// Required. The name of the PipelineJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  final String name;

  DeletePipelineJobRequest({required this.name}) : super(fullyQualifiedName);

  factory DeletePipelineJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeletePipelineJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeletePipelineJobRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.BatchDeletePipelineJobs`.
final class BatchDeletePipelineJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchDeletePipelineJobsRequest';

  /// Required. The name of the PipelineJobs' parent resource.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The names of the PipelineJobs to delete.
  /// A maximum of 32 PipelineJobs can be deleted in a batch.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
  final List<String> names;

  BatchDeletePipelineJobsRequest({required this.parent, required this.names})
    : super(fullyQualifiedName);

  factory BatchDeletePipelineJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchDeletePipelineJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      names: switch (json['names']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"names" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent, 'names': names};

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchDeletePipelineJobsRequest($contents)';
  }
}

/// Response message for
/// `PipelineService.BatchDeletePipelineJobs`.
final class BatchDeletePipelineJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchDeletePipelineJobsResponse';

  /// PipelineJobs deleted.
  final List<PipelineJob> pipelineJobs;

  BatchDeletePipelineJobsResponse({this.pipelineJobs = const []})
    : super(fullyQualifiedName);

  factory BatchDeletePipelineJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchDeletePipelineJobsResponse(
      pipelineJobs: switch (json['pipelineJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) PipelineJob.fromJson(i)],
        _ => throw const FormatException('"pipelineJobs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (pipelineJobs.isNotDefault) 'pipelineJobs': encodeList(pipelineJobs),
  };

  @override
  String toString() => 'BatchDeletePipelineJobsResponse()';
}

/// Request message for
/// `PipelineService.CancelPipelineJob`.
final class CancelPipelineJobRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelPipelineJobRequest';

  /// Required. The name of the PipelineJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  final String name;

  CancelPipelineJobRequest({required this.name}) : super(fullyQualifiedName);

  factory CancelPipelineJobRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelPipelineJobRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelPipelineJobRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.BatchCancelPipelineJobs`.
final class BatchCancelPipelineJobsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCancelPipelineJobsRequest';

  /// Required. The name of the PipelineJobs' parent resource.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The names of the PipelineJobs to cancel.
  /// A maximum of 32 PipelineJobs can be cancelled in a batch.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
  final List<String> names;

  BatchCancelPipelineJobsRequest({required this.parent, required this.names})
    : super(fullyQualifiedName);

  factory BatchCancelPipelineJobsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCancelPipelineJobsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      names: switch (json['names']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"names" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent, 'names': names};

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchCancelPipelineJobsRequest($contents)';
  }
}

/// Response message for
/// `PipelineService.BatchCancelPipelineJobs`.
final class BatchCancelPipelineJobsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCancelPipelineJobsResponse';

  /// PipelineJobs cancelled.
  final List<PipelineJob> pipelineJobs;

  BatchCancelPipelineJobsResponse({this.pipelineJobs = const []})
    : super(fullyQualifiedName);

  factory BatchCancelPipelineJobsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCancelPipelineJobsResponse(
      pipelineJobs: switch (json['pipelineJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) PipelineJob.fromJson(i)],
        _ => throw const FormatException('"pipelineJobs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (pipelineJobs.isNotDefault) 'pipelineJobs': encodeList(pipelineJobs),
  };

  @override
  String toString() => 'BatchCancelPipelineJobsResponse()';
}

/// Request message for
/// `PredictionService.Predict`.
final class PredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The instances that are the input to the prediction call.
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the prediction call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model.
  /// The schema of any single instance may be specified via Endpoint's
  /// DeployedModels'
  /// [Model's][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`.
  final List<protobuf.Value> instances;

  /// The parameters that govern the prediction. The schema of the parameters may
  /// be specified via Endpoint's DeployedModels' [Model's
  /// ][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `parameters_schema_uri`.
  final protobuf.Value? parameters;

  /// Optional. The user labels for Imagen billing usage only. Only Imagen
  /// supports labels. For other use cases, it will be ignored.
  final Map<String, String> labels;

  PredictRequest({
    required this.endpoint,
    required this.instances,
    this.parameters,
    this.labels = const {},
  }) : super(fullyQualifiedName);

  factory PredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"instances" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    'instances': encodeList(instances),
    if (parameters != null) 'parameters': parameters!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'PredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.Predict`.
final class PredictResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictResponse';

  /// The predictions that are the output of the predictions call.
  /// The schema of any single prediction may be specified via Endpoint's
  /// DeployedModels' [Model's
  /// ][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `prediction_schema_uri`.
  final List<protobuf.Value> predictions;

  /// ID of the Endpoint's DeployedModel that served this prediction.
  final String deployedModelId;

  /// Output only. The resource name of the Model which is deployed as the
  /// DeployedModel that this prediction hits.
  final String model;

  /// Output only. The version ID of the Model which is deployed as the
  /// DeployedModel that this prediction hits.
  final String modelVersionId;

  /// Output only. The [display
  /// name][google.cloud.aiplatform.v1beta1.Model.display_name] of the Model
  /// which is deployed as the DeployedModel that this prediction hits.
  final String modelDisplayName;

  /// Output only. Request-level metadata returned by the model. The metadata
  /// type will be dependent upon the model implementation.
  final protobuf.Value? metadata;

  PredictResponse({
    this.predictions = const [],
    this.deployedModelId = '',
    this.model = '',
    this.modelVersionId = '',
    this.modelDisplayName = '',
    this.metadata,
  }) : super(fullyQualifiedName);

  factory PredictResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PredictResponse(
      predictions: switch (json['predictions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"predictions" is not a list'),
      },
      deployedModelId: switch (json['deployedModelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersionId: switch (json['modelVersionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelDisplayName: switch (json['modelDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (predictions.isNotDefault) 'predictions': encodeList(predictions),
    if (deployedModelId.isNotDefault) 'deployedModelId': deployedModelId,
    if (model.isNotDefault) 'model': model,
    if (modelVersionId.isNotDefault) 'modelVersionId': modelVersionId,
    if (modelDisplayName.isNotDefault) 'modelDisplayName': modelDisplayName,
    if (metadata != null) 'metadata': metadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'deployedModelId=$deployedModelId',
      'model=$model',
      'modelVersionId=$modelVersionId',
      'modelDisplayName=$modelDisplayName',
    ].join(',');
    return 'PredictResponse($contents)';
  }
}

/// Request message for
/// `PredictionService.RawPredict`.
final class RawPredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// The prediction input. Supports HTTP headers and arbitrary data payload.
  ///
  /// A `DeployedModel` may have
  /// an upper limit on the number of instances it supports per request. When
  /// this limit it is exceeded for an AutoML model, the
  /// `RawPredict`
  /// method returns an error. When this limit is exceeded for a custom-trained
  /// model, the behavior varies depending on the model.
  ///
  /// You can specify the schema for each instance in the
  /// `predict_schemata.instance_schema_uri`
  /// field when you create a `Model`.
  /// This schema applies when you deploy the `Model` as a `DeployedModel` to an
  /// `Endpoint` and use the
  /// `RawPredict` method.
  final HttpBody? httpBody;

  RawPredictRequest({required this.endpoint, this.httpBody})
    : super(fullyQualifiedName);

  factory RawPredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RawPredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      httpBody: switch (json['httpBody']) {
        null => null,
        Object $1 => HttpBody.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (httpBody != null) 'httpBody': httpBody!.toJson(),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'RawPredictRequest($contents)';
  }
}

/// Request message for
/// `PredictionService.StreamRawPredict`.
final class StreamRawPredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamRawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// The prediction input. Supports HTTP headers and arbitrary data payload.
  final HttpBody? httpBody;

  StreamRawPredictRequest({required this.endpoint, this.httpBody})
    : super(fullyQualifiedName);

  factory StreamRawPredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamRawPredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      httpBody: switch (json['httpBody']) {
        null => null,
        Object $1 => HttpBody.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (httpBody != null) 'httpBody': httpBody!.toJson(),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'StreamRawPredictRequest($contents)';
  }
}

/// Request message for
/// `PredictionService.DirectPredict`.
final class DirectPredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// The prediction input.
  final List<Tensor> inputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  DirectPredictRequest({
    required this.endpoint,
    this.inputs = const [],
    this.parameters,
  }) : super(fullyQualifiedName);

  factory DirectPredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DirectPredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      inputs: switch (json['inputs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tensor.fromJson(i)],
        _ => throw const FormatException('"inputs" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => Tensor.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (inputs.isNotDefault) 'inputs': encodeList(inputs),
    if (parameters != null) 'parameters': parameters!.toJson(),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'DirectPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.DirectPredict`.
final class DirectPredictResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectPredictResponse';

  /// The prediction output.
  final List<Tensor> outputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  DirectPredictResponse({this.outputs = const [], this.parameters})
    : super(fullyQualifiedName);

  factory DirectPredictResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DirectPredictResponse(
      outputs: switch (json['outputs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tensor.fromJson(i)],
        _ => throw const FormatException('"outputs" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => Tensor.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (outputs.isNotDefault) 'outputs': encodeList(outputs),
    if (parameters != null) 'parameters': parameters!.toJson(),
  };

  @override
  String toString() => 'DirectPredictResponse()';
}

/// Request message for
/// `PredictionService.DirectRawPredict`.
final class DirectRawPredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectRawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Fully qualified name of the API method being invoked to perform
  /// predictions.
  ///
  /// Format:
  /// `/namespace.Service/Method/`
  /// Example:
  /// `/tensorflow.serving.PredictionService/Predict`
  final String methodName;

  /// The prediction input.
  final Uint8List input;

  DirectRawPredictRequest({
    required this.endpoint,
    this.methodName = '',
    Uint8List? input,
  }) : input = input ?? Uint8List(0),
       super(fullyQualifiedName);

  factory DirectRawPredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DirectRawPredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      methodName: switch (json['methodName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      input: switch (json['input']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (methodName.isNotDefault) 'methodName': methodName,
    if (input.isNotDefault) 'input': encodeBytes(input),
  };

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      'methodName=$methodName',
      'input=$input',
    ].join(',');
    return 'DirectRawPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.DirectRawPredict`.
final class DirectRawPredictResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectRawPredictResponse';

  /// The prediction output.
  final Uint8List output;

  DirectRawPredictResponse({Uint8List? output})
    : output = output ?? Uint8List(0),
      super(fullyQualifiedName);

  factory DirectRawPredictResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DirectRawPredictResponse(
      output: switch (json['output']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {if (output.isNotDefault) 'output': encodeBytes(output)};

  @override
  String toString() {
    final contents = ['output=$output'].join(',');
    return 'DirectRawPredictResponse($contents)';
  }
}

/// Request message for
/// `PredictionService.StreamDirectPredict`.
///
/// The first message must contain
/// `endpoint`
/// field and optionally `input`. The subsequent messages must contain
/// `input`.
final class StreamDirectPredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamDirectPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Optional. The prediction input.
  final List<Tensor> inputs;

  /// Optional. The parameters that govern the prediction.
  final Tensor? parameters;

  StreamDirectPredictRequest({
    required this.endpoint,
    this.inputs = const [],
    this.parameters,
  }) : super(fullyQualifiedName);

  factory StreamDirectPredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamDirectPredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      inputs: switch (json['inputs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tensor.fromJson(i)],
        _ => throw const FormatException('"inputs" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => Tensor.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (inputs.isNotDefault) 'inputs': encodeList(inputs),
    if (parameters != null) 'parameters': parameters!.toJson(),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'StreamDirectPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.StreamDirectPredict`.
final class StreamDirectPredictResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamDirectPredictResponse';

  /// The prediction output.
  final List<Tensor> outputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  StreamDirectPredictResponse({this.outputs = const [], this.parameters})
    : super(fullyQualifiedName);

  factory StreamDirectPredictResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamDirectPredictResponse(
      outputs: switch (json['outputs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tensor.fromJson(i)],
        _ => throw const FormatException('"outputs" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => Tensor.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (outputs.isNotDefault) 'outputs': encodeList(outputs),
    if (parameters != null) 'parameters': parameters!.toJson(),
  };

  @override
  String toString() => 'StreamDirectPredictResponse()';
}

/// Request message for
/// `PredictionService.StreamDirectRawPredict`.
///
/// The first message must contain
/// `endpoint`
/// and
/// `method_name`
/// fields and optionally
/// `input`.
/// The subsequent messages must contain
/// `input`.
/// `method_name`
/// in the subsequent messages have no effect.
final class StreamDirectRawPredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamDirectRawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Optional. Fully qualified name of the API method being invoked to perform
  /// predictions.
  ///
  /// Format:
  /// `/namespace.Service/Method/`
  /// Example:
  /// `/tensorflow.serving.PredictionService/Predict`
  final String methodName;

  /// Optional. The prediction input.
  final Uint8List input;

  StreamDirectRawPredictRequest({
    required this.endpoint,
    this.methodName = '',
    Uint8List? input,
  }) : input = input ?? Uint8List(0),
       super(fullyQualifiedName);

  factory StreamDirectRawPredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamDirectRawPredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      methodName: switch (json['methodName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      input: switch (json['input']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (methodName.isNotDefault) 'methodName': methodName,
    if (input.isNotDefault) 'input': encodeBytes(input),
  };

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      'methodName=$methodName',
      'input=$input',
    ].join(',');
    return 'StreamDirectRawPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.StreamDirectRawPredict`.
final class StreamDirectRawPredictResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamDirectRawPredictResponse';

  /// The prediction output.
  final Uint8List output;

  StreamDirectRawPredictResponse({Uint8List? output})
    : output = output ?? Uint8List(0),
      super(fullyQualifiedName);

  factory StreamDirectRawPredictResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamDirectRawPredictResponse(
      output: switch (json['output']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {if (output.isNotDefault) 'output': encodeBytes(output)};

  @override
  String toString() {
    final contents = ['output=$output'].join(',');
    return 'StreamDirectRawPredictResponse($contents)';
  }
}

/// Request message for
/// `PredictionService.StreamingPredict`.
///
/// The first message must contain
/// `endpoint`
/// field and optionally `input`. The subsequent messages must contain
/// `input`.
final class StreamingPredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// The prediction input.
  final List<Tensor> inputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  StreamingPredictRequest({
    required this.endpoint,
    this.inputs = const [],
    this.parameters,
  }) : super(fullyQualifiedName);

  factory StreamingPredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamingPredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      inputs: switch (json['inputs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tensor.fromJson(i)],
        _ => throw const FormatException('"inputs" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => Tensor.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (inputs.isNotDefault) 'inputs': encodeList(inputs),
    if (parameters != null) 'parameters': parameters!.toJson(),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'StreamingPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.StreamingPredict`.
final class StreamingPredictResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingPredictResponse';

  /// The prediction output.
  final List<Tensor> outputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  StreamingPredictResponse({this.outputs = const [], this.parameters})
    : super(fullyQualifiedName);

  factory StreamingPredictResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamingPredictResponse(
      outputs: switch (json['outputs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tensor.fromJson(i)],
        _ => throw const FormatException('"outputs" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => Tensor.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (outputs.isNotDefault) 'outputs': encodeList(outputs),
    if (parameters != null) 'parameters': parameters!.toJson(),
  };

  @override
  String toString() => 'StreamingPredictResponse()';
}

/// Request message for
/// `PredictionService.StreamingRawPredict`.
///
/// The first message must contain
/// `endpoint`
/// and
/// `method_name`
/// fields and optionally
/// `input`.
/// The subsequent messages must contain
/// `input`.
/// `method_name`
/// in the subsequent messages have no effect.
final class StreamingRawPredictRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingRawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Fully qualified name of the API method being invoked to perform
  /// predictions.
  ///
  /// Format:
  /// `/namespace.Service/Method/`
  /// Example:
  /// `/tensorflow.serving.PredictionService/Predict`
  final String methodName;

  /// The prediction input.
  final Uint8List input;

  StreamingRawPredictRequest({
    required this.endpoint,
    this.methodName = '',
    Uint8List? input,
  }) : input = input ?? Uint8List(0),
       super(fullyQualifiedName);

  factory StreamingRawPredictRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamingRawPredictRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      methodName: switch (json['methodName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      input: switch (json['input']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (methodName.isNotDefault) 'methodName': methodName,
    if (input.isNotDefault) 'input': encodeBytes(input),
  };

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      'methodName=$methodName',
      'input=$input',
    ].join(',');
    return 'StreamingRawPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.StreamingRawPredict`.
final class StreamingRawPredictResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingRawPredictResponse';

  /// The prediction output.
  final Uint8List output;

  StreamingRawPredictResponse({Uint8List? output})
    : output = output ?? Uint8List(0),
      super(fullyQualifiedName);

  factory StreamingRawPredictResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamingRawPredictResponse(
      output: switch (json['output']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {if (output.isNotDefault) 'output': encodeBytes(output)};

  @override
  String toString() {
    final contents = ['output=$output'].join(',');
    return 'StreamingRawPredictResponse($contents)';
  }
}

/// Request message for
/// `PredictionService.Explain`.
final class ExplainRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplainRequest';

  /// Required. The name of the Endpoint requested to serve the explanation.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The instances that are the input to the explanation call.
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the explanation call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model.
  /// The schema of any single instance may be specified via Endpoint's
  /// DeployedModels'
  /// [Model's][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`.
  final List<protobuf.Value> instances;

  /// The parameters that govern the prediction. The schema of the parameters may
  /// be specified via Endpoint's DeployedModels' [Model's
  /// ][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `parameters_schema_uri`.
  final protobuf.Value? parameters;

  /// If specified, overrides the
  /// `explanation_spec`
  /// of the DeployedModel. Can be used for explaining prediction results with
  /// different configurations, such as:
  ///  - Explaining top-5 predictions results as opposed to top-1;
  ///  - Increasing path count or step count of the attribution methods to reduce
  ///    approximate errors;
  ///  - Using different baselines for explaining the prediction results.
  final ExplanationSpecOverride? explanationSpecOverride;

  /// Optional. This field is the same as the one above, but supports multiple
  /// explanations to occur in parallel. The key can be any string. Each override
  /// will be run against the model, then its explanations will be grouped
  /// together.
  ///
  /// Note - these explanations are run **In Addition** to the default
  /// Explanation in the deployed model.
  final Map<String, ExplanationSpecOverride> concurrentExplanationSpecOverride;

  /// If specified, this ExplainRequest will be served by the chosen
  /// DeployedModel, overriding
  /// `Endpoint.traffic_split`.
  final String deployedModelId;

  ExplainRequest({
    required this.endpoint,
    required this.instances,
    this.parameters,
    this.explanationSpecOverride,
    this.concurrentExplanationSpecOverride = const {},
    this.deployedModelId = '',
  }) : super(fullyQualifiedName);

  factory ExplainRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplainRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"instances" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      explanationSpecOverride: switch (json['explanationSpecOverride']) {
        null => null,
        Object $1 => ExplanationSpecOverride.fromJson($1),
      },
      concurrentExplanationSpecOverride:
          switch (json['concurrentExplanationSpecOverride']) {
            null => {},
            Map<String, Object?> $1 => {
              for (final e in $1.entries)
                decodeString(e.key): ExplanationSpecOverride.fromJson(e.value),
            },
            _ => throw const FormatException(
              '"concurrentExplanationSpecOverride" is not an object',
            ),
          },
      deployedModelId: switch (json['deployedModelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    'instances': encodeList(instances),
    if (parameters != null) 'parameters': parameters!.toJson(),
    if (explanationSpecOverride != null)
      'explanationSpecOverride': explanationSpecOverride!.toJson(),
    if (concurrentExplanationSpecOverride.isNotDefault)
      'concurrentExplanationSpecOverride': encodeMap(
        concurrentExplanationSpecOverride,
      ),
    if (deployedModelId.isNotDefault) 'deployedModelId': deployedModelId,
  };

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      'deployedModelId=$deployedModelId',
    ].join(',');
    return 'ExplainRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.Explain`.
final class ExplainResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplainResponse';

  /// The explanations of the Model's
  /// `PredictResponse.predictions`.
  ///
  /// It has the same number of elements as
  /// `instances` to be
  /// explained.
  final List<Explanation> explanations;

  /// This field stores the results of the explanations run in parallel with
  /// The default explanation strategy/method.
  final Map<String, ExplainResponse_ConcurrentExplanation>
  concurrentExplanations;

  /// ID of the Endpoint's DeployedModel that served this explanation.
  final String deployedModelId;

  /// The predictions that are the output of the predictions call.
  /// Same as
  /// `PredictResponse.predictions`.
  final List<protobuf.Value> predictions;

  ExplainResponse({
    this.explanations = const [],
    this.concurrentExplanations = const {},
    this.deployedModelId = '',
    this.predictions = const [],
  }) : super(fullyQualifiedName);

  factory ExplainResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplainResponse(
      explanations: switch (json['explanations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Explanation.fromJson(i)],
        _ => throw const FormatException('"explanations" is not a list'),
      },
      concurrentExplanations: switch (json['concurrentExplanations']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): ExplainResponse_ConcurrentExplanation.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException(
          '"concurrentExplanations" is not an object',
        ),
      },
      deployedModelId: switch (json['deployedModelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      predictions: switch (json['predictions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"predictions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (explanations.isNotDefault) 'explanations': encodeList(explanations),
    if (concurrentExplanations.isNotDefault)
      'concurrentExplanations': encodeMap(concurrentExplanations),
    if (deployedModelId.isNotDefault) 'deployedModelId': deployedModelId,
    if (predictions.isNotDefault) 'predictions': encodeList(predictions),
  };

  @override
  String toString() {
    final contents = ['deployedModelId=$deployedModelId'].join(',');
    return 'ExplainResponse($contents)';
  }
}

/// This message is a wrapper grouping Concurrent Explanations.
final class ExplainResponse_ConcurrentExplanation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplainResponse.ConcurrentExplanation';

  /// The explanations of the Model's
  /// `PredictResponse.predictions`.
  ///
  /// It has the same number of elements as
  /// `instances` to
  /// be explained.
  final List<Explanation> explanations;

  ExplainResponse_ConcurrentExplanation({this.explanations = const []})
    : super(fullyQualifiedName);

  factory ExplainResponse_ConcurrentExplanation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExplainResponse_ConcurrentExplanation(
      explanations: switch (json['explanations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Explanation.fromJson(i)],
        _ => throw const FormatException('"explanations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (explanations.isNotDefault) 'explanations': encodeList(explanations),
  };

  @override
  String toString() => 'ConcurrentExplanation()';
}

/// Request message for
/// `PredictionService.CountTokens`.
final class CountTokensRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CountTokensRequest';

  /// Required. The name of the Endpoint requested to perform token counting.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Optional. The name of the publisher model requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/publishers/*/models/*`
  final String model;

  /// Optional. The instances that are the input to token counting call.
  /// Schema is identical to the prediction schema of the underlying model.
  final List<protobuf.Value> instances;

  /// Optional. Input content.
  final List<Content> contents;

  /// Optional. The user provided system instructions for the model.
  /// Note: only text should be used in parts and content in each part will be in
  /// a separate paragraph.
  final Content? systemInstruction;

  /// Optional. A list of `Tools` the model may use to generate the next
  /// response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  final List<Tool> tools;

  /// Optional. Generation config that the model will use to generate the
  /// response.
  final GenerationConfig? generationConfig;

  CountTokensRequest({
    required this.endpoint,
    this.model = '',
    this.instances = const [],
    this.contents = const [],
    this.systemInstruction,
    this.tools = const [],
    this.generationConfig,
  }) : super(fullyQualifiedName);

  factory CountTokensRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CountTokensRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      instances: switch (json['instances']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Value.fromJson(i)],
        _ => throw const FormatException('"instances" is not a list'),
      },
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
      systemInstruction: switch (json['systemInstruction']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
      tools: switch (json['tools']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tool.fromJson(i)],
        _ => throw const FormatException('"tools" is not a list'),
      },
      generationConfig: switch (json['generationConfig']) {
        null => null,
        Object $1 => GenerationConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (model.isNotDefault) 'model': model,
    if (instances.isNotDefault) 'instances': encodeList(instances),
    if (contents.isNotDefault) 'contents': encodeList(contents),
    if (systemInstruction != null)
      'systemInstruction': systemInstruction!.toJson(),
    if (tools.isNotDefault) 'tools': encodeList(tools),
    if (generationConfig != null)
      'generationConfig': generationConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint', 'model=$model'].join(',');
    return 'CountTokensRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.CountTokens`.
final class CountTokensResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CountTokensResponse';

  /// The total number of tokens counted across all instances from the request.
  final int totalTokens;

  /// The total number of billable characters counted across all instances from
  /// the request.
  final int totalBillableCharacters;

  /// Output only. List of modalities that were processed in the request input.
  final List<ModalityTokenCount> promptTokensDetails;

  CountTokensResponse({
    this.totalTokens = 0,
    this.totalBillableCharacters = 0,
    this.promptTokensDetails = const [],
  }) : super(fullyQualifiedName);

  factory CountTokensResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CountTokensResponse(
      totalTokens: switch (json['totalTokens']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      totalBillableCharacters: switch (json['totalBillableCharacters']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      promptTokensDetails: switch (json['promptTokensDetails']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModalityTokenCount.fromJson(i),
        ],
        _ => throw const FormatException('"promptTokensDetails" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (totalTokens.isNotDefault) 'totalTokens': totalTokens,
    if (totalBillableCharacters.isNotDefault)
      'totalBillableCharacters': totalBillableCharacters,
    if (promptTokensDetails.isNotDefault)
      'promptTokensDetails': encodeList(promptTokensDetails),
  };

  @override
  String toString() {
    final contents = [
      'totalTokens=$totalTokens',
      'totalBillableCharacters=$totalBillableCharacters',
    ].join(',');
    return 'CountTokensResponse($contents)';
  }
}

/// Request message for [PredictionService.GenerateContent].
final class GenerateContentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateContentRequest';

  /// Required. The fully qualified name of the publisher model or tuned model
  /// endpoint to use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers/*/models/*`
  ///
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String model;

  /// Required. The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn queries,
  /// this is a repeated field that contains conversation history + latest
  /// request.
  final List<Content> contents;

  /// Optional. The user provided system instructions for the model.
  /// Note: only text should be used in parts and content in each part will be in
  /// a separate paragraph.
  final Content? systemInstruction;

  /// Optional. The name of the cached content used as context to serve the
  /// prediction. Note: only used in explicit caching, where users can have
  /// control over caching (e.g. what content to cache) and enjoy guaranteed cost
  /// savings. Format:
  /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
  final String cachedContent;

  /// Optional. A list of `Tools` the model may use to generate the next
  /// response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  final List<Tool> tools;

  /// Optional. Tool config. This config is shared for all tools provided in the
  /// request.
  final ToolConfig? toolConfig;

  /// Optional. The labels with user-defined metadata for the request. It is used
  /// for billing and reporting only.
  ///
  /// Label keys and values can be no longer than 63 characters
  /// (Unicode codepoints) and can only contain lowercase letters, numeric
  /// characters, underscores, and dashes. International characters are allowed.
  /// Label values are optional. Label keys must start with a letter.
  final Map<String, String> labels;

  /// Optional. Per request settings for blocking unsafe content.
  /// Enforced on GenerateContentResponse.candidates.
  final List<SafetySetting> safetySettings;

  /// Optional. Settings for prompt and response sanitization using the Model
  /// Armor service. If supplied, safety_settings must not be supplied.
  final ModelArmorConfig? modelArmorConfig;

  /// Optional. Generation config.
  final GenerationConfig? generationConfig;

  GenerateContentRequest({
    required this.model,
    required this.contents,
    this.systemInstruction,
    this.cachedContent = '',
    this.tools = const [],
    this.toolConfig,
    this.labels = const {},
    this.safetySettings = const [],
    this.modelArmorConfig,
    this.generationConfig,
  }) : super(fullyQualifiedName);

  factory GenerateContentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateContentRequest(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
      systemInstruction: switch (json['systemInstruction']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
      cachedContent: switch (json['cachedContent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tools: switch (json['tools']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tool.fromJson(i)],
        _ => throw const FormatException('"tools" is not a list'),
      },
      toolConfig: switch (json['toolConfig']) {
        null => null,
        Object $1 => ToolConfig.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      safetySettings: switch (json['safetySettings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SafetySetting.fromJson(i)],
        _ => throw const FormatException('"safetySettings" is not a list'),
      },
      modelArmorConfig: switch (json['modelArmorConfig']) {
        null => null,
        Object $1 => ModelArmorConfig.fromJson($1),
      },
      generationConfig: switch (json['generationConfig']) {
        null => null,
        Object $1 => GenerationConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'model': model,
    'contents': encodeList(contents),
    if (systemInstruction != null)
      'systemInstruction': systemInstruction!.toJson(),
    if (cachedContent.isNotDefault) 'cachedContent': cachedContent,
    if (tools.isNotDefault) 'tools': encodeList(tools),
    if (toolConfig != null) 'toolConfig': toolConfig!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (safetySettings.isNotDefault)
      'safetySettings': encodeList(safetySettings),
    if (modelArmorConfig != null)
      'modelArmorConfig': modelArmorConfig!.toJson(),
    if (generationConfig != null)
      'generationConfig': generationConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['model=$model', 'cachedContent=$cachedContent'].join(',');
    return 'GenerateContentRequest($contents)';
  }
}

/// Response message for [PredictionService.GenerateContent].
final class GenerateContentResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateContentResponse';

  /// Output only. Generated candidates.
  final List<Candidate> candidates;

  /// Output only. The model version used to generate the response.
  final String modelVersion;

  /// Output only. Timestamp when the request is made to the server.
  final protobuf.Timestamp? createTime;

  /// Output only. response_id is used to identify each response. It is the
  /// encoding of the event_id.
  final String responseId;

  /// Output only. Content filter results for a prompt sent in the request.
  /// Note: Sent only in the first stream chunk.
  /// Only happens when no candidates were generated due to content violations.
  final GenerateContentResponse_PromptFeedback? promptFeedback;

  /// Usage metadata about the response(s).
  final GenerateContentResponse_UsageMetadata? usageMetadata;

  GenerateContentResponse({
    this.candidates = const [],
    this.modelVersion = '',
    this.createTime,
    this.responseId = '',
    this.promptFeedback,
    this.usageMetadata,
  }) : super(fullyQualifiedName);

  factory GenerateContentResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateContentResponse(
      candidates: switch (json['candidates']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Candidate.fromJson(i)],
        _ => throw const FormatException('"candidates" is not a list'),
      },
      modelVersion: switch (json['modelVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      responseId: switch (json['responseId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      promptFeedback: switch (json['promptFeedback']) {
        null => null,
        Object $1 => GenerateContentResponse_PromptFeedback.fromJson($1),
      },
      usageMetadata: switch (json['usageMetadata']) {
        null => null,
        Object $1 => GenerateContentResponse_UsageMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (candidates.isNotDefault) 'candidates': encodeList(candidates),
    if (modelVersion.isNotDefault) 'modelVersion': modelVersion,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (responseId.isNotDefault) 'responseId': responseId,
    if (promptFeedback != null) 'promptFeedback': promptFeedback!.toJson(),
    if (usageMetadata != null) 'usageMetadata': usageMetadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'modelVersion=$modelVersion',
      'responseId=$responseId',
    ].join(',');
    return 'GenerateContentResponse($contents)';
  }
}

/// Content filter results for a prompt sent in the request.
final class GenerateContentResponse_PromptFeedback extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateContentResponse.PromptFeedback';

  /// Output only. Blocked reason.
  final GenerateContentResponse_PromptFeedback_BlockedReason blockReason;

  /// Output only. Safety ratings.
  final List<SafetyRating> safetyRatings;

  /// Output only. A readable block reason message.
  final String blockReasonMessage;

  GenerateContentResponse_PromptFeedback({
    this.blockReason =
        GenerateContentResponse_PromptFeedback_BlockedReason.$default,
    this.safetyRatings = const [],
    this.blockReasonMessage = '',
  }) : super(fullyQualifiedName);

  factory GenerateContentResponse_PromptFeedback.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateContentResponse_PromptFeedback(
      blockReason: switch (json['blockReason']) {
        null => GenerateContentResponse_PromptFeedback_BlockedReason.$default,
        Object $1 =>
          GenerateContentResponse_PromptFeedback_BlockedReason.fromJson($1),
      },
      safetyRatings: switch (json['safetyRatings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SafetyRating.fromJson(i)],
        _ => throw const FormatException('"safetyRatings" is not a list'),
      },
      blockReasonMessage: switch (json['blockReasonMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (blockReason.isNotDefault) 'blockReason': blockReason.toJson(),
    if (safetyRatings.isNotDefault) 'safetyRatings': encodeList(safetyRatings),
    if (blockReasonMessage.isNotDefault)
      'blockReasonMessage': blockReasonMessage,
  };

  @override
  String toString() {
    final contents = [
      'blockReason=$blockReason',
      'blockReasonMessage=$blockReasonMessage',
    ].join(',');
    return 'PromptFeedback($contents)';
  }
}

/// Blocked reason enumeration.
final class GenerateContentResponse_PromptFeedback_BlockedReason
    extends ProtoEnum {
  /// Unspecified blocked reason.
  static const blockedReasonUnspecified =
      GenerateContentResponse_PromptFeedback_BlockedReason(
        'BLOCKED_REASON_UNSPECIFIED',
      );

  /// Candidates blocked due to safety.
  static const safety = GenerateContentResponse_PromptFeedback_BlockedReason(
    'SAFETY',
  );

  /// Candidates blocked due to other reason.
  static const other = GenerateContentResponse_PromptFeedback_BlockedReason(
    'OTHER',
  );

  /// Candidates blocked due to the terms which are included from the
  /// terminology blocklist.
  static const blocklist = GenerateContentResponse_PromptFeedback_BlockedReason(
    'BLOCKLIST',
  );

  /// Candidates blocked due to prohibited content.
  static const prohibitedContent =
      GenerateContentResponse_PromptFeedback_BlockedReason(
        'PROHIBITED_CONTENT',
      );

  /// The user prompt was blocked by Model Armor.
  static const modelArmor =
      GenerateContentResponse_PromptFeedback_BlockedReason('MODEL_ARMOR');

  /// The default value for [GenerateContentResponse_PromptFeedback_BlockedReason].
  static const $default = blockedReasonUnspecified;

  const GenerateContentResponse_PromptFeedback_BlockedReason(super.value);

  factory GenerateContentResponse_PromptFeedback_BlockedReason.fromJson(
    Object? json,
  ) => GenerateContentResponse_PromptFeedback_BlockedReason(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'BlockedReason.$value';
}

/// Usage metadata about response(s).
final class GenerateContentResponse_UsageMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateContentResponse.UsageMetadata';

  /// Number of tokens in the request. When `cached_content` is set, this is
  /// still the total effective prompt size meaning this includes the number of
  /// tokens in the cached content.
  final int promptTokenCount;

  /// Number of tokens in the response(s).
  final int candidatesTokenCount;

  /// Output only. Number of tokens present in thoughts output.
  final int thoughtsTokenCount;

  /// Total token count for prompt and response candidates.
  final int totalTokenCount;

  /// Output only. Number of tokens in the cached part in the input (the cached
  /// content).
  final int cachedContentTokenCount;

  /// Output only. List of modalities that were processed in the request input.
  final List<ModalityTokenCount> promptTokensDetails;

  /// Output only. List of modalities of the cached content in the request
  /// input.
  final List<ModalityTokenCount> cacheTokensDetails;

  /// Output only. List of modalities that were returned in the response.
  final List<ModalityTokenCount> candidatesTokensDetails;

  GenerateContentResponse_UsageMetadata({
    this.promptTokenCount = 0,
    this.candidatesTokenCount = 0,
    this.thoughtsTokenCount = 0,
    this.totalTokenCount = 0,
    this.cachedContentTokenCount = 0,
    this.promptTokensDetails = const [],
    this.cacheTokensDetails = const [],
    this.candidatesTokensDetails = const [],
  }) : super(fullyQualifiedName);

  factory GenerateContentResponse_UsageMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateContentResponse_UsageMetadata(
      promptTokenCount: switch (json['promptTokenCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      candidatesTokenCount: switch (json['candidatesTokenCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      thoughtsTokenCount: switch (json['thoughtsTokenCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      totalTokenCount: switch (json['totalTokenCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      cachedContentTokenCount: switch (json['cachedContentTokenCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      promptTokensDetails: switch (json['promptTokensDetails']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModalityTokenCount.fromJson(i),
        ],
        _ => throw const FormatException('"promptTokensDetails" is not a list'),
      },
      cacheTokensDetails: switch (json['cacheTokensDetails']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModalityTokenCount.fromJson(i),
        ],
        _ => throw const FormatException('"cacheTokensDetails" is not a list'),
      },
      candidatesTokensDetails: switch (json['candidatesTokensDetails']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ModalityTokenCount.fromJson(i),
        ],
        _ => throw const FormatException(
          '"candidatesTokensDetails" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (promptTokenCount.isNotDefault) 'promptTokenCount': promptTokenCount,
    if (candidatesTokenCount.isNotDefault)
      'candidatesTokenCount': candidatesTokenCount,
    if (thoughtsTokenCount.isNotDefault)
      'thoughtsTokenCount': thoughtsTokenCount,
    if (totalTokenCount.isNotDefault) 'totalTokenCount': totalTokenCount,
    if (cachedContentTokenCount.isNotDefault)
      'cachedContentTokenCount': cachedContentTokenCount,
    if (promptTokensDetails.isNotDefault)
      'promptTokensDetails': encodeList(promptTokensDetails),
    if (cacheTokensDetails.isNotDefault)
      'cacheTokensDetails': encodeList(cacheTokensDetails),
    if (candidatesTokensDetails.isNotDefault)
      'candidatesTokensDetails': encodeList(candidatesTokensDetails),
  };

  @override
  String toString() {
    final contents = [
      'promptTokenCount=$promptTokenCount',
      'candidatesTokenCount=$candidatesTokenCount',
      'thoughtsTokenCount=$thoughtsTokenCount',
      'totalTokenCount=$totalTokenCount',
      'cachedContentTokenCount=$cachedContentTokenCount',
    ].join(',');
    return 'UsageMetadata($contents)';
  }
}

/// Request message for [PredictionService.ChatCompletions]
final class ChatCompletionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ChatCompletionsRequest';

  /// Required. The name of the endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Optional. The prediction input. Supports HTTP headers and arbitrary data
  /// payload.
  final HttpBody? httpBody;

  ChatCompletionsRequest({required this.endpoint, this.httpBody})
    : super(fullyQualifiedName);

  factory ChatCompletionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ChatCompletionsRequest(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      httpBody: switch (json['httpBody']) {
        null => null,
        Object $1 => HttpBody.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (httpBody != null) 'httpBody': httpBody!.toJson(),
  };

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'ChatCompletionsRequest($contents)';
  }
}

/// Response message for [PredictionService.PredictLongRunning]
final class PredictLongRunningResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictLongRunningResponse';

  /// The response of the video generation prediction.
  final GenerateVideoResponse? generateVideoResponse;

  PredictLongRunningResponse({this.generateVideoResponse})
    : super(fullyQualifiedName);

  factory PredictLongRunningResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PredictLongRunningResponse(
      generateVideoResponse: switch (json['generateVideoResponse']) {
        null => null,
        Object $1 => GenerateVideoResponse.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (generateVideoResponse != null)
      'generateVideoResponse': generateVideoResponse!.toJson(),
  };

  @override
  String toString() => 'PredictLongRunningResponse()';
}

/// Metadata for PredictLongRunning long running operations.
final class PredictLongRunningMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictLongRunningMetadata';

  PredictLongRunningMetadata() : super(fullyQualifiedName);

  factory PredictLongRunningMetadata.fromJson(Object? j) =>
      PredictLongRunningMetadata();

  @override
  Object toJson() => {};

  @override
  String toString() => 'PredictLongRunningMetadata()';
}

/// Generate video response.
final class GenerateVideoResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateVideoResponse';

  /// The cloud storage uris of the generated videos.
  final List<String> generatedSamples;

  /// Returns if any videos were filtered due to RAI policies.
  final int? raiMediaFilteredCount;

  /// Returns rai failure reasons if any.
  final List<String> raiMediaFilteredReasons;

  GenerateVideoResponse({
    this.generatedSamples = const [],
    this.raiMediaFilteredCount,
    this.raiMediaFilteredReasons = const [],
  }) : super(fullyQualifiedName);

  factory GenerateVideoResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateVideoResponse(
      generatedSamples: switch (json['generatedSamples']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"generatedSamples" is not a list'),
      },
      raiMediaFilteredCount: switch (json['raiMediaFilteredCount']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      raiMediaFilteredReasons: switch (json['raiMediaFilteredReasons']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"raiMediaFilteredReasons" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (generatedSamples.isNotDefault) 'generatedSamples': generatedSamples,
    if (raiMediaFilteredCount != null)
      'raiMediaFilteredCount': raiMediaFilteredCount,
    if (raiMediaFilteredReasons.isNotDefault)
      'raiMediaFilteredReasons': raiMediaFilteredReasons,
  };

  @override
  String toString() {
    final contents = [
      if (raiMediaFilteredCount != null)
        'raiMediaFilteredCount=$raiMediaFilteredCount',
    ].join(',');
    return 'GenerateVideoResponse($contents)';
  }
}

/// A Model Garden Publisher Model.
final class PublisherModel extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel';

  /// Output only. The resource name of the PublisherModel.
  final String name;

  /// Output only. Immutable. The version ID of the PublisherModel.
  /// A new version is committed when a new model version is uploaded under an
  /// existing model id. It is an auto-incrementing decimal number in string
  /// representation.
  final String versionId;

  /// Required. Indicates the open source category of the publisher model.
  final PublisherModel_OpenSourceCategory openSourceCategory;

  /// Optional. The parent that this model was customized from. E.g., Vision API,
  /// Natural Language API, LaMDA, T5, etc. Foundation models don't have parents.
  final PublisherModel_Parent? parent;

  /// Optional. Supported call-to-action options.
  final PublisherModel_CallToAction? supportedActions;

  /// Optional. Additional information about the model's Frameworks.
  final List<String> frameworks;

  /// Optional. Indicates the launch stage of the model.
  final PublisherModel_LaunchStage launchStage;

  /// Optional. Indicates the state of the model version.
  final PublisherModel_VersionState versionState;

  /// Optional. Output only. Immutable. Used to indicate this model has a
  /// publisher model and provide the template of the publisher model resource
  /// name.
  final String publisherModelTemplate;

  /// Optional. The schemata that describes formats of the PublisherModel's
  /// predictions and explanations as given and returned via
  /// `PredictionService.Predict`.
  final PredictSchemata? predictSchemata;

  PublisherModel({
    this.name = '',
    this.versionId = '',
    required this.openSourceCategory,
    this.parent,
    this.supportedActions,
    this.frameworks = const [],
    this.launchStage = PublisherModel_LaunchStage.$default,
    this.versionState = PublisherModel_VersionState.$default,
    this.publisherModelTemplate = '',
    this.predictSchemata,
  }) : super(fullyQualifiedName);

  factory PublisherModel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      versionId: switch (json['versionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      openSourceCategory: switch (json['openSourceCategory']) {
        null => PublisherModel_OpenSourceCategory.$default,
        Object $1 => PublisherModel_OpenSourceCategory.fromJson($1),
      },
      parent: switch (json['parent']) {
        null => null,
        Object $1 => PublisherModel_Parent.fromJson($1),
      },
      supportedActions: switch (json['supportedActions']) {
        null => null,
        Object $1 => PublisherModel_CallToAction.fromJson($1),
      },
      frameworks: switch (json['frameworks']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"frameworks" is not a list'),
      },
      launchStage: switch (json['launchStage']) {
        null => PublisherModel_LaunchStage.$default,
        Object $1 => PublisherModel_LaunchStage.fromJson($1),
      },
      versionState: switch (json['versionState']) {
        null => PublisherModel_VersionState.$default,
        Object $1 => PublisherModel_VersionState.fromJson($1),
      },
      publisherModelTemplate: switch (json['publisherModelTemplate']) {
        null => '',
        Object $1 => decodeString($1),
      },
      predictSchemata: switch (json['predictSchemata']) {
        null => null,
        Object $1 => PredictSchemata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (versionId.isNotDefault) 'versionId': versionId,
    'openSourceCategory': openSourceCategory.toJson(),
    if (parent != null) 'parent': parent!.toJson(),
    if (supportedActions != null)
      'supportedActions': supportedActions!.toJson(),
    if (frameworks.isNotDefault) 'frameworks': frameworks,
    if (launchStage.isNotDefault) 'launchStage': launchStage.toJson(),
    if (versionState.isNotDefault) 'versionState': versionState.toJson(),
    if (publisherModelTemplate.isNotDefault)
      'publisherModelTemplate': publisherModelTemplate,
    if (predictSchemata != null) 'predictSchemata': predictSchemata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'versionId=$versionId',
      'openSourceCategory=$openSourceCategory',
      'launchStage=$launchStage',
      'versionState=$versionState',
      'publisherModelTemplate=$publisherModelTemplate',
    ].join(',');
    return 'PublisherModel($contents)';
  }
}

/// Reference to a resource.
final class PublisherModel_ResourceReference extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.ResourceReference';

  /// The URI of the resource.
  final String? uri;

  /// The resource name of the Google Cloud resource.
  final String? resourceName;

  /// Use case (CUJ) of the resource.
  final String? useCase;

  /// Description of the resource.
  final String? description;

  PublisherModel_ResourceReference({
    this.uri,
    this.resourceName,
    this.useCase,
    this.description,
  }) : super(fullyQualifiedName);

  factory PublisherModel_ResourceReference.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_ResourceReference(
      uri: switch (json['uri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      resourceName: switch (json['resourceName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      useCase: switch (json['useCase']) {
        null => null,
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (uri != null) 'uri': uri,
    if (resourceName != null) 'resourceName': resourceName,
    if (useCase != null) 'useCase': useCase,
    if (description != null) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (resourceName != null) 'resourceName=$resourceName',
      if (useCase != null) 'useCase=$useCase',
      if (description != null) 'description=$description',
    ].join(',');
    return 'ResourceReference($contents)';
  }
}

/// The information about the parent of a model.
final class PublisherModel_Parent extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.Parent';

  /// Required. The display name of the parent. E.g., LaMDA, T5, Vision API,
  /// Natural Language API.
  final String displayName;

  /// Optional. The Google Cloud resource name or the URI reference.
  final PublisherModel_ResourceReference? reference;

  PublisherModel_Parent({required this.displayName, this.reference})
    : super(fullyQualifiedName);

  factory PublisherModel_Parent.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_Parent(
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      reference: switch (json['reference']) {
        null => null,
        Object $1 => PublisherModel_ResourceReference.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'displayName': displayName,
    if (reference != null) 'reference': reference!.toJson(),
  };

  @override
  String toString() {
    final contents = ['displayName=$displayName'].join(',');
    return 'Parent($contents)';
  }
}

/// A named piece of documentation.
final class PublisherModel_Documentation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.Documentation';

  /// Required. E.g., OVERVIEW, USE CASES, DOCUMENTATION, SDK & SAMPLES, JAVA,
  /// NODE.JS, etc..
  final String title;

  /// Required. Content of this piece of document (in Markdown format).
  final String content;

  PublisherModel_Documentation({required this.title, required this.content})
    : super(fullyQualifiedName);

  factory PublisherModel_Documentation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_Documentation(
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
      content: switch (json['content']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'title': title, 'content': content};

  @override
  String toString() {
    final contents = ['title=$title', 'content=$content'].join(',');
    return 'Documentation($contents)';
  }
}

/// Actions could take on this Publisher Model.
final class PublisherModel_CallToAction extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction';

  /// Optional. To view Rest API docs.
  final PublisherModel_CallToAction_ViewRestApi? viewRestApi;

  /// Optional. Open notebook of the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences? openNotebook;

  /// Optional. Open notebooks of the PublisherModel.
  final PublisherModel_CallToAction_OpenNotebooks? openNotebooks;

  /// Optional. Create application using the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  createApplication;

  /// Optional. Open fine-tuning pipeline of the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  openFineTuningPipeline;

  /// Optional. Open fine-tuning pipelines of the PublisherModel.
  final PublisherModel_CallToAction_OpenFineTuningPipelines?
  openFineTuningPipelines;

  /// Optional. Open prompt-tuning pipeline of the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  openPromptTuningPipeline;

  /// Optional. Open Genie / Playground.
  final PublisherModel_CallToAction_RegionalResourceReferences? openGenie;

  /// Optional. Deploy the PublisherModel to Vertex Endpoint.
  final PublisherModel_CallToAction_Deploy? deploy;

  /// Optional. Multiple setups to deploy the PublisherModel to Vertex
  /// Endpoint.
  final PublisherModel_CallToAction_DeployVertex? multiDeployVertex;

  /// Optional. Deploy PublisherModel to Google Kubernetes Engine.
  final PublisherModel_CallToAction_DeployGke? deployGke;

  /// Optional. Open in Generation AI Studio.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  openGenerationAiStudio;

  /// Optional. Request for access.
  final PublisherModel_CallToAction_RegionalResourceReferences? requestAccess;

  /// Optional. Open evaluation pipeline of the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  openEvaluationPipeline;

  PublisherModel_CallToAction({
    this.viewRestApi,
    this.openNotebook,
    this.openNotebooks,
    this.createApplication,
    this.openFineTuningPipeline,
    this.openFineTuningPipelines,
    this.openPromptTuningPipeline,
    this.openGenie,
    this.deploy,
    this.multiDeployVertex,
    this.deployGke,
    this.openGenerationAiStudio,
    this.requestAccess,
    this.openEvaluationPipeline,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction(
      viewRestApi: switch (json['viewRestApi']) {
        null => null,
        Object $1 => PublisherModel_CallToAction_ViewRestApi.fromJson($1),
      },
      openNotebook: switch (json['openNotebook']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_RegionalResourceReferences.fromJson($1),
      },
      openNotebooks: switch (json['openNotebooks']) {
        null => null,
        Object $1 => PublisherModel_CallToAction_OpenNotebooks.fromJson($1),
      },
      createApplication: switch (json['createApplication']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_RegionalResourceReferences.fromJson($1),
      },
      openFineTuningPipeline: switch (json['openFineTuningPipeline']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_RegionalResourceReferences.fromJson($1),
      },
      openFineTuningPipelines: switch (json['openFineTuningPipelines']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_OpenFineTuningPipelines.fromJson($1),
      },
      openPromptTuningPipeline: switch (json['openPromptTuningPipeline']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_RegionalResourceReferences.fromJson($1),
      },
      openGenie: switch (json['openGenie']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_RegionalResourceReferences.fromJson($1),
      },
      deploy: switch (json['deploy']) {
        null => null,
        Object $1 => PublisherModel_CallToAction_Deploy.fromJson($1),
      },
      multiDeployVertex: switch (json['multiDeployVertex']) {
        null => null,
        Object $1 => PublisherModel_CallToAction_DeployVertex.fromJson($1),
      },
      deployGke: switch (json['deployGke']) {
        null => null,
        Object $1 => PublisherModel_CallToAction_DeployGke.fromJson($1),
      },
      openGenerationAiStudio: switch (json['openGenerationAiStudio']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_RegionalResourceReferences.fromJson($1),
      },
      requestAccess: switch (json['requestAccess']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_RegionalResourceReferences.fromJson($1),
      },
      openEvaluationPipeline: switch (json['openEvaluationPipeline']) {
        null => null,
        Object $1 =>
          PublisherModel_CallToAction_RegionalResourceReferences.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (viewRestApi != null) 'viewRestApi': viewRestApi!.toJson(),
    if (openNotebook != null) 'openNotebook': openNotebook!.toJson(),
    if (openNotebooks != null) 'openNotebooks': openNotebooks!.toJson(),
    if (createApplication != null)
      'createApplication': createApplication!.toJson(),
    if (openFineTuningPipeline != null)
      'openFineTuningPipeline': openFineTuningPipeline!.toJson(),
    if (openFineTuningPipelines != null)
      'openFineTuningPipelines': openFineTuningPipelines!.toJson(),
    if (openPromptTuningPipeline != null)
      'openPromptTuningPipeline': openPromptTuningPipeline!.toJson(),
    if (openGenie != null) 'openGenie': openGenie!.toJson(),
    if (deploy != null) 'deploy': deploy!.toJson(),
    if (multiDeployVertex != null)
      'multiDeployVertex': multiDeployVertex!.toJson(),
    if (deployGke != null) 'deployGke': deployGke!.toJson(),
    if (openGenerationAiStudio != null)
      'openGenerationAiStudio': openGenerationAiStudio!.toJson(),
    if (requestAccess != null) 'requestAccess': requestAccess!.toJson(),
    if (openEvaluationPipeline != null)
      'openEvaluationPipeline': openEvaluationPipeline!.toJson(),
  };

  @override
  String toString() => 'CallToAction()';
}

/// The regional resource name or the URI. Key is region, e.g.,
/// us-central1, europe-west2, global, etc..
final class PublisherModel_CallToAction_RegionalResourceReferences
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.RegionalResourceReferences';

  /// Required.
  final Map<String, PublisherModel_ResourceReference> references;

  /// Required.
  final String title;

  /// Optional. Title of the resource.
  final String? resourceTitle;

  /// Optional. Use case (CUJ) of the resource.
  final String? resourceUseCase;

  /// Optional. Description of the resource.
  final String? resourceDescription;

  PublisherModel_CallToAction_RegionalResourceReferences({
    required this.references,
    required this.title,
    this.resourceTitle,
    this.resourceUseCase,
    this.resourceDescription,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_RegionalResourceReferences.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction_RegionalResourceReferences(
      references: switch (json['references']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): PublisherModel_ResourceReference.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"references" is not an object'),
      },
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
      resourceTitle: switch (json['resourceTitle']) {
        null => null,
        Object $1 => decodeString($1),
      },
      resourceUseCase: switch (json['resourceUseCase']) {
        null => null,
        Object $1 => decodeString($1),
      },
      resourceDescription: switch (json['resourceDescription']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'references': encodeMap(references),
    'title': title,
    if (resourceTitle != null) 'resourceTitle': resourceTitle,
    if (resourceUseCase != null) 'resourceUseCase': resourceUseCase,
    if (resourceDescription != null) 'resourceDescription': resourceDescription,
  };

  @override
  String toString() {
    final contents = [
      'title=$title',
      if (resourceTitle != null) 'resourceTitle=$resourceTitle',
      if (resourceUseCase != null) 'resourceUseCase=$resourceUseCase',
      if (resourceDescription != null)
        'resourceDescription=$resourceDescription',
    ].join(',');
    return 'RegionalResourceReferences($contents)';
  }
}

/// Rest API docs.
final class PublisherModel_CallToAction_ViewRestApi extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.ViewRestApi';

  /// Required.
  final List<PublisherModel_Documentation> documentations;

  /// Required. The title of the view rest API.
  final String title;

  PublisherModel_CallToAction_ViewRestApi({
    required this.documentations,
    required this.title,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_ViewRestApi.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction_ViewRestApi(
      documentations: switch (json['documentations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PublisherModel_Documentation.fromJson(i),
        ],
        _ => throw const FormatException('"documentations" is not a list'),
      },
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'documentations': encodeList(documentations),
    'title': title,
  };

  @override
  String toString() {
    final contents = ['title=$title'].join(',');
    return 'ViewRestApi($contents)';
  }
}

/// Open notebooks.
final class PublisherModel_CallToAction_OpenNotebooks extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.OpenNotebooks';

  /// Required. Regional resource references to notebooks.
  final List<PublisherModel_CallToAction_RegionalResourceReferences> notebooks;

  PublisherModel_CallToAction_OpenNotebooks({required this.notebooks})
    : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_OpenNotebooks.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction_OpenNotebooks(
      notebooks: switch (json['notebooks']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            PublisherModel_CallToAction_RegionalResourceReferences.fromJson(i),
        ],
        _ => throw const FormatException('"notebooks" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'notebooks': encodeList(notebooks)};

  @override
  String toString() => 'OpenNotebooks()';
}

/// Open fine tuning pipelines.
final class PublisherModel_CallToAction_OpenFineTuningPipelines
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.OpenFineTuningPipelines';

  /// Required. Regional resource references to fine tuning pipelines.
  final List<PublisherModel_CallToAction_RegionalResourceReferences>
  fineTuningPipelines;

  PublisherModel_CallToAction_OpenFineTuningPipelines({
    required this.fineTuningPipelines,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_OpenFineTuningPipelines.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction_OpenFineTuningPipelines(
      fineTuningPipelines: switch (json['fineTuningPipelines']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            PublisherModel_CallToAction_RegionalResourceReferences.fromJson(i),
        ],
        _ => throw const FormatException('"fineTuningPipelines" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'fineTuningPipelines': encodeList(fineTuningPipelines)};

  @override
  String toString() => 'OpenFineTuningPipelines()';
}

/// Multiple setups to deploy the PublisherModel.
final class PublisherModel_CallToAction_DeployVertex extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.DeployVertex';

  /// Optional. One click deployment configurations.
  final List<PublisherModel_CallToAction_Deploy> multiDeployVertex;

  PublisherModel_CallToAction_DeployVertex({this.multiDeployVertex = const []})
    : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_DeployVertex.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction_DeployVertex(
      multiDeployVertex: switch (json['multiDeployVertex']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PublisherModel_CallToAction_Deploy.fromJson(i),
        ],
        _ => throw const FormatException('"multiDeployVertex" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (multiDeployVertex.isNotDefault)
      'multiDeployVertex': encodeList(multiDeployVertex),
  };

  @override
  String toString() => 'DeployVertex()';
}

/// Model metadata that is needed for UploadModel or
/// DeployModel/CreateEndpoint requests.
final class PublisherModel_CallToAction_Deploy extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.Deploy';

  /// A description of resources that are dedicated to the DeployedModel,
  /// and that need a higher degree of manual configuration.
  final DedicatedResources? dedicatedResources;

  /// A description of resources that to large degree are decided by Vertex
  /// AI, and require only a modest additional configuration.
  final AutomaticResources? automaticResources;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String? sharedResources;

  /// Optional. Default model display name.
  final String modelDisplayName;

  /// Optional. Large model reference. When this is set, model_artifact_spec
  /// is not needed.
  final LargeModelReference? largeModelReference;

  /// Optional. The specification of the container that is to be used when
  /// deploying this Model in Vertex AI. Not present for Large Models.
  final ModelContainerSpec? containerSpec;

  /// Optional. The path to the directory containing the Model artifact and
  /// any of its supporting files.
  final String artifactUri;

  /// Optional. The name of the deploy task (e.g., "text to image
  /// generation").
  final String? deployTaskName;

  /// Optional. Metadata information about this deployment config.
  final PublisherModel_CallToAction_Deploy_DeployMetadata? deployMetadata;

  /// Required. The title of the regional resource reference.
  final String title;

  /// Optional. The signed URI for ephemeral Cloud Storage access to model
  /// artifact.
  final String publicArtifactUri;

  PublisherModel_CallToAction_Deploy({
    this.dedicatedResources,
    this.automaticResources,
    this.sharedResources,
    this.modelDisplayName = '',
    this.largeModelReference,
    this.containerSpec,
    this.artifactUri = '',
    this.deployTaskName,
    this.deployMetadata,
    required this.title,
    this.publicArtifactUri = '',
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_Deploy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction_Deploy(
      dedicatedResources: switch (json['dedicatedResources']) {
        null => null,
        Object $1 => DedicatedResources.fromJson($1),
      },
      automaticResources: switch (json['automaticResources']) {
        null => null,
        Object $1 => AutomaticResources.fromJson($1),
      },
      sharedResources: switch (json['sharedResources']) {
        null => null,
        Object $1 => decodeString($1),
      },
      modelDisplayName: switch (json['modelDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      largeModelReference: switch (json['largeModelReference']) {
        null => null,
        Object $1 => LargeModelReference.fromJson($1),
      },
      containerSpec: switch (json['containerSpec']) {
        null => null,
        Object $1 => ModelContainerSpec.fromJson($1),
      },
      artifactUri: switch (json['artifactUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deployTaskName: switch (json['deployTaskName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      deployMetadata: switch (json['deployMetadata']) {
        null => null,
        Object $1 => PublisherModel_CallToAction_Deploy_DeployMetadata.fromJson(
          $1,
        ),
      },
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
      publicArtifactUri: switch (json['publicArtifactUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dedicatedResources != null)
      'dedicatedResources': dedicatedResources!.toJson(),
    if (automaticResources != null)
      'automaticResources': automaticResources!.toJson(),
    if (sharedResources != null) 'sharedResources': sharedResources,
    if (modelDisplayName.isNotDefault) 'modelDisplayName': modelDisplayName,
    if (largeModelReference != null)
      'largeModelReference': largeModelReference!.toJson(),
    if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
    if (artifactUri.isNotDefault) 'artifactUri': artifactUri,
    if (deployTaskName != null) 'deployTaskName': deployTaskName,
    if (deployMetadata != null) 'deployMetadata': deployMetadata!.toJson(),
    'title': title,
    if (publicArtifactUri.isNotDefault) 'publicArtifactUri': publicArtifactUri,
  };

  @override
  String toString() {
    final contents = [
      if (sharedResources != null) 'sharedResources=$sharedResources',
      'modelDisplayName=$modelDisplayName',
      'artifactUri=$artifactUri',
      if (deployTaskName != null) 'deployTaskName=$deployTaskName',
      'title=$title',
      'publicArtifactUri=$publicArtifactUri',
    ].join(',');
    return 'Deploy($contents)';
  }
}

/// Metadata information about the deployment for managing deployment
/// config.
final class PublisherModel_CallToAction_Deploy_DeployMetadata
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.Deploy.DeployMetadata';

  /// Optional. Labels for the deployment config. For managing deployment
  /// config like verifying, source of deployment config, etc.
  final Map<String, String> labels;

  /// Optional. Sample request for deployed endpoint.
  final String sampleRequest;

  PublisherModel_CallToAction_Deploy_DeployMetadata({
    this.labels = const {},
    this.sampleRequest = '',
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_Deploy_DeployMetadata.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction_Deploy_DeployMetadata(
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      sampleRequest: switch (json['sampleRequest']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (labels.isNotDefault) 'labels': labels,
    if (sampleRequest.isNotDefault) 'sampleRequest': sampleRequest,
  };

  @override
  String toString() {
    final contents = ['sampleRequest=$sampleRequest'].join(',');
    return 'DeployMetadata($contents)';
  }
}

/// Configurations for PublisherModel GKE deployment
final class PublisherModel_CallToAction_DeployGke extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.DeployGke';

  /// Optional. GKE deployment configuration in yaml format.
  final List<String> gkeYamlConfigs;

  PublisherModel_CallToAction_DeployGke({this.gkeYamlConfigs = const []})
    : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_DeployGke.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PublisherModel_CallToAction_DeployGke(
      gkeYamlConfigs: switch (json['gkeYamlConfigs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"gkeYamlConfigs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (gkeYamlConfigs.isNotDefault) 'gkeYamlConfigs': gkeYamlConfigs,
  };

  @override
  String toString() => 'DeployGke()';
}

/// An enum representing the open source category of a PublisherModel.
final class PublisherModel_OpenSourceCategory extends ProtoEnum {
  /// The open source category is unspecified, which should not be used.
  static const openSourceCategoryUnspecified =
      PublisherModel_OpenSourceCategory('OPEN_SOURCE_CATEGORY_UNSPECIFIED');

  /// Used to indicate the PublisherModel is not open sourced.
  static const proprietary = PublisherModel_OpenSourceCategory('PROPRIETARY');

  /// Used to indicate the PublisherModel is a Google-owned open source model
  /// w/ Google checkpoint.
  static const googleOwnedOssWithGoogleCheckpoint =
      PublisherModel_OpenSourceCategory(
        'GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT',
      );

  /// Used to indicate the PublisherModel is a 3p-owned open source model w/
  /// Google checkpoint.
  static const thirdPartyOwnedOssWithGoogleCheckpoint =
      PublisherModel_OpenSourceCategory(
        'THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT',
      );

  /// Used to indicate the PublisherModel is a Google-owned pure open source
  /// model.
  static const googleOwnedOss = PublisherModel_OpenSourceCategory(
    'GOOGLE_OWNED_OSS',
  );

  /// Used to indicate the PublisherModel is a 3p-owned pure open source model.
  static const thirdPartyOwnedOss = PublisherModel_OpenSourceCategory(
    'THIRD_PARTY_OWNED_OSS',
  );

  /// The default value for [PublisherModel_OpenSourceCategory].
  static const $default = openSourceCategoryUnspecified;

  const PublisherModel_OpenSourceCategory(super.value);

  factory PublisherModel_OpenSourceCategory.fromJson(Object? json) =>
      PublisherModel_OpenSourceCategory(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'OpenSourceCategory.$value';
}

/// An enum representing the launch stage of a PublisherModel.
final class PublisherModel_LaunchStage extends ProtoEnum {
  /// The model launch stage is unspecified.
  static const launchStageUnspecified = PublisherModel_LaunchStage(
    'LAUNCH_STAGE_UNSPECIFIED',
  );

  /// Used to indicate the PublisherModel is at Experimental launch stage,
  /// available to a small set of customers.
  static const experimental = PublisherModel_LaunchStage('EXPERIMENTAL');

  /// Used to indicate the PublisherModel is at Private Preview launch stage,
  /// only available to a small set of customers, although a larger set of
  /// customers than an Experimental launch. Previews are the first launch
  /// stage used to get feedback from customers.
  static const privatePreview = PublisherModel_LaunchStage('PRIVATE_PREVIEW');

  /// Used to indicate the PublisherModel is at Public Preview launch stage,
  /// available to all customers, although not supported for production
  /// workloads.
  static const publicPreview = PublisherModel_LaunchStage('PUBLIC_PREVIEW');

  /// Used to indicate the PublisherModel is at GA launch stage, available to
  /// all customers and ready for production workload.
  static const ga = PublisherModel_LaunchStage('GA');

  /// The default value for [PublisherModel_LaunchStage].
  static const $default = launchStageUnspecified;

  const PublisherModel_LaunchStage(super.value);

  factory PublisherModel_LaunchStage.fromJson(Object? json) =>
      PublisherModel_LaunchStage(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'LaunchStage.$value';
}

/// An enum representing the state of the PublicModelVersion.
final class PublisherModel_VersionState extends ProtoEnum {
  /// The version state is unspecified.
  static const versionStateUnspecified = PublisherModel_VersionState(
    'VERSION_STATE_UNSPECIFIED',
  );

  /// Used to indicate the version is stable.
  static const versionStateStable = PublisherModel_VersionState(
    'VERSION_STATE_STABLE',
  );

  /// Used to indicate the version is unstable.
  static const versionStateUnstable = PublisherModel_VersionState(
    'VERSION_STATE_UNSTABLE',
  );

  /// The default value for [PublisherModel_VersionState].
  static const $default = versionStateUnspecified;

  const PublisherModel_VersionState(super.value);

  factory PublisherModel_VersionState.fromJson(Object? json) =>
      PublisherModel_VersionState(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'VersionState.$value';
}

/// ReasoningEngine configurations
final class ReasoningEngineSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec';

  /// Deploy from source code files with a defined entrypoint.
  final ReasoningEngineSpec_SourceCodeSpec? sourceCodeSpec;

  /// Optional. The service account that the Reasoning Engine artifact runs as.
  /// It should have "roles/storage.objectViewer" for reading the user project's
  /// Cloud Storage and "roles/aiplatform.user" for using Vertex extensions. If
  /// not specified, the Vertex AI Reasoning Engine Service Agent in the project
  /// will be used.
  final String? serviceAccount;

  /// Optional. User provided package spec of the ReasoningEngine.
  /// Ignored when users directly specify a deployment image through
  /// `deployment_spec.first_party_image_override`, but keeping the
  /// field_behavior to avoid introducing breaking changes.
  /// The `deployment_source` field should not be set if `package_spec` is
  /// specified.
  final ReasoningEngineSpec_PackageSpec? packageSpec;

  /// Optional. The specification of a Reasoning Engine deployment.
  final ReasoningEngineSpec_DeploymentSpec? deploymentSpec;

  /// Optional. Declarations for object class methods in OpenAPI specification
  /// format.
  final List<protobuf.Struct> classMethods;

  /// Optional. The OSS agent framework used to develop the agent.
  /// Currently supported values: "google-adk", "langchain", "langgraph", "ag2",
  /// "llama-index", "custom".
  final String agentFramework;

  ReasoningEngineSpec({
    this.sourceCodeSpec,
    this.serviceAccount,
    this.packageSpec,
    this.deploymentSpec,
    this.classMethods = const [],
    this.agentFramework = '',
  }) : super(fullyQualifiedName);

  factory ReasoningEngineSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineSpec(
      sourceCodeSpec: switch (json['sourceCodeSpec']) {
        null => null,
        Object $1 => ReasoningEngineSpec_SourceCodeSpec.fromJson($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => null,
        Object $1 => decodeString($1),
      },
      packageSpec: switch (json['packageSpec']) {
        null => null,
        Object $1 => ReasoningEngineSpec_PackageSpec.fromJson($1),
      },
      deploymentSpec: switch (json['deploymentSpec']) {
        null => null,
        Object $1 => ReasoningEngineSpec_DeploymentSpec.fromJson($1),
      },
      classMethods: switch (json['classMethods']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) protobuf.Struct.fromJson(i)],
        _ => throw const FormatException('"classMethods" is not a list'),
      },
      agentFramework: switch (json['agentFramework']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sourceCodeSpec != null) 'sourceCodeSpec': sourceCodeSpec!.toJson(),
    if (serviceAccount != null) 'serviceAccount': serviceAccount,
    if (packageSpec != null) 'packageSpec': packageSpec!.toJson(),
    if (deploymentSpec != null) 'deploymentSpec': deploymentSpec!.toJson(),
    if (classMethods.isNotDefault) 'classMethods': encodeList(classMethods),
    if (agentFramework.isNotDefault) 'agentFramework': agentFramework,
  };

  @override
  String toString() {
    final contents = [
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      'agentFramework=$agentFramework',
    ].join(',');
    return 'ReasoningEngineSpec($contents)';
  }
}

/// User-provided package specification, containing pickled object and package
/// requirements.
final class ReasoningEngineSpec_PackageSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.PackageSpec';

  /// Optional. The Cloud Storage URI of the pickled python object.
  final String pickleObjectGcsUri;

  /// Optional. The Cloud Storage URI of the dependency files in tar.gz format.
  final String dependencyFilesGcsUri;

  /// Optional. The Cloud Storage URI of the `requirements.txt` file
  final String requirementsGcsUri;

  /// Optional. The Python version. Currently support 3.8, 3.9, 3.10, 3.11.
  /// If not specified, default value is 3.10.
  final String pythonVersion;

  ReasoningEngineSpec_PackageSpec({
    this.pickleObjectGcsUri = '',
    this.dependencyFilesGcsUri = '',
    this.requirementsGcsUri = '',
    this.pythonVersion = '',
  }) : super(fullyQualifiedName);

  factory ReasoningEngineSpec_PackageSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineSpec_PackageSpec(
      pickleObjectGcsUri: switch (json['pickleObjectGcsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dependencyFilesGcsUri: switch (json['dependencyFilesGcsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requirementsGcsUri: switch (json['requirementsGcsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pythonVersion: switch (json['pythonVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (pickleObjectGcsUri.isNotDefault)
      'pickleObjectGcsUri': pickleObjectGcsUri,
    if (dependencyFilesGcsUri.isNotDefault)
      'dependencyFilesGcsUri': dependencyFilesGcsUri,
    if (requirementsGcsUri.isNotDefault)
      'requirementsGcsUri': requirementsGcsUri,
    if (pythonVersion.isNotDefault) 'pythonVersion': pythonVersion,
  };

  @override
  String toString() {
    final contents = [
      'pickleObjectGcsUri=$pickleObjectGcsUri',
      'dependencyFilesGcsUri=$dependencyFilesGcsUri',
      'requirementsGcsUri=$requirementsGcsUri',
      'pythonVersion=$pythonVersion',
    ].join(',');
    return 'PackageSpec($contents)';
  }
}

/// The specification of a Reasoning Engine deployment.
final class ReasoningEngineSpec_DeploymentSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.DeploymentSpec';

  /// Optional. Environment variables to be set with the Reasoning Engine
  /// deployment. The environment variables can be updated through the
  /// UpdateReasoningEngine API.
  final List<EnvVar> env;

  /// Optional. Environment variables where the value is a secret in Cloud
  /// Secret Manager.
  /// To use this feature, add 'Secret Manager Secret Accessor' role
  /// (roles/secretmanager.secretAccessor) to AI Platform Reasoning Engine
  /// Service Agent.
  final List<SecretEnvVar> secretEnv;

  /// Optional. Configuration for PSC-I.
  final PscInterfaceConfig? pscInterfaceConfig;

  /// Optional. The minimum number of application instances that will be kept
  /// running at all times. Defaults to 1. Range: [0, 10].
  final int? minInstances;

  /// Optional. The maximum number of application instances that can be
  /// launched to handle increased traffic. Defaults to 100. Range: [1, 1000].
  ///
  /// If VPC-SC or PSC-I is enabled, the acceptable range is [1, 100].
  final int? maxInstances;

  /// Optional. Resource limits for each container. Only 'cpu' and 'memory'
  /// keys are supported. Defaults to {"cpu": "4", "memory": "4Gi"}.
  ///
  ///   * The only supported values for CPU are '1', '2', '4', '6' and '8'. For
  ///   more information, go to
  ///   https://cloud.google.com/run/docs/configuring/cpu.
  ///   * The only supported values for memory are '1Gi', '2Gi', ... '32 Gi'.
  ///   * For required cpu on different memory values, go to
  ///   https://cloud.google.com/run/docs/configuring/memory-limits
  final Map<String, String> resourceLimits;

  /// Optional. Concurrency for each container and agent server. Recommended
  /// value: 2 * cpu + 1. Defaults to 9.
  final int? containerConcurrency;

  ReasoningEngineSpec_DeploymentSpec({
    this.env = const [],
    this.secretEnv = const [],
    this.pscInterfaceConfig,
    this.minInstances,
    this.maxInstances,
    this.resourceLimits = const {},
    this.containerConcurrency,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineSpec_DeploymentSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineSpec_DeploymentSpec(
      env: switch (json['env']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) EnvVar.fromJson(i)],
        _ => throw const FormatException('"env" is not a list'),
      },
      secretEnv: switch (json['secretEnv']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SecretEnvVar.fromJson(i)],
        _ => throw const FormatException('"secretEnv" is not a list'),
      },
      pscInterfaceConfig: switch (json['pscInterfaceConfig']) {
        null => null,
        Object $1 => PscInterfaceConfig.fromJson($1),
      },
      minInstances: switch (json['minInstances']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      maxInstances: switch (json['maxInstances']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      resourceLimits: switch (json['resourceLimits']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"resourceLimits" is not an object'),
      },
      containerConcurrency: switch (json['containerConcurrency']) {
        null => null,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (env.isNotDefault) 'env': encodeList(env),
    if (secretEnv.isNotDefault) 'secretEnv': encodeList(secretEnv),
    if (pscInterfaceConfig != null)
      'pscInterfaceConfig': pscInterfaceConfig!.toJson(),
    if (minInstances != null) 'minInstances': minInstances,
    if (maxInstances != null) 'maxInstances': maxInstances,
    if (resourceLimits.isNotDefault) 'resourceLimits': resourceLimits,
    if (containerConcurrency != null)
      'containerConcurrency': containerConcurrency,
  };

  @override
  String toString() {
    final contents = [
      if (minInstances != null) 'minInstances=$minInstances',
      if (maxInstances != null) 'maxInstances=$maxInstances',
      if (containerConcurrency != null)
        'containerConcurrency=$containerConcurrency',
    ].join(',');
    return 'DeploymentSpec($contents)';
  }
}

/// Specification for deploying from source code.
final class ReasoningEngineSpec_SourceCodeSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.SourceCodeSpec';

  /// Source code is provided directly in the request.
  final ReasoningEngineSpec_SourceCodeSpec_InlineSource? inlineSource;

  /// Configuration for a Python application.
  final ReasoningEngineSpec_SourceCodeSpec_PythonSpec? pythonSpec;

  ReasoningEngineSpec_SourceCodeSpec({this.inlineSource, this.pythonSpec})
    : super(fullyQualifiedName);

  factory ReasoningEngineSpec_SourceCodeSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineSpec_SourceCodeSpec(
      inlineSource: switch (json['inlineSource']) {
        null => null,
        Object $1 => ReasoningEngineSpec_SourceCodeSpec_InlineSource.fromJson(
          $1,
        ),
      },
      pythonSpec: switch (json['pythonSpec']) {
        null => null,
        Object $1 => ReasoningEngineSpec_SourceCodeSpec_PythonSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (inlineSource != null) 'inlineSource': inlineSource!.toJson(),
    if (pythonSpec != null) 'pythonSpec': pythonSpec!.toJson(),
  };

  @override
  String toString() => 'SourceCodeSpec()';
}

/// Specifies source code provided as a byte stream.
final class ReasoningEngineSpec_SourceCodeSpec_InlineSource
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.SourceCodeSpec.InlineSource';

  /// Required. Input only. The application source code archive, provided as
  /// a compressed tarball
  /// (.tar.gz) file.
  final Uint8List sourceArchive;

  ReasoningEngineSpec_SourceCodeSpec_InlineSource({required this.sourceArchive})
    : super(fullyQualifiedName);

  factory ReasoningEngineSpec_SourceCodeSpec_InlineSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineSpec_SourceCodeSpec_InlineSource(
      sourceArchive: switch (json['sourceArchive']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {'sourceArchive': encodeBytes(sourceArchive)};

  @override
  String toString() {
    final contents = ['sourceArchive=$sourceArchive'].join(',');
    return 'InlineSource($contents)';
  }
}

/// Specification for running a Python application from source.
final class ReasoningEngineSpec_SourceCodeSpec_PythonSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.SourceCodeSpec.PythonSpec';

  /// Optional. The version of Python to use. Support version
  /// includes 3.9, 3.10, 3.11, 3.12, 3.13.
  /// If not specified, default value is 3.10.
  final String version;

  /// Optional. The Python module to load as the entrypoint, specified as a
  /// fully qualified module name. For example: path.to.agent.
  /// If not specified, defaults to "agent".
  ///
  /// The project root will be added to Python sys.path, allowing imports
  /// to be specified relative to the root.
  final String entrypointModule;

  /// Optional. The name of the callable object within the
  /// `entrypoint_module` to use as the application If not specified,
  /// defaults to "root_agent".
  final String entrypointObject;

  /// Optional. The path to the requirements file, relative to the source
  /// root. If not specified, defaults to "requirements.txt".
  final String requirementsFile;

  ReasoningEngineSpec_SourceCodeSpec_PythonSpec({
    this.version = '',
    this.entrypointModule = '',
    this.entrypointObject = '',
    this.requirementsFile = '',
  }) : super(fullyQualifiedName);

  factory ReasoningEngineSpec_SourceCodeSpec_PythonSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineSpec_SourceCodeSpec_PythonSpec(
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entrypointModule: switch (json['entrypointModule']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entrypointObject: switch (json['entrypointObject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requirementsFile: switch (json['requirementsFile']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (version.isNotDefault) 'version': version,
    if (entrypointModule.isNotDefault) 'entrypointModule': entrypointModule,
    if (entrypointObject.isNotDefault) 'entrypointObject': entrypointObject,
    if (requirementsFile.isNotDefault) 'requirementsFile': requirementsFile,
  };

  @override
  String toString() {
    final contents = [
      'version=$version',
      'entrypointModule=$entrypointModule',
      'entrypointObject=$entrypointObject',
      'requirementsFile=$requirementsFile',
    ].join(',');
    return 'PythonSpec($contents)';
  }
}

/// ReasoningEngine provides a customizable runtime for models to determine
/// which actions to take and in which order.
final class ReasoningEngine extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngine';

  /// Identifier. The resource name of the ReasoningEngine.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  /// Required. The display name of the ReasoningEngine.
  final String displayName;

  /// Optional. The description of the ReasoningEngine.
  final String description;

  /// Optional. Configurations of the ReasoningEngine
  final ReasoningEngineSpec? spec;

  /// Output only. Timestamp when this ReasoningEngine was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ReasoningEngine was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String etag;

  /// Optional. Configuration for how Agent Engine sub-resources should manage
  /// context.
  final ReasoningEngineContextSpec? contextSpec;

  /// Customer-managed encryption key spec for a ReasoningEngine. If set, this
  /// ReasoningEngine and all sub-resources of this ReasoningEngine will be
  /// secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Labels for the ReasoningEngine.
  final Map<String, String> labels;

  ReasoningEngine({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.spec,
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.contextSpec,
    this.encryptionSpec,
    this.labels = const {},
  }) : super(fullyQualifiedName);

  factory ReasoningEngine.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngine(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      spec: switch (json['spec']) {
        null => null,
        Object $1 => ReasoningEngineSpec.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      contextSpec: switch (json['contextSpec']) {
        null => null,
        Object $1 => ReasoningEngineContextSpec.fromJson($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (spec != null) 'spec': spec!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (contextSpec != null) 'contextSpec': contextSpec!.toJson(),
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'etag=$etag',
    ].join(',');
    return 'ReasoningEngine($contents)';
  }
}

/// Configuration for how Agent Engine sub-resources should manage context.
final class ReasoningEngineContextSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec';

  /// Optional. Specification for a Memory Bank, which manages memories for the
  /// Agent Engine.
  final ReasoningEngineContextSpec_MemoryBankConfig? memoryBankConfig;

  ReasoningEngineContextSpec({this.memoryBankConfig})
    : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineContextSpec(
      memoryBankConfig: switch (json['memoryBankConfig']) {
        null => null,
        Object $1 => ReasoningEngineContextSpec_MemoryBankConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (memoryBankConfig != null)
      'memoryBankConfig': memoryBankConfig!.toJson(),
  };

  @override
  String toString() => 'ReasoningEngineContextSpec()';
}

/// Specification for a Memory Bank.
final class ReasoningEngineContextSpec_MemoryBankConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig';

  /// Optional. Configuration for how to generate memories for the Memory Bank.
  final ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig?
  generationConfig;

  /// Optional. Configuration for how to perform similarity search on memories.
  /// If not set, the Memory Bank will use the default embedding model
  /// `text-embedding-005`.
  final ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig?
  similaritySearchConfig;

  /// Optional. Configuration for automatic TTL ("time-to-live") of the
  /// memories in the Memory Bank. If not set, TTL will not be applied
  /// automatically. The TTL can be explicitly set by modifying the
  /// `expire_time` of each Memory resource.
  final ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig? ttlConfig;

  ReasoningEngineContextSpec_MemoryBankConfig({
    this.generationConfig,
    this.similaritySearchConfig,
    this.ttlConfig,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineContextSpec_MemoryBankConfig(
      generationConfig: switch (json['generationConfig']) {
        null => null,
        Object $1 =>
          ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig.fromJson(
            $1,
          ),
      },
      similaritySearchConfig: switch (json['similaritySearchConfig']) {
        null => null,
        Object $1 =>
          ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig.fromJson(
            $1,
          ),
      },
      ttlConfig: switch (json['ttlConfig']) {
        null => null,
        Object $1 =>
          ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (generationConfig != null)
      'generationConfig': generationConfig!.toJson(),
    if (similaritySearchConfig != null)
      'similaritySearchConfig': similaritySearchConfig!.toJson(),
    if (ttlConfig != null) 'ttlConfig': ttlConfig!.toJson(),
  };

  @override
  String toString() => 'MemoryBankConfig()';
}

/// Configuration for automatically setting the TTL ("time-to-live") of the
/// memories in the Memory Bank.
final class ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig.TtlConfig';

  /// Optional. The default TTL duration of the memories in the Memory
  /// Bank. This applies to all operations that create or update a memory.
  final protobuf.Duration? defaultTtl;

  /// Optional. The granular TTL configuration of the memories in the
  /// Memory Bank.
  final ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig?
  granularTtlConfig;

  ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig({
    this.defaultTtl,
    this.granularTtlConfig,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig(
      defaultTtl: switch (json['defaultTtl']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      granularTtlConfig: switch (json['granularTtlConfig']) {
        null => null,
        Object $1 =>
          ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig.fromJson(
            $1,
          ),
      },
    );
  }

  @override
  Object toJson() => {
    if (defaultTtl != null) 'defaultTtl': defaultTtl!.toJson(),
    if (granularTtlConfig != null)
      'granularTtlConfig': granularTtlConfig!.toJson(),
  };

  @override
  String toString() => 'TtlConfig()';
}

/// Configuration for TTL of the memories in the Memory Bank based on the
/// action that created or updated the memory.
final class ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig.TtlConfig.GranularTtlConfig';

  /// Optional. The TTL duration for memories uploaded via CreateMemory.
  final protobuf.Duration? createTtl;

  /// Optional. The TTL duration for memories newly generated via
  /// GenerateMemories
  /// (`GenerateMemoriesResponse.GeneratedMemory.Action.CREATED`).
  final protobuf.Duration? generateCreatedTtl;

  /// Optional. The TTL duration for memories updated via GenerateMemories
  /// (`GenerateMemoriesResponse.GeneratedMemory.Action.CREATED`).
  /// In the case of an UPDATE action, the `expire_time` of the existing
  /// memory will be updated to the new value (now + TTL).
  final protobuf.Duration? generateUpdatedTtl;

  ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig({
    this.createTtl,
    this.generateCreatedTtl,
    this.generateUpdatedTtl,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig(
      createTtl: switch (json['createTtl']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      generateCreatedTtl: switch (json['generateCreatedTtl']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      generateUpdatedTtl: switch (json['generateUpdatedTtl']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (createTtl != null) 'createTtl': createTtl!.toJson(),
    if (generateCreatedTtl != null)
      'generateCreatedTtl': generateCreatedTtl!.toJson(),
    if (generateUpdatedTtl != null)
      'generateUpdatedTtl': generateUpdatedTtl!.toJson(),
  };

  @override
  String toString() => 'GranularTtlConfig()';
}

/// Configuration for how to generate memories.
final class ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig.GenerationConfig';

  /// Required. The model used to generate memories.
  /// Format:
  /// `projects/{project}/locations/{location}/publishers/google/models/{model}`.
  final String model;

  ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig({
    required this.model,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'model': model};

  @override
  String toString() {
    final contents = ['model=$model'].join(',');
    return 'GenerationConfig($contents)';
  }
}

/// Configuration for how to perform similarity search on memories.
final class ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig.SimilaritySearchConfig';

  /// Required. The model used to generate embeddings to lookup similar
  /// memories. Format:
  /// `projects/{project}/locations/{location}/publishers/google/models/{model}`.
  final String embeddingModel;

  ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig({
    required this.embeddingModel,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig(
      embeddingModel: switch (json['embeddingModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'embeddingModel': embeddingModel};

  @override
  String toString() {
    final contents = ['embeddingModel=$embeddingModel'].join(',');
    return 'SimilaritySearchConfig($contents)';
  }
}

/// Request message for `ReasoningEngineExecutionService.Query`.
final class QueryReasoningEngineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryReasoningEngineRequest';

  /// Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  /// Optional. Input content provided by users in JSON object format. Examples
  /// include text query, function calling parameters, media bytes, etc.
  final protobuf.Struct? input;

  /// Optional. Class method to be used for the query.
  /// It is optional and defaults to "query" if unspecified.
  final String classMethod;

  QueryReasoningEngineRequest({
    required this.name,
    this.input,
    this.classMethod = '',
  }) : super(fullyQualifiedName);

  factory QueryReasoningEngineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryReasoningEngineRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      input: switch (json['input']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      classMethod: switch (json['classMethod']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (input != null) 'input': input!.toJson(),
    if (classMethod.isNotDefault) 'classMethod': classMethod,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'classMethod=$classMethod'].join(',');
    return 'QueryReasoningEngineRequest($contents)';
  }
}

/// Response message for `ReasoningEngineExecutionService.Query`
final class QueryReasoningEngineResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryReasoningEngineResponse';

  /// Response provided by users in JSON object format.
  final protobuf.Value? output;

  QueryReasoningEngineResponse({this.output}) : super(fullyQualifiedName);

  factory QueryReasoningEngineResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QueryReasoningEngineResponse(
      output: switch (json['output']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (output != null) 'output': output!.toJson()};

  @override
  String toString() => 'QueryReasoningEngineResponse()';
}

/// Request message for `ReasoningEngineExecutionService.StreamQuery`.
final class StreamQueryReasoningEngineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamQueryReasoningEngineRequest';

  /// Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  /// Optional. Input content provided by users in JSON object format. Examples
  /// include text query, function calling parameters, media bytes, etc.
  final protobuf.Struct? input;

  /// Optional. Class method to be used for the stream query.
  /// It is optional and defaults to "stream_query" if unspecified.
  final String classMethod;

  StreamQueryReasoningEngineRequest({
    required this.name,
    this.input,
    this.classMethod = '',
  }) : super(fullyQualifiedName);

  factory StreamQueryReasoningEngineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StreamQueryReasoningEngineRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      input: switch (json['input']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      classMethod: switch (json['classMethod']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (input != null) 'input': input!.toJson(),
    if (classMethod.isNotDefault) 'classMethod': classMethod,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'classMethod=$classMethod'].join(',');
    return 'StreamQueryReasoningEngineRequest($contents)';
  }
}

/// Request message for
/// `ReasoningEngineService.CreateReasoningEngine`.
final class CreateReasoningEngineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateReasoningEngineRequest';

  /// Required. The resource name of the Location to create the ReasoningEngine
  /// in. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The ReasoningEngine to create.
  final ReasoningEngine? reasoningEngine;

  CreateReasoningEngineRequest({
    required this.parent,
    required this.reasoningEngine,
  }) : super(fullyQualifiedName);

  factory CreateReasoningEngineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateReasoningEngineRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      reasoningEngine: switch (json['reasoningEngine']) {
        null => null,
        Object $1 => ReasoningEngine.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (reasoningEngine != null) 'reasoningEngine': reasoningEngine!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateReasoningEngineRequest($contents)';
  }
}

/// Details of
/// `ReasoningEngineService.CreateReasoningEngine`
/// operation.
final class CreateReasoningEngineOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateReasoningEngineOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateReasoningEngineOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateReasoningEngineOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateReasoningEngineOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateReasoningEngineOperationMetadata()';
}

/// Request message for
/// `ReasoningEngineService.GetReasoningEngine`.
final class GetReasoningEngineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetReasoningEngineRequest';

  /// Required. The name of the ReasoningEngine resource.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  GetReasoningEngineRequest({required this.name}) : super(fullyQualifiedName);

  factory GetReasoningEngineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetReasoningEngineRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetReasoningEngineRequest($contents)';
  }
}

/// Request message for
/// `ReasoningEngineService.UpdateReasoningEngine`.
final class UpdateReasoningEngineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateReasoningEngineRequest';

  /// Required. The ReasoningEngine which replaces the resource on the server.
  final ReasoningEngine? reasoningEngine;

  /// Optional. Mask specifying which fields to update.
  final protobuf.FieldMask? updateMask;

  UpdateReasoningEngineRequest({required this.reasoningEngine, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateReasoningEngineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateReasoningEngineRequest(
      reasoningEngine: switch (json['reasoningEngine']) {
        null => null,
        Object $1 => ReasoningEngine.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (reasoningEngine != null) 'reasoningEngine': reasoningEngine!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateReasoningEngineRequest()';
}

/// Details of
/// `ReasoningEngineService.UpdateReasoningEngine`
/// operation.
final class UpdateReasoningEngineOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateReasoningEngineOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UpdateReasoningEngineOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateReasoningEngineOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateReasoningEngineOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateReasoningEngineOperationMetadata()';
}

/// Request message for
/// `ReasoningEngineService.ListReasoningEngines`.
final class ListReasoningEnginesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListReasoningEnginesRequest';

  /// Required. The resource name of the Location to list the ReasoningEngines
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String filter;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  final String pageToken;

  ListReasoningEnginesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListReasoningEnginesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListReasoningEnginesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListReasoningEnginesRequest($contents)';
  }
}

/// Response message for
/// `ReasoningEngineService.ListReasoningEngines`
final class ListReasoningEnginesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListReasoningEnginesResponse';

  /// List of ReasoningEngines in the requested page.
  final List<ReasoningEngine> reasoningEngines;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListReasoningEnginesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListReasoningEnginesResponse({
    this.reasoningEngines = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListReasoningEnginesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListReasoningEnginesResponse(
      reasoningEngines: switch (json['reasoningEngines']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ReasoningEngine.fromJson(i)],
        _ => throw const FormatException('"reasoningEngines" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (reasoningEngines.isNotDefault)
      'reasoningEngines': encodeList(reasoningEngines),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListReasoningEnginesResponse($contents)';
  }
}

/// Request message for
/// `ReasoningEngineService.DeleteReasoningEngine`.
final class DeleteReasoningEngineRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteReasoningEngineRequest';

  /// Required. The name of the ReasoningEngine resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  /// Optional. If set to true, child resources of this reasoning engine will
  /// also be deleted. Otherwise, the request will fail with FAILED_PRECONDITION
  /// error when the reasoning engine has undeleted child resources.
  final bool force;

  DeleteReasoningEngineRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteReasoningEngineRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteReasoningEngineRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteReasoningEngineRequest($contents)';
  }
}

/// A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a
/// DeployedModel) to draw its Compute Engine resources from a Shared
/// Reservation, or exclusively from on-demand capacity.
final class ReservationAffinity extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReservationAffinity';

  /// Required. Specifies the reservation affinity type.
  final ReservationAffinity_Type reservationAffinityType;

  /// Optional. Corresponds to the label key of a reservation resource. To target
  /// a SPECIFIC_RESERVATION by name, use
  /// `compute.googleapis.com/reservation-name` as the key and specify the name
  /// of your reservation as its value.
  final String key;

  /// Optional. Corresponds to the label values of a reservation resource. This
  /// must be the full resource name of the reservation.
  final List<String> values;

  ReservationAffinity({
    required this.reservationAffinityType,
    this.key = '',
    this.values = const [],
  }) : super(fullyQualifiedName);

  factory ReservationAffinity.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReservationAffinity(
      reservationAffinityType: switch (json['reservationAffinityType']) {
        null => ReservationAffinity_Type.$default,
        Object $1 => ReservationAffinity_Type.fromJson($1),
      },
      key: switch (json['key']) {
        null => '',
        Object $1 => decodeString($1),
      },
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'reservationAffinityType': reservationAffinityType.toJson(),
    if (key.isNotDefault) 'key': key,
    if (values.isNotDefault) 'values': values,
  };

  @override
  String toString() {
    final contents = [
      'reservationAffinityType=$reservationAffinityType',
      'key=$key',
    ].join(',');
    return 'ReservationAffinity($contents)';
  }
}

/// Identifies a type of reservation affinity.
final class ReservationAffinity_Type extends ProtoEnum {
  /// Default value. This should not be used.
  static const typeUnspecified = ReservationAffinity_Type('TYPE_UNSPECIFIED');

  /// Do not consume from any reserved capacity, only use on-demand.
  static const noReservation = ReservationAffinity_Type('NO_RESERVATION');

  /// Consume any reservation available, falling back to on-demand.
  static const anyReservation = ReservationAffinity_Type('ANY_RESERVATION');

  /// Consume from a specific reservation. When chosen, the reservation
  /// must be identified via the `key` and `values` fields.
  static const specificReservation = ReservationAffinity_Type(
    'SPECIFIC_RESERVATION',
  );

  /// The default value for [ReservationAffinity_Type].
  static const $default = typeUnspecified;

  const ReservationAffinity_Type(super.value);

  factory ReservationAffinity_Type.fromJson(Object? json) =>
      ReservationAffinity_Type(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// A SavedQuery is a view of the dataset. It references a subset of annotations
/// by problem type and filters.
final class SavedQuery extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SavedQuery';

  /// Output only. Resource name of the SavedQuery.
  final String name;

  /// Required. The user-defined name of the SavedQuery.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Some additional information about the SavedQuery.
  final protobuf.Value? metadata;

  /// Output only. Timestamp when this SavedQuery was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when SavedQuery was last updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Filters on the Annotations in the dataset.
  final String annotationFilter;

  /// Required. Problem type of the SavedQuery.
  /// Allowed values:
  ///
  /// * IMAGE_CLASSIFICATION_SINGLE_LABEL
  /// * IMAGE_CLASSIFICATION_MULTI_LABEL
  /// * IMAGE_BOUNDING_POLY
  /// * IMAGE_BOUNDING_BOX
  /// * TEXT_CLASSIFICATION_SINGLE_LABEL
  /// * TEXT_CLASSIFICATION_MULTI_LABEL
  /// * TEXT_EXTRACTION
  /// * TEXT_SENTIMENT
  /// * VIDEO_CLASSIFICATION
  /// * VIDEO_OBJECT_TRACKING
  final String problemType;

  /// Output only. Number of AnnotationSpecs in the context of the SavedQuery.
  final int annotationSpecCount;

  /// Used to perform a consistent read-modify-write update. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// Output only. If the Annotations belonging to the SavedQuery can be used for
  /// AutoML training.
  final bool supportAutomlTraining;

  SavedQuery({
    this.name = '',
    required this.displayName,
    this.metadata,
    this.createTime,
    this.updateTime,
    this.annotationFilter = '',
    required this.problemType,
    this.annotationSpecCount = 0,
    this.etag = '',
    this.supportAutomlTraining = false,
  }) : super(fullyQualifiedName);

  factory SavedQuery.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SavedQuery(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      annotationFilter: switch (json['annotationFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      problemType: switch (json['problemType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      annotationSpecCount: switch (json['annotationSpecCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      supportAutomlTraining: switch (json['supportAutomlTraining']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (annotationFilter.isNotDefault) 'annotationFilter': annotationFilter,
    'problemType': problemType,
    if (annotationSpecCount.isNotDefault)
      'annotationSpecCount': annotationSpecCount,
    if (etag.isNotDefault) 'etag': etag,
    if (supportAutomlTraining.isNotDefault)
      'supportAutomlTraining': supportAutomlTraining,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'annotationFilter=$annotationFilter',
      'problemType=$problemType',
      'annotationSpecCount=$annotationSpecCount',
      'etag=$etag',
      'supportAutomlTraining=$supportAutomlTraining',
    ].join(',');
    return 'SavedQuery($contents)';
  }
}

/// An instance of a Schedule periodically schedules runs to make API calls based
/// on user specified time specification and API request type.
final class Schedule extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Schedule';

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs. To explicitly set a timezone to the cron tab, apply a prefix in the
  /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
  /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
  /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
  /// "TZ=America/New_York 1 * * * *".
  final String? cron;

  /// Request for
  /// `PipelineService.CreatePipelineJob`.
  /// CreatePipelineJobRequest.parent field is required (format:
  /// projects/{project}/locations/{location}).
  final CreatePipelineJobRequest? createPipelineJobRequest;

  /// Request for
  /// `ModelMonitoringService.CreateModelMonitoringJob`.
  final CreateModelMonitoringJobRequest? createModelMonitoringJobRequest;

  /// Request for
  /// `NotebookService.CreateNotebookExecutionJob`.
  final CreateNotebookExecutionJobRequest? createNotebookExecutionJobRequest;

  /// Immutable. The resource name of the Schedule.
  final String name;

  /// Required. User provided name of the Schedule.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Optional. Timestamp after which the first run can be scheduled.
  /// Default to Schedule create time if not specified.
  final protobuf.Timestamp? startTime;

  /// Optional. Timestamp after which no new runs can be scheduled.
  /// If specified, The schedule will be completed when either
  /// end_time is reached or when scheduled_run_count >= max_run_count.
  /// If not specified, new runs will keep getting scheduled until this Schedule
  /// is paused or deleted. Already scheduled runs will be allowed to complete.
  /// Unset if not specified.
  final protobuf.Timestamp? endTime;

  /// Optional. Maximum run count of the schedule.
  /// If specified, The schedule will be completed when either
  /// started_run_count >= max_run_count or when end_time is reached.
  /// If not specified, new runs will keep getting scheduled until this Schedule
  /// is paused or deleted. Already scheduled runs will be allowed to complete.
  /// Unset if not specified.
  final int maxRunCount;

  /// Output only. The number of runs started by this schedule.
  final int startedRunCount;

  /// Output only. The state of this Schedule.
  final Schedule_State state;

  /// Output only. Timestamp when this Schedule was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Schedule was updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Timestamp when this Schedule should schedule the next run.
  /// Having a next_run_time in the past means the runs are being started
  /// behind schedule.
  final protobuf.Timestamp? nextRunTime;

  /// Output only. Timestamp when this Schedule was last paused.
  /// Unset if never paused.
  final protobuf.Timestamp? lastPauseTime;

  /// Output only. Timestamp when this Schedule was last resumed.
  /// Unset if never resumed from pause.
  final protobuf.Timestamp? lastResumeTime;

  /// Required. Maximum number of runs that can be started concurrently for this
  /// Schedule. This is the limit for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  final int maxConcurrentRunCount;

  /// Optional. Whether new scheduled runs can be queued when max_concurrent_runs
  /// limit is reached. If set to true, new runs will be queued instead of
  /// skipped. Default to false.
  final bool allowQueueing;

  /// Output only. Whether to backfill missed runs when the schedule is resumed
  /// from PAUSED state. If set to true, all missed runs will be scheduled. New
  /// runs will be scheduled after the backfill is complete. Default to false.
  final bool catchUp;

  /// Output only. Response of the last scheduled run.
  /// This is the response for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  /// Unset if no run has been scheduled yet.
  final Schedule_RunResponse? lastScheduledRunResponse;

  Schedule({
    this.cron,
    this.createPipelineJobRequest,
    this.createModelMonitoringJobRequest,
    this.createNotebookExecutionJobRequest,
    this.name = '',
    required this.displayName,
    this.startTime,
    this.endTime,
    this.maxRunCount = 0,
    this.startedRunCount = 0,
    this.state = Schedule_State.$default,
    this.createTime,
    this.updateTime,
    this.nextRunTime,
    this.lastPauseTime,
    this.lastResumeTime,
    required this.maxConcurrentRunCount,
    this.allowQueueing = false,
    this.catchUp = false,
    this.lastScheduledRunResponse,
  }) : super(fullyQualifiedName);

  factory Schedule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Schedule(
      cron: switch (json['cron']) {
        null => null,
        Object $1 => decodeString($1),
      },
      createPipelineJobRequest: switch (json['createPipelineJobRequest']) {
        null => null,
        Object $1 => CreatePipelineJobRequest.fromJson($1),
      },
      createModelMonitoringJobRequest:
          switch (json['createModelMonitoringJobRequest']) {
            null => null,
            Object $1 => CreateModelMonitoringJobRequest.fromJson($1),
          },
      createNotebookExecutionJobRequest:
          switch (json['createNotebookExecutionJobRequest']) {
            null => null,
            Object $1 => CreateNotebookExecutionJobRequest.fromJson($1),
          },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      maxRunCount: switch (json['maxRunCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      startedRunCount: switch (json['startedRunCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      state: switch (json['state']) {
        null => Schedule_State.$default,
        Object $1 => Schedule_State.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      nextRunTime: switch (json['nextRunTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      lastPauseTime: switch (json['lastPauseTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      lastResumeTime: switch (json['lastResumeTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      maxConcurrentRunCount: switch (json['maxConcurrentRunCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      allowQueueing: switch (json['allowQueueing']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      catchUp: switch (json['catchUp']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      lastScheduledRunResponse: switch (json['lastScheduledRunResponse']) {
        null => null,
        Object $1 => Schedule_RunResponse.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (cron != null) 'cron': cron,
    if (createPipelineJobRequest != null)
      'createPipelineJobRequest': createPipelineJobRequest!.toJson(),
    if (createModelMonitoringJobRequest != null)
      'createModelMonitoringJobRequest': createModelMonitoringJobRequest!
          .toJson(),
    if (createNotebookExecutionJobRequest != null)
      'createNotebookExecutionJobRequest': createNotebookExecutionJobRequest!
          .toJson(),
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (maxRunCount.isNotDefault) 'maxRunCount': encodeInt64(maxRunCount),
    if (startedRunCount.isNotDefault)
      'startedRunCount': encodeInt64(startedRunCount),
    if (state.isNotDefault) 'state': state.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (nextRunTime != null) 'nextRunTime': nextRunTime!.toJson(),
    if (lastPauseTime != null) 'lastPauseTime': lastPauseTime!.toJson(),
    if (lastResumeTime != null) 'lastResumeTime': lastResumeTime!.toJson(),
    'maxConcurrentRunCount': encodeInt64(maxConcurrentRunCount),
    if (allowQueueing.isNotDefault) 'allowQueueing': allowQueueing,
    if (catchUp.isNotDefault) 'catchUp': catchUp,
    if (lastScheduledRunResponse != null)
      'lastScheduledRunResponse': lastScheduledRunResponse!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (cron != null) 'cron=$cron',
      'name=$name',
      'displayName=$displayName',
      'maxRunCount=$maxRunCount',
      'startedRunCount=$startedRunCount',
      'state=$state',
      'maxConcurrentRunCount=$maxConcurrentRunCount',
      'allowQueueing=$allowQueueing',
      'catchUp=$catchUp',
    ].join(',');
    return 'Schedule($contents)';
  }
}

/// Status of a scheduled run.
final class Schedule_RunResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Schedule.RunResponse';

  /// The scheduled run time based on the user-specified schedule.
  final protobuf.Timestamp? scheduledRunTime;

  /// The response of the scheduled run.
  final String runResponse;

  Schedule_RunResponse({this.scheduledRunTime, this.runResponse = ''})
    : super(fullyQualifiedName);

  factory Schedule_RunResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Schedule_RunResponse(
      scheduledRunTime: switch (json['scheduledRunTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      runResponse: switch (json['runResponse']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (scheduledRunTime != null)
      'scheduledRunTime': scheduledRunTime!.toJson(),
    if (runResponse.isNotDefault) 'runResponse': runResponse,
  };

  @override
  String toString() {
    final contents = ['runResponse=$runResponse'].join(',');
    return 'RunResponse($contents)';
  }
}

/// Possible state of the schedule.
final class Schedule_State extends ProtoEnum {
  /// Unspecified.
  static const stateUnspecified = Schedule_State('STATE_UNSPECIFIED');

  /// The Schedule is active. Runs are being scheduled on the user-specified
  /// timespec.
  static const active = Schedule_State('ACTIVE');

  /// The schedule is paused. No new runs will be created until the schedule
  /// is resumed. Already started runs will be allowed to complete.
  static const paused = Schedule_State('PAUSED');

  /// The Schedule is completed. No new runs will be scheduled. Already started
  /// runs will be allowed to complete. Schedules in completed state cannot be
  /// paused or resumed.
  static const completed = Schedule_State('COMPLETED');

  /// The default value for [Schedule_State].
  static const $default = stateUnspecified;

  const Schedule_State(super.value);

  factory Schedule_State.fromJson(Object? json) =>
      Schedule_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Request message for
/// `ScheduleService.CreateSchedule`.
final class CreateScheduleRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateScheduleRequest';

  /// Required. The resource name of the Location to create the Schedule in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Schedule to create.
  final Schedule? schedule;

  CreateScheduleRequest({required this.parent, required this.schedule})
    : super(fullyQualifiedName);

  factory CreateScheduleRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateScheduleRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      schedule: switch (json['schedule']) {
        null => null,
        Object $1 => Schedule.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (schedule != null) 'schedule': schedule!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.GetSchedule`.
final class GetScheduleRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetScheduleRequest';

  /// Required. The name of the Schedule resource.
  /// Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  final String name;

  GetScheduleRequest({required this.name}) : super(fullyQualifiedName);

  factory GetScheduleRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetScheduleRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.ListSchedules`.
final class ListSchedulesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSchedulesRequest';

  /// Required. The resource name of the Location to list the Schedules from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the Schedules that match the filter expression. The following
  /// fields are supported:
  ///
  /// * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard.
  /// * `state`: Supports `=` and `!=` comparisons.
  /// * `request`: Supports existence of the <request_type> check.
  ///       (e.g. `create_pipeline_job_request:*` --> Schedule has
  ///       create_pipeline_job_request).
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///       Values must be in RFC 3339 format.
  /// * `start_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///       Values must be in RFC 3339 format.
  /// * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, `>=` comparisons and `:*`
  ///       existence check. Values must be in RFC 3339 format.
  /// * `next_run_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  ///       comparisons. Values must be in RFC 3339 format.
  ///
  ///
  /// Filter expressions can be combined together using logical operators
  /// (`NOT`, `AND` & `OR`).
  /// The syntax to define filter expression is based on
  /// https://google.aip.dev/160.
  ///
  /// Examples:
  ///
  /// * `state="ACTIVE" AND display_name:"my_schedule_*"`
  /// * `NOT display_name="my_schedule"`
  /// * `create_time>"2021-05-18T00:00:00Z"`
  /// * `end_time>"2021-05-18T00:00:00Z" OR NOT end_time:*`
  /// * `create_pipeline_job_request:*`
  final String filter;

  /// The standard list page size.
  /// Default to 100 if not specified.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListSchedulesResponse.next_page_token`
  /// of the previous
  /// `ScheduleService.ListSchedules`
  /// call.
  final String pageToken;

  /// A comma-separated list of fields to order by. The default sort order is in
  /// ascending order. Use "desc" after a field name for descending. You can have
  /// multiple order_by fields provided.
  ///
  /// For example, using "create_time desc, end_time" will order results by
  /// create time in descending order, and if there are multiple schedules having
  /// the same create time, order them by the end time in ascending order.
  ///
  /// If order_by is not specified, it will order by default with create_time in
  /// descending order.
  ///
  /// Supported fields:
  ///
  ///   * `create_time`
  ///   * `start_time`
  ///   * `end_time`
  ///   * `next_run_time`
  final String orderBy;

  ListSchedulesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListSchedulesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSchedulesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListSchedulesRequest($contents)';
  }
}

/// Response message for
/// `ScheduleService.ListSchedules`
final class ListSchedulesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSchedulesResponse';

  /// List of Schedules in the requested page.
  final List<Schedule> schedules;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListSchedulesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListSchedulesResponse({this.schedules = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListSchedulesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSchedulesResponse(
      schedules: switch (json['schedules']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Schedule.fromJson(i)],
        _ => throw const FormatException('"schedules" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (schedules.isNotDefault) 'schedules': encodeList(schedules),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListSchedulesResponse($contents)';
  }
}

/// Request message for
/// `ScheduleService.DeleteSchedule`.
final class DeleteScheduleRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteScheduleRequest';

  /// Required. The name of the Schedule resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  final String name;

  DeleteScheduleRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteScheduleRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteScheduleRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.PauseSchedule`.
final class PauseScheduleRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PauseScheduleRequest';

  /// Required. The name of the Schedule resource to be paused.
  /// Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  final String name;

  PauseScheduleRequest({required this.name}) : super(fullyQualifiedName);

  factory PauseScheduleRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PauseScheduleRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'PauseScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.ResumeSchedule`.
final class ResumeScheduleRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResumeScheduleRequest';

  /// Required. The name of the Schedule resource to be resumed.
  /// Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  final String name;

  /// Optional. Whether to backfill missed runs when the schedule is resumed from
  /// PAUSED state. If set to true, all missed runs will be scheduled. New runs
  /// will be scheduled after the backfill is complete. This will also update
  /// `Schedule.catch_up`
  /// field. Default to false.
  final bool catchUp;

  ResumeScheduleRequest({required this.name, this.catchUp = false})
    : super(fullyQualifiedName);

  factory ResumeScheduleRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResumeScheduleRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      catchUp: switch (json['catchUp']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (catchUp.isNotDefault) 'catchUp': catchUp,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'catchUp=$catchUp'].join(',');
    return 'ResumeScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.UpdateSchedule`.
final class UpdateScheduleRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateScheduleRequest';

  /// Required. The Schedule which replaces the resource on the server.
  /// The following restrictions will be applied:
  ///
  ///   * The scheduled request type cannot be changed.
  ///   * The non-empty fields cannot be unset.
  ///   * The output_only fields will be ignored if specified.
  final Schedule? schedule;

  /// Required. The update mask applies to the resource. See
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateScheduleRequest({required this.schedule, required this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateScheduleRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateScheduleRequest(
      schedule: switch (json['schedule']) {
        null => null,
        Object $1 => Schedule.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (schedule != null) 'schedule': schedule!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateScheduleRequest()';
}

/// PSC config that is used to automatically create PSC endpoints in the user
/// projects.
final class PscautomationConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PSCAutomationConfig';

  /// Required. Project id used to create forwarding rule.
  final String projectId;

  /// Required. The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/get):
  /// `projects/{project}/global/networks/{network}`.
  final String network;

  /// Output only. IP address rule created by the PSC service automation.
  final String ipAddress;

  /// Output only. Forwarding rule created by the PSC service automation.
  final String forwardingRule;

  /// Output only. The state of the PSC service automation.
  final PscautomationState state;

  /// Output only. Error message if the PSC service automation failed.
  final String errorMessage;

  PscautomationConfig({
    required this.projectId,
    required this.network,
    this.ipAddress = '',
    this.forwardingRule = '',
    this.state = PscautomationState.$default,
    this.errorMessage = '',
  }) : super(fullyQualifiedName);

  factory PscautomationConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PscautomationConfig(
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      network: switch (json['network']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ipAddress: switch (json['ipAddress']) {
        null => '',
        Object $1 => decodeString($1),
      },
      forwardingRule: switch (json['forwardingRule']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => PscautomationState.$default,
        Object $1 => PscautomationState.fromJson($1),
      },
      errorMessage: switch (json['errorMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'projectId': projectId,
    'network': network,
    if (ipAddress.isNotDefault) 'ipAddress': ipAddress,
    if (forwardingRule.isNotDefault) 'forwardingRule': forwardingRule,
    if (state.isNotDefault) 'state': state.toJson(),
    if (errorMessage.isNotDefault) 'errorMessage': errorMessage,
  };

  @override
  String toString() {
    final contents = [
      'projectId=$projectId',
      'network=$network',
      'ipAddress=$ipAddress',
      'forwardingRule=$forwardingRule',
      'state=$state',
      'errorMessage=$errorMessage',
    ].join(',');
    return 'PSCAutomationConfig($contents)';
  }
}

/// Represents configuration for private service connect.
final class PrivateServiceConnectConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PrivateServiceConnectConfig';

  /// Required. If true, expose the IndexEndpoint via private service connect.
  final bool enablePrivateServiceConnect;

  /// A list of Projects from which the forwarding rule will target the service
  /// attachment.
  final List<String> projectAllowlist;

  /// Optional. List of projects and networks where the PSC endpoints will be
  /// created. This field is used by Online Inference(Prediction) only.
  final List<PscautomationConfig> pscAutomationConfigs;

  /// Optional. If set to true, enable secure private service connect with IAM
  /// authorization. Otherwise, private service connect will be done without
  /// authorization. Note latency will be slightly increased if authorization is
  /// enabled.
  final bool enableSecurePrivateServiceConnect;

  /// Output only. The name of the generated service attachment resource.
  /// This is only populated if the endpoint is deployed with
  /// PrivateServiceConnect.
  final String serviceAttachment;

  PrivateServiceConnectConfig({
    required this.enablePrivateServiceConnect,
    this.projectAllowlist = const [],
    this.pscAutomationConfigs = const [],
    this.enableSecurePrivateServiceConnect = false,
    this.serviceAttachment = '',
  }) : super(fullyQualifiedName);

  factory PrivateServiceConnectConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PrivateServiceConnectConfig(
      enablePrivateServiceConnect:
          switch (json['enablePrivateServiceConnect']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      projectAllowlist: switch (json['projectAllowlist']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"projectAllowlist" is not a list'),
      },
      pscAutomationConfigs: switch (json['pscAutomationConfigs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PscautomationConfig.fromJson(i),
        ],
        _ => throw const FormatException(
          '"pscAutomationConfigs" is not a list',
        ),
      },
      enableSecurePrivateServiceConnect:
          switch (json['enableSecurePrivateServiceConnect']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      serviceAttachment: switch (json['serviceAttachment']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'enablePrivateServiceConnect': enablePrivateServiceConnect,
    if (projectAllowlist.isNotDefault) 'projectAllowlist': projectAllowlist,
    if (pscAutomationConfigs.isNotDefault)
      'pscAutomationConfigs': encodeList(pscAutomationConfigs),
    if (enableSecurePrivateServiceConnect.isNotDefault)
      'enableSecurePrivateServiceConnect': enableSecurePrivateServiceConnect,
    if (serviceAttachment.isNotDefault) 'serviceAttachment': serviceAttachment,
  };

  @override
  String toString() {
    final contents = [
      'enablePrivateServiceConnect=$enablePrivateServiceConnect',
      'enableSecurePrivateServiceConnect=$enableSecurePrivateServiceConnect',
      'serviceAttachment=$serviceAttachment',
    ].join(',');
    return 'PrivateServiceConnectConfig($contents)';
  }
}

/// PscAutomatedEndpoints defines the output of the forwarding rule
/// automatically created by each PscAutomationConfig.
final class PscAutomatedEndpoints extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PscAutomatedEndpoints';

  /// Corresponding project_id in pscAutomationConfigs
  final String projectId;

  /// Corresponding network in pscAutomationConfigs.
  final String network;

  /// Ip Address created by the automated forwarding rule.
  final String matchAddress;

  PscAutomatedEndpoints({
    this.projectId = '',
    this.network = '',
    this.matchAddress = '',
  }) : super(fullyQualifiedName);

  factory PscAutomatedEndpoints.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PscAutomatedEndpoints(
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      network: switch (json['network']) {
        null => '',
        Object $1 => decodeString($1),
      },
      matchAddress: switch (json['matchAddress']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (projectId.isNotDefault) 'projectId': projectId,
    if (network.isNotDefault) 'network': network,
    if (matchAddress.isNotDefault) 'matchAddress': matchAddress,
  };

  @override
  String toString() {
    final contents = [
      'projectId=$projectId',
      'network=$network',
      'matchAddress=$matchAddress',
    ].join(',');
    return 'PscAutomatedEndpoints($contents)';
  }
}

/// Configuration for PSC-I.
final class PscInterfaceConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PscInterfaceConfig';

  /// Optional. The name of the Compute Engine
  /// [network
  /// attachment](https://cloud.google.com/vpc/docs/about-network-attachments) to
  /// attach to the resource within the region and user project.
  /// To specify this field, you must have already [created a network attachment]
  /// (https://cloud.google.com/vpc/docs/create-manage-network-attachments#create-network-attachments).
  /// This field is only used for resources using PSC-I.
  final String networkAttachment;

  /// Optional. DNS peering configurations. When specified, Vertex AI will
  /// attempt to configure DNS peering zones in the tenant project VPC
  /// to resolve the specified domains using the target network's Cloud DNS.
  /// The user must grant the dns.peer role to the Vertex AI Service Agent
  /// on the target project.
  final List<DnsPeeringConfig> dnsPeeringConfigs;

  PscInterfaceConfig({
    this.networkAttachment = '',
    this.dnsPeeringConfigs = const [],
  }) : super(fullyQualifiedName);

  factory PscInterfaceConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PscInterfaceConfig(
      networkAttachment: switch (json['networkAttachment']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dnsPeeringConfigs: switch (json['dnsPeeringConfigs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DnsPeeringConfig.fromJson(i)],
        _ => throw const FormatException('"dnsPeeringConfigs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (networkAttachment.isNotDefault) 'networkAttachment': networkAttachment,
    if (dnsPeeringConfigs.isNotDefault)
      'dnsPeeringConfigs': encodeList(dnsPeeringConfigs),
  };

  @override
  String toString() {
    final contents = ['networkAttachment=$networkAttachment'].join(',');
    return 'PscInterfaceConfig($contents)';
  }
}

/// DNS peering configuration. These configurations are used to create
/// DNS peering zones in the Vertex tenant project VPC, enabling resolution
/// of records within the specified domain hosted in the target network's
/// Cloud DNS.
final class DnsPeeringConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DnsPeeringConfig';

  /// Required. The DNS name suffix of the zone being peered to, e.g.,
  /// "my-internal-domain.corp.". Must end with a dot.
  final String domain;

  /// Required. The project ID hosting the Cloud DNS managed zone that
  /// contains the 'domain'. The Vertex AI Service Agent requires the
  /// dns.peer role on this project.
  final String targetProject;

  /// Required. The VPC network name
  /// in the target_project where the DNS zone specified by 'domain' is
  /// visible.
  final String targetNetwork;

  DnsPeeringConfig({
    required this.domain,
    required this.targetProject,
    required this.targetNetwork,
  }) : super(fullyQualifiedName);

  factory DnsPeeringConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DnsPeeringConfig(
      domain: switch (json['domain']) {
        null => '',
        Object $1 => decodeString($1),
      },
      targetProject: switch (json['targetProject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      targetNetwork: switch (json['targetNetwork']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'domain': domain,
    'targetProject': targetProject,
    'targetNetwork': targetNetwork,
  };

  @override
  String toString() {
    final contents = [
      'domain=$domain',
      'targetProject=$targetProject',
      'targetNetwork=$targetNetwork',
    ].join(',');
    return 'DnsPeeringConfig($contents)';
  }
}

/// A session contains a set of actions between users and Vertex agents.
final class Session extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Session';

  /// Optional. Timestamp of when this session is considered expired.
  /// This is *always* provided on output, regardless of what was sent
  /// on input.
  final protobuf.Timestamp? expireTime;

  /// Optional. Input only. The TTL for this session.
  final protobuf.Duration? ttl;

  /// Identifier. The resource name of the session.
  /// Format:
  /// 'projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}'.
  final String name;

  /// Output only. Timestamp when the session was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when the session was updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The display name of the session.
  final String displayName;

  /// Optional. Session specific memory which stores key conversation points.
  final protobuf.Struct? sessionState;

  /// Required. Immutable. String id provided by the user
  final String userId;

  Session({
    this.expireTime,
    this.ttl,
    this.name = '',
    this.createTime,
    this.updateTime,
    this.displayName = '',
    this.sessionState,
    required this.userId,
  }) : super(fullyQualifiedName);

  factory Session.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Session(
      expireTime: switch (json['expireTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      ttl: switch (json['ttl']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sessionState: switch (json['sessionState']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      userId: switch (json['userId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (expireTime != null) 'expireTime': expireTime!.toJson(),
    if (ttl != null) 'ttl': ttl!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (displayName.isNotDefault) 'displayName': displayName,
    if (sessionState != null) 'sessionState': sessionState!.toJson(),
    'userId': userId,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'userId=$userId',
    ].join(',');
    return 'Session($contents)';
  }
}

/// An event represents a message from either the user or agent.
final class SessionEvent extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SessionEvent';

  /// Identifier. The resource name of the event.
  /// Format:`projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}/events/{event}`.
  final String name;

  /// Required. The name of the agent that sent the event, or user.
  final String author;

  /// Optional. Content of the event provided by the author.
  final Content? content;

  /// Required. The invocation id of the event, multiple events can have the same
  /// invocation id.
  final String invocationId;

  /// Optional. Actions executed by the agent.
  final EventActions? actions;

  /// Required. Timestamp when the event was created on client side.
  final protobuf.Timestamp? timestamp;

  /// Optional. Error code if the response is an error. Code varies by model.
  final String errorCode;

  /// Optional. Error message if the response is an error.
  final String errorMessage;

  /// Optional. Metadata relating to this event.
  final EventMetadata? eventMetadata;

  SessionEvent({
    this.name = '',
    required this.author,
    this.content,
    required this.invocationId,
    this.actions,
    required this.timestamp,
    this.errorCode = '',
    this.errorMessage = '',
    this.eventMetadata,
  }) : super(fullyQualifiedName);

  factory SessionEvent.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SessionEvent(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      author: switch (json['author']) {
        null => '',
        Object $1 => decodeString($1),
      },
      content: switch (json['content']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
      invocationId: switch (json['invocationId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      actions: switch (json['actions']) {
        null => null,
        Object $1 => EventActions.fromJson($1),
      },
      timestamp: switch (json['timestamp']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      errorCode: switch (json['errorCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      errorMessage: switch (json['errorMessage']) {
        null => '',
        Object $1 => decodeString($1),
      },
      eventMetadata: switch (json['eventMetadata']) {
        null => null,
        Object $1 => EventMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'author': author,
    if (content != null) 'content': content!.toJson(),
    'invocationId': invocationId,
    if (actions != null) 'actions': actions!.toJson(),
    if (timestamp != null) 'timestamp': timestamp!.toJson(),
    if (errorCode.isNotDefault) 'errorCode': errorCode,
    if (errorMessage.isNotDefault) 'errorMessage': errorMessage,
    if (eventMetadata != null) 'eventMetadata': eventMetadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'author=$author',
      'invocationId=$invocationId',
      'errorCode=$errorCode',
      'errorMessage=$errorMessage',
    ].join(',');
    return 'SessionEvent($contents)';
  }
}

/// Metadata relating to a LLM response event.
final class EventMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EventMetadata';

  /// Optional. Metadata returned to client when grounding is enabled.
  final GroundingMetadata? groundingMetadata;

  /// Optional. Indicates whether the text content is part of a unfinished text
  /// stream. Only used for streaming mode and when the content is plain text.
  final bool partial;

  /// Optional. Indicates whether the response from the model is complete.
  /// Only used for streaming mode.
  final bool turnComplete;

  /// Optional. Flag indicating that LLM was interrupted when generating the
  /// content. Usually it's due to user interruption during a bidi streaming.
  final bool interrupted;

  /// Optional. Set of ids of the long running function calls.
  /// Agent client will know from this field about which function call is long
  /// running. Only valid for function call event.
  final List<String> longRunningToolIds;

  /// Optional. The branch of the event.
  /// The format is like agent_1.agent_2.agent_3, where agent_1 is the parent of
  /// agent_2, and agent_2 is the parent of agent_3.
  /// Branch is used when multiple child agents shouldn't see their siblings'
  /// conversation history.
  final String branch;

  /// The custom metadata of the LlmResponse.
  final protobuf.Struct? customMetadata;

  EventMetadata({
    this.groundingMetadata,
    this.partial = false,
    this.turnComplete = false,
    this.interrupted = false,
    this.longRunningToolIds = const [],
    this.branch = '',
    this.customMetadata,
  }) : super(fullyQualifiedName);

  factory EventMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EventMetadata(
      groundingMetadata: switch (json['groundingMetadata']) {
        null => null,
        Object $1 => GroundingMetadata.fromJson($1),
      },
      partial: switch (json['partial']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      turnComplete: switch (json['turnComplete']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      interrupted: switch (json['interrupted']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      longRunningToolIds: switch (json['longRunningToolIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"longRunningToolIds" is not a list'),
      },
      branch: switch (json['branch']) {
        null => '',
        Object $1 => decodeString($1),
      },
      customMetadata: switch (json['customMetadata']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (groundingMetadata != null)
      'groundingMetadata': groundingMetadata!.toJson(),
    if (partial.isNotDefault) 'partial': partial,
    if (turnComplete.isNotDefault) 'turnComplete': turnComplete,
    if (interrupted.isNotDefault) 'interrupted': interrupted,
    if (longRunningToolIds.isNotDefault)
      'longRunningToolIds': longRunningToolIds,
    if (branch.isNotDefault) 'branch': branch,
    if (customMetadata != null) 'customMetadata': customMetadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'partial=$partial',
      'turnComplete=$turnComplete',
      'interrupted=$interrupted',
      'branch=$branch',
    ].join(',');
    return 'EventMetadata($contents)';
  }
}

/// Actions are parts of events that are executed by the agent.
final class EventActions extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EventActions';

  /// Optional. If true, it won't call model to summarize function response.
  /// Only used for function_response event.
  final bool skipSummarization;

  /// Optional. Indicates that the event is updating the state with the given
  /// delta.
  final protobuf.Struct? stateDelta;

  /// Optional. Indicates that the event is updating an artifact. key is the
  /// filename, value is the version.
  final Map<String, int> artifactDelta;

  /// Deprecated. If set, the event transfers to the specified agent.
  final bool transferToAgent;

  /// Optional. The agent is escalating to a higher level agent.
  final bool escalate;

  /// Optional. Will only be set by a tool response indicating tool request euc.
  /// Struct key is the function call id since one function call response (from
  /// model) could correspond to multiple function calls. Struct value is the
  /// required auth config, which can be another struct.
  final protobuf.Struct? requestedAuthConfigs;

  /// Optional. If set, the event transfers to the specified agent.
  final String transferAgent;

  EventActions({
    this.skipSummarization = false,
    this.stateDelta,
    this.artifactDelta = const {},
    this.transferToAgent = false,
    this.escalate = false,
    this.requestedAuthConfigs,
    this.transferAgent = '',
  }) : super(fullyQualifiedName);

  factory EventActions.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EventActions(
      skipSummarization: switch (json['skipSummarization']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      stateDelta: switch (json['stateDelta']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      artifactDelta: switch (json['artifactDelta']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries) decodeString(e.key): decodeInt(e.value),
        },
        _ => throw const FormatException('"artifactDelta" is not an object'),
      },
      transferToAgent: switch (json['transferToAgent']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      escalate: switch (json['escalate']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      requestedAuthConfigs: switch (json['requestedAuthConfigs']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      transferAgent: switch (json['transferAgent']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (skipSummarization.isNotDefault) 'skipSummarization': skipSummarization,
    if (stateDelta != null) 'stateDelta': stateDelta!.toJson(),
    if (artifactDelta.isNotDefault) 'artifactDelta': artifactDelta,
    if (transferToAgent.isNotDefault) 'transferToAgent': transferToAgent,
    if (escalate.isNotDefault) 'escalate': escalate,
    if (requestedAuthConfigs != null)
      'requestedAuthConfigs': requestedAuthConfigs!.toJson(),
    if (transferAgent.isNotDefault) 'transferAgent': transferAgent,
  };

  @override
  String toString() {
    final contents = [
      'skipSummarization=$skipSummarization',
      'transferToAgent=$transferToAgent',
      'escalate=$escalate',
      'transferAgent=$transferAgent',
    ].join(',');
    return 'EventActions($contents)';
  }
}

/// Request message for
/// `SessionService.CreateSession`.
final class CreateSessionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateSessionRequest';

  /// Required. The resource name of the location to create the session in.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Required. The session to create.
  final Session? session;

  CreateSessionRequest({required this.parent, required this.session})
    : super(fullyQualifiedName);

  factory CreateSessionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateSessionRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      session: switch (json['session']) {
        null => null,
        Object $1 => Session.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (session != null) 'session': session!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateSessionRequest($contents)';
  }
}

/// Metadata associated with the
/// `SessionService.CreateSession`
/// operation.
final class CreateSessionOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateSessionOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateSessionOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateSessionOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateSessionOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateSessionOperationMetadata()';
}

/// Request message for
/// `SessionService.GetSession`.
final class GetSessionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetSessionRequest';

  /// Required. The resource name of the session.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String name;

  GetSessionRequest({required this.name}) : super(fullyQualifiedName);

  factory GetSessionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetSessionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetSessionRequest($contents)';
  }
}

/// Request message for
/// `SessionService.ListSessions`.
final class ListSessionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSessionsRequest';

  /// Required. The resource name of the location to list sessions from.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Optional. The maximum number of sessions to return. The service may return
  /// fewer than this value. If unspecified, at most 100 sessions will be
  /// returned.
  final int pageSize;

  /// Optional. The
  /// `next_page_token`
  /// value returned from a previous list
  /// `SessionService.ListSessions`
  /// call.
  final String pageToken;

  /// Optional. The standard list filter.
  /// Supported fields:
  ///    * `display_name`
  ///
  /// Example: `display_name=abc`.
  final String filter;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `create_time desc`.
  final String orderBy;

  ListSessionsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListSessionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSessionsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListSessionsRequest($contents)';
  }
}

/// Response message for
/// `SessionService.ListSessions`.
final class ListSessionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSessionsResponse';

  /// A list of sessions matching the request.
  final List<Session> sessions;

  /// A token, which can be sent as
  /// `ListSessionsRequest.page_token`
  /// to retrieve the next page. Absence of this field indicates there are no
  /// subsequent pages.
  final String nextPageToken;

  ListSessionsResponse({this.sessions = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListSessionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSessionsResponse(
      sessions: switch (json['sessions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Session.fromJson(i)],
        _ => throw const FormatException('"sessions" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sessions.isNotDefault) 'sessions': encodeList(sessions),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListSessionsResponse($contents)';
  }
}

/// Request message for
/// `SessionService.UpdateSession`.
final class UpdateSessionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateSessionRequest';

  /// Required. The session to update.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final Session? session;

  /// Optional. Field mask is used to control which fields get updated. If the
  /// mask is not present, all fields will be updated.
  final protobuf.FieldMask? updateMask;

  UpdateSessionRequest({required this.session, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateSessionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateSessionRequest(
      session: switch (json['session']) {
        null => null,
        Object $1 => Session.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (session != null) 'session': session!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateSessionRequest()';
}

/// Request message for
/// `SessionService.DeleteSession`.
final class DeleteSessionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteSessionRequest';

  /// Required. The resource name of the session.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String name;

  DeleteSessionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteSessionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteSessionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteSessionRequest($contents)';
  }
}

/// Request message for
/// `SessionService.ListEvents`.
final class ListEventsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEventsRequest';

  /// Required. The resource name of the session to list events from.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String parent;

  /// Optional. The maximum number of events to return. The service may return
  /// fewer than this value. If unspecified, at most 100 events will be returned.
  /// These events are ordered by timestamp in ascending order.
  final int pageSize;

  /// Optional. The
  /// `next_page_token`
  /// value returned from a previous list
  /// `SessionService.ListEvents`
  /// call.
  final String pageToken;

  /// Optional. The standard list filter.
  /// Supported fields:
  ///    * `timestamp` range (i.e. `timestamp>="2025-01-31T11:30:00-04:00"` where
  ///    the timestamp is in RFC 3339 format)
  ///
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String filter;

  ListEventsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
  }) : super(fullyQualifiedName);

  factory ListEventsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListEventsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
    ].join(',');
    return 'ListEventsRequest($contents)';
  }
}

/// Response message for
/// `SessionService.ListEvents`.
final class ListEventsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEventsResponse';

  /// A list of events matching the request. Ordered by timestamp in ascending
  /// order.
  final List<SessionEvent> sessionEvents;

  /// A token, which can be sent as
  /// `ListEventsRequest.page_token`
  /// to retrieve the next page. Absence of this field indicates there are no
  /// subsequent pages.
  final String nextPageToken;

  ListEventsResponse({this.sessionEvents = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListEventsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListEventsResponse(
      sessionEvents: switch (json['sessionEvents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SessionEvent.fromJson(i)],
        _ => throw const FormatException('"sessionEvents" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sessionEvents.isNotDefault) 'sessionEvents': encodeList(sessionEvents),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListEventsResponse($contents)';
  }
}

/// Request message for
/// `SessionService.AppendEvent`.
final class AppendEventRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AppendEventRequest';

  /// Required. The resource name of the session to append event to.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String name;

  /// Required. The event to append to the session.
  final SessionEvent? event;

  AppendEventRequest({required this.name, required this.event})
    : super(fullyQualifiedName);

  factory AppendEventRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AppendEventRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      event: switch (json['event']) {
        null => null,
        Object $1 => SessionEvent.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (event != null) 'event': event!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AppendEventRequest($contents)';
  }
}

/// Response message for
/// `SessionService.AppendEvent`.
final class AppendEventResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AppendEventResponse';

  AppendEventResponse() : super(fullyQualifiedName);

  factory AppendEventResponse.fromJson(Object? j) => AppendEventResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'AppendEventResponse()';
}

/// SpecialistPool represents customers' own workforce to work on their data
/// labeling jobs. It includes a group of specialist managers and workers.
/// Managers are responsible for managing the workers in this pool as well as
/// customers' data labeling jobs associated with this pool. Customers create
/// specialist pool as well as start data labeling jobs on Cloud, managers and
/// workers handle the jobs using CrowdCompute console.
final class SpecialistPool extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpecialistPool';

  /// Required. The resource name of the SpecialistPool.
  final String name;

  /// Required. The user-defined name of the SpecialistPool.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  /// This field should be unique on project-level.
  final String displayName;

  /// Output only. The number of managers in this SpecialistPool.
  final int specialistManagersCount;

  /// The email addresses of the managers in the SpecialistPool.
  final List<String> specialistManagerEmails;

  /// Output only. The resource name of the pending data labeling jobs.
  final List<String> pendingDataLabelingJobs;

  /// The email addresses of workers in the SpecialistPool.
  final List<String> specialistWorkerEmails;

  SpecialistPool({
    required this.name,
    required this.displayName,
    this.specialistManagersCount = 0,
    this.specialistManagerEmails = const [],
    this.pendingDataLabelingJobs = const [],
    this.specialistWorkerEmails = const [],
  }) : super(fullyQualifiedName);

  factory SpecialistPool.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SpecialistPool(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      specialistManagersCount: switch (json['specialistManagersCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      specialistManagerEmails: switch (json['specialistManagerEmails']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"specialistManagerEmails" is not a list',
        ),
      },
      pendingDataLabelingJobs: switch (json['pendingDataLabelingJobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"pendingDataLabelingJobs" is not a list',
        ),
      },
      specialistWorkerEmails: switch (json['specialistWorkerEmails']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"specialistWorkerEmails" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    'displayName': displayName,
    if (specialistManagersCount.isNotDefault)
      'specialistManagersCount': specialistManagersCount,
    if (specialistManagerEmails.isNotDefault)
      'specialistManagerEmails': specialistManagerEmails,
    if (pendingDataLabelingJobs.isNotDefault)
      'pendingDataLabelingJobs': pendingDataLabelingJobs,
    if (specialistWorkerEmails.isNotDefault)
      'specialistWorkerEmails': specialistWorkerEmails,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'specialistManagersCount=$specialistManagersCount',
    ].join(',');
    return 'SpecialistPool($contents)';
  }
}

/// Request message for
/// `SpecialistPoolService.CreateSpecialistPool`.
final class CreateSpecialistPoolRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateSpecialistPoolRequest';

  /// Required. The parent Project name for the new SpecialistPool.
  /// The form is `projects/{project}/locations/{location}`.
  final String parent;

  /// Required. The SpecialistPool to create.
  final SpecialistPool? specialistPool;

  CreateSpecialistPoolRequest({
    required this.parent,
    required this.specialistPool,
  }) : super(fullyQualifiedName);

  factory CreateSpecialistPoolRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateSpecialistPoolRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      specialistPool: switch (json['specialistPool']) {
        null => null,
        Object $1 => SpecialistPool.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (specialistPool != null) 'specialistPool': specialistPool!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateSpecialistPoolRequest($contents)';
  }
}

/// Runtime operation information for
/// `SpecialistPoolService.CreateSpecialistPool`.
final class CreateSpecialistPoolOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateSpecialistPoolOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateSpecialistPoolOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateSpecialistPoolOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateSpecialistPoolOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateSpecialistPoolOperationMetadata()';
}

/// Request message for
/// `SpecialistPoolService.GetSpecialistPool`.
final class GetSpecialistPoolRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetSpecialistPoolRequest';

  /// Required. The name of the SpecialistPool resource.
  /// The form is
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
  final String name;

  GetSpecialistPoolRequest({required this.name}) : super(fullyQualifiedName);

  factory GetSpecialistPoolRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetSpecialistPoolRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetSpecialistPoolRequest($contents)';
  }
}

/// Request message for
/// `SpecialistPoolService.ListSpecialistPools`.
final class ListSpecialistPoolsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSpecialistPoolsRequest';

  /// Required. The name of the SpecialistPool's parent resource.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  /// Typically obtained by
  /// `ListSpecialistPoolsResponse.next_page_token`
  /// of the previous
  /// `SpecialistPoolService.ListSpecialistPools`
  /// call. Return first page if empty.
  final String pageToken;

  /// Mask specifying which fields to read. FieldMask represents a set of
  final protobuf.FieldMask? readMask;

  ListSpecialistPoolsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListSpecialistPoolsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSpecialistPoolsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListSpecialistPoolsRequest($contents)';
  }
}

/// Response message for
/// `SpecialistPoolService.ListSpecialistPools`.
final class ListSpecialistPoolsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSpecialistPoolsResponse';

  /// A list of SpecialistPools that matches the specified filter in the request.
  final List<SpecialistPool> specialistPools;

  /// The standard List next-page token.
  final String nextPageToken;

  ListSpecialistPoolsResponse({
    this.specialistPools = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListSpecialistPoolsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSpecialistPoolsResponse(
      specialistPools: switch (json['specialistPools']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SpecialistPool.fromJson(i)],
        _ => throw const FormatException('"specialistPools" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (specialistPools.isNotDefault)
      'specialistPools': encodeList(specialistPools),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListSpecialistPoolsResponse($contents)';
  }
}

/// Request message for
/// `SpecialistPoolService.DeleteSpecialistPool`.
final class DeleteSpecialistPoolRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteSpecialistPoolRequest';

  /// Required. The resource name of the SpecialistPool to delete. Format:
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`
  final String name;

  /// If set to true, any specialist managers in this SpecialistPool will also be
  /// deleted. (Otherwise, the request will only work if the SpecialistPool has
  /// no specialist managers.)
  final bool force;

  DeleteSpecialistPoolRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteSpecialistPoolRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteSpecialistPoolRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteSpecialistPoolRequest($contents)';
  }
}

/// Request message for
/// `SpecialistPoolService.UpdateSpecialistPool`.
final class UpdateSpecialistPoolRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateSpecialistPoolRequest';

  /// Required. The SpecialistPool which replaces the resource on the server.
  final SpecialistPool? specialistPool;

  /// Required. The update mask applies to the resource.
  final protobuf.FieldMask? updateMask;

  UpdateSpecialistPoolRequest({
    required this.specialistPool,
    required this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateSpecialistPoolRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateSpecialistPoolRequest(
      specialistPool: switch (json['specialistPool']) {
        null => null,
        Object $1 => SpecialistPool.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (specialistPool != null) 'specialistPool': specialistPool!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateSpecialistPoolRequest()';
}

/// Runtime operation metadata for
/// `SpecialistPoolService.UpdateSpecialistPool`.
final class UpdateSpecialistPoolOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateSpecialistPoolOperationMetadata';

  /// Output only. The name of the SpecialistPool to which the specialists are
  /// being added. Format:
  /// `projects/{project_id}/locations/{location_id}/specialistPools/{specialist_pool}`
  final String specialistPool;

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateSpecialistPoolOperationMetadata({
    this.specialistPool = '',
    this.genericMetadata,
  }) : super(fullyQualifiedName);

  factory UpdateSpecialistPoolOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateSpecialistPoolOperationMetadata(
      specialistPool: switch (json['specialistPool']) {
        null => '',
        Object $1 => decodeString($1),
      },
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (specialistPool.isNotDefault) 'specialistPool': specialistPool,
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() {
    final contents = ['specialistPool=$specialistPool'].join(',');
    return 'UpdateSpecialistPoolOperationMetadata($contents)';
  }
}

/// A message representing a Study.
final class Study extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Study';

  /// Output only. The name of a study. The study's globally unique identifier.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String name;

  /// Required. Describes the Study, default value is empty string.
  final String displayName;

  /// Required. Configuration of the Study.
  final StudySpec? studySpec;

  /// Output only. The detailed state of a Study.
  final Study_State state;

  /// Output only. Time at which the study was created.
  final protobuf.Timestamp? createTime;

  /// Output only. A human readable reason why the Study is inactive.
  /// This should be empty if a study is ACTIVE or COMPLETED.
  final String inactiveReason;

  Study({
    this.name = '',
    required this.displayName,
    required this.studySpec,
    this.state = Study_State.$default,
    this.createTime,
    this.inactiveReason = '',
  }) : super(fullyQualifiedName);

  factory Study.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Study(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      studySpec: switch (json['studySpec']) {
        null => null,
        Object $1 => StudySpec.fromJson($1),
      },
      state: switch (json['state']) {
        null => Study_State.$default,
        Object $1 => Study_State.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      inactiveReason: switch (json['inactiveReason']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (studySpec != null) 'studySpec': studySpec!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (inactiveReason.isNotDefault) 'inactiveReason': inactiveReason,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'state=$state',
      'inactiveReason=$inactiveReason',
    ].join(',');
    return 'Study($contents)';
  }
}

/// Describes the Study state.
final class Study_State extends ProtoEnum {
  /// The study state is unspecified.
  static const stateUnspecified = Study_State('STATE_UNSPECIFIED');

  /// The study is active.
  static const active = Study_State('ACTIVE');

  /// The study is stopped due to an internal error.
  static const inactive = Study_State('INACTIVE');

  /// The study is done when the service exhausts the parameter search space
  /// or max_trial_count is reached.
  static const completed = Study_State('COMPLETED');

  /// The default value for [Study_State].
  static const $default = stateUnspecified;

  const Study_State(super.value);

  factory Study_State.fromJson(Object? json) => Study_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// A message representing a Trial. A Trial contains a unique set of Parameters
/// that has been or will be evaluated, along with the objective metrics got by
/// running the Trial.
final class Trial extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Trial';

  /// Output only. Resource name of the Trial assigned by the service.
  final String name;

  /// Output only. The identifier of the Trial assigned by the service.
  final String id;

  /// Output only. The detailed state of the Trial.
  final Trial_State state;

  /// Output only. The parameters of the Trial.
  final List<Trial_Parameter> parameters;

  /// Output only. The final measurement containing the objective value.
  final Measurement? finalMeasurement;

  /// Output only. A list of measurements that are strictly lexicographically
  /// ordered by their induced tuples (steps, elapsed_duration).
  /// These are used for early stopping computations.
  final List<Measurement> measurements;

  /// Output only. Time when the Trial was started.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the Trial's status changed to `SUCCEEDED` or
  /// `INFEASIBLE`.
  final protobuf.Timestamp? endTime;

  /// Output only. The identifier of the client that originally requested this
  /// Trial. Each client is identified by a unique client_id. When a client asks
  /// for a suggestion, Vertex AI Vizier will assign it a Trial. The client
  /// should evaluate the Trial, complete it, and report back to Vertex AI
  /// Vizier. If suggestion is asked again by same client_id before the Trial is
  /// completed, the same Trial will be returned. Multiple clients with
  /// different client_ids can ask for suggestions simultaneously, each of them
  /// will get their own Trial.
  final String clientId;

  /// Output only. A human readable string describing why the Trial is
  /// infeasible. This is set only if Trial state is `INFEASIBLE`.
  final String infeasibleReason;

  /// Output only. The CustomJob name linked to the Trial.
  /// It's set for a HyperparameterTuningJob's Trial.
  final String customJob;

  /// Output only. URIs for accessing [interactive
  /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node). Only available if this trial is part of
  /// a
  /// `HyperparameterTuningJob`
  /// and the job's
  /// `trial_job_spec.enable_web_access`
  /// field is `true`.
  ///
  /// The keys are names of each node used for the trial; for example,
  /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
  /// the second worker pool, and `workerpool1-1` for the second node in the
  /// second worker pool.
  ///
  /// The values are the URIs for each node's interactive shell.
  final Map<String, String> webAccessUris;

  Trial({
    this.name = '',
    this.id = '',
    this.state = Trial_State.$default,
    this.parameters = const [],
    this.finalMeasurement,
    this.measurements = const [],
    this.startTime,
    this.endTime,
    this.clientId = '',
    this.infeasibleReason = '',
    this.customJob = '',
    this.webAccessUris = const {},
  }) : super(fullyQualifiedName);

  factory Trial.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Trial(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => Trial_State.$default,
        Object $1 => Trial_State.fromJson($1),
      },
      parameters: switch (json['parameters']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Trial_Parameter.fromJson(i)],
        _ => throw const FormatException('"parameters" is not a list'),
      },
      finalMeasurement: switch (json['finalMeasurement']) {
        null => null,
        Object $1 => Measurement.fromJson($1),
      },
      measurements: switch (json['measurements']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Measurement.fromJson(i)],
        _ => throw const FormatException('"measurements" is not a list'),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      clientId: switch (json['clientId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      infeasibleReason: switch (json['infeasibleReason']) {
        null => '',
        Object $1 => decodeString($1),
      },
      customJob: switch (json['customJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      webAccessUris: switch (json['webAccessUris']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"webAccessUris" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (id.isNotDefault) 'id': id,
    if (state.isNotDefault) 'state': state.toJson(),
    if (parameters.isNotDefault) 'parameters': encodeList(parameters),
    if (finalMeasurement != null)
      'finalMeasurement': finalMeasurement!.toJson(),
    if (measurements.isNotDefault) 'measurements': encodeList(measurements),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (clientId.isNotDefault) 'clientId': clientId,
    if (infeasibleReason.isNotDefault) 'infeasibleReason': infeasibleReason,
    if (customJob.isNotDefault) 'customJob': customJob,
    if (webAccessUris.isNotDefault) 'webAccessUris': webAccessUris,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'id=$id',
      'state=$state',
      'clientId=$clientId',
      'infeasibleReason=$infeasibleReason',
      'customJob=$customJob',
    ].join(',');
    return 'Trial($contents)';
  }
}

/// A message representing a parameter to be tuned.
final class Trial_Parameter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Trial.Parameter';

  /// Output only. The ID of the parameter. The parameter should be defined in
  /// [StudySpec's
  /// Parameters][google.cloud.aiplatform.v1beta1.StudySpec.parameters].
  final String parameterId;

  /// Output only. The value of the parameter.
  /// `number_value` will be set if a parameter defined in StudySpec is
  /// in type 'INTEGER', 'DOUBLE' or 'DISCRETE'.
  /// `string_value` will be set if a parameter defined in StudySpec is
  /// in type 'CATEGORICAL'.
  final protobuf.Value? value;

  Trial_Parameter({this.parameterId = '', this.value})
    : super(fullyQualifiedName);

  factory Trial_Parameter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Trial_Parameter(
      parameterId: switch (json['parameterId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      value: switch (json['value']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (parameterId.isNotDefault) 'parameterId': parameterId,
    if (value != null) 'value': value!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parameterId=$parameterId'].join(',');
    return 'Parameter($contents)';
  }
}

/// Describes a Trial state.
final class Trial_State extends ProtoEnum {
  /// The Trial state is unspecified.
  static const stateUnspecified = Trial_State('STATE_UNSPECIFIED');

  /// Indicates that a specific Trial has been requested, but it has not yet
  /// been suggested by the service.
  static const requested = Trial_State('REQUESTED');

  /// Indicates that the Trial has been suggested.
  static const active = Trial_State('ACTIVE');

  /// Indicates that the Trial should stop according to the service.
  static const stopping = Trial_State('STOPPING');

  /// Indicates that the Trial is completed successfully.
  static const succeeded = Trial_State('SUCCEEDED');

  /// Indicates that the Trial should not be attempted again.
  /// The service will set a Trial to INFEASIBLE when it's done but missing
  /// the final_measurement.
  static const infeasible = Trial_State('INFEASIBLE');

  /// The default value for [Trial_State].
  static const $default = stateUnspecified;

  const Trial_State(super.value);

  factory Trial_State.fromJson(Object? json) => Trial_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

final class TrialContext extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrialContext';

  /// A human-readable field which can store a description of this context.
  /// This will become part of the resulting Trial's description field.
  final String description;

  /// If/when a Trial is generated or selected from this Context,
  /// its Parameters will match any parameters specified here.
  /// (I.e. if this context specifies parameter name:'a' int_value:3,
  /// then a resulting Trial will have int_value:3 for its parameter named
  /// 'a'.) Note that we first attempt to match existing REQUESTED Trials with
  /// contexts, and if there are no matches, we generate suggestions in the
  /// subspace defined by the parameters specified here.
  /// NOTE: a Context without any Parameters matches the entire feasible search
  ///   space.
  final List<Trial_Parameter> parameters;

  TrialContext({this.description = '', this.parameters = const []})
    : super(fullyQualifiedName);

  factory TrialContext.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrialContext(
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parameters: switch (json['parameters']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Trial_Parameter.fromJson(i)],
        _ => throw const FormatException('"parameters" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (description.isNotDefault) 'description': description,
    if (parameters.isNotDefault) 'parameters': encodeList(parameters),
  };

  @override
  String toString() {
    final contents = ['description=$description'].join(',');
    return 'TrialContext($contents)';
  }
}

/// Time-based Constraint for Study
final class StudyTimeConstraint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudyTimeConstraint';

  /// Counts the wallclock time passed since the creation of this Study.
  final protobuf.Duration? maxDuration;

  /// Compares the wallclock time to this time. Must use UTC timezone.
  final protobuf.Timestamp? endTime;

  StudyTimeConstraint({this.maxDuration, this.endTime})
    : super(fullyQualifiedName);

  factory StudyTimeConstraint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudyTimeConstraint(
      maxDuration: switch (json['maxDuration']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxDuration != null) 'maxDuration': maxDuration!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() => 'StudyTimeConstraint()';
}

/// Represents specification of a Study.
final class StudySpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec';

  /// The automated early stopping spec using decay curve rule.
  final StudySpec_DecayCurveAutomatedStoppingSpec? decayCurveStoppingSpec;

  /// The automated early stopping spec using median rule.
  final StudySpec_MedianAutomatedStoppingSpec? medianAutomatedStoppingSpec;

  /// Deprecated.
  /// The automated early stopping using convex stopping rule.
  final StudySpec_ConvexStopConfig? convexStopConfig;

  /// The automated early stopping spec using convex stopping rule.
  final StudySpec_ConvexAutomatedStoppingSpec? convexAutomatedStoppingSpec;

  /// Required. Metric specs for the Study.
  final List<StudySpec_MetricSpec> metrics;

  /// Required. The set of parameters to tune.
  final List<StudySpec_ParameterSpec> parameters;

  /// The search algorithm specified for the Study.
  final StudySpec_Algorithm algorithm;

  /// The observation noise level of the study.
  /// Currently only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  final StudySpec_ObservationNoise observationNoise;

  /// Describe which measurement selection type will be used
  final StudySpec_MeasurementSelectionType measurementSelectionType;

  /// The configuration info/options for transfer learning. Currently supported
  /// for Vertex AI Vizier service, not HyperParameterTuningJob
  final StudySpec_TransferLearningConfig? transferLearningConfig;

  /// Conditions for automated stopping of a Study. Enable automated stopping by
  /// configuring at least one condition.
  final StudySpec_StudyStoppingConfig? studyStoppingConfig;

  StudySpec({
    this.decayCurveStoppingSpec,
    this.medianAutomatedStoppingSpec,
    this.convexStopConfig,
    this.convexAutomatedStoppingSpec,
    required this.metrics,
    required this.parameters,
    this.algorithm = StudySpec_Algorithm.$default,
    this.observationNoise = StudySpec_ObservationNoise.$default,
    this.measurementSelectionType = StudySpec_MeasurementSelectionType.$default,
    this.transferLearningConfig,
    this.studyStoppingConfig,
  }) : super(fullyQualifiedName);

  factory StudySpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec(
      decayCurveStoppingSpec: switch (json['decayCurveStoppingSpec']) {
        null => null,
        Object $1 => StudySpec_DecayCurveAutomatedStoppingSpec.fromJson($1),
      },
      medianAutomatedStoppingSpec:
          switch (json['medianAutomatedStoppingSpec']) {
            null => null,
            Object $1 => StudySpec_MedianAutomatedStoppingSpec.fromJson($1),
          },
      convexStopConfig: switch (json['convexStopConfig']) {
        null => null,
        Object $1 => StudySpec_ConvexStopConfig.fromJson($1),
      },
      convexAutomatedStoppingSpec:
          switch (json['convexAutomatedStoppingSpec']) {
            null => null,
            Object $1 => StudySpec_ConvexAutomatedStoppingSpec.fromJson($1),
          },
      metrics: switch (json['metrics']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) StudySpec_MetricSpec.fromJson(i),
        ],
        _ => throw const FormatException('"metrics" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) StudySpec_ParameterSpec.fromJson(i),
        ],
        _ => throw const FormatException('"parameters" is not a list'),
      },
      algorithm: switch (json['algorithm']) {
        null => StudySpec_Algorithm.$default,
        Object $1 => StudySpec_Algorithm.fromJson($1),
      },
      observationNoise: switch (json['observationNoise']) {
        null => StudySpec_ObservationNoise.$default,
        Object $1 => StudySpec_ObservationNoise.fromJson($1),
      },
      measurementSelectionType: switch (json['measurementSelectionType']) {
        null => StudySpec_MeasurementSelectionType.$default,
        Object $1 => StudySpec_MeasurementSelectionType.fromJson($1),
      },
      transferLearningConfig: switch (json['transferLearningConfig']) {
        null => null,
        Object $1 => StudySpec_TransferLearningConfig.fromJson($1),
      },
      studyStoppingConfig: switch (json['studyStoppingConfig']) {
        null => null,
        Object $1 => StudySpec_StudyStoppingConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (decayCurveStoppingSpec != null)
      'decayCurveStoppingSpec': decayCurveStoppingSpec!.toJson(),
    if (medianAutomatedStoppingSpec != null)
      'medianAutomatedStoppingSpec': medianAutomatedStoppingSpec!.toJson(),
    if (convexStopConfig != null)
      'convexStopConfig': convexStopConfig!.toJson(),
    if (convexAutomatedStoppingSpec != null)
      'convexAutomatedStoppingSpec': convexAutomatedStoppingSpec!.toJson(),
    'metrics': encodeList(metrics),
    'parameters': encodeList(parameters),
    if (algorithm.isNotDefault) 'algorithm': algorithm.toJson(),
    if (observationNoise.isNotDefault)
      'observationNoise': observationNoise.toJson(),
    if (measurementSelectionType.isNotDefault)
      'measurementSelectionType': measurementSelectionType.toJson(),
    if (transferLearningConfig != null)
      'transferLearningConfig': transferLearningConfig!.toJson(),
    if (studyStoppingConfig != null)
      'studyStoppingConfig': studyStoppingConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'algorithm=$algorithm',
      'observationNoise=$observationNoise',
      'measurementSelectionType=$measurementSelectionType',
    ].join(',');
    return 'StudySpec($contents)';
  }
}

/// Represents a metric to optimize.
final class StudySpec_MetricSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.MetricSpec';

  /// Required. The ID of the metric. Must not contain whitespaces and must be
  /// unique amongst all MetricSpecs.
  final String metricId;

  /// Required. The optimization goal of the metric.
  final StudySpec_MetricSpec_GoalType goal;

  /// Used for safe search. In the case, the metric will be a safety
  /// metric. You must provide a separate metric for objective metric.
  final StudySpec_MetricSpec_SafetyMetricConfig? safetyConfig;

  StudySpec_MetricSpec({
    required this.metricId,
    required this.goal,
    this.safetyConfig,
  }) : super(fullyQualifiedName);

  factory StudySpec_MetricSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_MetricSpec(
      metricId: switch (json['metricId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      goal: switch (json['goal']) {
        null => StudySpec_MetricSpec_GoalType.$default,
        Object $1 => StudySpec_MetricSpec_GoalType.fromJson($1),
      },
      safetyConfig: switch (json['safetyConfig']) {
        null => null,
        Object $1 => StudySpec_MetricSpec_SafetyMetricConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'metricId': metricId,
    'goal': goal.toJson(),
    if (safetyConfig != null) 'safetyConfig': safetyConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['metricId=$metricId', 'goal=$goal'].join(',');
    return 'MetricSpec($contents)';
  }
}

/// Used in safe optimization to specify threshold levels and risk tolerance.
final class StudySpec_MetricSpec_SafetyMetricConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.MetricSpec.SafetyMetricConfig';

  /// Safety threshold (boundary value between safe and unsafe). NOTE that if
  /// you leave SafetyMetricConfig unset, a default value of 0 will be used.
  final double safetyThreshold;

  /// Desired minimum fraction of safe trials (over total number of trials)
  /// that should be targeted by the algorithm at any time during the
  /// study (best effort). This should be between 0.0 and 1.0 and a value of
  /// 0.0 means that there is no minimum and an algorithm proceeds without
  /// targeting any specific fraction. A value of 1.0 means that the
  /// algorithm attempts to only Suggest safe Trials.
  final double? desiredMinSafeTrialsFraction;

  StudySpec_MetricSpec_SafetyMetricConfig({
    this.safetyThreshold = 0,
    this.desiredMinSafeTrialsFraction,
  }) : super(fullyQualifiedName);

  factory StudySpec_MetricSpec_SafetyMetricConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_MetricSpec_SafetyMetricConfig(
      safetyThreshold: switch (json['safetyThreshold']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      desiredMinSafeTrialsFraction:
          switch (json['desiredMinSafeTrialsFraction']) {
            null => null,
            Object $1 => decodeDouble($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (safetyThreshold.isNotDefault)
      'safetyThreshold': encodeDouble(safetyThreshold),
    if (desiredMinSafeTrialsFraction != null)
      'desiredMinSafeTrialsFraction': encodeDouble(
        desiredMinSafeTrialsFraction,
      ),
  };

  @override
  String toString() {
    final contents = [
      'safetyThreshold=$safetyThreshold',
      if (desiredMinSafeTrialsFraction != null)
        'desiredMinSafeTrialsFraction=$desiredMinSafeTrialsFraction',
    ].join(',');
    return 'SafetyMetricConfig($contents)';
  }
}

/// The available types of optimization goals.
final class StudySpec_MetricSpec_GoalType extends ProtoEnum {
  /// Goal Type will default to maximize.
  static const goalTypeUnspecified = StudySpec_MetricSpec_GoalType(
    'GOAL_TYPE_UNSPECIFIED',
  );

  /// Maximize the goal metric.
  static const maximize = StudySpec_MetricSpec_GoalType('MAXIMIZE');

  /// Minimize the goal metric.
  static const minimize = StudySpec_MetricSpec_GoalType('MINIMIZE');

  /// The default value for [StudySpec_MetricSpec_GoalType].
  static const $default = goalTypeUnspecified;

  const StudySpec_MetricSpec_GoalType(super.value);

  factory StudySpec_MetricSpec_GoalType.fromJson(Object? json) =>
      StudySpec_MetricSpec_GoalType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'GoalType.$value';
}

/// Represents a single parameter to optimize.
final class StudySpec_ParameterSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec';

  /// The value spec for a 'DOUBLE' parameter.
  final StudySpec_ParameterSpec_DoubleValueSpec? doubleValueSpec;

  /// The value spec for an 'INTEGER' parameter.
  final StudySpec_ParameterSpec_IntegerValueSpec? integerValueSpec;

  /// The value spec for a 'CATEGORICAL' parameter.
  final StudySpec_ParameterSpec_CategoricalValueSpec? categoricalValueSpec;

  /// The value spec for a 'DISCRETE' parameter.
  final StudySpec_ParameterSpec_DiscreteValueSpec? discreteValueSpec;

  /// Required. The ID of the parameter. Must not contain whitespaces and must
  /// be unique amongst all ParameterSpecs.
  final String parameterId;

  /// How the parameter should be scaled.
  /// Leave unset for `CATEGORICAL` parameters.
  final StudySpec_ParameterSpec_ScaleType scaleType;

  /// A conditional parameter node is active if the parameter's value matches
  /// the conditional node's parent_value_condition.
  ///
  /// If two items in conditional_parameter_specs have the same name, they
  /// must have disjoint parent_value_condition.
  final List<StudySpec_ParameterSpec_ConditionalParameterSpec>
  conditionalParameterSpecs;

  StudySpec_ParameterSpec({
    this.doubleValueSpec,
    this.integerValueSpec,
    this.categoricalValueSpec,
    this.discreteValueSpec,
    required this.parameterId,
    this.scaleType = StudySpec_ParameterSpec_ScaleType.$default,
    this.conditionalParameterSpecs = const [],
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec(
      doubleValueSpec: switch (json['doubleValueSpec']) {
        null => null,
        Object $1 => StudySpec_ParameterSpec_DoubleValueSpec.fromJson($1),
      },
      integerValueSpec: switch (json['integerValueSpec']) {
        null => null,
        Object $1 => StudySpec_ParameterSpec_IntegerValueSpec.fromJson($1),
      },
      categoricalValueSpec: switch (json['categoricalValueSpec']) {
        null => null,
        Object $1 => StudySpec_ParameterSpec_CategoricalValueSpec.fromJson($1),
      },
      discreteValueSpec: switch (json['discreteValueSpec']) {
        null => null,
        Object $1 => StudySpec_ParameterSpec_DiscreteValueSpec.fromJson($1),
      },
      parameterId: switch (json['parameterId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      scaleType: switch (json['scaleType']) {
        null => StudySpec_ParameterSpec_ScaleType.$default,
        Object $1 => StudySpec_ParameterSpec_ScaleType.fromJson($1),
      },
      conditionalParameterSpecs: switch (json['conditionalParameterSpecs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            StudySpec_ParameterSpec_ConditionalParameterSpec.fromJson(i),
        ],
        _ => throw const FormatException(
          '"conditionalParameterSpecs" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (doubleValueSpec != null) 'doubleValueSpec': doubleValueSpec!.toJson(),
    if (integerValueSpec != null)
      'integerValueSpec': integerValueSpec!.toJson(),
    if (categoricalValueSpec != null)
      'categoricalValueSpec': categoricalValueSpec!.toJson(),
    if (discreteValueSpec != null)
      'discreteValueSpec': discreteValueSpec!.toJson(),
    'parameterId': parameterId,
    if (scaleType.isNotDefault) 'scaleType': scaleType.toJson(),
    if (conditionalParameterSpecs.isNotDefault)
      'conditionalParameterSpecs': encodeList(conditionalParameterSpecs),
  };

  @override
  String toString() {
    final contents = [
      'parameterId=$parameterId',
      'scaleType=$scaleType',
    ].join(',');
    return 'ParameterSpec($contents)';
  }
}

/// Value specification for a parameter in `DOUBLE` type.
final class StudySpec_ParameterSpec_DoubleValueSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.DoubleValueSpec';

  /// Required. Inclusive minimum value of the parameter.
  final double minValue;

  /// Required. Inclusive maximum value of the parameter.
  final double maxValue;

  /// A default value for a `DOUBLE` parameter that is assumed to be a
  /// relatively good starting point.  Unset value signals that there is no
  /// offered starting point.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported
  /// by HyperparameterTuningJob or TrainingPipeline.
  final double? defaultValue;

  StudySpec_ParameterSpec_DoubleValueSpec({
    required this.minValue,
    required this.maxValue,
    this.defaultValue,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_DoubleValueSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec_DoubleValueSpec(
      minValue: switch (json['minValue']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      maxValue: switch (json['maxValue']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      defaultValue: switch (json['defaultValue']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    'minValue': encodeDouble(minValue),
    'maxValue': encodeDouble(maxValue),
    if (defaultValue != null) 'defaultValue': encodeDouble(defaultValue),
  };

  @override
  String toString() {
    final contents = [
      'minValue=$minValue',
      'maxValue=$maxValue',
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'DoubleValueSpec($contents)';
  }
}

/// Value specification for a parameter in `INTEGER` type.
final class StudySpec_ParameterSpec_IntegerValueSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.IntegerValueSpec';

  /// Required. Inclusive minimum value of the parameter.
  final int minValue;

  /// Required. Inclusive maximum value of the parameter.
  final int maxValue;

  /// A default value for an `INTEGER` parameter that is assumed to be a
  /// relatively good starting point.  Unset value signals that there is no
  /// offered starting point.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported
  /// by HyperparameterTuningJob or TrainingPipeline.
  final int? defaultValue;

  StudySpec_ParameterSpec_IntegerValueSpec({
    required this.minValue,
    required this.maxValue,
    this.defaultValue,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_IntegerValueSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec_IntegerValueSpec(
      minValue: switch (json['minValue']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      maxValue: switch (json['maxValue']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      defaultValue: switch (json['defaultValue']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    'minValue': encodeInt64(minValue),
    'maxValue': encodeInt64(maxValue),
    if (defaultValue != null) 'defaultValue': encodeInt64(defaultValue),
  };

  @override
  String toString() {
    final contents = [
      'minValue=$minValue',
      'maxValue=$maxValue',
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'IntegerValueSpec($contents)';
  }
}

/// Value specification for a parameter in `CATEGORICAL` type.
final class StudySpec_ParameterSpec_CategoricalValueSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.CategoricalValueSpec';

  /// Required. The list of possible categories.
  final List<String> values;

  /// A default value for a `CATEGORICAL` parameter that is assumed to be a
  /// relatively good starting point.  Unset value signals that there is no
  /// offered starting point.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported
  /// by HyperparameterTuningJob or TrainingPipeline.
  final String? defaultValue;

  StudySpec_ParameterSpec_CategoricalValueSpec({
    required this.values,
    this.defaultValue,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_CategoricalValueSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec_CategoricalValueSpec(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
      defaultValue: switch (json['defaultValue']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'values': values,
    if (defaultValue != null) 'defaultValue': defaultValue,
  };

  @override
  String toString() {
    final contents = [
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'CategoricalValueSpec($contents)';
  }
}

/// Value specification for a parameter in `DISCRETE` type.
final class StudySpec_ParameterSpec_DiscreteValueSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.DiscreteValueSpec';

  /// Required. A list of possible values.
  /// The list should be in increasing order and at least 1e-10 apart.
  /// For instance, this parameter might have possible settings of 1.5, 2.5,
  /// and 4.0. This list should not contain more than 1,000 values.
  final List<double> values;

  /// A default value for a `DISCRETE` parameter that is assumed to be a
  /// relatively good starting point.  Unset value signals that there is no
  /// offered starting point.  It automatically rounds to the
  /// nearest feasible discrete point.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported
  /// by HyperparameterTuningJob or TrainingPipeline.
  final double? defaultValue;

  StudySpec_ParameterSpec_DiscreteValueSpec({
    required this.values,
    this.defaultValue,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_DiscreteValueSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec_DiscreteValueSpec(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
      defaultValue: switch (json['defaultValue']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    'values': values,
    if (defaultValue != null) 'defaultValue': encodeDouble(defaultValue),
  };

  @override
  String toString() {
    final contents = [
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'DiscreteValueSpec($contents)';
  }
}

/// Represents a parameter spec with condition from its parent parameter.
final class StudySpec_ParameterSpec_ConditionalParameterSpec
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.ConditionalParameterSpec';

  /// The spec for matching values from a parent parameter of
  /// `DISCRETE` type.
  final StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition?
  parentDiscreteValues;

  /// The spec for matching values from a parent parameter of `INTEGER`
  /// type.
  final StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition?
  parentIntValues;

  /// The spec for matching values from a parent parameter of
  /// `CATEGORICAL` type.
  final StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition?
  parentCategoricalValues;

  /// Required. The spec for a conditional parameter.
  final StudySpec_ParameterSpec? parameterSpec;

  StudySpec_ParameterSpec_ConditionalParameterSpec({
    this.parentDiscreteValues,
    this.parentIntValues,
    this.parentCategoricalValues,
    required this.parameterSpec,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_ConditionalParameterSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec_ConditionalParameterSpec(
      parentDiscreteValues: switch (json['parentDiscreteValues']) {
        null => null,
        Object $1 =>
          StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.fromJson(
            $1,
          ),
      },
      parentIntValues: switch (json['parentIntValues']) {
        null => null,
        Object $1 =>
          StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.fromJson(
            $1,
          ),
      },
      parentCategoricalValues: switch (json['parentCategoricalValues']) {
        null => null,
        Object $1 =>
          StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition.fromJson(
            $1,
          ),
      },
      parameterSpec: switch (json['parameterSpec']) {
        null => null,
        Object $1 => StudySpec_ParameterSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (parentDiscreteValues != null)
      'parentDiscreteValues': parentDiscreteValues!.toJson(),
    if (parentIntValues != null) 'parentIntValues': parentIntValues!.toJson(),
    if (parentCategoricalValues != null)
      'parentCategoricalValues': parentCategoricalValues!.toJson(),
    if (parameterSpec != null) 'parameterSpec': parameterSpec!.toJson(),
  };

  @override
  String toString() => 'ConditionalParameterSpec()';
}

/// Represents the spec to match discrete values from parent parameter.
final class StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition';

  /// Required. Matches values of the parent parameter of 'DISCRETE' type.
  /// All values must exist in `discrete_value_spec` of parent parameter.
  ///
  /// The Epsilon of the value matching is 1e-10.
  final List<double> values;

  StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition({
    required this.values,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'values': values};

  @override
  String toString() => 'DiscreteValueCondition()';
}

/// Represents the spec to match integer values from parent parameter.
final class StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition';

  /// Required. Matches values of the parent parameter of 'INTEGER' type.
  /// All values must lie in `integer_value_spec` of parent parameter.
  final List<int> values;

  StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition({
    required this.values,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'values': values};

  @override
  String toString() => 'IntValueCondition()';
}

/// Represents the spec to match categorical values from parent parameter.
final class StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition';

  /// Required. Matches values of the parent parameter of 'CATEGORICAL'
  /// type. All values must exist in `categorical_value_spec` of parent
  /// parameter.
  final List<String> values;

  StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition({
    required this.values,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'values': values};

  @override
  String toString() => 'CategoricalValueCondition()';
}

/// The type of scaling that should be applied to this parameter.
final class StudySpec_ParameterSpec_ScaleType extends ProtoEnum {
  /// By default, no scaling is applied.
  static const scaleTypeUnspecified = StudySpec_ParameterSpec_ScaleType(
    'SCALE_TYPE_UNSPECIFIED',
  );

  /// Scales the feasible space to (0, 1) linearly.
  static const unitLinearScale = StudySpec_ParameterSpec_ScaleType(
    'UNIT_LINEAR_SCALE',
  );

  /// Scales the feasible space logarithmically to (0, 1). The entire
  /// feasible space must be strictly positive.
  static const unitLogScale = StudySpec_ParameterSpec_ScaleType(
    'UNIT_LOG_SCALE',
  );

  /// Scales the feasible space "reverse" logarithmically to (0, 1). The
  /// result is that values close to the top of the feasible space are spread
  /// out more than points near the bottom. The entire feasible space must be
  /// strictly positive.
  static const unitReverseLogScale = StudySpec_ParameterSpec_ScaleType(
    'UNIT_REVERSE_LOG_SCALE',
  );

  /// The default value for [StudySpec_ParameterSpec_ScaleType].
  static const $default = scaleTypeUnspecified;

  const StudySpec_ParameterSpec_ScaleType(super.value);

  factory StudySpec_ParameterSpec_ScaleType.fromJson(Object? json) =>
      StudySpec_ParameterSpec_ScaleType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ScaleType.$value';
}

/// The decay curve automated stopping rule builds a Gaussian Process
/// Regressor to predict the final objective value of a Trial based on the
/// already completed Trials and the intermediate measurements of the current
/// Trial. Early stopping is requested for the current Trial if there is very
/// low probability to exceed the optimal value found so far.
final class StudySpec_DecayCurveAutomatedStoppingSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.DecayCurveAutomatedStoppingSpec';

  /// True if
  /// `Measurement.elapsed_duration`
  /// is used as the x-axis of each Trials Decay Curve. Otherwise,
  /// `Measurement.step_count`
  /// will be used as the x-axis.
  final bool useElapsedDuration;

  StudySpec_DecayCurveAutomatedStoppingSpec({this.useElapsedDuration = false})
    : super(fullyQualifiedName);

  factory StudySpec_DecayCurveAutomatedStoppingSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_DecayCurveAutomatedStoppingSpec(
      useElapsedDuration: switch (json['useElapsedDuration']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useElapsedDuration.isNotDefault)
      'useElapsedDuration': useElapsedDuration,
  };

  @override
  String toString() {
    final contents = ['useElapsedDuration=$useElapsedDuration'].join(',');
    return 'DecayCurveAutomatedStoppingSpec($contents)';
  }
}

/// The median automated stopping rule stops a pending Trial if the Trial's
/// best objective_value is strictly below the median 'performance' of all
/// completed Trials reported up to the Trial's last measurement.
/// Currently, 'performance' refers to the running average of the objective
/// values reported by the Trial in each measurement.
final class StudySpec_MedianAutomatedStoppingSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.MedianAutomatedStoppingSpec';

  /// True if median automated stopping rule applies on
  /// `Measurement.elapsed_duration`.
  /// It means that elapsed_duration field of latest measurement of current
  /// Trial is used to compute median objective value for each completed
  /// Trials.
  final bool useElapsedDuration;

  StudySpec_MedianAutomatedStoppingSpec({this.useElapsedDuration = false})
    : super(fullyQualifiedName);

  factory StudySpec_MedianAutomatedStoppingSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_MedianAutomatedStoppingSpec(
      useElapsedDuration: switch (json['useElapsedDuration']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useElapsedDuration.isNotDefault)
      'useElapsedDuration': useElapsedDuration,
  };

  @override
  String toString() {
    final contents = ['useElapsedDuration=$useElapsedDuration'].join(',');
    return 'MedianAutomatedStoppingSpec($contents)';
  }
}

/// Configuration for ConvexAutomatedStoppingSpec.
/// When there are enough completed trials (configured by
/// min_measurement_count), for pending trials with enough measurements and
/// steps, the policy first computes an overestimate of the objective value at
/// max_num_steps according to the slope of the incomplete objective value
/// curve. No prediction can be made if the curve is completely flat. If the
/// overestimation is worse than the best objective value of the completed
/// trials, this pending trial will be early-stopped, but a last measurement
/// will be added to the pending trial with max_num_steps and predicted
/// objective value from the autoregression model.
final class StudySpec_ConvexAutomatedStoppingSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ConvexAutomatedStoppingSpec';

  /// Steps used in predicting the final objective for early stopped trials. In
  /// general, it's set to be the same as the defined steps in training /
  /// tuning. If not defined, it will learn it from the completed trials. When
  /// use_steps is false, this field is set to the maximum elapsed seconds.
  final int maxStepCount;

  /// Minimum number of steps for a trial to complete. Trials which do not have
  /// a measurement with step_count > min_step_count won't be considered for
  /// early stopping. It's ok to set it to 0, and a trial can be early stopped
  /// at any stage. By default, min_step_count is set to be one-tenth of the
  /// max_step_count.
  /// When use_elapsed_duration is true, this field is set to the minimum
  /// elapsed seconds.
  final int minStepCount;

  /// The minimal number of measurements in a Trial.  Early-stopping checks
  /// will not trigger if less than min_measurement_count+1 completed trials or
  /// pending trials with less than min_measurement_count measurements. If not
  /// defined, the default value is 5.
  final int minMeasurementCount;

  /// The hyper-parameter name used in the tuning job that stands for learning
  /// rate. Leave it blank if learning rate is not in a parameter in tuning.
  /// The learning_rate is used to estimate the objective value of the ongoing
  /// trial.
  final String learningRateParameterName;

  /// This bool determines whether or not the rule is applied based on
  /// elapsed_secs or steps. If use_elapsed_duration==false, the early stopping
  /// decision is made according to the predicted objective values according to
  /// the target steps. If use_elapsed_duration==true, elapsed_secs is used
  /// instead of steps. Also, in this case, the parameters max_num_steps and
  /// min_num_steps are overloaded to contain max_elapsed_seconds and
  /// min_elapsed_seconds.
  final bool useElapsedDuration;

  /// ConvexAutomatedStoppingSpec by default only updates the trials that needs
  /// to be early stopped using a newly trained auto-regressive model. When
  /// this flag is set to True, all stopped trials from the beginning are
  /// potentially updated in terms of their `final_measurement`. Also, note
  /// that the training logic of autoregressive models is different in this
  /// case. Enabling this option has shown better results and this may be the
  /// default option in the future.
  final bool? updateAllStoppedTrials;

  StudySpec_ConvexAutomatedStoppingSpec({
    this.maxStepCount = 0,
    this.minStepCount = 0,
    this.minMeasurementCount = 0,
    this.learningRateParameterName = '',
    this.useElapsedDuration = false,
    this.updateAllStoppedTrials,
  }) : super(fullyQualifiedName);

  factory StudySpec_ConvexAutomatedStoppingSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_ConvexAutomatedStoppingSpec(
      maxStepCount: switch (json['maxStepCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      minStepCount: switch (json['minStepCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      minMeasurementCount: switch (json['minMeasurementCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      learningRateParameterName: switch (json['learningRateParameterName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      useElapsedDuration: switch (json['useElapsedDuration']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      updateAllStoppedTrials: switch (json['updateAllStoppedTrials']) {
        null => null,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxStepCount.isNotDefault) 'maxStepCount': encodeInt64(maxStepCount),
    if (minStepCount.isNotDefault) 'minStepCount': encodeInt64(minStepCount),
    if (minMeasurementCount.isNotDefault)
      'minMeasurementCount': encodeInt64(minMeasurementCount),
    if (learningRateParameterName.isNotDefault)
      'learningRateParameterName': learningRateParameterName,
    if (useElapsedDuration.isNotDefault)
      'useElapsedDuration': useElapsedDuration,
    if (updateAllStoppedTrials != null)
      'updateAllStoppedTrials': updateAllStoppedTrials,
  };

  @override
  String toString() {
    final contents = [
      'maxStepCount=$maxStepCount',
      'minStepCount=$minStepCount',
      'minMeasurementCount=$minMeasurementCount',
      'learningRateParameterName=$learningRateParameterName',
      'useElapsedDuration=$useElapsedDuration',
      if (updateAllStoppedTrials != null)
        'updateAllStoppedTrials=$updateAllStoppedTrials',
    ].join(',');
    return 'ConvexAutomatedStoppingSpec($contents)';
  }
}

/// Configuration for ConvexStopPolicy.
final class StudySpec_ConvexStopConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ConvexStopConfig';

  /// Steps used in predicting the final objective for early stopped trials. In
  /// general, it's set to be the same as the defined steps in training /
  /// tuning. When use_steps is false, this field is set to the maximum elapsed
  /// seconds.
  final int maxNumSteps;

  /// Minimum number of steps for a trial to complete. Trials which do not have
  /// a measurement with num_steps > min_num_steps won't be considered for
  /// early stopping. It's ok to set it to 0, and a trial can be early stopped
  /// at any stage. By default, min_num_steps is set to be one-tenth of the
  /// max_num_steps.
  /// When use_steps is false, this field is set to the minimum elapsed
  /// seconds.
  final int minNumSteps;

  /// The number of Trial measurements used in autoregressive model for
  /// value prediction. A trial won't be considered early stopping if has fewer
  /// measurement points.
  final int autoregressiveOrder;

  /// The hyper-parameter name used in the tuning job that stands for learning
  /// rate. Leave it blank if learning rate is not in a parameter in tuning.
  /// The learning_rate is used to estimate the objective value of the ongoing
  /// trial.
  final String learningRateParameterName;

  /// This bool determines whether or not the rule is applied based on
  /// elapsed_secs or steps. If use_seconds==false, the early stopping decision
  /// is made according to the predicted objective values according to the
  /// target steps. If use_seconds==true, elapsed_secs is used instead of
  /// steps. Also, in this case, the parameters max_num_steps and min_num_steps
  /// are overloaded to contain max_elapsed_seconds and min_elapsed_seconds.
  final bool useSeconds;

  StudySpec_ConvexStopConfig({
    this.maxNumSteps = 0,
    this.minNumSteps = 0,
    this.autoregressiveOrder = 0,
    this.learningRateParameterName = '',
    this.useSeconds = false,
  }) : super(fullyQualifiedName);

  factory StudySpec_ConvexStopConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_ConvexStopConfig(
      maxNumSteps: switch (json['maxNumSteps']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      minNumSteps: switch (json['minNumSteps']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      autoregressiveOrder: switch (json['autoregressiveOrder']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      learningRateParameterName: switch (json['learningRateParameterName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      useSeconds: switch (json['useSeconds']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxNumSteps.isNotDefault) 'maxNumSteps': encodeInt64(maxNumSteps),
    if (minNumSteps.isNotDefault) 'minNumSteps': encodeInt64(minNumSteps),
    if (autoregressiveOrder.isNotDefault)
      'autoregressiveOrder': encodeInt64(autoregressiveOrder),
    if (learningRateParameterName.isNotDefault)
      'learningRateParameterName': learningRateParameterName,
    if (useSeconds.isNotDefault) 'useSeconds': useSeconds,
  };

  @override
  String toString() {
    final contents = [
      'maxNumSteps=$maxNumSteps',
      'minNumSteps=$minNumSteps',
      'autoregressiveOrder=$autoregressiveOrder',
      'learningRateParameterName=$learningRateParameterName',
      'useSeconds=$useSeconds',
    ].join(',');
    return 'ConvexStopConfig($contents)';
  }
}

/// This contains flag for manually disabling transfer learning for a study.
/// The names of prior studies being used for transfer learning (if any)
/// are also listed here.
final class StudySpec_TransferLearningConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.TransferLearningConfig';

  /// Flag to to manually prevent vizier from using transfer learning on a
  /// new study. Otherwise, vizier will automatically determine whether or not
  /// to use transfer learning.
  final bool disableTransferLearning;

  /// Output only. Names of previously completed studies
  final List<String> priorStudyNames;

  StudySpec_TransferLearningConfig({
    this.disableTransferLearning = false,
    this.priorStudyNames = const [],
  }) : super(fullyQualifiedName);

  factory StudySpec_TransferLearningConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_TransferLearningConfig(
      disableTransferLearning: switch (json['disableTransferLearning']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      priorStudyNames: switch (json['priorStudyNames']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"priorStudyNames" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (disableTransferLearning.isNotDefault)
      'disableTransferLearning': disableTransferLearning,
    if (priorStudyNames.isNotDefault) 'priorStudyNames': priorStudyNames,
  };

  @override
  String toString() {
    final contents = [
      'disableTransferLearning=$disableTransferLearning',
    ].join(',');
    return 'TransferLearningConfig($contents)';
  }
}

/// The configuration (stopping conditions) for automated stopping of a Study.
/// Conditions include trial budgets, time budgets, and convergence detection.
final class StudySpec_StudyStoppingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.StudyStoppingConfig';

  /// If true, a Study enters STOPPING_ASAP whenever it would normally enters
  /// STOPPING state.
  ///
  /// The bottom line is: set to true if you want to interrupt on-going
  /// evaluations of Trials as soon as the study stopping condition is met.
  /// (Please see Study.State documentation for the source of truth).
  final protobuf.BoolValue? shouldStopAsap;

  /// Each "stopping rule" in this proto specifies an "if" condition. Before
  /// Vizier would generate a new suggestion, it first checks each specified
  /// stopping rule, from top to bottom in this list.
  /// Note that the first few rules (e.g. minimum_runtime_constraint,
  /// min_num_trials) will prevent other stopping rules from being evaluated
  /// until they are met. For example, setting `min_num_trials=5` and
  /// `always_stop_after= 1 hour` means that the Study will ONLY stop after it
  /// has 5 COMPLETED trials, even if more than an hour has passed since its
  /// creation. It follows the first applicable rule (whose "if" condition is
  /// satisfied) to make a stopping decision. If none of the specified rules
  /// are applicable, then Vizier decides that the study should not stop.
  /// If Vizier decides that the study should stop, the study enters
  /// STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
  /// IMPORTANT: The automatic study state transition happens precisely as
  /// described above; that is, deleting trials or updating StudyConfig NEVER
  /// automatically moves the study state back to ACTIVE. If you want to
  /// _resume_ a Study that was stopped, 1) change the stopping conditions if
  /// necessary, 2) activate the study, and then 3) ask for suggestions.
  /// If the specified time or duration has not passed, do not stop the
  /// study.
  final StudyTimeConstraint? minimumRuntimeConstraint;

  /// If the specified time or duration has passed, stop the study.
  final StudyTimeConstraint? maximumRuntimeConstraint;

  /// If there are fewer than this many COMPLETED trials, do not stop the
  /// study.
  final protobuf.Int32Value? minNumTrials;

  /// If there are more than this many trials, stop the study.
  final protobuf.Int32Value? maxNumTrials;

  /// If the objective value has not improved for this many consecutive
  /// trials, stop the study.
  ///
  /// WARNING: Effective only for single-objective studies.
  final protobuf.Int32Value? maxNumTrialsNoProgress;

  /// If the objective value has not improved for this much time, stop the
  /// study.
  ///
  /// WARNING: Effective only for single-objective studies.
  final protobuf.Duration? maxDurationNoProgress;

  StudySpec_StudyStoppingConfig({
    this.shouldStopAsap,
    this.minimumRuntimeConstraint,
    this.maximumRuntimeConstraint,
    this.minNumTrials,
    this.maxNumTrials,
    this.maxNumTrialsNoProgress,
    this.maxDurationNoProgress,
  }) : super(fullyQualifiedName);

  factory StudySpec_StudyStoppingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StudySpec_StudyStoppingConfig(
      shouldStopAsap: switch (json['shouldStopAsap']) {
        null => null,
        Object $1 => protobuf.BoolValue.fromJson($1),
      },
      minimumRuntimeConstraint: switch (json['minimumRuntimeConstraint']) {
        null => null,
        Object $1 => StudyTimeConstraint.fromJson($1),
      },
      maximumRuntimeConstraint: switch (json['maximumRuntimeConstraint']) {
        null => null,
        Object $1 => StudyTimeConstraint.fromJson($1),
      },
      minNumTrials: switch (json['minNumTrials']) {
        null => null,
        Object $1 => protobuf.Int32Value.fromJson($1),
      },
      maxNumTrials: switch (json['maxNumTrials']) {
        null => null,
        Object $1 => protobuf.Int32Value.fromJson($1),
      },
      maxNumTrialsNoProgress: switch (json['maxNumTrialsNoProgress']) {
        null => null,
        Object $1 => protobuf.Int32Value.fromJson($1),
      },
      maxDurationNoProgress: switch (json['maxDurationNoProgress']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (shouldStopAsap != null) 'shouldStopAsap': shouldStopAsap!.toJson(),
    if (minimumRuntimeConstraint != null)
      'minimumRuntimeConstraint': minimumRuntimeConstraint!.toJson(),
    if (maximumRuntimeConstraint != null)
      'maximumRuntimeConstraint': maximumRuntimeConstraint!.toJson(),
    if (minNumTrials != null) 'minNumTrials': minNumTrials!.toJson(),
    if (maxNumTrials != null) 'maxNumTrials': maxNumTrials!.toJson(),
    if (maxNumTrialsNoProgress != null)
      'maxNumTrialsNoProgress': maxNumTrialsNoProgress!.toJson(),
    if (maxDurationNoProgress != null)
      'maxDurationNoProgress': maxDurationNoProgress!.toJson(),
  };

  @override
  String toString() => 'StudyStoppingConfig()';
}

/// The available search algorithms for the Study.
final class StudySpec_Algorithm extends ProtoEnum {
  /// The default algorithm used by Vertex AI for [hyperparameter
  /// tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
  /// and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
  static const algorithmUnspecified = StudySpec_Algorithm(
    'ALGORITHM_UNSPECIFIED',
  );

  /// Simple grid search within the feasible space. To use grid search,
  /// all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
  static const gridSearch = StudySpec_Algorithm('GRID_SEARCH');

  /// Simple random search within the feasible space.
  static const randomSearch = StudySpec_Algorithm('RANDOM_SEARCH');

  /// The default value for [StudySpec_Algorithm].
  static const $default = algorithmUnspecified;

  const StudySpec_Algorithm(super.value);

  factory StudySpec_Algorithm.fromJson(Object? json) =>
      StudySpec_Algorithm(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Algorithm.$value';
}

/// Describes the noise level of the repeated observations.
///
/// "Noisy" means that the repeated observations with the same Trial parameters
/// may lead to different metric evaluations.
final class StudySpec_ObservationNoise extends ProtoEnum {
  /// The default noise level chosen by Vertex AI.
  static const observationNoiseUnspecified = StudySpec_ObservationNoise(
    'OBSERVATION_NOISE_UNSPECIFIED',
  );

  /// Vertex AI assumes that the objective function is (nearly)
  /// perfectly reproducible, and will never repeat the same Trial
  /// parameters.
  static const low = StudySpec_ObservationNoise('LOW');

  /// Vertex AI will estimate the amount of noise in metric
  /// evaluations, it may repeat the same Trial parameters more than once.
  static const high = StudySpec_ObservationNoise('HIGH');

  /// The default value for [StudySpec_ObservationNoise].
  static const $default = observationNoiseUnspecified;

  const StudySpec_ObservationNoise(super.value);

  factory StudySpec_ObservationNoise.fromJson(Object? json) =>
      StudySpec_ObservationNoise(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ObservationNoise.$value';
}

/// This indicates which measurement to use if/when the service automatically
/// selects the final measurement from previously reported intermediate
/// measurements. Choose this based on two considerations:
///  A) Do you expect your measurements to monotonically improve?
///     If so, choose LAST_MEASUREMENT. On the other hand, if you're in a
///     situation where your system can "over-train" and you expect the
///     performance to get better for a while but then start declining,
///     choose BEST_MEASUREMENT.
///  B) Are your measurements significantly noisy and/or irreproducible?
///     If so, BEST_MEASUREMENT will tend to be over-optimistic, and it
///     may be better to choose LAST_MEASUREMENT.
///  If both or neither of (A) and (B) apply, it doesn't matter which
///  selection type is chosen.
final class StudySpec_MeasurementSelectionType extends ProtoEnum {
  /// Will be treated as LAST_MEASUREMENT.
  static const measurementSelectionTypeUnspecified =
      StudySpec_MeasurementSelectionType(
        'MEASUREMENT_SELECTION_TYPE_UNSPECIFIED',
      );

  /// Use the last measurement reported.
  static const lastMeasurement = StudySpec_MeasurementSelectionType(
    'LAST_MEASUREMENT',
  );

  /// Use the best measurement reported.
  static const bestMeasurement = StudySpec_MeasurementSelectionType(
    'BEST_MEASUREMENT',
  );

  /// The default value for [StudySpec_MeasurementSelectionType].
  static const $default = measurementSelectionTypeUnspecified;

  const StudySpec_MeasurementSelectionType(super.value);

  factory StudySpec_MeasurementSelectionType.fromJson(Object? json) =>
      StudySpec_MeasurementSelectionType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'MeasurementSelectionType.$value';
}

/// A message representing a Measurement of a Trial. A Measurement contains
/// the Metrics got by executing a Trial using suggested hyperparameter
/// values.
final class Measurement extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Measurement';

  /// Output only. Time that the Trial has been running at the point of this
  /// Measurement.
  final protobuf.Duration? elapsedDuration;

  /// Output only. The number of steps the machine learning model has been
  /// trained for. Must be non-negative.
  final int stepCount;

  /// Output only. A list of metrics got by evaluating the objective functions
  /// using suggested Parameter values.
  final List<Measurement_Metric> metrics;

  Measurement({
    this.elapsedDuration,
    this.stepCount = 0,
    this.metrics = const [],
  }) : super(fullyQualifiedName);

  factory Measurement.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Measurement(
      elapsedDuration: switch (json['elapsedDuration']) {
        null => null,
        Object $1 => protobuf.Duration.fromJson($1),
      },
      stepCount: switch (json['stepCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      metrics: switch (json['metrics']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Measurement_Metric.fromJson(i),
        ],
        _ => throw const FormatException('"metrics" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (elapsedDuration != null) 'elapsedDuration': elapsedDuration!.toJson(),
    if (stepCount.isNotDefault) 'stepCount': encodeInt64(stepCount),
    if (metrics.isNotDefault) 'metrics': encodeList(metrics),
  };

  @override
  String toString() {
    final contents = ['stepCount=$stepCount'].join(',');
    return 'Measurement($contents)';
  }
}

/// A message representing a metric in the measurement.
final class Measurement_Metric extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Measurement.Metric';

  /// Output only. The ID of the Metric. The Metric should be defined in
  /// [StudySpec's Metrics][google.cloud.aiplatform.v1beta1.StudySpec.metrics].
  final String metricId;

  /// Output only. The value for this metric.
  final double value;

  Measurement_Metric({this.metricId = '', this.value = 0})
    : super(fullyQualifiedName);

  factory Measurement_Metric.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Measurement_Metric(
      metricId: switch (json['metricId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      value: switch (json['value']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (metricId.isNotDefault) 'metricId': metricId,
    if (value.isNotDefault) 'value': encodeDouble(value),
  };

  @override
  String toString() {
    final contents = ['metricId=$metricId', 'value=$value'].join(',');
    return 'Metric($contents)';
  }
}

/// Tensorboard is a physical database that stores users' training metrics.
/// A default Tensorboard is provided in each region of a Google Cloud project.
/// If needed users can also create extra Tensorboards in their projects.
final class Tensorboard extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tensorboard';

  /// Output only. Name of the Tensorboard.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String name;

  /// Required. User provided name of this Tensorboard.
  final String displayName;

  /// Description of this Tensorboard.
  final String description;

  /// Customer-managed encryption key spec for a Tensorboard. If set, this
  /// Tensorboard and all sub-resources of this Tensorboard will be secured by
  /// this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Consumer project Cloud Storage path prefix used to store blob
  /// data, which can either be a bucket or directory. Does not end with a '/'.
  final String blobStoragePathPrefix;

  /// Output only. The number of Runs stored in this Tensorboard.
  final int runCount;

  /// Output only. Timestamp when this Tensorboard was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Tensorboard was last updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize your Tensorboards.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Tensorboard
  /// (System labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> labels;

  /// Used to perform a consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// Used to indicate if the TensorBoard instance is the default one.
  /// Each project & region can have at most one default TensorBoard instance.
  /// Creation of a default TensorBoard instance and updating an existing
  /// TensorBoard instance to be default will mark all other TensorBoard
  /// instances (if any) as non default.
  final bool isDefault;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool satisfiesPzi;

  Tensorboard({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.encryptionSpec,
    this.blobStoragePathPrefix = '',
    this.runCount = 0,
    this.createTime,
    this.updateTime,
    this.labels = const {},
    this.etag = '',
    this.isDefault = false,
    this.satisfiesPzs = false,
    this.satisfiesPzi = false,
  }) : super(fullyQualifiedName);

  factory Tensorboard.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Tensorboard(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      blobStoragePathPrefix: switch (json['blobStoragePathPrefix']) {
        null => '',
        Object $1 => decodeString($1),
      },
      runCount: switch (json['runCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      isDefault: switch (json['isDefault']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      satisfiesPzi: switch (json['satisfiesPzi']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (blobStoragePathPrefix.isNotDefault)
      'blobStoragePathPrefix': blobStoragePathPrefix,
    if (runCount.isNotDefault) 'runCount': runCount,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (etag.isNotDefault) 'etag': etag,
    if (isDefault.isNotDefault) 'isDefault': isDefault,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (satisfiesPzi.isNotDefault) 'satisfiesPzi': satisfiesPzi,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'blobStoragePathPrefix=$blobStoragePathPrefix',
      'runCount=$runCount',
      'etag=$etag',
      'isDefault=$isDefault',
      'satisfiesPzs=$satisfiesPzs',
      'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Tensorboard($contents)';
  }
}

/// All the data stored in a TensorboardTimeSeries.
final class TimeSeriesData extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TimeSeriesData';

  /// Required. The ID of the TensorboardTimeSeries, which will become the final
  /// component of the TensorboardTimeSeries' resource name
  final String tensorboardTimeSeriesId;

  /// Required. Immutable. The value type of this time series. All the values in
  /// this time series data must match this value type.
  final TensorboardTimeSeries_ValueType valueType;

  /// Required. Data points in this time series.
  final List<TimeSeriesDataPoint> values;

  TimeSeriesData({
    required this.tensorboardTimeSeriesId,
    required this.valueType,
    required this.values,
  }) : super(fullyQualifiedName);

  factory TimeSeriesData.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TimeSeriesData(
      tensorboardTimeSeriesId: switch (json['tensorboardTimeSeriesId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      valueType: switch (json['valueType']) {
        null => TensorboardTimeSeries_ValueType.$default,
        Object $1 => TensorboardTimeSeries_ValueType.fromJson($1),
      },
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TimeSeriesDataPoint.fromJson(i),
        ],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'tensorboardTimeSeriesId': tensorboardTimeSeriesId,
    'valueType': valueType.toJson(),
    'values': encodeList(values),
  };

  @override
  String toString() {
    final contents = [
      'tensorboardTimeSeriesId=$tensorboardTimeSeriesId',
      'valueType=$valueType',
    ].join(',');
    return 'TimeSeriesData($contents)';
  }
}

/// A TensorboardTimeSeries data point.
final class TimeSeriesDataPoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TimeSeriesDataPoint';

  /// A scalar value.
  final Scalar? scalar;

  /// A tensor value.
  final TensorboardTensor? tensor;

  /// A blob sequence value.
  final TensorboardBlobSequence? blobs;

  /// Wall clock timestamp when this data point is generated by the end user.
  final protobuf.Timestamp? wallTime;

  /// Step index of this data point within the run.
  final int step;

  TimeSeriesDataPoint({
    this.scalar,
    this.tensor,
    this.blobs,
    this.wallTime,
    this.step = 0,
  }) : super(fullyQualifiedName);

  factory TimeSeriesDataPoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TimeSeriesDataPoint(
      scalar: switch (json['scalar']) {
        null => null,
        Object $1 => Scalar.fromJson($1),
      },
      tensor: switch (json['tensor']) {
        null => null,
        Object $1 => TensorboardTensor.fromJson($1),
      },
      blobs: switch (json['blobs']) {
        null => null,
        Object $1 => TensorboardBlobSequence.fromJson($1),
      },
      wallTime: switch (json['wallTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      step: switch (json['step']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (scalar != null) 'scalar': scalar!.toJson(),
    if (tensor != null) 'tensor': tensor!.toJson(),
    if (blobs != null) 'blobs': blobs!.toJson(),
    if (wallTime != null) 'wallTime': wallTime!.toJson(),
    if (step.isNotDefault) 'step': encodeInt64(step),
  };

  @override
  String toString() {
    final contents = ['step=$step'].join(',');
    return 'TimeSeriesDataPoint($contents)';
  }
}

/// One point viewable on a scalar metric plot.
final class Scalar extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Scalar';

  /// Value of the point at this step / timestamp.
  final double value;

  Scalar({this.value = 0}) : super(fullyQualifiedName);

  factory Scalar.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Scalar(
      value: switch (json['value']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (value.isNotDefault) 'value': encodeDouble(value)};

  @override
  String toString() {
    final contents = ['value=$value'].join(',');
    return 'Scalar($contents)';
  }
}

/// One point viewable on a tensor metric plot.
final class TensorboardTensor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardTensor';

  /// Required. Serialized form of
  /// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/tensor.proto
  final Uint8List value;

  /// Optional. Version number of TensorProto used to serialize
  /// `value`.
  final int versionNumber;

  TensorboardTensor({required this.value, this.versionNumber = 0})
    : super(fullyQualifiedName);

  factory TensorboardTensor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TensorboardTensor(
      value: switch (json['value']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
      versionNumber: switch (json['versionNumber']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    'value': encodeBytes(value),
    if (versionNumber.isNotDefault) 'versionNumber': versionNumber,
  };

  @override
  String toString() {
    final contents = ['value=$value', 'versionNumber=$versionNumber'].join(',');
    return 'TensorboardTensor($contents)';
  }
}

/// One point viewable on a blob metric plot, but mostly just a wrapper message
/// to work around repeated fields can't be used directly within `oneof` fields.
final class TensorboardBlobSequence extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardBlobSequence';

  /// List of blobs contained within the sequence.
  final List<TensorboardBlob> values;

  TensorboardBlobSequence({this.values = const []}) : super(fullyQualifiedName);

  factory TensorboardBlobSequence.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TensorboardBlobSequence(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TensorboardBlob.fromJson(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (values.isNotDefault) 'values': encodeList(values)};

  @override
  String toString() => 'TensorboardBlobSequence()';
}

/// One blob (e.g, image, graph) viewable on a blob metric plot.
final class TensorboardBlob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardBlob';

  /// Output only. A URI safe key uniquely identifying a blob. Can be used to
  /// locate the blob stored in the Cloud Storage bucket of the consumer project.
  final String id;

  /// Optional. The bytes of the blob is not present unless it's returned by the
  /// ReadTensorboardBlobData endpoint.
  final Uint8List data;

  TensorboardBlob({this.id = '', Uint8List? data})
    : data = data ?? Uint8List(0),
      super(fullyQualifiedName);

  factory TensorboardBlob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TensorboardBlob(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      data: switch (json['data']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    if (data.isNotDefault) 'data': encodeBytes(data),
  };

  @override
  String toString() {
    final contents = ['id=$id', 'data=$data'].join(',');
    return 'TensorboardBlob($contents)';
  }
}

/// A TensorboardExperiment is a group of TensorboardRuns, that are typically the
/// results of a training job run, in a Tensorboard.
final class TensorboardExperiment extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardExperiment';

  /// Output only. Name of the TensorboardExperiment.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String name;

  /// User provided name of this TensorboardExperiment.
  final String displayName;

  /// Description of this TensorboardExperiment.
  final String description;

  /// Output only. Timestamp when this TensorboardExperiment was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this TensorboardExperiment was last updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize your
  /// TensorboardExperiment.
  ///
  /// Label keys and values cannot be longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Dataset (System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with `aiplatform.googleapis.com/`
  /// and are immutable. The following system labels exist for each Dataset:
  ///
  /// * `aiplatform.googleapis.com/dataset_metadata_schema`: output only. Its
  ///    value is the
  ///    [metadata_schema's][google.cloud.aiplatform.v1beta1.Dataset.metadata_schema_uri]
  ///    title.
  final Map<String, String> labels;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// Immutable. Source of the TensorboardExperiment. Example: a custom training
  /// job.
  final String source;

  TensorboardExperiment({
    this.name = '',
    this.displayName = '',
    this.description = '',
    this.createTime,
    this.updateTime,
    this.labels = const {},
    this.etag = '',
    this.source = '',
  }) : super(fullyQualifiedName);

  factory TensorboardExperiment.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TensorboardExperiment(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      source: switch (json['source']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (etag.isNotDefault) 'etag': etag,
    if (source.isNotDefault) 'source': source,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'etag=$etag',
      'source=$source',
    ].join(',');
    return 'TensorboardExperiment($contents)';
  }
}

/// TensorboardRun maps to a specific execution of a training job with a given
/// set of hyperparameter values, model definition, dataset, etc
final class TensorboardRun extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardRun';

  /// Output only. Name of the TensorboardRun.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String name;

  /// Required. User provided name of this TensorboardRun.
  /// This value must be unique among all TensorboardRuns
  /// belonging to the same parent TensorboardExperiment.
  final String displayName;

  /// Description of this TensorboardRun.
  final String description;

  /// Output only. Timestamp when this TensorboardRun was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this TensorboardRun was last updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize your TensorboardRuns.
  ///
  /// This field will be used to filter and visualize Runs in the Tensorboard UI.
  /// For example, a Vertex AI training job can set a label
  /// aiplatform.googleapis.com/training_job_id=xxxxx to all the runs created
  /// within that job. An end user can set a label experiment_id=xxxxx for all
  /// the runs produced in a Jupyter notebook. These runs can be grouped by a
  /// label value and visualized together in the Tensorboard UI.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one TensorboardRun
  /// (System labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String> labels;

  /// Used to perform a consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  TensorboardRun({
    this.name = '',
    required this.displayName,
    this.description = '',
    this.createTime,
    this.updateTime,
    this.labels = const {},
    this.etag = '',
  }) : super(fullyQualifiedName);

  factory TensorboardRun.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TensorboardRun(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (etag.isNotDefault) 'etag': etag,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'etag=$etag',
    ].join(',');
    return 'TensorboardRun($contents)';
  }
}

/// Request message for
/// `TensorboardService.CreateTensorboard`.
final class CreateTensorboardRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardRequest';

  /// Required. The resource name of the Location to create the Tensorboard in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Tensorboard to create.
  final Tensorboard? tensorboard;

  CreateTensorboardRequest({required this.parent, required this.tensorboard})
    : super(fullyQualifiedName);

  factory CreateTensorboardRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateTensorboardRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tensorboard: switch (json['tensorboard']) {
        null => null,
        Object $1 => Tensorboard.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (tensorboard != null) 'tensorboard': tensorboard!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateTensorboardRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.GetTensorboard`.
final class GetTensorboardRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTensorboardRequest';

  /// Required. The name of the Tensorboard resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String name;

  GetTensorboardRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTensorboardRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetTensorboardRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTensorboardRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ListTensorboards`.
final class ListTensorboardsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardsRequest';

  /// Required. The resource name of the Location to list Tensorboards.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the Tensorboards that match the filter expression.
  final String filter;

  /// The maximum number of Tensorboards to return. The service may return
  /// fewer than this value. If unspecified, at most 100 Tensorboards are
  /// returned. The maximum value is 100; values above 100 are coerced to
  /// 100.
  final int pageSize;

  /// A page token, received from a previous
  /// `TensorboardService.ListTensorboards`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `TensorboardService.ListTensorboards`
  /// must match the call that provided the page token.
  final String pageToken;

  /// Field to use to sort the list.
  final String orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTensorboardsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTensorboardsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTensorboardsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListTensorboardsRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ListTensorboards`.
final class ListTensorboardsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardsResponse';

  /// The Tensorboards mathching the request.
  final List<Tensorboard> tensorboards;

  /// A token, which can be sent as
  /// `ListTensorboardsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListTensorboardsResponse({
    this.tensorboards = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListTensorboardsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTensorboardsResponse(
      tensorboards: switch (json['tensorboards']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tensorboard.fromJson(i)],
        _ => throw const FormatException('"tensorboards" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tensorboards.isNotDefault) 'tensorboards': encodeList(tensorboards),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListTensorboardsResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.UpdateTensorboard`.
final class UpdateTensorboardRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardRequest';

  /// Required. Field mask is used to specify the fields to be overwritten in the
  /// Tensorboard resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field is overwritten if it's in the mask. If the
  /// user does not provide a mask then all fields are overwritten if new
  /// values are specified.
  final protobuf.FieldMask? updateMask;

  /// Required. The Tensorboard's `name` field is used to identify the
  /// Tensorboard to be updated. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final Tensorboard? tensorboard;

  UpdateTensorboardRequest({
    required this.updateMask,
    required this.tensorboard,
  }) : super(fullyQualifiedName);

  factory UpdateTensorboardRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateTensorboardRequest(
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      tensorboard: switch (json['tensorboard']) {
        null => null,
        Object $1 => Tensorboard.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
    if (tensorboard != null) 'tensorboard': tensorboard!.toJson(),
  };

  @override
  String toString() => 'UpdateTensorboardRequest()';
}

/// Request message for
/// `TensorboardService.DeleteTensorboard`.
final class DeleteTensorboardRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTensorboardRequest';

  /// Required. The name of the Tensorboard to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String name;

  DeleteTensorboardRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteTensorboardRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteTensorboardRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTensorboardRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ReadTensorboardUsage`.
final class ReadTensorboardUsageRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardUsageRequest';

  /// Required. The name of the Tensorboard resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String tensorboard;

  ReadTensorboardUsageRequest({required this.tensorboard})
    : super(fullyQualifiedName);

  factory ReadTensorboardUsageRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardUsageRequest(
      tensorboard: switch (json['tensorboard']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'tensorboard': tensorboard};

  @override
  String toString() {
    final contents = ['tensorboard=$tensorboard'].join(',');
    return 'ReadTensorboardUsageRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ReadTensorboardUsage`.
final class ReadTensorboardUsageResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardUsageResponse';

  /// Maps year-month (YYYYMM) string to per month usage data.
  final Map<String, ReadTensorboardUsageResponse_PerMonthUsageData>
  monthlyUsageData;

  ReadTensorboardUsageResponse({this.monthlyUsageData = const {}})
    : super(fullyQualifiedName);

  factory ReadTensorboardUsageResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardUsageResponse(
      monthlyUsageData: switch (json['monthlyUsageData']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(
              e.key,
            ): ReadTensorboardUsageResponse_PerMonthUsageData.fromJson(
              e.value,
            ),
        },
        _ => throw const FormatException('"monthlyUsageData" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (monthlyUsageData.isNotDefault)
      'monthlyUsageData': encodeMap(monthlyUsageData),
  };

  @override
  String toString() => 'ReadTensorboardUsageResponse()';
}

/// Per user usage data.
final class ReadTensorboardUsageResponse_PerUserUsageData extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardUsageResponse.PerUserUsageData';

  /// User's username
  final String username;

  /// Number of times the user has read data within the Tensorboard.
  final int viewCount;

  ReadTensorboardUsageResponse_PerUserUsageData({
    this.username = '',
    this.viewCount = 0,
  }) : super(fullyQualifiedName);

  factory ReadTensorboardUsageResponse_PerUserUsageData.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardUsageResponse_PerUserUsageData(
      username: switch (json['username']) {
        null => '',
        Object $1 => decodeString($1),
      },
      viewCount: switch (json['viewCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (username.isNotDefault) 'username': username,
    if (viewCount.isNotDefault) 'viewCount': encodeInt64(viewCount),
  };

  @override
  String toString() {
    final contents = ['username=$username', 'viewCount=$viewCount'].join(',');
    return 'PerUserUsageData($contents)';
  }
}

/// Per month usage data
final class ReadTensorboardUsageResponse_PerMonthUsageData
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardUsageResponse.PerMonthUsageData';

  /// Usage data for each user in the given month.
  final List<ReadTensorboardUsageResponse_PerUserUsageData> userUsageData;

  ReadTensorboardUsageResponse_PerMonthUsageData({
    this.userUsageData = const [],
  }) : super(fullyQualifiedName);

  factory ReadTensorboardUsageResponse_PerMonthUsageData.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardUsageResponse_PerMonthUsageData(
      userUsageData: switch (json['userUsageData']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ReadTensorboardUsageResponse_PerUserUsageData.fromJson(i),
        ],
        _ => throw const FormatException('"userUsageData" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (userUsageData.isNotDefault) 'userUsageData': encodeList(userUsageData),
  };

  @override
  String toString() => 'PerMonthUsageData()';
}

/// Request message for
/// `TensorboardService.ReadTensorboardSize`.
final class ReadTensorboardSizeRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardSizeRequest';

  /// Required. The name of the Tensorboard resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String tensorboard;

  ReadTensorboardSizeRequest({required this.tensorboard})
    : super(fullyQualifiedName);

  factory ReadTensorboardSizeRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardSizeRequest(
      tensorboard: switch (json['tensorboard']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'tensorboard': tensorboard};

  @override
  String toString() {
    final contents = ['tensorboard=$tensorboard'].join(',');
    return 'ReadTensorboardSizeRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ReadTensorboardSize`.
final class ReadTensorboardSizeResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardSizeResponse';

  /// Payload storage size for the TensorBoard
  final int storageSizeByte;

  ReadTensorboardSizeResponse({this.storageSizeByte = 0})
    : super(fullyQualifiedName);

  factory ReadTensorboardSizeResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardSizeResponse(
      storageSizeByte: switch (json['storageSizeByte']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (storageSizeByte.isNotDefault)
      'storageSizeByte': encodeInt64(storageSizeByte),
  };

  @override
  String toString() {
    final contents = ['storageSizeByte=$storageSizeByte'].join(',');
    return 'ReadTensorboardSizeResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.CreateTensorboardExperiment`.
final class CreateTensorboardExperimentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardExperimentRequest';

  /// Required. The resource name of the Tensorboard to create the
  /// TensorboardExperiment in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String parent;

  /// The TensorboardExperiment to create.
  final TensorboardExperiment? tensorboardExperiment;

  /// Required. The ID to use for the Tensorboard experiment, which becomes the
  /// final component of the Tensorboard experiment's resource name.
  ///
  /// This value should be 1-128 characters, and valid characters
  /// are `/[a-z][0-9]-/`.
  final String tensorboardExperimentId;

  CreateTensorboardExperimentRequest({
    required this.parent,
    this.tensorboardExperiment,
    required this.tensorboardExperimentId,
  }) : super(fullyQualifiedName);

  factory CreateTensorboardExperimentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateTensorboardExperimentRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tensorboardExperiment: switch (json['tensorboardExperiment']) {
        null => null,
        Object $1 => TensorboardExperiment.fromJson($1),
      },
      tensorboardExperimentId: switch (json['tensorboardExperimentId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (tensorboardExperiment != null)
      'tensorboardExperiment': tensorboardExperiment!.toJson(),
    'tensorboardExperimentId': tensorboardExperimentId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'tensorboardExperimentId=$tensorboardExperimentId',
    ].join(',');
    return 'CreateTensorboardExperimentRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.GetTensorboardExperiment`.
final class GetTensorboardExperimentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTensorboardExperimentRequest';

  /// Required. The name of the TensorboardExperiment resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String name;

  GetTensorboardExperimentRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetTensorboardExperimentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetTensorboardExperimentRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTensorboardExperimentRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ListTensorboardExperiments`.
final class ListTensorboardExperimentsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardExperimentsRequest';

  /// Required. The resource name of the Tensorboard to list
  /// TensorboardExperiments. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String parent;

  /// Lists the TensorboardExperiments that match the filter expression.
  final String filter;

  /// The maximum number of TensorboardExperiments to return. The service may
  /// return fewer than this value. If unspecified, at most 50
  /// TensorboardExperiments are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  final int pageSize;

  /// A page token, received from a previous
  /// `TensorboardService.ListTensorboardExperiments`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `TensorboardService.ListTensorboardExperiments`
  /// must match the call that provided the page token.
  final String pageToken;

  /// Field to use to sort the list.
  final String orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTensorboardExperimentsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTensorboardExperimentsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTensorboardExperimentsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListTensorboardExperimentsRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ListTensorboardExperiments`.
final class ListTensorboardExperimentsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardExperimentsResponse';

  /// The TensorboardExperiments mathching the request.
  final List<TensorboardExperiment> tensorboardExperiments;

  /// A token, which can be sent as
  /// `ListTensorboardExperimentsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListTensorboardExperimentsResponse({
    this.tensorboardExperiments = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListTensorboardExperimentsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTensorboardExperimentsResponse(
      tensorboardExperiments: switch (json['tensorboardExperiments']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TensorboardExperiment.fromJson(i),
        ],
        _ => throw const FormatException(
          '"tensorboardExperiments" is not a list',
        ),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tensorboardExperiments.isNotDefault)
      'tensorboardExperiments': encodeList(tensorboardExperiments),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListTensorboardExperimentsResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.UpdateTensorboardExperiment`.
final class UpdateTensorboardExperimentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardExperimentRequest';

  /// Required. Field mask is used to specify the fields to be overwritten in the
  /// TensorboardExperiment resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field is overwritten if it's in the mask. If the
  /// user does not provide a mask then all fields are overwritten if new
  /// values are specified.
  final protobuf.FieldMask? updateMask;

  /// Required. The TensorboardExperiment's `name` field is used to identify the
  /// TensorboardExperiment to be updated. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final TensorboardExperiment? tensorboardExperiment;

  UpdateTensorboardExperimentRequest({
    required this.updateMask,
    required this.tensorboardExperiment,
  }) : super(fullyQualifiedName);

  factory UpdateTensorboardExperimentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateTensorboardExperimentRequest(
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      tensorboardExperiment: switch (json['tensorboardExperiment']) {
        null => null,
        Object $1 => TensorboardExperiment.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
    if (tensorboardExperiment != null)
      'tensorboardExperiment': tensorboardExperiment!.toJson(),
  };

  @override
  String toString() => 'UpdateTensorboardExperimentRequest()';
}

/// Request message for
/// `TensorboardService.DeleteTensorboardExperiment`.
final class DeleteTensorboardExperimentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTensorboardExperimentRequest';

  /// Required. The name of the TensorboardExperiment to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String name;

  DeleteTensorboardExperimentRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteTensorboardExperimentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteTensorboardExperimentRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTensorboardExperimentRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.BatchCreateTensorboardRuns`.
final class BatchCreateTensorboardRunsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateTensorboardRunsRequest';

  /// Required. The resource name of the TensorboardExperiment to create the
  /// TensorboardRuns in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The parent field in the CreateTensorboardRunRequest messages must match
  /// this field.
  final String parent;

  /// Required. The request message specifying the TensorboardRuns to create.
  /// A maximum of 1000 TensorboardRuns can be created in a batch.
  final List<CreateTensorboardRunRequest> requests;

  BatchCreateTensorboardRunsRequest({
    required this.parent,
    required this.requests,
  }) : super(fullyQualifiedName);

  factory BatchCreateTensorboardRunsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCreateTensorboardRunsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requests: switch (json['requests']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) CreateTensorboardRunRequest.fromJson(i),
        ],
        _ => throw const FormatException('"requests" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent, 'requests': encodeList(requests)};

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchCreateTensorboardRunsRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.BatchCreateTensorboardRuns`.
final class BatchCreateTensorboardRunsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateTensorboardRunsResponse';

  /// The created TensorboardRuns.
  final List<TensorboardRun> tensorboardRuns;

  BatchCreateTensorboardRunsResponse({this.tensorboardRuns = const []})
    : super(fullyQualifiedName);

  factory BatchCreateTensorboardRunsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCreateTensorboardRunsResponse(
      tensorboardRuns: switch (json['tensorboardRuns']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TensorboardRun.fromJson(i)],
        _ => throw const FormatException('"tensorboardRuns" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (tensorboardRuns.isNotDefault)
      'tensorboardRuns': encodeList(tensorboardRuns),
  };

  @override
  String toString() => 'BatchCreateTensorboardRunsResponse()';
}

/// Request message for
/// `TensorboardService.CreateTensorboardRun`.
final class CreateTensorboardRunRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardRunRequest';

  /// Required. The resource name of the TensorboardExperiment to create the
  /// TensorboardRun in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String parent;

  /// Required. The TensorboardRun to create.
  final TensorboardRun? tensorboardRun;

  /// Required. The ID to use for the Tensorboard run, which becomes the final
  /// component of the Tensorboard run's resource name.
  ///
  /// This value should be 1-128 characters, and valid characters
  /// are `/[a-z][0-9]-/`.
  final String tensorboardRunId;

  CreateTensorboardRunRequest({
    required this.parent,
    required this.tensorboardRun,
    required this.tensorboardRunId,
  }) : super(fullyQualifiedName);

  factory CreateTensorboardRunRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateTensorboardRunRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tensorboardRun: switch (json['tensorboardRun']) {
        null => null,
        Object $1 => TensorboardRun.fromJson($1),
      },
      tensorboardRunId: switch (json['tensorboardRunId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (tensorboardRun != null) 'tensorboardRun': tensorboardRun!.toJson(),
    'tensorboardRunId': tensorboardRunId,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'tensorboardRunId=$tensorboardRunId',
    ].join(',');
    return 'CreateTensorboardRunRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.GetTensorboardRun`.
final class GetTensorboardRunRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTensorboardRunRequest';

  /// Required. The name of the TensorboardRun resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String name;

  GetTensorboardRunRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTensorboardRunRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetTensorboardRunRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTensorboardRunRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ReadTensorboardBlobData`.
final class ReadTensorboardBlobDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardBlobDataRequest';

  /// Required. The resource name of the TensorboardTimeSeries to list Blobs.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String timeSeries;

  /// IDs of the blobs to read.
  final List<String> blobIds;

  ReadTensorboardBlobDataRequest({
    required this.timeSeries,
    this.blobIds = const [],
  }) : super(fullyQualifiedName);

  factory ReadTensorboardBlobDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardBlobDataRequest(
      timeSeries: switch (json['timeSeries']) {
        null => '',
        Object $1 => decodeString($1),
      },
      blobIds: switch (json['blobIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"blobIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'timeSeries': timeSeries,
    if (blobIds.isNotDefault) 'blobIds': blobIds,
  };

  @override
  String toString() {
    final contents = ['timeSeries=$timeSeries'].join(',');
    return 'ReadTensorboardBlobDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ReadTensorboardBlobData`.
final class ReadTensorboardBlobDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardBlobDataResponse';

  /// Blob messages containing blob bytes.
  final List<TensorboardBlob> blobs;

  ReadTensorboardBlobDataResponse({this.blobs = const []})
    : super(fullyQualifiedName);

  factory ReadTensorboardBlobDataResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardBlobDataResponse(
      blobs: switch (json['blobs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TensorboardBlob.fromJson(i)],
        _ => throw const FormatException('"blobs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (blobs.isNotDefault) 'blobs': encodeList(blobs)};

  @override
  String toString() => 'ReadTensorboardBlobDataResponse()';
}

/// Request message for
/// `TensorboardService.ListTensorboardRuns`.
final class ListTensorboardRunsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardRunsRequest';

  /// Required. The resource name of the TensorboardExperiment to list
  /// TensorboardRuns. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String parent;

  /// Lists the TensorboardRuns that match the filter expression.
  final String filter;

  /// The maximum number of TensorboardRuns to return. The service may return
  /// fewer than this value. If unspecified, at most 50 TensorboardRuns are
  /// returned. The maximum value is 1000; values above 1000 are coerced to
  /// 1000.
  final int pageSize;

  /// A page token, received from a previous
  /// `TensorboardService.ListTensorboardRuns`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `TensorboardService.ListTensorboardRuns`
  /// must match the call that provided the page token.
  final String pageToken;

  /// Field to use to sort the list.
  final String orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTensorboardRunsRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTensorboardRunsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTensorboardRunsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListTensorboardRunsRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ListTensorboardRuns`.
final class ListTensorboardRunsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardRunsResponse';

  /// The TensorboardRuns mathching the request.
  final List<TensorboardRun> tensorboardRuns;

  /// A token, which can be sent as
  /// `ListTensorboardRunsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListTensorboardRunsResponse({
    this.tensorboardRuns = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListTensorboardRunsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTensorboardRunsResponse(
      tensorboardRuns: switch (json['tensorboardRuns']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TensorboardRun.fromJson(i)],
        _ => throw const FormatException('"tensorboardRuns" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tensorboardRuns.isNotDefault)
      'tensorboardRuns': encodeList(tensorboardRuns),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListTensorboardRunsResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.UpdateTensorboardRun`.
final class UpdateTensorboardRunRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardRunRequest';

  /// Required. Field mask is used to specify the fields to be overwritten in the
  /// TensorboardRun resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field is overwritten if it's in the mask. If the
  /// user does not provide a mask then all fields are overwritten if new
  /// values are specified.
  final protobuf.FieldMask? updateMask;

  /// Required. The TensorboardRun's `name` field is used to identify the
  /// TensorboardRun to be updated. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final TensorboardRun? tensorboardRun;

  UpdateTensorboardRunRequest({
    required this.updateMask,
    required this.tensorboardRun,
  }) : super(fullyQualifiedName);

  factory UpdateTensorboardRunRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateTensorboardRunRequest(
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      tensorboardRun: switch (json['tensorboardRun']) {
        null => null,
        Object $1 => TensorboardRun.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
    if (tensorboardRun != null) 'tensorboardRun': tensorboardRun!.toJson(),
  };

  @override
  String toString() => 'UpdateTensorboardRunRequest()';
}

/// Request message for
/// `TensorboardService.DeleteTensorboardRun`.
final class DeleteTensorboardRunRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTensorboardRunRequest';

  /// Required. The name of the TensorboardRun to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String name;

  DeleteTensorboardRunRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteTensorboardRunRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteTensorboardRunRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTensorboardRunRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.BatchCreateTensorboardTimeSeries`.
final class BatchCreateTensorboardTimeSeriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateTensorboardTimeSeriesRequest';

  /// Required. The resource name of the TensorboardExperiment to create the
  /// TensorboardTimeSeries in.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The TensorboardRuns referenced by the parent fields in the
  /// CreateTensorboardTimeSeriesRequest messages must be sub resources of this
  /// TensorboardExperiment.
  final String parent;

  /// Required. The request message specifying the TensorboardTimeSeries to
  /// create. A maximum of 1000 TensorboardTimeSeries can be created in a batch.
  final List<CreateTensorboardTimeSeriesRequest> requests;

  BatchCreateTensorboardTimeSeriesRequest({
    required this.parent,
    required this.requests,
  }) : super(fullyQualifiedName);

  factory BatchCreateTensorboardTimeSeriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCreateTensorboardTimeSeriesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requests: switch (json['requests']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) CreateTensorboardTimeSeriesRequest.fromJson(i),
        ],
        _ => throw const FormatException('"requests" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent, 'requests': encodeList(requests)};

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchCreateTensorboardTimeSeriesRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.BatchCreateTensorboardTimeSeries`.
final class BatchCreateTensorboardTimeSeriesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateTensorboardTimeSeriesResponse';

  /// The created TensorboardTimeSeries.
  final List<TensorboardTimeSeries> tensorboardTimeSeries;

  BatchCreateTensorboardTimeSeriesResponse({
    this.tensorboardTimeSeries = const [],
  }) : super(fullyQualifiedName);

  factory BatchCreateTensorboardTimeSeriesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchCreateTensorboardTimeSeriesResponse(
      tensorboardTimeSeries: switch (json['tensorboardTimeSeries']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TensorboardTimeSeries.fromJson(i),
        ],
        _ => throw const FormatException(
          '"tensorboardTimeSeries" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (tensorboardTimeSeries.isNotDefault)
      'tensorboardTimeSeries': encodeList(tensorboardTimeSeries),
  };

  @override
  String toString() => 'BatchCreateTensorboardTimeSeriesResponse()';
}

/// Request message for
/// `TensorboardService.CreateTensorboardTimeSeries`.
final class CreateTensorboardTimeSeriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardTimeSeriesRequest';

  /// Required. The resource name of the TensorboardRun to create the
  /// TensorboardTimeSeries in.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String parent;

  /// Optional. The user specified unique ID to use for the
  /// TensorboardTimeSeries, which becomes the final component of the
  /// TensorboardTimeSeries's resource name. This value should match
  /// "[a-z0-9][a-z0-9-]{0, 127}"
  final String tensorboardTimeSeriesId;

  /// Required. The TensorboardTimeSeries to create.
  final TensorboardTimeSeries? tensorboardTimeSeries;

  CreateTensorboardTimeSeriesRequest({
    required this.parent,
    this.tensorboardTimeSeriesId = '',
    required this.tensorboardTimeSeries,
  }) : super(fullyQualifiedName);

  factory CreateTensorboardTimeSeriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateTensorboardTimeSeriesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tensorboardTimeSeriesId: switch (json['tensorboardTimeSeriesId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tensorboardTimeSeries: switch (json['tensorboardTimeSeries']) {
        null => null,
        Object $1 => TensorboardTimeSeries.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (tensorboardTimeSeriesId.isNotDefault)
      'tensorboardTimeSeriesId': tensorboardTimeSeriesId,
    if (tensorboardTimeSeries != null)
      'tensorboardTimeSeries': tensorboardTimeSeries!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'tensorboardTimeSeriesId=$tensorboardTimeSeriesId',
    ].join(',');
    return 'CreateTensorboardTimeSeriesRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.GetTensorboardTimeSeries`.
final class GetTensorboardTimeSeriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTensorboardTimeSeriesRequest';

  /// Required. The name of the TensorboardTimeSeries resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String name;

  GetTensorboardTimeSeriesRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetTensorboardTimeSeriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetTensorboardTimeSeriesRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTensorboardTimeSeriesRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ListTensorboardTimeSeries`.
final class ListTensorboardTimeSeriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardTimeSeriesRequest';

  /// Required. The resource name of the TensorboardRun to list
  /// TensorboardTimeSeries. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String parent;

  /// Lists the TensorboardTimeSeries that match the filter expression.
  final String filter;

  /// The maximum number of TensorboardTimeSeries to return. The service may
  /// return fewer than this value. If unspecified, at most 50
  /// TensorboardTimeSeries are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  final int pageSize;

  /// A page token, received from a previous
  /// `TensorboardService.ListTensorboardTimeSeries`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `TensorboardService.ListTensorboardTimeSeries`
  /// must match the call that provided the page token.
  final String pageToken;

  /// Field to use to sort the list.
  final String orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTensorboardTimeSeriesRequest({
    required this.parent,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTensorboardTimeSeriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTensorboardTimeSeriesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
      readMask: switch (json['readMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
    if (readMask != null) 'readMask': readMask!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListTensorboardTimeSeriesRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ListTensorboardTimeSeries`.
final class ListTensorboardTimeSeriesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardTimeSeriesResponse';

  /// The TensorboardTimeSeries mathching the request.
  final List<TensorboardTimeSeries> tensorboardTimeSeries;

  /// A token, which can be sent as
  /// `ListTensorboardTimeSeriesRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ListTensorboardTimeSeriesResponse({
    this.tensorboardTimeSeries = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ListTensorboardTimeSeriesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTensorboardTimeSeriesResponse(
      tensorboardTimeSeries: switch (json['tensorboardTimeSeries']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TensorboardTimeSeries.fromJson(i),
        ],
        _ => throw const FormatException(
          '"tensorboardTimeSeries" is not a list',
        ),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tensorboardTimeSeries.isNotDefault)
      'tensorboardTimeSeries': encodeList(tensorboardTimeSeries),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListTensorboardTimeSeriesResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.UpdateTensorboardTimeSeries`.
final class UpdateTensorboardTimeSeriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardTimeSeriesRequest';

  /// Required. Field mask is used to specify the fields to be overwritten in the
  /// TensorboardTimeSeries resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field is overwritten if it's in the mask. If the
  /// user does not provide a mask then all fields are overwritten if new
  /// values are specified.
  final protobuf.FieldMask? updateMask;

  /// Required. The TensorboardTimeSeries' `name` field is used to identify the
  /// TensorboardTimeSeries to be updated.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final TensorboardTimeSeries? tensorboardTimeSeries;

  UpdateTensorboardTimeSeriesRequest({
    required this.updateMask,
    required this.tensorboardTimeSeries,
  }) : super(fullyQualifiedName);

  factory UpdateTensorboardTimeSeriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateTensorboardTimeSeriesRequest(
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => protobuf.FieldMask.fromJson($1),
      },
      tensorboardTimeSeries: switch (json['tensorboardTimeSeries']) {
        null => null,
        Object $1 => TensorboardTimeSeries.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
    if (tensorboardTimeSeries != null)
      'tensorboardTimeSeries': tensorboardTimeSeries!.toJson(),
  };

  @override
  String toString() => 'UpdateTensorboardTimeSeriesRequest()';
}

/// Request message for
/// `TensorboardService.DeleteTensorboardTimeSeries`.
final class DeleteTensorboardTimeSeriesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTensorboardTimeSeriesRequest';

  /// Required. The name of the TensorboardTimeSeries to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String name;

  DeleteTensorboardTimeSeriesRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteTensorboardTimeSeriesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteTensorboardTimeSeriesRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTensorboardTimeSeriesRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.BatchReadTensorboardTimeSeriesData`.
final class BatchReadTensorboardTimeSeriesDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadTensorboardTimeSeriesDataRequest';

  /// Required. The resource name of the Tensorboard containing
  /// TensorboardTimeSeries to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`.
  /// The TensorboardTimeSeries referenced by
  /// `time_series`
  /// must be sub resources of this Tensorboard.
  final String tensorboard;

  /// Required. The resource names of the TensorboardTimeSeries to read data
  /// from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final List<String> timeSeries;

  BatchReadTensorboardTimeSeriesDataRequest({
    required this.tensorboard,
    required this.timeSeries,
  }) : super(fullyQualifiedName);

  factory BatchReadTensorboardTimeSeriesDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchReadTensorboardTimeSeriesDataRequest(
      tensorboard: switch (json['tensorboard']) {
        null => '',
        Object $1 => decodeString($1),
      },
      timeSeries: switch (json['timeSeries']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"timeSeries" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'tensorboard': tensorboard, 'timeSeries': timeSeries};

  @override
  String toString() {
    final contents = ['tensorboard=$tensorboard'].join(',');
    return 'BatchReadTensorboardTimeSeriesDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.BatchReadTensorboardTimeSeriesData`.
final class BatchReadTensorboardTimeSeriesDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadTensorboardTimeSeriesDataResponse';

  /// The returned time series data.
  final List<TimeSeriesData> timeSeriesData;

  BatchReadTensorboardTimeSeriesDataResponse({this.timeSeriesData = const []})
    : super(fullyQualifiedName);

  factory BatchReadTensorboardTimeSeriesDataResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BatchReadTensorboardTimeSeriesDataResponse(
      timeSeriesData: switch (json['timeSeriesData']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TimeSeriesData.fromJson(i)],
        _ => throw const FormatException('"timeSeriesData" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (timeSeriesData.isNotDefault)
      'timeSeriesData': encodeList(timeSeriesData),
  };

  @override
  String toString() => 'BatchReadTensorboardTimeSeriesDataResponse()';
}

/// Request message for
/// `TensorboardService.ReadTensorboardTimeSeriesData`.
final class ReadTensorboardTimeSeriesDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardTimeSeriesDataRequest';

  /// Required. The resource name of the TensorboardTimeSeries to read data from.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String tensorboardTimeSeries;

  /// The maximum number of TensorboardTimeSeries' data to return.
  ///
  /// This value should be a positive integer.
  /// This value can be set to -1 to return all data.
  final int maxDataPoints;

  /// Reads the TensorboardTimeSeries' data that match the filter expression.
  final String filter;

  ReadTensorboardTimeSeriesDataRequest({
    required this.tensorboardTimeSeries,
    this.maxDataPoints = 0,
    this.filter = '',
  }) : super(fullyQualifiedName);

  factory ReadTensorboardTimeSeriesDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardTimeSeriesDataRequest(
      tensorboardTimeSeries: switch (json['tensorboardTimeSeries']) {
        null => '',
        Object $1 => decodeString($1),
      },
      maxDataPoints: switch (json['maxDataPoints']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'tensorboardTimeSeries': tensorboardTimeSeries,
    if (maxDataPoints.isNotDefault) 'maxDataPoints': maxDataPoints,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = [
      'tensorboardTimeSeries=$tensorboardTimeSeries',
      'maxDataPoints=$maxDataPoints',
      'filter=$filter',
    ].join(',');
    return 'ReadTensorboardTimeSeriesDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ReadTensorboardTimeSeriesData`.
final class ReadTensorboardTimeSeriesDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardTimeSeriesDataResponse';

  /// The returned time series data.
  final TimeSeriesData? timeSeriesData;

  ReadTensorboardTimeSeriesDataResponse({this.timeSeriesData})
    : super(fullyQualifiedName);

  factory ReadTensorboardTimeSeriesDataResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReadTensorboardTimeSeriesDataResponse(
      timeSeriesData: switch (json['timeSeriesData']) {
        null => null,
        Object $1 => TimeSeriesData.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!.toJson(),
  };

  @override
  String toString() => 'ReadTensorboardTimeSeriesDataResponse()';
}

/// Request message for
/// `TensorboardService.WriteTensorboardExperimentData`.
final class WriteTensorboardExperimentDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteTensorboardExperimentDataRequest';

  /// Required. The resource name of the TensorboardExperiment to write data to.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String tensorboardExperiment;

  /// Required. Requests containing per-run TensorboardTimeSeries data to write.
  final List<WriteTensorboardRunDataRequest> writeRunDataRequests;

  WriteTensorboardExperimentDataRequest({
    required this.tensorboardExperiment,
    required this.writeRunDataRequests,
  }) : super(fullyQualifiedName);

  factory WriteTensorboardExperimentDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return WriteTensorboardExperimentDataRequest(
      tensorboardExperiment: switch (json['tensorboardExperiment']) {
        null => '',
        Object $1 => decodeString($1),
      },
      writeRunDataRequests: switch (json['writeRunDataRequests']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) WriteTensorboardRunDataRequest.fromJson(i),
        ],
        _ => throw const FormatException(
          '"writeRunDataRequests" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    'tensorboardExperiment': tensorboardExperiment,
    'writeRunDataRequests': encodeList(writeRunDataRequests),
  };

  @override
  String toString() {
    final contents = ['tensorboardExperiment=$tensorboardExperiment'].join(',');
    return 'WriteTensorboardExperimentDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.WriteTensorboardExperimentData`.
final class WriteTensorboardExperimentDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteTensorboardExperimentDataResponse';

  WriteTensorboardExperimentDataResponse() : super(fullyQualifiedName);

  factory WriteTensorboardExperimentDataResponse.fromJson(Object? j) =>
      WriteTensorboardExperimentDataResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'WriteTensorboardExperimentDataResponse()';
}

/// Request message for
/// `TensorboardService.WriteTensorboardRunData`.
final class WriteTensorboardRunDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteTensorboardRunDataRequest';

  /// Required. The resource name of the TensorboardRun to write data to.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String tensorboardRun;

  /// Required. The TensorboardTimeSeries data to write.
  /// Values with in a time series are indexed by their step value.
  /// Repeated writes to the same step will overwrite the existing value for that
  /// step.
  /// The upper limit of data points per write request is 5000.
  final List<TimeSeriesData> timeSeriesData;

  WriteTensorboardRunDataRequest({
    required this.tensorboardRun,
    required this.timeSeriesData,
  }) : super(fullyQualifiedName);

  factory WriteTensorboardRunDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return WriteTensorboardRunDataRequest(
      tensorboardRun: switch (json['tensorboardRun']) {
        null => '',
        Object $1 => decodeString($1),
      },
      timeSeriesData: switch (json['timeSeriesData']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TimeSeriesData.fromJson(i)],
        _ => throw const FormatException('"timeSeriesData" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'tensorboardRun': tensorboardRun,
    'timeSeriesData': encodeList(timeSeriesData),
  };

  @override
  String toString() {
    final contents = ['tensorboardRun=$tensorboardRun'].join(',');
    return 'WriteTensorboardRunDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.WriteTensorboardRunData`.
final class WriteTensorboardRunDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteTensorboardRunDataResponse';

  WriteTensorboardRunDataResponse() : super(fullyQualifiedName);

  factory WriteTensorboardRunDataResponse.fromJson(Object? j) =>
      WriteTensorboardRunDataResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'WriteTensorboardRunDataResponse()';
}

/// Request message for
/// `TensorboardService.ExportTensorboardTimeSeriesData`.
final class ExportTensorboardTimeSeriesDataRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportTensorboardTimeSeriesDataRequest';

  /// Required. The resource name of the TensorboardTimeSeries to export data
  /// from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String tensorboardTimeSeries;

  /// Exports the TensorboardTimeSeries' data that match the filter expression.
  final String filter;

  /// The maximum number of data points to return per page.
  /// The default page_size is 1000. Values must be between 1 and 10000.
  /// Values above 10000 are coerced to 10000.
  final int pageSize;

  /// A page token, received from a previous
  /// `ExportTensorboardTimeSeriesData`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `ExportTensorboardTimeSeriesData`
  /// must match the call that provided the page token.
  final String pageToken;

  /// Field to use to sort the TensorboardTimeSeries' data.
  /// By default, TensorboardTimeSeries' data is returned in a pseudo random
  /// order.
  final String orderBy;

  ExportTensorboardTimeSeriesDataRequest({
    required this.tensorboardTimeSeries,
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ExportTensorboardTimeSeriesDataRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportTensorboardTimeSeriesDataRequest(
      tensorboardTimeSeries: switch (json['tensorboardTimeSeries']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'tensorboardTimeSeries': tensorboardTimeSeries,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'tensorboardTimeSeries=$tensorboardTimeSeries',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'orderBy=$orderBy',
    ].join(',');
    return 'ExportTensorboardTimeSeriesDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ExportTensorboardTimeSeriesData`.
final class ExportTensorboardTimeSeriesDataResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportTensorboardTimeSeriesDataResponse';

  /// The returned time series data points.
  final List<TimeSeriesDataPoint> timeSeriesDataPoints;

  /// A token, which can be sent as
  /// `page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String nextPageToken;

  ExportTensorboardTimeSeriesDataResponse({
    this.timeSeriesDataPoints = const [],
    this.nextPageToken = '',
  }) : super(fullyQualifiedName);

  factory ExportTensorboardTimeSeriesDataResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExportTensorboardTimeSeriesDataResponse(
      timeSeriesDataPoints: switch (json['timeSeriesDataPoints']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TimeSeriesDataPoint.fromJson(i),
        ],
        _ => throw const FormatException(
          '"timeSeriesDataPoints" is not a list',
        ),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (timeSeriesDataPoints.isNotDefault)
      'timeSeriesDataPoints': encodeList(timeSeriesDataPoints),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ExportTensorboardTimeSeriesDataResponse($contents)';
  }
}

/// Details of operations that perform create Tensorboard.
final class CreateTensorboardOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardOperationMetadata';

  /// Operation metadata for Tensorboard.
  final GenericOperationMetadata? genericMetadata;

  CreateTensorboardOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateTensorboardOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateTensorboardOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateTensorboardOperationMetadata()';
}

/// Details of operations that perform update Tensorboard.
final class UpdateTensorboardOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardOperationMetadata';

  /// Operation metadata for Tensorboard.
  final GenericOperationMetadata? genericMetadata;

  UpdateTensorboardOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateTensorboardOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateTensorboardOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateTensorboardOperationMetadata()';
}

/// TensorboardTimeSeries maps to times series produced in training runs
final class TensorboardTimeSeries extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardTimeSeries';

  /// Output only. Name of the TensorboardTimeSeries.
  final String name;

  /// Required. User provided name of this TensorboardTimeSeries.
  /// This value should be unique among all TensorboardTimeSeries resources
  /// belonging to the same TensorboardRun resource (parent resource).
  final String displayName;

  /// Description of this TensorboardTimeSeries.
  final String description;

  /// Required. Immutable. Type of TensorboardTimeSeries value.
  final TensorboardTimeSeries_ValueType valueType;

  /// Output only. Timestamp when this TensorboardTimeSeries was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this TensorboardTimeSeries was last updated.
  final protobuf.Timestamp? updateTime;

  /// Used to perform a consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String etag;

  /// Immutable. Name of the plugin this time series pertain to. Such as Scalar,
  /// Tensor, Blob
  final String pluginName;

  /// Data of the current plugin, with the size limited to 65KB.
  final Uint8List pluginData;

  /// Output only. Scalar, Tensor, or Blob metadata for this
  /// TensorboardTimeSeries.
  final TensorboardTimeSeries_Metadata? metadata;

  TensorboardTimeSeries({
    this.name = '',
    required this.displayName,
    this.description = '',
    required this.valueType,
    this.createTime,
    this.updateTime,
    this.etag = '',
    this.pluginName = '',
    Uint8List? pluginData,
    this.metadata,
  }) : pluginData = pluginData ?? Uint8List(0),
       super(fullyQualifiedName);

  factory TensorboardTimeSeries.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TensorboardTimeSeries(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      valueType: switch (json['valueType']) {
        null => TensorboardTimeSeries_ValueType.$default,
        Object $1 => TensorboardTimeSeries_ValueType.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pluginName: switch (json['pluginName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pluginData: switch (json['pluginData']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => TensorboardTimeSeries_Metadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    'valueType': valueType.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (pluginName.isNotDefault) 'pluginName': pluginName,
    if (pluginData.isNotDefault) 'pluginData': encodeBytes(pluginData),
    if (metadata != null) 'metadata': metadata!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'valueType=$valueType',
      'etag=$etag',
      'pluginName=$pluginName',
      'pluginData=$pluginData',
    ].join(',');
    return 'TensorboardTimeSeries($contents)';
  }
}

/// Describes metadata for a TensorboardTimeSeries.
final class TensorboardTimeSeries_Metadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardTimeSeries.Metadata';

  /// Output only. Max step index of all data points within a
  /// TensorboardTimeSeries.
  final int maxStep;

  /// Output only. Max wall clock timestamp of all data points within a
  /// TensorboardTimeSeries.
  final protobuf.Timestamp? maxWallTime;

  /// Output only. The largest blob sequence length (number of blobs) of all
  /// data points in this time series, if its ValueType is BLOB_SEQUENCE.
  final int maxBlobSequenceLength;

  TensorboardTimeSeries_Metadata({
    this.maxStep = 0,
    this.maxWallTime,
    this.maxBlobSequenceLength = 0,
  }) : super(fullyQualifiedName);

  factory TensorboardTimeSeries_Metadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TensorboardTimeSeries_Metadata(
      maxStep: switch (json['maxStep']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      maxWallTime: switch (json['maxWallTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      maxBlobSequenceLength: switch (json['maxBlobSequenceLength']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (maxStep.isNotDefault) 'maxStep': encodeInt64(maxStep),
    if (maxWallTime != null) 'maxWallTime': maxWallTime!.toJson(),
    if (maxBlobSequenceLength.isNotDefault)
      'maxBlobSequenceLength': encodeInt64(maxBlobSequenceLength),
  };

  @override
  String toString() {
    final contents = [
      'maxStep=$maxStep',
      'maxBlobSequenceLength=$maxBlobSequenceLength',
    ].join(',');
    return 'Metadata($contents)';
  }
}

/// An enum representing the value type of a TensorboardTimeSeries.
final class TensorboardTimeSeries_ValueType extends ProtoEnum {
  /// The value type is unspecified.
  static const valueTypeUnspecified = TensorboardTimeSeries_ValueType(
    'VALUE_TYPE_UNSPECIFIED',
  );

  /// Used for TensorboardTimeSeries that is a list of scalars.
  /// E.g. accuracy of a model over epochs/time.
  static const scalar = TensorboardTimeSeries_ValueType('SCALAR');

  /// Used for TensorboardTimeSeries that is a list of tensors.
  /// E.g. histograms of weights of layer in a model over epoch/time.
  static const tensor = TensorboardTimeSeries_ValueType('TENSOR');

  /// Used for TensorboardTimeSeries that is a list of blob sequences.
  /// E.g. set of sample images with labels over epochs/time.
  static const blobSequence = TensorboardTimeSeries_ValueType('BLOB_SEQUENCE');

  /// The default value for [TensorboardTimeSeries_ValueType].
  static const $default = valueTypeUnspecified;

  const TensorboardTimeSeries_ValueType(super.value);

  factory TensorboardTimeSeries_ValueType.fromJson(Object? json) =>
      TensorboardTimeSeries_ValueType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ValueType.$value';
}

/// Tool details that the model may use to generate response.
///
/// A `Tool` is a piece of code that enables the system to interact with
/// external systems to perform an action, or set of actions, outside of
/// knowledge and scope of the model. A Tool object should contain exactly
/// one type of Tool (e.g FunctionDeclaration, Retrieval or
/// GoogleSearchRetrieval).
final class Tool extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tool';

  /// Optional. Function tool type.
  /// One or more function declarations to be passed to the model along with the
  /// current user query. Model may decide to call a subset of these functions
  /// by populating
  /// `FunctionCall` in the
  /// response. User should provide a
  /// `FunctionResponse`
  /// for each function call in the next turn. Based on the function responses,
  /// Model will generate the final response back to the user.
  /// Maximum 128 function declarations can be provided.
  final List<FunctionDeclaration> functionDeclarations;

  /// Optional. Retrieval tool type.
  /// System will always execute the provided retrieval tool(s) to get external
  /// knowledge to answer the prompt. Retrieval results are presented to the
  /// model for generation.
  final Retrieval? retrieval;

  /// Optional. GoogleSearch tool type.
  /// Tool to support Google Search in Model. Powered by Google.
  final Tool_GoogleSearch? googleSearch;

  /// Optional. GoogleSearchRetrieval tool type.
  /// Specialized retrieval tool that is powered by Google search.
  final GoogleSearchRetrieval? googleSearchRetrieval;

  /// Optional. GoogleMaps tool type.
  /// Tool to support Google Maps in Model.
  final GoogleMaps? googleMaps;

  /// Optional. Tool to support searching public web data, powered by Vertex AI
  /// Search and Sec4 compliance.
  final EnterpriseWebSearch? enterpriseWebSearch;

  /// Optional. CodeExecution tool type.
  /// Enables the model to execute code as part of generation.
  final Tool_CodeExecution? codeExecution;

  /// Optional. Tool to support URL context retrieval.
  final UrlContext? urlContext;

  /// Optional. Tool to support the model interacting directly with the computer.
  /// If enabled, it automatically populates computer-use specific Function
  /// Declarations.
  final Tool_ComputerUse? computerUse;

  Tool({
    this.functionDeclarations = const [],
    this.retrieval,
    this.googleSearch,
    this.googleSearchRetrieval,
    this.googleMaps,
    this.enterpriseWebSearch,
    this.codeExecution,
    this.urlContext,
    this.computerUse,
  }) : super(fullyQualifiedName);

  factory Tool.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Tool(
      functionDeclarations: switch (json['functionDeclarations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) FunctionDeclaration.fromJson(i),
        ],
        _ => throw const FormatException(
          '"functionDeclarations" is not a list',
        ),
      },
      retrieval: switch (json['retrieval']) {
        null => null,
        Object $1 => Retrieval.fromJson($1),
      },
      googleSearch: switch (json['googleSearch']) {
        null => null,
        Object $1 => Tool_GoogleSearch.fromJson($1),
      },
      googleSearchRetrieval: switch (json['googleSearchRetrieval']) {
        null => null,
        Object $1 => GoogleSearchRetrieval.fromJson($1),
      },
      googleMaps: switch (json['googleMaps']) {
        null => null,
        Object $1 => GoogleMaps.fromJson($1),
      },
      enterpriseWebSearch: switch (json['enterpriseWebSearch']) {
        null => null,
        Object $1 => EnterpriseWebSearch.fromJson($1),
      },
      codeExecution: switch (json['codeExecution']) {
        null => null,
        Object $1 => Tool_CodeExecution.fromJson($1),
      },
      urlContext: switch (json['urlContext']) {
        null => null,
        Object $1 => UrlContext.fromJson($1),
      },
      computerUse: switch (json['computerUse']) {
        null => null,
        Object $1 => Tool_ComputerUse.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (functionDeclarations.isNotDefault)
      'functionDeclarations': encodeList(functionDeclarations),
    if (retrieval != null) 'retrieval': retrieval!.toJson(),
    if (googleSearch != null) 'googleSearch': googleSearch!.toJson(),
    if (googleSearchRetrieval != null)
      'googleSearchRetrieval': googleSearchRetrieval!.toJson(),
    if (googleMaps != null) 'googleMaps': googleMaps!.toJson(),
    if (enterpriseWebSearch != null)
      'enterpriseWebSearch': enterpriseWebSearch!.toJson(),
    if (codeExecution != null) 'codeExecution': codeExecution!.toJson(),
    if (urlContext != null) 'urlContext': urlContext!.toJson(),
    if (computerUse != null) 'computerUse': computerUse!.toJson(),
  };

  @override
  String toString() => 'Tool()';
}

/// GoogleSearch tool type.
/// Tool to support Google Search in Model. Powered by Google.
final class Tool_GoogleSearch extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tool.GoogleSearch';

  /// Optional. List of domains to be excluded from the search results.
  /// The default limit is 2000 domains.
  /// Example: ["amazon.com", "facebook.com"].
  final List<String> excludeDomains;

  /// Optional. Sites with confidence level chosen & above this value will be
  /// blocked from the search results.
  final Tool_PhishBlockThreshold? blockingConfidence;

  Tool_GoogleSearch({this.excludeDomains = const [], this.blockingConfidence})
    : super(fullyQualifiedName);

  factory Tool_GoogleSearch.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Tool_GoogleSearch(
      excludeDomains: switch (json['excludeDomains']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"excludeDomains" is not a list'),
      },
      blockingConfidence: switch (json['blockingConfidence']) {
        null => null,
        Object $1 => Tool_PhishBlockThreshold.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (excludeDomains.isNotDefault) 'excludeDomains': excludeDomains,
    if (blockingConfidence != null)
      'blockingConfidence': blockingConfidence!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (blockingConfidence != null) 'blockingConfidence=$blockingConfidence',
    ].join(',');
    return 'GoogleSearch($contents)';
  }
}

/// Tool that executes code generated by the model, and automatically returns
/// the result to the model.
///
/// See also [ExecutableCode]and [CodeExecutionResult] which are input and
/// output to this tool.
final class Tool_CodeExecution extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tool.CodeExecution';

  Tool_CodeExecution() : super(fullyQualifiedName);

  factory Tool_CodeExecution.fromJson(Object? j) => Tool_CodeExecution();

  @override
  Object toJson() => {};

  @override
  String toString() => 'CodeExecution()';
}

/// Tool to support computer use.
final class Tool_ComputerUse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tool.ComputerUse';

  /// Required. The environment being operated.
  final Tool_ComputerUse_Environment environment;

  Tool_ComputerUse({required this.environment}) : super(fullyQualifiedName);

  factory Tool_ComputerUse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Tool_ComputerUse(
      environment: switch (json['environment']) {
        null => Tool_ComputerUse_Environment.$default,
        Object $1 => Tool_ComputerUse_Environment.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {'environment': environment.toJson()};

  @override
  String toString() {
    final contents = ['environment=$environment'].join(',');
    return 'ComputerUse($contents)';
  }
}

/// Represents the environment being operated, such as a web browser.
final class Tool_ComputerUse_Environment extends ProtoEnum {
  /// Defaults to browser.
  static const environmentUnspecified = Tool_ComputerUse_Environment(
    'ENVIRONMENT_UNSPECIFIED',
  );

  /// Operates in a web browser.
  static const environmentBrowser = Tool_ComputerUse_Environment(
    'ENVIRONMENT_BROWSER',
  );

  /// The default value for [Tool_ComputerUse_Environment].
  static const $default = environmentUnspecified;

  const Tool_ComputerUse_Environment(super.value);

  factory Tool_ComputerUse_Environment.fromJson(Object? json) =>
      Tool_ComputerUse_Environment(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Environment.$value';
}

/// These are available confidence level user can set to block malicious urls
/// with chosen confidence and above. For understanding different confidence of
/// webrisk, please refer to
/// https://cloud.google.com/web-risk/docs/reference/rpc/google.cloud.webrisk.v1eap1#confidencelevel
final class Tool_PhishBlockThreshold extends ProtoEnum {
  /// Defaults to unspecified.
  static const phishBlockThresholdUnspecified = Tool_PhishBlockThreshold(
    'PHISH_BLOCK_THRESHOLD_UNSPECIFIED',
  );

  /// Blocks Low and above confidence URL that is risky.
  static const blockLowAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_LOW_AND_ABOVE',
  );

  /// Blocks Medium and above confidence URL that is risky.
  static const blockMediumAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_MEDIUM_AND_ABOVE',
  );

  /// Blocks High and above confidence URL that is risky.
  static const blockHighAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_HIGH_AND_ABOVE',
  );

  /// Blocks Higher and above confidence URL that is risky.
  static const blockHigherAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_HIGHER_AND_ABOVE',
  );

  /// Blocks Very high and above confidence URL that is risky.
  static const blockVeryHighAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_VERY_HIGH_AND_ABOVE',
  );

  /// Blocks Extremely high confidence URL that is risky.
  static const blockOnlyExtremelyHigh = Tool_PhishBlockThreshold(
    'BLOCK_ONLY_EXTREMELY_HIGH',
  );

  /// The default value for [Tool_PhishBlockThreshold].
  static const $default = phishBlockThresholdUnspecified;

  const Tool_PhishBlockThreshold(super.value);

  factory Tool_PhishBlockThreshold.fromJson(Object? json) =>
      Tool_PhishBlockThreshold(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PhishBlockThreshold.$value';
}

/// Tool to support URL context.
final class UrlContext extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UrlContext';

  UrlContext() : super(fullyQualifiedName);

  factory UrlContext.fromJson(Object? j) => UrlContext();

  @override
  Object toJson() => {};

  @override
  String toString() => 'UrlContext()';
}

/// A single example of the tool usage.
final class ToolUseExample extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolUseExample';

  /// Extension operation to call.
  final ToolUseExample_ExtensionOperation? extensionOperation;

  /// Function name to call.
  final String? functionName;

  /// Required. The display name for example.
  final String displayName;

  /// Required. Query that should be routed to this tool.
  final String query;

  /// Request parameters used for executing this tool.
  final protobuf.Struct? requestParams;

  /// Response parameters generated by this tool.
  final protobuf.Struct? responseParams;

  /// Summary of the tool response to the user query.
  final String responseSummary;

  ToolUseExample({
    this.extensionOperation,
    this.functionName,
    required this.displayName,
    required this.query,
    this.requestParams,
    this.responseParams,
    this.responseSummary = '',
  }) : super(fullyQualifiedName);

  factory ToolUseExample.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolUseExample(
      extensionOperation: switch (json['extensionOperation']) {
        null => null,
        Object $1 => ToolUseExample_ExtensionOperation.fromJson($1),
      },
      functionName: switch (json['functionName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      query: switch (json['query']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requestParams: switch (json['requestParams']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      responseParams: switch (json['responseParams']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
      responseSummary: switch (json['responseSummary']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (extensionOperation != null)
      'extensionOperation': extensionOperation!.toJson(),
    if (functionName != null) 'functionName': functionName,
    'displayName': displayName,
    'query': query,
    if (requestParams != null) 'requestParams': requestParams!.toJson(),
    if (responseParams != null) 'responseParams': responseParams!.toJson(),
    if (responseSummary.isNotDefault) 'responseSummary': responseSummary,
  };

  @override
  String toString() {
    final contents = [
      if (functionName != null) 'functionName=$functionName',
      'displayName=$displayName',
      'query=$query',
      'responseSummary=$responseSummary',
    ].join(',');
    return 'ToolUseExample($contents)';
  }
}

/// Identifies one operation of the extension.
final class ToolUseExample_ExtensionOperation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolUseExample.ExtensionOperation';

  /// Resource name of the extension.
  final String extension;

  /// Required. Operation ID of the extension.
  final String operationId;

  ToolUseExample_ExtensionOperation({
    this.extension = '',
    required this.operationId,
  }) : super(fullyQualifiedName);

  factory ToolUseExample_ExtensionOperation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolUseExample_ExtensionOperation(
      extension: switch (json['extension']) {
        null => '',
        Object $1 => decodeString($1),
      },
      operationId: switch (json['operationId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (extension.isNotDefault) 'extension': extension,
    'operationId': operationId,
  };

  @override
  String toString() {
    final contents = [
      'extension=$extension',
      'operationId=$operationId',
    ].join(',');
    return 'ExtensionOperation($contents)';
  }
}

/// Structured representation of a function declaration as defined by the
/// [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included
/// in this declaration are the function name, description, parameters and
/// response type. This FunctionDeclaration is a representation of a block of
/// code that can be used as a `Tool` by the model and executed by the client.
final class FunctionDeclaration extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FunctionDeclaration';

  /// Required. The name of the function to call.
  /// Must start with a letter or an underscore.
  /// Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a
  /// maximum length of 64.
  final String name;

  /// Optional. Description and purpose of the function.
  /// Model uses it to decide how and whether to call the function.
  final String description;

  /// Optional. Describes the parameters to this function in JSON Schema Object
  /// format. Reflects the Open API 3.03 Parameter Object. string Key: the name
  /// of the parameter. Parameter names are case sensitive. Schema Value: the
  /// Schema defining the type used for the parameter. For function with no
  /// parameters, this can be left unset. Parameter names must start with a
  /// letter or an underscore and must only contain chars a-z, A-Z, 0-9, or
  /// underscores with a maximum length of 64. Example with 1 required and 1
  /// optional parameter: type: OBJECT properties:
  ///  param1:
  ///    type: STRING
  ///  param2:
  ///    type: INTEGER
  /// required:
  ///  - param1
  final Schema? parameters;

  /// Optional. Describes the parameters to the function in JSON Schema format.
  /// The schema must describe an object where the properties are the parameters
  /// to the function. For example:
  ///
  /// ```
  /// {
  ///   "type": "object",
  ///   "properties": {
  ///     "name": { "type": "string" },
  ///     "age": { "type": "integer" }
  ///   },
  ///   "additionalProperties": false,
  ///   "required": ["name", "age"],
  ///   "propertyOrdering": ["name", "age"]
  /// }
  /// ```
  ///
  /// This field is mutually exclusive with `parameters`.
  final protobuf.Value? parametersJsonSchema;

  /// Optional. Describes the output from this function in JSON Schema format.
  /// Reflects the Open API 3.03 Response Object. The Schema defines the type
  /// used for the response value of the function.
  final Schema? response;

  /// Optional. Describes the output from this function in JSON Schema format.
  /// The value specified by the schema is the response value of the function.
  ///
  /// This field is mutually exclusive with `response`.
  final protobuf.Value? responseJsonSchema;

  FunctionDeclaration({
    required this.name,
    this.description = '',
    this.parameters,
    this.parametersJsonSchema,
    this.response,
    this.responseJsonSchema,
  }) : super(fullyQualifiedName);

  factory FunctionDeclaration.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FunctionDeclaration(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => Schema.fromJson($1),
      },
      parametersJsonSchema: switch (json['parametersJsonSchema']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      response: switch (json['response']) {
        null => null,
        Object $1 => Schema.fromJson($1),
      },
      responseJsonSchema: switch (json['responseJsonSchema']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (description.isNotDefault) 'description': description,
    if (parameters != null) 'parameters': parameters!.toJson(),
    if (parametersJsonSchema != null)
      'parametersJsonSchema': parametersJsonSchema!.toJson(),
    if (response != null) 'response': response!.toJson(),
    if (responseJsonSchema != null)
      'responseJsonSchema': responseJsonSchema!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'description=$description'].join(',');
    return 'FunctionDeclaration($contents)';
  }
}

/// A predicted [FunctionCall] returned from the model that contains a string
/// representing the [FunctionDeclaration.name] and a structured JSON object
/// containing the parameters and their values.
final class FunctionCall extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FunctionCall';

  /// Optional. The unique id of the function call. If populated, the client to
  /// execute the `function_call` and return the response with the matching `id`.
  final String id;

  /// Required. The name of the function to call.
  /// Matches [FunctionDeclaration.name].
  final String name;

  /// Optional. Required. The function parameters and values in JSON object
  /// format. See [FunctionDeclaration.parameters] for parameter details.
  final protobuf.Struct? args;

  FunctionCall({this.id = '', required this.name, this.args})
    : super(fullyQualifiedName);

  factory FunctionCall.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FunctionCall(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      args: switch (json['args']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    'name': name,
    if (args != null) 'args': args!.toJson(),
  };

  @override
  String toString() {
    final contents = ['id=$id', 'name=$name'].join(',');
    return 'FunctionCall($contents)';
  }
}

/// The result output from a [FunctionCall] that contains a string representing
/// the [FunctionDeclaration.name] and a structured JSON object containing any
/// output from the function is used as context to the model. This should contain
/// the result of a [FunctionCall] made based on model prediction.
final class FunctionResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FunctionResponse';

  /// Optional. The id of the function call this response is for. Populated by
  /// the client to match the corresponding function call `id`.
  final String id;

  /// Required. The name of the function to call.
  /// Matches [FunctionDeclaration.name] and [FunctionCall.name].
  final String name;

  /// Required. The function response in JSON object format.
  /// Use "output" key to specify function output and "error" key to specify
  /// error details (if any). If "output" and "error" keys are not specified,
  /// then whole "response" is treated as function output.
  final protobuf.Struct? response;

  FunctionResponse({this.id = '', required this.name, required this.response})
    : super(fullyQualifiedName);

  factory FunctionResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FunctionResponse(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      response: switch (json['response']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    'name': name,
    if (response != null) 'response': response!.toJson(),
  };

  @override
  String toString() {
    final contents = ['id=$id', 'name=$name'].join(',');
    return 'FunctionResponse($contents)';
  }
}

/// Code generated by the model that is meant to be executed, and the result
/// returned to the model.
///
/// Generated when using the [FunctionDeclaration] tool and
/// [FunctionCallingConfig] mode is set to [Mode.CODE].
final class ExecutableCode extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExecutableCode';

  /// Required. Programming language of the `code`.
  final ExecutableCode_Language language;

  /// Required. The code to be executed.
  final String code;

  ExecutableCode({required this.language, required this.code})
    : super(fullyQualifiedName);

  factory ExecutableCode.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ExecutableCode(
      language: switch (json['language']) {
        null => ExecutableCode_Language.$default,
        Object $1 => ExecutableCode_Language.fromJson($1),
      },
      code: switch (json['code']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'language': language.toJson(), 'code': code};

  @override
  String toString() {
    final contents = ['language=$language', 'code=$code'].join(',');
    return 'ExecutableCode($contents)';
  }
}

/// Supported programming languages for the generated code.
final class ExecutableCode_Language extends ProtoEnum {
  /// Unspecified language. This value should not be used.
  static const languageUnspecified = ExecutableCode_Language(
    'LANGUAGE_UNSPECIFIED',
  );

  /// Python >= 3.10, with numpy and simpy available.
  static const python = ExecutableCode_Language('PYTHON');

  /// The default value for [ExecutableCode_Language].
  static const $default = languageUnspecified;

  const ExecutableCode_Language(super.value);

  factory ExecutableCode_Language.fromJson(Object? json) =>
      ExecutableCode_Language(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Language.$value';
}

/// Result of executing the [ExecutableCode].
///
/// Always follows a `part` containing the [ExecutableCode].
final class CodeExecutionResult extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CodeExecutionResult';

  /// Required. Outcome of the code execution.
  final CodeExecutionResult_Outcome outcome;

  /// Optional. Contains stdout when code execution is successful, stderr or
  /// other description otherwise.
  final String output;

  CodeExecutionResult({required this.outcome, this.output = ''})
    : super(fullyQualifiedName);

  factory CodeExecutionResult.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CodeExecutionResult(
      outcome: switch (json['outcome']) {
        null => CodeExecutionResult_Outcome.$default,
        Object $1 => CodeExecutionResult_Outcome.fromJson($1),
      },
      output: switch (json['output']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'outcome': outcome.toJson(),
    if (output.isNotDefault) 'output': output,
  };

  @override
  String toString() {
    final contents = ['outcome=$outcome', 'output=$output'].join(',');
    return 'CodeExecutionResult($contents)';
  }
}

/// Enumeration of possible outcomes of the code execution.
final class CodeExecutionResult_Outcome extends ProtoEnum {
  /// Unspecified status. This value should not be used.
  static const outcomeUnspecified = CodeExecutionResult_Outcome(
    'OUTCOME_UNSPECIFIED',
  );

  /// Code execution completed successfully.
  static const outcomeOk = CodeExecutionResult_Outcome('OUTCOME_OK');

  /// Code execution finished but with a failure. `stderr` should contain the
  /// reason.
  static const outcomeFailed = CodeExecutionResult_Outcome('OUTCOME_FAILED');

  /// Code execution ran for too long, and was cancelled. There may or may not
  /// be a partial output present.
  static const outcomeDeadlineExceeded = CodeExecutionResult_Outcome(
    'OUTCOME_DEADLINE_EXCEEDED',
  );

  /// The default value for [CodeExecutionResult_Outcome].
  static const $default = outcomeUnspecified;

  const CodeExecutionResult_Outcome(super.value);

  factory CodeExecutionResult_Outcome.fromJson(Object? json) =>
      CodeExecutionResult_Outcome(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Outcome.$value';
}

/// Defines a retrieval tool that model can call to access external knowledge.
final class Retrieval extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Retrieval';

  /// Set to use data source powered by Vertex AI Search.
  final VertexAisearch? vertexAiSearch;

  /// Set to use data source powered by Vertex RAG store.
  /// User data is uploaded via the VertexRagDataService.
  final VertexRagStore? vertexRagStore;

  /// Optional. Deprecated. This option is no longer supported.
  final bool disableAttribution;

  Retrieval({
    this.vertexAiSearch,
    this.vertexRagStore,
    this.disableAttribution = false,
  }) : super(fullyQualifiedName);

  factory Retrieval.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Retrieval(
      vertexAiSearch: switch (json['vertexAiSearch']) {
        null => null,
        Object $1 => VertexAisearch.fromJson($1),
      },
      vertexRagStore: switch (json['vertexRagStore']) {
        null => null,
        Object $1 => VertexRagStore.fromJson($1),
      },
      disableAttribution: switch (json['disableAttribution']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vertexAiSearch != null) 'vertexAiSearch': vertexAiSearch!.toJson(),
    if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!.toJson(),
    if (disableAttribution.isNotDefault)
      'disableAttribution': disableAttribution,
  };

  @override
  String toString() {
    final contents = ['disableAttribution=$disableAttribution'].join(',');
    return 'Retrieval($contents)';
  }
}

/// Retrieve from Vertex RAG Store for grounding.
final class VertexRagStore extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexRagStore';

  /// Optional. Deprecated. Please use rag_resources instead.
  final List<String> ragCorpora;

  /// Optional. The representation of the rag source. It can be used to specify
  /// corpus only or ragfiles. Currently only support one corpus or multiple
  /// files from one corpus. In the future we may open up multiple corpora
  /// support.
  final List<VertexRagStore_RagResource> ragResources;

  /// Optional. Number of top k results to return from the selected corpora.
  final int? similarityTopK;

  /// Optional. Only return results with vector distance smaller than the
  /// threshold.
  final double? vectorDistanceThreshold;

  /// Optional. The retrieval config for the Rag query.
  final RagRetrievalConfig? ragRetrievalConfig;

  /// Optional. Currently only supported for Gemini Multimodal Live API.
  ///
  /// In Gemini Multimodal Live API, if `store_context` bool is
  /// true, Gemini will leverage it to automatically memorize the
  /// interactions between the client and Gemini, and retrieve context when
  /// needed to augment the response generation for users' ongoing and future
  /// interactions.
  final bool storeContext;

  VertexRagStore({
    this.ragCorpora = const [],
    this.ragResources = const [],
    this.similarityTopK,
    this.vectorDistanceThreshold,
    this.ragRetrievalConfig,
    this.storeContext = false,
  }) : super(fullyQualifiedName);

  factory VertexRagStore.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VertexRagStore(
      ragCorpora: switch (json['ragCorpora']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"ragCorpora" is not a list'),
      },
      ragResources: switch (json['ragResources']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) VertexRagStore_RagResource.fromJson(i),
        ],
        _ => throw const FormatException('"ragResources" is not a list'),
      },
      similarityTopK: switch (json['similarityTopK']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      vectorDistanceThreshold: switch (json['vectorDistanceThreshold']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      ragRetrievalConfig: switch (json['ragRetrievalConfig']) {
        null => null,
        Object $1 => RagRetrievalConfig.fromJson($1),
      },
      storeContext: switch (json['storeContext']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragCorpora.isNotDefault) 'ragCorpora': ragCorpora,
    if (ragResources.isNotDefault) 'ragResources': encodeList(ragResources),
    if (similarityTopK != null) 'similarityTopK': similarityTopK,
    if (vectorDistanceThreshold != null)
      'vectorDistanceThreshold': encodeDouble(vectorDistanceThreshold),
    if (ragRetrievalConfig != null)
      'ragRetrievalConfig': ragRetrievalConfig!.toJson(),
    if (storeContext.isNotDefault) 'storeContext': storeContext,
  };

  @override
  String toString() {
    final contents = [
      if (similarityTopK != null) 'similarityTopK=$similarityTopK',
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold=$vectorDistanceThreshold',
      'storeContext=$storeContext',
    ].join(',');
    return 'VertexRagStore($contents)';
  }
}

/// The definition of the Rag resource.
final class VertexRagStore_RagResource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexRagStore.RagResource';

  /// Optional. RagCorpora resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String ragCorpus;

  /// Optional. rag_file_id. The files should be in the same rag_corpus set in
  /// rag_corpus field.
  final List<String> ragFileIds;

  VertexRagStore_RagResource({this.ragCorpus = '', this.ragFileIds = const []})
    : super(fullyQualifiedName);

  factory VertexRagStore_RagResource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VertexRagStore_RagResource(
      ragCorpus: switch (json['ragCorpus']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ragFileIds: switch (json['ragFileIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"ragFileIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragCorpus.isNotDefault) 'ragCorpus': ragCorpus,
    if (ragFileIds.isNotDefault) 'ragFileIds': ragFileIds,
  };

  @override
  String toString() {
    final contents = ['ragCorpus=$ragCorpus'].join(',');
    return 'RagResource($contents)';
  }
}

/// Retrieve from Vertex AI Search datastore or engine for grounding.
/// datastore and engine are mutually exclusive.
/// See https://cloud.google.com/products/agent-builder
final class VertexAisearch extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexAISearch';

  /// Optional. Fully-qualified Vertex AI Search data store resource ID.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
  final String datastore;

  /// Optional. Fully-qualified Vertex AI Search engine resource ID.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
  final String engine;

  /// Optional. Number of search results to return per query.
  /// The default value is 10.
  /// The maximumm allowed value is 10.
  final int maxResults;

  /// Optional. Filter strings to be passed to the search API.
  final String filter;

  /// Specifications that define the specific DataStores to be searched, along
  /// with configurations for those data stores. This is only considered for
  /// Engines with multiple data stores.
  /// It should only be set if engine is used.
  final List<VertexAisearch_DataStoreSpec> dataStoreSpecs;

  VertexAisearch({
    this.datastore = '',
    this.engine = '',
    this.maxResults = 0,
    this.filter = '',
    this.dataStoreSpecs = const [],
  }) : super(fullyQualifiedName);

  factory VertexAisearch.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VertexAisearch(
      datastore: switch (json['datastore']) {
        null => '',
        Object $1 => decodeString($1),
      },
      engine: switch (json['engine']) {
        null => '',
        Object $1 => decodeString($1),
      },
      maxResults: switch (json['maxResults']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dataStoreSpecs: switch (json['dataStoreSpecs']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) VertexAisearch_DataStoreSpec.fromJson(i),
        ],
        _ => throw const FormatException('"dataStoreSpecs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (datastore.isNotDefault) 'datastore': datastore,
    if (engine.isNotDefault) 'engine': engine,
    if (maxResults.isNotDefault) 'maxResults': maxResults,
    if (filter.isNotDefault) 'filter': filter,
    if (dataStoreSpecs.isNotDefault)
      'dataStoreSpecs': encodeList(dataStoreSpecs),
  };

  @override
  String toString() {
    final contents = [
      'datastore=$datastore',
      'engine=$engine',
      'maxResults=$maxResults',
      'filter=$filter',
    ].join(',');
    return 'VertexAISearch($contents)';
  }
}

/// Define data stores within engine to filter on in a search call and
/// configurations for those data stores. For more information, see
/// https://cloud.google.com/generative-ai-app-builder/docs/reference/rpc/google.cloud.discoveryengine.v1#datastorespec
final class VertexAisearch_DataStoreSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexAISearch.DataStoreSpec';

  /// Full resource name of DataStore, such as
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
  final String dataStore;

  /// Optional. Filter specification to filter documents in the data store
  /// specified by data_store field. For more information on filtering, see
  /// [Filtering](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
  final String filter;

  VertexAisearch_DataStoreSpec({this.dataStore = '', this.filter = ''})
    : super(fullyQualifiedName);

  factory VertexAisearch_DataStoreSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VertexAisearch_DataStoreSpec(
      dataStore: switch (json['dataStore']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dataStore.isNotDefault) 'dataStore': dataStore,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = ['dataStore=$dataStore', 'filter=$filter'].join(',');
    return 'DataStoreSpec($contents)';
  }
}

/// Tool to retrieve public web data for grounding, powered by Google.
final class GoogleSearchRetrieval extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GoogleSearchRetrieval';

  /// Specifies the dynamic retrieval configuration for the given source.
  final DynamicRetrievalConfig? dynamicRetrievalConfig;

  GoogleSearchRetrieval({this.dynamicRetrievalConfig})
    : super(fullyQualifiedName);

  factory GoogleSearchRetrieval.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GoogleSearchRetrieval(
      dynamicRetrievalConfig: switch (json['dynamicRetrievalConfig']) {
        null => null,
        Object $1 => DynamicRetrievalConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dynamicRetrievalConfig != null)
      'dynamicRetrievalConfig': dynamicRetrievalConfig!.toJson(),
  };

  @override
  String toString() => 'GoogleSearchRetrieval()';
}

/// Tool to retrieve public maps data for grounding, powered by Google.
final class GoogleMaps extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GoogleMaps';

  /// If true, include the widget context token in the response.
  final bool enableWidget;

  GoogleMaps({this.enableWidget = false}) : super(fullyQualifiedName);

  factory GoogleMaps.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GoogleMaps(
      enableWidget: switch (json['enableWidget']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enableWidget.isNotDefault) 'enableWidget': enableWidget,
  };

  @override
  String toString() {
    final contents = ['enableWidget=$enableWidget'].join(',');
    return 'GoogleMaps($contents)';
  }
}

/// Tool to search public web data, powered by Vertex AI Search and Sec4
/// compliance.
final class EnterpriseWebSearch extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EnterpriseWebSearch';

  /// Optional. List of domains to be excluded from the search results.
  /// The default limit is 2000 domains.
  final List<String> excludeDomains;

  /// Optional. Sites with confidence level chosen & above this value will be
  /// blocked from the search results.
  final Tool_PhishBlockThreshold? blockingConfidence;

  EnterpriseWebSearch({this.excludeDomains = const [], this.blockingConfidence})
    : super(fullyQualifiedName);

  factory EnterpriseWebSearch.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EnterpriseWebSearch(
      excludeDomains: switch (json['excludeDomains']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"excludeDomains" is not a list'),
      },
      blockingConfidence: switch (json['blockingConfidence']) {
        null => null,
        Object $1 => Tool_PhishBlockThreshold.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (excludeDomains.isNotDefault) 'excludeDomains': excludeDomains,
    if (blockingConfidence != null)
      'blockingConfidence': blockingConfidence!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (blockingConfidence != null) 'blockingConfidence=$blockingConfidence',
    ].join(',');
    return 'EnterpriseWebSearch($contents)';
  }
}

/// Describes the options to customize dynamic retrieval.
final class DynamicRetrievalConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DynamicRetrievalConfig';

  /// The mode of the predictor to be used in dynamic retrieval.
  final DynamicRetrievalConfig_Mode mode;

  /// Optional. The threshold to be used in dynamic retrieval.
  /// If not set, a system default value is used.
  final double? dynamicThreshold;

  DynamicRetrievalConfig({
    this.mode = DynamicRetrievalConfig_Mode.$default,
    this.dynamicThreshold,
  }) : super(fullyQualifiedName);

  factory DynamicRetrievalConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DynamicRetrievalConfig(
      mode: switch (json['mode']) {
        null => DynamicRetrievalConfig_Mode.$default,
        Object $1 => DynamicRetrievalConfig_Mode.fromJson($1),
      },
      dynamicThreshold: switch (json['dynamicThreshold']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (mode.isNotDefault) 'mode': mode.toJson(),
    if (dynamicThreshold != null)
      'dynamicThreshold': encodeDouble(dynamicThreshold),
  };

  @override
  String toString() {
    final contents = [
      'mode=$mode',
      if (dynamicThreshold != null) 'dynamicThreshold=$dynamicThreshold',
    ].join(',');
    return 'DynamicRetrievalConfig($contents)';
  }
}

/// The mode of the predictor to be used in dynamic retrieval.
final class DynamicRetrievalConfig_Mode extends ProtoEnum {
  /// Always trigger retrieval.
  static const modeUnspecified = DynamicRetrievalConfig_Mode(
    'MODE_UNSPECIFIED',
  );

  /// Run retrieval only when system decides it is necessary.
  static const modeDynamic = DynamicRetrievalConfig_Mode('MODE_DYNAMIC');

  /// The default value for [DynamicRetrievalConfig_Mode].
  static const $default = modeUnspecified;

  const DynamicRetrievalConfig_Mode(super.value);

  factory DynamicRetrievalConfig_Mode.fromJson(Object? json) =>
      DynamicRetrievalConfig_Mode(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Mode.$value';
}

/// Tool config. This config is shared for all tools provided in the request.
final class ToolConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolConfig';

  /// Optional. Function calling config.
  final FunctionCallingConfig? functionCallingConfig;

  /// Optional. Retrieval config.
  final RetrievalConfig? retrievalConfig;

  ToolConfig({this.functionCallingConfig, this.retrievalConfig})
    : super(fullyQualifiedName);

  factory ToolConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ToolConfig(
      functionCallingConfig: switch (json['functionCallingConfig']) {
        null => null,
        Object $1 => FunctionCallingConfig.fromJson($1),
      },
      retrievalConfig: switch (json['retrievalConfig']) {
        null => null,
        Object $1 => RetrievalConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (functionCallingConfig != null)
      'functionCallingConfig': functionCallingConfig!.toJson(),
    if (retrievalConfig != null) 'retrievalConfig': retrievalConfig!.toJson(),
  };

  @override
  String toString() => 'ToolConfig()';
}

/// Function calling config.
final class FunctionCallingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FunctionCallingConfig';

  /// Optional. Function calling mode.
  final FunctionCallingConfig_Mode mode;

  /// Optional. Function names to call. Only set when the Mode is ANY. Function
  /// names should match [FunctionDeclaration.name]. With mode set to ANY, model
  /// will predict a function call from the set of function names provided.
  final List<String> allowedFunctionNames;

  FunctionCallingConfig({
    this.mode = FunctionCallingConfig_Mode.$default,
    this.allowedFunctionNames = const [],
  }) : super(fullyQualifiedName);

  factory FunctionCallingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FunctionCallingConfig(
      mode: switch (json['mode']) {
        null => FunctionCallingConfig_Mode.$default,
        Object $1 => FunctionCallingConfig_Mode.fromJson($1),
      },
      allowedFunctionNames: switch (json['allowedFunctionNames']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"allowedFunctionNames" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (mode.isNotDefault) 'mode': mode.toJson(),
    if (allowedFunctionNames.isNotDefault)
      'allowedFunctionNames': allowedFunctionNames,
  };

  @override
  String toString() {
    final contents = ['mode=$mode'].join(',');
    return 'FunctionCallingConfig($contents)';
  }
}

/// Function calling mode.
final class FunctionCallingConfig_Mode extends ProtoEnum {
  /// Unspecified function calling mode. This value should not be used.
  static const modeUnspecified = FunctionCallingConfig_Mode('MODE_UNSPECIFIED');

  /// Default model behavior, model decides to predict either function calls
  /// or natural language response.
  static const auto = FunctionCallingConfig_Mode('AUTO');

  /// Model is constrained to always predicting function calls only.
  /// If `allowed_function_names`
  /// are set, the predicted function calls will be limited to any one of
  /// `allowed_function_names`, else the predicted function calls will be any
  /// one of the provided [FunctionDeclaration].
  static const any = FunctionCallingConfig_Mode('ANY');

  /// Model will not predict any function calls. Model behavior is same as when
  /// not passing any function declarations.
  static const none = FunctionCallingConfig_Mode('NONE');

  /// Model is constrained to predict either function calls or natural language
  /// response.
  /// If `allowed_function_names`
  /// are set, the predicted function calls will be limited to any one of
  /// `allowed_function_names`, else the predicted function calls will be any
  /// one of the provided [FunctionDeclaration].
  static const validated = FunctionCallingConfig_Mode('VALIDATED');

  /// The default value for [FunctionCallingConfig_Mode].
  static const $default = modeUnspecified;

  const FunctionCallingConfig_Mode(super.value);

  factory FunctionCallingConfig_Mode.fromJson(Object? json) =>
      FunctionCallingConfig_Mode(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Mode.$value';
}

/// Retrieval config.
final class RetrievalConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrievalConfig';

  /// The location of the user.
  final LatLng? latLng;

  /// The language code of the user.
  final String? languageCode;

  RetrievalConfig({this.latLng, this.languageCode}) : super(fullyQualifiedName);

  factory RetrievalConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrievalConfig(
      latLng: switch (json['latLng']) {
        null => null,
        Object $1 => LatLng.fromJson($1),
      },
      languageCode: switch (json['languageCode']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (latLng != null) 'latLng': latLng!.toJson(),
    if (languageCode != null) 'languageCode': languageCode,
  };

  @override
  String toString() {
    final contents = [
      if (languageCode != null) 'languageCode=$languageCode',
    ].join(',');
    return 'RetrievalConfig($contents)';
  }
}

/// Specifies the context retrieval config.
final class RagRetrievalConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig';

  /// Optional. The number of contexts to retrieve.
  final int topK;

  /// Optional. Config for Hybrid Search.
  final RagRetrievalConfig_HybridSearch? hybridSearch;

  /// Optional. Config for filters.
  final RagRetrievalConfig_Filter? filter;

  /// Optional. Config for ranking and reranking.
  final RagRetrievalConfig_Ranking? ranking;

  RagRetrievalConfig({
    this.topK = 0,
    this.hybridSearch,
    this.filter,
    this.ranking,
  }) : super(fullyQualifiedName);

  factory RagRetrievalConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagRetrievalConfig(
      topK: switch (json['topK']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      hybridSearch: switch (json['hybridSearch']) {
        null => null,
        Object $1 => RagRetrievalConfig_HybridSearch.fromJson($1),
      },
      filter: switch (json['filter']) {
        null => null,
        Object $1 => RagRetrievalConfig_Filter.fromJson($1),
      },
      ranking: switch (json['ranking']) {
        null => null,
        Object $1 => RagRetrievalConfig_Ranking.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (topK.isNotDefault) 'topK': topK,
    if (hybridSearch != null) 'hybridSearch': hybridSearch!.toJson(),
    if (filter != null) 'filter': filter!.toJson(),
    if (ranking != null) 'ranking': ranking!.toJson(),
  };

  @override
  String toString() {
    final contents = ['topK=$topK'].join(',');
    return 'RagRetrievalConfig($contents)';
  }
}

/// Config for Hybrid Search.
final class RagRetrievalConfig_HybridSearch extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.HybridSearch';

  /// Optional. Alpha value controls the weight between dense and sparse vector
  /// search results. The range is [0, 1], while 0 means sparse vector search
  /// only and 1 means dense vector search only. The default value is 0.5 which
  /// balances sparse and dense vector search equally.
  final double? alpha;

  RagRetrievalConfig_HybridSearch({this.alpha}) : super(fullyQualifiedName);

  factory RagRetrievalConfig_HybridSearch.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagRetrievalConfig_HybridSearch(
      alpha: switch (json['alpha']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (alpha != null) 'alpha': encodeDouble(alpha)};

  @override
  String toString() {
    final contents = [if (alpha != null) 'alpha=$alpha'].join(',');
    return 'HybridSearch($contents)';
  }
}

/// Config for filters.
final class RagRetrievalConfig_Filter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.Filter';

  /// Optional. Only returns contexts with vector distance smaller than the
  /// threshold.
  final double? vectorDistanceThreshold;

  /// Optional. Only returns contexts with vector similarity larger than the
  /// threshold.
  final double? vectorSimilarityThreshold;

  /// Optional. String for metadata filtering.
  final String metadataFilter;

  RagRetrievalConfig_Filter({
    this.vectorDistanceThreshold,
    this.vectorSimilarityThreshold,
    this.metadataFilter = '',
  }) : super(fullyQualifiedName);

  factory RagRetrievalConfig_Filter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagRetrievalConfig_Filter(
      vectorDistanceThreshold: switch (json['vectorDistanceThreshold']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      vectorSimilarityThreshold: switch (json['vectorSimilarityThreshold']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      metadataFilter: switch (json['metadataFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vectorDistanceThreshold != null)
      'vectorDistanceThreshold': encodeDouble(vectorDistanceThreshold),
    if (vectorSimilarityThreshold != null)
      'vectorSimilarityThreshold': encodeDouble(vectorSimilarityThreshold),
    if (metadataFilter.isNotDefault) 'metadataFilter': metadataFilter,
  };

  @override
  String toString() {
    final contents = [
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold=$vectorDistanceThreshold',
      if (vectorSimilarityThreshold != null)
        'vectorSimilarityThreshold=$vectorSimilarityThreshold',
      'metadataFilter=$metadataFilter',
    ].join(',');
    return 'Filter($contents)';
  }
}

/// Config for ranking and reranking.
final class RagRetrievalConfig_Ranking extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.Ranking';

  /// Optional. Config for Rank Service.
  final RagRetrievalConfig_Ranking_RankService? rankService;

  /// Optional. Config for LlmRanker.
  final RagRetrievalConfig_Ranking_LlmRanker? llmRanker;

  RagRetrievalConfig_Ranking({this.rankService, this.llmRanker})
    : super(fullyQualifiedName);

  factory RagRetrievalConfig_Ranking.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagRetrievalConfig_Ranking(
      rankService: switch (json['rankService']) {
        null => null,
        Object $1 => RagRetrievalConfig_Ranking_RankService.fromJson($1),
      },
      llmRanker: switch (json['llmRanker']) {
        null => null,
        Object $1 => RagRetrievalConfig_Ranking_LlmRanker.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (rankService != null) 'rankService': rankService!.toJson(),
    if (llmRanker != null) 'llmRanker': llmRanker!.toJson(),
  };

  @override
  String toString() => 'Ranking()';
}

/// Config for Rank Service.
final class RagRetrievalConfig_Ranking_RankService extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.Ranking.RankService';

  /// Optional. The model name of the rank service.
  /// Format: `semantic-ranker-512@latest`
  final String? modelName;

  RagRetrievalConfig_Ranking_RankService({this.modelName})
    : super(fullyQualifiedName);

  factory RagRetrievalConfig_Ranking_RankService.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagRetrievalConfig_Ranking_RankService(
      modelName: switch (json['modelName']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (modelName != null) 'modelName': modelName};

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'RankService($contents)';
  }
}

/// Config for LlmRanker.
final class RagRetrievalConfig_Ranking_LlmRanker extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.Ranking.LlmRanker';

  /// Optional. The model name used for ranking.
  /// Format: `gemini-1.5-pro`
  final String? modelName;

  RagRetrievalConfig_Ranking_LlmRanker({this.modelName})
    : super(fullyQualifiedName);

  factory RagRetrievalConfig_Ranking_LlmRanker.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagRetrievalConfig_Ranking_LlmRanker(
      modelName: switch (json['modelName']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (modelName != null) 'modelName': modelName};

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'LlmRanker($contents)';
  }
}

/// The TrainingPipeline orchestrates tasks associated with training a Model. It
/// always executes the training task, and optionally may also
/// export data from Vertex AI's Dataset which becomes the training input,
/// `upload` the Model
/// to Vertex AI, and evaluate the Model.
final class TrainingPipeline extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrainingPipeline';

  /// Output only. Resource name of the TrainingPipeline.
  final String name;

  /// Required. The user-defined name of this TrainingPipeline.
  final String displayName;

  /// Specifies Vertex AI owned input data that may be used for training the
  /// Model. The TrainingPipeline's
  /// `training_task_definition`
  /// should make clear whether this config is used and if there are any special
  /// requirements on how it should be filled. If nothing about this config is
  /// mentioned in the
  /// `training_task_definition`,
  /// then it should be assumed that the TrainingPipeline does not depend on this
  /// configuration.
  final InputDataConfig? inputDataConfig;

  /// Required. A Google Cloud Storage path to the YAML file that defines the
  /// training task which is responsible for producing the model artifact, and
  /// may also include additional auxiliary work. The definition files that can
  /// be used here are found in
  /// gs://google-cloud-aiplatform/schema/trainingjob/definition/.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String trainingTaskDefinition;

  /// Required. The training task's parameter(s), as specified in the
  /// `training_task_definition`'s
  /// `inputs`.
  final protobuf.Value? trainingTaskInputs;

  /// Output only. The metadata information as specified in the
  /// `training_task_definition`'s
  /// `metadata`. This metadata is an auxiliary runtime and final information
  /// about the training task. While the pipeline is running this information is
  /// populated only at a best effort basis. Only present if the
  /// pipeline's
  /// `training_task_definition`
  /// contains `metadata` object.
  final protobuf.Value? trainingTaskMetadata;

  /// Describes the Model that may be uploaded (via
  /// `ModelService.UploadModel`)
  /// by this TrainingPipeline. The TrainingPipeline's
  /// `training_task_definition`
  /// should make clear whether this Model description should be populated, and
  /// if there are any special requirements regarding how it should be filled. If
  /// nothing is mentioned in the
  /// `training_task_definition`,
  /// then it should be assumed that this field should not be filled and the
  /// training task either uploads the Model without a need of this information,
  /// or that training task does not support uploading a Model as part of the
  /// pipeline. When the Pipeline's state becomes `PIPELINE_STATE_SUCCEEDED` and
  /// the trained Model had been uploaded into Vertex AI, then the
  /// model_to_upload's resource
  /// `name` is populated. The Model
  /// is always uploaded into the Project and Location in which this pipeline
  /// is.
  final Model? modelToUpload;

  /// Optional. The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  final String modelId;

  /// Optional. When specify this field, the `model_to_upload` will not be
  /// uploaded as a new model, instead, it will become a new version of this
  /// `parent_model`.
  final String parentModel;

  /// Output only. The detailed state of the pipeline.
  final PipelineState state;

  /// Output only. Only populated when the pipeline's state is
  /// `PIPELINE_STATE_FAILED` or `PIPELINE_STATE_CANCELLED`.
  final Status? error;

  /// Output only. Time when the TrainingPipeline was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the TrainingPipeline for the first time entered the
  /// `PIPELINE_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the TrainingPipeline entered any of the following
  /// states: `PIPELINE_STATE_SUCCEEDED`, `PIPELINE_STATE_FAILED`,
  /// `PIPELINE_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the TrainingPipeline was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize TrainingPipelines.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Customer-managed encryption key spec for a TrainingPipeline. If set, this
  /// TrainingPipeline will be secured by this key.
  ///
  /// Note: Model trained by this TrainingPipeline is also secured by this key if
  /// `model_to_upload`
  /// is not set separately.
  final EncryptionSpec? encryptionSpec;

  TrainingPipeline({
    this.name = '',
    required this.displayName,
    this.inputDataConfig,
    required this.trainingTaskDefinition,
    required this.trainingTaskInputs,
    this.trainingTaskMetadata,
    this.modelToUpload,
    this.modelId = '',
    this.parentModel = '',
    this.state = PipelineState.$default,
    this.error,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.labels = const {},
    this.encryptionSpec,
  }) : super(fullyQualifiedName);

  factory TrainingPipeline.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TrainingPipeline(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      inputDataConfig: switch (json['inputDataConfig']) {
        null => null,
        Object $1 => InputDataConfig.fromJson($1),
      },
      trainingTaskDefinition: switch (json['trainingTaskDefinition']) {
        null => '',
        Object $1 => decodeString($1),
      },
      trainingTaskInputs: switch (json['trainingTaskInputs']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      trainingTaskMetadata: switch (json['trainingTaskMetadata']) {
        null => null,
        Object $1 => protobuf.Value.fromJson($1),
      },
      modelToUpload: switch (json['modelToUpload']) {
        null => null,
        Object $1 => Model.fromJson($1),
      },
      modelId: switch (json['modelId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parentModel: switch (json['parentModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => PipelineState.$default,
        Object $1 => PipelineState.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (inputDataConfig != null) 'inputDataConfig': inputDataConfig!.toJson(),
    'trainingTaskDefinition': trainingTaskDefinition,
    if (trainingTaskInputs != null)
      'trainingTaskInputs': trainingTaskInputs!.toJson(),
    if (trainingTaskMetadata != null)
      'trainingTaskMetadata': trainingTaskMetadata!.toJson(),
    if (modelToUpload != null) 'modelToUpload': modelToUpload!.toJson(),
    if (modelId.isNotDefault) 'modelId': modelId,
    if (parentModel.isNotDefault) 'parentModel': parentModel,
    if (state.isNotDefault) 'state': state.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'trainingTaskDefinition=$trainingTaskDefinition',
      'modelId=$modelId',
      'parentModel=$parentModel',
      'state=$state',
    ].join(',');
    return 'TrainingPipeline($contents)';
  }
}

/// Specifies Vertex AI owned input data to be used for training, and
/// possibly evaluating, the Model.
final class InputDataConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.InputDataConfig';

  /// Split based on fractions defining the size of each set.
  final FractionSplit? fractionSplit;

  /// Split based on the provided filters for each set.
  final FilterSplit? filterSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on a predefined key.
  final PredefinedSplit? predefinedSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the timestamp of the input data pieces.
  final TimestampSplit? timestampSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the distribution of the specified column.
  final StratifiedSplit? stratifiedSplit;

  /// The Cloud Storage location where the training data is to be
  /// written to. In the given directory a new directory is created with
  /// name:
  /// `dataset-<dataset-id>-<annotation-type>-<timestamp-of-training-call>`
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format.
  /// All training input data is written into that directory.
  ///
  /// The Vertex AI environment variables representing Cloud Storage
  /// data URIs are represented in the Cloud Storage wildcard
  /// format to support sharded data. e.g.: "gs://.../training-*.jsonl"
  ///
  /// * AIP_DATA_FORMAT = "jsonl" for non-tabular data, "csv" for tabular data
  /// * AIP_TRAINING_DATA_URI =
  /// "gcs_destination/dataset-<dataset-id>-<annotation-type>-<time>/training-*.${AIP_DATA_FORMAT}"
  ///
  /// * AIP_VALIDATION_DATA_URI =
  /// "gcs_destination/dataset-<dataset-id>-<annotation-type>-<time>/validation-*.${AIP_DATA_FORMAT}"
  ///
  /// * AIP_TEST_DATA_URI =
  /// "gcs_destination/dataset-<dataset-id>-<annotation-type>-<time>/test-*.${AIP_DATA_FORMAT}"
  final GcsDestination? gcsDestination;

  /// Only applicable to custom training with tabular Dataset with BigQuery
  /// source.
  ///
  /// The BigQuery project location where the training data is to be written
  /// to. In the given project a new dataset is created with name
  /// `dataset_<dataset-id>_<annotation-type>_<timestamp-of-training-call>`
  /// where timestamp is in YYYY_MM_DDThh_mm_ss_sssZ format. All training
  /// input data is written into that dataset. In the dataset three
  /// tables are created, `training`, `validation` and `test`.
  ///
  /// * AIP_DATA_FORMAT = "bigquery".
  /// * AIP_TRAINING_DATA_URI  =
  /// "bigquery_destination.dataset_<dataset-id>_<annotation-type>_<time>.training"
  ///
  /// * AIP_VALIDATION_DATA_URI =
  /// "bigquery_destination.dataset_<dataset-id>_<annotation-type>_<time>.validation"
  ///
  /// * AIP_TEST_DATA_URI =
  /// "bigquery_destination.dataset_<dataset-id>_<annotation-type>_<time>.test"
  final BigQueryDestination? bigqueryDestination;

  /// Required. The ID of the Dataset in the same Project and Location which data
  /// will be used to train the Model. The Dataset must use schema compatible
  /// with Model being trained, and what is compatible should be described in the
  /// used TrainingPipeline's [training_task_definition]
  /// [google.cloud.aiplatform.v1beta1.TrainingPipeline.training_task_definition].
  /// For tabular Datasets, all their data is exported to training, to pick
  /// and choose from.
  final String datasetId;

  /// Applicable only to Datasets that have DataItems and Annotations.
  ///
  /// A filter on Annotations of the Dataset. Only Annotations that both
  /// match this filter and belong to DataItems not ignored by the split method
  /// are used in respectively training, validation or test role, depending on
  /// the role of the DataItem they are on (for the auto-assigned that role is
  /// decided by Vertex AI). A filter with same syntax as the one used in
  /// `ListAnnotations`
  /// may be used, but note here it filters across all Annotations of the
  /// Dataset, and not just within a single DataItem.
  final String annotationsFilter;

  /// Applicable only to custom training with Datasets that have DataItems and
  /// Annotations.
  ///
  /// Cloud Storage URI that points to a YAML file describing the annotation
  /// schema. The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/ , note that the
  /// chosen schema must be consistent with
  /// `metadata` of
  /// the Dataset specified by
  /// `dataset_id`.
  ///
  /// Only Annotations that both match this schema and belong to DataItems not
  /// ignored by the split method are used in respectively training, validation
  /// or test role, depending on the role of the DataItem they are on.
  ///
  /// When used in conjunction with
  /// `annotations_filter`,
  /// the Annotations used for training are filtered by both
  /// `annotations_filter`
  /// and
  /// `annotation_schema_uri`.
  final String annotationSchemaUri;

  /// Only applicable to Datasets that have SavedQueries.
  ///
  /// The ID of a SavedQuery (annotation set) under the Dataset specified by
  /// `dataset_id`
  /// used for filtering Annotations for training.
  ///
  /// Only Annotations that are associated with this SavedQuery are used in
  /// respectively training. When used in conjunction with
  /// `annotations_filter`,
  /// the Annotations used for training are filtered by both
  /// `saved_query_id`
  /// and
  /// `annotations_filter`.
  ///
  /// Only one of
  /// `saved_query_id`
  /// and
  /// `annotation_schema_uri`
  /// should be specified as both of them represent the same thing: problem type.
  final String savedQueryId;

  /// Whether to persist the ML use assignment to data item system labels.
  final bool persistMlUseAssignment;

  InputDataConfig({
    this.fractionSplit,
    this.filterSplit,
    this.predefinedSplit,
    this.timestampSplit,
    this.stratifiedSplit,
    this.gcsDestination,
    this.bigqueryDestination,
    required this.datasetId,
    this.annotationsFilter = '',
    this.annotationSchemaUri = '',
    this.savedQueryId = '',
    this.persistMlUseAssignment = false,
  }) : super(fullyQualifiedName);

  factory InputDataConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return InputDataConfig(
      fractionSplit: switch (json['fractionSplit']) {
        null => null,
        Object $1 => FractionSplit.fromJson($1),
      },
      filterSplit: switch (json['filterSplit']) {
        null => null,
        Object $1 => FilterSplit.fromJson($1),
      },
      predefinedSplit: switch (json['predefinedSplit']) {
        null => null,
        Object $1 => PredefinedSplit.fromJson($1),
      },
      timestampSplit: switch (json['timestampSplit']) {
        null => null,
        Object $1 => TimestampSplit.fromJson($1),
      },
      stratifiedSplit: switch (json['stratifiedSplit']) {
        null => null,
        Object $1 => StratifiedSplit.fromJson($1),
      },
      gcsDestination: switch (json['gcsDestination']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      bigqueryDestination: switch (json['bigqueryDestination']) {
        null => null,
        Object $1 => BigQueryDestination.fromJson($1),
      },
      datasetId: switch (json['datasetId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      annotationsFilter: switch (json['annotationsFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      annotationSchemaUri: switch (json['annotationSchemaUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      savedQueryId: switch (json['savedQueryId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      persistMlUseAssignment: switch (json['persistMlUseAssignment']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (fractionSplit != null) 'fractionSplit': fractionSplit!.toJson(),
    if (filterSplit != null) 'filterSplit': filterSplit!.toJson(),
    if (predefinedSplit != null) 'predefinedSplit': predefinedSplit!.toJson(),
    if (timestampSplit != null) 'timestampSplit': timestampSplit!.toJson(),
    if (stratifiedSplit != null) 'stratifiedSplit': stratifiedSplit!.toJson(),
    if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
    if (bigqueryDestination != null)
      'bigqueryDestination': bigqueryDestination!.toJson(),
    'datasetId': datasetId,
    if (annotationsFilter.isNotDefault) 'annotationsFilter': annotationsFilter,
    if (annotationSchemaUri.isNotDefault)
      'annotationSchemaUri': annotationSchemaUri,
    if (savedQueryId.isNotDefault) 'savedQueryId': savedQueryId,
    if (persistMlUseAssignment.isNotDefault)
      'persistMlUseAssignment': persistMlUseAssignment,
  };

  @override
  String toString() {
    final contents = [
      'datasetId=$datasetId',
      'annotationsFilter=$annotationsFilter',
      'annotationSchemaUri=$annotationSchemaUri',
      'savedQueryId=$savedQueryId',
      'persistMlUseAssignment=$persistMlUseAssignment',
    ].join(',');
    return 'InputDataConfig($contents)';
  }
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions. Any of `training_fraction`, `validation_fraction` and
/// `test_fraction` may optionally be provided, they must sum to up to 1. If the
/// provided ones sum to less than 1, the remainder is assigned to sets as
/// decided by Vertex AI. If none of the fractions are set, by default roughly
/// 80% of data is used for training, 10% for validation, and 10% for test.
final class FractionSplit extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FractionSplit';

  /// The fraction of the input data that is to be used to train the Model.
  final double trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  final double validationFraction;

  /// The fraction of the input data that is to be used to evaluate the Model.
  final double testFraction;

  FractionSplit({
    this.trainingFraction = 0,
    this.validationFraction = 0,
    this.testFraction = 0,
  }) : super(fullyQualifiedName);

  factory FractionSplit.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FractionSplit(
      trainingFraction: switch (json['trainingFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      validationFraction: switch (json['validationFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      testFraction: switch (json['testFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trainingFraction.isNotDefault)
      'trainingFraction': encodeDouble(trainingFraction),
    if (validationFraction.isNotDefault)
      'validationFraction': encodeDouble(validationFraction),
    if (testFraction.isNotDefault) 'testFraction': encodeDouble(testFraction),
  };

  @override
  String toString() {
    final contents = [
      'trainingFraction=$trainingFraction',
      'validationFraction=$validationFraction',
      'testFraction=$testFraction',
    ].join(',');
    return 'FractionSplit($contents)';
  }
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored. Currently only
/// supported for Datasets containing DataItems.
/// If any of the filters in this message are to match nothing, then they can be
/// set as '-' (the minus sign).
///
/// Supported only for unstructured Datasets.
final class FilterSplit extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FilterSplit';

  /// Required. A filter on DataItems of the Dataset. DataItems that match
  /// this filter are used to train the Model. A filter with same syntax
  /// as the one used in
  /// `DatasetService.ListDataItems`
  /// may be used. If a single DataItem is matched by more than one of the
  /// FilterSplit filters, then it is assigned to the first set that applies to
  /// it in the training, validation, test order.
  final String trainingFilter;

  /// Required. A filter on DataItems of the Dataset. DataItems that match
  /// this filter are used to validate the Model. A filter with same syntax
  /// as the one used in
  /// `DatasetService.ListDataItems`
  /// may be used. If a single DataItem is matched by more than one of the
  /// FilterSplit filters, then it is assigned to the first set that applies to
  /// it in the training, validation, test order.
  final String validationFilter;

  /// Required. A filter on DataItems of the Dataset. DataItems that match
  /// this filter are used to test the Model. A filter with same syntax
  /// as the one used in
  /// `DatasetService.ListDataItems`
  /// may be used. If a single DataItem is matched by more than one of the
  /// FilterSplit filters, then it is assigned to the first set that applies to
  /// it in the training, validation, test order.
  final String testFilter;

  FilterSplit({
    required this.trainingFilter,
    required this.validationFilter,
    required this.testFilter,
  }) : super(fullyQualifiedName);

  factory FilterSplit.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FilterSplit(
      trainingFilter: switch (json['trainingFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      validationFilter: switch (json['validationFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      testFilter: switch (json['testFilter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'trainingFilter': trainingFilter,
    'validationFilter': validationFilter,
    'testFilter': testFilter,
  };

  @override
  String toString() {
    final contents = [
      'trainingFilter=$trainingFilter',
      'validationFilter=$validationFilter',
      'testFilter=$testFilter',
    ].join(',');
    return 'FilterSplit($contents)';
  }
}

/// Assigns input data to training, validation, and test sets based on the
/// value of a provided key.
///
/// Supported only for tabular Datasets.
final class PredefinedSplit extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredefinedSplit';

  /// Required. The key is a name of one of the Dataset's data columns.
  /// The value of the key (either the label's value or value in the column)
  /// must be one of {`training`, `validation`, `test`}, and it defines to which
  /// set the given piece of data is assigned. If for a piece of data the key
  /// is not present or has an invalid value, that piece is ignored by the
  /// pipeline.
  final String key;

  PredefinedSplit({required this.key}) : super(fullyQualifiedName);

  factory PredefinedSplit.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PredefinedSplit(
      key: switch (json['key']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'key': key};

  @override
  String toString() {
    final contents = ['key=$key'].join(',');
    return 'PredefinedSplit($contents)';
  }
}

/// Assigns input data to training, validation, and test sets based on a
/// provided timestamps. The youngest data pieces are assigned to training set,
/// next to validation set, and the oldest to the test set.
///
/// Supported only for tabular Datasets.
final class TimestampSplit extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TimestampSplit';

  /// The fraction of the input data that is to be used to train the Model.
  final double trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  final double validationFraction;

  /// The fraction of the input data that is to be used to evaluate the Model.
  final double testFraction;

  /// Required. The key is a name of one of the Dataset's data columns.
  /// The values of the key (the values in the column) must be in RFC 3339
  /// `date-time` format, where `time-offset` = `"Z"`
  /// (e.g. 1985-04-12T23:20:50.52Z). If for a piece of data the key is not
  /// present or has an invalid value, that piece is ignored by the pipeline.
  final String key;

  TimestampSplit({
    this.trainingFraction = 0,
    this.validationFraction = 0,
    this.testFraction = 0,
    required this.key,
  }) : super(fullyQualifiedName);

  factory TimestampSplit.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TimestampSplit(
      trainingFraction: switch (json['trainingFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      validationFraction: switch (json['validationFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      testFraction: switch (json['testFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      key: switch (json['key']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trainingFraction.isNotDefault)
      'trainingFraction': encodeDouble(trainingFraction),
    if (validationFraction.isNotDefault)
      'validationFraction': encodeDouble(validationFraction),
    if (testFraction.isNotDefault) 'testFraction': encodeDouble(testFraction),
    'key': key,
  };

  @override
  String toString() {
    final contents = [
      'trainingFraction=$trainingFraction',
      'validationFraction=$validationFraction',
      'testFraction=$testFraction',
      'key=$key',
    ].join(',');
    return 'TimestampSplit($contents)';
  }
}

/// Assigns input data to the training, validation, and test sets so that the
/// distribution of values found in the categorical column (as specified by the
/// `key` field) is mirrored within each split. The fraction values determine
/// the relative sizes of the splits.
///
/// For example, if the specified column has three values, with 50% of the rows
/// having value "A", 25% value "B", and 25% value "C", and the split fractions
/// are specified as 80/10/10, then the training set will constitute 80% of the
/// training data, with about 50% of the training set rows having the value "A"
/// for the specified column, about 25% having the value "B", and about 25%
/// having the value "C".
///
/// Only the top 500 occurring values are used; any values not in the top
/// 500 values are randomly assigned to a split. If less than three rows contain
/// a specific value, those rows are randomly assigned.
///
/// Supported only for tabular Datasets.
final class StratifiedSplit extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StratifiedSplit';

  /// The fraction of the input data that is to be used to train the Model.
  final double trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  final double validationFraction;

  /// The fraction of the input data that is to be used to evaluate the Model.
  final double testFraction;

  /// Required. The key is a name of one of the Dataset's data columns.
  /// The key provided must be for a categorical column.
  final String key;

  StratifiedSplit({
    this.trainingFraction = 0,
    this.validationFraction = 0,
    this.testFraction = 0,
    required this.key,
  }) : super(fullyQualifiedName);

  factory StratifiedSplit.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StratifiedSplit(
      trainingFraction: switch (json['trainingFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      validationFraction: switch (json['validationFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      testFraction: switch (json['testFraction']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      key: switch (json['key']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trainingFraction.isNotDefault)
      'trainingFraction': encodeDouble(trainingFraction),
    if (validationFraction.isNotDefault)
      'validationFraction': encodeDouble(validationFraction),
    if (testFraction.isNotDefault) 'testFraction': encodeDouble(testFraction),
    'key': key,
  };

  @override
  String toString() {
    final contents = [
      'trainingFraction=$trainingFraction',
      'validationFraction=$validationFraction',
      'testFraction=$testFraction',
      'key=$key',
    ].join(',');
    return 'StratifiedSplit($contents)';
  }
}

/// Represents a TuningJob that runs with Google owned models.
final class TuningJob extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TuningJob';

  /// The base model that is being tuned. See [Supported
  /// models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/tuning#supported_models).
  final String? baseModel;

  /// The pre-tuned model for continuous tuning.
  final PreTunedModel? preTunedModel;

  /// Tuning Spec for Supervised Fine Tuning.
  final SupervisedTuningSpec? supervisedTuningSpec;

  /// Tuning Spec for Distillation.
  final DistillationSpec? distillationSpec;

  /// Tuning Spec for open sourced and third party Partner models.
  final PartnerModelTuningSpec? partnerModelTuningSpec;

  /// Tuning Spec for Veo Tuning.
  final VeoTuningSpec? veoTuningSpec;

  /// Output only. Identifier. Resource name of a TuningJob. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  final String name;

  /// Optional. The display name of the
  /// `TunedModel`. The name can be up to 128
  /// characters long and can consist of any UTF-8 characters.
  final String tunedModelDisplayName;

  /// Optional. The description of the
  /// `TuningJob`.
  final String description;

  /// Optional. The user-provided path to custom model weights. Set this field
  /// to tune a custom model. The path must be a Cloud Storage directory that
  /// contains the model weights in .safetensors format along with associated
  /// model metadata files. If this field is set, the base_model field must still
  /// be set to indicate which base model the custom model is derived from. This
  /// feature is only available for open source models.
  final String customBaseModel;

  /// Output only. The detailed state of the job.
  final JobState state;

  /// Output only. Time when the
  /// `TuningJob` was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the
  /// `TuningJob` for the first time
  /// entered the `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the TuningJob entered any of the following
  /// `JobStates`: `JOB_STATE_SUCCEEDED`,
  /// `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`, `JOB_STATE_EXPIRED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the
  /// `TuningJob` was most recently
  /// updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  final Status? error;

  /// Optional. The labels with user-defined metadata to organize
  /// `TuningJob` and generated resources
  /// such as `Model` and
  /// `Endpoint`.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String> labels;

  /// Output only. The Experiment associated with this
  /// `TuningJob`.
  final String experiment;

  /// Output only. The tuned model resources associated with this
  /// `TuningJob`.
  final TunedModel? tunedModel;

  /// Output only. The tuning data statistics associated with this
  /// `TuningJob`.
  final TuningDataStats? tuningDataStats;

  /// Output only. The resource name of the PipelineJob associated with the
  /// `TuningJob`. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`.
  final String pipelineJob;

  /// Customer-managed encryption key options for a TuningJob. If this is set,
  /// then all resources created by the TuningJob will be encrypted with the
  /// provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// The service account that the tuningJob workload runs as.
  /// If not specified, the Vertex AI Secure Fine-Tuned Service Agent in the
  /// project will be used. See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-secure-fine-tuning-service-agent
  ///
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  final String serviceAccount;

  /// Optional. Cloud Storage path to the directory where tuning job outputs are
  /// written to. This field is only available and required for open source
  /// models.
  final String outputUri;

  /// Output only. Evaluation runs for the Tuning Job.
  final List<EvaluateDatasetRun> evaluateDatasetRuns;

  TuningJob({
    this.baseModel,
    this.preTunedModel,
    this.supervisedTuningSpec,
    this.distillationSpec,
    this.partnerModelTuningSpec,
    this.veoTuningSpec,
    this.name = '',
    this.tunedModelDisplayName = '',
    this.description = '',
    this.customBaseModel = '',
    this.state = JobState.$default,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.error,
    this.labels = const {},
    this.experiment = '',
    this.tunedModel,
    this.tuningDataStats,
    this.pipelineJob = '',
    this.encryptionSpec,
    this.serviceAccount = '',
    this.outputUri = '',
    this.evaluateDatasetRuns = const [],
  }) : super(fullyQualifiedName);

  factory TuningJob.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TuningJob(
      baseModel: switch (json['baseModel']) {
        null => null,
        Object $1 => decodeString($1),
      },
      preTunedModel: switch (json['preTunedModel']) {
        null => null,
        Object $1 => PreTunedModel.fromJson($1),
      },
      supervisedTuningSpec: switch (json['supervisedTuningSpec']) {
        null => null,
        Object $1 => SupervisedTuningSpec.fromJson($1),
      },
      distillationSpec: switch (json['distillationSpec']) {
        null => null,
        Object $1 => DistillationSpec.fromJson($1),
      },
      partnerModelTuningSpec: switch (json['partnerModelTuningSpec']) {
        null => null,
        Object $1 => PartnerModelTuningSpec.fromJson($1),
      },
      veoTuningSpec: switch (json['veoTuningSpec']) {
        null => null,
        Object $1 => VeoTuningSpec.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tunedModelDisplayName: switch (json['tunedModelDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      customBaseModel: switch (json['customBaseModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => JobState.$default,
        Object $1 => JobState.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      experiment: switch (json['experiment']) {
        null => '',
        Object $1 => decodeString($1),
      },
      tunedModel: switch (json['tunedModel']) {
        null => null,
        Object $1 => TunedModel.fromJson($1),
      },
      tuningDataStats: switch (json['tuningDataStats']) {
        null => null,
        Object $1 => TuningDataStats.fromJson($1),
      },
      pipelineJob: switch (json['pipelineJob']) {
        null => '',
        Object $1 => decodeString($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
      outputUri: switch (json['outputUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      evaluateDatasetRuns: switch (json['evaluateDatasetRuns']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) EvaluateDatasetRun.fromJson(i),
        ],
        _ => throw const FormatException('"evaluateDatasetRuns" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (baseModel != null) 'baseModel': baseModel,
    if (preTunedModel != null) 'preTunedModel': preTunedModel!.toJson(),
    if (supervisedTuningSpec != null)
      'supervisedTuningSpec': supervisedTuningSpec!.toJson(),
    if (distillationSpec != null)
      'distillationSpec': distillationSpec!.toJson(),
    if (partnerModelTuningSpec != null)
      'partnerModelTuningSpec': partnerModelTuningSpec!.toJson(),
    if (veoTuningSpec != null) 'veoTuningSpec': veoTuningSpec!.toJson(),
    if (name.isNotDefault) 'name': name,
    if (tunedModelDisplayName.isNotDefault)
      'tunedModelDisplayName': tunedModelDisplayName,
    if (description.isNotDefault) 'description': description,
    if (customBaseModel.isNotDefault) 'customBaseModel': customBaseModel,
    if (state.isNotDefault) 'state': state.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (experiment.isNotDefault) 'experiment': experiment,
    if (tunedModel != null) 'tunedModel': tunedModel!.toJson(),
    if (tuningDataStats != null) 'tuningDataStats': tuningDataStats!.toJson(),
    if (pipelineJob.isNotDefault) 'pipelineJob': pipelineJob,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
    if (outputUri.isNotDefault) 'outputUri': outputUri,
    if (evaluateDatasetRuns.isNotDefault)
      'evaluateDatasetRuns': encodeList(evaluateDatasetRuns),
  };

  @override
  String toString() {
    final contents = [
      if (baseModel != null) 'baseModel=$baseModel',
      'name=$name',
      'tunedModelDisplayName=$tunedModelDisplayName',
      'description=$description',
      'customBaseModel=$customBaseModel',
      'state=$state',
      'experiment=$experiment',
      'pipelineJob=$pipelineJob',
      'serviceAccount=$serviceAccount',
      'outputUri=$outputUri',
    ].join(',');
    return 'TuningJob($contents)';
  }
}

/// The Model Registry Model and Online Prediction Endpoint associated with
/// this `TuningJob`.
final class TunedModel extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TunedModel';

  /// Output only. The resource name of the TunedModel. Format:
  ///
  /// `projects/{project}/locations/{location}/models/{model}@{version_id}`
  ///
  /// When tuning from a base model, the version_id will be 1.
  ///
  /// For continuous tuning, the version id will be incremented by 1 from the
  /// last version id in the parent model. E.g.,
  /// `projects/{project}/locations/{location}/models/{model}@{last_version_id +
  /// 1}`
  final String model;

  /// Output only. A resource name of an Endpoint. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`.
  final String endpoint;

  /// Output only. The checkpoints associated with this TunedModel.
  /// This field is only populated for tuning jobs that enable intermediate
  /// checkpoints.
  final List<TunedModelCheckpoint> checkpoints;

  TunedModel({this.model = '', this.endpoint = '', this.checkpoints = const []})
    : super(fullyQualifiedName);

  factory TunedModel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TunedModel(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      checkpoints: switch (json['checkpoints']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) TunedModelCheckpoint.fromJson(i),
        ],
        _ => throw const FormatException('"checkpoints" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (model.isNotDefault) 'model': model,
    if (endpoint.isNotDefault) 'endpoint': endpoint,
    if (checkpoints.isNotDefault) 'checkpoints': encodeList(checkpoints),
  };

  @override
  String toString() {
    final contents = ['model=$model', 'endpoint=$endpoint'].join(',');
    return 'TunedModel($contents)';
  }
}

/// Dataset distribution for Supervised Tuning.
final class SupervisedTuningDatasetDistribution extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedTuningDatasetDistribution';

  /// Output only. Sum of a given population of values.
  final int sum;

  /// Output only. Sum of a given population of values that are billable.
  final int billableSum;

  /// Output only. The minimum of the population values.
  final double min;

  /// Output only. The maximum of the population values.
  final double max;

  /// Output only. The arithmetic mean of the values in the population.
  final double mean;

  /// Output only. The median of the values in the population.
  final double median;

  /// Output only. The 5th percentile of the values in the population.
  final double p5;

  /// Output only. The 95th percentile of the values in the population.
  final double p95;

  /// Output only. Defines the histogram bucket.
  final List<SupervisedTuningDatasetDistribution_DatasetBucket> buckets;

  SupervisedTuningDatasetDistribution({
    this.sum = 0,
    this.billableSum = 0,
    this.min = 0,
    this.max = 0,
    this.mean = 0,
    this.median = 0,
    this.p5 = 0,
    this.p95 = 0,
    this.buckets = const [],
  }) : super(fullyQualifiedName);

  factory SupervisedTuningDatasetDistribution.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SupervisedTuningDatasetDistribution(
      sum: switch (json['sum']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      billableSum: switch (json['billableSum']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      min: switch (json['min']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      max: switch (json['max']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      mean: switch (json['mean']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      median: switch (json['median']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      p5: switch (json['p5']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      p95: switch (json['p95']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      buckets: switch (json['buckets']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            SupervisedTuningDatasetDistribution_DatasetBucket.fromJson(i),
        ],
        _ => throw const FormatException('"buckets" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (sum.isNotDefault) 'sum': encodeInt64(sum),
    if (billableSum.isNotDefault) 'billableSum': encodeInt64(billableSum),
    if (min.isNotDefault) 'min': encodeDouble(min),
    if (max.isNotDefault) 'max': encodeDouble(max),
    if (mean.isNotDefault) 'mean': encodeDouble(mean),
    if (median.isNotDefault) 'median': encodeDouble(median),
    if (p5.isNotDefault) 'p5': encodeDouble(p5),
    if (p95.isNotDefault) 'p95': encodeDouble(p95),
    if (buckets.isNotDefault) 'buckets': encodeList(buckets),
  };

  @override
  String toString() {
    final contents = [
      'sum=$sum',
      'billableSum=$billableSum',
      'min=$min',
      'max=$max',
      'mean=$mean',
      'median=$median',
      'p5=$p5',
      'p95=$p95',
    ].join(',');
    return 'SupervisedTuningDatasetDistribution($contents)';
  }
}

/// Dataset bucket used to create a histogram for the distribution given a
/// population of values.
final class SupervisedTuningDatasetDistribution_DatasetBucket
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedTuningDatasetDistribution.DatasetBucket';

  /// Output only. Number of values in the bucket.
  final double count;

  /// Output only. Left bound of the bucket.
  final double left;

  /// Output only. Right bound of the bucket.
  final double right;

  SupervisedTuningDatasetDistribution_DatasetBucket({
    this.count = 0,
    this.left = 0,
    this.right = 0,
  }) : super(fullyQualifiedName);

  factory SupervisedTuningDatasetDistribution_DatasetBucket.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return SupervisedTuningDatasetDistribution_DatasetBucket(
      count: switch (json['count']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      left: switch (json['left']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      right: switch (json['right']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (count.isNotDefault) 'count': encodeDouble(count),
    if (left.isNotDefault) 'left': encodeDouble(left),
    if (right.isNotDefault) 'right': encodeDouble(right),
  };

  @override
  String toString() {
    final contents = ['count=$count', 'left=$left', 'right=$right'].join(',');
    return 'DatasetBucket($contents)';
  }
}

/// Tuning data statistics for Supervised Tuning.
final class SupervisedTuningDataStats extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedTuningDataStats';

  /// Output only. Number of examples in the tuning dataset.
  final int tuningDatasetExampleCount;

  /// Output only. Number of tuning characters in the tuning dataset.
  final int totalTuningCharacterCount;

  /// Output only. Number of billable characters in the tuning dataset.
  final int totalBillableCharacterCount;

  /// Output only. Number of billable tokens in the tuning dataset.
  final int totalBillableTokenCount;

  /// Output only. Number of tuning steps for this Tuning Job.
  final int tuningStepCount;

  /// Output only. Dataset distributions for the user input tokens.
  final SupervisedTuningDatasetDistribution? userInputTokenDistribution;

  /// Output only. Dataset distributions for the user output tokens.
  final SupervisedTuningDatasetDistribution? userOutputTokenDistribution;

  /// Output only. Dataset distributions for the messages per example.
  final SupervisedTuningDatasetDistribution? userMessagePerExampleDistribution;

  /// Output only. Sample user messages in the training dataset uri.
  final List<Content> userDatasetExamples;

  /// Output only. The number of examples in the dataset that have been dropped.
  /// An example can be dropped for reasons including: too many tokens, contains
  /// an invalid image, contains too many images, etc.
  final int totalTruncatedExampleCount;

  /// Output only. A partial sample of the indices (starting from 1) of the
  /// dropped examples.
  final List<int> truncatedExampleIndices;

  /// Output only. For each index in `truncated_example_indices`, the user-facing
  /// reason why the example was dropped.
  final List<String> droppedExampleReasons;

  SupervisedTuningDataStats({
    this.tuningDatasetExampleCount = 0,
    this.totalTuningCharacterCount = 0,
    this.totalBillableCharacterCount = 0,
    this.totalBillableTokenCount = 0,
    this.tuningStepCount = 0,
    this.userInputTokenDistribution,
    this.userOutputTokenDistribution,
    this.userMessagePerExampleDistribution,
    this.userDatasetExamples = const [],
    this.totalTruncatedExampleCount = 0,
    this.truncatedExampleIndices = const [],
    this.droppedExampleReasons = const [],
  }) : super(fullyQualifiedName);

  factory SupervisedTuningDataStats.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SupervisedTuningDataStats(
      tuningDatasetExampleCount: switch (json['tuningDatasetExampleCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      totalTuningCharacterCount: switch (json['totalTuningCharacterCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      totalBillableCharacterCount:
          switch (json['totalBillableCharacterCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
      totalBillableTokenCount: switch (json['totalBillableTokenCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      tuningStepCount: switch (json['tuningStepCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      userInputTokenDistribution: switch (json['userInputTokenDistribution']) {
        null => null,
        Object $1 => SupervisedTuningDatasetDistribution.fromJson($1),
      },
      userOutputTokenDistribution:
          switch (json['userOutputTokenDistribution']) {
            null => null,
            Object $1 => SupervisedTuningDatasetDistribution.fromJson($1),
          },
      userMessagePerExampleDistribution:
          switch (json['userMessagePerExampleDistribution']) {
            null => null,
            Object $1 => SupervisedTuningDatasetDistribution.fromJson($1),
          },
      userDatasetExamples: switch (json['userDatasetExamples']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"userDatasetExamples" is not a list'),
      },
      totalTruncatedExampleCount: switch (json['totalTruncatedExampleCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      truncatedExampleIndices: switch (json['truncatedExampleIndices']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException(
          '"truncatedExampleIndices" is not a list',
        ),
      },
      droppedExampleReasons: switch (json['droppedExampleReasons']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"droppedExampleReasons" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (tuningDatasetExampleCount.isNotDefault)
      'tuningDatasetExampleCount': encodeInt64(tuningDatasetExampleCount),
    if (totalTuningCharacterCount.isNotDefault)
      'totalTuningCharacterCount': encodeInt64(totalTuningCharacterCount),
    if (totalBillableCharacterCount.isNotDefault)
      'totalBillableCharacterCount': encodeInt64(totalBillableCharacterCount),
    if (totalBillableTokenCount.isNotDefault)
      'totalBillableTokenCount': encodeInt64(totalBillableTokenCount),
    if (tuningStepCount.isNotDefault)
      'tuningStepCount': encodeInt64(tuningStepCount),
    if (userInputTokenDistribution != null)
      'userInputTokenDistribution': userInputTokenDistribution!.toJson(),
    if (userOutputTokenDistribution != null)
      'userOutputTokenDistribution': userOutputTokenDistribution!.toJson(),
    if (userMessagePerExampleDistribution != null)
      'userMessagePerExampleDistribution': userMessagePerExampleDistribution!
          .toJson(),
    if (userDatasetExamples.isNotDefault)
      'userDatasetExamples': encodeList(userDatasetExamples),
    if (totalTruncatedExampleCount.isNotDefault)
      'totalTruncatedExampleCount': encodeInt64(totalTruncatedExampleCount),
    if (truncatedExampleIndices.isNotDefault)
      'truncatedExampleIndices': truncatedExampleIndices,
    if (droppedExampleReasons.isNotDefault)
      'droppedExampleReasons': droppedExampleReasons,
  };

  @override
  String toString() {
    final contents = [
      'tuningDatasetExampleCount=$tuningDatasetExampleCount',
      'totalTuningCharacterCount=$totalTuningCharacterCount',
      'totalBillableCharacterCount=$totalBillableCharacterCount',
      'totalBillableTokenCount=$totalBillableTokenCount',
      'tuningStepCount=$tuningStepCount',
      'totalTruncatedExampleCount=$totalTruncatedExampleCount',
    ].join(',');
    return 'SupervisedTuningDataStats($contents)';
  }
}

/// Distribution computed over a tuning dataset.
final class DatasetDistribution extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DatasetDistribution';

  /// Output only. Sum of a given population of values.
  final double sum;

  /// Output only. The minimum of the population values.
  final double min;

  /// Output only. The maximum of the population values.
  final double max;

  /// Output only. The arithmetic mean of the values in the population.
  final double mean;

  /// Output only. The median of the values in the population.
  final double median;

  /// Output only. The 5th percentile of the values in the population.
  final double p5;

  /// Output only. The 95th percentile of the values in the population.
  final double p95;

  /// Output only. Defines the histogram bucket.
  final List<DatasetDistribution_DistributionBucket> buckets;

  DatasetDistribution({
    this.sum = 0,
    this.min = 0,
    this.max = 0,
    this.mean = 0,
    this.median = 0,
    this.p5 = 0,
    this.p95 = 0,
    this.buckets = const [],
  }) : super(fullyQualifiedName);

  factory DatasetDistribution.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DatasetDistribution(
      sum: switch (json['sum']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      min: switch (json['min']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      max: switch (json['max']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      mean: switch (json['mean']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      median: switch (json['median']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      p5: switch (json['p5']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      p95: switch (json['p95']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      buckets: switch (json['buckets']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            DatasetDistribution_DistributionBucket.fromJson(i),
        ],
        _ => throw const FormatException('"buckets" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (sum.isNotDefault) 'sum': encodeDouble(sum),
    if (min.isNotDefault) 'min': encodeDouble(min),
    if (max.isNotDefault) 'max': encodeDouble(max),
    if (mean.isNotDefault) 'mean': encodeDouble(mean),
    if (median.isNotDefault) 'median': encodeDouble(median),
    if (p5.isNotDefault) 'p5': encodeDouble(p5),
    if (p95.isNotDefault) 'p95': encodeDouble(p95),
    if (buckets.isNotDefault) 'buckets': encodeList(buckets),
  };

  @override
  String toString() {
    final contents = [
      'sum=$sum',
      'min=$min',
      'max=$max',
      'mean=$mean',
      'median=$median',
      'p5=$p5',
      'p95=$p95',
    ].join(',');
    return 'DatasetDistribution($contents)';
  }
}

/// Dataset bucket used to create a histogram for the distribution given a
/// population of values.
final class DatasetDistribution_DistributionBucket extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DatasetDistribution.DistributionBucket';

  /// Output only. Number of values in the bucket.
  final int count;

  /// Output only. Left bound of the bucket.
  final double left;

  /// Output only. Right bound of the bucket.
  final double right;

  DatasetDistribution_DistributionBucket({
    this.count = 0,
    this.left = 0,
    this.right = 0,
  }) : super(fullyQualifiedName);

  factory DatasetDistribution_DistributionBucket.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DatasetDistribution_DistributionBucket(
      count: switch (json['count']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      left: switch (json['left']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      right: switch (json['right']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (count.isNotDefault) 'count': encodeInt64(count),
    if (left.isNotDefault) 'left': encodeDouble(left),
    if (right.isNotDefault) 'right': encodeDouble(right),
  };

  @override
  String toString() {
    final contents = ['count=$count', 'left=$left', 'right=$right'].join(',');
    return 'DistributionBucket($contents)';
  }
}

/// Statistics computed over a tuning dataset.
final class DatasetStats extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DatasetStats';

  /// Output only. Number of examples in the tuning dataset.
  final int tuningDatasetExampleCount;

  /// Output only. Number of tuning characters in the tuning dataset.
  final int totalTuningCharacterCount;

  /// Output only. Number of billable characters in the tuning dataset.
  final int totalBillableCharacterCount;

  /// Output only. Number of tuning steps for this Tuning Job.
  final int tuningStepCount;

  /// Output only. Dataset distributions for the user input tokens.
  final DatasetDistribution? userInputTokenDistribution;

  /// Output only. Dataset distributions for the user output tokens.
  final DatasetDistribution? userOutputTokenDistribution;

  /// Output only. Dataset distributions for the messages per example.
  final DatasetDistribution? userMessagePerExampleDistribution;

  /// Output only. Sample user messages in the training dataset uri.
  final List<Content> userDatasetExamples;

  DatasetStats({
    this.tuningDatasetExampleCount = 0,
    this.totalTuningCharacterCount = 0,
    this.totalBillableCharacterCount = 0,
    this.tuningStepCount = 0,
    this.userInputTokenDistribution,
    this.userOutputTokenDistribution,
    this.userMessagePerExampleDistribution,
    this.userDatasetExamples = const [],
  }) : super(fullyQualifiedName);

  factory DatasetStats.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DatasetStats(
      tuningDatasetExampleCount: switch (json['tuningDatasetExampleCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      totalTuningCharacterCount: switch (json['totalTuningCharacterCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      totalBillableCharacterCount:
          switch (json['totalBillableCharacterCount']) {
            null => 0,
            Object $1 => decodeInt64($1),
          },
      tuningStepCount: switch (json['tuningStepCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      userInputTokenDistribution: switch (json['userInputTokenDistribution']) {
        null => null,
        Object $1 => DatasetDistribution.fromJson($1),
      },
      userOutputTokenDistribution:
          switch (json['userOutputTokenDistribution']) {
            null => null,
            Object $1 => DatasetDistribution.fromJson($1),
          },
      userMessagePerExampleDistribution:
          switch (json['userMessagePerExampleDistribution']) {
            null => null,
            Object $1 => DatasetDistribution.fromJson($1),
          },
      userDatasetExamples: switch (json['userDatasetExamples']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"userDatasetExamples" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (tuningDatasetExampleCount.isNotDefault)
      'tuningDatasetExampleCount': encodeInt64(tuningDatasetExampleCount),
    if (totalTuningCharacterCount.isNotDefault)
      'totalTuningCharacterCount': encodeInt64(totalTuningCharacterCount),
    if (totalBillableCharacterCount.isNotDefault)
      'totalBillableCharacterCount': encodeInt64(totalBillableCharacterCount),
    if (tuningStepCount.isNotDefault)
      'tuningStepCount': encodeInt64(tuningStepCount),
    if (userInputTokenDistribution != null)
      'userInputTokenDistribution': userInputTokenDistribution!.toJson(),
    if (userOutputTokenDistribution != null)
      'userOutputTokenDistribution': userOutputTokenDistribution!.toJson(),
    if (userMessagePerExampleDistribution != null)
      'userMessagePerExampleDistribution': userMessagePerExampleDistribution!
          .toJson(),
    if (userDatasetExamples.isNotDefault)
      'userDatasetExamples': encodeList(userDatasetExamples),
  };

  @override
  String toString() {
    final contents = [
      'tuningDatasetExampleCount=$tuningDatasetExampleCount',
      'totalTuningCharacterCount=$totalTuningCharacterCount',
      'totalBillableCharacterCount=$totalBillableCharacterCount',
      'tuningStepCount=$tuningStepCount',
    ].join(',');
    return 'DatasetStats($contents)';
  }
}

/// Statistics computed for datasets used for distillation.
final class DistillationDataStats extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DistillationDataStats';

  /// Output only. Statistics computed for the training dataset.
  final DatasetStats? trainingDatasetStats;

  DistillationDataStats({this.trainingDatasetStats})
    : super(fullyQualifiedName);

  factory DistillationDataStats.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DistillationDataStats(
      trainingDatasetStats: switch (json['trainingDatasetStats']) {
        null => null,
        Object $1 => DatasetStats.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trainingDatasetStats != null)
      'trainingDatasetStats': trainingDatasetStats!.toJson(),
  };

  @override
  String toString() => 'DistillationDataStats()';
}

/// The tuning data statistic values for
/// `TuningJob`.
final class TuningDataStats extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TuningDataStats';

  /// The SFT Tuning data stats.
  final SupervisedTuningDataStats? supervisedTuningDataStats;

  /// Output only. Statistics for distillation.
  final DistillationDataStats? distillationDataStats;

  TuningDataStats({this.supervisedTuningDataStats, this.distillationDataStats})
    : super(fullyQualifiedName);

  factory TuningDataStats.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TuningDataStats(
      supervisedTuningDataStats: switch (json['supervisedTuningDataStats']) {
        null => null,
        Object $1 => SupervisedTuningDataStats.fromJson($1),
      },
      distillationDataStats: switch (json['distillationDataStats']) {
        null => null,
        Object $1 => DistillationDataStats.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (supervisedTuningDataStats != null)
      'supervisedTuningDataStats': supervisedTuningDataStats!.toJson(),
    if (distillationDataStats != null)
      'distillationDataStats': distillationDataStats!.toJson(),
  };

  @override
  String toString() => 'TuningDataStats()';
}

/// Hyperparameters for SFT.
final class SupervisedHyperParameters extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedHyperParameters';

  /// Optional. Number of complete passes the model makes over the entire
  /// training dataset during training.
  final int epochCount;

  /// Optional. Multiplier for adjusting the default learning rate.
  /// Mutually exclusive with `learning_rate`.
  final double learningRateMultiplier;

  /// Optional. Learning rate for tuning.
  /// Mutually exclusive with `learning_rate_multiplier`.
  /// This feature is only available for open source models.
  final double learningRate;

  /// Optional. Adapter size for tuning.
  final SupervisedHyperParameters_AdapterSize adapterSize;

  /// Optional. Batch size for tuning.
  /// This feature is only available for open source models.
  final int batchSize;

  SupervisedHyperParameters({
    this.epochCount = 0,
    this.learningRateMultiplier = 0,
    this.learningRate = 0,
    this.adapterSize = SupervisedHyperParameters_AdapterSize.$default,
    this.batchSize = 0,
  }) : super(fullyQualifiedName);

  factory SupervisedHyperParameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SupervisedHyperParameters(
      epochCount: switch (json['epochCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      learningRateMultiplier: switch (json['learningRateMultiplier']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      learningRate: switch (json['learningRate']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      adapterSize: switch (json['adapterSize']) {
        null => SupervisedHyperParameters_AdapterSize.$default,
        Object $1 => SupervisedHyperParameters_AdapterSize.fromJson($1),
      },
      batchSize: switch (json['batchSize']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (epochCount.isNotDefault) 'epochCount': encodeInt64(epochCount),
    if (learningRateMultiplier.isNotDefault)
      'learningRateMultiplier': encodeDouble(learningRateMultiplier),
    if (learningRate.isNotDefault) 'learningRate': encodeDouble(learningRate),
    if (adapterSize.isNotDefault) 'adapterSize': adapterSize.toJson(),
    if (batchSize.isNotDefault) 'batchSize': encodeInt64(batchSize),
  };

  @override
  String toString() {
    final contents = [
      'epochCount=$epochCount',
      'learningRateMultiplier=$learningRateMultiplier',
      'learningRate=$learningRate',
      'adapterSize=$adapterSize',
      'batchSize=$batchSize',
    ].join(',');
    return 'SupervisedHyperParameters($contents)';
  }
}

/// Supported adapter sizes for tuning.
final class SupervisedHyperParameters_AdapterSize extends ProtoEnum {
  /// Adapter size is unspecified.
  static const adapterSizeUnspecified = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_UNSPECIFIED',
  );

  /// Adapter size 1.
  static const adapterSizeOne = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_ONE',
  );

  /// Adapter size 2.
  static const adapterSizeTwo = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_TWO',
  );

  /// Adapter size 4.
  static const adapterSizeFour = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_FOUR',
  );

  /// Adapter size 8.
  static const adapterSizeEight = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_EIGHT',
  );

  /// Adapter size 16.
  static const adapterSizeSixteen = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_SIXTEEN',
  );

  /// Adapter size 32.
  static const adapterSizeThirtyTwo = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_THIRTY_TWO',
  );

  /// The default value for [SupervisedHyperParameters_AdapterSize].
  static const $default = adapterSizeUnspecified;

  const SupervisedHyperParameters_AdapterSize(super.value);

  factory SupervisedHyperParameters_AdapterSize.fromJson(Object? json) =>
      SupervisedHyperParameters_AdapterSize(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'AdapterSize.$value';
}

/// Tuning Spec for Supervised Tuning for first party models.
final class SupervisedTuningSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedTuningSpec';

  /// Required. Training dataset used for tuning. The dataset can be specified as
  /// either a Cloud Storage path to a JSONL file or as the resource name of a
  /// Vertex Multimodal Dataset.
  final String trainingDatasetUri;

  /// Optional. Validation dataset used for tuning. The dataset can be specified
  /// as either a Cloud Storage path to a JSONL file or as the resource name of a
  /// Vertex Multimodal Dataset.
  final String validationDatasetUri;

  /// Optional. Hyperparameters for SFT.
  final SupervisedHyperParameters? hyperParameters;

  /// Optional. If set to true, disable intermediate checkpoints for SFT and only
  /// the last checkpoint will be exported. Otherwise, enable intermediate
  /// checkpoints for SFT. Default is false.
  final bool exportLastCheckpointOnly;

  /// Optional. Evaluation Config for Tuning Job.
  final EvaluationConfig? evaluationConfig;

  /// Tuning mode.
  final SupervisedTuningSpec_TuningMode tuningMode;

  SupervisedTuningSpec({
    required this.trainingDatasetUri,
    this.validationDatasetUri = '',
    this.hyperParameters,
    this.exportLastCheckpointOnly = false,
    this.evaluationConfig,
    this.tuningMode = SupervisedTuningSpec_TuningMode.$default,
  }) : super(fullyQualifiedName);

  factory SupervisedTuningSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SupervisedTuningSpec(
      trainingDatasetUri: switch (json['trainingDatasetUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      validationDatasetUri: switch (json['validationDatasetUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      hyperParameters: switch (json['hyperParameters']) {
        null => null,
        Object $1 => SupervisedHyperParameters.fromJson($1),
      },
      exportLastCheckpointOnly: switch (json['exportLastCheckpointOnly']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      evaluationConfig: switch (json['evaluationConfig']) {
        null => null,
        Object $1 => EvaluationConfig.fromJson($1),
      },
      tuningMode: switch (json['tuningMode']) {
        null => SupervisedTuningSpec_TuningMode.$default,
        Object $1 => SupervisedTuningSpec_TuningMode.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'trainingDatasetUri': trainingDatasetUri,
    if (validationDatasetUri.isNotDefault)
      'validationDatasetUri': validationDatasetUri,
    if (hyperParameters != null) 'hyperParameters': hyperParameters!.toJson(),
    if (exportLastCheckpointOnly.isNotDefault)
      'exportLastCheckpointOnly': exportLastCheckpointOnly,
    if (evaluationConfig != null)
      'evaluationConfig': evaluationConfig!.toJson(),
    if (tuningMode.isNotDefault) 'tuningMode': tuningMode.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'trainingDatasetUri=$trainingDatasetUri',
      'validationDatasetUri=$validationDatasetUri',
      'exportLastCheckpointOnly=$exportLastCheckpointOnly',
      'tuningMode=$tuningMode',
    ].join(',');
    return 'SupervisedTuningSpec($contents)';
  }
}

/// Supported tuning modes.
final class SupervisedTuningSpec_TuningMode extends ProtoEnum {
  /// Tuning mode is unspecified.
  static const tuningModeUnspecified = SupervisedTuningSpec_TuningMode(
    'TUNING_MODE_UNSPECIFIED',
  );

  /// Full fine-tuning mode.
  static const tuningModeFull = SupervisedTuningSpec_TuningMode(
    'TUNING_MODE_FULL',
  );

  /// PEFT adapter tuning mode.
  static const tuningModePeftAdapter = SupervisedTuningSpec_TuningMode(
    'TUNING_MODE_PEFT_ADAPTER',
  );

  /// The default value for [SupervisedTuningSpec_TuningMode].
  static const $default = tuningModeUnspecified;

  const SupervisedTuningSpec_TuningMode(super.value);

  factory SupervisedTuningSpec_TuningMode.fromJson(Object? json) =>
      SupervisedTuningSpec_TuningMode(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'TuningMode.$value';
}

/// Tuning Spec for Distillation.
final class DistillationSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DistillationSpec';

  /// The base teacher model that is being distilled. See [Supported
  /// models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/tuning#supported_models).
  final String? baseTeacherModel;

  /// The resource name of the Tuned teacher model. Format:
  /// `projects/{project}/locations/{location}/models/{model}`.
  final String? tunedTeacherModelSource;

  /// Required. Cloud Storage path to file containing training dataset for
  /// tuning. The dataset must be formatted as a JSONL file.
  final String trainingDatasetUri;

  /// Optional. Cloud Storage path to file containing validation dataset for
  /// tuning. The dataset must be formatted as a JSONL file.
  final String? validationDatasetUri;

  /// Optional. Hyperparameters for Distillation.
  final DistillationHyperParameters? hyperParameters;

  /// The student model that is being tuned, e.g., "google/gemma-2b-1.1-it".
  final String studentModel;

  /// Required. A path in a Cloud Storage bucket, which will be treated as the
  /// root output directory of the distillation pipeline. It is used by the
  /// system to generate the paths of output artifacts.
  final String pipelineRootDirectory;

  DistillationSpec({
    this.baseTeacherModel,
    this.tunedTeacherModelSource,
    required this.trainingDatasetUri,
    this.validationDatasetUri,
    this.hyperParameters,
    this.studentModel = '',
    required this.pipelineRootDirectory,
  }) : super(fullyQualifiedName);

  factory DistillationSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DistillationSpec(
      baseTeacherModel: switch (json['baseTeacherModel']) {
        null => null,
        Object $1 => decodeString($1),
      },
      tunedTeacherModelSource: switch (json['tunedTeacherModelSource']) {
        null => null,
        Object $1 => decodeString($1),
      },
      trainingDatasetUri: switch (json['trainingDatasetUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      validationDatasetUri: switch (json['validationDatasetUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      hyperParameters: switch (json['hyperParameters']) {
        null => null,
        Object $1 => DistillationHyperParameters.fromJson($1),
      },
      studentModel: switch (json['studentModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pipelineRootDirectory: switch (json['pipelineRootDirectory']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (baseTeacherModel != null) 'baseTeacherModel': baseTeacherModel,
    if (tunedTeacherModelSource != null)
      'tunedTeacherModelSource': tunedTeacherModelSource,
    'trainingDatasetUri': trainingDatasetUri,
    if (validationDatasetUri != null)
      'validationDatasetUri': validationDatasetUri,
    if (hyperParameters != null) 'hyperParameters': hyperParameters!.toJson(),
    if (studentModel.isNotDefault) 'studentModel': studentModel,
    'pipelineRootDirectory': pipelineRootDirectory,
  };

  @override
  String toString() {
    final contents = [
      if (baseTeacherModel != null) 'baseTeacherModel=$baseTeacherModel',
      if (tunedTeacherModelSource != null)
        'tunedTeacherModelSource=$tunedTeacherModelSource',
      'trainingDatasetUri=$trainingDatasetUri',
      if (validationDatasetUri != null)
        'validationDatasetUri=$validationDatasetUri',
      'studentModel=$studentModel',
      'pipelineRootDirectory=$pipelineRootDirectory',
    ].join(',');
    return 'DistillationSpec($contents)';
  }
}

/// Hyperparameters for Distillation.
final class DistillationHyperParameters extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DistillationHyperParameters';

  /// Optional. Number of complete passes the model makes over the entire
  /// training dataset during training.
  final int? epochCount;

  /// Optional. Multiplier for adjusting the default learning rate.
  final double? learningRateMultiplier;

  /// Optional. Adapter size for distillation.
  final SupervisedHyperParameters_AdapterSize adapterSize;

  DistillationHyperParameters({
    this.epochCount,
    this.learningRateMultiplier,
    this.adapterSize = SupervisedHyperParameters_AdapterSize.$default,
  }) : super(fullyQualifiedName);

  factory DistillationHyperParameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DistillationHyperParameters(
      epochCount: switch (json['epochCount']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      learningRateMultiplier: switch (json['learningRateMultiplier']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      adapterSize: switch (json['adapterSize']) {
        null => SupervisedHyperParameters_AdapterSize.$default,
        Object $1 => SupervisedHyperParameters_AdapterSize.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (epochCount != null) 'epochCount': encodeInt64(epochCount),
    if (learningRateMultiplier != null)
      'learningRateMultiplier': encodeDouble(learningRateMultiplier),
    if (adapterSize.isNotDefault) 'adapterSize': adapterSize.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (epochCount != null) 'epochCount=$epochCount',
      if (learningRateMultiplier != null)
        'learningRateMultiplier=$learningRateMultiplier',
      'adapterSize=$adapterSize',
    ].join(',');
    return 'DistillationHyperParameters($contents)';
  }
}

/// Tuning spec for Partner models.
final class PartnerModelTuningSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PartnerModelTuningSpec';

  /// Required. Cloud Storage path to file containing training dataset for
  /// tuning. The dataset must be formatted as a JSONL file.
  final String trainingDatasetUri;

  /// Optional. Cloud Storage path to file containing validation dataset for
  /// tuning. The dataset must be formatted as a JSONL file.
  final String validationDatasetUri;

  /// Hyperparameters for tuning. The accepted hyper_parameters and their valid
  /// range of values will differ depending on the base model.
  final Map<String, protobuf.Value> hyperParameters;

  PartnerModelTuningSpec({
    required this.trainingDatasetUri,
    this.validationDatasetUri = '',
    this.hyperParameters = const {},
  }) : super(fullyQualifiedName);

  factory PartnerModelTuningSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PartnerModelTuningSpec(
      trainingDatasetUri: switch (json['trainingDatasetUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      validationDatasetUri: switch (json['validationDatasetUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      hyperParameters: switch (json['hyperParameters']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): protobuf.Value.fromJson(e.value),
        },
        _ => throw const FormatException('"hyperParameters" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    'trainingDatasetUri': trainingDatasetUri,
    if (validationDatasetUri.isNotDefault)
      'validationDatasetUri': validationDatasetUri,
    if (hyperParameters.isNotDefault)
      'hyperParameters': encodeMap(hyperParameters),
  };

  @override
  String toString() {
    final contents = [
      'trainingDatasetUri=$trainingDatasetUri',
      'validationDatasetUri=$validationDatasetUri',
    ].join(',');
    return 'PartnerModelTuningSpec($contents)';
  }
}

/// TunedModel Reference for legacy model migration.
final class TunedModelRef extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TunedModelRef';

  /// Support migration from model registry.
  final String? tunedModel;

  /// Support migration from tuning job list page, from gemini-1.0-pro-002
  /// to 1.5 and above.
  final String? tuningJob;

  /// Support migration from tuning job list page, from bison model to gemini
  /// model.
  final String? pipelineJob;

  TunedModelRef({this.tunedModel, this.tuningJob, this.pipelineJob})
    : super(fullyQualifiedName);

  factory TunedModelRef.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TunedModelRef(
      tunedModel: switch (json['tunedModel']) {
        null => null,
        Object $1 => decodeString($1),
      },
      tuningJob: switch (json['tuningJob']) {
        null => null,
        Object $1 => decodeString($1),
      },
      pipelineJob: switch (json['pipelineJob']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tunedModel != null) 'tunedModel': tunedModel,
    if (tuningJob != null) 'tuningJob': tuningJob,
    if (pipelineJob != null) 'pipelineJob': pipelineJob,
  };

  @override
  String toString() {
    final contents = [
      if (tunedModel != null) 'tunedModel=$tunedModel',
      if (tuningJob != null) 'tuningJob=$tuningJob',
      if (pipelineJob != null) 'pipelineJob=$pipelineJob',
    ].join(',');
    return 'TunedModelRef($contents)';
  }
}

/// Hyperparameters for Veo.
final class VeoHyperParameters extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VeoHyperParameters';

  /// Optional. Number of complete passes the model makes over the entire
  /// training dataset during training.
  final int epochCount;

  /// Optional. Multiplier for adjusting the default learning rate.
  final double learningRateMultiplier;

  /// Optional. The tuning task. Either I2V or T2V.
  final VeoHyperParameters_TuningTask tuningTask;

  VeoHyperParameters({
    this.epochCount = 0,
    this.learningRateMultiplier = 0,
    this.tuningTask = VeoHyperParameters_TuningTask.$default,
  }) : super(fullyQualifiedName);

  factory VeoHyperParameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VeoHyperParameters(
      epochCount: switch (json['epochCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      learningRateMultiplier: switch (json['learningRateMultiplier']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      tuningTask: switch (json['tuningTask']) {
        null => VeoHyperParameters_TuningTask.$default,
        Object $1 => VeoHyperParameters_TuningTask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (epochCount.isNotDefault) 'epochCount': encodeInt64(epochCount),
    if (learningRateMultiplier.isNotDefault)
      'learningRateMultiplier': encodeDouble(learningRateMultiplier),
    if (tuningTask.isNotDefault) 'tuningTask': tuningTask.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'epochCount=$epochCount',
      'learningRateMultiplier=$learningRateMultiplier',
      'tuningTask=$tuningTask',
    ].join(',');
    return 'VeoHyperParameters($contents)';
  }
}

/// An enum defining the tuning task used for Veo.
final class VeoHyperParameters_TuningTask extends ProtoEnum {
  /// Default value. This value is unused.
  static const tuningTaskUnspecified = VeoHyperParameters_TuningTask(
    'TUNING_TASK_UNSPECIFIED',
  );

  /// Tuning task for image to video.
  static const tuningTaskI2V = VeoHyperParameters_TuningTask('TUNING_TASK_I2V');

  /// Tuning task for text to video.
  static const tuningTaskT2V = VeoHyperParameters_TuningTask('TUNING_TASK_T2V');

  /// The default value for [VeoHyperParameters_TuningTask].
  static const $default = tuningTaskUnspecified;

  const VeoHyperParameters_TuningTask(super.value);

  factory VeoHyperParameters_TuningTask.fromJson(Object? json) =>
      VeoHyperParameters_TuningTask(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'TuningTask.$value';
}

/// Tuning Spec for Veo Model Tuning.
final class VeoTuningSpec extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VeoTuningSpec';

  /// Required. Training dataset used for tuning. The dataset can be specified as
  /// either a Cloud Storage path to a JSONL file or as the resource name of a
  /// Vertex Multimodal Dataset.
  final String trainingDatasetUri;

  /// Optional. Validation dataset used for tuning. The dataset can be specified
  /// as either a Cloud Storage path to a JSONL file or as the resource name of a
  /// Vertex Multimodal Dataset.
  final String validationDatasetUri;

  /// Optional. Hyperparameters for Veo.
  final VeoHyperParameters? hyperParameters;

  VeoTuningSpec({
    required this.trainingDatasetUri,
    this.validationDatasetUri = '',
    this.hyperParameters,
  }) : super(fullyQualifiedName);

  factory VeoTuningSpec.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VeoTuningSpec(
      trainingDatasetUri: switch (json['trainingDatasetUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      validationDatasetUri: switch (json['validationDatasetUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      hyperParameters: switch (json['hyperParameters']) {
        null => null,
        Object $1 => VeoHyperParameters.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'trainingDatasetUri': trainingDatasetUri,
    if (validationDatasetUri.isNotDefault)
      'validationDatasetUri': validationDatasetUri,
    if (hyperParameters != null) 'hyperParameters': hyperParameters!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'trainingDatasetUri=$trainingDatasetUri',
      'validationDatasetUri=$validationDatasetUri',
    ].join(',');
    return 'VeoTuningSpec($contents)';
  }
}

/// Evaluation Config for Tuning Job.
final class EvaluationConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluationConfig';

  /// Required. The metrics used for evaluation.
  final List<Metric> metrics;

  /// Required. Config for evaluation output.
  final OutputConfig? outputConfig;

  /// Optional. Autorater config for evaluation.
  final AutoraterConfig? autoraterConfig;

  EvaluationConfig({
    required this.metrics,
    required this.outputConfig,
    this.autoraterConfig,
  }) : super(fullyQualifiedName);

  factory EvaluationConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluationConfig(
      metrics: switch (json['metrics']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Metric.fromJson(i)],
        _ => throw const FormatException('"metrics" is not a list'),
      },
      outputConfig: switch (json['outputConfig']) {
        null => null,
        Object $1 => OutputConfig.fromJson($1),
      },
      autoraterConfig: switch (json['autoraterConfig']) {
        null => null,
        Object $1 => AutoraterConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'metrics': encodeList(metrics),
    if (outputConfig != null) 'outputConfig': outputConfig!.toJson(),
    if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!.toJson(),
  };

  @override
  String toString() => 'EvaluationConfig()';
}

/// Evaluate Dataset Run Result for Tuning Job.
final class EvaluateDatasetRun extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateDatasetRun';

  /// Output only. The operation ID of the evaluation run. Format:
  /// `projects/{project}/locations/{location}/operations/{operation_id}`.
  final String operationName;

  /// Output only. The checkpoint id used in the evaluation run. Only populated
  /// when evaluating checkpoints.
  final String checkpointId;

  /// Output only. Results for EvaluationService.EvaluateDataset.
  final EvaluateDatasetResponse? evaluateDatasetResponse;

  /// Output only. The error of the evaluation run if any.
  final Status? error;

  EvaluateDatasetRun({
    this.operationName = '',
    this.checkpointId = '',
    this.evaluateDatasetResponse,
    this.error,
  }) : super(fullyQualifiedName);

  factory EvaluateDatasetRun.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EvaluateDatasetRun(
      operationName: switch (json['operationName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      checkpointId: switch (json['checkpointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      evaluateDatasetResponse: switch (json['evaluateDatasetResponse']) {
        null => null,
        Object $1 => EvaluateDatasetResponse.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (operationName.isNotDefault) 'operationName': operationName,
    if (checkpointId.isNotDefault) 'checkpointId': checkpointId,
    if (evaluateDatasetResponse != null)
      'evaluateDatasetResponse': evaluateDatasetResponse!.toJson(),
    if (error != null) 'error': error!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'operationName=$operationName',
      'checkpointId=$checkpointId',
    ].join(',');
    return 'EvaluateDatasetRun($contents)';
  }
}

/// TunedModelCheckpoint for the Tuned Model of a Tuning Job.
final class TunedModelCheckpoint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TunedModelCheckpoint';

  /// The ID of the checkpoint.
  final String checkpointId;

  /// The epoch of the checkpoint.
  final int epoch;

  /// The step of the checkpoint.
  final int step;

  /// The Endpoint resource name that the checkpoint is deployed to. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`.
  final String endpoint;

  TunedModelCheckpoint({
    this.checkpointId = '',
    this.epoch = 0,
    this.step = 0,
    this.endpoint = '',
  }) : super(fullyQualifiedName);

  factory TunedModelCheckpoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TunedModelCheckpoint(
      checkpointId: switch (json['checkpointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      epoch: switch (json['epoch']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      step: switch (json['step']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (checkpointId.isNotDefault) 'checkpointId': checkpointId,
    if (epoch.isNotDefault) 'epoch': encodeInt64(epoch),
    if (step.isNotDefault) 'step': encodeInt64(step),
    if (endpoint.isNotDefault) 'endpoint': endpoint,
  };

  @override
  String toString() {
    final contents = [
      'checkpointId=$checkpointId',
      'epoch=$epoch',
      'step=$step',
      'endpoint=$endpoint',
    ].join(',');
    return 'TunedModelCheckpoint($contents)';
  }
}

/// A pre-tuned model for continuous tuning.
final class PreTunedModel extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PreTunedModel';

  /// The resource name of the Model.
  /// E.g., a model resource name with a specified version id or alias:
  ///
  /// `projects/{project}/locations/{location}/models/{model}@{version_id}`
  ///
  /// `projects/{project}/locations/{location}/models/{model}@{alias}`
  ///
  /// Or, omit the version id to use the default version:
  ///
  /// `projects/{project}/locations/{location}/models/{model}`
  final String tunedModelName;

  /// Optional. The source checkpoint id. If not specified, the default
  /// checkpoint will be used.
  final String checkpointId;

  /// Output only. The name of the base model this
  /// `PreTunedModel` was tuned
  /// from.
  final String baseModel;

  PreTunedModel({
    this.tunedModelName = '',
    this.checkpointId = '',
    this.baseModel = '',
  }) : super(fullyQualifiedName);

  factory PreTunedModel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PreTunedModel(
      tunedModelName: switch (json['tunedModelName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      checkpointId: switch (json['checkpointId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      baseModel: switch (json['baseModel']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (tunedModelName.isNotDefault) 'tunedModelName': tunedModelName,
    if (checkpointId.isNotDefault) 'checkpointId': checkpointId,
    if (baseModel.isNotDefault) 'baseModel': baseModel,
  };

  @override
  String toString() {
    final contents = [
      'tunedModelName=$tunedModelName',
      'checkpointId=$checkpointId',
      'baseModel=$baseModel',
    ].join(',');
    return 'PreTunedModel($contents)';
  }
}

/// A list of boolean values.
final class BoolArray extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BoolArray';

  /// A list of bool values.
  final List<bool> values;

  BoolArray({this.values = const []}) : super(fullyQualifiedName);

  factory BoolArray.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BoolArray(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeBool(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (values.isNotDefault) 'values': values};

  @override
  String toString() => 'BoolArray()';
}

/// A list of double values.
final class DoubleArray extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DoubleArray';

  /// A list of double values.
  final List<double> values;

  DoubleArray({this.values = const []}) : super(fullyQualifiedName);

  factory DoubleArray.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DoubleArray(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (values.isNotDefault) 'values': values};

  @override
  String toString() => 'DoubleArray()';
}

/// A list of int64 values.
final class Int64Array extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Int64Array';

  /// A list of int64 values.
  final List<int> values;

  Int64Array({this.values = const []}) : super(fullyQualifiedName);

  factory Int64Array.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Int64Array(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (values.isNotDefault) 'values': values};

  @override
  String toString() => 'Int64Array()';
}

/// A list of string values.
final class StringArray extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StringArray';

  /// A list of string values.
  final List<String> values;

  StringArray({this.values = const []}) : super(fullyQualifiedName);

  factory StringArray.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StringArray(
      values: switch (json['values']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"values" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (values.isNotDefault) 'values': values};

  @override
  String toString() => 'StringArray()';
}

/// A tensor value type.
final class Tensor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tensor';

  /// The data type of tensor.
  final Tensor_DataType dtype;

  /// Shape of the tensor.
  final List<int> shape;

  /// Type specific representations that make it easy to create tensor protos in
  /// all languages.  Only the representation corresponding to "dtype" can
  /// be set.  The values hold the flattened representation of the tensor in
  /// row major order.
  ///
  /// `BOOL`
  final List<bool> boolVal;

  /// `STRING`
  final List<String> stringVal;

  /// `STRING`
  final List<Uint8List> bytesVal;

  /// `FLOAT`
  final List<double> floatVal;

  /// `DOUBLE`
  final List<double> doubleVal;

  /// `INT_8`
  /// `INT_16`
  /// `INT_32`
  final List<int> intVal;

  /// `INT64`
  final List<int> int64Val;

  /// `UINT8`
  /// `UINT16`
  /// `UINT32`
  final List<int> uintVal;

  /// `UINT64`
  final List<BigInt> uint64Val;

  /// A list of tensor values.
  final List<Tensor> listVal;

  /// A map of string to tensor.
  final Map<String, Tensor> structVal;

  /// Serialized raw tensor content.
  final Uint8List tensorVal;

  Tensor({
    this.dtype = Tensor_DataType.$default,
    this.shape = const [],
    this.boolVal = const [],
    this.stringVal = const [],
    this.bytesVal = const [],
    this.floatVal = const [],
    this.doubleVal = const [],
    this.intVal = const [],
    this.int64Val = const [],
    this.uintVal = const [],
    this.uint64Val = const [],
    this.listVal = const [],
    this.structVal = const {},
    Uint8List? tensorVal,
  }) : tensorVal = tensorVal ?? Uint8List(0),
       super(fullyQualifiedName);

  factory Tensor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Tensor(
      dtype: switch (json['dtype']) {
        null => Tensor_DataType.$default,
        Object $1 => Tensor_DataType.fromJson($1),
      },
      shape: switch (json['shape']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException('"shape" is not a list'),
      },
      boolVal: switch (json['boolVal']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeBool(i)],
        _ => throw const FormatException('"boolVal" is not a list'),
      },
      stringVal: switch (json['stringVal']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"stringVal" is not a list'),
      },
      bytesVal: switch (json['bytesVal']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeBytes(i)],
        _ => throw const FormatException('"bytesVal" is not a list'),
      },
      floatVal: switch (json['floatVal']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"floatVal" is not a list'),
      },
      doubleVal: switch (json['doubleVal']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"doubleVal" is not a list'),
      },
      intVal: switch (json['intVal']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt(i)],
        _ => throw const FormatException('"intVal" is not a list'),
      },
      int64Val: switch (json['int64Val']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException('"int64Val" is not a list'),
      },
      uintVal: switch (json['uintVal']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt(i)],
        _ => throw const FormatException('"uintVal" is not a list'),
      },
      uint64Val: switch (json['uint64Val']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeUint64(i)],
        _ => throw const FormatException('"uint64Val" is not a list'),
      },
      listVal: switch (json['listVal']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Tensor.fromJson(i)],
        _ => throw const FormatException('"listVal" is not a list'),
      },
      structVal: switch (json['structVal']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Tensor.fromJson(e.value),
        },
        _ => throw const FormatException('"structVal" is not an object'),
      },
      tensorVal: switch (json['tensorVal']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (dtype.isNotDefault) 'dtype': dtype.toJson(),
    if (shape.isNotDefault) 'shape': shape,
    if (boolVal.isNotDefault) 'boolVal': boolVal,
    if (stringVal.isNotDefault) 'stringVal': stringVal,
    if (bytesVal.isNotDefault) 'bytesVal': encodeListBytes(bytesVal),
    if (floatVal.isNotDefault) 'floatVal': floatVal,
    if (doubleVal.isNotDefault) 'doubleVal': doubleVal,
    if (intVal.isNotDefault) 'intVal': intVal,
    if (int64Val.isNotDefault) 'int64Val': int64Val,
    if (uintVal.isNotDefault) 'uintVal': uintVal,
    if (uint64Val.isNotDefault) 'uint64Val': uint64Val,
    if (listVal.isNotDefault) 'listVal': encodeList(listVal),
    if (structVal.isNotDefault) 'structVal': encodeMap(structVal),
    if (tensorVal.isNotDefault) 'tensorVal': encodeBytes(tensorVal),
  };

  @override
  String toString() {
    final contents = ['dtype=$dtype', 'tensorVal=$tensorVal'].join(',');
    return 'Tensor($contents)';
  }
}

/// Data type of the tensor.
final class Tensor_DataType extends ProtoEnum {
  /// Not a legal value for DataType. Used to indicate a DataType field has not
  /// been set.
  static const dataTypeUnspecified = Tensor_DataType('DATA_TYPE_UNSPECIFIED');

  /// Data types that all computation devices are expected to be
  /// capable to support.
  static const bool$ = Tensor_DataType('BOOL');

  static const string = Tensor_DataType('STRING');

  static const float = Tensor_DataType('FLOAT');

  static const double$ = Tensor_DataType('DOUBLE');

  static const int8 = Tensor_DataType('INT8');

  static const int16 = Tensor_DataType('INT16');

  static const int32 = Tensor_DataType('INT32');

  static const int64 = Tensor_DataType('INT64');

  static const uint8 = Tensor_DataType('UINT8');

  static const uint16 = Tensor_DataType('UINT16');

  static const uint32 = Tensor_DataType('UINT32');

  static const uint64 = Tensor_DataType('UINT64');

  /// The default value for [Tensor_DataType].
  static const $default = dataTypeUnspecified;

  const Tensor_DataType(super.value);

  factory Tensor_DataType.fromJson(Object? json) =>
      Tensor_DataType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DataType.$value';
}

/// The definition of a artifact type in MLMD.
final class ArtifactTypeSchema extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ArtifactTypeSchema';

  /// The name of the type. The format of the title must be:
  /// `<namespace>.<title>`.
  /// Examples:
  ///  - `aiplatform.Model`
  ///  - `acme.CustomModel`
  /// When this field is set, the type must be pre-registered in the MLMD
  /// store.
  final String? schemaTitle;

  /// Points to a YAML file stored on Cloud Storage describing the
  /// format.
  /// Deprecated. Use `PipelineArtifactTypeSchema.schema_title` or
  /// `PipelineArtifactTypeSchema.instance_schema` instead.
  final String? schemaUri;

  /// Contains a raw YAML string, describing the format of
  /// the properties of the type.
  final String? instanceSchema;

  /// The schema version of the artifact. If the value is not set, it defaults
  /// to the latest version in the system.
  final String schemaVersion;

  ArtifactTypeSchema({
    this.schemaTitle,
    this.schemaUri,
    this.instanceSchema,
    this.schemaVersion = '',
  }) : super(fullyQualifiedName);

  factory ArtifactTypeSchema.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ArtifactTypeSchema(
      schemaTitle: switch (json['schemaTitle']) {
        null => null,
        Object $1 => decodeString($1),
      },
      schemaUri: switch (json['schemaUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      instanceSchema: switch (json['instanceSchema']) {
        null => null,
        Object $1 => decodeString($1),
      },
      schemaVersion: switch (json['schemaVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (schemaTitle != null) 'schemaTitle': schemaTitle,
    if (schemaUri != null) 'schemaUri': schemaUri,
    if (instanceSchema != null) 'instanceSchema': instanceSchema,
    if (schemaVersion.isNotDefault) 'schemaVersion': schemaVersion,
  };

  @override
  String toString() {
    final contents = [
      if (schemaTitle != null) 'schemaTitle=$schemaTitle',
      if (schemaUri != null) 'schemaUri=$schemaUri',
      if (instanceSchema != null) 'instanceSchema=$instanceSchema',
      'schemaVersion=$schemaVersion',
    ].join(',');
    return 'ArtifactTypeSchema($contents)';
  }
}

/// The definition of a runtime artifact.
final class RuntimeArtifact extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RuntimeArtifact';

  /// The name of an artifact.
  final String name;

  /// The type of the artifact.
  final ArtifactTypeSchema? type;

  /// The URI of the artifact.
  final String uri;

  /// The properties of the artifact.
  /// Deprecated. Use
  /// `RuntimeArtifact.metadata`
  /// instead.
  final Map<String, Value> properties;

  /// The custom properties of the artifact.
  /// Deprecated. Use
  /// `RuntimeArtifact.metadata`
  /// instead.
  final Map<String, Value> customProperties;

  /// Properties of the Artifact.
  final protobuf.Struct? metadata;

  RuntimeArtifact({
    this.name = '',
    this.type,
    this.uri = '',
    this.properties = const {},
    this.customProperties = const {},
    this.metadata,
  }) : super(fullyQualifiedName);

  factory RuntimeArtifact.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RuntimeArtifact(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      type: switch (json['type']) {
        null => null,
        Object $1 => ArtifactTypeSchema.fromJson($1),
      },
      uri: switch (json['uri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      properties: switch (json['properties']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Value.fromJson(e.value),
        },
        _ => throw const FormatException('"properties" is not an object'),
      },
      customProperties: switch (json['customProperties']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): Value.fromJson(e.value),
        },
        _ => throw const FormatException('"customProperties" is not an object'),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => protobuf.Struct.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (type != null) 'type': type!.toJson(),
    if (uri.isNotDefault) 'uri': uri,
    if (properties.isNotDefault) 'properties': encodeMap(properties),
    if (customProperties.isNotDefault)
      'customProperties': encodeMap(customProperties),
    if (metadata != null) 'metadata': metadata!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'uri=$uri'].join(',');
    return 'RuntimeArtifact($contents)';
  }
}

/// Contains model information necessary to perform batch prediction without
/// requiring a full model import.
final class UnmanagedContainerModel extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UnmanagedContainerModel';

  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  final String artifactUri;

  /// Contains the schemata used in Model's predictions and explanations
  final PredictSchemata? predictSchemata;

  /// Input only. The specification of the container that is to be used when
  /// deploying this Model.
  final ModelContainerSpec? containerSpec;

  UnmanagedContainerModel({
    this.artifactUri = '',
    this.predictSchemata,
    this.containerSpec,
  }) : super(fullyQualifiedName);

  factory UnmanagedContainerModel.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UnmanagedContainerModel(
      artifactUri: switch (json['artifactUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      predictSchemata: switch (json['predictSchemata']) {
        null => null,
        Object $1 => PredictSchemata.fromJson($1),
      },
      containerSpec: switch (json['containerSpec']) {
        null => null,
        Object $1 => ModelContainerSpec.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (artifactUri.isNotDefault) 'artifactUri': artifactUri,
    if (predictSchemata != null) 'predictSchemata': predictSchemata!.toJson(),
    if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
  };

  @override
  String toString() {
    final contents = ['artifactUri=$artifactUri'].join(',');
    return 'UnmanagedContainerModel($contents)';
  }
}

/// References an API call. It contains more information about long running
/// operation and Jobs that are triggered by the API call.
final class UserActionReference extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UserActionReference';

  /// For API calls that return a long running operation.
  /// Resource name of the long running operation.
  /// Format:
  /// `projects/{project}/locations/{location}/operations/{operation}`
  final String? operation;

  /// For API calls that start a LabelingJob.
  /// Resource name of the LabelingJob.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  final String? dataLabelingJob;

  /// The method name of the API RPC call. For example,
  /// "/google.cloud.aiplatform.{apiVersion}.DatasetService.CreateDataset"
  final String method;

  UserActionReference({this.operation, this.dataLabelingJob, this.method = ''})
    : super(fullyQualifiedName);

  factory UserActionReference.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UserActionReference(
      operation: switch (json['operation']) {
        null => null,
        Object $1 => decodeString($1),
      },
      dataLabelingJob: switch (json['dataLabelingJob']) {
        null => null,
        Object $1 => decodeString($1),
      },
      method: switch (json['method']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (operation != null) 'operation': operation,
    if (dataLabelingJob != null) 'dataLabelingJob': dataLabelingJob,
    if (method.isNotDefault) 'method': method,
  };

  @override
  String toString() {
    final contents = [
      if (operation != null) 'operation=$operation',
      if (dataLabelingJob != null) 'dataLabelingJob=$dataLabelingJob',
      'method=$method',
    ].join(',');
    return 'UserActionReference($contents)';
  }
}

/// Value is the value of the field.
final class Value extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Value';

  /// An integer value.
  final int? intValue;

  /// A double value.
  final double? doubleValue;

  /// A string value.
  final String? stringValue;

  Value({this.intValue, this.doubleValue, this.stringValue})
    : super(fullyQualifiedName);

  factory Value.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Value(
      intValue: switch (json['intValue']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
      doubleValue: switch (json['doubleValue']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      stringValue: switch (json['stringValue']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (intValue != null) 'intValue': encodeInt64(intValue),
    if (doubleValue != null) 'doubleValue': encodeDouble(doubleValue),
    if (stringValue != null) 'stringValue': stringValue,
  };

  @override
  String toString() {
    final contents = [
      if (intValue != null) 'intValue=$intValue',
      if (doubleValue != null) 'doubleValue=$doubleValue',
      if (stringValue != null) 'stringValue=$stringValue',
    ].join(',');
    return 'Value($contents)';
  }
}

/// Config for the embedding model to use for RAG.
final class RagEmbeddingModelConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig';

  /// The Vertex AI Prediction Endpoint that either refers to a publisher model
  /// or an endpoint that is hosting a 1P fine-tuned text embedding model.
  /// Endpoints hosting non-1P fine-tuned text embedding models are
  /// currently not supported.
  /// This is used for dense vector search.
  final RagEmbeddingModelConfig_VertexPredictionEndpoint?
  vertexPredictionEndpoint;

  /// Configuration for hybrid search.
  final RagEmbeddingModelConfig_HybridSearchConfig? hybridSearchConfig;

  RagEmbeddingModelConfig({
    this.vertexPredictionEndpoint,
    this.hybridSearchConfig,
  }) : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagEmbeddingModelConfig(
      vertexPredictionEndpoint: switch (json['vertexPredictionEndpoint']) {
        null => null,
        Object $1 => RagEmbeddingModelConfig_VertexPredictionEndpoint.fromJson(
          $1,
        ),
      },
      hybridSearchConfig: switch (json['hybridSearchConfig']) {
        null => null,
        Object $1 => RagEmbeddingModelConfig_HybridSearchConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vertexPredictionEndpoint != null)
      'vertexPredictionEndpoint': vertexPredictionEndpoint!.toJson(),
    if (hybridSearchConfig != null)
      'hybridSearchConfig': hybridSearchConfig!.toJson(),
  };

  @override
  String toString() => 'RagEmbeddingModelConfig()';
}

/// Config representing a model hosted on Vertex Prediction Endpoint.
final class RagEmbeddingModelConfig_VertexPredictionEndpoint
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig.VertexPredictionEndpoint';

  /// Required. The endpoint resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// or
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Output only. The resource name of the model that is deployed on the
  /// endpoint. Present only when the endpoint is not a publisher model.
  /// Pattern:
  /// `projects/{project}/locations/{location}/models/{model}`
  final String model;

  /// Output only. Version ID of the model that is deployed on the endpoint.
  /// Present only when the endpoint is not a publisher model.
  final String modelVersionId;

  RagEmbeddingModelConfig_VertexPredictionEndpoint({
    required this.endpoint,
    this.model = '',
    this.modelVersionId = '',
  }) : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig_VertexPredictionEndpoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagEmbeddingModelConfig_VertexPredictionEndpoint(
      endpoint: switch (json['endpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersionId: switch (json['modelVersionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'endpoint': endpoint,
    if (model.isNotDefault) 'model': model,
    if (modelVersionId.isNotDefault) 'modelVersionId': modelVersionId,
  };

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      'model=$model',
      'modelVersionId=$modelVersionId',
    ].join(',');
    return 'VertexPredictionEndpoint($contents)';
  }
}

/// Configuration for sparse emebdding generation.
final class RagEmbeddingModelConfig_SparseEmbeddingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig.SparseEmbeddingConfig';

  /// Use BM25 scoring algorithm.
  final RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25? bm25;

  RagEmbeddingModelConfig_SparseEmbeddingConfig({this.bm25})
    : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig_SparseEmbeddingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagEmbeddingModelConfig_SparseEmbeddingConfig(
      bm25: switch (json['bm25']) {
        null => null,
        Object $1 =>
          RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (bm25 != null) 'bm25': bm25!.toJson()};

  @override
  String toString() => 'SparseEmbeddingConfig()';
}

/// Message for BM25 parameters.
final class RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig.SparseEmbeddingConfig.Bm25';

  /// Optional. Use multilingual tokenizer if set to true.
  final bool multilingual;

  /// Optional. The parameter to control term frequency saturation. It
  /// determines the scaling between the matching term frequency and final
  /// score. k1 is in the range of [1.2, 3]. The default value is 1.2.
  final double? k1;

  /// Optional. The parameter to control document length normalization. It
  /// determines how much the document length affects the final score. b is
  /// in the range of [0, 1]. The default value is 0.75.
  final double? b;

  RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25({
    this.multilingual = false,
    this.k1,
    this.b,
  }) : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25(
      multilingual: switch (json['multilingual']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      k1: switch (json['k1']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      b: switch (json['b']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (multilingual.isNotDefault) 'multilingual': multilingual,
    if (k1 != null) 'k1': encodeDouble(k1),
    if (b != null) 'b': encodeDouble(b),
  };

  @override
  String toString() {
    final contents = [
      'multilingual=$multilingual',
      if (k1 != null) 'k1=$k1',
      if (b != null) 'b=$b',
    ].join(',');
    return 'Bm25($contents)';
  }
}

/// Config for hybrid search.
final class RagEmbeddingModelConfig_HybridSearchConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig.HybridSearchConfig';

  /// Optional. The configuration for sparse embedding generation. This field
  /// is optional the default behavior depends on the vector database choice on
  /// the RagCorpus.
  final RagEmbeddingModelConfig_SparseEmbeddingConfig? sparseEmbeddingConfig;

  /// Required. The Vertex AI Prediction Endpoint that hosts the embedding
  /// model for dense embedding generations.
  final RagEmbeddingModelConfig_VertexPredictionEndpoint?
  denseEmbeddingModelPredictionEndpoint;

  RagEmbeddingModelConfig_HybridSearchConfig({
    this.sparseEmbeddingConfig,
    required this.denseEmbeddingModelPredictionEndpoint,
  }) : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig_HybridSearchConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagEmbeddingModelConfig_HybridSearchConfig(
      sparseEmbeddingConfig: switch (json['sparseEmbeddingConfig']) {
        null => null,
        Object $1 => RagEmbeddingModelConfig_SparseEmbeddingConfig.fromJson($1),
      },
      denseEmbeddingModelPredictionEndpoint:
          switch (json['denseEmbeddingModelPredictionEndpoint']) {
            null => null,
            Object $1 =>
              RagEmbeddingModelConfig_VertexPredictionEndpoint.fromJson($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (sparseEmbeddingConfig != null)
      'sparseEmbeddingConfig': sparseEmbeddingConfig!.toJson(),
    if (denseEmbeddingModelPredictionEndpoint != null)
      'denseEmbeddingModelPredictionEndpoint':
          denseEmbeddingModelPredictionEndpoint!.toJson(),
  };

  @override
  String toString() => 'HybridSearchConfig()';
}

/// Config for the Vector DB to use for RAG.
final class RagVectorDbConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig';

  /// The config for the RAG-managed Vector DB.
  final RagVectorDbConfig_RagManagedDb? ragManagedDb;

  /// The config for the Weaviate.
  final RagVectorDbConfig_Weaviate? weaviate;

  /// The config for the Pinecone.
  final RagVectorDbConfig_Pinecone? pinecone;

  /// The config for the Vertex Feature Store.
  final RagVectorDbConfig_VertexFeatureStore? vertexFeatureStore;

  /// The config for the Vertex Vector Search.
  final RagVectorDbConfig_VertexVectorSearch? vertexVectorSearch;

  /// Authentication config for the chosen Vector DB.
  final ApiAuth? apiAuth;

  /// Optional. Immutable. The embedding model config of the Vector DB.
  final RagEmbeddingModelConfig? ragEmbeddingModelConfig;

  RagVectorDbConfig({
    this.ragManagedDb,
    this.weaviate,
    this.pinecone,
    this.vertexFeatureStore,
    this.vertexVectorSearch,
    this.apiAuth,
    this.ragEmbeddingModelConfig,
  }) : super(fullyQualifiedName);

  factory RagVectorDbConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagVectorDbConfig(
      ragManagedDb: switch (json['ragManagedDb']) {
        null => null,
        Object $1 => RagVectorDbConfig_RagManagedDb.fromJson($1),
      },
      weaviate: switch (json['weaviate']) {
        null => null,
        Object $1 => RagVectorDbConfig_Weaviate.fromJson($1),
      },
      pinecone: switch (json['pinecone']) {
        null => null,
        Object $1 => RagVectorDbConfig_Pinecone.fromJson($1),
      },
      vertexFeatureStore: switch (json['vertexFeatureStore']) {
        null => null,
        Object $1 => RagVectorDbConfig_VertexFeatureStore.fromJson($1),
      },
      vertexVectorSearch: switch (json['vertexVectorSearch']) {
        null => null,
        Object $1 => RagVectorDbConfig_VertexVectorSearch.fromJson($1),
      },
      apiAuth: switch (json['apiAuth']) {
        null => null,
        Object $1 => ApiAuth.fromJson($1),
      },
      ragEmbeddingModelConfig: switch (json['ragEmbeddingModelConfig']) {
        null => null,
        Object $1 => RagEmbeddingModelConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragManagedDb != null) 'ragManagedDb': ragManagedDb!.toJson(),
    if (weaviate != null) 'weaviate': weaviate!.toJson(),
    if (pinecone != null) 'pinecone': pinecone!.toJson(),
    if (vertexFeatureStore != null)
      'vertexFeatureStore': vertexFeatureStore!.toJson(),
    if (vertexVectorSearch != null)
      'vertexVectorSearch': vertexVectorSearch!.toJson(),
    if (apiAuth != null) 'apiAuth': apiAuth!.toJson(),
    if (ragEmbeddingModelConfig != null)
      'ragEmbeddingModelConfig': ragEmbeddingModelConfig!.toJson(),
  };

  @override
  String toString() => 'RagVectorDbConfig()';
}

/// The config for the default RAG-managed Vector DB.
final class RagVectorDbConfig_RagManagedDb extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.RagManagedDb';

  /// Performs a KNN search on RagCorpus.
  /// Default choice if not specified.
  final RagVectorDbConfig_RagManagedDb_Knn? knn;

  /// Performs an ANN search on RagCorpus. Use this if you have a lot of
  /// files (> 10K) in your RagCorpus and want to reduce the search latency.
  final RagVectorDbConfig_RagManagedDb_Ann? ann;

  RagVectorDbConfig_RagManagedDb({this.knn, this.ann})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_RagManagedDb.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagVectorDbConfig_RagManagedDb(
      knn: switch (json['knn']) {
        null => null,
        Object $1 => RagVectorDbConfig_RagManagedDb_Knn.fromJson($1),
      },
      ann: switch (json['ann']) {
        null => null,
        Object $1 => RagVectorDbConfig_RagManagedDb_Ann.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (knn != null) 'knn': knn!.toJson(),
    if (ann != null) 'ann': ann!.toJson(),
  };

  @override
  String toString() => 'RagManagedDb()';
}

/// Config for KNN search.
final class RagVectorDbConfig_RagManagedDb_Knn extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.RagManagedDb.KNN';

  RagVectorDbConfig_RagManagedDb_Knn() : super(fullyQualifiedName);

  factory RagVectorDbConfig_RagManagedDb_Knn.fromJson(Object? j) =>
      RagVectorDbConfig_RagManagedDb_Knn();

  @override
  Object toJson() => {};

  @override
  String toString() => 'KNN()';
}

/// Config for ANN search.
///
/// RagManagedDb uses a tree-based structure to partition data and
/// facilitate faster searches. As a tradeoff, it requires longer indexing
/// time and manual triggering of index rebuild via the ImportRagFiles and
/// UpdateRagCorpus API.
final class RagVectorDbConfig_RagManagedDb_Ann extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.RagManagedDb.ANN';

  /// The depth of the tree-based structure. Only depth values of 2 and 3 are
  /// supported.
  ///
  /// Recommended value is 2 if you have if you have O(10K) files in the
  /// RagCorpus and set this to 3 if more than that.
  ///
  /// Default value is 2.
  final int treeDepth;

  /// Number of leaf nodes in the tree-based structure. Each leaf node
  /// contains groups of closely related vectors along with their
  /// corresponding centroid.
  ///
  /// Recommended value is 10 * sqrt(num of RagFiles in your RagCorpus).
  ///
  /// Default value is 500.
  final int leafCount;

  RagVectorDbConfig_RagManagedDb_Ann({this.treeDepth = 0, this.leafCount = 0})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_RagManagedDb_Ann.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagVectorDbConfig_RagManagedDb_Ann(
      treeDepth: switch (json['treeDepth']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      leafCount: switch (json['leafCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (treeDepth.isNotDefault) 'treeDepth': treeDepth,
    if (leafCount.isNotDefault) 'leafCount': leafCount,
  };

  @override
  String toString() {
    final contents = ['treeDepth=$treeDepth', 'leafCount=$leafCount'].join(',');
    return 'ANN($contents)';
  }
}

/// The config for the Weaviate.
final class RagVectorDbConfig_Weaviate extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.Weaviate';

  /// Weaviate DB instance HTTP endpoint. e.g. 34.56.78.90:8080
  /// Vertex RAG only supports HTTP connection to Weaviate.
  /// This value cannot be changed after it's set.
  final String httpEndpoint;

  /// The corresponding collection this corpus maps to.
  /// This value cannot be changed after it's set.
  final String collectionName;

  RagVectorDbConfig_Weaviate({this.httpEndpoint = '', this.collectionName = ''})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_Weaviate.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagVectorDbConfig_Weaviate(
      httpEndpoint: switch (json['httpEndpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      collectionName: switch (json['collectionName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (httpEndpoint.isNotDefault) 'httpEndpoint': httpEndpoint,
    if (collectionName.isNotDefault) 'collectionName': collectionName,
  };

  @override
  String toString() {
    final contents = [
      'httpEndpoint=$httpEndpoint',
      'collectionName=$collectionName',
    ].join(',');
    return 'Weaviate($contents)';
  }
}

/// The config for the Pinecone.
final class RagVectorDbConfig_Pinecone extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.Pinecone';

  /// Pinecone index name.
  /// This value cannot be changed after it's set.
  final String indexName;

  RagVectorDbConfig_Pinecone({this.indexName = ''}) : super(fullyQualifiedName);

  factory RagVectorDbConfig_Pinecone.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagVectorDbConfig_Pinecone(
      indexName: switch (json['indexName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (indexName.isNotDefault) 'indexName': indexName};

  @override
  String toString() {
    final contents = ['indexName=$indexName'].join(',');
    return 'Pinecone($contents)';
  }
}

/// The config for the Vertex Feature Store.
final class RagVectorDbConfig_VertexFeatureStore extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.VertexFeatureStore';

  /// The resource name of the FeatureView.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String featureViewResourceName;

  RagVectorDbConfig_VertexFeatureStore({this.featureViewResourceName = ''})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_VertexFeatureStore.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagVectorDbConfig_VertexFeatureStore(
      featureViewResourceName: switch (json['featureViewResourceName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (featureViewResourceName.isNotDefault)
      'featureViewResourceName': featureViewResourceName,
  };

  @override
  String toString() {
    final contents = [
      'featureViewResourceName=$featureViewResourceName',
    ].join(',');
    return 'VertexFeatureStore($contents)';
  }
}

/// The config for the Vertex Vector Search.
final class RagVectorDbConfig_VertexVectorSearch extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.VertexVectorSearch';

  /// The resource name of the Index Endpoint.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// The resource name of the Index.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String index;

  RagVectorDbConfig_VertexVectorSearch({
    this.indexEndpoint = '',
    this.index = '',
  }) : super(fullyQualifiedName);

  factory RagVectorDbConfig_VertexVectorSearch.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagVectorDbConfig_VertexVectorSearch(
      indexEndpoint: switch (json['indexEndpoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      index: switch (json['index']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (indexEndpoint.isNotDefault) 'indexEndpoint': indexEndpoint,
    if (index.isNotDefault) 'index': index,
  };

  @override
  String toString() {
    final contents = ['indexEndpoint=$indexEndpoint', 'index=$index'].join(',');
    return 'VertexVectorSearch($contents)';
  }
}

/// RagFile status.
final class FileStatus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FileStatus';

  /// Output only. RagFile state.
  final FileStatus_State state;

  /// Output only. Only when the `state` field is ERROR.
  final String errorStatus;

  FileStatus({this.state = FileStatus_State.$default, this.errorStatus = ''})
    : super(fullyQualifiedName);

  factory FileStatus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FileStatus(
      state: switch (json['state']) {
        null => FileStatus_State.$default,
        Object $1 => FileStatus_State.fromJson($1),
      },
      errorStatus: switch (json['errorStatus']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (state.isNotDefault) 'state': state.toJson(),
    if (errorStatus.isNotDefault) 'errorStatus': errorStatus,
  };

  @override
  String toString() {
    final contents = ['state=$state', 'errorStatus=$errorStatus'].join(',');
    return 'FileStatus($contents)';
  }
}

/// RagFile state.
final class FileStatus_State extends ProtoEnum {
  /// RagFile state is unspecified.
  static const stateUnspecified = FileStatus_State('STATE_UNSPECIFIED');

  /// RagFile resource has been created and indexed successfully.
  static const active = FileStatus_State('ACTIVE');

  /// RagFile resource is in a problematic state.
  /// See `error_message` field for details.
  static const error = FileStatus_State('ERROR');

  /// The default value for [FileStatus_State].
  static const $default = stateUnspecified;

  const FileStatus_State(super.value);

  factory FileStatus_State.fromJson(Object? json) =>
      FileStatus_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Config for the Vertex AI Search.
final class VertexAiSearchConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexAiSearchConfig';

  /// Vertex AI Search Serving Config resource full name. For example,
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/servingConfigs/{serving_config}`.
  final String servingConfig;

  VertexAiSearchConfig({this.servingConfig = ''}) : super(fullyQualifiedName);

  factory VertexAiSearchConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VertexAiSearchConfig(
      servingConfig: switch (json['servingConfig']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (servingConfig.isNotDefault) 'servingConfig': servingConfig,
  };

  @override
  String toString() {
    final contents = ['servingConfig=$servingConfig'].join(',');
    return 'VertexAiSearchConfig($contents)';
  }
}

/// RagCorpus status.
final class CorpusStatus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CorpusStatus';

  /// Output only. RagCorpus life state.
  final CorpusStatus_State state;

  /// Output only. Only when the `state` field is ERROR.
  final String errorStatus;

  CorpusStatus({
    this.state = CorpusStatus_State.$default,
    this.errorStatus = '',
  }) : super(fullyQualifiedName);

  factory CorpusStatus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CorpusStatus(
      state: switch (json['state']) {
        null => CorpusStatus_State.$default,
        Object $1 => CorpusStatus_State.fromJson($1),
      },
      errorStatus: switch (json['errorStatus']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (state.isNotDefault) 'state': state.toJson(),
    if (errorStatus.isNotDefault) 'errorStatus': errorStatus,
  };

  @override
  String toString() {
    final contents = ['state=$state', 'errorStatus=$errorStatus'].join(',');
    return 'CorpusStatus($contents)';
  }
}

/// RagCorpus life state.
final class CorpusStatus_State extends ProtoEnum {
  /// This state is not supposed to happen.
  static const unknown = CorpusStatus_State('UNKNOWN');

  /// RagCorpus resource entry is initialized, but hasn't done validation.
  static const initialized = CorpusStatus_State('INITIALIZED');

  /// RagCorpus is provisioned successfully and is ready to serve.
  static const active = CorpusStatus_State('ACTIVE');

  /// RagCorpus is in a problematic situation.
  /// See `error_message` field for details.
  static const error = CorpusStatus_State('ERROR');

  /// The default value for [CorpusStatus_State].
  static const $default = unknown;

  const CorpusStatus_State(super.value);

  factory CorpusStatus_State.fromJson(Object? json) =>
      CorpusStatus_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// A RagCorpus is a RagFile container and a project can have multiple
/// RagCorpora.
final class RagCorpus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagCorpus';

  /// Optional. Immutable. The config for the Vector DBs.
  final RagVectorDbConfig? vectorDbConfig;

  /// Optional. Immutable. The config for the Vertex AI Search.
  final VertexAiSearchConfig? vertexAiSearchConfig;

  /// Output only. The resource name of the RagCorpus.
  final String name;

  /// Required. The display name of the RagCorpus.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Optional. The description of the RagCorpus.
  final String description;

  /// Optional. Immutable. The embedding model config of the RagCorpus.
  final RagEmbeddingModelConfig? ragEmbeddingModelConfig;

  /// Optional. Immutable. The Vector DB config of the RagCorpus.
  final RagVectorDbConfig? ragVectorDbConfig;

  /// Output only. Timestamp when this RagCorpus was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this RagCorpus was last updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. RagCorpus state.
  final CorpusStatus? corpusStatus;

  /// Output only. Number of RagFiles in the RagCorpus.
  final int ragFilesCount;

  /// Optional. Immutable. The CMEK key name used to encrypt at-rest data related
  /// to this Corpus. Only applicable to RagManagedDb option for Vector DB. This
  /// field can only be set at corpus creation time, and cannot be updated or
  /// deleted.
  final EncryptionSpec? encryptionSpec;

  /// Optional. The corpus type config of the RagCorpus.
  final RagCorpus_CorpusTypeConfig? corpusTypeConfig;

  RagCorpus({
    this.vectorDbConfig,
    this.vertexAiSearchConfig,
    this.name = '',
    required this.displayName,
    this.description = '',
    this.ragEmbeddingModelConfig,
    this.ragVectorDbConfig,
    this.createTime,
    this.updateTime,
    this.corpusStatus,
    this.ragFilesCount = 0,
    this.encryptionSpec,
    this.corpusTypeConfig,
  }) : super(fullyQualifiedName);

  factory RagCorpus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagCorpus(
      vectorDbConfig: switch (json['vectorDbConfig']) {
        null => null,
        Object $1 => RagVectorDbConfig.fromJson($1),
      },
      vertexAiSearchConfig: switch (json['vertexAiSearchConfig']) {
        null => null,
        Object $1 => VertexAiSearchConfig.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ragEmbeddingModelConfig: switch (json['ragEmbeddingModelConfig']) {
        null => null,
        Object $1 => RagEmbeddingModelConfig.fromJson($1),
      },
      ragVectorDbConfig: switch (json['ragVectorDbConfig']) {
        null => null,
        Object $1 => RagVectorDbConfig.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      corpusStatus: switch (json['corpusStatus']) {
        null => null,
        Object $1 => CorpusStatus.fromJson($1),
      },
      ragFilesCount: switch (json['ragFilesCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      encryptionSpec: switch (json['encryptionSpec']) {
        null => null,
        Object $1 => EncryptionSpec.fromJson($1),
      },
      corpusTypeConfig: switch (json['corpusTypeConfig']) {
        null => null,
        Object $1 => RagCorpus_CorpusTypeConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vectorDbConfig != null) 'vectorDbConfig': vectorDbConfig!.toJson(),
    if (vertexAiSearchConfig != null)
      'vertexAiSearchConfig': vertexAiSearchConfig!.toJson(),
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (ragEmbeddingModelConfig != null)
      'ragEmbeddingModelConfig': ragEmbeddingModelConfig!.toJson(),
    if (ragVectorDbConfig != null)
      'ragVectorDbConfig': ragVectorDbConfig!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (corpusStatus != null) 'corpusStatus': corpusStatus!.toJson(),
    if (ragFilesCount.isNotDefault) 'ragFilesCount': ragFilesCount,
    if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    if (corpusTypeConfig != null)
      'corpusTypeConfig': corpusTypeConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'ragFilesCount=$ragFilesCount',
    ].join(',');
    return 'RagCorpus($contents)';
  }
}

/// The config for the corpus type of the RagCorpus.
final class RagCorpus_CorpusTypeConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagCorpus.CorpusTypeConfig';

  /// Optional. Config for the document corpus.
  final RagCorpus_CorpusTypeConfig_DocumentCorpus? documentCorpus;

  /// Optional. Config for the memory corpus.
  final RagCorpus_CorpusTypeConfig_MemoryCorpus? memoryCorpus;

  RagCorpus_CorpusTypeConfig({this.documentCorpus, this.memoryCorpus})
    : super(fullyQualifiedName);

  factory RagCorpus_CorpusTypeConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagCorpus_CorpusTypeConfig(
      documentCorpus: switch (json['documentCorpus']) {
        null => null,
        Object $1 => RagCorpus_CorpusTypeConfig_DocumentCorpus.fromJson($1),
      },
      memoryCorpus: switch (json['memoryCorpus']) {
        null => null,
        Object $1 => RagCorpus_CorpusTypeConfig_MemoryCorpus.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (documentCorpus != null) 'documentCorpus': documentCorpus!.toJson(),
    if (memoryCorpus != null) 'memoryCorpus': memoryCorpus!.toJson(),
  };

  @override
  String toString() => 'CorpusTypeConfig()';
}

/// Config for the document corpus.
final class RagCorpus_CorpusTypeConfig_DocumentCorpus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagCorpus.CorpusTypeConfig.DocumentCorpus';

  RagCorpus_CorpusTypeConfig_DocumentCorpus() : super(fullyQualifiedName);

  factory RagCorpus_CorpusTypeConfig_DocumentCorpus.fromJson(Object? j) =>
      RagCorpus_CorpusTypeConfig_DocumentCorpus();

  @override
  Object toJson() => {};

  @override
  String toString() => 'DocumentCorpus()';
}

/// Config for the memory corpus.
final class RagCorpus_CorpusTypeConfig_MemoryCorpus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagCorpus.CorpusTypeConfig.MemoryCorpus';

  /// The LLM parser to use for the memory corpus.
  final RagFileParsingConfig_LlmParser? llmParser;

  RagCorpus_CorpusTypeConfig_MemoryCorpus({this.llmParser})
    : super(fullyQualifiedName);

  factory RagCorpus_CorpusTypeConfig_MemoryCorpus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagCorpus_CorpusTypeConfig_MemoryCorpus(
      llmParser: switch (json['llmParser']) {
        null => null,
        Object $1 => RagFileParsingConfig_LlmParser.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (llmParser != null) 'llmParser': llmParser!.toJson()};

  @override
  String toString() => 'MemoryCorpus()';
}

/// A RagFile contains user data for chunking, embedding and indexing.
final class RagFile extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFile';

  /// Output only. Google Cloud Storage location of the RagFile.
  /// It does not support wildcards in the Cloud Storage uri for now.
  final GcsSource? gcsSource;

  /// Output only. Google Drive location. Supports importing individual files
  /// as well as Google Drive folders.
  final GoogleDriveSource? googleDriveSource;

  /// Output only. The RagFile is encapsulated and uploaded in the
  /// UploadRagFile request.
  final DirectUploadSource? directUploadSource;

  /// The RagFile is imported from a Slack channel.
  final SlackSource? slackSource;

  /// The RagFile is imported from a Jira query.
  final JiraSource? jiraSource;

  /// The RagFile is imported from a SharePoint source.
  final SharePointSources? sharePointSources;

  /// Output only. The resource name of the RagFile.
  final String name;

  /// Required. The display name of the RagFile.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String displayName;

  /// Optional. The description of the RagFile.
  final String description;

  /// Output only. The size of the RagFile in bytes.
  final int sizeBytes;

  /// Output only. The type of the RagFile.
  final RagFile_RagFileType ragFileType;

  /// Output only. Timestamp when this RagFile was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this RagFile was last updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. State of the RagFile.
  final FileStatus? fileStatus;

  /// Output only. The metadata for metadata search. The contents will be
  /// be in JSON format.
  final String userMetadata;

  RagFile({
    this.gcsSource,
    this.googleDriveSource,
    this.directUploadSource,
    this.slackSource,
    this.jiraSource,
    this.sharePointSources,
    this.name = '',
    required this.displayName,
    this.description = '',
    this.sizeBytes = 0,
    this.ragFileType = RagFile_RagFileType.$default,
    this.createTime,
    this.updateTime,
    this.fileStatus,
    this.userMetadata = '',
  }) : super(fullyQualifiedName);

  factory RagFile.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFile(
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      googleDriveSource: switch (json['googleDriveSource']) {
        null => null,
        Object $1 => GoogleDriveSource.fromJson($1),
      },
      directUploadSource: switch (json['directUploadSource']) {
        null => null,
        Object $1 => DirectUploadSource.fromJson($1),
      },
      slackSource: switch (json['slackSource']) {
        null => null,
        Object $1 => SlackSource.fromJson($1),
      },
      jiraSource: switch (json['jiraSource']) {
        null => null,
        Object $1 => JiraSource.fromJson($1),
      },
      sharePointSources: switch (json['sharePointSources']) {
        null => null,
        Object $1 => SharePointSources.fromJson($1),
      },
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sizeBytes: switch (json['sizeBytes']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      ragFileType: switch (json['ragFileType']) {
        null => RagFile_RagFileType.$default,
        Object $1 => RagFile_RagFileType.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      fileStatus: switch (json['fileStatus']) {
        null => null,
        Object $1 => FileStatus.fromJson($1),
      },
      userMetadata: switch (json['userMetadata']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    if (googleDriveSource != null)
      'googleDriveSource': googleDriveSource!.toJson(),
    if (directUploadSource != null)
      'directUploadSource': directUploadSource!.toJson(),
    if (slackSource != null) 'slackSource': slackSource!.toJson(),
    if (jiraSource != null) 'jiraSource': jiraSource!.toJson(),
    if (sharePointSources != null)
      'sharePointSources': sharePointSources!.toJson(),
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (sizeBytes.isNotDefault) 'sizeBytes': encodeInt64(sizeBytes),
    if (ragFileType.isNotDefault) 'ragFileType': ragFileType.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (fileStatus != null) 'fileStatus': fileStatus!.toJson(),
    if (userMetadata.isNotDefault) 'userMetadata': userMetadata,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
      'sizeBytes=$sizeBytes',
      'ragFileType=$ragFileType',
      'userMetadata=$userMetadata',
    ].join(',');
    return 'RagFile($contents)';
  }
}

/// The type of the RagFile.
final class RagFile_RagFileType extends ProtoEnum {
  /// RagFile type is unspecified.
  static const ragFileTypeUnspecified = RagFile_RagFileType(
    'RAG_FILE_TYPE_UNSPECIFIED',
  );

  /// RagFile type is TXT.
  static const ragFileTypeTxt = RagFile_RagFileType('RAG_FILE_TYPE_TXT');

  /// RagFile type is PDF.
  static const ragFileTypePdf = RagFile_RagFileType('RAG_FILE_TYPE_PDF');

  /// The default value for [RagFile_RagFileType].
  static const $default = ragFileTypeUnspecified;

  const RagFile_RagFileType(super.value);

  factory RagFile_RagFileType.fromJson(Object? json) =>
      RagFile_RagFileType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'RagFileType.$value';
}

/// A RagChunk includes the content of a chunk of a RagFile, and associated
/// metadata.
final class RagChunk extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagChunk';

  /// The content of the chunk.
  final String text;

  /// If populated, represents where the chunk starts and ends in the document.
  final RagChunk_PageSpan? pageSpan;

  RagChunk({this.text = '', this.pageSpan}) : super(fullyQualifiedName);

  factory RagChunk.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagChunk(
      text: switch (json['text']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSpan: switch (json['pageSpan']) {
        null => null,
        Object $1 => RagChunk_PageSpan.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (text.isNotDefault) 'text': text,
    if (pageSpan != null) 'pageSpan': pageSpan!.toJson(),
  };

  @override
  String toString() {
    final contents = ['text=$text'].join(',');
    return 'RagChunk($contents)';
  }
}

/// Represents where the chunk starts and ends in the document.
final class RagChunk_PageSpan extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagChunk.PageSpan';

  /// Page where chunk starts in the document. Inclusive. 1-indexed.
  final int firstPage;

  /// Page where chunk ends in the document. Inclusive. 1-indexed.
  final int lastPage;

  RagChunk_PageSpan({this.firstPage = 0, this.lastPage = 0})
    : super(fullyQualifiedName);

  factory RagChunk_PageSpan.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagChunk_PageSpan(
      firstPage: switch (json['firstPage']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      lastPage: switch (json['lastPage']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (firstPage.isNotDefault) 'firstPage': firstPage,
    if (lastPage.isNotDefault) 'lastPage': lastPage,
  };

  @override
  String toString() {
    final contents = ['firstPage=$firstPage', 'lastPage=$lastPage'].join(',');
    return 'PageSpan($contents)';
  }
}

/// Specifies the size and overlap of chunks for RagFiles.
final class RagFileChunkingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileChunkingConfig';

  /// Specifies the fixed length chunking config.
  final RagFileChunkingConfig_FixedLengthChunking? fixedLengthChunking;

  /// The size of the chunks.
  final int chunkSize;

  /// The overlap between chunks.
  final int chunkOverlap;

  RagFileChunkingConfig({
    this.fixedLengthChunking,
    this.chunkSize = 0,
    this.chunkOverlap = 0,
  }) : super(fullyQualifiedName);

  factory RagFileChunkingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFileChunkingConfig(
      fixedLengthChunking: switch (json['fixedLengthChunking']) {
        null => null,
        Object $1 => RagFileChunkingConfig_FixedLengthChunking.fromJson($1),
      },
      chunkSize: switch (json['chunkSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      chunkOverlap: switch (json['chunkOverlap']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (fixedLengthChunking != null)
      'fixedLengthChunking': fixedLengthChunking!.toJson(),
    if (chunkSize.isNotDefault) 'chunkSize': chunkSize,
    if (chunkOverlap.isNotDefault) 'chunkOverlap': chunkOverlap,
  };

  @override
  String toString() {
    final contents = [
      'chunkSize=$chunkSize',
      'chunkOverlap=$chunkOverlap',
    ].join(',');
    return 'RagFileChunkingConfig($contents)';
  }
}

/// Specifies the fixed length chunking config.
final class RagFileChunkingConfig_FixedLengthChunking extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileChunkingConfig.FixedLengthChunking';

  /// The size of the chunks.
  final int chunkSize;

  /// The overlap between chunks.
  final int chunkOverlap;

  RagFileChunkingConfig_FixedLengthChunking({
    this.chunkSize = 0,
    this.chunkOverlap = 0,
  }) : super(fullyQualifiedName);

  factory RagFileChunkingConfig_FixedLengthChunking.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFileChunkingConfig_FixedLengthChunking(
      chunkSize: switch (json['chunkSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      chunkOverlap: switch (json['chunkOverlap']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (chunkSize.isNotDefault) 'chunkSize': chunkSize,
    if (chunkOverlap.isNotDefault) 'chunkOverlap': chunkOverlap,
  };

  @override
  String toString() {
    final contents = [
      'chunkSize=$chunkSize',
      'chunkOverlap=$chunkOverlap',
    ].join(',');
    return 'FixedLengthChunking($contents)';
  }
}

/// Specifies the transformation config for RagFiles.
final class RagFileTransformationConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileTransformationConfig';

  /// Specifies the chunking config for RagFiles.
  final RagFileChunkingConfig? ragFileChunkingConfig;

  RagFileTransformationConfig({this.ragFileChunkingConfig})
    : super(fullyQualifiedName);

  factory RagFileTransformationConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFileTransformationConfig(
      ragFileChunkingConfig: switch (json['ragFileChunkingConfig']) {
        null => null,
        Object $1 => RagFileChunkingConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragFileChunkingConfig != null)
      'ragFileChunkingConfig': ragFileChunkingConfig!.toJson(),
  };

  @override
  String toString() => 'RagFileTransformationConfig()';
}

/// Specifies the parsing config for RagFiles.
final class RagFileParsingConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileParsingConfig';

  /// The Advanced Parser to use for RagFiles.
  final RagFileParsingConfig_AdvancedParser? advancedParser;

  /// The Layout Parser to use for RagFiles.
  final RagFileParsingConfig_LayoutParser? layoutParser;

  /// The LLM Parser to use for RagFiles.
  final RagFileParsingConfig_LlmParser? llmParser;

  /// Whether to use advanced PDF parsing.
  final bool useAdvancedPdfParsing;

  RagFileParsingConfig({
    this.advancedParser,
    this.layoutParser,
    this.llmParser,
    this.useAdvancedPdfParsing = false,
  }) : super(fullyQualifiedName);

  factory RagFileParsingConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFileParsingConfig(
      advancedParser: switch (json['advancedParser']) {
        null => null,
        Object $1 => RagFileParsingConfig_AdvancedParser.fromJson($1),
      },
      layoutParser: switch (json['layoutParser']) {
        null => null,
        Object $1 => RagFileParsingConfig_LayoutParser.fromJson($1),
      },
      llmParser: switch (json['llmParser']) {
        null => null,
        Object $1 => RagFileParsingConfig_LlmParser.fromJson($1),
      },
      useAdvancedPdfParsing: switch (json['useAdvancedPdfParsing']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (advancedParser != null) 'advancedParser': advancedParser!.toJson(),
    if (layoutParser != null) 'layoutParser': layoutParser!.toJson(),
    if (llmParser != null) 'llmParser': llmParser!.toJson(),
    if (useAdvancedPdfParsing.isNotDefault)
      'useAdvancedPdfParsing': useAdvancedPdfParsing,
  };

  @override
  String toString() {
    final contents = ['useAdvancedPdfParsing=$useAdvancedPdfParsing'].join(',');
    return 'RagFileParsingConfig($contents)';
  }
}

/// Specifies the advanced parsing for RagFiles.
final class RagFileParsingConfig_AdvancedParser extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileParsingConfig.AdvancedParser';

  /// Whether to use advanced PDF parsing.
  final bool useAdvancedPdfParsing;

  RagFileParsingConfig_AdvancedParser({this.useAdvancedPdfParsing = false})
    : super(fullyQualifiedName);

  factory RagFileParsingConfig_AdvancedParser.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFileParsingConfig_AdvancedParser(
      useAdvancedPdfParsing: switch (json['useAdvancedPdfParsing']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (useAdvancedPdfParsing.isNotDefault)
      'useAdvancedPdfParsing': useAdvancedPdfParsing,
  };

  @override
  String toString() {
    final contents = ['useAdvancedPdfParsing=$useAdvancedPdfParsing'].join(',');
    return 'AdvancedParser($contents)';
  }
}

/// Document AI Layout Parser config.
final class RagFileParsingConfig_LayoutParser extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileParsingConfig.LayoutParser';

  /// The full resource name of a Document AI processor or processor version.
  /// The processor must have type `LAYOUT_PARSER_PROCESSOR`. If specified, the
  /// `additional_config.parse_as_scanned_pdf` field must be false.
  /// Format:
  /// * `projects/{project_id}/locations/{location}/processors/{processor_id}`
  /// * `projects/{project_id}/locations/{location}/processors/{processor_id}/processorVersions/{processor_version_id}`
  final String processorName;

  /// The maximum number of requests the job is allowed to make to the Document
  /// AI processor per minute. Consult
  /// https://cloud.google.com/document-ai/quotas and the Quota page for your
  /// project to set an appropriate value here. If unspecified, a default value
  /// of 120 QPM would be used.
  final int maxParsingRequestsPerMin;

  /// The maximum number of requests the job is allowed to make to the Document
  /// AI processor per minute in this project. Consult
  /// https://cloud.google.com/document-ai/quotas and the Quota page for your
  /// project to set an appropriate value here.
  /// If this value is not specified,
  /// max_parsing_requests_per_min will be used by indexing
  /// pipeline as the global limit.
  final int globalMaxParsingRequestsPerMin;

  RagFileParsingConfig_LayoutParser({
    this.processorName = '',
    this.maxParsingRequestsPerMin = 0,
    this.globalMaxParsingRequestsPerMin = 0,
  }) : super(fullyQualifiedName);

  factory RagFileParsingConfig_LayoutParser.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFileParsingConfig_LayoutParser(
      processorName: switch (json['processorName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      maxParsingRequestsPerMin: switch (json['maxParsingRequestsPerMin']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      globalMaxParsingRequestsPerMin:
          switch (json['globalMaxParsingRequestsPerMin']) {
            null => 0,
            Object $1 => decodeInt($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (processorName.isNotDefault) 'processorName': processorName,
    if (maxParsingRequestsPerMin.isNotDefault)
      'maxParsingRequestsPerMin': maxParsingRequestsPerMin,
    if (globalMaxParsingRequestsPerMin.isNotDefault)
      'globalMaxParsingRequestsPerMin': globalMaxParsingRequestsPerMin,
  };

  @override
  String toString() {
    final contents = [
      'processorName=$processorName',
      'maxParsingRequestsPerMin=$maxParsingRequestsPerMin',
      'globalMaxParsingRequestsPerMin=$globalMaxParsingRequestsPerMin',
    ].join(',');
    return 'LayoutParser($contents)';
  }
}

/// Specifies the LLM parsing for RagFiles.
final class RagFileParsingConfig_LlmParser extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileParsingConfig.LlmParser';

  /// The name of a LLM model used for parsing.
  /// Format:
  /// * `projects/{project_id}/locations/{location}/publishers/{publisher}/models/{model}`
  final String modelName;

  /// The maximum number of requests the job is allowed to make to the
  /// LLM model per minute. Consult
  /// https://cloud.google.com/vertex-ai/generative-ai/docs/quotas
  /// and your document size to set an appropriate value here. If unspecified,
  /// a default value of 5000 QPM would be used.
  final int maxParsingRequestsPerMin;

  /// The maximum number of requests the job is allowed to make to the
  /// LLM model per minute in this project. Consult
  /// https://cloud.google.com/vertex-ai/generative-ai/docs/quotas
  /// and your document size to set an appropriate value here.
  /// If this value is not specified,
  /// max_parsing_requests_per_min will be used by indexing pipeline job as the
  /// global limit.
  final int globalMaxParsingRequestsPerMin;

  /// The prompt to use for parsing. If not specified, a default prompt will
  /// be used.
  final String customParsingPrompt;

  RagFileParsingConfig_LlmParser({
    this.modelName = '',
    this.maxParsingRequestsPerMin = 0,
    this.globalMaxParsingRequestsPerMin = 0,
    this.customParsingPrompt = '',
  }) : super(fullyQualifiedName);

  factory RagFileParsingConfig_LlmParser.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFileParsingConfig_LlmParser(
      modelName: switch (json['modelName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      maxParsingRequestsPerMin: switch (json['maxParsingRequestsPerMin']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      globalMaxParsingRequestsPerMin:
          switch (json['globalMaxParsingRequestsPerMin']) {
            null => 0,
            Object $1 => decodeInt($1),
          },
      customParsingPrompt: switch (json['customParsingPrompt']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (modelName.isNotDefault) 'modelName': modelName,
    if (maxParsingRequestsPerMin.isNotDefault)
      'maxParsingRequestsPerMin': maxParsingRequestsPerMin,
    if (globalMaxParsingRequestsPerMin.isNotDefault)
      'globalMaxParsingRequestsPerMin': globalMaxParsingRequestsPerMin,
    if (customParsingPrompt.isNotDefault)
      'customParsingPrompt': customParsingPrompt,
  };

  @override
  String toString() {
    final contents = [
      'modelName=$modelName',
      'maxParsingRequestsPerMin=$maxParsingRequestsPerMin',
      'globalMaxParsingRequestsPerMin=$globalMaxParsingRequestsPerMin',
      'customParsingPrompt=$customParsingPrompt',
    ].join(',');
    return 'LlmParser($contents)';
  }
}

/// Metadata config for RagFile.
final class RagFileMetadataConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileMetadataConfig';

  /// Google Cloud Storage location. Supports importing individual files as
  /// well as entire Google Cloud Storage directories. Sample formats:
  /// - `gs://bucket_name/my_directory/object_name/metadata_schema.json`
  /// - `gs://bucket_name/my_directory`
  /// If providing a directory, the metadata schema will be read from
  /// the files that ends with "metadata_schema.json" in the directory.
  final GcsSource? gcsMetadataSchemaSource;

  /// Google Drive location. Supports importing individual files as
  /// well as Google Drive folders.
  /// If providing a folder, the metadata schema will be read from
  /// the files that ends with "metadata_schema.json" in the directory.
  final GoogleDriveSource? googleDriveMetadataSchemaSource;

  /// Inline metadata schema source. Must be a JSON string.
  final String? inlineMetadataSchemaSource;

  /// Google Cloud Storage location. Supports importing individual files as
  /// well as entire Google Cloud Storage directories. Sample formats:
  /// - `gs://bucket_name/my_directory/object_name/metadata.json`
  /// - `gs://bucket_name/my_directory`
  /// If providing a directory, the metadata will be read from
  /// the files that ends with "metadata.json" in the directory.
  final GcsSource? gcsMetadataSource;

  /// Google Drive location. Supports importing individual files as
  /// well as Google Drive folders.
  /// If providing a directory, the metadata will be read from
  /// the files that ends with "metadata.json" in the directory.
  final GoogleDriveSource? googleDriveMetadataSource;

  /// Inline metadata source. Must be a JSON string.
  final String? inlineMetadataSource;

  RagFileMetadataConfig({
    this.gcsMetadataSchemaSource,
    this.googleDriveMetadataSchemaSource,
    this.inlineMetadataSchemaSource,
    this.gcsMetadataSource,
    this.googleDriveMetadataSource,
    this.inlineMetadataSource,
  }) : super(fullyQualifiedName);

  factory RagFileMetadataConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagFileMetadataConfig(
      gcsMetadataSchemaSource: switch (json['gcsMetadataSchemaSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      googleDriveMetadataSchemaSource:
          switch (json['googleDriveMetadataSchemaSource']) {
            null => null,
            Object $1 => GoogleDriveSource.fromJson($1),
          },
      inlineMetadataSchemaSource: switch (json['inlineMetadataSchemaSource']) {
        null => null,
        Object $1 => decodeString($1),
      },
      gcsMetadataSource: switch (json['gcsMetadataSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      googleDriveMetadataSource: switch (json['googleDriveMetadataSource']) {
        null => null,
        Object $1 => GoogleDriveSource.fromJson($1),
      },
      inlineMetadataSource: switch (json['inlineMetadataSource']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsMetadataSchemaSource != null)
      'gcsMetadataSchemaSource': gcsMetadataSchemaSource!.toJson(),
    if (googleDriveMetadataSchemaSource != null)
      'googleDriveMetadataSchemaSource': googleDriveMetadataSchemaSource!
          .toJson(),
    if (inlineMetadataSchemaSource != null)
      'inlineMetadataSchemaSource': inlineMetadataSchemaSource,
    if (gcsMetadataSource != null)
      'gcsMetadataSource': gcsMetadataSource!.toJson(),
    if (googleDriveMetadataSource != null)
      'googleDriveMetadataSource': googleDriveMetadataSource!.toJson(),
    if (inlineMetadataSource != null)
      'inlineMetadataSource': inlineMetadataSource,
  };

  @override
  String toString() {
    final contents = [
      if (inlineMetadataSchemaSource != null)
        'inlineMetadataSchemaSource=$inlineMetadataSchemaSource',
      if (inlineMetadataSource != null)
        'inlineMetadataSource=$inlineMetadataSource',
    ].join(',');
    return 'RagFileMetadataConfig($contents)';
  }
}

/// Config for uploading RagFile.
final class UploadRagFileConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadRagFileConfig';

  /// Specifies the size and overlap of chunks after uploading RagFile.
  final RagFileChunkingConfig? ragFileChunkingConfig;

  /// Specifies the transformation config for RagFiles.
  final RagFileTransformationConfig? ragFileTransformationConfig;

  /// Specifies the metadata config for RagFiles.
  /// Including paths for metadata schema and metadata.
  /// Alteratively, inline metadata schema and metadata can be provided.
  final RagFileMetadataConfig? ragFileMetadataConfig;

  /// Optional. Specifies the parsing config for RagFiles.
  /// RAG will use the default parser if this field is not set.
  final RagFileParsingConfig? ragFileParsingConfig;

  UploadRagFileConfig({
    this.ragFileChunkingConfig,
    this.ragFileTransformationConfig,
    this.ragFileMetadataConfig,
    this.ragFileParsingConfig,
  }) : super(fullyQualifiedName);

  factory UploadRagFileConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UploadRagFileConfig(
      ragFileChunkingConfig: switch (json['ragFileChunkingConfig']) {
        null => null,
        Object $1 => RagFileChunkingConfig.fromJson($1),
      },
      ragFileTransformationConfig:
          switch (json['ragFileTransformationConfig']) {
            null => null,
            Object $1 => RagFileTransformationConfig.fromJson($1),
          },
      ragFileMetadataConfig: switch (json['ragFileMetadataConfig']) {
        null => null,
        Object $1 => RagFileMetadataConfig.fromJson($1),
      },
      ragFileParsingConfig: switch (json['ragFileParsingConfig']) {
        null => null,
        Object $1 => RagFileParsingConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragFileChunkingConfig != null)
      'ragFileChunkingConfig': ragFileChunkingConfig!.toJson(),
    if (ragFileTransformationConfig != null)
      'ragFileTransformationConfig': ragFileTransformationConfig!.toJson(),
    if (ragFileMetadataConfig != null)
      'ragFileMetadataConfig': ragFileMetadataConfig!.toJson(),
    if (ragFileParsingConfig != null)
      'ragFileParsingConfig': ragFileParsingConfig!.toJson(),
  };

  @override
  String toString() => 'UploadRagFileConfig()';
}

/// Config for importing RagFiles.
final class ImportRagFilesConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportRagFilesConfig';

  /// Google Cloud Storage location. Supports importing individual files as
  /// well as entire Google Cloud Storage directories. Sample formats:
  /// - `gs://bucket_name/my_directory/object_name/my_file.txt`
  /// - `gs://bucket_name/my_directory`
  final GcsSource? gcsSource;

  /// Google Drive location. Supports importing individual files as
  /// well as Google Drive folders.
  final GoogleDriveSource? googleDriveSource;

  /// Slack channels with their corresponding access tokens.
  final SlackSource? slackSource;

  /// Jira queries with their corresponding authentication.
  final JiraSource? jiraSource;

  /// SharePoint sources.
  final SharePointSources? sharePointSources;

  /// The Cloud Storage path to write partial failures to.
  /// Deprecated. Prefer to use `import_result_gcs_sink`.
  final GcsDestination? partialFailureGcsSink;

  /// The BigQuery destination to write partial failures to. It should be a
  /// bigquery table resource name (e.g.
  /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
  /// table does not exist, it will be created with the expected schema. If the
  /// table exists, the schema will be validated and data will be added to this
  /// existing table.
  /// Deprecated. Prefer to use `import_result_bq_sink`.
  final BigQueryDestination? partialFailureBigquerySink;

  /// The Cloud Storage path to write import result to.
  final GcsDestination? importResultGcsSink;

  /// The BigQuery destination to write import result to. It should be a
  /// bigquery table resource name (e.g.
  /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
  /// table does not exist, it will be created with the expected schema. If the
  /// table exists, the schema will be validated and data will be added to this
  /// existing table.
  final BigQueryDestination? importResultBigquerySink;

  /// Specifies the size and overlap of chunks after importing RagFiles.
  final RagFileChunkingConfig? ragFileChunkingConfig;

  /// Specifies the transformation config for RagFiles.
  final RagFileTransformationConfig? ragFileTransformationConfig;

  /// Optional. Specifies the parsing config for RagFiles.
  /// RAG will use the default parser if this field is not set.
  final RagFileParsingConfig? ragFileParsingConfig;

  /// Specifies the metadata config for RagFiles.
  /// Including paths for metadata schema and metadata.
  final RagFileMetadataConfig? ragFileMetadataConfig;

  /// Optional. The max number of queries per minute that this job is allowed to
  /// make to the embedding model specified on the corpus. This value is specific
  /// to this job and not shared across other import jobs. Consult the Quotas
  /// page on the project to set an appropriate value here.
  /// If unspecified, a default value of 1,000 QPM would be used.
  final int maxEmbeddingRequestsPerMin;

  /// Optional. The max number of queries per minute that the indexing pipeline
  /// job is allowed to make to the embedding model specified in the project.
  /// Please follow the quota usage guideline of the embedding model you use to
  /// set the value properly.If this value is not specified,
  /// max_embedding_requests_per_min will be used by indexing pipeline job as the
  /// global limit.
  final int globalMaxEmbeddingRequestsPerMin;

  /// Rebuilds the ANN index to optimize for recall on the imported data.
  /// Only applicable for RagCorpora running on RagManagedDb with
  /// `retrieval_strategy` set to `ANN`. The rebuild will be performed using the
  /// existing ANN config set on the RagCorpus. To change the ANN config, please
  /// use the UpdateRagCorpus API.
  ///
  /// Default is false, i.e., index is not rebuilt.
  final bool rebuildAnnIndex;

  ImportRagFilesConfig({
    this.gcsSource,
    this.googleDriveSource,
    this.slackSource,
    this.jiraSource,
    this.sharePointSources,
    this.partialFailureGcsSink,
    this.partialFailureBigquerySink,
    this.importResultGcsSink,
    this.importResultBigquerySink,
    this.ragFileChunkingConfig,
    this.ragFileTransformationConfig,
    this.ragFileParsingConfig,
    this.ragFileMetadataConfig,
    this.maxEmbeddingRequestsPerMin = 0,
    this.globalMaxEmbeddingRequestsPerMin = 0,
    this.rebuildAnnIndex = false,
  }) : super(fullyQualifiedName);

  factory ImportRagFilesConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportRagFilesConfig(
      gcsSource: switch (json['gcsSource']) {
        null => null,
        Object $1 => GcsSource.fromJson($1),
      },
      googleDriveSource: switch (json['googleDriveSource']) {
        null => null,
        Object $1 => GoogleDriveSource.fromJson($1),
      },
      slackSource: switch (json['slackSource']) {
        null => null,
        Object $1 => SlackSource.fromJson($1),
      },
      jiraSource: switch (json['jiraSource']) {
        null => null,
        Object $1 => JiraSource.fromJson($1),
      },
      sharePointSources: switch (json['sharePointSources']) {
        null => null,
        Object $1 => SharePointSources.fromJson($1),
      },
      partialFailureGcsSink: switch (json['partialFailureGcsSink']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      partialFailureBigquerySink: switch (json['partialFailureBigquerySink']) {
        null => null,
        Object $1 => BigQueryDestination.fromJson($1),
      },
      importResultGcsSink: switch (json['importResultGcsSink']) {
        null => null,
        Object $1 => GcsDestination.fromJson($1),
      },
      importResultBigquerySink: switch (json['importResultBigquerySink']) {
        null => null,
        Object $1 => BigQueryDestination.fromJson($1),
      },
      ragFileChunkingConfig: switch (json['ragFileChunkingConfig']) {
        null => null,
        Object $1 => RagFileChunkingConfig.fromJson($1),
      },
      ragFileTransformationConfig:
          switch (json['ragFileTransformationConfig']) {
            null => null,
            Object $1 => RagFileTransformationConfig.fromJson($1),
          },
      ragFileParsingConfig: switch (json['ragFileParsingConfig']) {
        null => null,
        Object $1 => RagFileParsingConfig.fromJson($1),
      },
      ragFileMetadataConfig: switch (json['ragFileMetadataConfig']) {
        null => null,
        Object $1 => RagFileMetadataConfig.fromJson($1),
      },
      maxEmbeddingRequestsPerMin: switch (json['maxEmbeddingRequestsPerMin']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      globalMaxEmbeddingRequestsPerMin:
          switch (json['globalMaxEmbeddingRequestsPerMin']) {
            null => 0,
            Object $1 => decodeInt($1),
          },
      rebuildAnnIndex: switch (json['rebuildAnnIndex']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    if (googleDriveSource != null)
      'googleDriveSource': googleDriveSource!.toJson(),
    if (slackSource != null) 'slackSource': slackSource!.toJson(),
    if (jiraSource != null) 'jiraSource': jiraSource!.toJson(),
    if (sharePointSources != null)
      'sharePointSources': sharePointSources!.toJson(),
    if (partialFailureGcsSink != null)
      'partialFailureGcsSink': partialFailureGcsSink!.toJson(),
    if (partialFailureBigquerySink != null)
      'partialFailureBigquerySink': partialFailureBigquerySink!.toJson(),
    if (importResultGcsSink != null)
      'importResultGcsSink': importResultGcsSink!.toJson(),
    if (importResultBigquerySink != null)
      'importResultBigquerySink': importResultBigquerySink!.toJson(),
    if (ragFileChunkingConfig != null)
      'ragFileChunkingConfig': ragFileChunkingConfig!.toJson(),
    if (ragFileTransformationConfig != null)
      'ragFileTransformationConfig': ragFileTransformationConfig!.toJson(),
    if (ragFileParsingConfig != null)
      'ragFileParsingConfig': ragFileParsingConfig!.toJson(),
    if (ragFileMetadataConfig != null)
      'ragFileMetadataConfig': ragFileMetadataConfig!.toJson(),
    if (maxEmbeddingRequestsPerMin.isNotDefault)
      'maxEmbeddingRequestsPerMin': maxEmbeddingRequestsPerMin,
    if (globalMaxEmbeddingRequestsPerMin.isNotDefault)
      'globalMaxEmbeddingRequestsPerMin': globalMaxEmbeddingRequestsPerMin,
    if (rebuildAnnIndex.isNotDefault) 'rebuildAnnIndex': rebuildAnnIndex,
  };

  @override
  String toString() {
    final contents = [
      'maxEmbeddingRequestsPerMin=$maxEmbeddingRequestsPerMin',
      'globalMaxEmbeddingRequestsPerMin=$globalMaxEmbeddingRequestsPerMin',
      'rebuildAnnIndex=$rebuildAnnIndex',
    ].join(',');
    return 'ImportRagFilesConfig($contents)';
  }
}

/// Configuration message for RagManagedDb used by RagEngine.
final class RagManagedDbConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig';

  /// Deprecated: Please use `Scaled` tier instead.
  /// Sets the RagManagedDb to the Enterprise tier. This is the default tier
  /// if not explicitly chosen.
  final RagManagedDbConfig_Enterprise? enterprise;

  /// Sets the RagManagedDb to the Scaled tier.
  final RagManagedDbConfig_Scaled? scaled;

  /// Sets the RagManagedDb to the Basic tier.
  final RagManagedDbConfig_Basic? basic;

  /// Sets the RagManagedDb to the Unprovisioned tier.
  final RagManagedDbConfig_Unprovisioned? unprovisioned;

  RagManagedDbConfig({
    this.enterprise,
    this.scaled,
    this.basic,
    this.unprovisioned,
  }) : super(fullyQualifiedName);

  factory RagManagedDbConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagManagedDbConfig(
      enterprise: switch (json['enterprise']) {
        null => null,
        Object $1 => RagManagedDbConfig_Enterprise.fromJson($1),
      },
      scaled: switch (json['scaled']) {
        null => null,
        Object $1 => RagManagedDbConfig_Scaled.fromJson($1),
      },
      basic: switch (json['basic']) {
        null => null,
        Object $1 => RagManagedDbConfig_Basic.fromJson($1),
      },
      unprovisioned: switch (json['unprovisioned']) {
        null => null,
        Object $1 => RagManagedDbConfig_Unprovisioned.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (enterprise != null) 'enterprise': enterprise!.toJson(),
    if (scaled != null) 'scaled': scaled!.toJson(),
    if (basic != null) 'basic': basic!.toJson(),
    if (unprovisioned != null) 'unprovisioned': unprovisioned!.toJson(),
  };

  @override
  String toString() => 'RagManagedDbConfig()';
}

/// Deprecated: Please use `Scaled` tier instead.
/// Enterprise tier offers production grade performance along with
/// autoscaling functionality. It is suitable for customers with large
/// amounts of data or performance sensitive workloads.
final class RagManagedDbConfig_Enterprise extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig.Enterprise';

  RagManagedDbConfig_Enterprise() : super(fullyQualifiedName);

  factory RagManagedDbConfig_Enterprise.fromJson(Object? j) =>
      RagManagedDbConfig_Enterprise();

  @override
  Object toJson() => {};

  @override
  String toString() => 'Enterprise()';
}

/// Scaled tier offers production grade performance along with
/// autoscaling functionality. It is suitable for customers with large
/// amounts of data or performance sensitive workloads.
final class RagManagedDbConfig_Scaled extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig.Scaled';

  RagManagedDbConfig_Scaled() : super(fullyQualifiedName);

  factory RagManagedDbConfig_Scaled.fromJson(Object? j) =>
      RagManagedDbConfig_Scaled();

  @override
  Object toJson() => {};

  @override
  String toString() => 'Scaled()';
}

/// Basic tier is a cost-effective and low compute tier suitable for
/// the following cases:
/// * Experimenting with RagManagedDb.
/// * Small data size.
/// * Latency insensitive workload.
/// * Only using RAG Engine with external vector DBs.
///
/// NOTE: This is the default tier if not explicitly chosen.
final class RagManagedDbConfig_Basic extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig.Basic';

  RagManagedDbConfig_Basic() : super(fullyQualifiedName);

  factory RagManagedDbConfig_Basic.fromJson(Object? j) =>
      RagManagedDbConfig_Basic();

  @override
  Object toJson() => {};

  @override
  String toString() => 'Basic()';
}

/// Disables the RAG Engine service and deletes all your data held
/// within this service. This will halt the billing of the service.
///
/// NOTE: Once deleted the data cannot be recovered. To start using
/// RAG Engine again, you will need to update the tier by calling the
/// UpdateRagEngineConfig API.
final class RagManagedDbConfig_Unprovisioned extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig.Unprovisioned';

  RagManagedDbConfig_Unprovisioned() : super(fullyQualifiedName);

  factory RagManagedDbConfig_Unprovisioned.fromJson(Object? j) =>
      RagManagedDbConfig_Unprovisioned();

  @override
  Object toJson() => {};

  @override
  String toString() => 'Unprovisioned()';
}

/// Config for RagEngine.
final class RagEngineConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEngineConfig';

  /// Identifier. The name of the RagEngineConfig.
  /// Format:
  /// `projects/{project}/locations/{location}/ragEngineConfig`
  final String name;

  /// The config of the RagManagedDb used by RagEngine.
  final RagManagedDbConfig? ragManagedDbConfig;

  RagEngineConfig({this.name = '', this.ragManagedDbConfig})
    : super(fullyQualifiedName);

  factory RagEngineConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagEngineConfig(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ragManagedDbConfig: switch (json['ragManagedDbConfig']) {
        null => null,
        Object $1 => RagManagedDbConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (ragManagedDbConfig != null)
      'ragManagedDbConfig': ragManagedDbConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'RagEngineConfig($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.CreateRagCorpus`.
final class CreateRagCorpusRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateRagCorpusRequest';

  /// Required. The resource name of the Location to create the RagCorpus in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The RagCorpus to create.
  final RagCorpus? ragCorpus;

  CreateRagCorpusRequest({required this.parent, required this.ragCorpus})
    : super(fullyQualifiedName);

  factory CreateRagCorpusRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateRagCorpusRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ragCorpus: switch (json['ragCorpus']) {
        null => null,
        Object $1 => RagCorpus.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (ragCorpus != null) 'ragCorpus': ragCorpus!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateRagCorpusRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.GetRagCorpus`
final class GetRagCorpusRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetRagCorpusRequest';

  /// Required. The name of the RagCorpus resource.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String name;

  GetRagCorpusRequest({required this.name}) : super(fullyQualifiedName);

  factory GetRagCorpusRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetRagCorpusRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetRagCorpusRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.ListRagCorpora`.
final class ListRagCorporaRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListRagCorporaRequest';

  /// Required. The resource name of the Location from which to list the
  /// RagCorpora. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListRagCorporaResponse.next_page_token`
  /// of the previous
  /// `VertexRagDataService.ListRagCorpora`
  /// call.
  final String pageToken;

  ListRagCorporaRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListRagCorporaRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListRagCorporaRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListRagCorporaRequest($contents)';
  }
}

/// Response message for
/// `VertexRagDataService.ListRagCorpora`.
final class ListRagCorporaResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListRagCorporaResponse';

  /// List of RagCorpora in the requested page.
  final List<RagCorpus> ragCorpora;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListRagCorporaRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListRagCorporaResponse({this.ragCorpora = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListRagCorporaResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListRagCorporaResponse(
      ragCorpora: switch (json['ragCorpora']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) RagCorpus.fromJson(i)],
        _ => throw const FormatException('"ragCorpora" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragCorpora.isNotDefault) 'ragCorpora': encodeList(ragCorpora),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListRagCorporaResponse($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.DeleteRagCorpus`.
final class DeleteRagCorpusRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteRagCorpusRequest';

  /// Required. The name of the RagCorpus resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String name;

  /// Optional. If set to true, any RagFiles in this RagCorpus will also be
  /// deleted. Otherwise, the request will only work if the RagCorpus has no
  /// RagFiles.
  final bool force;

  DeleteRagCorpusRequest({required this.name, this.force = false})
    : super(fullyQualifiedName);

  factory DeleteRagCorpusRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteRagCorpusRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      force: switch (json['force']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (force.isNotDefault) 'force': force};

  @override
  String toString() {
    final contents = ['name=$name', 'force=$force'].join(',');
    return 'DeleteRagCorpusRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.UploadRagFile`.
final class UploadRagFileRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadRagFileRequest';

  /// Required. The name of the RagCorpus resource into which to upload the file.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String parent;

  /// Required. The RagFile to upload.
  final RagFile? ragFile;

  /// Required. The config for the RagFiles to be uploaded into the RagCorpus.
  /// `VertexRagDataService.UploadRagFile`.
  final UploadRagFileConfig? uploadRagFileConfig;

  UploadRagFileRequest({
    required this.parent,
    required this.ragFile,
    required this.uploadRagFileConfig,
  }) : super(fullyQualifiedName);

  factory UploadRagFileRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UploadRagFileRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ragFile: switch (json['ragFile']) {
        null => null,
        Object $1 => RagFile.fromJson($1),
      },
      uploadRagFileConfig: switch (json['uploadRagFileConfig']) {
        null => null,
        Object $1 => UploadRagFileConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (ragFile != null) 'ragFile': ragFile!.toJson(),
    if (uploadRagFileConfig != null)
      'uploadRagFileConfig': uploadRagFileConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'UploadRagFileRequest($contents)';
  }
}

/// Response message for
/// `VertexRagDataService.UploadRagFile`.
final class UploadRagFileResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadRagFileResponse';

  /// The RagFile that had been uploaded into the RagCorpus.
  final RagFile? ragFile;

  /// The error that occurred while processing the RagFile.
  final Status? error;

  UploadRagFileResponse({this.ragFile, this.error}) : super(fullyQualifiedName);

  factory UploadRagFileResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UploadRagFileResponse(
      ragFile: switch (json['ragFile']) {
        null => null,
        Object $1 => RagFile.fromJson($1),
      },
      error: switch (json['error']) {
        null => null,
        Object $1 => Status.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragFile != null) 'ragFile': ragFile!.toJson(),
    if (error != null) 'error': error!.toJson(),
  };

  @override
  String toString() => 'UploadRagFileResponse()';
}

/// Request message for
/// `VertexRagDataService.ImportRagFiles`.
final class ImportRagFilesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportRagFilesRequest';

  /// Required. The name of the RagCorpus resource into which to import files.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String parent;

  /// Required. The config for the RagFiles to be synced and imported into the
  /// RagCorpus.
  /// `VertexRagDataService.ImportRagFiles`.
  final ImportRagFilesConfig? importRagFilesConfig;

  ImportRagFilesRequest({
    required this.parent,
    required this.importRagFilesConfig,
  }) : super(fullyQualifiedName);

  factory ImportRagFilesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportRagFilesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      importRagFilesConfig: switch (json['importRagFilesConfig']) {
        null => null,
        Object $1 => ImportRagFilesConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (importRagFilesConfig != null)
      'importRagFilesConfig': importRagFilesConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ImportRagFilesRequest($contents)';
  }
}

/// Response message for
/// `VertexRagDataService.ImportRagFiles`.
final class ImportRagFilesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportRagFilesResponse';

  /// The Google Cloud Storage path into which the partial failures were
  /// written.
  final String? partialFailuresGcsPath;

  /// The BigQuery table into which the partial failures were written.
  final String? partialFailuresBigqueryTable;

  /// The number of RagFiles that had been imported into the RagCorpus.
  final int importedRagFilesCount;

  /// The number of RagFiles that had failed while importing into the RagCorpus.
  final int failedRagFilesCount;

  /// The number of RagFiles that was skipped while importing into the RagCorpus.
  final int skippedRagFilesCount;

  ImportRagFilesResponse({
    this.partialFailuresGcsPath,
    this.partialFailuresBigqueryTable,
    this.importedRagFilesCount = 0,
    this.failedRagFilesCount = 0,
    this.skippedRagFilesCount = 0,
  }) : super(fullyQualifiedName);

  factory ImportRagFilesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportRagFilesResponse(
      partialFailuresGcsPath: switch (json['partialFailuresGcsPath']) {
        null => null,
        Object $1 => decodeString($1),
      },
      partialFailuresBigqueryTable:
          switch (json['partialFailuresBigqueryTable']) {
            null => null,
            Object $1 => decodeString($1),
          },
      importedRagFilesCount: switch (json['importedRagFilesCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      failedRagFilesCount: switch (json['failedRagFilesCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      skippedRagFilesCount: switch (json['skippedRagFilesCount']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (partialFailuresGcsPath != null)
      'partialFailuresGcsPath': partialFailuresGcsPath,
    if (partialFailuresBigqueryTable != null)
      'partialFailuresBigqueryTable': partialFailuresBigqueryTable,
    if (importedRagFilesCount.isNotDefault)
      'importedRagFilesCount': encodeInt64(importedRagFilesCount),
    if (failedRagFilesCount.isNotDefault)
      'failedRagFilesCount': encodeInt64(failedRagFilesCount),
    if (skippedRagFilesCount.isNotDefault)
      'skippedRagFilesCount': encodeInt64(skippedRagFilesCount),
  };

  @override
  String toString() {
    final contents = [
      if (partialFailuresGcsPath != null)
        'partialFailuresGcsPath=$partialFailuresGcsPath',
      if (partialFailuresBigqueryTable != null)
        'partialFailuresBigqueryTable=$partialFailuresBigqueryTable',
      'importedRagFilesCount=$importedRagFilesCount',
      'failedRagFilesCount=$failedRagFilesCount',
      'skippedRagFilesCount=$skippedRagFilesCount',
    ].join(',');
    return 'ImportRagFilesResponse($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.GetRagFile`
final class GetRagFileRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetRagFileRequest';

  /// Required. The name of the RagFile resource.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
  final String name;

  GetRagFileRequest({required this.name}) : super(fullyQualifiedName);

  factory GetRagFileRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetRagFileRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetRagFileRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.ListRagFiles`.
final class ListRagFilesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListRagFilesRequest';

  /// Required. The resource name of the RagCorpus from which to list the
  /// RagFiles. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String parent;

  /// Optional. The standard list page size.
  final int pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListRagFilesResponse.next_page_token`
  /// of the previous
  /// `VertexRagDataService.ListRagFiles`
  /// call.
  final String pageToken;

  ListRagFilesRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
  }) : super(fullyQualifiedName);

  factory ListRagFilesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListRagFilesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListRagFilesRequest($contents)';
  }
}

/// Response message for
/// `VertexRagDataService.ListRagFiles`.
final class ListRagFilesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListRagFilesResponse';

  /// List of RagFiles in the requested page.
  final List<RagFile> ragFiles;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListRagFilesRequest.page_token`
  /// to obtain that page.
  final String nextPageToken;

  ListRagFilesResponse({this.ragFiles = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListRagFilesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListRagFilesResponse(
      ragFiles: switch (json['ragFiles']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) RagFile.fromJson(i)],
        _ => throw const FormatException('"ragFiles" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragFiles.isNotDefault) 'ragFiles': encodeList(ragFiles),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListRagFilesResponse($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.DeleteRagFile`.
final class DeleteRagFileRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteRagFileRequest';

  /// Required. The name of the RagFile resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
  final String name;

  /// Optional. If set to true, any errors generated by external vector database
  /// during the deletion will be ignored. The default value is false.
  final bool forceDelete;

  DeleteRagFileRequest({required this.name, this.forceDelete = false})
    : super(fullyQualifiedName);

  factory DeleteRagFileRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteRagFileRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      forceDelete: switch (json['forceDelete']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (forceDelete.isNotDefault) 'forceDelete': forceDelete,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'forceDelete=$forceDelete'].join(',');
    return 'DeleteRagFileRequest($contents)';
  }
}

/// Runtime operation information for
/// `VertexRagDataService.CreateRagCorpus`.
final class CreateRagCorpusOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateRagCorpusOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateRagCorpusOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateRagCorpusOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateRagCorpusOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'CreateRagCorpusOperationMetadata()';
}

/// Request message for
/// `VertexRagDataService.GetRagEngineConfig`
final class GetRagEngineConfigRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetRagEngineConfigRequest';

  /// Required. The name of the RagEngineConfig resource.
  /// Format:
  /// `projects/{project}/locations/{location}/ragEngineConfig`
  final String name;

  GetRagEngineConfigRequest({required this.name}) : super(fullyQualifiedName);

  factory GetRagEngineConfigRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetRagEngineConfigRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetRagEngineConfigRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.UpdateRagCorpus`.
final class UpdateRagCorpusRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateRagCorpusRequest';

  /// Required. The RagCorpus which replaces the resource on the server.
  final RagCorpus? ragCorpus;

  UpdateRagCorpusRequest({required this.ragCorpus}) : super(fullyQualifiedName);

  factory UpdateRagCorpusRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateRagCorpusRequest(
      ragCorpus: switch (json['ragCorpus']) {
        null => null,
        Object $1 => RagCorpus.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (ragCorpus != null) 'ragCorpus': ragCorpus!.toJson()};

  @override
  String toString() => 'UpdateRagCorpusRequest()';
}

/// Runtime operation information for
/// `VertexRagDataService.UpdateRagCorpus`.
final class UpdateRagCorpusOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateRagCorpusOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateRagCorpusOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateRagCorpusOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateRagCorpusOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateRagCorpusOperationMetadata()';
}

/// Runtime operation information for
/// `VertexRagDataService.ImportRagFiles`.
final class ImportRagFilesOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportRagFilesOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The resource ID of RagCorpus that this operation is executed on.
  final int ragCorpusId;

  /// Output only. The config that was passed in the ImportRagFilesRequest.
  final ImportRagFilesConfig? importRagFilesConfig;

  /// The progress percentage of the operation. Value is in the range [0, 100].
  /// This percentage is calculated as follows:
  ///    progress_percentage = 100 * (successes + failures + skips) / total
  final int progressPercentage;

  ImportRagFilesOperationMetadata({
    this.genericMetadata,
    this.ragCorpusId = 0,
    this.importRagFilesConfig,
    this.progressPercentage = 0,
  }) : super(fullyQualifiedName);

  factory ImportRagFilesOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ImportRagFilesOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      ragCorpusId: switch (json['ragCorpusId']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      importRagFilesConfig: switch (json['importRagFilesConfig']) {
        null => null,
        Object $1 => ImportRagFilesConfig.fromJson($1),
      },
      progressPercentage: switch (json['progressPercentage']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (ragCorpusId.isNotDefault) 'ragCorpusId': encodeInt64(ragCorpusId),
    if (importRagFilesConfig != null)
      'importRagFilesConfig': importRagFilesConfig!.toJson(),
    if (progressPercentage.isNotDefault)
      'progressPercentage': progressPercentage,
  };

  @override
  String toString() {
    final contents = [
      'ragCorpusId=$ragCorpusId',
      'progressPercentage=$progressPercentage',
    ].join(',');
    return 'ImportRagFilesOperationMetadata($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.UpdateRagEngineConfig`.
final class UpdateRagEngineConfigRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateRagEngineConfigRequest';

  /// Required. The updated RagEngineConfig.
  ///
  /// NOTE: Downgrading your RagManagedDb's ComputeTier could temporarily
  /// increase request latencies until the operation is fully complete.
  final RagEngineConfig? ragEngineConfig;

  UpdateRagEngineConfigRequest({required this.ragEngineConfig})
    : super(fullyQualifiedName);

  factory UpdateRagEngineConfigRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateRagEngineConfigRequest(
      ragEngineConfig: switch (json['ragEngineConfig']) {
        null => null,
        Object $1 => RagEngineConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragEngineConfig != null) 'ragEngineConfig': ragEngineConfig!.toJson(),
  };

  @override
  String toString() => 'UpdateRagEngineConfigRequest()';
}

/// Runtime operation information for
/// `VertexRagDataService.UpdateRagEngineConfig`.
final class UpdateRagEngineConfigOperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateRagEngineConfigOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateRagEngineConfigOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateRagEngineConfigOperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateRagEngineConfigOperationMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
  };

  @override
  String toString() => 'UpdateRagEngineConfigOperationMetadata()';
}

/// A query to retrieve relevant contexts.
final class RagQuery extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagQuery';

  /// Optional. The query in text format to get relevant contexts.
  final String? text;

  /// Optional. The number of contexts to retrieve.
  final int similarityTopK;

  /// Optional. Configurations for hybrid search results ranking.
  final RagQuery_Ranking? ranking;

  /// Optional. The retrieval config for the query.
  final RagRetrievalConfig? ragRetrievalConfig;

  RagQuery({
    this.text,
    this.similarityTopK = 0,
    this.ranking,
    this.ragRetrievalConfig,
  }) : super(fullyQualifiedName);

  factory RagQuery.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagQuery(
      text: switch (json['text']) {
        null => null,
        Object $1 => decodeString($1),
      },
      similarityTopK: switch (json['similarityTopK']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      ranking: switch (json['ranking']) {
        null => null,
        Object $1 => RagQuery_Ranking.fromJson($1),
      },
      ragRetrievalConfig: switch (json['ragRetrievalConfig']) {
        null => null,
        Object $1 => RagRetrievalConfig.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (text != null) 'text': text,
    if (similarityTopK.isNotDefault) 'similarityTopK': similarityTopK,
    if (ranking != null) 'ranking': ranking!.toJson(),
    if (ragRetrievalConfig != null)
      'ragRetrievalConfig': ragRetrievalConfig!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (text != null) 'text=$text',
      'similarityTopK=$similarityTopK',
    ].join(',');
    return 'RagQuery($contents)';
  }
}

/// Configurations for hybrid search results ranking.
final class RagQuery_Ranking extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagQuery.Ranking';

  /// Optional. Alpha value controls the weight between dense and sparse vector
  /// search results. The range is [0, 1], while 0 means sparse vector search
  /// only and 1 means dense vector search only. The default value is 0.5 which
  /// balances sparse and dense vector search equally.
  final double? alpha;

  RagQuery_Ranking({this.alpha}) : super(fullyQualifiedName);

  factory RagQuery_Ranking.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagQuery_Ranking(
      alpha: switch (json['alpha']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {if (alpha != null) 'alpha': encodeDouble(alpha)};

  @override
  String toString() {
    final contents = [if (alpha != null) 'alpha=$alpha'].join(',');
    return 'Ranking($contents)';
  }
}

/// Request message for
/// `VertexRagService.RetrieveContexts`.
final class RetrieveContextsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveContextsRequest';

  /// The data source for Vertex RagStore.
  final RetrieveContextsRequest_VertexRagStore? vertexRagStore;

  /// Required. The resource name of the Location from which to retrieve
  /// RagContexts. The users must have permission to make a call in the project.
  /// Format:
  /// `projects/{project}/locations/{location}`.
  final String parent;

  /// Required. Single RAG retrieve query.
  final RagQuery? query;

  RetrieveContextsRequest({
    this.vertexRagStore,
    required this.parent,
    required this.query,
  }) : super(fullyQualifiedName);

  factory RetrieveContextsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrieveContextsRequest(
      vertexRagStore: switch (json['vertexRagStore']) {
        null => null,
        Object $1 => RetrieveContextsRequest_VertexRagStore.fromJson($1),
      },
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      query: switch (json['query']) {
        null => null,
        Object $1 => RagQuery.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!.toJson(),
    'parent': parent,
    if (query != null) 'query': query!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'RetrieveContextsRequest($contents)';
  }
}

/// The data source for Vertex RagStore.
final class RetrieveContextsRequest_VertexRagStore extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveContextsRequest.VertexRagStore';

  /// Optional. Deprecated. Please use rag_resources to specify the data
  /// source.
  final List<String> ragCorpora;

  /// Optional. The representation of the rag source. It can be used to specify
  /// corpus only or ragfiles. Currently only support one corpus or multiple
  /// files from one corpus. In the future we may open up multiple corpora
  /// support.
  final List<RetrieveContextsRequest_VertexRagStore_RagResource> ragResources;

  /// Optional. Only return contexts with vector distance smaller than the
  /// threshold.
  final double? vectorDistanceThreshold;

  RetrieveContextsRequest_VertexRagStore({
    this.ragCorpora = const [],
    this.ragResources = const [],
    this.vectorDistanceThreshold,
  }) : super(fullyQualifiedName);

  factory RetrieveContextsRequest_VertexRagStore.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrieveContextsRequest_VertexRagStore(
      ragCorpora: switch (json['ragCorpora']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"ragCorpora" is not a list'),
      },
      ragResources: switch (json['ragResources']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            RetrieveContextsRequest_VertexRagStore_RagResource.fromJson(i),
        ],
        _ => throw const FormatException('"ragResources" is not a list'),
      },
      vectorDistanceThreshold: switch (json['vectorDistanceThreshold']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragCorpora.isNotDefault) 'ragCorpora': ragCorpora,
    if (ragResources.isNotDefault) 'ragResources': encodeList(ragResources),
    if (vectorDistanceThreshold != null)
      'vectorDistanceThreshold': encodeDouble(vectorDistanceThreshold),
  };

  @override
  String toString() {
    final contents = [
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold=$vectorDistanceThreshold',
    ].join(',');
    return 'VertexRagStore($contents)';
  }
}

/// The definition of the Rag resource.
final class RetrieveContextsRequest_VertexRagStore_RagResource
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveContextsRequest.VertexRagStore.RagResource';

  /// Optional. RagCorpora resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String ragCorpus;

  /// Optional. rag_file_id. The files should be in the same rag_corpus set
  /// in rag_corpus field.
  final List<String> ragFileIds;

  RetrieveContextsRequest_VertexRagStore_RagResource({
    this.ragCorpus = '',
    this.ragFileIds = const [],
  }) : super(fullyQualifiedName);

  factory RetrieveContextsRequest_VertexRagStore_RagResource.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return RetrieveContextsRequest_VertexRagStore_RagResource(
      ragCorpus: switch (json['ragCorpus']) {
        null => '',
        Object $1 => decodeString($1),
      },
      ragFileIds: switch (json['ragFileIds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"ragFileIds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (ragCorpus.isNotDefault) 'ragCorpus': ragCorpus,
    if (ragFileIds.isNotDefault) 'ragFileIds': ragFileIds,
  };

  @override
  String toString() {
    final contents = ['ragCorpus=$ragCorpus'].join(',');
    return 'RagResource($contents)';
  }
}

/// Relevant contexts for one query.
final class RagContexts extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagContexts';

  /// All its contexts.
  final List<RagContexts_Context> contexts;

  RagContexts({this.contexts = const []}) : super(fullyQualifiedName);

  factory RagContexts.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagContexts(
      contexts: switch (json['contexts']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) RagContexts_Context.fromJson(i),
        ],
        _ => throw const FormatException('"contexts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (contexts.isNotDefault) 'contexts': encodeList(contexts),
  };

  @override
  String toString() => 'RagContexts()';
}

/// A context of the query.
final class RagContexts_Context extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagContexts.Context';

  /// If the file is imported from Cloud Storage or Google Drive, source_uri
  /// will be original file URI in Cloud Storage or Google Drive; if file is
  /// uploaded, source_uri will be file display name.
  final String sourceUri;

  /// The file display name.
  final String sourceDisplayName;

  /// The text chunk.
  final String text;

  /// The distance between the query dense embedding vector and the context
  /// text vector.
  final double distance;

  /// The distance between the query sparse embedding vector and the context
  /// text vector.
  final double sparseDistance;

  /// According to the underlying Vector DB and the selected metric type, the
  /// score can be either the distance or the similarity between the query and
  /// the context and its range depends on the metric type.
  ///
  /// For example, if the metric type is COSINE_DISTANCE, it represents the
  /// distance between the query and the context. The larger the distance, the
  /// less relevant the context is to the query. The range is [0, 2], while 0
  /// means the most relevant and 2 means the least relevant.
  final double? score;

  /// Context of the retrieved chunk.
  final RagChunk? chunk;

  RagContexts_Context({
    this.sourceUri = '',
    this.sourceDisplayName = '',
    this.text = '',
    this.distance = 0,
    this.sparseDistance = 0,
    this.score,
    this.chunk,
  }) : super(fullyQualifiedName);

  factory RagContexts_Context.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RagContexts_Context(
      sourceUri: switch (json['sourceUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sourceDisplayName: switch (json['sourceDisplayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      text: switch (json['text']) {
        null => '',
        Object $1 => decodeString($1),
      },
      distance: switch (json['distance']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      sparseDistance: switch (json['sparseDistance']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      chunk: switch (json['chunk']) {
        null => null,
        Object $1 => RagChunk.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sourceUri.isNotDefault) 'sourceUri': sourceUri,
    if (sourceDisplayName.isNotDefault) 'sourceDisplayName': sourceDisplayName,
    if (text.isNotDefault) 'text': text,
    if (distance.isNotDefault) 'distance': encodeDouble(distance),
    if (sparseDistance.isNotDefault)
      'sparseDistance': encodeDouble(sparseDistance),
    if (score != null) 'score': encodeDouble(score),
    if (chunk != null) 'chunk': chunk!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'sourceUri=$sourceUri',
      'sourceDisplayName=$sourceDisplayName',
      'text=$text',
      'distance=$distance',
      'sparseDistance=$sparseDistance',
      if (score != null) 'score=$score',
    ].join(',');
    return 'Context($contents)';
  }
}

/// Response message for
/// `VertexRagService.RetrieveContexts`.
final class RetrieveContextsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveContextsResponse';

  /// The contexts of the query.
  final RagContexts? contexts;

  RetrieveContextsResponse({this.contexts}) : super(fullyQualifiedName);

  factory RetrieveContextsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetrieveContextsResponse(
      contexts: switch (json['contexts']) {
        null => null,
        Object $1 => RagContexts.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (contexts != null) 'contexts': contexts!.toJson()};

  @override
  String toString() => 'RetrieveContextsResponse()';
}

/// Request message for AugmentPrompt.
final class AugmentPromptRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AugmentPromptRequest';

  /// Optional. Retrieves contexts from the Vertex RagStore.
  final VertexRagStore? vertexRagStore;

  /// Required. The resource name of the Location from which to augment prompt.
  /// The users must have permission to make a call in the project.
  /// Format:
  /// `projects/{project}/locations/{location}`.
  final String parent;

  /// Optional. Input content to augment, only text format is supported for now.
  final List<Content> contents;

  /// Optional. Metadata of the backend deployed model.
  final AugmentPromptRequest_Model? model;

  AugmentPromptRequest({
    this.vertexRagStore,
    required this.parent,
    this.contents = const [],
    this.model,
  }) : super(fullyQualifiedName);

  factory AugmentPromptRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AugmentPromptRequest(
      vertexRagStore: switch (json['vertexRagStore']) {
        null => null,
        Object $1 => VertexRagStore.fromJson($1),
      },
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      contents: switch (json['contents']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"contents" is not a list'),
      },
      model: switch (json['model']) {
        null => null,
        Object $1 => AugmentPromptRequest_Model.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!.toJson(),
    'parent': parent,
    if (contents.isNotDefault) 'contents': encodeList(contents),
    if (model != null) 'model': model!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'AugmentPromptRequest($contents)';
  }
}

/// Metadata of the backend deployed model.
final class AugmentPromptRequest_Model extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AugmentPromptRequest.Model';

  /// Optional. The model that the user will send the augmented prompt for
  /// content generation.
  final String model;

  /// Optional. The model version of the backend deployed model.
  final String modelVersion;

  AugmentPromptRequest_Model({this.model = '', this.modelVersion = ''})
    : super(fullyQualifiedName);

  factory AugmentPromptRequest_Model.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AugmentPromptRequest_Model(
      model: switch (json['model']) {
        null => '',
        Object $1 => decodeString($1),
      },
      modelVersion: switch (json['modelVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (model.isNotDefault) 'model': model,
    if (modelVersion.isNotDefault) 'modelVersion': modelVersion,
  };

  @override
  String toString() {
    final contents = ['model=$model', 'modelVersion=$modelVersion'].join(',');
    return 'Model($contents)';
  }
}

/// Response message for AugmentPrompt.
final class AugmentPromptResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AugmentPromptResponse';

  /// Augmented prompt, only text format is supported for now.
  final List<Content> augmentedPrompt;

  /// Retrieved facts from RAG data sources.
  final List<Fact> facts;

  AugmentPromptResponse({
    this.augmentedPrompt = const [],
    this.facts = const [],
  }) : super(fullyQualifiedName);

  factory AugmentPromptResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AugmentPromptResponse(
      augmentedPrompt: switch (json['augmentedPrompt']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Content.fromJson(i)],
        _ => throw const FormatException('"augmentedPrompt" is not a list'),
      },
      facts: switch (json['facts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Fact.fromJson(i)],
        _ => throw const FormatException('"facts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (augmentedPrompt.isNotDefault)
      'augmentedPrompt': encodeList(augmentedPrompt),
    if (facts.isNotDefault) 'facts': encodeList(facts),
  };

  @override
  String toString() => 'AugmentPromptResponse()';
}

/// Request message for CorroborateContent.
final class CorroborateContentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CorroborateContentRequest';

  /// Required. The resource name of the Location from which to corroborate text.
  /// The users must have permission to make a call in the project.
  /// Format:
  /// `projects/{project}/locations/{location}`.
  final String parent;

  /// Optional. Input content to corroborate, only text format is supported for
  /// now.
  final Content? content;

  /// Optional. Facts used to generate the text can also be used to corroborate
  /// the text.
  final List<Fact> facts;

  /// Optional. Parameters that can be set to override default settings per
  /// request.
  final CorroborateContentRequest_Parameters? parameters;

  CorroborateContentRequest({
    required this.parent,
    this.content,
    this.facts = const [],
    this.parameters,
  }) : super(fullyQualifiedName);

  factory CorroborateContentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CorroborateContentRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      content: switch (json['content']) {
        null => null,
        Object $1 => Content.fromJson($1),
      },
      facts: switch (json['facts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Fact.fromJson(i)],
        _ => throw const FormatException('"facts" is not a list'),
      },
      parameters: switch (json['parameters']) {
        null => null,
        Object $1 => CorroborateContentRequest_Parameters.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (content != null) 'content': content!.toJson(),
    if (facts.isNotDefault) 'facts': encodeList(facts),
    if (parameters != null) 'parameters': parameters!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CorroborateContentRequest($contents)';
  }
}

/// Parameters that can be overrided per request.
final class CorroborateContentRequest_Parameters extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CorroborateContentRequest.Parameters';

  /// Optional. Only return claims with citation score larger than the
  /// threshold.
  final double citationThreshold;

  CorroborateContentRequest_Parameters({this.citationThreshold = 0})
    : super(fullyQualifiedName);

  factory CorroborateContentRequest_Parameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CorroborateContentRequest_Parameters(
      citationThreshold: switch (json['citationThreshold']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (citationThreshold.isNotDefault)
      'citationThreshold': encodeDouble(citationThreshold),
  };

  @override
  String toString() {
    final contents = ['citationThreshold=$citationThreshold'].join(',');
    return 'Parameters($contents)';
  }
}

/// Response message for CorroborateContent.
final class CorroborateContentResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CorroborateContentResponse';

  /// Confidence score of corroborating content. Value is [0,1] with 1 is the
  /// most confidence.
  final double? corroborationScore;

  /// Claims that are extracted from the input content and facts that support the
  /// claims.
  final List<Claim> claims;

  CorroborateContentResponse({this.corroborationScore, this.claims = const []})
    : super(fullyQualifiedName);

  factory CorroborateContentResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CorroborateContentResponse(
      corroborationScore: switch (json['corroborationScore']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      claims: switch (json['claims']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Claim.fromJson(i)],
        _ => throw const FormatException('"claims" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (corroborationScore != null)
      'corroborationScore': encodeDouble(corroborationScore),
    if (claims.isNotDefault) 'claims': encodeList(claims),
  };

  @override
  String toString() {
    final contents = [
      if (corroborationScore != null) 'corroborationScore=$corroborationScore',
    ].join(',');
    return 'CorroborateContentResponse($contents)';
  }
}

/// The fact used in grounding.
final class Fact extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Fact';

  /// Query that is used to retrieve this fact.
  final String? query;

  /// If present, it refers to the title of this fact.
  final String? title;

  /// If present, this uri links to the source of the fact.
  final String? uri;

  /// If present, the summary/snippet of the fact.
  final String? summary;

  /// If present, the distance between the query vector and this fact vector.
  final double? vectorDistance;

  /// If present, according to the underlying Vector DB and the selected metric
  /// type, the score can be either the distance or the similarity between the
  /// query and the fact and its range depends on the metric type.
  ///
  /// For example, if the metric type is COSINE_DISTANCE, it represents the
  /// distance between the query and the fact. The larger the distance, the less
  /// relevant the fact is to the query. The range is [0, 2], while 0 means the
  /// most relevant and 2 means the least relevant.
  final double? score;

  /// If present, chunk properties.
  final RagChunk? chunk;

  Fact({
    this.query,
    this.title,
    this.uri,
    this.summary,
    this.vectorDistance,
    this.score,
    this.chunk,
  }) : super(fullyQualifiedName);

  factory Fact.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Fact(
      query: switch (json['query']) {
        null => null,
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => null,
        Object $1 => decodeString($1),
      },
      uri: switch (json['uri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      summary: switch (json['summary']) {
        null => null,
        Object $1 => decodeString($1),
      },
      vectorDistance: switch (json['vectorDistance']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
      chunk: switch (json['chunk']) {
        null => null,
        Object $1 => RagChunk.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (query != null) 'query': query,
    if (title != null) 'title': title,
    if (uri != null) 'uri': uri,
    if (summary != null) 'summary': summary,
    if (vectorDistance != null) 'vectorDistance': encodeDouble(vectorDistance),
    if (score != null) 'score': encodeDouble(score),
    if (chunk != null) 'chunk': chunk!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      if (query != null) 'query=$query',
      if (title != null) 'title=$title',
      if (uri != null) 'uri=$uri',
      if (summary != null) 'summary=$summary',
      if (vectorDistance != null) 'vectorDistance=$vectorDistance',
      if (score != null) 'score=$score',
    ].join(',');
    return 'Fact($contents)';
  }
}

/// Claim that is extracted from the input text and facts that support it.
final class Claim extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Claim';

  /// Index in the input text where the claim starts (inclusive).
  final int? startIndex;

  /// Index in the input text where the claim ends (exclusive).
  final int? endIndex;

  /// Indexes of the facts supporting this claim.
  final List<int> factIndexes;

  /// Confidence score of this corroboration.
  final double? score;

  Claim({
    this.startIndex,
    this.endIndex,
    this.factIndexes = const [],
    this.score,
  }) : super(fullyQualifiedName);

  factory Claim.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Claim(
      startIndex: switch (json['startIndex']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      endIndex: switch (json['endIndex']) {
        null => null,
        Object $1 => decodeInt($1),
      },
      factIndexes: switch (json['factIndexes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt(i)],
        _ => throw const FormatException('"factIndexes" is not a list'),
      },
      score: switch (json['score']) {
        null => null,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (startIndex != null) 'startIndex': startIndex,
    if (endIndex != null) 'endIndex': endIndex,
    if (factIndexes.isNotDefault) 'factIndexes': factIndexes,
    if (score != null) 'score': encodeDouble(score),
  };

  @override
  String toString() {
    final contents = [
      if (startIndex != null) 'startIndex=$startIndex',
      if (endIndex != null) 'endIndex=$endIndex',
      if (score != null) 'score=$score',
    ].join(',');
    return 'Claim($contents)';
  }
}

/// Request message for
/// `VizierService.GetStudy`.
final class GetStudyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetStudyRequest';

  /// Required. The name of the Study resource.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String name;

  GetStudyRequest({required this.name}) : super(fullyQualifiedName);

  factory GetStudyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetStudyRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetStudyRequest($contents)';
  }
}

/// Request message for
/// `VizierService.CreateStudy`.
final class CreateStudyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateStudyRequest';

  /// Required. The resource name of the Location to create the CustomJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Study configuration used to create the Study.
  final Study? study;

  CreateStudyRequest({required this.parent, required this.study})
    : super(fullyQualifiedName);

  factory CreateStudyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateStudyRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      study: switch (json['study']) {
        null => null,
        Object $1 => Study.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (study != null) 'study': study!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateStudyRequest($contents)';
  }
}

/// Request message for
/// `VizierService.ListStudies`.
final class ListStudiesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListStudiesRequest';

  /// Required. The resource name of the Location to list the Study from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  final String pageToken;

  /// Optional. The maximum number of studies to return per "page" of results.
  /// If unspecified, service will pick an appropriate default.
  final int pageSize;

  ListStudiesRequest({
    required this.parent,
    this.pageToken = '',
    this.pageSize = 0,
  }) : super(fullyQualifiedName);

  factory ListStudiesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListStudiesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageToken=$pageToken',
      'pageSize=$pageSize',
    ].join(',');
    return 'ListStudiesRequest($contents)';
  }
}

/// Response message for
/// `VizierService.ListStudies`.
final class ListStudiesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListStudiesResponse';

  /// The studies associated with the project.
  final List<Study> studies;

  /// Passes this token as the `page_token` field of the request for a
  /// subsequent call.
  /// If this field is omitted, there are no subsequent pages.
  final String nextPageToken;

  ListStudiesResponse({this.studies = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListStudiesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListStudiesResponse(
      studies: switch (json['studies']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Study.fromJson(i)],
        _ => throw const FormatException('"studies" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (studies.isNotDefault) 'studies': encodeList(studies),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListStudiesResponse($contents)';
  }
}

/// Request message for
/// `VizierService.DeleteStudy`.
final class DeleteStudyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteStudyRequest';

  /// Required. The name of the Study resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String name;

  DeleteStudyRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteStudyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteStudyRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteStudyRequest($contents)';
  }
}

/// Request message for
/// `VizierService.LookupStudy`.
final class LookupStudyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LookupStudyRequest';

  /// Required. The resource name of the Location to get the Study from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The user-defined display name of the Study
  final String displayName;

  LookupStudyRequest({required this.parent, required this.displayName})
    : super(fullyQualifiedName);

  factory LookupStudyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LookupStudyRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent, 'displayName': displayName};

  @override
  String toString() {
    final contents = ['parent=$parent', 'displayName=$displayName'].join(',');
    return 'LookupStudyRequest($contents)';
  }
}

/// Request message for
/// `VizierService.SuggestTrials`.
final class SuggestTrialsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SuggestTrialsRequest';

  /// Required. The project and location that the Study belongs to.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String parent;

  /// Required. The number of suggestions requested. It must be positive.
  final int suggestionCount;

  /// Required. The identifier of the client that is requesting the suggestion.
  ///
  /// If multiple SuggestTrialsRequests have the same `client_id`,
  /// the service will return the identical suggested Trial if the Trial is
  /// pending, and provide a new Trial if the last suggested Trial was completed.
  final String clientId;

  /// Optional. This allows you to specify the "context" for a Trial; a context
  /// is a slice (a subspace) of the search space.
  ///
  /// Typical uses for contexts:
  /// 1) You are using Vizier to tune a server for best performance, but there's
  ///   a strong weekly cycle.  The context specifies the day-of-week.
  ///   This allows Tuesday to generalize from Wednesday without assuming that
  ///   everything is identical.
  /// 2) Imagine you're optimizing some medical treatment for people.
  ///   As they walk in the door, you know certain facts about them
  ///   (e.g. sex, weight, height, blood-pressure).  Put that information in the
  ///   context, and Vizier will adapt its suggestions to the patient.
  /// 3) You want to do a fair A/B test efficiently.  Specify the "A" and "B"
  ///   conditions as contexts, and Vizier will generalize between "A" and "B"
  ///   conditions.  If they are similar, this will allow Vizier to converge
  ///   to the optimum faster than if "A" and "B" were separate Studies.
  ///   NOTE: You can also enter contexts as REQUESTED Trials, e.g. via the
  ///   CreateTrial() RPC; that's the asynchronous option where you don't need a
  ///   close association between contexts and suggestions.
  ///
  /// NOTE: All the Parameters you set in a context MUST be defined in the
  ///   Study.
  /// NOTE: You must supply 0 or $suggestion_count contexts.
  ///   If you don't supply any contexts, Vizier will make suggestions
  ///   from the full search space specified in the StudySpec; if you supply
  ///   a full set of context, each suggestion will match the corresponding
  ///   context.
  /// NOTE: A Context with no features set matches anything, and allows
  ///   suggestions from the full search space.
  /// NOTE: Contexts MUST lie within the search space specified in the
  ///   StudySpec.  It's an error if they don't.
  /// NOTE: Contexts preferentially match ACTIVE then REQUESTED trials before
  ///   new suggestions are generated.
  /// NOTE: Generation of suggestions involves a match between a Context and
  ///   (optionally) a REQUESTED trial; if that match is not fully specified, a
  ///   suggestion will be geneated in the merged subspace.
  final List<TrialContext> contexts;

  SuggestTrialsRequest({
    required this.parent,
    required this.suggestionCount,
    required this.clientId,
    this.contexts = const [],
  }) : super(fullyQualifiedName);

  factory SuggestTrialsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SuggestTrialsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      suggestionCount: switch (json['suggestionCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      clientId: switch (json['clientId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      contexts: switch (json['contexts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TrialContext.fromJson(i)],
        _ => throw const FormatException('"contexts" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'suggestionCount': suggestionCount,
    'clientId': clientId,
    if (contexts.isNotDefault) 'contexts': encodeList(contexts),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'suggestionCount=$suggestionCount',
      'clientId=$clientId',
    ].join(',');
    return 'SuggestTrialsRequest($contents)';
  }
}

/// Response message for
/// `VizierService.SuggestTrials`.
final class SuggestTrialsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SuggestTrialsResponse';

  /// A list of Trials.
  final List<Trial> trials;

  /// The state of the Study.
  final Study_State studyState;

  /// The time at which the operation was started.
  final protobuf.Timestamp? startTime;

  /// The time at which operation processing completed.
  final protobuf.Timestamp? endTime;

  SuggestTrialsResponse({
    this.trials = const [],
    this.studyState = Study_State.$default,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory SuggestTrialsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SuggestTrialsResponse(
      trials: switch (json['trials']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Trial.fromJson(i)],
        _ => throw const FormatException('"trials" is not a list'),
      },
      studyState: switch (json['studyState']) {
        null => Study_State.$default,
        Object $1 => Study_State.fromJson($1),
      },
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => protobuf.Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trials.isNotDefault) 'trials': encodeList(trials),
    if (studyState.isNotDefault) 'studyState': studyState.toJson(),
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['studyState=$studyState'].join(',');
    return 'SuggestTrialsResponse($contents)';
  }
}

/// Details of operations that perform Trials suggestion.
final class SuggestTrialsMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SuggestTrialsMetadata';

  /// Operation metadata for suggesting Trials.
  final GenericOperationMetadata? genericMetadata;

  /// The identifier of the client that is requesting the suggestion.
  ///
  /// If multiple SuggestTrialsRequests have the same `client_id`,
  /// the service will return the identical suggested Trial if the Trial is
  /// pending, and provide a new Trial if the last suggested Trial was completed.
  final String clientId;

  SuggestTrialsMetadata({this.genericMetadata, this.clientId = ''})
    : super(fullyQualifiedName);

  factory SuggestTrialsMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SuggestTrialsMetadata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      clientId: switch (json['clientId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (clientId.isNotDefault) 'clientId': clientId,
  };

  @override
  String toString() {
    final contents = ['clientId=$clientId'].join(',');
    return 'SuggestTrialsMetadata($contents)';
  }
}

/// Request message for
/// `VizierService.CreateTrial`.
final class CreateTrialRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTrialRequest';

  /// Required. The resource name of the Study to create the Trial in.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String parent;

  /// Required. The Trial to create.
  final Trial? trial;

  CreateTrialRequest({required this.parent, required this.trial})
    : super(fullyQualifiedName);

  factory CreateTrialRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateTrialRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      trial: switch (json['trial']) {
        null => null,
        Object $1 => Trial.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (trial != null) 'trial': trial!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.GetTrial`.
final class GetTrialRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTrialRequest';

  /// Required. The name of the Trial resource.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String name;

  GetTrialRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTrialRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetTrialRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.ListTrials`.
final class ListTrialsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTrialsRequest';

  /// Required. The resource name of the Study to list the Trial from.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String parent;

  /// Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  final String pageToken;

  /// Optional. The number of Trials to retrieve per "page" of results.
  /// If unspecified, the service will pick an appropriate default.
  final int pageSize;

  ListTrialsRequest({
    required this.parent,
    this.pageToken = '',
    this.pageSize = 0,
  }) : super(fullyQualifiedName);

  factory ListTrialsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTrialsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageToken=$pageToken',
      'pageSize=$pageSize',
    ].join(',');
    return 'ListTrialsRequest($contents)';
  }
}

/// Response message for
/// `VizierService.ListTrials`.
final class ListTrialsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTrialsResponse';

  /// The Trials associated with the Study.
  final List<Trial> trials;

  /// Pass this token as the `page_token` field of the request for a
  /// subsequent call.
  /// If this field is omitted, there are no subsequent pages.
  final String nextPageToken;

  ListTrialsResponse({this.trials = const [], this.nextPageToken = ''})
    : super(fullyQualifiedName);

  factory ListTrialsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListTrialsResponse(
      trials: switch (json['trials']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Trial.fromJson(i)],
        _ => throw const FormatException('"trials" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trials.isNotDefault) 'trials': encodeList(trials),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListTrialsResponse($contents)';
  }
}

/// Request message for
/// `VizierService.AddTrialMeasurement`.
final class AddTrialMeasurementRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddTrialMeasurementRequest';

  /// Required. The name of the trial to add measurement.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String trialName;

  /// Required. The measurement to be added to a Trial.
  final Measurement? measurement;

  AddTrialMeasurementRequest({
    required this.trialName,
    required this.measurement,
  }) : super(fullyQualifiedName);

  factory AddTrialMeasurementRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AddTrialMeasurementRequest(
      trialName: switch (json['trialName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      measurement: switch (json['measurement']) {
        null => null,
        Object $1 => Measurement.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'trialName': trialName,
    if (measurement != null) 'measurement': measurement!.toJson(),
  };

  @override
  String toString() {
    final contents = ['trialName=$trialName'].join(',');
    return 'AddTrialMeasurementRequest($contents)';
  }
}

/// Request message for
/// `VizierService.CompleteTrial`.
final class CompleteTrialRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CompleteTrialRequest';

  /// Required. The Trial's name.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String name;

  /// Optional. If provided, it will be used as the completed Trial's
  /// final_measurement; Otherwise, the service will auto-select a
  /// previously reported measurement as the final-measurement
  final Measurement? finalMeasurement;

  /// Optional. True if the Trial cannot be run with the given Parameter, and
  /// final_measurement will be ignored.
  final bool trialInfeasible;

  /// Optional. A human readable reason why the trial was infeasible. This should
  /// only be provided if `trial_infeasible` is true.
  final String infeasibleReason;

  CompleteTrialRequest({
    required this.name,
    this.finalMeasurement,
    this.trialInfeasible = false,
    this.infeasibleReason = '',
  }) : super(fullyQualifiedName);

  factory CompleteTrialRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CompleteTrialRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      finalMeasurement: switch (json['finalMeasurement']) {
        null => null,
        Object $1 => Measurement.fromJson($1),
      },
      trialInfeasible: switch (json['trialInfeasible']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      infeasibleReason: switch (json['infeasibleReason']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (finalMeasurement != null)
      'finalMeasurement': finalMeasurement!.toJson(),
    if (trialInfeasible.isNotDefault) 'trialInfeasible': trialInfeasible,
    if (infeasibleReason.isNotDefault) 'infeasibleReason': infeasibleReason,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'trialInfeasible=$trialInfeasible',
      'infeasibleReason=$infeasibleReason',
    ].join(',');
    return 'CompleteTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.DeleteTrial`.
final class DeleteTrialRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTrialRequest';

  /// Required. The Trial's name.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String name;

  DeleteTrialRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteTrialRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteTrialRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.CheckTrialEarlyStoppingState`.
final class CheckTrialEarlyStoppingStateRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CheckTrialEarlyStoppingStateRequest';

  /// Required. The Trial's name.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String trialName;

  CheckTrialEarlyStoppingStateRequest({required this.trialName})
    : super(fullyQualifiedName);

  factory CheckTrialEarlyStoppingStateRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CheckTrialEarlyStoppingStateRequest(
      trialName: switch (json['trialName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'trialName': trialName};

  @override
  String toString() {
    final contents = ['trialName=$trialName'].join(',');
    return 'CheckTrialEarlyStoppingStateRequest($contents)';
  }
}

/// Response message for
/// `VizierService.CheckTrialEarlyStoppingState`.
final class CheckTrialEarlyStoppingStateResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CheckTrialEarlyStoppingStateResponse';

  /// True if the Trial should stop.
  final bool shouldStop;

  CheckTrialEarlyStoppingStateResponse({this.shouldStop = false})
    : super(fullyQualifiedName);

  factory CheckTrialEarlyStoppingStateResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CheckTrialEarlyStoppingStateResponse(
      shouldStop: switch (json['shouldStop']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {if (shouldStop.isNotDefault) 'shouldStop': shouldStop};

  @override
  String toString() {
    final contents = ['shouldStop=$shouldStop'].join(',');
    return 'CheckTrialEarlyStoppingStateResponse($contents)';
  }
}

/// This message will be placed in the metadata field of a
/// google.longrunning.Operation associated with a CheckTrialEarlyStoppingState
/// request.
final class CheckTrialEarlyStoppingStateMetatdata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CheckTrialEarlyStoppingStateMetatdata';

  /// Operation metadata for suggesting Trials.
  final GenericOperationMetadata? genericMetadata;

  /// The name of the Study that the Trial belongs to.
  final String study;

  /// The Trial name.
  final String trial;

  CheckTrialEarlyStoppingStateMetatdata({
    this.genericMetadata,
    this.study = '',
    this.trial = '',
  }) : super(fullyQualifiedName);

  factory CheckTrialEarlyStoppingStateMetatdata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CheckTrialEarlyStoppingStateMetatdata(
      genericMetadata: switch (json['genericMetadata']) {
        null => null,
        Object $1 => GenericOperationMetadata.fromJson($1),
      },
      study: switch (json['study']) {
        null => '',
        Object $1 => decodeString($1),
      },
      trial: switch (json['trial']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    if (study.isNotDefault) 'study': study,
    if (trial.isNotDefault) 'trial': trial,
  };

  @override
  String toString() {
    final contents = ['study=$study', 'trial=$trial'].join(',');
    return 'CheckTrialEarlyStoppingStateMetatdata($contents)';
  }
}

/// Request message for
/// `VizierService.StopTrial`.
final class StopTrialRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StopTrialRequest';

  /// Required. The Trial's name.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String name;

  StopTrialRequest({required this.name}) : super(fullyQualifiedName);

  factory StopTrialRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StopTrialRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StopTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.ListOptimalTrials`.
final class ListOptimalTrialsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListOptimalTrialsRequest';

  /// Required. The name of the Study that the optimal Trial belongs to.
  final String parent;

  ListOptimalTrialsRequest({required this.parent}) : super(fullyQualifiedName);

  factory ListOptimalTrialsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListOptimalTrialsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'parent': parent};

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ListOptimalTrialsRequest($contents)';
  }
}

/// Response message for
/// `VizierService.ListOptimalTrials`.
final class ListOptimalTrialsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListOptimalTrialsResponse';

  /// The pareto-optimal Trials for multiple objective Study or the
  /// optimal trial for single objective Study. The definition of
  /// pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  final List<Trial> optimalTrials;

  ListOptimalTrialsResponse({this.optimalTrials = const []})
    : super(fullyQualifiedName);

  factory ListOptimalTrialsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListOptimalTrialsResponse(
      optimalTrials: switch (json['optimalTrials']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Trial.fromJson(i)],
        _ => throw const FormatException('"optimalTrials" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (optimalTrials.isNotDefault) 'optimalTrials': encodeList(optimalTrials),
  };

  @override
  String toString() => 'ListOptimalTrialsResponse()';
}

/// Represents a hardware accelerator type.
final class AcceleratorType extends ProtoEnum {
  /// Unspecified accelerator type, which means no accelerator.
  static const acceleratorTypeUnspecified = AcceleratorType(
    'ACCELERATOR_TYPE_UNSPECIFIED',
  );

  /// Deprecated: Nvidia Tesla K80 GPU has reached end of support,
  /// see https://cloud.google.com/compute/docs/eol/k80-eol.
  static const nvidiaTeslaK80 = AcceleratorType('NVIDIA_TESLA_K80');

  /// Nvidia Tesla P100 GPU.
  static const nvidiaTeslaP100 = AcceleratorType('NVIDIA_TESLA_P100');

  /// Nvidia Tesla V100 GPU.
  static const nvidiaTeslaV100 = AcceleratorType('NVIDIA_TESLA_V100');

  /// Nvidia Tesla P4 GPU.
  static const nvidiaTeslaP4 = AcceleratorType('NVIDIA_TESLA_P4');

  /// Nvidia Tesla T4 GPU.
  static const nvidiaTeslaT4 = AcceleratorType('NVIDIA_TESLA_T4');

  /// Nvidia Tesla A100 GPU.
  static const nvidiaTeslaA100 = AcceleratorType('NVIDIA_TESLA_A100');

  /// Nvidia A100 80GB GPU.
  static const nvidiaA10080Gb = AcceleratorType('NVIDIA_A100_80GB');

  /// Nvidia L4 GPU.
  static const nvidiaL4 = AcceleratorType('NVIDIA_L4');

  /// Nvidia H100 80Gb GPU.
  static const nvidiaH10080Gb = AcceleratorType('NVIDIA_H100_80GB');

  /// Nvidia H100 Mega 80Gb GPU.
  static const nvidiaH100Mega80Gb = AcceleratorType('NVIDIA_H100_MEGA_80GB');

  /// Nvidia H200 141Gb GPU.
  static const nvidiaH200141Gb = AcceleratorType('NVIDIA_H200_141GB');

  /// Nvidia B200 GPU.
  static const nvidiaB200 = AcceleratorType('NVIDIA_B200');

  /// Nvidia GB200 GPU.
  static const nvidiaGb200 = AcceleratorType('NVIDIA_GB200');

  /// Nvidia RTX Pro 6000 GPU.
  static const nvidiaRtxPro6000 = AcceleratorType('NVIDIA_RTX_PRO_6000');

  /// TPU v2.
  static const tpuV2 = AcceleratorType('TPU_V2');

  /// TPU v3.
  static const tpuV3 = AcceleratorType('TPU_V3');

  /// TPU v4.
  static const tpuV4Pod = AcceleratorType('TPU_V4_POD');

  /// TPU v5.
  static const tpuV5Litepod = AcceleratorType('TPU_V5_LITEPOD');

  /// The default value for [AcceleratorType].
  static const $default = acceleratorTypeUnspecified;

  const AcceleratorType(super.value);

  factory AcceleratorType.fromJson(Object? json) =>
      AcceleratorType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'AcceleratorType.$value';
}

/// Harm categories that will block the content.
final class HarmCategory extends ProtoEnum {
  /// The harm category is unspecified.
  static const harmCategoryUnspecified = HarmCategory(
    'HARM_CATEGORY_UNSPECIFIED',
  );

  /// The harm category is hate speech.
  static const harmCategoryHateSpeech = HarmCategory(
    'HARM_CATEGORY_HATE_SPEECH',
  );

  /// The harm category is dangerous content.
  static const harmCategoryDangerousContent = HarmCategory(
    'HARM_CATEGORY_DANGEROUS_CONTENT',
  );

  /// The harm category is harassment.
  static const harmCategoryHarassment = HarmCategory(
    'HARM_CATEGORY_HARASSMENT',
  );

  /// The harm category is sexually explicit content.
  static const harmCategorySexuallyExplicit = HarmCategory(
    'HARM_CATEGORY_SEXUALLY_EXPLICIT',
  );

  /// Deprecated: Election filter is not longer supported.
  /// The harm category is civic integrity.
  static const harmCategoryCivicIntegrity = HarmCategory(
    'HARM_CATEGORY_CIVIC_INTEGRITY',
  );

  /// The harm category is for jailbreak prompts.
  static const harmCategoryJailbreak = HarmCategory('HARM_CATEGORY_JAILBREAK');

  /// The default value for [HarmCategory].
  static const $default = harmCategoryUnspecified;

  const HarmCategory(super.value);

  factory HarmCategory.fromJson(Object? json) => HarmCategory(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'HarmCategory.$value';
}

/// Content Part modality
final class Modality extends ProtoEnum {
  /// Unspecified modality.
  static const modalityUnspecified = Modality('MODALITY_UNSPECIFIED');

  /// Plain text.
  static const text = Modality('TEXT');

  /// Image.
  static const image = Modality('IMAGE');

  /// Video.
  static const video = Modality('VIDEO');

  /// Audio.
  static const audio = Modality('AUDIO');

  /// Document, e.g. PDF.
  static const document = Modality('DOCUMENT');

  /// The default value for [Modality].
  static const $default = modalityUnspecified;

  const Modality(super.value);

  factory Modality.fromJson(Object? json) => Modality(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Modality.$value';
}

/// Stage field indicating the current progress of a deployment.
final class DeploymentStage extends ProtoEnum {
  /// Default value. This value is unused.
  static const deploymentStageUnspecified = DeploymentStage(
    'DEPLOYMENT_STAGE_UNSPECIFIED',
  );

  /// The deployment is initializing and setting up the environment.
  static const startingDeployment = DeploymentStage('STARTING_DEPLOYMENT');

  /// The deployment is preparing the model assets.
  static const preparingModel = DeploymentStage('PREPARING_MODEL');

  /// The deployment is creating the underlying serving cluster.
  static const creatingServingCluster = DeploymentStage(
    'CREATING_SERVING_CLUSTER',
  );

  /// The deployment is adding nodes to the serving cluster.
  static const addingNodesToCluster = DeploymentStage(
    'ADDING_NODES_TO_CLUSTER',
  );

  /// The deployment is getting the container image for the model server.
  static const gettingContainerImage = DeploymentStage(
    'GETTING_CONTAINER_IMAGE',
  );

  /// The deployment is starting the model server.
  static const startingModelServer = DeploymentStage('STARTING_MODEL_SERVER');

  /// The deployment is performing finalization steps.
  static const finishingUp = DeploymentStage('FINISHING_UP');

  /// The deployment has terminated.
  static const deploymentTerminated = DeploymentStage('DEPLOYMENT_TERMINATED');

  /// The default value for [DeploymentStage].
  static const $default = deploymentStageUnspecified;

  const DeploymentStage(super.value);

  factory DeploymentStage.fromJson(Object? json) =>
      DeploymentStage(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DeploymentStage.$value';
}

/// Pairwise prediction autorater preference.
final class PairwiseChoice extends ProtoEnum {
  /// Unspecified prediction choice.
  static const pairwiseChoiceUnspecified = PairwiseChoice(
    'PAIRWISE_CHOICE_UNSPECIFIED',
  );

  /// Baseline prediction wins
  static const baseline = PairwiseChoice('BASELINE');

  /// Candidate prediction wins
  static const candidate = PairwiseChoice('CANDIDATE');

  /// Winner cannot be determined
  static const tie = PairwiseChoice('TIE');

  /// The default value for [PairwiseChoice].
  static const $default = pairwiseChoiceUnspecified;

  const PairwiseChoice(super.value);

  factory PairwiseChoice.fromJson(Object? json) =>
      PairwiseChoice(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PairwiseChoice.$value';
}

/// Enum of location an HTTP element can be.
final class HttpElementLocation extends ProtoEnum {
  static const httpInUnspecified = HttpElementLocation('HTTP_IN_UNSPECIFIED');

  /// Element is in the HTTP request query.
  static const httpInQuery = HttpElementLocation('HTTP_IN_QUERY');

  /// Element is in the HTTP request header.
  static const httpInHeader = HttpElementLocation('HTTP_IN_HEADER');

  /// Element is in the HTTP request path.
  static const httpInPath = HttpElementLocation('HTTP_IN_PATH');

  /// Element is in the HTTP request body.
  static const httpInBody = HttpElementLocation('HTTP_IN_BODY');

  /// Element is in the HTTP request cookie.
  static const httpInCookie = HttpElementLocation('HTTP_IN_COOKIE');

  /// The default value for [HttpElementLocation].
  static const $default = httpInUnspecified;

  const HttpElementLocation(super.value);

  factory HttpElementLocation.fromJson(Object? json) =>
      HttpElementLocation(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'HttpElementLocation.$value';
}

/// Type of Auth.
final class AuthType extends ProtoEnum {
  static const authTypeUnspecified = AuthType('AUTH_TYPE_UNSPECIFIED');

  /// No Auth.
  static const noAuth = AuthType('NO_AUTH');

  /// API Key Auth.
  static const apiKeyAuth = AuthType('API_KEY_AUTH');

  /// HTTP Basic Auth.
  static const httpBasicAuth = AuthType('HTTP_BASIC_AUTH');

  /// Google Service Account Auth.
  static const googleServiceAccountAuth = AuthType(
    'GOOGLE_SERVICE_ACCOUNT_AUTH',
  );

  /// OAuth auth.
  static const oauth = AuthType('OAUTH');

  /// OpenID Connect (OIDC) Auth.
  static const oidcAuth = AuthType('OIDC_AUTH');

  /// The default value for [AuthType].
  static const $default = authTypeUnspecified;

  const AuthType(super.value);

  factory AuthType.fromJson(Object? json) => AuthType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'AuthType.$value';
}

/// Format of the data in the Feature View.
final class FeatureViewDataFormat extends ProtoEnum {
  /// Not set. Will be treated as the KeyValue format.
  static const featureViewDataFormatUnspecified = FeatureViewDataFormat(
    'FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED',
  );

  /// Return response data in key-value format.
  static const keyValue = FeatureViewDataFormat('KEY_VALUE');

  /// Return response data in proto Struct format.
  static const protoStruct = FeatureViewDataFormat('PROTO_STRUCT');

  /// The default value for [FeatureViewDataFormat].
  static const $default = featureViewDataFormatUnspecified;

  const FeatureViewDataFormat(super.value);

  factory FeatureViewDataFormat.fromJson(Object? json) =>
      FeatureViewDataFormat(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'FeatureViewDataFormat.$value';
}

/// Describes the state of a job.
final class JobState extends ProtoEnum {
  /// The job state is unspecified.
  static const jobStateUnspecified = JobState('JOB_STATE_UNSPECIFIED');

  /// The job has been just created or resumed and processing has not yet begun.
  static const jobStateQueued = JobState('JOB_STATE_QUEUED');

  /// The service is preparing to run the job.
  static const jobStatePending = JobState('JOB_STATE_PENDING');

  /// The job is in progress.
  static const jobStateRunning = JobState('JOB_STATE_RUNNING');

  /// The job completed successfully.
  static const jobStateSucceeded = JobState('JOB_STATE_SUCCEEDED');

  /// The job failed.
  static const jobStateFailed = JobState('JOB_STATE_FAILED');

  /// The job is being cancelled. From this state the job may only go to
  /// either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
  static const jobStateCancelling = JobState('JOB_STATE_CANCELLING');

  /// The job has been cancelled.
  static const jobStateCancelled = JobState('JOB_STATE_CANCELLED');

  /// The job has been stopped, and can be resumed.
  static const jobStatePaused = JobState('JOB_STATE_PAUSED');

  /// The job has expired.
  static const jobStateExpired = JobState('JOB_STATE_EXPIRED');

  /// The job is being updated. Only jobs in the `RUNNING` state can be updated.
  /// After updating, the job goes back to the `RUNNING` state.
  static const jobStateUpdating = JobState('JOB_STATE_UPDATING');

  /// The job is partially succeeded, some results may be missing due to errors.
  static const jobStatePartiallySucceeded = JobState(
    'JOB_STATE_PARTIALLY_SUCCEEDED',
  );

  /// The default value for [JobState].
  static const $default = jobStateUnspecified;

  const JobState(super.value);

  factory JobState.fromJson(Object? json) => JobState(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'JobState.$value';
}

/// The Model Monitoring Objective types.
final class ModelDeploymentMonitoringObjectiveType extends ProtoEnum {
  /// Default value, should not be set.
  static const modelDeploymentMonitoringObjectiveTypeUnspecified =
      ModelDeploymentMonitoringObjectiveType(
        'MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED',
      );

  /// Raw feature values' stats to detect skew between Training-Prediction
  /// datasets.
  static const rawFeatureSkew = ModelDeploymentMonitoringObjectiveType(
    'RAW_FEATURE_SKEW',
  );

  /// Raw feature values' stats to detect drift between Serving-Prediction
  /// datasets.
  static const rawFeatureDrift = ModelDeploymentMonitoringObjectiveType(
    'RAW_FEATURE_DRIFT',
  );

  /// Feature attribution scores to detect skew between Training-Prediction
  /// datasets.
  static const featureAttributionSkew = ModelDeploymentMonitoringObjectiveType(
    'FEATURE_ATTRIBUTION_SKEW',
  );

  /// Feature attribution scores to detect skew between Prediction datasets
  /// collected within different time windows.
  static const featureAttributionDrift = ModelDeploymentMonitoringObjectiveType(
    'FEATURE_ATTRIBUTION_DRIFT',
  );

  /// The default value for [ModelDeploymentMonitoringObjectiveType].
  static const $default = modelDeploymentMonitoringObjectiveTypeUnspecified;

  const ModelDeploymentMonitoringObjectiveType(super.value);

  factory ModelDeploymentMonitoringObjectiveType.fromJson(Object? json) =>
      ModelDeploymentMonitoringObjectiveType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ModelDeploymentMonitoringObjectiveType.$value';
}

/// View enumeration of PublisherModel.
final class PublisherModelView extends ProtoEnum {
  /// The default / unset value. The API will default to the BASIC view.
  static const publisherModelViewUnspecified = PublisherModelView(
    'PUBLISHER_MODEL_VIEW_UNSPECIFIED',
  );

  /// Include basic metadata about the publisher model, but not the full
  /// contents.
  static const publisherModelViewBasic = PublisherModelView(
    'PUBLISHER_MODEL_VIEW_BASIC',
  );

  /// Include everything.
  static const publisherModelViewFull = PublisherModelView(
    'PUBLISHER_MODEL_VIEW_FULL',
  );

  /// Include: VersionId, ModelVersionExternalName, and SupportedActions.
  static const publisherModelVersionViewBasic = PublisherModelView(
    'PUBLISHER_MODEL_VERSION_VIEW_BASIC',
  );

  /// The default value for [PublisherModelView].
  static const $default = publisherModelViewUnspecified;

  const PublisherModelView(super.value);

  factory PublisherModelView.fromJson(Object? json) =>
      PublisherModelView(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PublisherModelView.$value';
}

/// Represents a notebook runtime type.
final class NotebookRuntimeType extends ProtoEnum {
  /// Unspecified notebook runtime type, NotebookRuntimeType will default to
  /// USER_DEFINED.
  static const notebookRuntimeTypeUnspecified = NotebookRuntimeType(
    'NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED',
  );

  /// runtime or template with coustomized configurations from user.
  static const userDefined = NotebookRuntimeType('USER_DEFINED');

  /// runtime or template with system defined configurations.
  static const oneClick = NotebookRuntimeType('ONE_CLICK');

  /// The default value for [NotebookRuntimeType].
  static const $default = notebookRuntimeTypeUnspecified;

  const NotebookRuntimeType(super.value);

  factory NotebookRuntimeType.fromJson(Object? json) =>
      NotebookRuntimeType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'NotebookRuntimeType.$value';
}

/// Views for Get/List NotebookExecutionJob
final class NotebookExecutionJobView extends ProtoEnum {
  /// When unspecified, the API defaults to the BASIC view.
  static const notebookExecutionJobViewUnspecified = NotebookExecutionJobView(
    'NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED',
  );

  /// Includes all fields except for direct notebook inputs.
  static const notebookExecutionJobViewBasic = NotebookExecutionJobView(
    'NOTEBOOK_EXECUTION_JOB_VIEW_BASIC',
  );

  /// Includes all fields.
  static const notebookExecutionJobViewFull = NotebookExecutionJobView(
    'NOTEBOOK_EXECUTION_JOB_VIEW_FULL',
  );

  /// The default value for [NotebookExecutionJobView].
  static const $default = notebookExecutionJobViewUnspecified;

  const NotebookExecutionJobView(super.value);

  factory NotebookExecutionJobView.fromJson(Object? json) =>
      NotebookExecutionJobView(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'NotebookExecutionJobView.$value';
}

/// Type contains the list of OpenAPI data types as defined by
/// https://swagger.io/docs/specification/data-models/data-types/
final class Type extends ProtoEnum {
  /// Not specified, should not be used.
  static const typeUnspecified = Type('TYPE_UNSPECIFIED');

  /// OpenAPI string type
  static const string = Type('STRING');

  /// OpenAPI number type
  static const number = Type('NUMBER');

  /// OpenAPI integer type
  static const integer = Type('INTEGER');

  /// OpenAPI boolean type
  static const boolean = Type('BOOLEAN');

  /// OpenAPI array type
  static const array = Type('ARRAY');

  /// OpenAPI object type
  static const object = Type('OBJECT');

  /// The default value for [Type].
  static const $default = typeUnspecified;

  const Type(super.value);

  factory Type.fromJson(Object? json) => Type(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Represents the failure policy of a pipeline. Currently, the default of a
/// pipeline is that the pipeline will continue to run until no more tasks can be
/// executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a
/// pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling
/// any new tasks when a task has failed. Any scheduled tasks will continue to
/// completion.
final class PipelineFailurePolicy extends ProtoEnum {
  /// Default value, and follows fail slow behavior.
  static const pipelineFailurePolicyUnspecified = PipelineFailurePolicy(
    'PIPELINE_FAILURE_POLICY_UNSPECIFIED',
  );

  /// Indicates that the pipeline should continue to run until all possible
  /// tasks have been scheduled and completed.
  static const pipelineFailurePolicyFailSlow = PipelineFailurePolicy(
    'PIPELINE_FAILURE_POLICY_FAIL_SLOW',
  );

  /// Indicates that the pipeline should stop scheduling new tasks after a task
  /// has failed.
  static const pipelineFailurePolicyFailFast = PipelineFailurePolicy(
    'PIPELINE_FAILURE_POLICY_FAIL_FAST',
  );

  /// The default value for [PipelineFailurePolicy].
  static const $default = pipelineFailurePolicyUnspecified;

  const PipelineFailurePolicy(super.value);

  factory PipelineFailurePolicy.fromJson(Object? json) =>
      PipelineFailurePolicy(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PipelineFailurePolicy.$value';
}

/// Describes the state of a pipeline.
final class PipelineState extends ProtoEnum {
  /// The pipeline state is unspecified.
  static const pipelineStateUnspecified = PipelineState(
    'PIPELINE_STATE_UNSPECIFIED',
  );

  /// The pipeline has been created or resumed, and processing has not yet
  /// begun.
  static const pipelineStateQueued = PipelineState('PIPELINE_STATE_QUEUED');

  /// The service is preparing to run the pipeline.
  static const pipelineStatePending = PipelineState('PIPELINE_STATE_PENDING');

  /// The pipeline is in progress.
  static const pipelineStateRunning = PipelineState('PIPELINE_STATE_RUNNING');

  /// The pipeline completed successfully.
  static const pipelineStateSucceeded = PipelineState(
    'PIPELINE_STATE_SUCCEEDED',
  );

  /// The pipeline failed.
  static const pipelineStateFailed = PipelineState('PIPELINE_STATE_FAILED');

  /// The pipeline is being cancelled. From this state, the pipeline may only go
  /// to either PIPELINE_STATE_SUCCEEDED, PIPELINE_STATE_FAILED or
  /// PIPELINE_STATE_CANCELLED.
  static const pipelineStateCancelling = PipelineState(
    'PIPELINE_STATE_CANCELLING',
  );

  /// The pipeline has been cancelled.
  static const pipelineStateCancelled = PipelineState(
    'PIPELINE_STATE_CANCELLED',
  );

  /// The pipeline has been stopped, and can be resumed.
  static const pipelineStatePaused = PipelineState('PIPELINE_STATE_PAUSED');

  /// The default value for [PipelineState].
  static const $default = pipelineStateUnspecified;

  const PipelineState(super.value);

  factory PipelineState.fromJson(Object? json) => PipelineState(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PipelineState.$value';
}

/// The state of the PSC service automation.
final class PscautomationState extends ProtoEnum {
  /// Should not be used.
  static const pscAutomationStateUnspecified = PscautomationState(
    'PSC_AUTOMATION_STATE_UNSPECIFIED',
  );

  /// The PSC service automation is successful.
  static const pscAutomationStateSuccessful = PscautomationState(
    'PSC_AUTOMATION_STATE_SUCCESSFUL',
  );

  /// The PSC service automation has failed.
  static const pscAutomationStateFailed = PscautomationState(
    'PSC_AUTOMATION_STATE_FAILED',
  );

  /// The default value for [PscautomationState].
  static const $default = pscAutomationStateUnspecified;

  const PscautomationState(super.value);

  factory PscautomationState.fromJson(Object? json) =>
      PscautomationState(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PSCAutomationState.$value';
}
