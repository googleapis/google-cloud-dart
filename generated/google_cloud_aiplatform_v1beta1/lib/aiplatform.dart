// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Vertex AI API.
///
/// Train high-quality custom machine learning models with minimal machine
/// learning expertise and effort.
library;

import 'package:google_cloud_api/api.dart';
import 'package:google_cloud_gax/gax.dart';
import 'package:google_cloud_iam_v1/iam.dart';
import 'package:google_cloud_location/location.dart';
import 'package:google_cloud_longrunning/longrunning.dart';
import 'package:google_cloud_protobuf/protobuf.dart' as protobuf;
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/rpc.dart';
import 'package:google_cloud_type/type.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// The service that manages Vertex AI Dataset and its child resources.
final class DatasetService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `DatasetService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `DatasetService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  DatasetService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `DatasetService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory DatasetService.fromApiKey([String? apiKey]) {
    return DatasetService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Dataset, CreateDatasetOperationMetadata>> createDataset(
    CreateDatasetRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/datasets');
    final response = await _client.post(url, body: request.dataset);
    return Operation.fromJson(
      response,
      OperationHelper(
        Dataset.fromJson,
        CreateDatasetOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Dataset> getDataset(GetDatasetRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return Dataset.fromJson(response);
  }

  /// Updates a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Dataset> updateDataset(UpdateDatasetRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.dataset.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.dataset);
    return Dataset.fromJson(response);
  }

  /// Lists Datasets in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDatasetsResponse> listDatasets(ListDatasetsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/datasets', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListDatasetsResponse.fromJson(response);
  }

  /// Deletes a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteDataset(
    DeleteDatasetRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Imports data into a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ImportDataResponse, ImportDataOperationMetadata>> importData(
    ImportDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:import');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ImportDataResponse.fromJson,
        ImportDataOperationMetadata.fromJson,
      ),
    );
  }

  /// Exports data from a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ExportDataResponse, ExportDataOperationMetadata>> exportData(
    ExportDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:export');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExportDataResponse.fromJson,
        ExportDataOperationMetadata.fromJson,
      ),
    );
  }

  /// Create a version from a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DatasetVersion, CreateDatasetVersionOperationMetadata>>
  createDatasetVersion(CreateDatasetVersionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/datasetVersions');
    final response = await _client.post(url, body: request.datasetVersion);
    return Operation.fromJson(
      response,
      OperationHelper(
        DatasetVersion.fromJson,
        CreateDatasetVersionOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a DatasetVersion.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DatasetVersion> updateDatasetVersion(
    UpdateDatasetVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.datasetVersion.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.datasetVersion);
    return DatasetVersion.fromJson(response);
  }

  /// Deletes a Dataset version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteDatasetVersion(DeleteDatasetVersionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Dataset version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DatasetVersion> getDatasetVersion(
    GetDatasetVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return DatasetVersion.fromJson(response);
  }

  /// Lists DatasetVersions in a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDatasetVersionsResponse> listDatasetVersions(
    ListDatasetVersionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/datasetVersions', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListDatasetVersionsResponse.fromJson(response);
  }

  /// Restores a dataset version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DatasetVersion, RestoreDatasetVersionOperationMetadata>>
  restoreDatasetVersion(RestoreDatasetVersionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:restore');
    final response = await _client.get(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        DatasetVersion.fromJson,
        RestoreDatasetVersionOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists DataItems in a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDataItemsResponse> listDataItems(
    ListDataItemsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/dataItems', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListDataItemsResponse.fromJson(response);
  }

  /// Searches DataItems in a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchDataItemsResponse> searchDataItems(
    SearchDataItemsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.dataset}:searchDataItems', {
          if (request.orderByDataItem != null)
            'orderByDataItem': request.orderByDataItem!,
          if (request.orderByAnnotation?.savedQuery != null)
            'orderByAnnotation.savedQuery':
                request.orderByAnnotation?.savedQuery!,
          if (request.orderByAnnotation?.orderBy != null)
            'orderByAnnotation.orderBy': request.orderByAnnotation?.orderBy!,
          if (request.savedQuery != null) 'savedQuery': request.savedQuery!,
          if (request.dataLabelingJob != null)
            'dataLabelingJob': request.dataLabelingJob!,
          if (request.dataItemFilter != null)
            'dataItemFilter': request.dataItemFilter!,
          if (request.annotationsFilter != null)
            'annotationsFilter': request.annotationsFilter!,
          if (request.annotationFilters != null)
            'annotationFilters': request.annotationFilters!,
          if (request.fieldMask?.paths != null)
            'fieldMask.paths': request.fieldMask?.paths!,
          if (request.annotationsLimit != null)
            'annotationsLimit': '${request.annotationsLimit}',
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.orderBy != null) 'orderBy': request.orderBy!,
          if (request.pageToken != null) 'pageToken': request.pageToken!,
        });
    final response = await _client.get(url);
    return SearchDataItemsResponse.fromJson(response);
  }

  /// Lists SavedQueries in a Dataset.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSavedQueriesResponse> listSavedQueries(
    ListSavedQueriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/savedQueries', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListSavedQueriesResponse.fromJson(response);
  }

  /// Deletes a SavedQuery.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteSavedQuery(
    DeleteSavedQueryRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets an AnnotationSpec.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnnotationSpec> getAnnotationSpec(
    GetAnnotationSpecRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return AnnotationSpec.fromJson(response);
  }

  /// Lists Annotations belongs to a dataitem.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListAnnotationsResponse> listAnnotations(
    ListAnnotationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/annotations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListAnnotationsResponse.fromJson(response);
  }

  /// Assesses the state or validity of the dataset with respect to a given use
  /// case.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<AssessDataResponse, AssessDataOperationMetadata>> assessData(
    AssessDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:assess');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        AssessDataResponse.fromJson,
        AssessDataOperationMetadata.fromJson,
      ),
    );
  }

  /// Assembles each row of a multimodal dataset and writes the result into a
  /// BigQuery table.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<AssembleDataResponse, AssembleDataOperationMetadata>>
  assembleData(AssembleDataRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:assemble');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        AssembleDataResponse.fromJson,
        AssembleDataOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service that manages the DeploymentResourcePool resource.
final class DeploymentResourcePoolService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `DeploymentResourcePoolService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `DeploymentResourcePoolService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  DeploymentResourcePoolService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `DeploymentResourcePoolService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory DeploymentResourcePoolService.fromApiKey([String? apiKey]) {
    return DeploymentResourcePoolService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Create a DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      DeploymentResourcePool,
      CreateDeploymentResourcePoolOperationMetadata
    >
  >
  createDeploymentResourcePool(
    CreateDeploymentResourcePoolRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/deploymentResourcePools',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeploymentResourcePool.fromJson,
        CreateDeploymentResourcePoolOperationMetadata.fromJson,
      ),
    );
  }

  /// Get a DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DeploymentResourcePool> getDeploymentResourcePool(
    GetDeploymentResourcePoolRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return DeploymentResourcePool.fromJson(response);
  }

  /// List DeploymentResourcePools in a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDeploymentResourcePoolsResponse> listDeploymentResourcePools(
    ListDeploymentResourcePoolsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/deploymentResourcePools', {
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
        });
    final response = await _client.get(url);
    return ListDeploymentResourcePoolsResponse.fromJson(response);
  }

  /// Update a DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      DeploymentResourcePool,
      UpdateDeploymentResourcePoolOperationMetadata
    >
  >
  updateDeploymentResourcePool(
    UpdateDeploymentResourcePoolRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.deploymentResourcePool.name}', {
          if (request.updateMask?.paths != null)
            'updateMask.paths': request.updateMask?.paths!,
        });
    final response = await _client.patch(
      url,
      body: request.deploymentResourcePool,
    );
    return Operation.fromJson(
      response,
      OperationHelper(
        DeploymentResourcePool.fromJson,
        UpdateDeploymentResourcePoolOperationMetadata.fromJson,
      ),
    );
  }

  /// Delete a DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteDeploymentResourcePool(
    DeleteDeploymentResourcePoolRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// List DeployedModels that have been deployed on this DeploymentResourcePool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<QueryDeployedModelsResponse> queryDeployedModels(
    QueryDeployedModelsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.deploymentResourcePool}:queryDeployedModels',
      {
        if (request.pageSize != null) 'pageSize': '${request.pageSize}',
        if (request.pageToken != null) 'pageToken': request.pageToken!,
      },
    );
    final response = await _client.get(url);
    return QueryDeployedModelsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's Endpoints.
final class EndpointService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `EndpointService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `EndpointService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  EndpointService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `EndpointService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory EndpointService.fromApiKey([String? apiKey]) {
    return EndpointService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates an Endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Endpoint, CreateEndpointOperationMetadata>> createEndpoint(
    CreateEndpointRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/endpoints', {
      if (request.endpointId != null) 'endpointId': request.endpointId!,
    });
    final response = await _client.post(url, body: request.endpoint);
    return Operation.fromJson(
      response,
      OperationHelper(
        Endpoint.fromJson,
        CreateEndpointOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets an Endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Endpoint> getEndpoint(GetEndpointRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Endpoint.fromJson(response);
  }

  /// Lists Endpoints in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListEndpointsResponse> listEndpoints(
    ListEndpointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/endpoints', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListEndpointsResponse.fromJson(response);
  }

  /// Updates an Endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Endpoint> updateEndpoint(UpdateEndpointRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.endpoint);
    return Endpoint.fromJson(response);
  }

  /// Updates an Endpoint with a long running operation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Endpoint, UpdateEndpointOperationMetadata>>
  updateEndpointLongRunning(UpdateEndpointLongRunningRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint.name}:update');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        Endpoint.fromJson,
        UpdateEndpointOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes an Endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteEndpoint(
    DeleteEndpointRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Deploys a Model into this Endpoint, creating a DeployedModel within it.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DeployModelResponse, DeployModelOperationMetadata>>
  deployModel(DeployModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:deployModel');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeployModelResponse.fromJson,
        DeployModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Undeploys a Model from an Endpoint, removing a DeployedModel from it, and
  /// freeing all resources it's using.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<UndeployModelResponse, UndeployModelOperationMetadata>>
  undeployModel(UndeployModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:undeployModel');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UndeployModelResponse.fromJson,
        UndeployModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates an existing deployed model. Updatable fields include
  /// `min_replica_count`, `max_replica_count`, `required_replica_count`,
  /// `autoscaling_metric_specs`, `disable_container_logging` (v1 only), and
  /// `enable_container_logging` (v1beta1 only).
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<MutateDeployedModelResponse, MutateDeployedModelOperationMetadata>
  >
  mutateDeployedModel(MutateDeployedModelRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}:mutateDeployedModel',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        MutateDeployedModelResponse.fromJson,
        MutateDeployedModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Sets (creates or updates) configs of publisher models. For example, sets
  /// the request/response logging config.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<PublisherModelConfig, SetPublisherModelConfigOperationMetadata>
  >
  setPublisherModelConfig(SetPublisherModelConfigRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.name}:setPublisherModelConfig',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PublisherModelConfig.fromJson,
        SetPublisherModelConfigOperationMetadata.fromJson,
      ),
    );
  }

  /// Fetches the configs of publisher models.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PublisherModelConfig> fetchPublisherModelConfig(
    FetchPublisherModelConfigRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.name}:fetchPublisherModelConfig',
    );
    final response = await _client.get(url);
    return PublisherModelConfig.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Vertex AI Online Evaluation Service.
final class EvaluationService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `EvaluationService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `EvaluationService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  EvaluationService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `EvaluationService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory EvaluationService.fromApiKey([String? apiKey]) {
    return EvaluationService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Evaluates instances based on a given metric.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EvaluateInstancesResponse> evaluateInstances(
    EvaluateInstancesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.location}:evaluateInstances',
    );
    final response = await _client.post(url, body: request);
    return EvaluateInstancesResponse.fromJson(response);
  }

  /// Evaluates a dataset based on a set of given metrics.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<EvaluateDatasetResponse, EvaluateDatasetOperationMetadata>>
  evaluateDataset(EvaluateDatasetRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.location}:evaluateDataset',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        EvaluateDatasetResponse.fromJson,
        EvaluateDatasetOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing and retrieving few-shot examples.
final class ExampleStoreService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ExampleStoreService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ExampleStoreService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ExampleStoreService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ExampleStoreService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ExampleStoreService.fromApiKey([String? apiKey]) {
    return ExampleStoreService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Create an ExampleStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ExampleStore, CreateExampleStoreOperationMetadata>>
  createExampleStore(CreateExampleStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/exampleStores');
    final response = await _client.post(url, body: request.exampleStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExampleStore.fromJson,
        CreateExampleStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Get an ExampleStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ExampleStore> getExampleStore(GetExampleStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ExampleStore.fromJson(response);
  }

  /// Update an ExampleStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ExampleStore, UpdateExampleStoreOperationMetadata>>
  updateExampleStore(UpdateExampleStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.exampleStore.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.exampleStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExampleStore.fromJson,
        UpdateExampleStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Delete an ExampleStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteExampleStoreOperationMetadata>>
  deleteExampleStore(DeleteExampleStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteExampleStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// List ExampleStores in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListExampleStoresResponse> listExampleStores(
    ListExampleStoresRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/exampleStores', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListExampleStoresResponse.fromJson(response);
  }

  /// Create or update Examples in the Example Store.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<UpsertExamplesResponse> upsertExamples(
    UpsertExamplesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.exampleStore}:upsertExamples',
    );
    final response = await _client.post(url, body: request);
    return UpsertExamplesResponse.fromJson(response);
  }

  /// Remove Examples from the Example Store.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RemoveExamplesResponse> removeExamples(
    RemoveExamplesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.exampleStore}:removeExamples',
    );
    final response = await _client.post(url, body: request);
    return RemoveExamplesResponse.fromJson(response);
  }

  /// Search for similar Examples for given selection criteria.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchExamplesResponse> searchExamples(
    SearchExamplesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.exampleStore}:searchExamples',
    );
    final response = await _client.post(url, body: request);
    return SearchExamplesResponse.fromJson(response);
  }

  /// Get Examples from the Example Store.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FetchExamplesResponse> fetchExamples(
    FetchExamplesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.exampleStore}:fetchExamples',
    );
    final response = await _client.post(url, body: request);
    return FetchExamplesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for Extension execution.
final class ExtensionExecutionService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ExtensionExecutionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ExtensionExecutionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ExtensionExecutionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ExtensionExecutionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ExtensionExecutionService.fromApiKey([String? apiKey]) {
    return ExtensionExecutionService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Executes the request against a given extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ExecuteExtensionResponse> executeExtension(
    ExecuteExtensionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:execute');
    final response = await _client.post(url, body: request);
    return ExecuteExtensionResponse.fromJson(response);
  }

  /// Queries an extension with a default controller.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<QueryExtensionResponse> queryExtension(
    QueryExtensionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:query');
    final response = await _client.post(url, body: request);
    return QueryExtensionResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's Extension registry.
final class ExtensionRegistryService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ExtensionRegistryService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ExtensionRegistryService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ExtensionRegistryService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ExtensionRegistryService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ExtensionRegistryService.fromApiKey([String? apiKey]) {
    return ExtensionRegistryService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Imports an Extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Extension, ImportExtensionOperationMetadata>>
  importExtension(ImportExtensionRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/extensions:import',
    );
    final response = await _client.post(url, body: request.extension);
    return Operation.fromJson(
      response,
      OperationHelper(
        Extension.fromJson,
        ImportExtensionOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets an Extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Extension> getExtension(GetExtensionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Extension.fromJson(response);
  }

  /// Lists Extensions in a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListExtensionsResponse> listExtensions(
    ListExtensionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/extensions', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListExtensionsResponse.fromJson(response);
  }

  /// Updates an Extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Extension> updateExtension(UpdateExtensionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.extension.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.extension);
    return Extension.fromJson(response);
  }

  /// Deletes an Extension.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteExtension(
    DeleteExtensionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The service that handles CRUD and List for resources for
/// FeatureOnlineStore.
final class FeatureOnlineStoreAdminService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeatureOnlineStoreAdminService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeatureOnlineStoreAdminService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeatureOnlineStoreAdminService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeatureOnlineStoreAdminService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeatureOnlineStoreAdminService.fromApiKey([String? apiKey]) {
    return FeatureOnlineStoreAdminService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Creates a new FeatureOnlineStore in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<FeatureOnlineStore, CreateFeatureOnlineStoreOperationMetadata>
  >
  createFeatureOnlineStore(CreateFeatureOnlineStoreRequest request) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureOnlineStores', {
          if (request.featureOnlineStoreId != null)
            'featureOnlineStoreId': request.featureOnlineStoreId!,
        });
    final response = await _client.post(url, body: request.featureOnlineStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureOnlineStore.fromJson,
        CreateFeatureOnlineStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single FeatureOnlineStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureOnlineStore> getFeatureOnlineStore(
    GetFeatureOnlineStoreRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureOnlineStore.fromJson(response);
  }

  /// Lists FeatureOnlineStores in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureOnlineStoresResponse> listFeatureOnlineStores(
    ListFeatureOnlineStoresRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureOnlineStores', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.orderBy != null) 'orderBy': request.orderBy!,
        });
    final response = await _client.get(url);
    return ListFeatureOnlineStoresResponse.fromJson(response);
  }

  /// Updates the parameters of a single FeatureOnlineStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<FeatureOnlineStore, UpdateFeatureOnlineStoreOperationMetadata>
  >
  updateFeatureOnlineStore(UpdateFeatureOnlineStoreRequest request) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.featureOnlineStore.name}', {
          if (request.updateMask?.paths != null)
            'updateMask.paths': request.updateMask?.paths!,
        });
    final response = await _client.patch(url, body: request.featureOnlineStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureOnlineStore.fromJson,
        UpdateFeatureOnlineStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single FeatureOnlineStore. The FeatureOnlineStore must not
  /// contain any FeatureViews.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteFeatureOnlineStore(DeleteFeatureOnlineStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new FeatureView in a given FeatureOnlineStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureView, CreateFeatureViewOperationMetadata>>
  createFeatureView(CreateFeatureViewRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureViews', {
      if (request.featureViewId != null)
        'featureViewId': request.featureViewId!,
      if (request.runSyncImmediately != null)
        'runSyncImmediately': '${request.runSyncImmediately}',
    });
    final response = await _client.post(url, body: request.featureView);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureView.fromJson,
        CreateFeatureViewOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureView> getFeatureView(GetFeatureViewRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureView.fromJson(response);
  }

  /// Lists FeatureViews in a given FeatureOnlineStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureViewsResponse> listFeatureViews(
    ListFeatureViewsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureViews', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListFeatureViewsResponse.fromJson(response);
  }

  /// Updates the parameters of a single FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureView, UpdateFeatureViewOperationMetadata>>
  updateFeatureView(UpdateFeatureViewRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.featureView.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.featureView);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureView.fromJson,
        UpdateFeatureViewOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeatureView(
    DeleteFeatureViewRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Triggers on-demand sync for the FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SyncFeatureViewResponse> syncFeatureView(
    SyncFeatureViewRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.featureView}:sync');
    final response = await _client.post(url, body: request);
    return SyncFeatureViewResponse.fromJson(response);
  }

  /// Gets details of a single FeatureViewSync.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureViewSync> getFeatureViewSync(
    GetFeatureViewSyncRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureViewSync.fromJson(response);
  }

  /// Lists FeatureViewSyncs in a given FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureViewSyncsResponse> listFeatureViewSyncs(
    ListFeatureViewSyncsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureViewSyncs', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.orderBy != null) 'orderBy': request.orderBy!,
        });
    final response = await _client.get(url);
    return ListFeatureViewSyncsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for fetching feature values from the online store.
final class FeatureOnlineStoreService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeatureOnlineStoreService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeatureOnlineStoreService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeatureOnlineStoreService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeatureOnlineStoreService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeatureOnlineStoreService.fromApiKey([String? apiKey]) {
    return FeatureOnlineStoreService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Fetch feature values under a FeatureView.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FetchFeatureValuesResponse> fetchFeatureValues(
    FetchFeatureValuesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featureView}:fetchFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return FetchFeatureValuesResponse.fromJson(response);
  }

  /// Search the nearest entities under a FeatureView.
  /// Search only works for indexable feature view; if a feature view isn't
  /// indexable, returns Invalid argument response.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchNearestEntitiesResponse> searchNearestEntities(
    SearchNearestEntitiesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featureView}:searchNearestEntities',
    );
    final response = await _client.post(url, body: request);
    return SearchNearestEntitiesResponse.fromJson(response);
  }

  /// RPC to generate an access token for the given feature view. FeatureViews
  /// under the same FeatureOnlineStore share the same access token.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GenerateFetchAccessTokenResponse> generateFetchAccessToken(
    GenerateFetchAccessTokenRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featureView}:generateFetchAccessToken',
    );
    final response = await _client.post(url, body: request);
    return GenerateFetchAccessTokenResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The service that handles CRUD and List for resources for
/// FeatureRegistry.
final class FeatureRegistryService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeatureRegistryService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeatureRegistryService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeatureRegistryService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeatureRegistryService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeatureRegistryService.fromApiKey([String? apiKey]) {
    return FeatureRegistryService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Creates a new FeatureGroup in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureGroup, CreateFeatureGroupOperationMetadata>>
  createFeatureGroup(CreateFeatureGroupRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureGroups', {
      if (request.featureGroupId != null)
        'featureGroupId': request.featureGroupId!,
    });
    final response = await _client.post(url, body: request.featureGroup);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureGroup.fromJson,
        CreateFeatureGroupOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureGroup> getFeatureGroup(GetFeatureGroupRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureGroup.fromJson(response);
  }

  /// Lists FeatureGroups in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureGroupsResponse> listFeatureGroups(
    ListFeatureGroupsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureGroups', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListFeatureGroupsResponse.fromJson(response);
  }

  /// Updates the parameters of a single FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureGroup, UpdateFeatureGroupOperationMetadata>>
  updateFeatureGroup(UpdateFeatureGroupRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.featureGroup.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.featureGroup);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureGroup.fromJson,
        UpdateFeatureGroupOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeatureGroup(
    DeleteFeatureGroupRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new Feature in a given FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Feature, CreateFeatureOperationMetadata>> createFeature(
    CreateFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/features', {
      if (request.featureId != null) 'featureId': request.featureId!,
    });
    final response = await _client.post(url, body: request.feature);
    return Operation.fromJson(
      response,
      OperationHelper(
        Feature.fromJson,
        CreateFeatureOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a batch of Features in a given FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<BatchCreateFeaturesResponse, BatchCreateFeaturesOperationMetadata>
  >
  batchCreateFeatures(BatchCreateFeaturesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/features:batchCreate',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchCreateFeaturesResponse.fromJson,
        BatchCreateFeaturesOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Feature> getFeature(GetFeatureRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.featureStatsAndAnomalySpec?.latestStatsCount != null)
        'featureStatsAndAnomalySpec.latestStatsCount':
            '${request.featureStatsAndAnomalySpec?.latestStatsCount}',
      if (request
              .featureStatsAndAnomalySpec
              ?.statsTimeRange
              ?.startTime
              ?.seconds !=
          null)
        'featureStatsAndAnomalySpec.statsTimeRange.startTime.seconds':
            '${request.featureStatsAndAnomalySpec?.statsTimeRange?.startTime?.seconds}',
      if (request
              .featureStatsAndAnomalySpec
              ?.statsTimeRange
              ?.startTime
              ?.nanos !=
          null)
        'featureStatsAndAnomalySpec.statsTimeRange.startTime.nanos':
            '${request.featureStatsAndAnomalySpec?.statsTimeRange?.startTime?.nanos}',
      if (request
              .featureStatsAndAnomalySpec
              ?.statsTimeRange
              ?.endTime
              ?.seconds !=
          null)
        'featureStatsAndAnomalySpec.statsTimeRange.endTime.seconds':
            '${request.featureStatsAndAnomalySpec?.statsTimeRange?.endTime?.seconds}',
      if (request.featureStatsAndAnomalySpec?.statsTimeRange?.endTime?.nanos !=
          null)
        'featureStatsAndAnomalySpec.statsTimeRange.endTime.nanos':
            '${request.featureStatsAndAnomalySpec?.statsTimeRange?.endTime?.nanos}',
    });
    final response = await _client.get(url);
    return Feature.fromJson(response);
  }

  /// Lists Features in a given FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeaturesResponse> listFeatures(ListFeaturesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/features', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
      if (request.latestStatsCount != null)
        'latestStatsCount': '${request.latestStatsCount}',
    });
    final response = await _client.get(url);
    return ListFeaturesResponse.fromJson(response);
  }

  /// Updates the parameters of a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Feature, UpdateFeatureOperationMetadata>> updateFeature(
    UpdateFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.feature.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.feature);
    return Operation.fromJson(
      response,
      OperationHelper(
        Feature.fromJson,
        UpdateFeatureOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeature(
    DeleteFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new FeatureMonitor in a given project, location and FeatureGroup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureMonitor, CreateFeatureMonitorOperationMetadata>>
  createFeatureMonitor(CreateFeatureMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureMonitors', {
      if (request.featureMonitorId != null)
        'featureMonitorId': request.featureMonitorId!,
    });
    final response = await _client.post(url, body: request.featureMonitor);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureMonitor.fromJson,
        CreateFeatureMonitorOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single FeatureMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureMonitor> getFeatureMonitor(
    GetFeatureMonitorRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureMonitor.fromJson(response);
  }

  /// Lists FeatureGroups in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureMonitorsResponse> listFeatureMonitors(
    ListFeatureMonitorsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featureMonitors', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListFeatureMonitorsResponse.fromJson(response);
  }

  /// Updates the parameters of a single FeatureMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<FeatureMonitor, UpdateFeatureMonitorOperationMetadata>>
  updateFeatureMonitor(UpdateFeatureMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.featureMonitor.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.featureMonitor);
    return Operation.fromJson(
      response,
      OperationHelper(
        FeatureMonitor.fromJson,
        UpdateFeatureMonitorOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single FeatureMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteFeatureMonitor(DeleteFeatureMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new feature monitor job.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureMonitorJob> createFeatureMonitorJob(
    CreateFeatureMonitorJobRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureMonitorJobs', {
          if (request.featureMonitorJobId != null)
            'featureMonitorJobId': '${request.featureMonitorJobId}',
        });
    final response = await _client.post(url, body: request.featureMonitorJob);
    return FeatureMonitorJob.fromJson(response);
  }

  /// Get a feature monitor job.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FeatureMonitorJob> getFeatureMonitorJob(
    GetFeatureMonitorJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return FeatureMonitorJob.fromJson(response);
  }

  /// List feature monitor jobs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeatureMonitorJobsResponse> listFeatureMonitorJobs(
    ListFeatureMonitorJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/featureMonitorJobs', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.orderBy != null) 'orderBy': request.orderBy!,
        });
    final response = await _client.get(url);
    return ListFeatureMonitorJobsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for serving online feature values.
final class FeaturestoreOnlineServingService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeaturestoreOnlineServingService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeaturestoreOnlineServingService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeaturestoreOnlineServingService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeaturestoreOnlineServingService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeaturestoreOnlineServingService.fromApiKey([String? apiKey]) {
    return FeaturestoreOnlineServingService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Reads Feature values of a specific entity of an EntityType. For reading
  /// feature values of multiple entities of an EntityType, please use
  /// StreamingReadFeatureValues.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadFeatureValuesResponse> readFeatureValues(
    ReadFeatureValuesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:readFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return ReadFeatureValuesResponse.fromJson(response);
  }

  /// Reads Feature values for multiple entities. Depending on their size, data
  /// for different entities may be broken
  /// up across multiple responses.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<ReadFeatureValuesResponse> streamingReadFeatureValues(
    StreamingReadFeatureValuesRequest request,
  ) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:streamingReadFeatureValues',
    );
    return _client
        .postStreaming(url, body: request)
        .map(ReadFeatureValuesResponse.fromJson);
  }

  /// Writes Feature values of one or more entities of an EntityType.
  ///
  /// The Feature values are merged into existing entities if any. The Feature
  /// values to be written must have timestamp within the online storage
  /// retention.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<WriteFeatureValuesResponse> writeFeatureValues(
    WriteFeatureValuesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:writeFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return WriteFeatureValuesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The service that handles CRUD and List for resources for Featurestore.
final class FeaturestoreService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FeaturestoreService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FeaturestoreService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FeaturestoreService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FeaturestoreService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FeaturestoreService.fromApiKey([String? apiKey]) {
    return FeaturestoreService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a new Featurestore in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Featurestore, CreateFeaturestoreOperationMetadata>>
  createFeaturestore(CreateFeaturestoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featurestores', {
      if (request.featurestoreId != null)
        'featurestoreId': request.featurestoreId!,
    });
    final response = await _client.post(url, body: request.featurestore);
    return Operation.fromJson(
      response,
      OperationHelper(
        Featurestore.fromJson,
        CreateFeaturestoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single Featurestore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Featurestore> getFeaturestore(GetFeaturestoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Featurestore.fromJson(response);
  }

  /// Lists Featurestores in a given project and location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeaturestoresResponse> listFeaturestores(
    ListFeaturestoresRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/featurestores', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListFeaturestoresResponse.fromJson(response);
  }

  /// Updates the parameters of a single Featurestore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Featurestore, UpdateFeaturestoreOperationMetadata>>
  updateFeaturestore(UpdateFeaturestoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.featurestore.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.featurestore);
    return Operation.fromJson(
      response,
      OperationHelper(
        Featurestore.fromJson,
        UpdateFeaturestoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a single Featurestore. The Featurestore must not contain any
  /// EntityTypes or `force` must be set to true for the request to succeed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeaturestore(
    DeleteFeaturestoreRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new EntityType in a given Featurestore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<EntityType, CreateEntityTypeOperationMetadata>>
  createEntityType(CreateEntityTypeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/entityTypes', {
      if (request.entityTypeId != null) 'entityTypeId': request.entityTypeId!,
    });
    final response = await _client.post(url, body: request.entityType);
    return Operation.fromJson(
      response,
      OperationHelper(
        EntityType.fromJson,
        CreateEntityTypeOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EntityType> getEntityType(GetEntityTypeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return EntityType.fromJson(response);
  }

  /// Lists EntityTypes in a given Featurestore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListEntityTypesResponse> listEntityTypes(
    ListEntityTypesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/entityTypes', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListEntityTypesResponse.fromJson(response);
  }

  /// Updates the parameters of a single EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EntityType> updateEntityType(UpdateEntityTypeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.entityType.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.entityType);
    return EntityType.fromJson(response);
  }

  /// Deletes a single EntityType. The EntityType must not have any Features
  /// or `force` must be set to true for the request to succeed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteEntityType(
    DeleteEntityTypeRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a new Feature in a given EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Feature, CreateFeatureOperationMetadata>> createFeature(
    CreateFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/features', {
      if (request.featureId != null) 'featureId': request.featureId!,
    });
    final response = await _client.post(url, body: request.feature);
    return Operation.fromJson(
      response,
      OperationHelper(
        Feature.fromJson,
        CreateFeatureOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a batch of Features in a given EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<BatchCreateFeaturesResponse, BatchCreateFeaturesOperationMetadata>
  >
  batchCreateFeatures(BatchCreateFeaturesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/features:batchCreate',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchCreateFeaturesResponse.fromJson,
        BatchCreateFeaturesOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Feature> getFeature(GetFeatureRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.featureStatsAndAnomalySpec?.latestStatsCount != null)
        'featureStatsAndAnomalySpec.latestStatsCount':
            '${request.featureStatsAndAnomalySpec?.latestStatsCount}',
      if (request
              .featureStatsAndAnomalySpec
              ?.statsTimeRange
              ?.startTime
              ?.seconds !=
          null)
        'featureStatsAndAnomalySpec.statsTimeRange.startTime.seconds':
            '${request.featureStatsAndAnomalySpec?.statsTimeRange?.startTime?.seconds}',
      if (request
              .featureStatsAndAnomalySpec
              ?.statsTimeRange
              ?.startTime
              ?.nanos !=
          null)
        'featureStatsAndAnomalySpec.statsTimeRange.startTime.nanos':
            '${request.featureStatsAndAnomalySpec?.statsTimeRange?.startTime?.nanos}',
      if (request
              .featureStatsAndAnomalySpec
              ?.statsTimeRange
              ?.endTime
              ?.seconds !=
          null)
        'featureStatsAndAnomalySpec.statsTimeRange.endTime.seconds':
            '${request.featureStatsAndAnomalySpec?.statsTimeRange?.endTime?.seconds}',
      if (request.featureStatsAndAnomalySpec?.statsTimeRange?.endTime?.nanos !=
          null)
        'featureStatsAndAnomalySpec.statsTimeRange.endTime.nanos':
            '${request.featureStatsAndAnomalySpec?.statsTimeRange?.endTime?.nanos}',
    });
    final response = await _client.get(url);
    return Feature.fromJson(response);
  }

  /// Lists Features in a given EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFeaturesResponse> listFeatures(ListFeaturesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/features', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
      if (request.latestStatsCount != null)
        'latestStatsCount': '${request.latestStatsCount}',
    });
    final response = await _client.get(url);
    return ListFeaturesResponse.fromJson(response);
  }

  /// Updates the parameters of a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Feature> updateFeature(UpdateFeatureRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.feature.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.feature);
    return Feature.fromJson(response);
  }

  /// Deletes a single Feature.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteFeature(
    DeleteFeatureRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Imports Feature values into the Featurestore from a source storage.
  ///
  /// The progress of the import is tracked by the returned operation. The
  /// imported features are guaranteed to be visible to subsequent read
  /// operations after the operation is marked as successfully done.
  ///
  /// If an import operation fails, the Feature values returned from
  /// reads and exports may be inconsistent. If consistency is
  /// required, the caller must retry the same import request again and wait till
  /// the new operation returned is marked as successfully done.
  ///
  /// There are also scenarios where the caller can cause inconsistency.
  ///
  ///  - Source data for import contains multiple distinct Feature values for
  ///    the same entity ID and timestamp.
  ///  - Source is modified during an import. This includes adding, updating, or
  ///  removing source data and/or metadata. Examples of updating metadata
  ///  include but are not limited to changing storage location, storage class,
  ///  or retention policy.
  ///  - Online serving cluster is under-provisioned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<ImportFeatureValuesResponse, ImportFeatureValuesOperationMetadata>
  >
  importFeatureValues(ImportFeatureValuesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:importFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ImportFeatureValuesResponse.fromJson,
        ImportFeatureValuesOperationMetadata.fromJson,
      ),
    );
  }

  /// Batch reads Feature values from a Featurestore.
  ///
  /// This API enables batch reading Feature values, where each read
  /// instance in the batch may read Feature values of entities from one or
  /// more EntityTypes. Point-in-time correctness is guaranteed for Feature
  /// values of each read instance as of each instance's read timestamp.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      BatchReadFeatureValuesResponse,
      BatchReadFeatureValuesOperationMetadata
    >
  >
  batchReadFeatureValues(BatchReadFeatureValuesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.featurestore}:batchReadFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchReadFeatureValuesResponse.fromJson,
        BatchReadFeatureValuesOperationMetadata.fromJson,
      ),
    );
  }

  /// Exports Feature values from all the entities of a target EntityType.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<ExportFeatureValuesResponse, ExportFeatureValuesOperationMetadata>
  >
  exportFeatureValues(ExportFeatureValuesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:exportFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExportFeatureValuesResponse.fromJson,
        ExportFeatureValuesOperationMetadata.fromJson,
      ),
    );
  }

  /// Delete Feature values from Featurestore.
  ///
  /// The progress of the deletion is tracked by the returned operation. The
  /// deleted feature values are guaranteed to be invisible to subsequent read
  /// operations after the operation is marked as successfully done.
  ///
  /// If a delete feature values operation fails, the feature values
  /// returned from reads and exports may be inconsistent. If consistency is
  /// required, the caller must retry the same delete request again and wait till
  /// the new operation returned is marked as successfully done.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<DeleteFeatureValuesResponse, DeleteFeatureValuesOperationMetadata>
  >
  deleteFeatureValues(DeleteFeatureValuesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.entityType}:deleteFeatureValues',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeleteFeatureValuesResponse.fromJson,
        DeleteFeatureValuesOperationMetadata.fromJson,
      ),
    );
  }

  /// Searches Features matching a query in a given project.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchFeaturesResponse> searchFeatures(
    SearchFeaturesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.location}/featurestores:searchFeatures',
      {
        if (request.query != null) 'query': request.query!,
        if (request.pageSize != null) 'pageSize': '${request.pageSize}',
        if (request.pageToken != null) 'pageToken': request.pageToken!,
      },
    );
    final response = await _client.get(url);
    return SearchFeaturesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for managing Vertex AI's CachedContent resource.
final class GenAiCacheService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `GenAiCacheService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `GenAiCacheService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  GenAiCacheService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `GenAiCacheService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory GenAiCacheService.fromApiKey([String? apiKey]) {
    return GenAiCacheService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates cached content, this call will initialize the cached content in the
  /// data storage, and users need to pay for the cache data storage.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CachedContent> createCachedContent(
    CreateCachedContentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/cachedContents');
    final response = await _client.post(url, body: request.cachedContent);
    return CachedContent.fromJson(response);
  }

  /// Gets cached content configurations
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CachedContent> getCachedContent(
    GetCachedContentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return CachedContent.fromJson(response);
  }

  /// Updates cached content configurations
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CachedContent> updateCachedContent(
    UpdateCachedContentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.cachedContent.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.cachedContent);
    return CachedContent.fromJson(response);
  }

  /// Deletes cached content
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteCachedContent(DeleteCachedContentRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Lists cached contents in a project
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListCachedContentsResponse> listCachedContents(
    ListCachedContentsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/cachedContents', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListCachedContentsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing GenAI Tuning Jobs.
final class GenAiTuningService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `GenAiTuningService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `GenAiTuningService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  GenAiTuningService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `GenAiTuningService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory GenAiTuningService.fromApiKey([String? apiKey]) {
    return GenAiTuningService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a TuningJob. A created TuningJob right away will be attempted to
  /// be run.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TuningJob> createTuningJob(CreateTuningJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tuningJobs');
    final response = await _client.post(url, body: request.tuningJob);
    return TuningJob.fromJson(response);
  }

  /// Gets a TuningJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TuningJob> getTuningJob(GetTuningJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TuningJob.fromJson(response);
  }

  /// Lists TuningJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTuningJobsResponse> listTuningJobs(
    ListTuningJobsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tuningJobs', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListTuningJobsResponse.fromJson(response);
  }

  /// Cancels a TuningJob.
  /// Starts asynchronous cancellation on the TuningJob. The server makes a best
  /// effort to cancel the job, but success is not guaranteed. Clients can use
  /// `GenAiTuningService.GetTuningJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On successful cancellation, the
  /// TuningJob is not deleted; instead it becomes a job with a
  /// `TuningJob.error` value
  /// with a `google.rpc.Status.code` of 1, corresponding
  /// to `Code.CANCELLED`, and
  /// `TuningJob.state` is set
  /// to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelTuningJob(CancelTuningJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Rebase a TunedModel.
  /// Creates a LongRunningOperation that takes a legacy Tuned GenAI model
  /// Reference and creates a TuningJob based on newly available model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<TuningJob, RebaseTunedModelOperationMetadata>>
  rebaseTunedModel(RebaseTunedModelRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/tuningJobs:rebaseTunedModel',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        TuningJob.fromJson,
        RebaseTunedModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's IndexEndpoints.
final class IndexEndpointService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `IndexEndpointService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `IndexEndpointService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  IndexEndpointService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `IndexEndpointService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory IndexEndpointService.fromApiKey([String? apiKey]) {
    return IndexEndpointService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<IndexEndpoint, CreateIndexEndpointOperationMetadata>>
  createIndexEndpoint(CreateIndexEndpointRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/indexEndpoints');
    final response = await _client.post(url, body: request.indexEndpoint);
    return Operation.fromJson(
      response,
      OperationHelper(
        IndexEndpoint.fromJson,
        CreateIndexEndpointOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<IndexEndpoint> getIndexEndpoint(
    GetIndexEndpointRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return IndexEndpoint.fromJson(response);
  }

  /// Lists IndexEndpoints in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListIndexEndpointsResponse> listIndexEndpoints(
    ListIndexEndpointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/indexEndpoints', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListIndexEndpointsResponse.fromJson(response);
  }

  /// Updates an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<IndexEndpoint> updateIndexEndpoint(
    UpdateIndexEndpointRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.indexEndpoint.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.indexEndpoint);
    return IndexEndpoint.fromJson(response);
  }

  /// Deletes an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteIndexEndpoint(DeleteIndexEndpointRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Deploys an Index into this IndexEndpoint, creating a DeployedIndex within
  /// it.
  /// Only non-empty Indexes can be deployed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DeployIndexResponse, DeployIndexOperationMetadata>>
  deployIndex(DeployIndexRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:deployIndex',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeployIndexResponse.fromJson,
        DeployIndexOperationMetadata.fromJson,
      ),
    );
  }

  /// Undeploys an Index from an IndexEndpoint, removing a DeployedIndex from it,
  /// and freeing all resources it's using.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<UndeployIndexResponse, UndeployIndexOperationMetadata>>
  undeployIndex(UndeployIndexRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:undeployIndex',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UndeployIndexResponse.fromJson,
        UndeployIndexOperationMetadata.fromJson,
      ),
    );
  }

  /// Update an existing DeployedIndex under an IndexEndpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<MutateDeployedIndexResponse, MutateDeployedIndexOperationMetadata>
  >
  mutateDeployedIndex(MutateDeployedIndexRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:mutateDeployedIndex',
    );
    final response = await _client.post(url, body: request.deployedIndex);
    return Operation.fromJson(
      response,
      OperationHelper(
        MutateDeployedIndexResponse.fromJson,
        MutateDeployedIndexOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI's Index resources.
final class IndexService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `IndexService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `IndexService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  IndexService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `IndexService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory IndexService.fromApiKey([String? apiKey]) {
    return IndexService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Index, CreateIndexOperationMetadata>> createIndex(
    CreateIndexRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/indexes');
    final response = await _client.post(url, body: request.index);
    return Operation.fromJson(
      response,
      OperationHelper(Index.fromJson, CreateIndexOperationMetadata.fromJson),
    );
  }

  /// Gets an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Index> getIndex(GetIndexRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Index.fromJson(response);
  }

  /// Imports an Index from an external source (e.g., BigQuery).
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Index, ImportIndexOperationMetadata>> importIndex(
    ImportIndexRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:import');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(Index.fromJson, ImportIndexOperationMetadata.fromJson),
    );
  }

  /// Lists Indexes in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListIndexesResponse> listIndexes(ListIndexesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/indexes', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListIndexesResponse.fromJson(response);
  }

  /// Updates an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Index, UpdateIndexOperationMetadata>> updateIndex(
    UpdateIndexRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.index.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.index);
    return Operation.fromJson(
      response,
      OperationHelper(Index.fromJson, UpdateIndexOperationMetadata.fromJson),
    );
  }

  /// Deletes an Index.
  /// An Index can only be deleted when all its
  /// `DeployedIndexes`
  /// had been undeployed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteIndex(
    DeleteIndexRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Add/update Datapoints into an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<UpsertDatapointsResponse> upsertDatapoints(
    UpsertDatapointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.index}:upsertDatapoints');
    final response = await _client.post(url, body: request);
    return UpsertDatapointsResponse.fromJson(response);
  }

  /// Remove Datapoints from an Index.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RemoveDatapointsResponse> removeDatapoints(
    RemoveDatapointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.index}:removeDatapoints');
    final response = await _client.post(url, body: request);
    return RemoveDatapointsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI's jobs.
final class JobService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `JobService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `JobService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  JobService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `JobService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory JobService.fromApiKey([String? apiKey]) {
    return JobService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a CustomJob. A created CustomJob right away
  /// will be attempted to be run.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CustomJob> createCustomJob(CreateCustomJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/customJobs');
    final response = await _client.post(url, body: request.customJob);
    return CustomJob.fromJson(response);
  }

  /// Gets a CustomJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CustomJob> getCustomJob(GetCustomJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return CustomJob.fromJson(response);
  }

  /// Lists CustomJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListCustomJobsResponse> listCustomJobs(
    ListCustomJobsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/customJobs', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListCustomJobsResponse.fromJson(response);
  }

  /// Deletes a CustomJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteCustomJob(
    DeleteCustomJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a CustomJob.
  /// Starts asynchronous cancellation on the CustomJob. The server
  /// makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use
  /// `JobService.GetCustomJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On successful cancellation,
  /// the CustomJob is not deleted; instead it becomes a job with
  /// a `CustomJob.error` value
  /// with a `google.rpc.Status.code` of 1, corresponding
  /// to `Code.CANCELLED`, and
  /// `CustomJob.state` is set
  /// to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelCustomJob(CancelCustomJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a DataLabelingJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DataLabelingJob> createDataLabelingJob(
    CreateDataLabelingJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/dataLabelingJobs');
    final response = await _client.post(url, body: request.dataLabelingJob);
    return DataLabelingJob.fromJson(response);
  }

  /// Gets a DataLabelingJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DataLabelingJob> getDataLabelingJob(
    GetDataLabelingJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return DataLabelingJob.fromJson(response);
  }

  /// Lists DataLabelingJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListDataLabelingJobsResponse> listDataLabelingJobs(
    ListDataLabelingJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/dataLabelingJobs', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.readMask?.paths != null)
            'readMask.paths': request.readMask?.paths!,
          if (request.orderBy != null) 'orderBy': request.orderBy!,
        });
    final response = await _client.get(url);
    return ListDataLabelingJobsResponse.fromJson(response);
  }

  /// Deletes a DataLabelingJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteDataLabelingJob(DeleteDataLabelingJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a DataLabelingJob. Success of cancellation is not guaranteed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelDataLabelingJob(
    CancelDataLabelingJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a HyperparameterTuningJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HyperparameterTuningJob> createHyperparameterTuningJob(
    CreateHyperparameterTuningJobRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/hyperparameterTuningJobs',
    );
    final response = await _client.post(
      url,
      body: request.hyperparameterTuningJob,
    );
    return HyperparameterTuningJob.fromJson(response);
  }

  /// Gets a HyperparameterTuningJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HyperparameterTuningJob> getHyperparameterTuningJob(
    GetHyperparameterTuningJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return HyperparameterTuningJob.fromJson(response);
  }

  /// Lists HyperparameterTuningJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListHyperparameterTuningJobsResponse> listHyperparameterTuningJobs(
    ListHyperparameterTuningJobsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/hyperparameterTuningJobs',
      {
        if (request.filter != null) 'filter': request.filter!,
        if (request.pageSize != null) 'pageSize': '${request.pageSize}',
        if (request.pageToken != null) 'pageToken': request.pageToken!,
        if (request.readMask?.paths != null)
          'readMask.paths': request.readMask?.paths!,
      },
    );
    final response = await _client.get(url);
    return ListHyperparameterTuningJobsResponse.fromJson(response);
  }

  /// Deletes a HyperparameterTuningJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteHyperparameterTuningJob(
    DeleteHyperparameterTuningJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a HyperparameterTuningJob.
  /// Starts asynchronous cancellation on the HyperparameterTuningJob. The server
  /// makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use
  /// `JobService.GetHyperparameterTuningJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On successful cancellation,
  /// the HyperparameterTuningJob is not deleted; instead it becomes a job with
  /// a
  /// `HyperparameterTuningJob.error`
  /// value with a `google.rpc.Status.code` of 1,
  /// corresponding to `Code.CANCELLED`, and
  /// `HyperparameterTuningJob.state`
  /// is set to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelHyperparameterTuningJob(
    CancelHyperparameterTuningJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a NasJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NasJob> createNasJob(CreateNasJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/nasJobs');
    final response = await _client.post(url, body: request.nasJob);
    return NasJob.fromJson(response);
  }

  /// Gets a NasJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NasJob> getNasJob(GetNasJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return NasJob.fromJson(response);
  }

  /// Lists NasJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNasJobsResponse> listNasJobs(ListNasJobsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/nasJobs', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListNasJobsResponse.fromJson(response);
  }

  /// Deletes a NasJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteNasJob(
    DeleteNasJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a NasJob.
  /// Starts asynchronous cancellation on the NasJob. The server
  /// makes a best effort to cancel the job, but success is not
  /// guaranteed. Clients can use
  /// `JobService.GetNasJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On successful cancellation,
  /// the NasJob is not deleted; instead it becomes a job with
  /// a `NasJob.error` value with a
  /// `google.rpc.Status.code` of 1, corresponding to
  /// `Code.CANCELLED`, and
  /// `NasJob.state` is set to
  /// `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelNasJob(CancelNasJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Gets a NasTrialDetail.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NasTrialDetail> getNasTrialDetail(
    GetNasTrialDetailRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return NasTrialDetail.fromJson(response);
  }

  /// List top NasTrialDetails of a NasJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNasTrialDetailsResponse> listNasTrialDetails(
    ListNasTrialDetailsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/nasTrialDetails', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListNasTrialDetailsResponse.fromJson(response);
  }

  /// Creates a BatchPredictionJob. A BatchPredictionJob once created will
  /// right away be attempted to start.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchPredictionJob> createBatchPredictionJob(
    CreateBatchPredictionJobRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/batchPredictionJobs',
    );
    final response = await _client.post(url, body: request.batchPredictionJob);
    return BatchPredictionJob.fromJson(response);
  }

  /// Gets a BatchPredictionJob
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchPredictionJob> getBatchPredictionJob(
    GetBatchPredictionJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return BatchPredictionJob.fromJson(response);
  }

  /// Lists BatchPredictionJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListBatchPredictionJobsResponse> listBatchPredictionJobs(
    ListBatchPredictionJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/batchPredictionJobs', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.readMask?.paths != null)
            'readMask.paths': request.readMask?.paths!,
        });
    final response = await _client.get(url);
    return ListBatchPredictionJobsResponse.fromJson(response);
  }

  /// Deletes a BatchPredictionJob. Can only be called on jobs that already
  /// finished.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteBatchPredictionJob(DeleteBatchPredictionJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a BatchPredictionJob.
  ///
  /// Starts asynchronous cancellation on the BatchPredictionJob. The server
  /// makes the best effort to cancel the job, but success is not
  /// guaranteed. Clients can use
  /// `JobService.GetBatchPredictionJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// job completed despite cancellation. On a successful cancellation,
  /// the BatchPredictionJob is not deleted;instead its
  /// `BatchPredictionJob.state`
  /// is set to `CANCELLED`. Any files already outputted by the job are not
  /// deleted.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelBatchPredictionJob(
    CancelBatchPredictionJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a ModelDeploymentMonitoringJob. It will run periodically on a
  /// configured interval.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelDeploymentMonitoringJob> createModelDeploymentMonitoringJob(
    CreateModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/modelDeploymentMonitoringJobs',
    );
    final response = await _client.post(
      url,
      body: request.modelDeploymentMonitoringJob,
    );
    return ModelDeploymentMonitoringJob.fromJson(response);
  }

  /// Searches Model Monitoring Statistics generated within a given time window.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchModelDeploymentMonitoringStatsAnomaliesResponse>
  searchModelDeploymentMonitoringStatsAnomalies(
    SearchModelDeploymentMonitoringStatsAnomaliesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.modelDeploymentMonitoringJob}:searchModelDeploymentMonitoringStatsAnomalies',
    );
    final response = await _client.post(url, body: request);
    return SearchModelDeploymentMonitoringStatsAnomaliesResponse.fromJson(
      response,
    );
  }

  /// Gets a ModelDeploymentMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelDeploymentMonitoringJob> getModelDeploymentMonitoringJob(
    GetModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelDeploymentMonitoringJob.fromJson(response);
  }

  /// Lists ModelDeploymentMonitoringJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelDeploymentMonitoringJobsResponse>
  listModelDeploymentMonitoringJobs(
    ListModelDeploymentMonitoringJobsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/modelDeploymentMonitoringJobs',
      {
        if (request.filter != null) 'filter': request.filter!,
        if (request.pageSize != null) 'pageSize': '${request.pageSize}',
        if (request.pageToken != null) 'pageToken': request.pageToken!,
        if (request.readMask?.paths != null)
          'readMask.paths': request.readMask?.paths!,
      },
    );
    final response = await _client.get(url);
    return ListModelDeploymentMonitoringJobsResponse.fromJson(response);
  }

  /// Updates a ModelDeploymentMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      ModelDeploymentMonitoringJob,
      UpdateModelDeploymentMonitoringJobOperationMetadata
    >
  >
  updateModelDeploymentMonitoringJob(
    UpdateModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.modelDeploymentMonitoringJob.name}',
      {
        if (request.updateMask?.paths != null)
          'updateMask.paths': request.updateMask?.paths!,
      },
    );
    final response = await _client.patch(
      url,
      body: request.modelDeploymentMonitoringJob,
    );
    return Operation.fromJson(
      response,
      OperationHelper(
        ModelDeploymentMonitoringJob.fromJson,
        UpdateModelDeploymentMonitoringJobOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a ModelDeploymentMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteModelDeploymentMonitoringJob(
    DeleteModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Pauses a ModelDeploymentMonitoringJob. If the job is running, the server
  /// makes a best effort to cancel the job. Will mark
  /// `ModelDeploymentMonitoringJob.state`
  /// to 'PAUSED'.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> pauseModelDeploymentMonitoringJob(
    PauseModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:pause');
    await _client.post(url, body: request);
  }

  /// Resumes a paused ModelDeploymentMonitoringJob. It will start to run from
  /// next scheduled time. A deleted ModelDeploymentMonitoringJob can't be
  /// resumed.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> resumeModelDeploymentMonitoringJob(
    ResumeModelDeploymentMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:resume');
    await _client.post(url, body: request);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for LLM related utility functions.
final class LlmUtilityService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `LlmUtilityService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `LlmUtilityService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  LlmUtilityService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `LlmUtilityService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory LlmUtilityService.fromApiKey([String? apiKey]) {
    return LlmUtilityService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Return a list of tokens based on the input text.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ComputeTokensResponse> computeTokens(
    ComputeTokensRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:computeTokens');
    final response = await _client.post(url, body: request);
    return ComputeTokensResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// MatchService is a Google managed service for efficient vector similarity
/// search at scale.
final class MatchService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `MatchService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `MatchService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  MatchService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `MatchService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory MatchService.fromApiKey([String? apiKey]) {
    return MatchService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Finds the nearest neighbors of each vector within the request.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FindNeighborsResponse> findNeighbors(
    FindNeighborsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:findNeighbors',
    );
    final response = await _client.post(url, body: request);
    return FindNeighborsResponse.fromJson(response);
  }

  /// Reads the datapoints/vectors of the given IDs.
  /// A maximum of 1000 datapoints can be retrieved in a batch.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadIndexDatapointsResponse> readIndexDatapoints(
    ReadIndexDatapointsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.indexEndpoint}:readIndexDatapoints',
    );
    final response = await _client.post(url, body: request);
    return ReadIndexDatapointsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing memories for LLM applications.
final class MemoryBankService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `MemoryBankService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `MemoryBankService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  MemoryBankService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `MemoryBankService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory MemoryBankService.fromApiKey([String? apiKey]) {
    return MemoryBankService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Create a Memory.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Memory, CreateMemoryOperationMetadata>> createMemory(
    CreateMemoryRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/memories');
    final response = await _client.post(url, body: request.memory);
    return Operation.fromJson(
      response,
      OperationHelper(Memory.fromJson, CreateMemoryOperationMetadata.fromJson),
    );
  }

  /// Get a Memory.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Memory> getMemory(GetMemoryRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Memory.fromJson(response);
  }

  /// Update a Memory.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Memory, UpdateMemoryOperationMetadata>> updateMemory(
    UpdateMemoryRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.memory.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.memory);
    return Operation.fromJson(
      response,
      OperationHelper(Memory.fromJson, UpdateMemoryOperationMetadata.fromJson),
    );
  }

  /// List Memories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListMemoriesResponse> listMemories(ListMemoriesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/memories', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListMemoriesResponse.fromJson(response);
  }

  /// Delete a Memory.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteMemoryOperationMetadata>> deleteMemory(
    DeleteMemoryRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteMemoryOperationMetadata.fromJson,
      ),
    );
  }

  /// Generate memories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<GenerateMemoriesResponse, GenerateMemoriesOperationMetadata>>
  generateMemories(GenerateMemoriesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/memories:generate',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        GenerateMemoriesResponse.fromJson,
        GenerateMemoriesOperationMetadata.fromJson,
      ),
    );
  }

  /// Retrieve memories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RetrieveMemoriesResponse> retrieveMemories(
    RetrieveMemoriesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/memories:retrieve',
    );
    final response = await _client.post(url, body: request);
    return RetrieveMemoriesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Service for reading and writing metadata entries.
final class MetadataService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `MetadataService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `MetadataService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  MetadataService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `MetadataService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory MetadataService.fromApiKey([String? apiKey]) {
    return MetadataService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Initializes a MetadataStore, including allocation of resources.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<MetadataStore, CreateMetadataStoreOperationMetadata>>
  createMetadataStore(CreateMetadataStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/metadataStores', {
      if (request.metadataStoreId != null)
        'metadataStoreId': request.metadataStoreId!,
    });
    final response = await _client.post(url, body: request.metadataStore);
    return Operation.fromJson(
      response,
      OperationHelper(
        MetadataStore.fromJson,
        CreateMetadataStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Retrieves a specific MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<MetadataStore> getMetadataStore(
    GetMetadataStoreRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return MetadataStore.fromJson(response);
  }

  /// Lists MetadataStores for a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListMetadataStoresResponse> listMetadataStores(
    ListMetadataStoresRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/metadataStores', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListMetadataStoresResponse.fromJson(response);
  }

  /// Deletes a single MetadataStore and all its child resources (Artifacts,
  /// Executions, and Contexts).
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteMetadataStoreOperationMetadata>>
  deleteMetadataStore(DeleteMetadataStoreRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteMetadataStoreOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates an Artifact associated with a MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Artifact> createArtifact(CreateArtifactRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/artifacts', {
      if (request.artifactId != null) 'artifactId': request.artifactId!,
    });
    final response = await _client.post(url, body: request.artifact);
    return Artifact.fromJson(response);
  }

  /// Retrieves a specific Artifact.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Artifact> getArtifact(GetArtifactRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Artifact.fromJson(response);
  }

  /// Lists Artifacts in the MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListArtifactsResponse> listArtifacts(
    ListArtifactsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/artifacts', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.filter != null) 'filter': request.filter!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListArtifactsResponse.fromJson(response);
  }

  /// Updates a stored Artifact.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Artifact> updateArtifact(UpdateArtifactRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.artifact.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
      if (request.allowMissing != null)
        'allowMissing': '${request.allowMissing}',
    });
    final response = await _client.patch(url, body: request.artifact);
    return Artifact.fromJson(response);
  }

  /// Deletes an Artifact.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteArtifact(
    DeleteArtifactRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.etag != null) 'etag': request.etag!,
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Purges Artifacts.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<PurgeArtifactsResponse, PurgeArtifactsMetadata>>
  purgeArtifacts(PurgeArtifactsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/artifacts:purge');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PurgeArtifactsResponse.fromJson,
        PurgeArtifactsMetadata.fromJson,
      ),
    );
  }

  /// Creates a Context associated with a MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Context> createContext(CreateContextRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/contexts', {
      if (request.contextId != null) 'contextId': request.contextId!,
    });
    final response = await _client.post(url, body: request.context);
    return Context.fromJson(response);
  }

  /// Retrieves a specific Context.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Context> getContext(GetContextRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Context.fromJson(response);
  }

  /// Lists Contexts on the MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListContextsResponse> listContexts(ListContextsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/contexts', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.filter != null) 'filter': request.filter!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListContextsResponse.fromJson(response);
  }

  /// Updates a stored Context.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Context> updateContext(UpdateContextRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.context.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
      if (request.allowMissing != null)
        'allowMissing': '${request.allowMissing}',
    });
    final response = await _client.patch(url, body: request.context);
    return Context.fromJson(response);
  }

  /// Deletes a stored Context.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteContext(
    DeleteContextRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
      if (request.etag != null) 'etag': request.etag!,
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Purges Contexts.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<PurgeContextsResponse, PurgeContextsMetadata>> purgeContexts(
    PurgeContextsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/contexts:purge');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PurgeContextsResponse.fromJson,
        PurgeContextsMetadata.fromJson,
      ),
    );
  }

  /// Adds a set of Artifacts and Executions to a Context. If any of the
  /// Artifacts or Executions have already been added to a Context, they are
  /// simply skipped.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AddContextArtifactsAndExecutionsResponse>
  addContextArtifactsAndExecutions(
    AddContextArtifactsAndExecutionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.context}:addContextArtifactsAndExecutions',
    );
    final response = await _client.post(url, body: request);
    return AddContextArtifactsAndExecutionsResponse.fromJson(response);
  }

  /// Adds a set of Contexts as children to a parent Context. If any of the
  /// child Contexts have already been added to the parent Context, they are
  /// simply skipped. If this call would create a cycle or cause any Context to
  /// have more than 10 parents, the request will fail with an INVALID_ARGUMENT
  /// error.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AddContextChildrenResponse> addContextChildren(
    AddContextChildrenRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.context}:addContextChildren',
    );
    final response = await _client.post(url, body: request);
    return AddContextChildrenResponse.fromJson(response);
  }

  /// Remove a set of children contexts from a parent Context. If any of the
  /// child Contexts were NOT added to the parent Context, they are
  /// simply skipped.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RemoveContextChildrenResponse> removeContextChildren(
    RemoveContextChildrenRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.context}:removeContextChildren',
    );
    final response = await _client.post(url, body: request);
    return RemoveContextChildrenResponse.fromJson(response);
  }

  /// Retrieves Artifacts and Executions within the specified Context, connected
  /// by Event edges and returned as a LineageSubgraph.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<LineageSubgraph> queryContextLineageSubgraph(
    QueryContextLineageSubgraphRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.context}:queryContextLineageSubgraph',
    );
    final response = await _client.get(url);
    return LineageSubgraph.fromJson(response);
  }

  /// Creates an Execution associated with a MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Execution> createExecution(CreateExecutionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/executions', {
      if (request.executionId != null) 'executionId': request.executionId!,
    });
    final response = await _client.post(url, body: request.execution);
    return Execution.fromJson(response);
  }

  /// Retrieves a specific Execution.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Execution> getExecution(GetExecutionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Execution.fromJson(response);
  }

  /// Lists Executions in the MetadataStore.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListExecutionsResponse> listExecutions(
    ListExecutionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/executions', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.filter != null) 'filter': request.filter!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListExecutionsResponse.fromJson(response);
  }

  /// Updates a stored Execution.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Execution> updateExecution(UpdateExecutionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.execution.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
      if (request.allowMissing != null)
        'allowMissing': '${request.allowMissing}',
    });
    final response = await _client.patch(url, body: request.execution);
    return Execution.fromJson(response);
  }

  /// Deletes an Execution.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteExecution(
    DeleteExecutionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.etag != null) 'etag': request.etag!,
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Purges Executions.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<PurgeExecutionsResponse, PurgeExecutionsMetadata>>
  purgeExecutions(PurgeExecutionsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/executions:purge');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PurgeExecutionsResponse.fromJson,
        PurgeExecutionsMetadata.fromJson,
      ),
    );
  }

  /// Adds Events to the specified Execution. An Event indicates whether an
  /// Artifact was used as an input or output for an Execution. If an Event
  /// already exists between the Execution and the Artifact, the Event is
  /// skipped.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AddExecutionEventsResponse> addExecutionEvents(
    AddExecutionEventsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.execution}:addExecutionEvents',
    );
    final response = await _client.post(url, body: request);
    return AddExecutionEventsResponse.fromJson(response);
  }

  /// Obtains the set of input and output Artifacts for this Execution, in the
  /// form of LineageSubgraph that also contains the Execution and connecting
  /// Events.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<LineageSubgraph> queryExecutionInputsAndOutputs(
    QueryExecutionInputsAndOutputsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.execution}:queryExecutionInputsAndOutputs',
    );
    final response = await _client.get(url);
    return LineageSubgraph.fromJson(response);
  }

  /// Creates a MetadataSchema.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<MetadataSchema> createMetadataSchema(
    CreateMetadataSchemaRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/metadataSchemas', {
      if (request.metadataSchemaId != null)
        'metadataSchemaId': request.metadataSchemaId!,
    });
    final response = await _client.post(url, body: request.metadataSchema);
    return MetadataSchema.fromJson(response);
  }

  /// Retrieves a specific MetadataSchema.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<MetadataSchema> getMetadataSchema(
    GetMetadataSchemaRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return MetadataSchema.fromJson(response);
  }

  /// Lists MetadataSchemas.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListMetadataSchemasResponse> listMetadataSchemas(
    ListMetadataSchemasRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/metadataSchemas', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.filter != null) 'filter': request.filter!,
    });
    final response = await _client.get(url);
    return ListMetadataSchemasResponse.fromJson(response);
  }

  /// Retrieves lineage of an Artifact represented through Artifacts and
  /// Executions connected by Event edges and returned as a LineageSubgraph.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<LineageSubgraph> queryArtifactLineageSubgraph(
    QueryArtifactLineageSubgraphRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.artifact}:queryArtifactLineageSubgraph',
      {
        if (request.maxHops != null) 'maxHops': '${request.maxHops}',
        if (request.filter != null) 'filter': request.filter!,
      },
    );
    final response = await _client.get(url);
    return LineageSubgraph.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service that migrates resources from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
final class MigrationService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `MigrationService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `MigrationService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  MigrationService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `MigrationService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory MigrationService.fromApiKey([String? apiKey]) {
    return MigrationService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Searches all of the resources in automl.googleapis.com,
  /// datalabeling.googleapis.com and ml.googleapis.com that can be migrated to
  /// Vertex AI's given location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchMigratableResourcesResponse> searchMigratableResources(
    SearchMigratableResourcesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/migratableResources:search',
    );
    final response = await _client.post(url, body: request);
    return SearchMigratableResourcesResponse.fromJson(response);
  }

  /// Batch migrates resources from ml.googleapis.com, automl.googleapis.com,
  /// and datalabeling.googleapis.com to Vertex AI.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      BatchMigrateResourcesResponse,
      BatchMigrateResourcesOperationMetadata
    >
  >
  batchMigrateResources(BatchMigrateResourcesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/migratableResources:batchMigrate',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchMigrateResourcesResponse.fromJson,
        BatchMigrateResourcesOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The interface of Model Garden Service.
final class ModelGardenService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ModelGardenService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ModelGardenService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ModelGardenService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ModelGardenService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ModelGardenService.fromApiKey([String? apiKey]) {
    return ModelGardenService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Gets a Model Garden publisher model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PublisherModel> getPublisherModel(
    GetPublisherModelRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.languageCode != null) 'languageCode': request.languageCode!,
      if (request.view != null) 'view': request.view!.value,
      if (request.isHuggingFaceModel != null)
        'isHuggingFaceModel': '${request.isHuggingFaceModel}',
      if (request.huggingFaceToken != null)
        'huggingFaceToken': request.huggingFaceToken!,
      if (request.includeEquivalentModelGardenModelDeploymentConfigs != null)
        'includeEquivalentModelGardenModelDeploymentConfigs':
            '${request.includeEquivalentModelGardenModelDeploymentConfigs}',
    });
    final response = await _client.get(url);
    return PublisherModel.fromJson(response);
  }

  /// Lists publisher models in Model Garden.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListPublisherModelsResponse> listPublisherModels(
    ListPublisherModelsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/models', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.view != null) 'view': request.view!.value,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.languageCode != null) 'languageCode': request.languageCode!,
      if (request.listAllVersions != null)
        'listAllVersions': '${request.listAllVersions}',
    });
    final response = await _client.get(url);
    return ListPublisherModelsResponse.fromJson(response);
  }

  /// Deploys a model to a new endpoint.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<DeployResponse, DeployOperationMetadata>> deploy(
    DeployRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.destination}:deploy');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeployResponse.fromJson,
        DeployOperationMetadata.fromJson,
      ),
    );
  }

  /// Deploys publisher models.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      DeployPublisherModelResponse,
      DeployPublisherModelOperationMetadata
    >
  >
  deployPublisherModel(DeployPublisherModelRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.destination}:deployPublisherModel',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        DeployPublisherModelResponse.fromJson,
        DeployPublisherModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Exports a publisher model to a user provided Google Cloud Storage bucket.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      ExportPublisherModelResponse,
      ExportPublisherModelOperationMetadata
    >
  >
  exportPublisherModel(ExportPublisherModelRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/${request.name}:export',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExportPublisherModelResponse.fromJson,
        ExportPublisherModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Checks the EULA acceptance status of a publisher model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PublisherModelEulaAcceptance> checkPublisherModelEulaAcceptance(
    CheckPublisherModelEulaAcceptanceRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/modelGardenEula:check',
    );
    final response = await _client.post(url, body: request);
    return PublisherModelEulaAcceptance.fromJson(response);
  }

  /// Accepts the EULA acceptance status of a publisher model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PublisherModelEulaAcceptance> acceptPublisherModelEula(
    AcceptPublisherModelEulaRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/modelGardenEula:accept',
    );
    final response = await _client.post(url, body: request);
    return PublisherModelEulaAcceptance.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI Model moitoring. This includes
/// `ModelMonitor` resources, `ModelMonitoringJob` resources.
final class ModelMonitoringService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ModelMonitoringService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ModelMonitoringService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ModelMonitoringService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ModelMonitoringService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ModelMonitoringService.fromApiKey([String? apiKey]) {
    return ModelMonitoringService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Creates a ModelMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ModelMonitor, CreateModelMonitorOperationMetadata>>
  createModelMonitor(CreateModelMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/modelMonitors', {
      if (request.modelMonitorId != null)
        'modelMonitorId': request.modelMonitorId!,
    });
    final response = await _client.post(url, body: request.modelMonitor);
    return Operation.fromJson(
      response,
      OperationHelper(
        ModelMonitor.fromJson,
        CreateModelMonitorOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a ModelMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ModelMonitor, UpdateModelMonitorOperationMetadata>>
  updateModelMonitor(UpdateModelMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.modelMonitor.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.modelMonitor);
    return Operation.fromJson(
      response,
      OperationHelper(
        ModelMonitor.fromJson,
        UpdateModelMonitorOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a ModelMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelMonitor> getModelMonitor(GetModelMonitorRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelMonitor.fromJson(response);
  }

  /// Lists ModelMonitors in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelMonitorsResponse> listModelMonitors(
    ListModelMonitorsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/modelMonitors', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListModelMonitorsResponse.fromJson(response);
  }

  /// Deletes a ModelMonitor.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteModelMonitor(
    DeleteModelMonitorRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a ModelMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelMonitoringJob> createModelMonitoringJob(
    CreateModelMonitoringJobRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/modelMonitoringJobs', {
          if (request.modelMonitoringJobId != null)
            'modelMonitoringJobId': request.modelMonitoringJobId!,
        });
    final response = await _client.post(url, body: request.modelMonitoringJob);
    return ModelMonitoringJob.fromJson(response);
  }

  /// Gets a ModelMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelMonitoringJob> getModelMonitoringJob(
    GetModelMonitoringJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelMonitoringJob.fromJson(response);
  }

  /// Lists ModelMonitoringJobs.
  /// Callers may choose to read across multiple Monitors as per
  /// [AIP-159](https://google.aip.dev/159) by using '-' (the hyphen or dash
  /// character) as a wildcard character instead of modelMonitor id in the
  /// parent. Format
  /// `projects/{project_id}/locations/{location}/moodelMonitors/-/modelMonitoringJobs`
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelMonitoringJobsResponse> listModelMonitoringJobs(
    ListModelMonitoringJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/modelMonitoringJobs', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.readMask?.paths != null)
            'readMask.paths': request.readMask?.paths!,
        });
    final response = await _client.get(url);
    return ListModelMonitoringJobsResponse.fromJson(response);
  }

  /// Deletes a ModelMonitoringJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteModelMonitoringJob(DeleteModelMonitoringJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Searches Model Monitoring Stats generated within a given time window.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchModelMonitoringStatsResponse> searchModelMonitoringStats(
    SearchModelMonitoringStatsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.modelMonitor}:searchModelMonitoringStats',
    );
    final response = await _client.post(url, body: request);
    return SearchModelMonitoringStatsResponse.fromJson(response);
  }

  /// Returns the Model Monitoring alerts.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SearchModelMonitoringAlertsResponse> searchModelMonitoringAlerts(
    SearchModelMonitoringAlertsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.modelMonitor}:searchModelMonitoringAlerts',
    );
    final response = await _client.post(url, body: request);
    return SearchModelMonitoringAlertsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's machine learning Models.
final class ModelService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ModelService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ModelService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ModelService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ModelService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ModelService.fromApiKey([String? apiKey]) {
    return ModelService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Uploads a Model artifact into Vertex AI.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<UploadModelResponse, UploadModelOperationMetadata>>
  uploadModel(UploadModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/models:upload');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UploadModelResponse.fromJson,
        UploadModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Model> getModel(GetModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Model.fromJson(response);
  }

  /// Lists Models in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelsResponse> listModels(ListModelsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/models', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListModelsResponse.fromJson(response);
  }

  /// Lists versions of the specified model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelVersionsResponse> listModelVersions(
    ListModelVersionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:listVersions', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.filter != null) 'filter': request.filter!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListModelVersionsResponse.fromJson(response);
  }

  /// Lists checkpoints of the specified model version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelVersionCheckpointsResponse> listModelVersionCheckpoints(
    ListModelVersionCheckpointsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:listCheckpoints', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListModelVersionCheckpointsResponse.fromJson(response);
  }

  /// Updates a Model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Model> updateModel(UpdateModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.model.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.model);
    return Model.fromJson(response);
  }

  /// Incrementally update the dataset used for an examples model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      UpdateExplanationDatasetResponse,
      UpdateExplanationDatasetOperationMetadata
    >
  >
  updateExplanationDataset(UpdateExplanationDatasetRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.model}:updateExplanationDataset',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UpdateExplanationDatasetResponse.fromJson,
        UpdateExplanationDatasetOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a Model.
  ///
  /// A model cannot be deleted if any
  /// `Endpoint` resource has a
  /// `DeployedModel` based on the
  /// model in its
  /// `deployed_models`
  /// field.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteModel(
    DeleteModelRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a Model version.
  ///
  /// Model version can only be deleted if there are no
  /// `DeployedModels` created
  /// from it. Deleting the only version in the Model is not allowed. Use
  /// `DeleteModel` for
  /// deleting the Model instead.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteModelVersion(
    DeleteModelVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:deleteVersion');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Merges a set of aliases for a Model version.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Model> mergeVersionAliases(MergeVersionAliasesRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.name}:mergeVersionAliases',
    );
    final response = await _client.post(url, body: request);
    return Model.fromJson(response);
  }

  /// Exports a trained, exportable Model to a location specified by the
  /// user. A Model is considered to be exportable if it has at least one
  /// [supported export
  /// format][google.cloud.aiplatform.v1beta1.Model.supported_export_formats].
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ExportModelResponse, ExportModelOperationMetadata>>
  exportModel(ExportModelRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:export');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ExportModelResponse.fromJson,
        ExportModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Copies an already existing Vertex AI Model into the specified Location.
  /// The source Model must exist in the same Project.
  /// When copying custom Models, the users themselves are responsible for
  /// `Model.metadata` content to
  /// be region-agnostic, as well as making sure that any resources (e.g. files)
  /// it depends on remain accessible.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<CopyModelResponse, CopyModelOperationMetadata>> copyModel(
    CopyModelRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/models:copy');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        CopyModelResponse.fromJson,
        CopyModelOperationMetadata.fromJson,
      ),
    );
  }

  /// Imports an externally generated ModelEvaluation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelEvaluation> importModelEvaluation(
    ImportModelEvaluationRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/evaluations:import',
    );
    final response = await _client.post(url, body: request);
    return ModelEvaluation.fromJson(response);
  }

  /// Imports a list of externally generated ModelEvaluationSlice.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchImportModelEvaluationSlicesResponse>
  batchImportModelEvaluationSlices(
    BatchImportModelEvaluationSlicesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/slices:batchImport',
    );
    final response = await _client.post(url, body: request);
    return BatchImportModelEvaluationSlicesResponse.fromJson(response);
  }

  /// Imports a list of externally generated EvaluatedAnnotations.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchImportEvaluatedAnnotationsResponse>
  batchImportEvaluatedAnnotations(
    BatchImportEvaluatedAnnotationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:batchImport');
    final response = await _client.post(url, body: request);
    return BatchImportEvaluatedAnnotationsResponse.fromJson(response);
  }

  /// Gets a ModelEvaluation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelEvaluation> getModelEvaluation(
    GetModelEvaluationRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelEvaluation.fromJson(response);
  }

  /// Lists ModelEvaluations in a Model.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelEvaluationsResponse> listModelEvaluations(
    ListModelEvaluationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/evaluations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListModelEvaluationsResponse.fromJson(response);
  }

  /// Gets a ModelEvaluationSlice.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModelEvaluationSlice> getModelEvaluationSlice(
    GetModelEvaluationSliceRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ModelEvaluationSlice.fromJson(response);
  }

  /// Lists ModelEvaluationSlices in a ModelEvaluation.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListModelEvaluationSlicesResponse> listModelEvaluationSlices(
    ListModelEvaluationSlicesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/slices', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListModelEvaluationSlicesResponse.fromJson(response);
  }

  /// Gets a Model's spec recommendations.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RecommendSpecResponse> recommendSpec(
    RecommendSpecRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:recommendSpec');
    final response = await _client.post(url, body: request);
    return RecommendSpecResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The interface for Vertex Notebook service (a.k.a. Colab on Workbench).
final class NotebookService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `NotebookService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `NotebookService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  NotebookService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `NotebookService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory NotebookService.fromApiKey([String? apiKey]) {
    return NotebookService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a NotebookRuntimeTemplate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      NotebookRuntimeTemplate,
      CreateNotebookRuntimeTemplateOperationMetadata
    >
  >
  createNotebookRuntimeTemplate(
    CreateNotebookRuntimeTemplateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/notebookRuntimeTemplates',
      {
        if (request.notebookRuntimeTemplateId != null)
          'notebookRuntimeTemplateId': request.notebookRuntimeTemplateId!,
      },
    );
    final response = await _client.post(
      url,
      body: request.notebookRuntimeTemplate,
    );
    return Operation.fromJson(
      response,
      OperationHelper(
        NotebookRuntimeTemplate.fromJson,
        CreateNotebookRuntimeTemplateOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a NotebookRuntimeTemplate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NotebookRuntimeTemplate> getNotebookRuntimeTemplate(
    GetNotebookRuntimeTemplateRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return NotebookRuntimeTemplate.fromJson(response);
  }

  /// Lists NotebookRuntimeTemplates in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNotebookRuntimeTemplatesResponse> listNotebookRuntimeTemplates(
    ListNotebookRuntimeTemplatesRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/notebookRuntimeTemplates',
      {
        if (request.filter != null) 'filter': request.filter!,
        if (request.pageSize != null) 'pageSize': '${request.pageSize}',
        if (request.pageToken != null) 'pageToken': request.pageToken!,
        if (request.readMask?.paths != null)
          'readMask.paths': request.readMask?.paths!,
        if (request.orderBy != null) 'orderBy': request.orderBy!,
      },
    );
    final response = await _client.get(url);
    return ListNotebookRuntimeTemplatesResponse.fromJson(response);
  }

  /// Deletes a NotebookRuntimeTemplate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteNotebookRuntimeTemplate(
    DeleteNotebookRuntimeTemplateRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a NotebookRuntimeTemplate.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NotebookRuntimeTemplate> updateNotebookRuntimeTemplate(
    UpdateNotebookRuntimeTemplateRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.notebookRuntimeTemplate.name}', {
          if (request.updateMask?.paths != null)
            'updateMask.paths': request.updateMask?.paths!,
        });
    final response = await _client.patch(
      url,
      body: request.notebookRuntimeTemplate,
    );
    return NotebookRuntimeTemplate.fromJson(response);
  }

  /// Assigns a NotebookRuntime to a user for a particular Notebook file. This
  /// method will either returns an existing assignment or generates a new one.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<NotebookRuntime, AssignNotebookRuntimeOperationMetadata>>
  assignNotebookRuntime(AssignNotebookRuntimeRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/notebookRuntimes:assign',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        NotebookRuntime.fromJson,
        AssignNotebookRuntimeOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NotebookRuntime> getNotebookRuntime(
    GetNotebookRuntimeRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return NotebookRuntime.fromJson(response);
  }

  /// Lists NotebookRuntimes in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNotebookRuntimesResponse> listNotebookRuntimes(
    ListNotebookRuntimesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/notebookRuntimes', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.readMask?.paths != null)
            'readMask.paths': request.readMask?.paths!,
          if (request.orderBy != null) 'orderBy': request.orderBy!,
        });
    final response = await _client.get(url);
    return ListNotebookRuntimesResponse.fromJson(response);
  }

  /// Deletes a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteNotebookRuntime(DeleteNotebookRuntimeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Upgrades a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      UpgradeNotebookRuntimeResponse,
      UpgradeNotebookRuntimeOperationMetadata
    >
  >
  upgradeNotebookRuntime(UpgradeNotebookRuntimeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:upgrade');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        UpgradeNotebookRuntimeResponse.fromJson,
        UpgradeNotebookRuntimeOperationMetadata.fromJson,
      ),
    );
  }

  /// Starts a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      StartNotebookRuntimeResponse,
      StartNotebookRuntimeOperationMetadata
    >
  >
  startNotebookRuntime(StartNotebookRuntimeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:start');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        StartNotebookRuntimeResponse.fromJson,
        StartNotebookRuntimeOperationMetadata.fromJson,
      ),
    );
  }

  /// Stops a NotebookRuntime.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<StopNotebookRuntimeResponse, StopNotebookRuntimeOperationMetadata>
  >
  stopNotebookRuntime(StopNotebookRuntimeRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:stop');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        StopNotebookRuntimeResponse.fromJson,
        StopNotebookRuntimeOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a NotebookExecutionJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<NotebookExecutionJob, CreateNotebookExecutionJobOperationMetadata>
  >
  createNotebookExecutionJob(CreateNotebookExecutionJobRequest request) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/notebookExecutionJobs', {
          if (request.notebookExecutionJobId != null)
            'notebookExecutionJobId': request.notebookExecutionJobId!,
        });
    final response = await _client.post(
      url,
      body: request.notebookExecutionJob,
    );
    return Operation.fromJson(
      response,
      OperationHelper(
        NotebookExecutionJob.fromJson,
        CreateNotebookExecutionJobOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a NotebookExecutionJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<NotebookExecutionJob> getNotebookExecutionJob(
    GetNotebookExecutionJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.view != null) 'view': request.view!.value,
    });
    final response = await _client.get(url);
    return NotebookExecutionJob.fromJson(response);
  }

  /// Lists NotebookExecutionJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListNotebookExecutionJobsResponse> listNotebookExecutionJobs(
    ListNotebookExecutionJobsRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/notebookExecutionJobs', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.orderBy != null) 'orderBy': request.orderBy!,
          if (request.view != null) 'view': request.view!.value,
        });
    final response = await _client.get(url);
    return ListNotebookExecutionJobsResponse.fromJson(response);
  }

  /// Deletes a NotebookExecutionJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteNotebookExecutionJob(DeleteNotebookExecutionJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's machine learning PersistentResource.
final class PersistentResourceService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `PersistentResourceService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `PersistentResourceService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  PersistentResourceService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `PersistentResourceService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory PersistentResourceService.fromApiKey([String? apiKey]) {
    return PersistentResourceService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Creates a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<PersistentResource, CreatePersistentResourceOperationMetadata>
  >
  createPersistentResource(CreatePersistentResourceRequest request) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/persistentResources', {
          if (request.persistentResourceId != null)
            'persistentResourceId': request.persistentResourceId!,
        });
    final response = await _client.post(url, body: request.persistentResource);
    return Operation.fromJson(
      response,
      OperationHelper(
        PersistentResource.fromJson,
        CreatePersistentResourceOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PersistentResource> getPersistentResource(
    GetPersistentResourceRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return PersistentResource.fromJson(response);
  }

  /// Lists PersistentResources in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListPersistentResourcesResponse> listPersistentResources(
    ListPersistentResourcesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/persistentResources', {
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
        });
    final response = await _client.get(url);
    return ListPersistentResourcesResponse.fromJson(response);
  }

  /// Deletes a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deletePersistentResource(DeletePersistentResourceRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<PersistentResource, UpdatePersistentResourceOperationMetadata>
  >
  updatePersistentResource(UpdatePersistentResourceRequest request) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.persistentResource.name}', {
          if (request.updateMask?.paths != null)
            'updateMask.paths': request.updateMask?.paths!,
        });
    final response = await _client.patch(url, body: request.persistentResource);
    return Operation.fromJson(
      response,
      OperationHelper(
        PersistentResource.fromJson,
        UpdatePersistentResourceOperationMetadata.fromJson,
      ),
    );
  }

  /// Reboots a PersistentResource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<PersistentResource, RebootPersistentResourceOperationMetadata>
  >
  rebootPersistentResource(RebootPersistentResourceRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:reboot');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        PersistentResource.fromJson,
        RebootPersistentResourceOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI's pipelines. This includes both
/// `TrainingPipeline` resources (used for AutoML and custom training) and
/// `PipelineJob` resources (used for Vertex AI Pipelines).
final class PipelineService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `PipelineService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `PipelineService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  PipelineService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `PipelineService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory PipelineService.fromApiKey([String? apiKey]) {
    return PipelineService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a TrainingPipeline. A created TrainingPipeline right away will be
  /// attempted to be run.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TrainingPipeline> createTrainingPipeline(
    CreateTrainingPipelineRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/trainingPipelines',
    );
    final response = await _client.post(url, body: request.trainingPipeline);
    return TrainingPipeline.fromJson(response);
  }

  /// Gets a TrainingPipeline.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TrainingPipeline> getTrainingPipeline(
    GetTrainingPipelineRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TrainingPipeline.fromJson(response);
  }

  /// Lists TrainingPipelines in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTrainingPipelinesResponse> listTrainingPipelines(
    ListTrainingPipelinesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/trainingPipelines', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
          if (request.readMask?.paths != null)
            'readMask.paths': request.readMask?.paths!,
        });
    final response = await _client.get(url);
    return ListTrainingPipelinesResponse.fromJson(response);
  }

  /// Deletes a TrainingPipeline.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteTrainingPipeline(DeleteTrainingPipelineRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a TrainingPipeline.
  /// Starts asynchronous cancellation on the TrainingPipeline. The server
  /// makes a best effort to cancel the pipeline, but success is not
  /// guaranteed. Clients can use
  /// `PipelineService.GetTrainingPipeline`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// pipeline completed despite cancellation. On successful cancellation,
  /// the TrainingPipeline is not deleted; instead it becomes a pipeline with
  /// a
  /// `TrainingPipeline.error`
  /// value with a `google.rpc.Status.code` of 1,
  /// corresponding to `Code.CANCELLED`, and
  /// `TrainingPipeline.state`
  /// is set to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelTrainingPipeline(
    CancelTrainingPipelineRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Creates a PipelineJob. A PipelineJob will run immediately when created.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PipelineJob> createPipelineJob(
    CreatePipelineJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/pipelineJobs', {
      if (request.pipelineJobId != null)
        'pipelineJobId': request.pipelineJobId!,
    });
    final response = await _client.post(url, body: request.pipelineJob);
    return PipelineJob.fromJson(response);
  }

  /// Gets a PipelineJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PipelineJob> getPipelineJob(GetPipelineJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return PipelineJob.fromJson(response);
  }

  /// Lists PipelineJobs in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListPipelineJobsResponse> listPipelineJobs(
    ListPipelineJobsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/pipelineJobs', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListPipelineJobsResponse.fromJson(response);
  }

  /// Deletes a PipelineJob.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deletePipelineJob(
    DeletePipelineJobRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Batch deletes PipelineJobs
  /// The Operation is atomic. If it fails, none of the PipelineJobs are deleted.
  /// If it succeeds, all of the PipelineJobs are deleted.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<BatchDeletePipelineJobsResponse, DeleteOperationMetadata>>
  batchDeletePipelineJobs(BatchDeletePipelineJobsRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/pipelineJobs:batchDelete',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchDeletePipelineJobsResponse.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Cancels a PipelineJob.
  /// Starts asynchronous cancellation on the PipelineJob. The server
  /// makes a best effort to cancel the pipeline, but success is not
  /// guaranteed. Clients can use
  /// `PipelineService.GetPipelineJob`
  /// or other methods to check whether the cancellation succeeded or whether the
  /// pipeline completed despite cancellation. On successful cancellation,
  /// the PipelineJob is not deleted; instead it becomes a pipeline with
  /// a `PipelineJob.error`
  /// value with a `google.rpc.Status.code` of 1,
  /// corresponding to `Code.CANCELLED`, and
  /// `PipelineJob.state` is
  /// set to `CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelPipelineJob(CancelPipelineJobRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Batch cancel PipelineJobs.
  /// Firstly the server will check if all the jobs are in non-terminal states,
  /// and skip the jobs that are already terminated.
  /// If the operation failed, none of the pipeline jobs are cancelled.
  /// The server will poll the states of all the pipeline jobs periodically
  /// to check the cancellation status.
  /// This operation will return an LRO.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      BatchCancelPipelineJobsResponse,
      BatchCancelPipelineJobsOperationMetadata
    >
  >
  batchCancelPipelineJobs(BatchCancelPipelineJobsRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/pipelineJobs:batchCancel',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        BatchCancelPipelineJobsResponse.fromJson,
        BatchCancelPipelineJobsOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for online predictions and explanations.
final class PredictionService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `PredictionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `PredictionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  PredictionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `PredictionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory PredictionService.fromApiKey([String? apiKey]) {
    return PredictionService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Perform an online prediction.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PredictResponse> predict(PredictRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:predict');
    final response = await _client.post(url, body: request);
    return PredictResponse.fromJson(response);
  }

  /// Perform an online prediction with an arbitrary HTTP payload.
  ///
  /// The response includes the following HTTP headers:
  ///
  /// * `X-Vertex-AI-Endpoint-Id`: ID of the
  /// `Endpoint` that served this
  /// prediction.
  ///
  /// * `X-Vertex-AI-Deployed-Model-Id`: ID of the Endpoint's
  /// `DeployedModel` that served
  /// this prediction.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<HttpBody> rawPredict(RawPredictRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:rawPredict');
    final response = await _client.post(url, body: request);
    return HttpBody.fromJson(response);
  }

  /// Perform a streaming online prediction with an arbitrary HTTP payload.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<HttpBody> streamRawPredict(StreamRawPredictRequest request) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}:streamRawPredict',
    );
    return _client.postStreaming(url, body: request).map(HttpBody.fromJson);
  }

  /// Perform an unary online prediction request to a gRPC model server for
  /// Vertex first-party products and frameworks.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DirectPredictResponse> directPredict(
    DirectPredictRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:directPredict');
    final response = await _client.post(url, body: request);
    return DirectPredictResponse.fromJson(response);
  }

  /// Perform an unary online prediction request to a gRPC model server for
  /// custom containers.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<DirectRawPredictResponse> directRawPredict(
    DirectRawPredictRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}:directRawPredict',
    );
    final response = await _client.post(url, body: request);
    return DirectRawPredictResponse.fromJson(response);
  }

  /// Perform a server-side streaming online prediction request for Vertex
  /// LLM streaming.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<StreamingPredictResponse> serverStreamingPredict(
    StreamingPredictRequest request,
  ) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}:serverStreamingPredict',
    );
    return _client
        .postStreaming(url, body: request)
        .map(StreamingPredictResponse.fromJson);
  }

  /// Perform an online explanation.
  ///
  /// If
  /// `deployed_model_id`
  /// is specified, the corresponding DeployModel must have
  /// `explanation_spec`
  /// populated. If
  /// `deployed_model_id`
  /// is not specified, all DeployedModels must have
  /// `explanation_spec`
  /// populated.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ExplainResponse> explain(ExplainRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:explain');
    final response = await _client.post(url, body: request);
    return ExplainResponse.fromJson(response);
  }

  /// Perform a token counting.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CountTokensResponse> countTokens(CountTokensRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.endpoint}:countTokens');
    final response = await _client.post(url, body: request);
    return CountTokensResponse.fromJson(response);
  }

  /// Generate content with multimodal inputs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GenerateContentResponse> generateContent(
    GenerateContentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.model}:generateContent');
    final response = await _client.post(url, body: request);
    return GenerateContentResponse.fromJson(response);
  }

  /// Generate content with multimodal inputs with streaming support.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<GenerateContentResponse> streamGenerateContent(
    GenerateContentRequest request,
  ) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.model}:streamGenerateContent',
    );
    return _client
        .postStreaming(url, body: request)
        .map(GenerateContentResponse.fromJson);
  }

  /// Exposes an OpenAI-compatible endpoint for chat completions.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<HttpBody> chatCompletions(ChatCompletionsRequest request) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.endpoint}/chat/completions',
    );
    return _client
        .postStreaming(url, body: request.httpBody)
        .map(HttpBody.fromJson);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for executing queries on Reasoning Engine.
final class ReasoningEngineExecutionService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ReasoningEngineExecutionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ReasoningEngineExecutionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ReasoningEngineExecutionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ReasoningEngineExecutionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ReasoningEngineExecutionService.fromApiKey([String? apiKey]) {
    return ReasoningEngineExecutionService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Queries using a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<QueryReasoningEngineResponse> queryReasoningEngine(
    QueryReasoningEngineRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:query');
    final response = await _client.post(url, body: request);
    return QueryReasoningEngineResponse.fromJson(response);
  }

  /// Streams queries using a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<HttpBody> streamQueryReasoningEngine(
    StreamQueryReasoningEngineRequest request,
  ) {
    final url = Uri.https(_host, '/v1beta1/${request.name}:streamQuery');
    return _client.postStreaming(url, body: request).map(HttpBody.fromJson);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing Vertex AI's Reasoning Engines.
final class ReasoningEngineService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ReasoningEngineService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ReasoningEngineService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ReasoningEngineService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ReasoningEngineService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ReasoningEngineService.fromApiKey([String? apiKey]) {
    return ReasoningEngineService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Creates a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ReasoningEngine, CreateReasoningEngineOperationMetadata>>
  createReasoningEngine(CreateReasoningEngineRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/reasoningEngines');
    final response = await _client.post(url, body: request.reasoningEngine);
    return Operation.fromJson(
      response,
      OperationHelper(
        ReasoningEngine.fromJson,
        CreateReasoningEngineOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReasoningEngine> getReasoningEngine(
    GetReasoningEngineRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return ReasoningEngine.fromJson(response);
  }

  /// Lists reasoning engines in a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListReasoningEnginesResponse> listReasoningEngines(
    ListReasoningEnginesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.parent}/reasoningEngines', {
          if (request.filter != null) 'filter': request.filter!,
          if (request.pageSize != null) 'pageSize': '${request.pageSize}',
          if (request.pageToken != null) 'pageToken': request.pageToken!,
        });
    final response = await _client.get(url);
    return ListReasoningEnginesResponse.fromJson(response);
  }

  /// Updates a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ReasoningEngine, UpdateReasoningEngineOperationMetadata>>
  updateReasoningEngine(UpdateReasoningEngineRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.reasoningEngine.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.reasoningEngine);
    return Operation.fromJson(
      response,
      OperationHelper(
        ReasoningEngine.fromJson,
        UpdateReasoningEngineOperationMetadata.fromJson,
      ),
    );
  }

  /// Deletes a reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteReasoningEngine(DeleteReasoningEngineRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Vertex AI's Schedule resources to
/// periodically launch shceudled runs to make API calls.
final class ScheduleService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `ScheduleService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `ScheduleService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  ScheduleService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `ScheduleService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory ScheduleService.fromApiKey([String? apiKey]) {
    return ScheduleService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a Schedule.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Schedule> createSchedule(CreateScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/schedules');
    final response = await _client.post(url, body: request.schedule);
    return Schedule.fromJson(response);
  }

  /// Deletes a Schedule.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteSchedule(
    DeleteScheduleRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Schedule.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Schedule> getSchedule(GetScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Schedule.fromJson(response);
  }

  /// Lists Schedules in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSchedulesResponse> listSchedules(
    ListSchedulesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/schedules', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListSchedulesResponse.fromJson(response);
  }

  /// Pauses a Schedule. Will mark
  /// `Schedule.state` to
  /// 'PAUSED'. If the schedule is paused, no new runs will be created. Already
  /// created runs will NOT be paused or canceled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> pauseSchedule(PauseScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:pause');
    await _client.post(url, body: request);
  }

  /// Resumes a paused Schedule to start scheduling new runs. Will mark
  /// `Schedule.state` to
  /// 'ACTIVE'. Only paused Schedule can be resumed.
  ///
  /// When the Schedule is resumed, new runs will be scheduled starting from the
  /// next execution time after the current time based on the time_specification
  /// in the Schedule. If `Schedule.catchUp` is set up true, all
  /// missed runs will be scheduled for backfill first.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> resumeSchedule(ResumeScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:resume');
    await _client.post(url, body: request);
  }

  /// Updates an active or paused Schedule.
  ///
  /// When the Schedule is updated, new runs will be scheduled starting from the
  /// updated next execution time after the update time based on the
  /// time_specification in the updated Schedule. All unstarted runs before the
  /// update time will be skipped while already created runs will NOT be paused
  /// or canceled.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Schedule> updateSchedule(UpdateScheduleRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.schedule.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.schedule);
    return Schedule.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The service that manages Vertex Session related resources.
final class SessionService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `SessionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `SessionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  SessionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `SessionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory SessionService.fromApiKey([String? apiKey]) {
    return SessionService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a new `Session`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Session, CreateSessionOperationMetadata>> createSession(
    CreateSessionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/sessions');
    final response = await _client.post(url, body: request.session);
    return Operation.fromJson(
      response,
      OperationHelper(
        Session.fromJson,
        CreateSessionOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets details of the specific
  /// `Session`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Session> getSession(GetSessionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Session.fromJson(response);
  }

  /// Lists `Sessions` in a given
  /// reasoning engine.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSessionsResponse> listSessions(ListSessionsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/sessions', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.filter != null) 'filter': request.filter!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
    });
    final response = await _client.get(url);
    return ListSessionsResponse.fromJson(response);
  }

  /// Updates the specific `Session`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Session> updateSession(UpdateSessionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.session.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.session);
    return Session.fromJson(response);
  }

  /// Deletes details of the specific
  /// `Session`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteSession(
    DeleteSessionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists `Events` in a given session.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListEventsResponse> listEvents(ListEventsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/events', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.filter != null) 'filter': request.filter!,
    });
    final response = await _client.get(url);
    return ListEventsResponse.fromJson(response);
  }

  /// Appends an event to a given session.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AppendEventResponse> appendEvent(AppendEventRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:appendEvent');
    final response = await _client.post(url, body: request.event);
    return AppendEventResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for creating and managing Customer SpecialistPools.
/// When customers start Data Labeling jobs, they can reuse/create Specialist
/// Pools to bring their own Specialists to label the data.
/// Customers can add/remove Managers for the Specialist Pool on Cloud console,
/// then Managers will get email notifications to manage Specialists and tasks on
/// CrowdCompute console.
final class SpecialistPoolService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `SpecialistPoolService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `SpecialistPoolService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  SpecialistPoolService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `SpecialistPoolService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory SpecialistPoolService.fromApiKey([String? apiKey]) {
    return SpecialistPoolService(
      client: httpClientFromApiKey(apiKey, _apiKeys),
    );
  }

  /// Creates a SpecialistPool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<SpecialistPool, CreateSpecialistPoolOperationMetadata>>
  createSpecialistPool(CreateSpecialistPoolRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/specialistPools');
    final response = await _client.post(url, body: request.specialistPool);
    return Operation.fromJson(
      response,
      OperationHelper(
        SpecialistPool.fromJson,
        CreateSpecialistPoolOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a SpecialistPool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SpecialistPool> getSpecialistPool(
    GetSpecialistPoolRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return SpecialistPool.fromJson(response);
  }

  /// Lists SpecialistPools in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSpecialistPoolsResponse> listSpecialistPools(
    ListSpecialistPoolsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/specialistPools', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListSpecialistPoolsResponse.fromJson(response);
  }

  /// Deletes a SpecialistPool as well as all Specialists in the pool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteSpecialistPool(DeleteSpecialistPoolRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a SpecialistPool.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<SpecialistPool, UpdateSpecialistPoolOperationMetadata>>
  updateSpecialistPool(UpdateSpecialistPoolRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.specialistPool.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.specialistPool);
    return Operation.fromJson(
      response,
      OperationHelper(
        SpecialistPool.fromJson,
        UpdateSpecialistPoolOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// TensorboardService
final class TensorboardService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `TensorboardService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `TensorboardService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  TensorboardService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `TensorboardService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory TensorboardService.fromApiKey([String? apiKey]) {
    return TensorboardService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a Tensorboard.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Tensorboard, CreateTensorboardOperationMetadata>>
  createTensorboard(CreateTensorboardRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tensorboards');
    final response = await _client.post(url, body: request.tensorboard);
    return Operation.fromJson(
      response,
      OperationHelper(
        Tensorboard.fromJson,
        CreateTensorboardOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a Tensorboard.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Tensorboard> getTensorboard(GetTensorboardRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Tensorboard.fromJson(response);
  }

  /// Updates a Tensorboard.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Tensorboard, UpdateTensorboardOperationMetadata>>
  updateTensorboard(UpdateTensorboardRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboard.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.tensorboard);
    return Operation.fromJson(
      response,
      OperationHelper(
        Tensorboard.fromJson,
        UpdateTensorboardOperationMetadata.fromJson,
      ),
    );
  }

  /// Lists Tensorboards in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTensorboardsResponse> listTensorboards(
    ListTensorboardsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tensorboards', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListTensorboardsResponse.fromJson(response);
  }

  /// Deletes a Tensorboard.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteTensorboard(
    DeleteTensorboardRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Returns a list of monthly active users for a given TensorBoard instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadTensorboardUsageResponse> readTensorboardUsage(
    ReadTensorboardUsageRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboard}:readUsage');
    final response = await _client.get(url);
    return ReadTensorboardUsageResponse.fromJson(response);
  }

  /// Returns the storage size for a given TensorBoard instance.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadTensorboardSizeResponse> readTensorboardSize(
    ReadTensorboardSizeRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboard}:readSize');
    final response = await _client.get(url);
    return ReadTensorboardSizeResponse.fromJson(response);
  }

  /// Creates a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardExperiment> createTensorboardExperiment(
    CreateTensorboardExperimentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/experiments', {
      if (request.tensorboardExperimentId != null)
        'tensorboardExperimentId': request.tensorboardExperimentId!,
    });
    final response = await _client.post(
      url,
      body: request.tensorboardExperiment,
    );
    return TensorboardExperiment.fromJson(response);
  }

  /// Gets a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardExperiment> getTensorboardExperiment(
    GetTensorboardExperimentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TensorboardExperiment.fromJson(response);
  }

  /// Updates a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardExperiment> updateTensorboardExperiment(
    UpdateTensorboardExperimentRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.tensorboardExperiment.name}', {
          if (request.updateMask?.paths != null)
            'updateMask.paths': request.updateMask?.paths!,
        });
    final response = await _client.patch(
      url,
      body: request.tensorboardExperiment,
    );
    return TensorboardExperiment.fromJson(response);
  }

  /// Lists TensorboardExperiments in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTensorboardExperimentsResponse> listTensorboardExperiments(
    ListTensorboardExperimentsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/experiments', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListTensorboardExperimentsResponse.fromJson(response);
  }

  /// Deletes a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteTensorboardExperiment(
    DeleteTensorboardExperimentRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Creates a TensorboardRun.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardRun> createTensorboardRun(
    CreateTensorboardRunRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/runs', {
      if (request.tensorboardRunId != null)
        'tensorboardRunId': request.tensorboardRunId!,
    });
    final response = await _client.post(url, body: request.tensorboardRun);
    return TensorboardRun.fromJson(response);
  }

  /// Batch create TensorboardRuns.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchCreateTensorboardRunsResponse> batchCreateTensorboardRuns(
    BatchCreateTensorboardRunsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/runs:batchCreate');
    final response = await _client.post(url, body: request);
    return BatchCreateTensorboardRunsResponse.fromJson(response);
  }

  /// Gets a TensorboardRun.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardRun> getTensorboardRun(
    GetTensorboardRunRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TensorboardRun.fromJson(response);
  }

  /// Updates a TensorboardRun.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardRun> updateTensorboardRun(
    UpdateTensorboardRunRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboardRun.name}', {
      if (request.updateMask?.paths != null)
        'updateMask.paths': request.updateMask?.paths!,
    });
    final response = await _client.patch(url, body: request.tensorboardRun);
    return TensorboardRun.fromJson(response);
  }

  /// Lists TensorboardRuns in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTensorboardRunsResponse> listTensorboardRuns(
    ListTensorboardRunsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/runs', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListTensorboardRunsResponse.fromJson(response);
  }

  /// Deletes a TensorboardRun.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteTensorboardRun(DeleteTensorboardRunRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Batch create TensorboardTimeSeries that belong to a TensorboardExperiment.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchCreateTensorboardTimeSeriesResponse>
  batchCreateTensorboardTimeSeries(
    BatchCreateTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:batchCreate');
    final response = await _client.post(url, body: request);
    return BatchCreateTensorboardTimeSeriesResponse.fromJson(response);
  }

  /// Creates a TensorboardTimeSeries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardTimeSeries> createTensorboardTimeSeries(
    CreateTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/timeSeries', {
      if (request.tensorboardTimeSeriesId != null)
        'tensorboardTimeSeriesId': request.tensorboardTimeSeriesId!,
    });
    final response = await _client.post(
      url,
      body: request.tensorboardTimeSeries,
    );
    return TensorboardTimeSeries.fromJson(response);
  }

  /// Gets a TensorboardTimeSeries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardTimeSeries> getTensorboardTimeSeries(
    GetTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return TensorboardTimeSeries.fromJson(response);
  }

  /// Updates a TensorboardTimeSeries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TensorboardTimeSeries> updateTensorboardTimeSeries(
    UpdateTensorboardTimeSeriesRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.tensorboardTimeSeries.name}', {
          if (request.updateMask?.paths != null)
            'updateMask.paths': request.updateMask?.paths!,
        });
    final response = await _client.patch(
      url,
      body: request.tensorboardTimeSeries,
    );
    return TensorboardTimeSeries.fromJson(response);
  }

  /// Lists TensorboardTimeSeries in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTensorboardTimeSeriesResponse> listTensorboardTimeSeries(
    ListTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/timeSeries', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.orderBy != null) 'orderBy': request.orderBy!,
      if (request.readMask?.paths != null)
        'readMask.paths': request.readMask?.paths!,
    });
    final response = await _client.get(url);
    return ListTensorboardTimeSeriesResponse.fromJson(response);
  }

  /// Deletes a TensorboardTimeSeries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>>
  deleteTensorboardTimeSeries(
    DeleteTensorboardTimeSeriesRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Reads multiple TensorboardTimeSeries' data. The data point number limit is
  /// 1000 for scalars, 100 for tensors and blob references. If the number of
  /// data points stored is less than the limit, all data is returned.
  /// Otherwise, the number limit of data points is randomly selected from
  /// this time series and returned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BatchReadTensorboardTimeSeriesDataResponse>
  batchReadTensorboardTimeSeriesData(
    BatchReadTensorboardTimeSeriesDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboard}:batchRead', {
      if (request.timeSeries != null) 'timeSeries': request.timeSeries!,
    });
    final response = await _client.get(url);
    return BatchReadTensorboardTimeSeriesDataResponse.fromJson(response);
  }

  /// Reads a TensorboardTimeSeries' data. By default, if the number of data
  /// points stored is less than 1000, all data is returned. Otherwise, 1000
  /// data points is randomly selected from this time series and returned.
  /// This value can be changed by changing max_data_points, which can't be
  /// greater than 10k.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReadTensorboardTimeSeriesDataResponse> readTensorboardTimeSeriesData(
    ReadTensorboardTimeSeriesDataRequest request,
  ) async {
    final url =
        Uri.https(_host, '/v1beta1/${request.tensorboardTimeSeries}:read', {
          if (request.maxDataPoints != null)
            'maxDataPoints': '${request.maxDataPoints}',
          if (request.filter != null) 'filter': request.filter!,
        });
    final response = await _client.get(url);
    return ReadTensorboardTimeSeriesDataResponse.fromJson(response);
  }

  /// Gets bytes of TensorboardBlobs.
  /// This is to allow reading blob data stored in consumer project's Cloud
  /// Storage bucket without users having to obtain Cloud Storage access
  /// permission.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<ReadTensorboardBlobDataResponse> readTensorboardBlobData(
    ReadTensorboardBlobDataRequest request,
  ) {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.timeSeries}:readBlobData',
      {if (request.blobIds != null) 'blobIds': request.blobIds!},
    );
    return _client
        .getStreaming(url)
        .map(ReadTensorboardBlobDataResponse.fromJson);
  }

  /// Write time series data points of multiple TensorboardTimeSeries in multiple
  /// TensorboardRun's. If any data fail to be ingested, an error is returned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<WriteTensorboardExperimentDataResponse> writeTensorboardExperimentData(
    WriteTensorboardExperimentDataRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.tensorboardExperiment}:write',
    );
    final response = await _client.post(url, body: request);
    return WriteTensorboardExperimentDataResponse.fromJson(response);
  }

  /// Write time series data points into multiple TensorboardTimeSeries under
  /// a TensorboardRun. If any data fail to be ingested, an error is returned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<WriteTensorboardRunDataResponse> writeTensorboardRunData(
    WriteTensorboardRunDataRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.tensorboardRun}:write');
    final response = await _client.post(url, body: request);
    return WriteTensorboardRunDataResponse.fromJson(response);
  }

  /// Exports a TensorboardTimeSeries' data. Data is returned in paginated
  /// responses.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ExportTensorboardTimeSeriesDataResponse>
  exportTensorboardTimeSeriesData(
    ExportTensorboardTimeSeriesDataRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.tensorboardTimeSeries}:exportTensorboardTimeSeries',
    );
    final response = await _client.post(url, body: request);
    return ExportTensorboardTimeSeriesDataResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for managing user data for RAG.
final class VertexRagDataService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `VertexRagDataService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `VertexRagDataService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  VertexRagDataService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `VertexRagDataService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory VertexRagDataService.fromApiKey([String? apiKey]) {
    return VertexRagDataService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<RagCorpus, CreateRagCorpusOperationMetadata>>
  createRagCorpus(CreateRagCorpusRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragCorpora');
    final response = await _client.post(url, body: request.ragCorpus);
    return Operation.fromJson(
      response,
      OperationHelper(
        RagCorpus.fromJson,
        CreateRagCorpusOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<RagCorpus, UpdateRagCorpusOperationMetadata>>
  updateRagCorpus(UpdateRagCorpusRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.ragCorpus.name}');
    final response = await _client.patch(url, body: request.ragCorpus);
    return Operation.fromJson(
      response,
      OperationHelper(
        RagCorpus.fromJson,
        UpdateRagCorpusOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RagCorpus> getRagCorpus(GetRagCorpusRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return RagCorpus.fromJson(response);
  }

  /// Lists RagCorpora in a Location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListRagCorporaResponse> listRagCorpora(
    ListRagCorporaRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragCorpora', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListRagCorporaResponse.fromJson(response);
  }

  /// Deletes a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteRagCorpus(
    DeleteRagCorpusRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.force != null) 'force': '${request.force}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Upload a file into a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<UploadRagFileResponse> uploadRagFile(
    UploadRagFileRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragFiles:upload');
    final response = await _client.post(url, body: request);
    return UploadRagFileResponse.fromJson(response);
  }

  /// Import files from Google Cloud Storage or Google Drive into a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<ImportRagFilesResponse, ImportRagFilesOperationMetadata>>
  importRagFiles(ImportRagFilesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragFiles:import');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        ImportRagFilesResponse.fromJson,
        ImportRagFilesOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a RagFile.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RagFile> getRagFile(GetRagFileRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return RagFile.fromJson(response);
  }

  /// Lists RagFiles in a RagCorpus.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListRagFilesResponse> listRagFiles(ListRagFilesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/ragFiles', {
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListRagFilesResponse.fromJson(response);
  }

  /// Deletes a RagFile.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<protobuf.Empty, DeleteOperationMetadata>> deleteRagFile(
    DeleteRagFileRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}', {
      if (request.forceDelete != null) 'forceDelete': '${request.forceDelete}',
    });
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(
        protobuf.Empty.fromJson,
        DeleteOperationMetadata.fromJson,
      ),
    );
  }

  /// Updates a RagEngineConfig.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<RagEngineConfig, UpdateRagEngineConfigOperationMetadata>>
  updateRagEngineConfig(UpdateRagEngineConfigRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.ragEngineConfig.name}');
    final response = await _client.patch(url, body: request.ragEngineConfig);
    return Operation.fromJson(
      response,
      OperationHelper(
        RagEngineConfig.fromJson,
        UpdateRagEngineConfigOperationMetadata.fromJson,
      ),
    );
  }

  /// Gets a RagEngineConfig.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RagEngineConfig> getRagEngineConfig(
    GetRagEngineConfigRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return RagEngineConfig.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service for retrieving relevant contexts.
final class VertexRagService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `VertexRagService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `VertexRagService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  VertexRagService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `VertexRagService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory VertexRagService.fromApiKey([String? apiKey]) {
    return VertexRagService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Retrieves relevant contexts for a query.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RetrieveContextsResponse> retrieveContexts(
    RetrieveContextsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:retrieveContexts');
    final response = await _client.post(url, body: request);
    return RetrieveContextsResponse.fromJson(response);
  }

  /// Given an input prompt, it returns augmented prompt from vertex rag store
  ///  to guide LLM towards generating grounded responses.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AugmentPromptResponse> augmentPrompt(
    AugmentPromptRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}:augmentPrompt');
    final response = await _client.post(url, body: request);
    return AugmentPromptResponse.fromJson(response);
  }

  /// Given an input text, it returns a score that evaluates the factuality of
  /// the text. It also extracts and returns claims from the text and provides
  /// supporting facts.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<CorroborateContentResponse> corroborateContent(
    CorroborateContentRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}:corroborateContent',
    );
    final response = await _client.post(url, body: request);
    return CorroborateContentResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Vertex AI Vizier API.
///
/// Vertex AI Vizier is a service to solve blackbox optimization problems,
/// such as tuning machine learning hyperparameters and searching over deep
/// learning architectures.
final class VizierService {
  static const _host = 'aiplatform.googleapis.com';

  final ServiceClient _client;

  /// Creates a `VizierService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `VizierService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  VizierService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `VizierService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory VizierService.fromApiKey([String? apiKey]) {
    return VizierService(client: httpClientFromApiKey(apiKey, _apiKeys));
  }

  /// Creates a Study. A resource name will be generated after creation of the
  /// Study.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Study> createStudy(CreateStudyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/studies');
    final response = await _client.post(url, body: request.study);
    return Study.fromJson(response);
  }

  /// Gets a Study by name.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Study> getStudy(GetStudyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Study.fromJson(response);
  }

  /// Lists all the studies in a region for an associated project.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListStudiesResponse> listStudies(ListStudiesRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/studies', {
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
    });
    final response = await _client.get(url);
    return ListStudiesResponse.fromJson(response);
  }

  /// Deletes a Study.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteStudy(DeleteStudyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Looks a study up using the user-defined display_name field instead of the
  /// fully qualified resource name.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Study> lookupStudy(LookupStudyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/studies:lookup');
    final response = await _client.post(url, body: request);
    return Study.fromJson(response);
  }

  /// Adds one or more Trials to a Study, with parameter values
  /// suggested by Vertex AI Vizier. Returns a long-running
  /// operation associated with the generation of Trial suggestions.
  /// When this long-running operation succeeds, it will contain
  /// a
  /// `SuggestTrialsResponse`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<SuggestTrialsResponse, SuggestTrialsMetadata>> suggestTrials(
    SuggestTrialsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/trials:suggest');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        SuggestTrialsResponse.fromJson,
        SuggestTrialsMetadata.fromJson,
      ),
    );
  }

  /// Adds a user provided Trial to a Study.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> createTrial(CreateTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/trials');
    final response = await _client.post(url, body: request.trial);
    return Trial.fromJson(response);
  }

  /// Gets a Trial.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> getTrial(GetTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Trial.fromJson(response);
  }

  /// Lists the Trials associated with a Study.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTrialsResponse> listTrials(ListTrialsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/trials', {
      if (request.pageToken != null) 'pageToken': request.pageToken!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
    });
    final response = await _client.get(url);
    return ListTrialsResponse.fromJson(response);
  }

  /// Adds a measurement of the objective metrics to a Trial. This measurement
  /// is assumed to have been taken before the Trial is complete.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> addTrialMeasurement(AddTrialMeasurementRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.trialName}:addTrialMeasurement',
    );
    final response = await _client.post(url, body: request);
    return Trial.fromJson(response);
  }

  /// Marks a Trial as complete.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> completeTrial(CompleteTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:complete');
    final response = await _client.post(url, body: request);
    return Trial.fromJson(response);
  }

  /// Deletes a Trial.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteTrial(DeleteTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Checks  whether a Trial should stop or not. Returns a
  /// long-running operation. When the operation is successful,
  /// it will contain a
  /// `CheckTrialEarlyStoppingStateResponse`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<
    Operation<
      CheckTrialEarlyStoppingStateResponse,
      CheckTrialEarlyStoppingStateMetatdata
    >
  >
  checkTrialEarlyStoppingState(
    CheckTrialEarlyStoppingStateRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.trialName}:checkTrialEarlyStoppingState',
    );
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        CheckTrialEarlyStoppingStateResponse.fromJson,
        CheckTrialEarlyStoppingStateMetatdata.fromJson,
      ),
    );
  }

  /// Stops a Trial.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Trial> stopTrial(StopTrialRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:stop');
    final response = await _client.post(url, body: request);
    return Trial.fromJson(response);
  }

  /// Lists the pareto-optimal Trials for multi-objective Study or the
  /// optimal Trials for single-objective Study. The definition of
  /// pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOptimalTrialsResponse> listOptimalTrials(
    ListOptimalTrialsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.parent}/trials:listOptimalTrials',
    );
    final response = await _client.post(url, body: request);
    return ListOptimalTrialsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/locations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/ui/${request.name}/operations', {
      if (request.filter != null) 'filter': request.filter!,
      if (request.pageSize != null) 'pageSize': '${request.pageSize}',
      if (request.pageToken != null) 'pageToken': request.pageToken!,
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends protobuf.ProtoMessage,
    S extends protobuf.ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:cancel');
    await _client.post(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> waitOperation(WaitOperationRequest request) async {
    final url = Uri.https(_host, '/ui/${request.name}:wait', {
      if (request.timeout?.seconds != null)
        'timeout.seconds': '${request.timeout?.seconds}',
      if (request.timeout?.nanos != null)
        'timeout.nanos': '${request.timeout?.nanos}',
    });
    final response = await _client.post(url);
    return Operation.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Used to assign specific AnnotationSpec to a particular area of a DataItem or
/// the whole part of the DataItem.
final class Annotation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Annotation';

  /// Output only. Resource name of the Annotation.
  final String? name;

  /// Required. Google Cloud Storage URI points to a YAML file describing
  /// `payload`. The schema
  /// is defined as an [OpenAPI 3.0.2 Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/, note that the
  /// chosen schema must be consistent with the parent Dataset's
  /// `metadata`.
  final String? payloadSchemaUri;

  /// Required. The schema of the payload can be found in
  /// `payload_schema`.
  final protobuf.Value? payload;

  /// Output only. Timestamp when this Annotation was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Annotation was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Output only. The source of the Annotation.
  final UserActionReference? annotationSource;

  /// Optional. The labels with user-defined metadata to organize your
  /// Annotations.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Annotation(System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable. Following system labels exist for each Annotation:
  ///
  /// * "aiplatform.googleapis.com/annotation_set_name":
  ///   optional, name of the UI's annotation set this Annotation belongs to.
  ///   If not set, the Annotation is not visible in the UI.
  ///
  /// * "aiplatform.googleapis.com/payload_schema":
  ///   output only, its value is the
  ///   [payload_schema's][google.cloud.aiplatform.v1beta1.Annotation.payload_schema_uri]
  ///   title.
  final Map<String, String>? labels;

  Annotation({
    this.name,
    this.payloadSchemaUri,
    this.payload,
    this.createTime,
    this.updateTime,
    this.etag,
    this.annotationSource,
    this.labels,
  }) : super(fullyQualifiedName);

  factory Annotation.fromJson(Map<String, dynamic> json) {
    return Annotation(
      name: json['name'],
      payloadSchemaUri: json['payloadSchemaUri'],
      payload: decodeCustom(json['payload'], protobuf.Value.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      annotationSource: decode(
        json['annotationSource'],
        UserActionReference.fromJson,
      ),
      labels: decodeMap(json['labels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (payloadSchemaUri != null) 'payloadSchemaUri': payloadSchemaUri,
      if (payload != null) 'payload': payload!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (annotationSource != null)
        'annotationSource': annotationSource!.toJson(),
      if (labels != null) 'labels': labels,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (payloadSchemaUri != null) 'payloadSchemaUri=$payloadSchemaUri',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'Annotation($contents)';
  }
}

/// Identifies a concept with which DataItems may be annotated with.
final class AnnotationSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AnnotationSpec';

  /// Output only. Resource name of the AnnotationSpec.
  final String? name;

  /// Required. The user-defined name of the AnnotationSpec.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Output only. Timestamp when this AnnotationSpec was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when AnnotationSpec was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  AnnotationSpec({
    this.name,
    this.displayName,
    this.createTime,
    this.updateTime,
    this.etag,
  }) : super(fullyQualifiedName);

  factory AnnotationSpec.fromJson(Map<String, dynamic> json) {
    return AnnotationSpec(
      name: json['name'],
      displayName: json['displayName'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'AnnotationSpec($contents)';
  }
}

/// The generic reusable api auth config.
final class ApiAuth extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ApiAuth';

  /// The API secret.
  final ApiAuth_ApiKeyConfig? apiKeyConfig;

  ApiAuth({this.apiKeyConfig}) : super(fullyQualifiedName);

  factory ApiAuth.fromJson(Map<String, dynamic> json) {
    return ApiAuth(
      apiKeyConfig: decode(json['apiKeyConfig'], ApiAuth_ApiKeyConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!.toJson()};
  }

  @override
  String toString() => 'ApiAuth()';
}

/// The API secret.
final class ApiAuth_ApiKeyConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ApiAuth.ApiKeyConfig';

  /// Required. The SecretManager secret version resource name storing API key.
  /// e.g. projects/{project}/secrets/{secret}/versions/{version}
  final String? apiKeySecretVersion;

  ApiAuth_ApiKeyConfig({this.apiKeySecretVersion}) : super(fullyQualifiedName);

  factory ApiAuth_ApiKeyConfig.fromJson(Map<String, dynamic> json) {
    return ApiAuth_ApiKeyConfig(
      apiKeySecretVersion: json['apiKeySecretVersion'],
    );
  }

  @override
  Object toJson() {
    return {
      if (apiKeySecretVersion != null)
        'apiKeySecretVersion': apiKeySecretVersion,
    };
  }

  @override
  String toString() {
    final contents = [
      if (apiKeySecretVersion != null)
        'apiKeySecretVersion=$apiKeySecretVersion',
    ].join(',');
    return 'ApiKeyConfig($contents)';
  }
}

/// Instance of a general artifact.
final class Artifact extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Artifact';

  /// Output only. The resource name of the Artifact.
  final String? name;

  /// User provided display name of the Artifact.
  /// May be up to 128 Unicode characters.
  final String? displayName;

  /// The uniform resource identifier of the artifact file.
  /// May be empty if there is no actual artifact file.
  final String? uri;

  /// An eTag used to perform consistent read-modify-write updates. If not set, a
  /// blind "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize your Artifacts.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Artifact (System
  /// labels are excluded).
  final Map<String, String>? labels;

  /// Output only. Timestamp when this Artifact was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Artifact was last updated.
  final protobuf.Timestamp? updateTime;

  /// The state of this Artifact. This is a property of the Artifact, and does
  /// not imply or capture any ongoing process. This property is managed by
  /// clients (such as Vertex AI Pipelines), and the system does not prescribe
  /// or check the validity of state transitions.
  final Artifact_State? state;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String? schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String? schemaVersion;

  /// Properties of the Artifact.
  /// Top level metadata keys' heading and trailing spaces will be trimmed.
  /// The size of this field should not exceed 200KB.
  final protobuf.Struct? metadata;

  /// Description of the Artifact
  final String? description;

  Artifact({
    this.name,
    this.displayName,
    this.uri,
    this.etag,
    this.labels,
    this.createTime,
    this.updateTime,
    this.state,
    this.schemaTitle,
    this.schemaVersion,
    this.metadata,
    this.description,
  }) : super(fullyQualifiedName);

  factory Artifact.fromJson(Map<String, dynamic> json) {
    return Artifact(
      name: json['name'],
      displayName: json['displayName'],
      uri: json['uri'],
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      state: decodeEnum(json['state'], Artifact_State.fromJson),
      schemaTitle: json['schemaTitle'],
      schemaVersion: json['schemaVersion'],
      metadata: decodeCustom(json['metadata'], protobuf.Struct.fromJson),
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (uri != null) 'uri': uri,
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (schemaTitle != null) 'schemaTitle': schemaTitle,
      if (schemaVersion != null) 'schemaVersion': schemaVersion,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (uri != null) 'uri=$uri',
      if (etag != null) 'etag=$etag',
      if (state != null) 'state=$state',
      if (schemaTitle != null) 'schemaTitle=$schemaTitle',
      if (schemaVersion != null) 'schemaVersion=$schemaVersion',
      if (description != null) 'description=$description',
    ].join(',');
    return 'Artifact($contents)';
  }
}

/// Describes the state of the Artifact.
final class Artifact_State extends protobuf.ProtoEnum {
  /// Unspecified state for the Artifact.
  static const stateUnspecified = Artifact_State('STATE_UNSPECIFIED');

  /// A state used by systems like Vertex AI Pipelines to indicate that the
  /// underlying data item represented by this Artifact is being created.
  static const pending = Artifact_State('PENDING');

  /// A state indicating that the Artifact should exist, unless something
  /// external to the system deletes it.
  static const live = Artifact_State('LIVE');

  const Artifact_State(super.value);

  factory Artifact_State.fromJson(String json) => Artifact_State(json);

  @override
  String toString() => 'State.$value';
}

/// A job that uses a
/// `Model` to produce
/// predictions on multiple [input
/// instances][google.cloud.aiplatform.v1beta1.BatchPredictionJob.input_config].
/// If predictions for significant portion of the instances fail, the job may
/// finish without attempting predictions for all remaining instances.
final class BatchPredictionJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob';

  /// Output only. Resource name of the BatchPredictionJob.
  final String? name;

  /// Required. The user-defined name of this BatchPredictionJob.
  final String? displayName;

  /// The name of the Model resource that produces the predictions via this job,
  /// must share the same ancestor Location.
  /// Starting this job has no impact on any existing deployments of the Model
  /// and their resources.
  /// Exactly one of model and unmanaged_container_model must be set.
  ///
  /// The model resource name may contain version id or version alias to specify
  /// the version.
  ///  Example: `projects/{project}/locations/{location}/models/{model}@2`
  ///              or
  ///            `projects/{project}/locations/{location}/models/{model}@golden`
  /// if no version is specified, the default version will be deployed.
  ///
  /// The model resource could also be a publisher model.
  ///  Example: `publishers/{publisher}/models/{model}`
  ///              or
  ///           `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  final String? model;

  /// Output only. The version ID of the Model that produces the predictions via
  /// this job.
  final String? modelVersionId;

  /// Contains model information necessary to perform batch prediction without
  /// requiring uploading to model registry.
  /// Exactly one of model and unmanaged_container_model must be set.
  final UnmanagedContainerModel? unmanagedContainerModel;

  /// Required. Input configuration of the instances on which predictions are
  /// performed. The schema of any single instance may be specified via the
  /// [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`.
  final BatchPredictionJob_InputConfig? inputConfig;

  /// Configuration for how to convert batch prediction input instances to the
  /// prediction instances that are sent to the Model.
  final BatchPredictionJob_InstanceConfig? instanceConfig;

  /// The parameters that govern the predictions. The schema of the parameters
  /// may be specified via the
  /// [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `parameters_schema_uri`.
  final protobuf.Value? modelParameters;

  /// Required. The Configuration specifying where output predictions should
  /// be written.
  /// The schema of any single prediction may be specified as a concatenation
  /// of [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`
  /// and
  /// `prediction_schema_uri`.
  final BatchPredictionJob_OutputConfig? outputConfig;

  /// The config of resources used by the Model during the batch prediction. If
  /// the Model
  /// `supports`
  /// DEDICATED_RESOURCES this config may be provided (and the job will use these
  /// resources), if the Model doesn't support AUTOMATIC_RESOURCES, this config
  /// must be provided.
  final BatchDedicatedResources? dedicatedResources;

  /// The service account that the DeployedModel's container runs as. If not
  /// specified, a system generated one will be used, which
  /// has minimal permissions and the custom container, if used, may not have
  /// enough permission to access other Google Cloud resources.
  ///
  /// Users deploying the Model must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  final String? serviceAccount;

  /// Immutable. Parameters configuring the batch behavior. Currently only
  /// applicable when
  /// `dedicated_resources`
  /// are used (in other cases Vertex AI does the tuning itself).
  final ManualBatchTuningParameters? manualBatchTuningParameters;

  /// Generate explanation with the batch prediction results.
  ///
  /// When set to `true`, the batch prediction output changes based on the
  /// `predictions_format` field of the
  /// `BatchPredictionJob.output_config`
  /// object:
  ///
  ///  * `bigquery`: output includes a column named `explanation`. The value
  ///    is a struct that conforms to the
  ///    `Explanation` object.
  ///  * `jsonl`: The JSON objects on each line include an additional entry
  ///    keyed `explanation`. The value of the entry is a JSON object that
  ///    conforms to the
  ///    `Explanation` object.
  ///  * `csv`: Generating explanations for CSV format is not supported.
  ///
  /// If this field is set to true, either the
  /// `Model.explanation_spec`
  /// or
  /// `explanation_spec`
  /// must be populated.
  final bool? generateExplanation;

  /// Explanation configuration for this BatchPredictionJob. Can be
  /// specified only if
  /// `generate_explanation`
  /// is set to `true`.
  ///
  /// This value overrides the value of
  /// `Model.explanation_spec`.
  /// All fields of
  /// `explanation_spec`
  /// are optional in the request. If a field of the
  /// `explanation_spec`
  /// object is not populated, the corresponding field of the
  /// `Model.explanation_spec`
  /// object is inherited.
  final ExplanationSpec? explanationSpec;

  /// Output only. Information further describing the output of this job.
  final BatchPredictionJob_OutputInfo? outputInfo;

  /// Output only. The detailed state of the job.
  final JobState? state;

  /// Output only. Only populated when the job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  final Status? error;

  /// Output only. Partial failures encountered.
  /// For example, single files that can't be read.
  /// This field never exceeds 20 entries.
  /// Status details fields contain standard Google Cloud error details.
  final List<Status>? partialFailures;

  /// Output only. Information about resources that had been consumed by this
  /// job. Provided in real time at best effort basis, as well as a final value
  /// once the job completes.
  ///
  /// Note: This field currently may be not populated for batch predictions that
  /// use AutoML Models.
  final ResourcesConsumed? resourcesConsumed;

  /// Output only. Statistics on completed and failed prediction instances.
  final CompletionStats? completionStats;

  /// Output only. Time when the BatchPredictionJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the BatchPredictionJob for the first time entered
  /// the `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the BatchPredictionJob entered any of the following
  /// states: `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the BatchPredictionJob was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize BatchPredictionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Customer-managed encryption key options for a BatchPredictionJob. If this
  /// is set, then all resources created by the BatchPredictionJob will be
  /// encrypted with the provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// Model monitoring config will be used for analysis model behaviors, based on
  /// the input and output to the batch prediction job, as well as the provided
  /// training dataset.
  final ModelMonitoringConfig? modelMonitoringConfig;

  /// Get batch prediction job monitoring statistics.
  final List<ModelMonitoringStatsAnomalies>? modelMonitoringStatsAnomalies;

  /// Output only. The running status of the model monitoring pipeline.
  final Status? modelMonitoringStatus;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to
  /// Cloud Logging by default. Please note that the logs incur cost,
  /// which are subject to [Cloud Logging
  /// pricing](https://cloud.google.com/logging/pricing).
  ///
  /// User can disable container logging by setting this flag to true.
  final bool? disableContainerLogging;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  BatchPredictionJob({
    this.name,
    this.displayName,
    this.model,
    this.modelVersionId,
    this.unmanagedContainerModel,
    this.inputConfig,
    this.instanceConfig,
    this.modelParameters,
    this.outputConfig,
    this.dedicatedResources,
    this.serviceAccount,
    this.manualBatchTuningParameters,
    this.generateExplanation,
    this.explanationSpec,
    this.outputInfo,
    this.state,
    this.error,
    this.partialFailures,
    this.resourcesConsumed,
    this.completionStats,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.labels,
    this.encryptionSpec,
    this.modelMonitoringConfig,
    this.modelMonitoringStatsAnomalies,
    this.modelMonitoringStatus,
    this.disableContainerLogging,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob.fromJson(Map<String, dynamic> json) {
    return BatchPredictionJob(
      name: json['name'],
      displayName: json['displayName'],
      model: json['model'],
      modelVersionId: json['modelVersionId'],
      unmanagedContainerModel: decode(
        json['unmanagedContainerModel'],
        UnmanagedContainerModel.fromJson,
      ),
      inputConfig: decode(
        json['inputConfig'],
        BatchPredictionJob_InputConfig.fromJson,
      ),
      instanceConfig: decode(
        json['instanceConfig'],
        BatchPredictionJob_InstanceConfig.fromJson,
      ),
      modelParameters: decodeCustom(
        json['modelParameters'],
        protobuf.Value.fromJson,
      ),
      outputConfig: decode(
        json['outputConfig'],
        BatchPredictionJob_OutputConfig.fromJson,
      ),
      dedicatedResources: decode(
        json['dedicatedResources'],
        BatchDedicatedResources.fromJson,
      ),
      serviceAccount: json['serviceAccount'],
      manualBatchTuningParameters: decode(
        json['manualBatchTuningParameters'],
        ManualBatchTuningParameters.fromJson,
      ),
      generateExplanation: json['generateExplanation'],
      explanationSpec: decode(
        json['explanationSpec'],
        ExplanationSpec.fromJson,
      ),
      outputInfo: decode(
        json['outputInfo'],
        BatchPredictionJob_OutputInfo.fromJson,
      ),
      state: decodeEnum(json['state'], JobState.fromJson),
      error: decode(json['error'], Status.fromJson),
      partialFailures: decodeListMessage(
        json['partialFailures'],
        Status.fromJson,
      ),
      resourcesConsumed: decode(
        json['resourcesConsumed'],
        ResourcesConsumed.fromJson,
      ),
      completionStats: decode(
        json['completionStats'],
        CompletionStats.fromJson,
      ),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      modelMonitoringConfig: decode(
        json['modelMonitoringConfig'],
        ModelMonitoringConfig.fromJson,
      ),
      modelMonitoringStatsAnomalies: decodeListMessage(
        json['modelMonitoringStatsAnomalies'],
        ModelMonitoringStatsAnomalies.fromJson,
      ),
      modelMonitoringStatus: decode(
        json['modelMonitoringStatus'],
        Status.fromJson,
      ),
      disableContainerLogging: json['disableContainerLogging'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (model != null) 'model': model,
      if (modelVersionId != null) 'modelVersionId': modelVersionId,
      if (unmanagedContainerModel != null)
        'unmanagedContainerModel': unmanagedContainerModel!.toJson(),
      if (inputConfig != null) 'inputConfig': inputConfig!.toJson(),
      if (instanceConfig != null) 'instanceConfig': instanceConfig!.toJson(),
      if (modelParameters != null) 'modelParameters': modelParameters!.toJson(),
      if (outputConfig != null) 'outputConfig': outputConfig!.toJson(),
      if (dedicatedResources != null)
        'dedicatedResources': dedicatedResources!.toJson(),
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (manualBatchTuningParameters != null)
        'manualBatchTuningParameters': manualBatchTuningParameters!.toJson(),
      if (generateExplanation != null)
        'generateExplanation': generateExplanation,
      if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
      if (outputInfo != null) 'outputInfo': outputInfo!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (partialFailures != null)
        'partialFailures': encodeList(partialFailures),
      if (resourcesConsumed != null)
        'resourcesConsumed': resourcesConsumed!.toJson(),
      if (completionStats != null) 'completionStats': completionStats!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (modelMonitoringConfig != null)
        'modelMonitoringConfig': modelMonitoringConfig!.toJson(),
      if (modelMonitoringStatsAnomalies != null)
        'modelMonitoringStatsAnomalies': encodeList(
          modelMonitoringStatsAnomalies,
        ),
      if (modelMonitoringStatus != null)
        'modelMonitoringStatus': modelMonitoringStatus!.toJson(),
      if (disableContainerLogging != null)
        'disableContainerLogging': disableContainerLogging,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (model != null) 'model=$model',
      if (modelVersionId != null) 'modelVersionId=$modelVersionId',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (generateExplanation != null)
        'generateExplanation=$generateExplanation',
      if (state != null) 'state=$state',
      if (disableContainerLogging != null)
        'disableContainerLogging=$disableContainerLogging',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'BatchPredictionJob($contents)';
  }
}

/// Configures the input to
/// `BatchPredictionJob`.
/// See
/// `Model.supported_input_storage_formats`
/// for Model's supported input formats, and how instances should be expressed
/// via any of them.
final class BatchPredictionJob_InputConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob.InputConfig';

  /// The Cloud Storage location for the input instances.
  final GcsSource? gcsSource;

  /// The BigQuery location of the input table.
  /// The schema of the table should be in the format described by the given
  /// context OpenAPI Schema, if one is provided. The table may contain
  /// additional columns that are not described by the schema, and they will
  /// be ignored.
  final BigQuerySource? bigquerySource;

  /// Required. The format in which instances are given, must be one of the
  /// [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// `supported_input_storage_formats`.
  final String? instancesFormat;

  BatchPredictionJob_InputConfig({
    this.gcsSource,
    this.bigquerySource,
    this.instancesFormat,
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob_InputConfig.fromJson(Map<String, dynamic> json) {
    return BatchPredictionJob_InputConfig(
      gcsSource: decode(json['gcsSource'], GcsSource.fromJson),
      bigquerySource: decode(json['bigquerySource'], BigQuerySource.fromJson),
      instancesFormat: json['instancesFormat'],
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
      if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
      if (instancesFormat != null) 'instancesFormat': instancesFormat,
    };
  }

  @override
  String toString() {
    final contents = [
      if (instancesFormat != null) 'instancesFormat=$instancesFormat',
    ].join(',');
    return 'InputConfig($contents)';
  }
}

/// Configuration defining how to transform batch prediction input instances to
/// the instances that the Model accepts.
final class BatchPredictionJob_InstanceConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob.InstanceConfig';

  /// The format of the instance that the Model accepts. Vertex AI will
  /// convert compatible
  /// [batch prediction input instance
  /// formats][google.cloud.aiplatform.v1beta1.BatchPredictionJob.InputConfig.instances_format]
  /// to the specified format.
  ///
  /// Supported values are:
  ///
  /// * `object`: Each input is converted to JSON object format.
  ///     * For `bigquery`, each row is converted to an object.
  ///     * For `jsonl`, each line of the JSONL input must be an object.
  ///     * Does not apply to `csv`, `file-list`, `tf-record`, or
  ///       `tf-record-gzip`.
  ///
  /// * `array`: Each input is converted to JSON array format.
  ///     * For `bigquery`, each row is converted to an array. The order
  ///       of columns is determined by the BigQuery column order, unless
  ///       `included_fields`
  ///       is populated.
  ///       `included_fields`
  ///       must be populated for specifying field orders.
  ///     * For `jsonl`, if each line of the JSONL input is an object,
  ///       `included_fields`
  ///       must be populated for specifying field orders.
  ///     * Does not apply to `csv`, `file-list`, `tf-record`, or
  ///       `tf-record-gzip`.
  ///
  /// If not specified, Vertex AI converts the batch prediction input as
  /// follows:
  ///
  ///  * For `bigquery` and `csv`, the behavior is the same as `array`. The
  ///    order of columns is the same as defined in the file or table, unless
  ///    `included_fields`
  ///    is populated.
  ///  * For `jsonl`, the prediction instance format is determined by
  ///    each line of the input.
  ///  * For `tf-record`/`tf-record-gzip`, each record will be converted to
  ///    an object in the format of `{"b64": <value>}`, where `<value>` is
  ///    the Base64-encoded string of the content of the record.
  ///  * For `file-list`, each file in the list will be converted to an
  ///    object in the format of `{"b64": <value>}`, where `<value>` is
  ///    the Base64-encoded string of the content of the file.
  final String? instanceType;

  /// The name of the field that is considered as a key.
  ///
  /// The values identified by the key field is not included in the transformed
  /// instances that is sent to the Model. This is similar to
  /// specifying this name of the field in
  /// `excluded_fields`.
  /// In addition, the batch prediction output will not include the instances.
  /// Instead the output will only include the value of the key field, in a
  /// field named `key` in the output:
  ///
  ///  * For `jsonl` output format, the output will have a `key` field
  ///    instead of the `instance` field.
  ///  * For `csv`/`bigquery` output format, the output will have have a `key`
  ///    column instead of the instance feature columns.
  ///
  /// The input must be JSONL with objects at each line, CSV, BigQuery
  /// or TfRecord.
  final String? keyField;

  /// Fields that will be included in the prediction instance that is
  /// sent to the Model.
  ///
  /// If
  /// `instance_type`
  /// is `array`, the order of field names in included_fields also determines
  /// the order of the values in the array.
  ///
  /// When included_fields is populated,
  /// `excluded_fields`
  /// must be empty.
  ///
  /// The input must be JSONL with objects at each line, BigQuery
  /// or TfRecord.
  final List<String>? includedFields;

  /// Fields that will be excluded in the prediction instance that is
  /// sent to the Model.
  ///
  /// Excluded will be attached to the batch prediction output if
  /// `key_field`
  /// is not specified.
  ///
  /// When excluded_fields is populated,
  /// `included_fields`
  /// must be empty.
  ///
  /// The input must be JSONL with objects at each line, BigQuery
  /// or TfRecord.
  final List<String>? excludedFields;

  BatchPredictionJob_InstanceConfig({
    this.instanceType,
    this.keyField,
    this.includedFields,
    this.excludedFields,
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob_InstanceConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchPredictionJob_InstanceConfig(
      instanceType: json['instanceType'],
      keyField: json['keyField'],
      includedFields: decodeList(json['includedFields']),
      excludedFields: decodeList(json['excludedFields']),
    );
  }

  @override
  Object toJson() {
    return {
      if (instanceType != null) 'instanceType': instanceType,
      if (keyField != null) 'keyField': keyField,
      if (includedFields != null) 'includedFields': includedFields,
      if (excludedFields != null) 'excludedFields': excludedFields,
    };
  }

  @override
  String toString() {
    final contents = [
      if (instanceType != null) 'instanceType=$instanceType',
      if (keyField != null) 'keyField=$keyField',
    ].join(',');
    return 'InstanceConfig($contents)';
  }
}

/// Configures the output of
/// `BatchPredictionJob`.
/// See
/// `Model.supported_output_storage_formats`
/// for supported output formats, and how predictions are expressed via any of
/// them.
final class BatchPredictionJob_OutputConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob.OutputConfig';

  /// The Cloud Storage location of the directory where the output is
  /// to be written to. In the given directory a new directory is created.
  /// Its name is `prediction-<model-display-name>-<job-create-time>`,
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format.
  /// Inside of it files `predictions_0001.<extension>`,
  /// `predictions_0002.<extension>`, ..., `predictions_N.<extension>`
  /// are created where `<extension>` depends on chosen
  /// `predictions_format`,
  /// and N may equal 0001 and depends on the total number of successfully
  /// predicted instances. If the Model has both
  /// `instance`
  /// and
  /// `prediction`
  /// schemata defined then each such file contains predictions as per the
  /// `predictions_format`.
  /// If prediction for any instance failed (partially or completely), then
  /// an additional `errors_0001.<extension>`, `errors_0002.<extension>`,...,
  /// `errors_N.<extension>` files are created (N depends on total number
  /// of failed predictions). These files contain the failed instances,
  /// as per their schema, followed by an additional `error` field which as
  /// value has `google.rpc.Status`
  /// containing only `code` and `message` fields.
  final GcsDestination? gcsDestination;

  /// The BigQuery project or dataset location where the output is to be
  /// written to. If project is provided, a new dataset is created with name
  /// `prediction_<model-display-name>_<job-create-time>`
  /// where <model-display-name> is made
  /// BigQuery-dataset-name compatible (for example, most special characters
  /// become underscores), and timestamp is in
  /// YYYY_MM_DDThh_mm_ss_sssZ "based on ISO-8601" format. In the dataset
  /// two tables will be created, `predictions`, and `errors`.
  /// If the Model has both
  /// `instance`
  /// and
  /// `prediction`
  /// schemata defined then the tables have columns as follows: The
  /// `predictions` table contains instances for which the prediction
  /// succeeded, it has columns as per a concatenation of the Model's
  /// instance and prediction schemata. The `errors` table contains rows for
  /// which the prediction has failed, it has instance columns, as per the
  /// instance schema, followed by a single "errors" column, which as values
  /// has `google.rpc.Status`
  /// represented as a STRUCT, and containing only `code` and `message`.
  final BigQueryDestination? bigqueryDestination;

  /// Required. The format in which Vertex AI gives the predictions, must be
  /// one of the
  /// [Model's][google.cloud.aiplatform.v1beta1.BatchPredictionJob.model]
  /// `supported_output_storage_formats`.
  final String? predictionsFormat;

  BatchPredictionJob_OutputConfig({
    this.gcsDestination,
    this.bigqueryDestination,
    this.predictionsFormat,
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob_OutputConfig.fromJson(Map<String, dynamic> json) {
    return BatchPredictionJob_OutputConfig(
      gcsDestination: decode(json['gcsDestination'], GcsDestination.fromJson),
      bigqueryDestination: decode(
        json['bigqueryDestination'],
        BigQueryDestination.fromJson,
      ),
      predictionsFormat: json['predictionsFormat'],
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
      if (bigqueryDestination != null)
        'bigqueryDestination': bigqueryDestination!.toJson(),
      if (predictionsFormat != null) 'predictionsFormat': predictionsFormat,
    };
  }

  @override
  String toString() {
    final contents = [
      if (predictionsFormat != null) 'predictionsFormat=$predictionsFormat',
    ].join(',');
    return 'OutputConfig($contents)';
  }
}

/// Further describes this job's output.
/// Supplements
/// `output_config`.
final class BatchPredictionJob_OutputInfo extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchPredictionJob.OutputInfo';

  /// Output only. The full path of the Cloud Storage directory created, into
  /// which the prediction output is written.
  final String? gcsOutputDirectory;

  /// Output only. The path of the BigQuery dataset created, in
  /// `bq://projectId.bqDatasetId`
  /// format, into which the prediction output is written.
  final String? bigqueryOutputDataset;

  /// Output only. The name of the BigQuery table created, in
  /// `predictions_<timestamp>`
  /// format, into which the prediction output is written.
  /// Can be used by UI to generate the BigQuery output path, for example.
  final String? bigqueryOutputTable;

  BatchPredictionJob_OutputInfo({
    this.gcsOutputDirectory,
    this.bigqueryOutputDataset,
    this.bigqueryOutputTable,
  }) : super(fullyQualifiedName);

  factory BatchPredictionJob_OutputInfo.fromJson(Map<String, dynamic> json) {
    return BatchPredictionJob_OutputInfo(
      gcsOutputDirectory: json['gcsOutputDirectory'],
      bigqueryOutputDataset: json['bigqueryOutputDataset'],
      bigqueryOutputTable: json['bigqueryOutputTable'],
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsOutputDirectory != null) 'gcsOutputDirectory': gcsOutputDirectory,
      if (bigqueryOutputDataset != null)
        'bigqueryOutputDataset': bigqueryOutputDataset,
      if (bigqueryOutputTable != null)
        'bigqueryOutputTable': bigqueryOutputTable,
    };
  }

  @override
  String toString() {
    final contents = [
      if (gcsOutputDirectory != null) 'gcsOutputDirectory=$gcsOutputDirectory',
      if (bigqueryOutputDataset != null)
        'bigqueryOutputDataset=$bigqueryOutputDataset',
      if (bigqueryOutputTable != null)
        'bigqueryOutputTable=$bigqueryOutputTable',
    ].join(',');
    return 'OutputInfo($contents)';
  }
}

/// A resource used in LLM queries for users to explicitly specify what to cache
/// and how to cache.
final class CachedContent extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CachedContent';

  /// Timestamp of when this resource is considered expired.
  /// This is *always* provided on output, regardless of what was sent
  /// on input.
  final protobuf.Timestamp? expireTime;

  /// Input only. The TTL for this resource. The expiration time is computed:
  /// now + TTL.
  final protobuf.Duration? ttl;

  /// Immutable. Identifier. The server-generated resource name of the cached
  /// content Format:
  /// projects/{project}/locations/{location}/cachedContents/{cached_content}
  final String? name;

  /// Optional. Immutable. The user-generated meaningful display name of the
  /// cached content.
  final String? displayName;

  /// Immutable. The name of the `Model` to use for cached content. Currently,
  /// only the published Gemini base models are supported, in form of
  /// projects/{PROJECT}/locations/{LOCATION}/publishers/google/models/{MODEL}
  final String? model;

  /// Optional. Input only. Immutable. Developer set system instruction.
  /// Currently, text only
  final Content? systemInstruction;

  /// Optional. Input only. Immutable. The content to cache
  final List<Content>? contents;

  /// Optional. Input only. Immutable. A list of `Tools` the model may use to
  /// generate the next response
  final List<Tool>? tools;

  /// Optional. Input only. Immutable. Tool config. This config is shared for all
  /// tools
  final ToolConfig? toolConfig;

  /// Output only. Creation time of the cache entry.
  final protobuf.Timestamp? createTime;

  /// Output only. When the cache entry was last updated in UTC time.
  final protobuf.Timestamp? updateTime;

  /// Output only. Metadata on the usage of the cached content.
  final CachedContent_UsageMetadata? usageMetadata;

  /// Input only. Immutable. Customer-managed encryption key spec for a
  /// `CachedContent`. If set, this `CachedContent` and all its sub-resources
  /// will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  CachedContent({
    this.expireTime,
    this.ttl,
    this.name,
    this.displayName,
    this.model,
    this.systemInstruction,
    this.contents,
    this.tools,
    this.toolConfig,
    this.createTime,
    this.updateTime,
    this.usageMetadata,
    this.encryptionSpec,
  }) : super(fullyQualifiedName);

  factory CachedContent.fromJson(Map<String, dynamic> json) {
    return CachedContent(
      expireTime: decodeCustom(json['expireTime'], protobuf.Timestamp.fromJson),
      ttl: decodeCustom(json['ttl'], protobuf.Duration.fromJson),
      name: json['name'],
      displayName: json['displayName'],
      model: json['model'],
      systemInstruction: decode(json['systemInstruction'], Content.fromJson),
      contents: decodeListMessage(json['contents'], Content.fromJson),
      tools: decodeListMessage(json['tools'], Tool.fromJson),
      toolConfig: decode(json['toolConfig'], ToolConfig.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      usageMetadata: decode(
        json['usageMetadata'],
        CachedContent_UsageMetadata.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (expireTime != null) 'expireTime': expireTime!.toJson(),
      if (ttl != null) 'ttl': ttl!.toJson(),
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (model != null) 'model': model,
      if (systemInstruction != null)
        'systemInstruction': systemInstruction!.toJson(),
      if (contents != null) 'contents': encodeList(contents),
      if (tools != null) 'tools': encodeList(tools),
      if (toolConfig != null) 'toolConfig': toolConfig!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (usageMetadata != null) 'usageMetadata': usageMetadata!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (model != null) 'model=$model',
    ].join(',');
    return 'CachedContent($contents)';
  }
}

/// Metadata on the usage of the cached content.
final class CachedContent_UsageMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CachedContent.UsageMetadata';

  /// Total number of tokens that the cached content consumes.
  final int? totalTokenCount;

  /// Number of text characters.
  final int? textCount;

  /// Number of images.
  final int? imageCount;

  /// Duration of video in seconds.
  final int? videoDurationSeconds;

  /// Duration of audio in seconds.
  final int? audioDurationSeconds;

  CachedContent_UsageMetadata({
    this.totalTokenCount,
    this.textCount,
    this.imageCount,
    this.videoDurationSeconds,
    this.audioDurationSeconds,
  }) : super(fullyQualifiedName);

  factory CachedContent_UsageMetadata.fromJson(Map<String, dynamic> json) {
    return CachedContent_UsageMetadata(
      totalTokenCount: json['totalTokenCount'],
      textCount: json['textCount'],
      imageCount: json['imageCount'],
      videoDurationSeconds: json['videoDurationSeconds'],
      audioDurationSeconds: json['audioDurationSeconds'],
    );
  }

  @override
  Object toJson() {
    return {
      if (totalTokenCount != null) 'totalTokenCount': totalTokenCount,
      if (textCount != null) 'textCount': textCount,
      if (imageCount != null) 'imageCount': imageCount,
      if (videoDurationSeconds != null)
        'videoDurationSeconds': videoDurationSeconds,
      if (audioDurationSeconds != null)
        'audioDurationSeconds': audioDurationSeconds,
    };
  }

  @override
  String toString() {
    final contents = [
      if (totalTokenCount != null) 'totalTokenCount=$totalTokenCount',
      if (textCount != null) 'textCount=$textCount',
      if (imageCount != null) 'imageCount=$imageCount',
      if (videoDurationSeconds != null)
        'videoDurationSeconds=$videoDurationSeconds',
      if (audioDurationSeconds != null)
        'audioDurationSeconds=$audioDurationSeconds',
    ].join(',');
    return 'UsageMetadata($contents)';
  }
}

/// Success and error statistics of processing multiple entities
/// (for example, DataItems or structured data rows) in batch.
final class CompletionStats extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CompletionStats';

  /// Output only. The number of entities that had been processed successfully.
  final int? successfulCount;

  /// Output only. The number of entities for which any error was encountered.
  final int? failedCount;

  /// Output only. In cases when enough errors are encountered a job, pipeline,
  /// or operation may be failed as a whole. Below is the number of entities for
  /// which the processing had not been finished (either in successful or failed
  /// state). Set to -1 if the number is unknown (for example, the operation
  /// failed before the total entity number could be collected).
  final int? incompleteCount;

  /// Output only. The number of the successful forecast points that are
  /// generated by the forecasting model. This is ONLY used by the forecasting
  /// batch prediction.
  final int? successfulForecastPointCount;

  CompletionStats({
    this.successfulCount,
    this.failedCount,
    this.incompleteCount,
    this.successfulForecastPointCount,
  }) : super(fullyQualifiedName);

  factory CompletionStats.fromJson(Map<String, dynamic> json) {
    return CompletionStats(
      successfulCount: decodeInt64(json['successfulCount']),
      failedCount: decodeInt64(json['failedCount']),
      incompleteCount: decodeInt64(json['incompleteCount']),
      successfulForecastPointCount: decodeInt64(
        json['successfulForecastPointCount'],
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (successfulCount != null)
        'successfulCount': encodeInt64(successfulCount),
      if (failedCount != null) 'failedCount': encodeInt64(failedCount),
      if (incompleteCount != null)
        'incompleteCount': encodeInt64(incompleteCount),
      if (successfulForecastPointCount != null)
        'successfulForecastPointCount': encodeInt64(
          successfulForecastPointCount,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (successfulCount != null) 'successfulCount=$successfulCount',
      if (failedCount != null) 'failedCount=$failedCount',
      if (incompleteCount != null) 'incompleteCount=$incompleteCount',
      if (successfulForecastPointCount != null)
        'successfulForecastPointCount=$successfulForecastPointCount',
    ].join(',');
    return 'CompletionStats($contents)';
  }
}

/// The base structured datatype containing multi-part content of a message.
///
/// A `Content` includes a `role` field designating the producer of the `Content`
/// and a `parts` field containing multi-part data that contains the content of
/// the message turn.
final class Content extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Content';

  /// Optional. The producer of the content. Must be either 'user' or 'model'.
  ///
  /// Useful to set for multi-turn conversations, otherwise can be left blank
  /// or unset.
  final String? role;

  /// Required. Ordered `Parts` that constitute a single message. Parts may have
  /// different IANA MIME types.
  final List<Part>? parts;

  Content({this.role, this.parts}) : super(fullyQualifiedName);

  factory Content.fromJson(Map<String, dynamic> json) {
    return Content(
      role: json['role'],
      parts: decodeListMessage(json['parts'], Part.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (role != null) 'role': role,
      if (parts != null) 'parts': encodeList(parts),
    };
  }

  @override
  String toString() {
    final contents = [if (role != null) 'role=$role'].join(',');
    return 'Content($contents)';
  }
}

/// A datatype containing media that is part of a multi-part `Content` message.
///
/// A `Part` consists of data which has an associated datatype. A `Part` can only
/// contain one of the accepted types in `Part.data`.
///
/// A `Part` must have a fixed IANA MIME type identifying the type and subtype
/// of the media if `inline_data` or `file_data` field is filled with raw bytes.
final class Part extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Part';

  /// Optional. Text part (can be code).
  final String? text;

  /// Optional. Inlined bytes data.
  final Blob? inlineData;

  /// Optional. URI based data.
  final FileData? fileData;

  /// Optional. A predicted [FunctionCall] returned from the model that
  /// contains a string representing the [FunctionDeclaration.name] with the
  /// parameters and their values.
  final FunctionCall? functionCall;

  /// Optional. The result output of a [FunctionCall] that contains a string
  /// representing the [FunctionDeclaration.name] and a structured JSON object
  /// containing any output from the function call. It is used as context to
  /// the model.
  final FunctionResponse? functionResponse;

  /// Optional. Code generated by the model that is meant to be executed.
  final ExecutableCode? executableCode;

  /// Optional. Result of executing the [ExecutableCode].
  final CodeExecutionResult? codeExecutionResult;

  /// Optional. Video metadata. The metadata should only be specified while the
  /// video data is presented in inline_data or file_data.
  final VideoMetadata? videoMetadata;

  /// Indicates if the part is thought from the model.
  final bool? thought;

  /// An opaque signature for the thought so it can be reused in subsequent
  /// requests.
  final Uint8List? thoughtSignature;

  Part({
    this.text,
    this.inlineData,
    this.fileData,
    this.functionCall,
    this.functionResponse,
    this.executableCode,
    this.codeExecutionResult,
    this.videoMetadata,
    this.thought,
    this.thoughtSignature,
  }) : super(fullyQualifiedName);

  factory Part.fromJson(Map<String, dynamic> json) {
    return Part(
      text: json['text'],
      inlineData: decode(json['inlineData'], Blob.fromJson),
      fileData: decode(json['fileData'], FileData.fromJson),
      functionCall: decode(json['functionCall'], FunctionCall.fromJson),
      functionResponse: decode(
        json['functionResponse'],
        FunctionResponse.fromJson,
      ),
      executableCode: decode(json['executableCode'], ExecutableCode.fromJson),
      codeExecutionResult: decode(
        json['codeExecutionResult'],
        CodeExecutionResult.fromJson,
      ),
      videoMetadata: decode(json['videoMetadata'], VideoMetadata.fromJson),
      thought: json['thought'],
      thoughtSignature: decodeBytes(json['thoughtSignature']),
    );
  }

  @override
  Object toJson() {
    return {
      if (text != null) 'text': text,
      if (inlineData != null) 'inlineData': inlineData!.toJson(),
      if (fileData != null) 'fileData': fileData!.toJson(),
      if (functionCall != null) 'functionCall': functionCall!.toJson(),
      if (functionResponse != null)
        'functionResponse': functionResponse!.toJson(),
      if (executableCode != null) 'executableCode': executableCode!.toJson(),
      if (codeExecutionResult != null)
        'codeExecutionResult': codeExecutionResult!.toJson(),
      if (videoMetadata != null) 'videoMetadata': videoMetadata!.toJson(),
      if (thought != null) 'thought': thought,
      if (thoughtSignature != null)
        'thoughtSignature': encodeBytes(thoughtSignature),
    };
  }

  @override
  String toString() {
    final contents = [
      if (text != null) 'text=$text',
      if (thought != null) 'thought=$thought',
      if (thoughtSignature != null) 'thoughtSignature=$thoughtSignature',
    ].join(',');
    return 'Part($contents)';
  }
}

/// Content blob.
///
/// It's preferred to send as `text`
/// directly rather than raw bytes.
final class Blob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Blob';

  /// Required. The IANA standard MIME type of the source data.
  final String? mimeType;

  /// Required. Raw bytes.
  final Uint8List? data;

  Blob({this.mimeType, this.data}) : super(fullyQualifiedName);

  factory Blob.fromJson(Map<String, dynamic> json) {
    return Blob(mimeType: json['mimeType'], data: decodeBytes(json['data']));
  }

  @override
  Object toJson() {
    return {
      if (mimeType != null) 'mimeType': mimeType,
      if (data != null) 'data': encodeBytes(data),
    };
  }

  @override
  String toString() {
    final contents = [
      if (mimeType != null) 'mimeType=$mimeType',
      if (data != null) 'data=$data',
    ].join(',');
    return 'Blob($contents)';
  }
}

/// URI based data.
final class FileData extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FileData';

  /// Required. The IANA standard MIME type of the source data.
  final String? mimeType;

  /// Required. URI.
  final String? fileUri;

  FileData({this.mimeType, this.fileUri}) : super(fullyQualifiedName);

  factory FileData.fromJson(Map<String, dynamic> json) {
    return FileData(mimeType: json['mimeType'], fileUri: json['fileUri']);
  }

  @override
  Object toJson() {
    return {
      if (mimeType != null) 'mimeType': mimeType,
      if (fileUri != null) 'fileUri': fileUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (mimeType != null) 'mimeType=$mimeType',
      if (fileUri != null) 'fileUri=$fileUri',
    ].join(',');
    return 'FileData($contents)';
  }
}

/// Metadata describes the input video content.
final class VideoMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VideoMetadata';

  /// Optional. The start offset of the video.
  final protobuf.Duration? startOffset;

  /// Optional. The end offset of the video.
  final protobuf.Duration? endOffset;

  VideoMetadata({this.startOffset, this.endOffset}) : super(fullyQualifiedName);

  factory VideoMetadata.fromJson(Map<String, dynamic> json) {
    return VideoMetadata(
      startOffset: decodeCustom(
        json['startOffset'],
        protobuf.Duration.fromJson,
      ),
      endOffset: decodeCustom(json['endOffset'], protobuf.Duration.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (startOffset != null) 'startOffset': startOffset!.toJson(),
      if (endOffset != null) 'endOffset': endOffset!.toJson(),
    };
  }

  @override
  String toString() => 'VideoMetadata()';
}

/// The configuration for the prebuilt speaker to use.
final class PrebuiltVoiceConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PrebuiltVoiceConfig';

  /// The name of the preset voice to use.
  final String? voiceName;

  PrebuiltVoiceConfig({this.voiceName}) : super(fullyQualifiedName);

  factory PrebuiltVoiceConfig.fromJson(Map<String, dynamic> json) {
    return PrebuiltVoiceConfig(voiceName: json['voiceName']);
  }

  @override
  Object toJson() {
    return {if (voiceName != null) 'voiceName': voiceName};
  }

  @override
  String toString() {
    final contents = [if (voiceName != null) 'voiceName=$voiceName'].join(',');
    return 'PrebuiltVoiceConfig($contents)';
  }
}

/// The configuration for the voice to use.
final class VoiceConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VoiceConfig';

  /// The configuration for the prebuilt voice to use.
  final PrebuiltVoiceConfig? prebuiltVoiceConfig;

  VoiceConfig({this.prebuiltVoiceConfig}) : super(fullyQualifiedName);

  factory VoiceConfig.fromJson(Map<String, dynamic> json) {
    return VoiceConfig(
      prebuiltVoiceConfig: decode(
        json['prebuiltVoiceConfig'],
        PrebuiltVoiceConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (prebuiltVoiceConfig != null)
        'prebuiltVoiceConfig': prebuiltVoiceConfig!.toJson(),
    };
  }

  @override
  String toString() => 'VoiceConfig()';
}

/// The speech generation config.
final class SpeechConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpeechConfig';

  /// The configuration for the speaker to use.
  final VoiceConfig? voiceConfig;

  SpeechConfig({this.voiceConfig}) : super(fullyQualifiedName);

  factory SpeechConfig.fromJson(Map<String, dynamic> json) {
    return SpeechConfig(
      voiceConfig: decode(json['voiceConfig'], VoiceConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (voiceConfig != null) 'voiceConfig': voiceConfig!.toJson()};
  }

  @override
  String toString() => 'SpeechConfig()';
}

/// Config for image generation features.
final class ImageConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImageConfig';

  /// Optional. The desired aspect ratio for the generated images. The following
  /// aspect ratios are supported:
  ///
  /// "1:1"
  /// "2:3", "3:2"
  /// "3:4", "4:3"
  /// "4:5", "5:4"
  /// "9:16", "16:9"
  /// "21:9"
  final String? aspectRatio;

  ImageConfig({this.aspectRatio}) : super(fullyQualifiedName);

  factory ImageConfig.fromJson(Map<String, dynamic> json) {
    return ImageConfig(aspectRatio: json['aspectRatio']);
  }

  @override
  Object toJson() {
    return {if (aspectRatio != null) 'aspectRatio': aspectRatio};
  }

  @override
  String toString() {
    final contents = [
      if (aspectRatio != null) 'aspectRatio=$aspectRatio',
    ].join(',');
    return 'ImageConfig($contents)';
  }
}

/// Generation config.
final class GenerationConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig';

  /// Optional. Controls the randomness of predictions.
  final double? temperature;

  /// Optional. If specified, nucleus sampling will be used.
  final double? topP;

  /// Optional. If specified, top-k sampling will be used.
  final double? topK;

  /// Optional. Number of candidates to generate.
  final int? candidateCount;

  /// Optional. The maximum number of output tokens to generate per message.
  final int? maxOutputTokens;

  /// Optional. Stop sequences.
  final List<String>? stopSequences;

  /// Optional. If true, export the logprobs results in response.
  final bool? responseLogprobs;

  /// Optional. Logit probabilities.
  final int? logprobs;

  /// Optional. Positive penalties.
  final double? presencePenalty;

  /// Optional. Frequency penalties.
  final double? frequencyPenalty;

  /// Optional. Seed.
  final int? seed;

  /// Optional. Output response mimetype of the generated candidate text.
  /// Supported mimetype:
  /// - `text/plain`: (default) Text output.
  /// - `application/json`: JSON response in the candidates.
  /// The model needs to be prompted to output the appropriate response type,
  /// otherwise the behavior is undefined.
  /// This is a preview feature.
  final String? responseMimeType;

  /// Optional. The `Schema` object allows the definition of input and output
  /// data types. These types can be objects, but also primitives and arrays.
  /// Represents a select subset of an [OpenAPI 3.0 schema
  /// object](https://spec.openapis.org/oas/v3.0.3#schema).
  /// If set, a compatible response_mime_type must also be set.
  /// Compatible mimetypes:
  /// `application/json`: Schema for JSON response.
  final Schema? responseSchema;

  /// Optional. Output schema of the generated response. This is an alternative
  /// to `response_schema` that accepts [JSON Schema](https://json-schema.org/).
  ///
  /// If set, `response_schema` must be omitted, but `response_mime_type` is
  /// required.
  ///
  /// While the full JSON Schema may be sent, not all features are supported.
  /// Specifically, only the following properties are supported:
  ///
  /// - `$id`
  /// - `$defs`
  /// - `$ref`
  /// - `$anchor`
  /// - `type`
  /// - `format`
  /// - `title`
  /// - `description`
  /// - `enum` (for strings and numbers)
  /// - `items`
  /// - `prefixItems`
  /// - `minItems`
  /// - `maxItems`
  /// - `minimum`
  /// - `maximum`
  /// - `anyOf`
  /// - `oneOf` (interpreted the same as `anyOf`)
  /// - `properties`
  /// - `additionalProperties`
  /// - `required`
  ///
  /// The non-standard `propertyOrdering` property may also be set.
  ///
  /// Cyclic references are unrolled to a limited degree and, as such, may only
  /// be used within non-required properties. (Nullable properties are not
  /// sufficient.) If `$ref` is set on a sub-schema, no other properties, except
  /// for than those starting as a `$`, may be set.
  final protobuf.Value? responseJsonSchema;

  /// Optional. Routing configuration.
  final GenerationConfig_RoutingConfig? routingConfig;

  /// Optional. If enabled, audio timestamp will be included in the request to
  /// the model.
  final bool? audioTimestamp;

  /// Optional. The modalities of the response.
  final List<GenerationConfig_Modality>? responseModalities;

  /// Optional. If specified, the media resolution specified will be used.
  final GenerationConfig_MediaResolution? mediaResolution;

  /// Optional. The speech generation config.
  final SpeechConfig? speechConfig;

  /// Optional. Config for thinking features.
  /// An error will be returned if this field is set for models that don't
  /// support thinking.
  final GenerationConfig_ThinkingConfig? thinkingConfig;

  /// Optional. Config for model selection.
  final GenerationConfig_ModelConfig? modelConfig;

  /// Optional. Config for image generation features.
  final ImageConfig? imageConfig;

  GenerationConfig({
    this.temperature,
    this.topP,
    this.topK,
    this.candidateCount,
    this.maxOutputTokens,
    this.stopSequences,
    this.responseLogprobs,
    this.logprobs,
    this.presencePenalty,
    this.frequencyPenalty,
    this.seed,
    this.responseMimeType,
    this.responseSchema,
    this.responseJsonSchema,
    this.routingConfig,
    this.audioTimestamp,
    this.responseModalities,
    this.mediaResolution,
    this.speechConfig,
    this.thinkingConfig,
    this.modelConfig,
    this.imageConfig,
  }) : super(fullyQualifiedName);

  factory GenerationConfig.fromJson(Map<String, dynamic> json) {
    return GenerationConfig(
      temperature: decodeDouble(json['temperature']),
      topP: decodeDouble(json['topP']),
      topK: decodeDouble(json['topK']),
      candidateCount: json['candidateCount'],
      maxOutputTokens: json['maxOutputTokens'],
      stopSequences: decodeList(json['stopSequences']),
      responseLogprobs: json['responseLogprobs'],
      logprobs: json['logprobs'],
      presencePenalty: decodeDouble(json['presencePenalty']),
      frequencyPenalty: decodeDouble(json['frequencyPenalty']),
      seed: json['seed'],
      responseMimeType: json['responseMimeType'],
      responseSchema: decode(json['responseSchema'], Schema.fromJson),
      responseJsonSchema: decodeCustom(
        json['responseJsonSchema'],
        protobuf.Value.fromJson,
      ),
      routingConfig: decode(
        json['routingConfig'],
        GenerationConfig_RoutingConfig.fromJson,
      ),
      audioTimestamp: json['audioTimestamp'],
      responseModalities: decodeListEnum(
        json['responseModalities'],
        GenerationConfig_Modality.fromJson,
      ),
      mediaResolution: decodeEnum(
        json['mediaResolution'],
        GenerationConfig_MediaResolution.fromJson,
      ),
      speechConfig: decode(json['speechConfig'], SpeechConfig.fromJson),
      thinkingConfig: decode(
        json['thinkingConfig'],
        GenerationConfig_ThinkingConfig.fromJson,
      ),
      modelConfig: decode(
        json['modelConfig'],
        GenerationConfig_ModelConfig.fromJson,
      ),
      imageConfig: decode(json['imageConfig'], ImageConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (temperature != null) 'temperature': encodeDouble(temperature),
      if (topP != null) 'topP': encodeDouble(topP),
      if (topK != null) 'topK': encodeDouble(topK),
      if (candidateCount != null) 'candidateCount': candidateCount,
      if (maxOutputTokens != null) 'maxOutputTokens': maxOutputTokens,
      if (stopSequences != null) 'stopSequences': stopSequences,
      if (responseLogprobs != null) 'responseLogprobs': responseLogprobs,
      if (logprobs != null) 'logprobs': logprobs,
      if (presencePenalty != null)
        'presencePenalty': encodeDouble(presencePenalty),
      if (frequencyPenalty != null)
        'frequencyPenalty': encodeDouble(frequencyPenalty),
      if (seed != null) 'seed': seed,
      if (responseMimeType != null) 'responseMimeType': responseMimeType,
      if (responseSchema != null) 'responseSchema': responseSchema!.toJson(),
      if (responseJsonSchema != null)
        'responseJsonSchema': responseJsonSchema!.toJson(),
      if (routingConfig != null) 'routingConfig': routingConfig!.toJson(),
      if (audioTimestamp != null) 'audioTimestamp': audioTimestamp,
      if (responseModalities != null)
        'responseModalities': encodeList(responseModalities),
      if (mediaResolution != null) 'mediaResolution': mediaResolution!.toJson(),
      if (speechConfig != null) 'speechConfig': speechConfig!.toJson(),
      if (thinkingConfig != null) 'thinkingConfig': thinkingConfig!.toJson(),
      if (modelConfig != null) 'modelConfig': modelConfig!.toJson(),
      if (imageConfig != null) 'imageConfig': imageConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (temperature != null) 'temperature=$temperature',
      if (topP != null) 'topP=$topP',
      if (topK != null) 'topK=$topK',
      if (candidateCount != null) 'candidateCount=$candidateCount',
      if (maxOutputTokens != null) 'maxOutputTokens=$maxOutputTokens',
      if (responseLogprobs != null) 'responseLogprobs=$responseLogprobs',
      if (logprobs != null) 'logprobs=$logprobs',
      if (presencePenalty != null) 'presencePenalty=$presencePenalty',
      if (frequencyPenalty != null) 'frequencyPenalty=$frequencyPenalty',
      if (seed != null) 'seed=$seed',
      if (responseMimeType != null) 'responseMimeType=$responseMimeType',
      if (audioTimestamp != null) 'audioTimestamp=$audioTimestamp',
      if (mediaResolution != null) 'mediaResolution=$mediaResolution',
    ].join(',');
    return 'GenerationConfig($contents)';
  }
}

/// The configuration for routing the request to a specific model.
final class GenerationConfig_RoutingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.RoutingConfig';

  /// Automated routing.
  final GenerationConfig_RoutingConfig_AutoRoutingMode? autoMode;

  /// Manual routing.
  final GenerationConfig_RoutingConfig_ManualRoutingMode? manualMode;

  GenerationConfig_RoutingConfig({this.autoMode, this.manualMode})
    : super(fullyQualifiedName);

  factory GenerationConfig_RoutingConfig.fromJson(Map<String, dynamic> json) {
    return GenerationConfig_RoutingConfig(
      autoMode: decode(
        json['autoMode'],
        GenerationConfig_RoutingConfig_AutoRoutingMode.fromJson,
      ),
      manualMode: decode(
        json['manualMode'],
        GenerationConfig_RoutingConfig_ManualRoutingMode.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (autoMode != null) 'autoMode': autoMode!.toJson(),
      if (manualMode != null) 'manualMode': manualMode!.toJson(),
    };
  }

  @override
  String toString() => 'RoutingConfig()';
}

/// When automated routing is specified, the routing will be determined by
/// the pretrained routing model and customer provided model routing
/// preference.
final class GenerationConfig_RoutingConfig_AutoRoutingMode
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.RoutingConfig.AutoRoutingMode';

  /// The model routing preference.
  final GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference?
  modelRoutingPreference;

  GenerationConfig_RoutingConfig_AutoRoutingMode({this.modelRoutingPreference})
    : super(fullyQualifiedName);

  factory GenerationConfig_RoutingConfig_AutoRoutingMode.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerationConfig_RoutingConfig_AutoRoutingMode(
      modelRoutingPreference: decodeEnum(
        json['modelRoutingPreference'],
        GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (modelRoutingPreference != null)
        'modelRoutingPreference': modelRoutingPreference!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (modelRoutingPreference != null)
        'modelRoutingPreference=$modelRoutingPreference',
    ].join(',');
    return 'AutoRoutingMode($contents)';
  }
}

/// The model routing preference.
final class GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference
    extends protobuf.ProtoEnum {
  /// Unspecified model routing preference.
  static const unknown =
      GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
        'UNKNOWN',
      );

  /// Prefer higher quality over low cost.
  static const prioritizeQuality =
      GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
        'PRIORITIZE_QUALITY',
      );

  /// Balanced model routing preference.
  static const balanced =
      GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
        'BALANCED',
      );

  /// Prefer lower cost over higher quality.
  static const prioritizeCost =
      GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
        'PRIORITIZE_COST',
      );

  const GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
    super.value,
  );

  factory GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference.fromJson(
    String json,
  ) => GenerationConfig_RoutingConfig_AutoRoutingMode_ModelRoutingPreference(
    json,
  );

  @override
  String toString() => 'ModelRoutingPreference.$value';
}

/// When manual routing is set, the specified model will be used directly.
final class GenerationConfig_RoutingConfig_ManualRoutingMode
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.RoutingConfig.ManualRoutingMode';

  /// The model name to use. Only the public LLM models are accepted. e.g.
  /// 'gemini-1.5-pro-001'.
  final String? modelName;

  GenerationConfig_RoutingConfig_ManualRoutingMode({this.modelName})
    : super(fullyQualifiedName);

  factory GenerationConfig_RoutingConfig_ManualRoutingMode.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerationConfig_RoutingConfig_ManualRoutingMode(
      modelName: json['modelName'],
    );
  }

  @override
  Object toJson() {
    return {if (modelName != null) 'modelName': modelName};
  }

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'ManualRoutingMode($contents)';
  }
}

/// Config for thinking features.
final class GenerationConfig_ThinkingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.ThinkingConfig';

  /// Indicates whether to include thoughts in the response.
  /// If true, thoughts are returned only when available.
  final bool? includeThoughts;

  /// Optional. Indicates the thinking budget in tokens.
  /// This is only applied when enable_thinking is true.
  final int? thinkingBudget;

  GenerationConfig_ThinkingConfig({this.includeThoughts, this.thinkingBudget})
    : super(fullyQualifiedName);

  factory GenerationConfig_ThinkingConfig.fromJson(Map<String, dynamic> json) {
    return GenerationConfig_ThinkingConfig(
      includeThoughts: json['includeThoughts'],
      thinkingBudget: json['thinkingBudget'],
    );
  }

  @override
  Object toJson() {
    return {
      if (includeThoughts != null) 'includeThoughts': includeThoughts,
      if (thinkingBudget != null) 'thinkingBudget': thinkingBudget,
    };
  }

  @override
  String toString() {
    final contents = [
      if (includeThoughts != null) 'includeThoughts=$includeThoughts',
      if (thinkingBudget != null) 'thinkingBudget=$thinkingBudget',
    ].join(',');
    return 'ThinkingConfig($contents)';
  }
}

/// Config for model selection.
final class GenerationConfig_ModelConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerationConfig.ModelConfig';

  /// Required. Feature selection preference.
  final GenerationConfig_ModelConfig_FeatureSelectionPreference?
  featureSelectionPreference;

  GenerationConfig_ModelConfig({this.featureSelectionPreference})
    : super(fullyQualifiedName);

  factory GenerationConfig_ModelConfig.fromJson(Map<String, dynamic> json) {
    return GenerationConfig_ModelConfig(
      featureSelectionPreference: decodeEnum(
        json['featureSelectionPreference'],
        GenerationConfig_ModelConfig_FeatureSelectionPreference.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureSelectionPreference != null)
        'featureSelectionPreference': featureSelectionPreference!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureSelectionPreference != null)
        'featureSelectionPreference=$featureSelectionPreference',
    ].join(',');
    return 'ModelConfig($contents)';
  }
}

/// Options for feature selection preference.
final class GenerationConfig_ModelConfig_FeatureSelectionPreference
    extends protobuf.ProtoEnum {
  /// Unspecified feature selection preference.
  static const featureSelectionPreferenceUnspecified =
      GenerationConfig_ModelConfig_FeatureSelectionPreference(
        'FEATURE_SELECTION_PREFERENCE_UNSPECIFIED',
      );

  /// Prefer higher quality over lower cost.
  static const prioritizeQuality =
      GenerationConfig_ModelConfig_FeatureSelectionPreference(
        'PRIORITIZE_QUALITY',
      );

  /// Balanced feature selection preference.
  static const balanced =
      GenerationConfig_ModelConfig_FeatureSelectionPreference('BALANCED');

  /// Prefer lower cost over higher quality.
  static const prioritizeCost =
      GenerationConfig_ModelConfig_FeatureSelectionPreference(
        'PRIORITIZE_COST',
      );

  const GenerationConfig_ModelConfig_FeatureSelectionPreference(super.value);

  factory GenerationConfig_ModelConfig_FeatureSelectionPreference.fromJson(
    String json,
  ) => GenerationConfig_ModelConfig_FeatureSelectionPreference(json);

  @override
  String toString() => 'FeatureSelectionPreference.$value';
}

/// The modalities of the response.
final class GenerationConfig_Modality extends protobuf.ProtoEnum {
  /// Unspecified modality. Will be processed as text.
  static const modalityUnspecified = GenerationConfig_Modality(
    'MODALITY_UNSPECIFIED',
  );

  /// Text modality.
  static const text = GenerationConfig_Modality('TEXT');

  /// Image modality.
  static const image = GenerationConfig_Modality('IMAGE');

  /// Audio modality.
  static const audio = GenerationConfig_Modality('AUDIO');

  const GenerationConfig_Modality(super.value);

  factory GenerationConfig_Modality.fromJson(String json) =>
      GenerationConfig_Modality(json);

  @override
  String toString() => 'Modality.$value';
}

/// Media resolution for the input media.
final class GenerationConfig_MediaResolution extends protobuf.ProtoEnum {
  /// Media resolution has not been set.
  static const mediaResolutionUnspecified = GenerationConfig_MediaResolution(
    'MEDIA_RESOLUTION_UNSPECIFIED',
  );

  /// Media resolution set to low (64 tokens).
  static const mediaResolutionLow = GenerationConfig_MediaResolution(
    'MEDIA_RESOLUTION_LOW',
  );

  /// Media resolution set to medium (256 tokens).
  static const mediaResolutionMedium = GenerationConfig_MediaResolution(
    'MEDIA_RESOLUTION_MEDIUM',
  );

  /// Media resolution set to high (zoomed reframing with 256 tokens).
  static const mediaResolutionHigh = GenerationConfig_MediaResolution(
    'MEDIA_RESOLUTION_HIGH',
  );

  const GenerationConfig_MediaResolution(super.value);

  factory GenerationConfig_MediaResolution.fromJson(String json) =>
      GenerationConfig_MediaResolution(json);

  @override
  String toString() => 'MediaResolution.$value';
}

/// Safety settings.
final class SafetySetting extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetySetting';

  /// Required. Harm category.
  final HarmCategory? category;

  /// Required. The harm block threshold.
  final SafetySetting_HarmBlockThreshold? threshold;

  /// Optional. Specify if the threshold is used for probability or severity
  /// score. If not specified, the threshold is used for probability score.
  final SafetySetting_HarmBlockMethod? method;

  SafetySetting({this.category, this.threshold, this.method})
    : super(fullyQualifiedName);

  factory SafetySetting.fromJson(Map<String, dynamic> json) {
    return SafetySetting(
      category: decodeEnum(json['category'], HarmCategory.fromJson),
      threshold: decodeEnum(
        json['threshold'],
        SafetySetting_HarmBlockThreshold.fromJson,
      ),
      method: decodeEnum(
        json['method'],
        SafetySetting_HarmBlockMethod.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (category != null) 'category': category!.toJson(),
      if (threshold != null) 'threshold': threshold!.toJson(),
      if (method != null) 'method': method!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (category != null) 'category=$category',
      if (threshold != null) 'threshold=$threshold',
      if (method != null) 'method=$method',
    ].join(',');
    return 'SafetySetting($contents)';
  }
}

/// Probability based thresholds levels for blocking.
final class SafetySetting_HarmBlockThreshold extends protobuf.ProtoEnum {
  /// Unspecified harm block threshold.
  static const harmBlockThresholdUnspecified = SafetySetting_HarmBlockThreshold(
    'HARM_BLOCK_THRESHOLD_UNSPECIFIED',
  );

  /// Block low threshold and above (i.e. block more).
  static const blockLowAndAbove = SafetySetting_HarmBlockThreshold(
    'BLOCK_LOW_AND_ABOVE',
  );

  /// Block medium threshold and above.
  static const blockMediumAndAbove = SafetySetting_HarmBlockThreshold(
    'BLOCK_MEDIUM_AND_ABOVE',
  );

  /// Block only high threshold (i.e. block less).
  static const blockOnlyHigh = SafetySetting_HarmBlockThreshold(
    'BLOCK_ONLY_HIGH',
  );

  /// Block none.
  static const blockNone = SafetySetting_HarmBlockThreshold('BLOCK_NONE');

  /// Turn off the safety filter.
  static const off = SafetySetting_HarmBlockThreshold('OFF');

  const SafetySetting_HarmBlockThreshold(super.value);

  factory SafetySetting_HarmBlockThreshold.fromJson(String json) =>
      SafetySetting_HarmBlockThreshold(json);

  @override
  String toString() => 'HarmBlockThreshold.$value';
}

/// Probability vs severity.
final class SafetySetting_HarmBlockMethod extends protobuf.ProtoEnum {
  /// The harm block method is unspecified.
  static const harmBlockMethodUnspecified = SafetySetting_HarmBlockMethod(
    'HARM_BLOCK_METHOD_UNSPECIFIED',
  );

  /// The harm block method uses both probability and severity scores.
  static const severity = SafetySetting_HarmBlockMethod('SEVERITY');

  /// The harm block method uses the probability score.
  static const probability = SafetySetting_HarmBlockMethod('PROBABILITY');

  const SafetySetting_HarmBlockMethod(super.value);

  factory SafetySetting_HarmBlockMethod.fromJson(String json) =>
      SafetySetting_HarmBlockMethod(json);

  @override
  String toString() => 'HarmBlockMethod.$value';
}

/// Safety rating corresponding to the generated content.
final class SafetyRating extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetyRating';

  /// Output only. Harm category.
  final HarmCategory? category;

  /// Output only. Harm probability levels in the content.
  final SafetyRating_HarmProbability? probability;

  /// Output only. Harm probability score.
  final double? probabilityScore;

  /// Output only. Harm severity levels in the content.
  final SafetyRating_HarmSeverity? severity;

  /// Output only. Harm severity score.
  final double? severityScore;

  /// Output only. Indicates whether the content was filtered out because of this
  /// rating.
  final bool? blocked;

  SafetyRating({
    this.category,
    this.probability,
    this.probabilityScore,
    this.severity,
    this.severityScore,
    this.blocked,
  }) : super(fullyQualifiedName);

  factory SafetyRating.fromJson(Map<String, dynamic> json) {
    return SafetyRating(
      category: decodeEnum(json['category'], HarmCategory.fromJson),
      probability: decodeEnum(
        json['probability'],
        SafetyRating_HarmProbability.fromJson,
      ),
      probabilityScore: decodeDouble(json['probabilityScore']),
      severity: decodeEnum(
        json['severity'],
        SafetyRating_HarmSeverity.fromJson,
      ),
      severityScore: decodeDouble(json['severityScore']),
      blocked: json['blocked'],
    );
  }

  @override
  Object toJson() {
    return {
      if (category != null) 'category': category!.toJson(),
      if (probability != null) 'probability': probability!.toJson(),
      if (probabilityScore != null)
        'probabilityScore': encodeDouble(probabilityScore),
      if (severity != null) 'severity': severity!.toJson(),
      if (severityScore != null) 'severityScore': encodeDouble(severityScore),
      if (blocked != null) 'blocked': blocked,
    };
  }

  @override
  String toString() {
    final contents = [
      if (category != null) 'category=$category',
      if (probability != null) 'probability=$probability',
      if (probabilityScore != null) 'probabilityScore=$probabilityScore',
      if (severity != null) 'severity=$severity',
      if (severityScore != null) 'severityScore=$severityScore',
      if (blocked != null) 'blocked=$blocked',
    ].join(',');
    return 'SafetyRating($contents)';
  }
}

/// Harm probability levels in the content.
final class SafetyRating_HarmProbability extends protobuf.ProtoEnum {
  /// Harm probability unspecified.
  static const harmProbabilityUnspecified = SafetyRating_HarmProbability(
    'HARM_PROBABILITY_UNSPECIFIED',
  );

  /// Negligible level of harm.
  static const negligible = SafetyRating_HarmProbability('NEGLIGIBLE');

  /// Low level of harm.
  static const low = SafetyRating_HarmProbability('LOW');

  /// Medium level of harm.
  static const medium = SafetyRating_HarmProbability('MEDIUM');

  /// High level of harm.
  static const high = SafetyRating_HarmProbability('HIGH');

  const SafetyRating_HarmProbability(super.value);

  factory SafetyRating_HarmProbability.fromJson(String json) =>
      SafetyRating_HarmProbability(json);

  @override
  String toString() => 'HarmProbability.$value';
}

/// Harm severity levels.
final class SafetyRating_HarmSeverity extends protobuf.ProtoEnum {
  /// Harm severity unspecified.
  static const harmSeverityUnspecified = SafetyRating_HarmSeverity(
    'HARM_SEVERITY_UNSPECIFIED',
  );

  /// Negligible level of harm severity.
  static const harmSeverityNegligible = SafetyRating_HarmSeverity(
    'HARM_SEVERITY_NEGLIGIBLE',
  );

  /// Low level of harm severity.
  static const harmSeverityLow = SafetyRating_HarmSeverity('HARM_SEVERITY_LOW');

  /// Medium level of harm severity.
  static const harmSeverityMedium = SafetyRating_HarmSeverity(
    'HARM_SEVERITY_MEDIUM',
  );

  /// High level of harm severity.
  static const harmSeverityHigh = SafetyRating_HarmSeverity(
    'HARM_SEVERITY_HIGH',
  );

  const SafetyRating_HarmSeverity(super.value);

  factory SafetyRating_HarmSeverity.fromJson(String json) =>
      SafetyRating_HarmSeverity(json);

  @override
  String toString() => 'HarmSeverity.$value';
}

/// A collection of source attributions for a piece of content.
final class CitationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CitationMetadata';

  /// Output only. List of citations.
  final List<Citation>? citations;

  CitationMetadata({this.citations}) : super(fullyQualifiedName);

  factory CitationMetadata.fromJson(Map<String, dynamic> json) {
    return CitationMetadata(
      citations: decodeListMessage(json['citations'], Citation.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (citations != null) 'citations': encodeList(citations)};
  }

  @override
  String toString() => 'CitationMetadata()';
}

/// Source attributions for content.
final class Citation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Citation';

  /// Output only. Start index into the content.
  final int? startIndex;

  /// Output only. End index into the content.
  final int? endIndex;

  /// Output only. Url reference of the attribution.
  final String? uri;

  /// Output only. Title of the attribution.
  final String? title;

  /// Output only. License of the attribution.
  final String? license;

  /// Output only. Publication date of the attribution.
  final Date? publicationDate;

  Citation({
    this.startIndex,
    this.endIndex,
    this.uri,
    this.title,
    this.license,
    this.publicationDate,
  }) : super(fullyQualifiedName);

  factory Citation.fromJson(Map<String, dynamic> json) {
    return Citation(
      startIndex: json['startIndex'],
      endIndex: json['endIndex'],
      uri: json['uri'],
      title: json['title'],
      license: json['license'],
      publicationDate: decode(json['publicationDate'], Date.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (startIndex != null) 'startIndex': startIndex,
      if (endIndex != null) 'endIndex': endIndex,
      if (uri != null) 'uri': uri,
      if (title != null) 'title': title,
      if (license != null) 'license': license,
      if (publicationDate != null) 'publicationDate': publicationDate!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (startIndex != null) 'startIndex=$startIndex',
      if (endIndex != null) 'endIndex=$endIndex',
      if (uri != null) 'uri=$uri',
      if (title != null) 'title=$title',
      if (license != null) 'license=$license',
    ].join(',');
    return 'Citation($contents)';
  }
}

/// A response candidate generated from the model.
final class Candidate extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Candidate';

  /// Output only. Index of the candidate.
  final int? index;

  /// Output only. Content parts of the candidate.
  final Content? content;

  /// Output only. Average log probability score of the candidate.
  final double? avgLogprobs;

  /// Output only. Log-likelihood scores for the response tokens and top tokens
  final LogprobsResult? logprobsResult;

  /// Output only. The reason why the model stopped generating tokens.
  /// If empty, the model has not stopped generating the tokens.
  final Candidate_FinishReason? finishReason;

  /// Output only. List of ratings for the safety of a response candidate.
  ///
  /// There is at most one rating per category.
  final List<SafetyRating>? safetyRatings;

  /// Output only. Describes the reason the mode stopped generating tokens in
  /// more detail. This is only filled when `finish_reason` is set.
  final String? finishMessage;

  /// Output only. Source attribution of the generated content.
  final CitationMetadata? citationMetadata;

  /// Output only. Metadata specifies sources used to ground generated content.
  final GroundingMetadata? groundingMetadata;

  /// Output only. Metadata related to url context retrieval tool.
  final UrlContextMetadata? urlContextMetadata;

  Candidate({
    this.index,
    this.content,
    this.avgLogprobs,
    this.logprobsResult,
    this.finishReason,
    this.safetyRatings,
    this.finishMessage,
    this.citationMetadata,
    this.groundingMetadata,
    this.urlContextMetadata,
  }) : super(fullyQualifiedName);

  factory Candidate.fromJson(Map<String, dynamic> json) {
    return Candidate(
      index: json['index'],
      content: decode(json['content'], Content.fromJson),
      avgLogprobs: decodeDouble(json['avgLogprobs']),
      logprobsResult: decode(json['logprobsResult'], LogprobsResult.fromJson),
      finishReason: decodeEnum(
        json['finishReason'],
        Candidate_FinishReason.fromJson,
      ),
      safetyRatings: decodeListMessage(
        json['safetyRatings'],
        SafetyRating.fromJson,
      ),
      finishMessage: json['finishMessage'],
      citationMetadata: decode(
        json['citationMetadata'],
        CitationMetadata.fromJson,
      ),
      groundingMetadata: decode(
        json['groundingMetadata'],
        GroundingMetadata.fromJson,
      ),
      urlContextMetadata: decode(
        json['urlContextMetadata'],
        UrlContextMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (index != null) 'index': index,
      if (content != null) 'content': content!.toJson(),
      if (avgLogprobs != null) 'avgLogprobs': encodeDouble(avgLogprobs),
      if (logprobsResult != null) 'logprobsResult': logprobsResult!.toJson(),
      if (finishReason != null) 'finishReason': finishReason!.toJson(),
      if (safetyRatings != null) 'safetyRatings': encodeList(safetyRatings),
      if (finishMessage != null) 'finishMessage': finishMessage,
      if (citationMetadata != null)
        'citationMetadata': citationMetadata!.toJson(),
      if (groundingMetadata != null)
        'groundingMetadata': groundingMetadata!.toJson(),
      if (urlContextMetadata != null)
        'urlContextMetadata': urlContextMetadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (index != null) 'index=$index',
      if (avgLogprobs != null) 'avgLogprobs=$avgLogprobs',
      if (finishReason != null) 'finishReason=$finishReason',
      if (finishMessage != null) 'finishMessage=$finishMessage',
    ].join(',');
    return 'Candidate($contents)';
  }
}

/// The reason why the model stopped generating tokens.
/// If empty, the model has not stopped generating the tokens.
final class Candidate_FinishReason extends protobuf.ProtoEnum {
  /// The finish reason is unspecified.
  static const finishReasonUnspecified = Candidate_FinishReason(
    'FINISH_REASON_UNSPECIFIED',
  );

  /// Token generation reached a natural stopping point or a configured stop
  /// sequence.
  static const stop = Candidate_FinishReason('STOP');

  /// Token generation reached the configured maximum output tokens.
  static const maxTokens = Candidate_FinishReason('MAX_TOKENS');

  /// Token generation stopped because the content potentially contains safety
  /// violations. NOTE: When streaming,
  /// `content` is empty if
  /// content filters blocks the output.
  static const safety = Candidate_FinishReason('SAFETY');

  /// Token generation stopped because the content potentially contains
  /// copyright violations.
  static const recitation = Candidate_FinishReason('RECITATION');

  /// All other reasons that stopped the token generation.
  static const other = Candidate_FinishReason('OTHER');

  /// Token generation stopped because the content contains forbidden terms.
  static const blocklist = Candidate_FinishReason('BLOCKLIST');

  /// Token generation stopped for potentially containing prohibited content.
  static const prohibitedContent = Candidate_FinishReason('PROHIBITED_CONTENT');

  /// Token generation stopped because the content potentially contains
  /// Sensitive Personally Identifiable Information (SPII).
  static const spii = Candidate_FinishReason('SPII');

  /// The function call generated by the model is invalid.
  static const malformedFunctionCall = Candidate_FinishReason(
    'MALFORMED_FUNCTION_CALL',
  );

  /// The model response was blocked by Model Armor.
  static const modelArmor = Candidate_FinishReason('MODEL_ARMOR');

  const Candidate_FinishReason(super.value);

  factory Candidate_FinishReason.fromJson(String json) =>
      Candidate_FinishReason(json);

  @override
  String toString() => 'FinishReason.$value';
}

/// Metadata related to url context retrieval tool.
final class UrlContextMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UrlContextMetadata';

  /// Output only. List of url context.
  final List<UrlMetadata>? urlMetadata;

  UrlContextMetadata({this.urlMetadata}) : super(fullyQualifiedName);

  factory UrlContextMetadata.fromJson(Map<String, dynamic> json) {
    return UrlContextMetadata(
      urlMetadata: decodeListMessage(json['urlMetadata'], UrlMetadata.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (urlMetadata != null) 'urlMetadata': encodeList(urlMetadata)};
  }

  @override
  String toString() => 'UrlContextMetadata()';
}

/// Context of the a single url retrieval.
final class UrlMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UrlMetadata';

  /// Retrieved url by the tool.
  final String? retrievedUrl;

  /// Status of the url retrieval.
  final UrlMetadata_UrlRetrievalStatus? urlRetrievalStatus;

  UrlMetadata({this.retrievedUrl, this.urlRetrievalStatus})
    : super(fullyQualifiedName);

  factory UrlMetadata.fromJson(Map<String, dynamic> json) {
    return UrlMetadata(
      retrievedUrl: json['retrievedUrl'],
      urlRetrievalStatus: decodeEnum(
        json['urlRetrievalStatus'],
        UrlMetadata_UrlRetrievalStatus.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (retrievedUrl != null) 'retrievedUrl': retrievedUrl,
      if (urlRetrievalStatus != null)
        'urlRetrievalStatus': urlRetrievalStatus!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (retrievedUrl != null) 'retrievedUrl=$retrievedUrl',
      if (urlRetrievalStatus != null) 'urlRetrievalStatus=$urlRetrievalStatus',
    ].join(',');
    return 'UrlMetadata($contents)';
  }
}

/// Status of the url retrieval.
final class UrlMetadata_UrlRetrievalStatus extends protobuf.ProtoEnum {
  /// Default value. This value is unused.
  static const urlRetrievalStatusUnspecified = UrlMetadata_UrlRetrievalStatus(
    'URL_RETRIEVAL_STATUS_UNSPECIFIED',
  );

  /// Url retrieval is successful.
  static const urlRetrievalStatusSuccess = UrlMetadata_UrlRetrievalStatus(
    'URL_RETRIEVAL_STATUS_SUCCESS',
  );

  /// Url retrieval is failed due to error.
  static const urlRetrievalStatusError = UrlMetadata_UrlRetrievalStatus(
    'URL_RETRIEVAL_STATUS_ERROR',
  );

  const UrlMetadata_UrlRetrievalStatus(super.value);

  factory UrlMetadata_UrlRetrievalStatus.fromJson(String json) =>
      UrlMetadata_UrlRetrievalStatus(json);

  @override
  String toString() => 'UrlRetrievalStatus.$value';
}

/// Logprobs Result
final class LogprobsResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LogprobsResult';

  /// Length = total number of decoding steps.
  final List<LogprobsResult_TopCandidates>? topCandidates;

  /// Length = total number of decoding steps.
  /// The chosen candidates may or may not be in top_candidates.
  final List<LogprobsResult_Candidate>? chosenCandidates;

  LogprobsResult({this.topCandidates, this.chosenCandidates})
    : super(fullyQualifiedName);

  factory LogprobsResult.fromJson(Map<String, dynamic> json) {
    return LogprobsResult(
      topCandidates: decodeListMessage(
        json['topCandidates'],
        LogprobsResult_TopCandidates.fromJson,
      ),
      chosenCandidates: decodeListMessage(
        json['chosenCandidates'],
        LogprobsResult_Candidate.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (topCandidates != null) 'topCandidates': encodeList(topCandidates),
      if (chosenCandidates != null)
        'chosenCandidates': encodeList(chosenCandidates),
    };
  }

  @override
  String toString() => 'LogprobsResult()';
}

/// Candidate for the logprobs token and score.
final class LogprobsResult_Candidate extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LogprobsResult.Candidate';

  /// The candidates token string value.
  final String? token;

  /// The candidates token id value.
  final int? tokenId;

  /// The candidate's log probability.
  final double? logProbability;

  LogprobsResult_Candidate({this.token, this.tokenId, this.logProbability})
    : super(fullyQualifiedName);

  factory LogprobsResult_Candidate.fromJson(Map<String, dynamic> json) {
    return LogprobsResult_Candidate(
      token: json['token'],
      tokenId: json['tokenId'],
      logProbability: decodeDouble(json['logProbability']),
    );
  }

  @override
  Object toJson() {
    return {
      if (token != null) 'token': token,
      if (tokenId != null) 'tokenId': tokenId,
      if (logProbability != null)
        'logProbability': encodeDouble(logProbability),
    };
  }

  @override
  String toString() {
    final contents = [
      if (token != null) 'token=$token',
      if (tokenId != null) 'tokenId=$tokenId',
      if (logProbability != null) 'logProbability=$logProbability',
    ].join(',');
    return 'Candidate($contents)';
  }
}

/// Candidates with top log probabilities at each decoding step.
final class LogprobsResult_TopCandidates extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LogprobsResult.TopCandidates';

  /// Sorted by log probability in descending order.
  final List<LogprobsResult_Candidate>? candidates;

  LogprobsResult_TopCandidates({this.candidates}) : super(fullyQualifiedName);

  factory LogprobsResult_TopCandidates.fromJson(Map<String, dynamic> json) {
    return LogprobsResult_TopCandidates(
      candidates: decodeListMessage(
        json['candidates'],
        LogprobsResult_Candidate.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (candidates != null) 'candidates': encodeList(candidates)};
  }

  @override
  String toString() => 'TopCandidates()';
}

/// Segment of the content.
final class Segment extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Segment';

  /// Output only. The index of a Part object within its parent Content object.
  final int? partIndex;

  /// Output only. Start index in the given Part, measured in bytes. Offset from
  /// the start of the Part, inclusive, starting at zero.
  final int? startIndex;

  /// Output only. End index in the given Part, measured in bytes. Offset from
  /// the start of the Part, exclusive, starting at zero.
  final int? endIndex;

  /// Output only. The text corresponding to the segment from the response.
  final String? text;

  Segment({this.partIndex, this.startIndex, this.endIndex, this.text})
    : super(fullyQualifiedName);

  factory Segment.fromJson(Map<String, dynamic> json) {
    return Segment(
      partIndex: json['partIndex'],
      startIndex: json['startIndex'],
      endIndex: json['endIndex'],
      text: json['text'],
    );
  }

  @override
  Object toJson() {
    return {
      if (partIndex != null) 'partIndex': partIndex,
      if (startIndex != null) 'startIndex': startIndex,
      if (endIndex != null) 'endIndex': endIndex,
      if (text != null) 'text': text,
    };
  }

  @override
  String toString() {
    final contents = [
      if (partIndex != null) 'partIndex=$partIndex',
      if (startIndex != null) 'startIndex=$startIndex',
      if (endIndex != null) 'endIndex=$endIndex',
      if (text != null) 'text=$text',
    ].join(',');
    return 'Segment($contents)';
  }
}

/// Grounding chunk.
final class GroundingChunk extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk';

  /// Grounding chunk from the web.
  final GroundingChunk_Web? web;

  /// Grounding chunk from context retrieved by the retrieval tools.
  final GroundingChunk_RetrievedContext? retrievedContext;

  /// Grounding chunk from Google Maps.
  final GroundingChunk_Maps? maps;

  GroundingChunk({this.web, this.retrievedContext, this.maps})
    : super(fullyQualifiedName);

  factory GroundingChunk.fromJson(Map<String, dynamic> json) {
    return GroundingChunk(
      web: decode(json['web'], GroundingChunk_Web.fromJson),
      retrievedContext: decode(
        json['retrievedContext'],
        GroundingChunk_RetrievedContext.fromJson,
      ),
      maps: decode(json['maps'], GroundingChunk_Maps.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (web != null) 'web': web!.toJson(),
      if (retrievedContext != null)
        'retrievedContext': retrievedContext!.toJson(),
      if (maps != null) 'maps': maps!.toJson(),
    };
  }

  @override
  String toString() => 'GroundingChunk()';
}

/// Chunk from the web.
final class GroundingChunk_Web extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.Web';

  /// URI reference of the chunk.
  final String? uri;

  /// Title of the chunk.
  final String? title;

  GroundingChunk_Web({this.uri, this.title}) : super(fullyQualifiedName);

  factory GroundingChunk_Web.fromJson(Map<String, dynamic> json) {
    return GroundingChunk_Web(uri: json['uri'], title: json['title']);
  }

  @override
  Object toJson() {
    return {if (uri != null) 'uri': uri, if (title != null) 'title': title};
  }

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (title != null) 'title=$title',
    ].join(',');
    return 'Web($contents)';
  }
}

/// Chunk from context retrieved by the retrieval tools.
final class GroundingChunk_RetrievedContext extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.RetrievedContext';

  /// Additional context for the RAG retrieval result. This is only populated
  /// when using the RAG retrieval tool.
  final RagChunk? ragChunk;

  /// URI reference of the attribution.
  final String? uri;

  /// Title of the attribution.
  final String? title;

  /// Text of the attribution.
  final String? text;

  /// Output only. The full document name for the referenced Vertex AI Search
  /// document.
  final String? documentName;

  GroundingChunk_RetrievedContext({
    this.ragChunk,
    this.uri,
    this.title,
    this.text,
    this.documentName,
  }) : super(fullyQualifiedName);

  factory GroundingChunk_RetrievedContext.fromJson(Map<String, dynamic> json) {
    return GroundingChunk_RetrievedContext(
      ragChunk: decode(json['ragChunk'], RagChunk.fromJson),
      uri: json['uri'],
      title: json['title'],
      text: json['text'],
      documentName: json['documentName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (ragChunk != null) 'ragChunk': ragChunk!.toJson(),
      if (uri != null) 'uri': uri,
      if (title != null) 'title': title,
      if (text != null) 'text': text,
      if (documentName != null) 'documentName': documentName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (title != null) 'title=$title',
      if (text != null) 'text=$text',
      if (documentName != null) 'documentName=$documentName',
    ].join(',');
    return 'RetrievedContext($contents)';
  }
}

/// Chunk from Google Maps.
final class GroundingChunk_Maps extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.Maps';

  /// URI reference of the chunk.
  final String? uri;

  /// Title of the chunk.
  final String? title;

  /// Text of the chunk.
  final String? text;

  /// This Place's resource name, in `places/{place_id}` format.  Can be used
  /// to look up the Place.
  final String? placeId;

  /// Sources used to generate the place answer.
  /// This includes review snippets and photos that were used to generate the
  /// answer, as well as uris to flag content.
  final GroundingChunk_Maps_PlaceAnswerSources? placeAnswerSources;

  GroundingChunk_Maps({
    this.uri,
    this.title,
    this.text,
    this.placeId,
    this.placeAnswerSources,
  }) : super(fullyQualifiedName);

  factory GroundingChunk_Maps.fromJson(Map<String, dynamic> json) {
    return GroundingChunk_Maps(
      uri: json['uri'],
      title: json['title'],
      text: json['text'],
      placeId: json['placeId'],
      placeAnswerSources: decode(
        json['placeAnswerSources'],
        GroundingChunk_Maps_PlaceAnswerSources.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (uri != null) 'uri': uri,
      if (title != null) 'title': title,
      if (text != null) 'text': text,
      if (placeId != null) 'placeId': placeId,
      if (placeAnswerSources != null)
        'placeAnswerSources': placeAnswerSources!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (title != null) 'title=$title',
      if (text != null) 'text=$text',
      if (placeId != null) 'placeId=$placeId',
    ].join(',');
    return 'Maps($contents)';
  }
}

final class GroundingChunk_Maps_PlaceAnswerSources
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.Maps.PlaceAnswerSources';

  /// Snippets of reviews that are used to generate the answer.
  final List<GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet>?
  reviewSnippets;

  GroundingChunk_Maps_PlaceAnswerSources({this.reviewSnippets})
    : super(fullyQualifiedName);

  factory GroundingChunk_Maps_PlaceAnswerSources.fromJson(
    Map<String, dynamic> json,
  ) {
    return GroundingChunk_Maps_PlaceAnswerSources(
      reviewSnippets: decodeListMessage(
        json['reviewSnippets'],
        GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (reviewSnippets != null) 'reviewSnippets': encodeList(reviewSnippets),
    };
  }

  @override
  String toString() => 'PlaceAnswerSources()';
}

/// Encapsulates a review snippet.
final class GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingChunk.Maps.PlaceAnswerSources.ReviewSnippet';

  /// Id of the review referencing the place.
  final String? reviewId;

  /// A link to show the review on Google Maps.
  final String? googleMapsUri;

  /// Title of the review.
  final String? title;

  GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet({
    this.reviewId,
    this.googleMapsUri,
    this.title,
  }) : super(fullyQualifiedName);

  factory GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet.fromJson(
    Map<String, dynamic> json,
  ) {
    return GroundingChunk_Maps_PlaceAnswerSources_ReviewSnippet(
      reviewId: json['reviewId'],
      googleMapsUri: json['googleMapsUri'],
      title: json['title'],
    );
  }

  @override
  Object toJson() {
    return {
      if (reviewId != null) 'reviewId': reviewId,
      if (googleMapsUri != null) 'googleMapsUri': googleMapsUri,
      if (title != null) 'title': title,
    };
  }

  @override
  String toString() {
    final contents = [
      if (reviewId != null) 'reviewId=$reviewId',
      if (googleMapsUri != null) 'googleMapsUri=$googleMapsUri',
      if (title != null) 'title=$title',
    ].join(',');
    return 'ReviewSnippet($contents)';
  }
}

/// Grounding support.
final class GroundingSupport extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingSupport';

  /// Segment of the content this support belongs to.
  final Segment? segment;

  /// A list of indices (into 'grounding_chunk') specifying the
  /// citations associated with the claim. For instance [1,3,4] means
  /// that grounding_chunk[1], grounding_chunk[3],
  /// grounding_chunk[4] are the retrieved content attributed to the claim.
  final List<int>? groundingChunkIndices;

  /// Confidence score of the support references. Ranges from 0 to 1. 1 is the
  /// most confident. This list must have the same size as the
  /// grounding_chunk_indices.
  final List<double>? confidenceScores;

  GroundingSupport({
    this.segment,
    this.groundingChunkIndices,
    this.confidenceScores,
  }) : super(fullyQualifiedName);

  factory GroundingSupport.fromJson(Map<String, dynamic> json) {
    return GroundingSupport(
      segment: decode(json['segment'], Segment.fromJson),
      groundingChunkIndices: decodeList(json['groundingChunkIndices']),
      confidenceScores: decodeList(json['confidenceScores']),
    );
  }

  @override
  Object toJson() {
    return {
      if (segment != null) 'segment': segment!.toJson(),
      if (groundingChunkIndices != null)
        'groundingChunkIndices': groundingChunkIndices,
      if (confidenceScores != null) 'confidenceScores': confidenceScores,
    };
  }

  @override
  String toString() => 'GroundingSupport()';
}

/// Metadata returned to client when grounding is enabled.
final class GroundingMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingMetadata';

  /// Optional. Web search queries for the following-up web search.
  final List<String>? webSearchQueries;

  /// Optional. Google search entry for the following-up web searches.
  final SearchEntryPoint? searchEntryPoint;

  /// Optional. Queries executed by the retrieval tools.
  final List<String>? retrievalQueries;

  /// List of supporting references retrieved from specified grounding source.
  final List<GroundingChunk>? groundingChunks;

  /// Optional. List of grounding support.
  final List<GroundingSupport>? groundingSupports;

  /// Optional. Output only. Retrieval metadata.
  final RetrievalMetadata? retrievalMetadata;

  /// Optional. Output only. Resource name of the Google Maps widget context
  /// token to be used with the PlacesContextElement widget to render contextual
  /// data. This is populated only for Google Maps grounding.
  final String? googleMapsWidgetContextToken;

  /// List of source flagging uris. This is currently populated only for Google
  /// Maps grounding.
  final List<GroundingMetadata_SourceFlaggingUri>? sourceFlaggingUris;

  GroundingMetadata({
    this.webSearchQueries,
    this.searchEntryPoint,
    this.retrievalQueries,
    this.groundingChunks,
    this.groundingSupports,
    this.retrievalMetadata,
    this.googleMapsWidgetContextToken,
    this.sourceFlaggingUris,
  }) : super(fullyQualifiedName);

  factory GroundingMetadata.fromJson(Map<String, dynamic> json) {
    return GroundingMetadata(
      webSearchQueries: decodeList(json['webSearchQueries']),
      searchEntryPoint: decode(
        json['searchEntryPoint'],
        SearchEntryPoint.fromJson,
      ),
      retrievalQueries: decodeList(json['retrievalQueries']),
      groundingChunks: decodeListMessage(
        json['groundingChunks'],
        GroundingChunk.fromJson,
      ),
      groundingSupports: decodeListMessage(
        json['groundingSupports'],
        GroundingSupport.fromJson,
      ),
      retrievalMetadata: decode(
        json['retrievalMetadata'],
        RetrievalMetadata.fromJson,
      ),
      googleMapsWidgetContextToken: json['googleMapsWidgetContextToken'],
      sourceFlaggingUris: decodeListMessage(
        json['sourceFlaggingUris'],
        GroundingMetadata_SourceFlaggingUri.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (webSearchQueries != null) 'webSearchQueries': webSearchQueries,
      if (searchEntryPoint != null)
        'searchEntryPoint': searchEntryPoint!.toJson(),
      if (retrievalQueries != null) 'retrievalQueries': retrievalQueries,
      if (groundingChunks != null)
        'groundingChunks': encodeList(groundingChunks),
      if (groundingSupports != null)
        'groundingSupports': encodeList(groundingSupports),
      if (retrievalMetadata != null)
        'retrievalMetadata': retrievalMetadata!.toJson(),
      if (googleMapsWidgetContextToken != null)
        'googleMapsWidgetContextToken': googleMapsWidgetContextToken,
      if (sourceFlaggingUris != null)
        'sourceFlaggingUris': encodeList(sourceFlaggingUris),
    };
  }

  @override
  String toString() {
    final contents = [
      if (googleMapsWidgetContextToken != null)
        'googleMapsWidgetContextToken=$googleMapsWidgetContextToken',
    ].join(',');
    return 'GroundingMetadata($contents)';
  }
}

/// Source content flagging uri for a place or review. This is currently
/// populated only for Google Maps grounding.
final class GroundingMetadata_SourceFlaggingUri extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundingMetadata.SourceFlaggingUri';

  /// Id of the place or review.
  final String? sourceId;

  /// A link where users can flag a problem with the source (place or review).
  /// (-- The link is generated by Google and it does not contain
  /// information from the user query. It may contain information of the
  /// content it is flagging, which can be used to identify places. --)
  final String? flagContentUri;

  GroundingMetadata_SourceFlaggingUri({this.sourceId, this.flagContentUri})
    : super(fullyQualifiedName);

  factory GroundingMetadata_SourceFlaggingUri.fromJson(
    Map<String, dynamic> json,
  ) {
    return GroundingMetadata_SourceFlaggingUri(
      sourceId: json['sourceId'],
      flagContentUri: json['flagContentUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (sourceId != null) 'sourceId': sourceId,
      if (flagContentUri != null) 'flagContentUri': flagContentUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (sourceId != null) 'sourceId=$sourceId',
      if (flagContentUri != null) 'flagContentUri=$flagContentUri',
    ].join(',');
    return 'SourceFlaggingUri($contents)';
  }
}

/// Google search entry point.
final class SearchEntryPoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchEntryPoint';

  /// Optional. Web content snippet that can be embedded in a web page or an app
  /// webview.
  final String? renderedContent;

  /// Optional. Base64 encoded JSON representing array of <search term, search
  /// url> tuple.
  final Uint8List? sdkBlob;

  SearchEntryPoint({this.renderedContent, this.sdkBlob})
    : super(fullyQualifiedName);

  factory SearchEntryPoint.fromJson(Map<String, dynamic> json) {
    return SearchEntryPoint(
      renderedContent: json['renderedContent'],
      sdkBlob: decodeBytes(json['sdkBlob']),
    );
  }

  @override
  Object toJson() {
    return {
      if (renderedContent != null) 'renderedContent': renderedContent,
      if (sdkBlob != null) 'sdkBlob': encodeBytes(sdkBlob),
    };
  }

  @override
  String toString() {
    final contents = [
      if (renderedContent != null) 'renderedContent=$renderedContent',
      if (sdkBlob != null) 'sdkBlob=$sdkBlob',
    ].join(',');
    return 'SearchEntryPoint($contents)';
  }
}

/// Metadata related to retrieval in the grounding flow.
final class RetrievalMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrievalMetadata';

  /// Optional. Score indicating how likely information from Google Search could
  /// help answer the prompt. The score is in the range `[0, 1]`, where 0 is the
  /// least likely and 1 is the most likely. This score is only populated when
  /// Google Search grounding and dynamic retrieval is enabled. It will be
  /// compared to the threshold to determine whether to trigger Google Search.
  final double? googleSearchDynamicRetrievalScore;

  RetrievalMetadata({this.googleSearchDynamicRetrievalScore})
    : super(fullyQualifiedName);

  factory RetrievalMetadata.fromJson(Map<String, dynamic> json) {
    return RetrievalMetadata(
      googleSearchDynamicRetrievalScore: decodeDouble(
        json['googleSearchDynamicRetrievalScore'],
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (googleSearchDynamicRetrievalScore != null)
        'googleSearchDynamicRetrievalScore': encodeDouble(
          googleSearchDynamicRetrievalScore,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (googleSearchDynamicRetrievalScore != null)
        'googleSearchDynamicRetrievalScore=$googleSearchDynamicRetrievalScore',
    ].join(',');
    return 'RetrievalMetadata($contents)';
  }
}

/// Configuration for Model Armor integrations of prompt and responses.
final class ModelArmorConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelArmorConfig';

  /// Optional. The name of the Model Armor template to use for prompt
  /// sanitization.
  final String? promptTemplateName;

  /// Optional. The name of the Model Armor template to use for response
  /// sanitization.
  final String? responseTemplateName;

  ModelArmorConfig({this.promptTemplateName, this.responseTemplateName})
    : super(fullyQualifiedName);

  factory ModelArmorConfig.fromJson(Map<String, dynamic> json) {
    return ModelArmorConfig(
      promptTemplateName: json['promptTemplateName'],
      responseTemplateName: json['responseTemplateName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (promptTemplateName != null) 'promptTemplateName': promptTemplateName,
      if (responseTemplateName != null)
        'responseTemplateName': responseTemplateName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (promptTemplateName != null) 'promptTemplateName=$promptTemplateName',
      if (responseTemplateName != null)
        'responseTemplateName=$responseTemplateName',
    ].join(',');
    return 'ModelArmorConfig($contents)';
  }
}

/// Represents token counting info for a single modality.
final class ModalityTokenCount extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModalityTokenCount';

  /// The modality associated with this token count.
  final Modality? modality;

  /// Number of tokens.
  final int? tokenCount;

  ModalityTokenCount({this.modality, this.tokenCount})
    : super(fullyQualifiedName);

  factory ModalityTokenCount.fromJson(Map<String, dynamic> json) {
    return ModalityTokenCount(
      modality: decodeEnum(json['modality'], Modality.fromJson),
      tokenCount: json['tokenCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (modality != null) 'modality': modality!.toJson(),
      if (tokenCount != null) 'tokenCount': tokenCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (modality != null) 'modality=$modality',
      if (tokenCount != null) 'tokenCount=$tokenCount',
    ].join(',');
    return 'ModalityTokenCount($contents)';
  }
}

/// Instance of a general context.
final class Context extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Context';

  /// Immutable. The resource name of the Context.
  final String? name;

  /// User provided display name of the Context.
  /// May be up to 128 Unicode characters.
  final String? displayName;

  /// An eTag used to perform consistent read-modify-write updates. If not set, a
  /// blind "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize your Contexts.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Context (System
  /// labels are excluded).
  final Map<String, String>? labels;

  /// Output only. Timestamp when this Context was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Context was last updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. A list of resource names of Contexts that are parents of this
  /// Context. A Context may have at most 10 parent_contexts.
  final List<String>? parentContexts;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String? schemaTitle;

  /// The version of the schema in schema_name to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String? schemaVersion;

  /// Properties of the Context.
  /// Top level metadata keys' heading and trailing spaces will be trimmed.
  /// The size of this field should not exceed 200KB.
  final protobuf.Struct? metadata;

  /// Description of the Context
  final String? description;

  Context({
    this.name,
    this.displayName,
    this.etag,
    this.labels,
    this.createTime,
    this.updateTime,
    this.parentContexts,
    this.schemaTitle,
    this.schemaVersion,
    this.metadata,
    this.description,
  }) : super(fullyQualifiedName);

  factory Context.fromJson(Map<String, dynamic> json) {
    return Context(
      name: json['name'],
      displayName: json['displayName'],
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      parentContexts: decodeList(json['parentContexts']),
      schemaTitle: json['schemaTitle'],
      schemaVersion: json['schemaVersion'],
      metadata: decodeCustom(json['metadata'], protobuf.Struct.fromJson),
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (parentContexts != null) 'parentContexts': parentContexts,
      if (schemaTitle != null) 'schemaTitle': schemaTitle,
      if (schemaVersion != null) 'schemaVersion': schemaVersion,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (etag != null) 'etag=$etag',
      if (schemaTitle != null) 'schemaTitle=$schemaTitle',
      if (schemaVersion != null) 'schemaVersion=$schemaVersion',
      if (description != null) 'description=$description',
    ].join(',');
    return 'Context($contents)';
  }
}

/// Represents a job that runs custom workloads such as a Docker container or a
/// Python package. A CustomJob can have multiple worker pools and each worker
/// pool can have its own machine and input spec. A CustomJob will be cleaned up
/// once the job enters terminal state (failed or succeeded).
final class CustomJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CustomJob';

  /// Output only. Resource name of a CustomJob.
  final String? name;

  /// Required. The display name of the CustomJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Required. Job spec.
  final CustomJobSpec? jobSpec;

  /// Output only. The detailed state of the job.
  final JobState? state;

  /// Output only. Time when the CustomJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the CustomJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the CustomJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the CustomJob was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  final Status? error;

  /// The labels with user-defined metadata to organize CustomJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Customer-managed encryption key options for a CustomJob. If this is set,
  /// then all resources created by the CustomJob will be encrypted with the
  /// provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. URIs for accessing [interactive
  /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node). Only available if
  /// `job_spec.enable_web_access`
  /// is `true`.
  ///
  /// The keys are names of each node in the training job; for example,
  /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
  /// the second worker pool, and `workerpool1-1` for the second node in the
  /// second worker pool.
  ///
  /// The values are the URIs for each node's interactive shell.
  final Map<String, String>? webAccessUris;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  CustomJob({
    this.name,
    this.displayName,
    this.jobSpec,
    this.state,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.error,
    this.labels,
    this.encryptionSpec,
    this.webAccessUris,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory CustomJob.fromJson(Map<String, dynamic> json) {
    return CustomJob(
      name: json['name'],
      displayName: json['displayName'],
      jobSpec: decode(json['jobSpec'], CustomJobSpec.fromJson),
      state: decodeEnum(json['state'], JobState.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      error: decode(json['error'], Status.fromJson),
      labels: decodeMap(json['labels']),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      webAccessUris: decodeMap(json['webAccessUris']),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (jobSpec != null) 'jobSpec': jobSpec!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (labels != null) 'labels': labels,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (webAccessUris != null) 'webAccessUris': webAccessUris,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (state != null) 'state=$state',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'CustomJob($contents)';
  }
}

/// Represents the spec of a CustomJob.
final class CustomJobSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CustomJobSpec';

  /// Optional. The ID of the PersistentResource in the same Project and Location
  /// which to run
  ///
  /// If this is specified, the job will be run on existing machines held by the
  /// PersistentResource instead of on-demand short-live machines.
  /// The network and CMEK configs on the job should be consistent with those on
  /// the PersistentResource, otherwise, the job will be rejected.
  final String? persistentResourceId;

  /// Required. The spec of the worker pools including machine type and Docker
  /// image. All worker pools except the first one are optional and can be
  /// skipped by providing an empty value.
  final List<WorkerPoolSpec>? workerPoolSpecs;

  /// Scheduling options for a CustomJob.
  final Scheduling? scheduling;

  /// Specifies the service account for workload run-as account.
  /// Users submitting jobs must have act-as permission on this run-as account.
  /// If unspecified, the [Vertex AI Custom Code Service
  /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// for the CustomJob's project is used.
  final String? serviceAccount;

  /// Optional. The full name of the Compute Engine
  /// [network](/compute/docs/networks-and-firewalls#networks) to which the Job
  /// should be peered. For example, `projects/12345/global/networks/myVPC`.
  /// [Format](/compute/docs/reference/rest/v1/networks/insert)
  /// is of the form `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in `12345`, and {network} is a
  /// network name.
  ///
  /// To specify this field, you must have already [configured VPC Network
  /// Peering for Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  ///
  /// If this field is left unspecified, the job is not peered with any network.
  final String? network;

  /// Optional. A list of names for the reserved ip ranges under the VPC network
  /// that can be used for this job.
  ///
  /// If set, we will deploy the job within the provided ip ranges. Otherwise,
  /// the job will be deployed to any ip ranges under the provided VPC
  /// network.
  ///
  /// Example: ['vertex-ai-ip-range'].
  final List<String>? reservedIpRanges;

  /// Optional. Configuration for PSC-I for CustomJob.
  final PscInterfaceConfig? pscInterfaceConfig;

  /// The Cloud Storage location to store the output of this CustomJob or
  /// HyperparameterTuningJob. For HyperparameterTuningJob,
  /// the baseOutputDirectory of
  /// each child CustomJob backing a Trial is set to a subdirectory of name
  /// `id` under its parent
  /// HyperparameterTuningJob's baseOutputDirectory.
  ///
  /// The following Vertex AI environment variables will be passed to
  /// containers or python modules when this field is set:
  ///
  ///   For CustomJob:
  ///
  ///   * AIP_MODEL_DIR = `<base_output_directory>/model/`
  ///   * AIP_CHECKPOINT_DIR = `<base_output_directory>/checkpoints/`
  ///   * AIP_TENSORBOARD_LOG_DIR = `<base_output_directory>/logs/`
  ///
  ///   For CustomJob backing a Trial of HyperparameterTuningJob:
  ///
  ///   * AIP_MODEL_DIR = `<base_output_directory>/<trial_id>/model/`
  ///   * AIP_CHECKPOINT_DIR = `<base_output_directory>/<trial_id>/checkpoints/`
  ///   * AIP_TENSORBOARD_LOG_DIR = `<base_output_directory>/<trial_id>/logs/`
  final GcsDestination? baseOutputDirectory;

  /// The ID of the location to store protected artifacts. e.g. us-central1.
  /// Populate only when the location is different than CustomJob location.
  /// List of supported locations:
  /// https://cloud.google.com/vertex-ai/docs/general/locations
  final String? protectedArtifactLocationId;

  /// Optional. The name of a Vertex AI
  /// `Tensorboard` resource to
  /// which this CustomJob will upload Tensorboard logs. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String? tensorboard;

  /// Optional. Whether you want Vertex AI to enable [interactive shell
  /// access](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// to training containers.
  ///
  /// If set to `true`, you can access interactive shells at the URIs given
  /// by
  /// `CustomJob.web_access_uris`
  /// or
  /// `Trial.web_access_uris`
  /// (within
  /// `HyperparameterTuningJob.trials`).
  final bool? enableWebAccess;

  /// Optional. Whether you want Vertex AI to enable access to the customized
  /// dashboard in training chief container.
  ///
  /// If set to `true`, you can access the dashboard at the URIs given
  /// by
  /// `CustomJob.web_access_uris`
  /// or
  /// `Trial.web_access_uris`
  /// (within
  /// `HyperparameterTuningJob.trials`).
  final bool? enableDashboardAccess;

  /// Optional. The Experiment associated with this job.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}`
  final String? experiment;

  /// Optional. The Experiment Run associated with this job.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadataStores}/contexts/{experiment-name}-{experiment-run-name}`
  final String? experimentRun;

  /// Optional. The name of the Model resources for which to generate a mapping
  /// to artifact URIs. Applicable only to some of the Google-provided custom
  /// jobs. Format: `projects/{project}/locations/{location}/models/{model}`
  ///
  /// In order to retrieve a specific version of the model, also provide
  /// the version ID or version alias.
  ///   Example: `projects/{project}/locations/{location}/models/{model}@2`
  ///              or
  ///            `projects/{project}/locations/{location}/models/{model}@golden`
  /// If no version ID or alias is specified, the "default" version will be
  /// returned. The "default" version alias is created for the first version of
  /// the model, and can be moved to other versions later on. There will be
  /// exactly one default version.
  final List<String>? models;

  CustomJobSpec({
    this.persistentResourceId,
    this.workerPoolSpecs,
    this.scheduling,
    this.serviceAccount,
    this.network,
    this.reservedIpRanges,
    this.pscInterfaceConfig,
    this.baseOutputDirectory,
    this.protectedArtifactLocationId,
    this.tensorboard,
    this.enableWebAccess,
    this.enableDashboardAccess,
    this.experiment,
    this.experimentRun,
    this.models,
  }) : super(fullyQualifiedName);

  factory CustomJobSpec.fromJson(Map<String, dynamic> json) {
    return CustomJobSpec(
      persistentResourceId: json['persistentResourceId'],
      workerPoolSpecs: decodeListMessage(
        json['workerPoolSpecs'],
        WorkerPoolSpec.fromJson,
      ),
      scheduling: decode(json['scheduling'], Scheduling.fromJson),
      serviceAccount: json['serviceAccount'],
      network: json['network'],
      reservedIpRanges: decodeList(json['reservedIpRanges']),
      pscInterfaceConfig: decode(
        json['pscInterfaceConfig'],
        PscInterfaceConfig.fromJson,
      ),
      baseOutputDirectory: decode(
        json['baseOutputDirectory'],
        GcsDestination.fromJson,
      ),
      protectedArtifactLocationId: json['protectedArtifactLocationId'],
      tensorboard: json['tensorboard'],
      enableWebAccess: json['enableWebAccess'],
      enableDashboardAccess: json['enableDashboardAccess'],
      experiment: json['experiment'],
      experimentRun: json['experimentRun'],
      models: decodeList(json['models']),
    );
  }

  @override
  Object toJson() {
    return {
      if (persistentResourceId != null)
        'persistentResourceId': persistentResourceId,
      if (workerPoolSpecs != null)
        'workerPoolSpecs': encodeList(workerPoolSpecs),
      if (scheduling != null) 'scheduling': scheduling!.toJson(),
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (network != null) 'network': network,
      if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges,
      if (pscInterfaceConfig != null)
        'pscInterfaceConfig': pscInterfaceConfig!.toJson(),
      if (baseOutputDirectory != null)
        'baseOutputDirectory': baseOutputDirectory!.toJson(),
      if (protectedArtifactLocationId != null)
        'protectedArtifactLocationId': protectedArtifactLocationId,
      if (tensorboard != null) 'tensorboard': tensorboard,
      if (enableWebAccess != null) 'enableWebAccess': enableWebAccess,
      if (enableDashboardAccess != null)
        'enableDashboardAccess': enableDashboardAccess,
      if (experiment != null) 'experiment': experiment,
      if (experimentRun != null) 'experimentRun': experimentRun,
      if (models != null) 'models': models,
    };
  }

  @override
  String toString() {
    final contents = [
      if (persistentResourceId != null)
        'persistentResourceId=$persistentResourceId',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (network != null) 'network=$network',
      if (protectedArtifactLocationId != null)
        'protectedArtifactLocationId=$protectedArtifactLocationId',
      if (tensorboard != null) 'tensorboard=$tensorboard',
      if (enableWebAccess != null) 'enableWebAccess=$enableWebAccess',
      if (enableDashboardAccess != null)
        'enableDashboardAccess=$enableDashboardAccess',
      if (experiment != null) 'experiment=$experiment',
      if (experimentRun != null) 'experimentRun=$experimentRun',
    ].join(',');
    return 'CustomJobSpec($contents)';
  }
}

/// Represents the spec of a worker pool in a job.
final class WorkerPoolSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WorkerPoolSpec';

  /// The custom container task.
  final ContainerSpec? containerSpec;

  /// The Python packaged task.
  final PythonPackageSpec? pythonPackageSpec;

  /// Optional. Immutable. The specification of a single machine.
  final MachineSpec? machineSpec;

  /// Optional. The number of worker replicas to use for this worker pool.
  final int? replicaCount;

  /// Optional. List of NFS mount spec.
  final List<NfsMount>? nfsMounts;

  /// Disk spec.
  final DiskSpec? diskSpec;

  WorkerPoolSpec({
    this.containerSpec,
    this.pythonPackageSpec,
    this.machineSpec,
    this.replicaCount,
    this.nfsMounts,
    this.diskSpec,
  }) : super(fullyQualifiedName);

  factory WorkerPoolSpec.fromJson(Map<String, dynamic> json) {
    return WorkerPoolSpec(
      containerSpec: decode(json['containerSpec'], ContainerSpec.fromJson),
      pythonPackageSpec: decode(
        json['pythonPackageSpec'],
        PythonPackageSpec.fromJson,
      ),
      machineSpec: decode(json['machineSpec'], MachineSpec.fromJson),
      replicaCount: decodeInt64(json['replicaCount']),
      nfsMounts: decodeListMessage(json['nfsMounts'], NfsMount.fromJson),
      diskSpec: decode(json['diskSpec'], DiskSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
      if (pythonPackageSpec != null)
        'pythonPackageSpec': pythonPackageSpec!.toJson(),
      if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
      if (replicaCount != null) 'replicaCount': encodeInt64(replicaCount),
      if (nfsMounts != null) 'nfsMounts': encodeList(nfsMounts),
      if (diskSpec != null) 'diskSpec': diskSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (replicaCount != null) 'replicaCount=$replicaCount',
    ].join(',');
    return 'WorkerPoolSpec($contents)';
  }
}

/// The spec of a Container.
final class ContainerSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContainerSpec';

  /// Required. The URI of a container image in the Container Registry that is to
  /// be run on each worker replica.
  final String? imageUri;

  /// The command to be invoked when the container is started.
  /// It overrides the entrypoint instruction in Dockerfile when provided.
  final List<String>? command;

  /// The arguments to be passed when starting the container.
  final List<String>? args;

  /// Environment variables to be passed to the container.
  /// Maximum limit is 100.
  final List<EnvVar>? env;

  ContainerSpec({this.imageUri, this.command, this.args, this.env})
    : super(fullyQualifiedName);

  factory ContainerSpec.fromJson(Map<String, dynamic> json) {
    return ContainerSpec(
      imageUri: json['imageUri'],
      command: decodeList(json['command']),
      args: decodeList(json['args']),
      env: decodeListMessage(json['env'], EnvVar.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (imageUri != null) 'imageUri': imageUri,
      if (command != null) 'command': command,
      if (args != null) 'args': args,
      if (env != null) 'env': encodeList(env),
    };
  }

  @override
  String toString() {
    final contents = [if (imageUri != null) 'imageUri=$imageUri'].join(',');
    return 'ContainerSpec($contents)';
  }
}

/// The spec of a Python packaged code.
final class PythonPackageSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PythonPackageSpec';

  /// Required. The URI of a container image in Artifact Registry that will run
  /// the provided Python package. Vertex AI provides a wide range of executor
  /// images with pre-installed packages to meet users' various use cases. See
  /// the list of [pre-built containers for
  /// training](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  /// You must use an image from this list.
  final String? executorImageUri;

  /// Required. The Google Cloud Storage location of the Python package files
  /// which are the training program and its dependent packages. The maximum
  /// number of package URIs is 100.
  final List<String>? packageUris;

  /// Required. The Python module name to run after installing the packages.
  final String? pythonModule;

  /// Command line arguments to be passed to the Python task.
  final List<String>? args;

  /// Environment variables to be passed to the python module.
  /// Maximum limit is 100.
  final List<EnvVar>? env;

  PythonPackageSpec({
    this.executorImageUri,
    this.packageUris,
    this.pythonModule,
    this.args,
    this.env,
  }) : super(fullyQualifiedName);

  factory PythonPackageSpec.fromJson(Map<String, dynamic> json) {
    return PythonPackageSpec(
      executorImageUri: json['executorImageUri'],
      packageUris: decodeList(json['packageUris']),
      pythonModule: json['pythonModule'],
      args: decodeList(json['args']),
      env: decodeListMessage(json['env'], EnvVar.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (executorImageUri != null) 'executorImageUri': executorImageUri,
      if (packageUris != null) 'packageUris': packageUris,
      if (pythonModule != null) 'pythonModule': pythonModule,
      if (args != null) 'args': args,
      if (env != null) 'env': encodeList(env),
    };
  }

  @override
  String toString() {
    final contents = [
      if (executorImageUri != null) 'executorImageUri=$executorImageUri',
      if (pythonModule != null) 'pythonModule=$pythonModule',
    ].join(',');
    return 'PythonPackageSpec($contents)';
  }
}

/// All parameters related to queuing and scheduling of custom jobs.
final class Scheduling extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Scheduling';

  /// The maximum job running time. The default is 7 days.
  final protobuf.Duration? timeout;

  /// Restarts the entire CustomJob if a worker gets restarted.
  /// This feature can be used by distributed training jobs that are not
  /// resilient to workers leaving and joining a job.
  final bool? restartJobOnWorkerRestart;

  /// Optional. This determines which type of scheduling strategy to use.
  final Scheduling_Strategy? strategy;

  /// Optional. Indicates if the job should retry for internal errors after the
  /// job starts running. If true, overrides
  /// `Scheduling.restart_job_on_worker_restart` to false.
  final bool? disableRetries;

  /// Optional. This is the maximum duration that a job will wait for the
  /// requested resources to be provisioned if the scheduling strategy is set to
  /// [Strategy.DWS_FLEX_START].
  /// If set to 0, the job will wait indefinitely. The default is 24 hours.
  final protobuf.Duration? maxWaitDuration;

  Scheduling({
    this.timeout,
    this.restartJobOnWorkerRestart,
    this.strategy,
    this.disableRetries,
    this.maxWaitDuration,
  }) : super(fullyQualifiedName);

  factory Scheduling.fromJson(Map<String, dynamic> json) {
    return Scheduling(
      timeout: decodeCustom(json['timeout'], protobuf.Duration.fromJson),
      restartJobOnWorkerRestart: json['restartJobOnWorkerRestart'],
      strategy: decodeEnum(json['strategy'], Scheduling_Strategy.fromJson),
      disableRetries: json['disableRetries'],
      maxWaitDuration: decodeCustom(
        json['maxWaitDuration'],
        protobuf.Duration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (timeout != null) 'timeout': timeout!.toJson(),
      if (restartJobOnWorkerRestart != null)
        'restartJobOnWorkerRestart': restartJobOnWorkerRestart,
      if (strategy != null) 'strategy': strategy!.toJson(),
      if (disableRetries != null) 'disableRetries': disableRetries,
      if (maxWaitDuration != null) 'maxWaitDuration': maxWaitDuration!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (restartJobOnWorkerRestart != null)
        'restartJobOnWorkerRestart=$restartJobOnWorkerRestart',
      if (strategy != null) 'strategy=$strategy',
      if (disableRetries != null) 'disableRetries=$disableRetries',
    ].join(',');
    return 'Scheduling($contents)';
  }
}

/// Optional. This determines which type of scheduling strategy to use. Right
/// now users have two options such as STANDARD which will use regular on
/// demand resources to schedule the job, the other is SPOT which would
/// leverage spot resources alongwith regular resources to schedule
/// the job.
final class Scheduling_Strategy extends protobuf.ProtoEnum {
  /// Strategy will default to STANDARD.
  static const strategyUnspecified = Scheduling_Strategy(
    'STRATEGY_UNSPECIFIED',
  );

  /// Deprecated. Regular on-demand provisioning strategy.
  static const onDemand = Scheduling_Strategy('ON_DEMAND');

  /// Deprecated. Low cost by making potential use of spot resources.
  static const lowCost = Scheduling_Strategy('LOW_COST');

  /// Standard provisioning strategy uses regular on-demand resources.
  static const standard = Scheduling_Strategy('STANDARD');

  /// Spot provisioning strategy uses spot resources.
  static const spot = Scheduling_Strategy('SPOT');

  /// Flex Start strategy uses DWS to queue for resources.
  static const flexStart = Scheduling_Strategy('FLEX_START');

  const Scheduling_Strategy(super.value);

  factory Scheduling_Strategy.fromJson(String json) =>
      Scheduling_Strategy(json);

  @override
  String toString() => 'Strategy.$value';
}

/// A piece of data in a Dataset. Could be an image, a video, a document or plain
/// text.
final class DataItem extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DataItem';

  /// Output only. The resource name of the DataItem.
  final String? name;

  /// Output only. Timestamp when this DataItem was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this DataItem was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The labels with user-defined metadata to organize your DataItems.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one DataItem(System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? labels;

  /// Required. The data that the DataItem represents (for example, an image or a
  /// text snippet). The schema of the payload is stored in the parent Dataset's
  /// [metadata
  /// schema's][google.cloud.aiplatform.v1beta1.Dataset.metadata_schema_uri]
  /// dataItemSchemaUri field.
  final protobuf.Value? payload;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  DataItem({
    this.name,
    this.createTime,
    this.updateTime,
    this.labels,
    this.payload,
    this.etag,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory DataItem.fromJson(Map<String, dynamic> json) {
    return DataItem(
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      payload: decodeCustom(json['payload'], protobuf.Value.fromJson),
      etag: json['etag'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (payload != null) 'payload': payload!.toJson(),
      if (etag != null) 'etag': etag,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (etag != null) 'etag=$etag',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'DataItem($contents)';
  }
}

/// DataLabelingJob is used to trigger a human labeling job on unlabeled data
/// from the following Dataset:
final class DataLabelingJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DataLabelingJob';

  /// Output only. Resource name of the DataLabelingJob.
  final String? name;

  /// Required. The user-defined name of the DataLabelingJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  /// Display name of a DataLabelingJob.
  final String? displayName;

  /// Required. Dataset resource names. Right now we only support labeling from a
  /// single Dataset. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final List<String>? datasets;

  /// Labels to assign to annotations generated by this DataLabelingJob.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? annotationLabels;

  /// Required. Number of labelers to work on each DataItem.
  final int? labelerCount;

  /// Required. The Google Cloud Storage location of the instruction pdf. This
  /// pdf is shared with labelers, and provides detailed description on how to
  /// label DataItems in Datasets.
  final String? instructionUri;

  /// Required. Points to a YAML file stored on Google Cloud Storage describing
  /// the config for a specific type of DataLabelingJob. The schema files that
  /// can be used here are found in the
  /// https://storage.googleapis.com/google-cloud-aiplatform bucket in the
  /// /schema/datalabelingjob/inputs/ folder.
  final String? inputsSchemaUri;

  /// Required. Input config parameters for the DataLabelingJob.
  final protobuf.Value? inputs;

  /// Output only. The detailed state of the job.
  final JobState? state;

  /// Output only. Current labeling job progress percentage scaled in interval
  /// [0, 100], indicating the percentage of DataItems that has been finished.
  final int? labelingProgress;

  /// Output only. Estimated cost(in US dollars) that the DataLabelingJob has
  /// incurred to date.
  final Money? currentSpend;

  /// Output only. Timestamp when this DataLabelingJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this DataLabelingJob was updated most recently.
  final protobuf.Timestamp? updateTime;

  /// Output only. DataLabelingJob errors. It is only populated when job's state
  /// is `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
  final Status? error;

  /// The labels with user-defined metadata to organize your DataLabelingJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable. Following system labels exist for each DataLabelingJob:
  ///
  /// * "aiplatform.googleapis.com/schema": output only, its value is the
  ///   `inputs_schema`'s
  ///   title.
  final Map<String, String>? labels;

  /// The SpecialistPools' resource names associated with this job.
  final List<String>? specialistPools;

  /// Customer-managed encryption key spec for a DataLabelingJob. If set, this
  /// DataLabelingJob will be secured by this key.
  ///
  /// Note: Annotations created in the DataLabelingJob are associated with
  /// the EncryptionSpec of the Dataset they are exported to.
  final EncryptionSpec? encryptionSpec;

  /// Parameters that configure the active learning pipeline. Active learning
  /// will label the data incrementally via several iterations. For every
  /// iteration, it will select a batch of data based on the sampling strategy.
  final ActiveLearningConfig? activeLearningConfig;

  DataLabelingJob({
    this.name,
    this.displayName,
    this.datasets,
    this.annotationLabels,
    this.labelerCount,
    this.instructionUri,
    this.inputsSchemaUri,
    this.inputs,
    this.state,
    this.labelingProgress,
    this.currentSpend,
    this.createTime,
    this.updateTime,
    this.error,
    this.labels,
    this.specialistPools,
    this.encryptionSpec,
    this.activeLearningConfig,
  }) : super(fullyQualifiedName);

  factory DataLabelingJob.fromJson(Map<String, dynamic> json) {
    return DataLabelingJob(
      name: json['name'],
      displayName: json['displayName'],
      datasets: decodeList(json['datasets']),
      annotationLabels: decodeMap(json['annotationLabels']),
      labelerCount: json['labelerCount'],
      instructionUri: json['instructionUri'],
      inputsSchemaUri: json['inputsSchemaUri'],
      inputs: decodeCustom(json['inputs'], protobuf.Value.fromJson),
      state: decodeEnum(json['state'], JobState.fromJson),
      labelingProgress: json['labelingProgress'],
      currentSpend: decode(json['currentSpend'], Money.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      error: decode(json['error'], Status.fromJson),
      labels: decodeMap(json['labels']),
      specialistPools: decodeList(json['specialistPools']),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      activeLearningConfig: decode(
        json['activeLearningConfig'],
        ActiveLearningConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (datasets != null) 'datasets': datasets,
      if (annotationLabels != null) 'annotationLabels': annotationLabels,
      if (labelerCount != null) 'labelerCount': labelerCount,
      if (instructionUri != null) 'instructionUri': instructionUri,
      if (inputsSchemaUri != null) 'inputsSchemaUri': inputsSchemaUri,
      if (inputs != null) 'inputs': inputs!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (labelingProgress != null) 'labelingProgress': labelingProgress,
      if (currentSpend != null) 'currentSpend': currentSpend!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (labels != null) 'labels': labels,
      if (specialistPools != null) 'specialistPools': specialistPools,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (activeLearningConfig != null)
        'activeLearningConfig': activeLearningConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (labelerCount != null) 'labelerCount=$labelerCount',
      if (instructionUri != null) 'instructionUri=$instructionUri',
      if (inputsSchemaUri != null) 'inputsSchemaUri=$inputsSchemaUri',
      if (state != null) 'state=$state',
      if (labelingProgress != null) 'labelingProgress=$labelingProgress',
    ].join(',');
    return 'DataLabelingJob($contents)';
  }
}

/// Parameters that configure the active learning pipeline. Active learning will
///  label the data incrementally by several iterations. For every iteration, it
///  will select a batch of data based on the sampling strategy.
final class ActiveLearningConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ActiveLearningConfig';

  /// Max number of human labeled DataItems.
  final int? maxDataItemCount;

  /// Max percent of total DataItems for human labeling.
  final int? maxDataItemPercentage;

  /// Active learning data sampling config. For every active learning labeling
  /// iteration, it will select a batch of data based on the sampling strategy.
  final SampleConfig? sampleConfig;

  /// CMLE training config. For every active learning labeling iteration, system
  /// will train a machine learning model on CMLE. The trained model will be used
  /// by data sampling algorithm to select DataItems.
  final TrainingConfig? trainingConfig;

  ActiveLearningConfig({
    this.maxDataItemCount,
    this.maxDataItemPercentage,
    this.sampleConfig,
    this.trainingConfig,
  }) : super(fullyQualifiedName);

  factory ActiveLearningConfig.fromJson(Map<String, dynamic> json) {
    return ActiveLearningConfig(
      maxDataItemCount: decodeInt64(json['maxDataItemCount']),
      maxDataItemPercentage: json['maxDataItemPercentage'],
      sampleConfig: decode(json['sampleConfig'], SampleConfig.fromJson),
      trainingConfig: decode(json['trainingConfig'], TrainingConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (maxDataItemCount != null)
        'maxDataItemCount': encodeInt64(maxDataItemCount),
      if (maxDataItemPercentage != null)
        'maxDataItemPercentage': maxDataItemPercentage,
      if (sampleConfig != null) 'sampleConfig': sampleConfig!.toJson(),
      if (trainingConfig != null) 'trainingConfig': trainingConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxDataItemCount != null) 'maxDataItemCount=$maxDataItemCount',
      if (maxDataItemPercentage != null)
        'maxDataItemPercentage=$maxDataItemPercentage',
    ].join(',');
    return 'ActiveLearningConfig($contents)';
  }
}

/// Active learning data sampling config. For every active learning labeling
/// iteration, it will select a batch of data based on the sampling strategy.
final class SampleConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SampleConfig';

  /// The percentage of data needed to be labeled in the first batch.
  final int? initialBatchSamplePercentage;

  /// The percentage of data needed to be labeled in each following batch
  /// (except the first batch).
  final int? followingBatchSamplePercentage;

  /// Field to choose sampling strategy. Sampling strategy will decide which data
  /// should be selected for human labeling in every batch.
  final SampleConfig_SampleStrategy? sampleStrategy;

  SampleConfig({
    this.initialBatchSamplePercentage,
    this.followingBatchSamplePercentage,
    this.sampleStrategy,
  }) : super(fullyQualifiedName);

  factory SampleConfig.fromJson(Map<String, dynamic> json) {
    return SampleConfig(
      initialBatchSamplePercentage: json['initialBatchSamplePercentage'],
      followingBatchSamplePercentage: json['followingBatchSamplePercentage'],
      sampleStrategy: decodeEnum(
        json['sampleStrategy'],
        SampleConfig_SampleStrategy.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (initialBatchSamplePercentage != null)
        'initialBatchSamplePercentage': initialBatchSamplePercentage,
      if (followingBatchSamplePercentage != null)
        'followingBatchSamplePercentage': followingBatchSamplePercentage,
      if (sampleStrategy != null) 'sampleStrategy': sampleStrategy!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (initialBatchSamplePercentage != null)
        'initialBatchSamplePercentage=$initialBatchSamplePercentage',
      if (followingBatchSamplePercentage != null)
        'followingBatchSamplePercentage=$followingBatchSamplePercentage',
      if (sampleStrategy != null) 'sampleStrategy=$sampleStrategy',
    ].join(',');
    return 'SampleConfig($contents)';
  }
}

/// Sample strategy decides which subset of DataItems should be selected for
/// human labeling in every batch.
final class SampleConfig_SampleStrategy extends protobuf.ProtoEnum {
  /// Default will be treated as UNCERTAINTY.
  static const sampleStrategyUnspecified = SampleConfig_SampleStrategy(
    'SAMPLE_STRATEGY_UNSPECIFIED',
  );

  /// Sample the most uncertain data to label.
  static const uncertainty = SampleConfig_SampleStrategy('UNCERTAINTY');

  const SampleConfig_SampleStrategy(super.value);

  factory SampleConfig_SampleStrategy.fromJson(String json) =>
      SampleConfig_SampleStrategy(json);

  @override
  String toString() => 'SampleStrategy.$value';
}

/// CMLE training config. For every active learning labeling iteration, system
/// will train a machine learning model on CMLE. The trained model will be used
/// by data sampling algorithm to select DataItems.
final class TrainingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrainingConfig';

  /// The timeout hours for the CMLE training job, expressed in milli hours
  /// i.e. 1,000 value in this field means 1 hour.
  final int? timeoutTrainingMilliHours;

  TrainingConfig({this.timeoutTrainingMilliHours}) : super(fullyQualifiedName);

  factory TrainingConfig.fromJson(Map<String, dynamic> json) {
    return TrainingConfig(
      timeoutTrainingMilliHours: decodeInt64(json['timeoutTrainingMilliHours']),
    );
  }

  @override
  Object toJson() {
    return {
      if (timeoutTrainingMilliHours != null)
        'timeoutTrainingMilliHours': encodeInt64(timeoutTrainingMilliHours),
    };
  }

  @override
  String toString() {
    final contents = [
      if (timeoutTrainingMilliHours != null)
        'timeoutTrainingMilliHours=$timeoutTrainingMilliHours',
    ].join(',');
    return 'TrainingConfig($contents)';
  }
}

/// A collection of DataItems and Annotations on them.
final class Dataset extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Dataset';

  /// Output only. Identifier. The resource name of the Dataset.
  final String? name;

  /// Required. The user-defined name of the Dataset.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// The description of the Dataset.
  final String? description;

  /// Required. Points to a YAML file stored on Google Cloud Storage describing
  /// additional information about the Dataset. The schema is defined as an
  /// OpenAPI 3.0.2 Schema Object. The schema files that can be used here are
  /// found in gs://google-cloud-aiplatform/schema/dataset/metadata/.
  final String? metadataSchemaUri;

  /// Required. Additional information about the Dataset.
  final protobuf.Value? metadata;

  /// Output only. The number of DataItems in this Dataset. Only apply for
  /// non-structured Dataset.
  final int? dataItemCount;

  /// Output only. Timestamp when this Dataset was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Dataset was last updated.
  final protobuf.Timestamp? updateTime;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize your Datasets.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Dataset (System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable. Following system labels exist for each Dataset:
  ///
  /// * "aiplatform.googleapis.com/dataset_metadata_schema": output only, its
  ///   value is the
  ///   [metadata_schema's][google.cloud.aiplatform.v1beta1.Dataset.metadata_schema_uri]
  ///   title.
  final Map<String, String>? labels;

  /// All SavedQueries belong to the Dataset will be returned in List/Get
  /// Dataset response. The annotation_specs field
  /// will not be populated except for UI cases which will only use
  /// `annotation_spec_count`.
  /// In CreateDataset request, a SavedQuery is created together if
  /// this field is set, up to one SavedQuery can be set in CreateDatasetRequest.
  /// The SavedQuery should not contain any AnnotationSpec.
  final List<SavedQuery>? savedQueries;

  /// Customer-managed encryption key spec for a Dataset. If set, this Dataset
  /// and all sub-resources of this Dataset will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. The resource name of the Artifact that was created in
  /// MetadataStore when creating the Dataset. The Artifact resource name pattern
  /// is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  final String? metadataArtifact;

  /// Optional. Reference to the public base model last used by the dataset. Only
  /// set for prompt datasets.
  final String? modelReference;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  Dataset({
    this.name,
    this.displayName,
    this.description,
    this.metadataSchemaUri,
    this.metadata,
    this.dataItemCount,
    this.createTime,
    this.updateTime,
    this.etag,
    this.labels,
    this.savedQueries,
    this.encryptionSpec,
    this.metadataArtifact,
    this.modelReference,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory Dataset.fromJson(Map<String, dynamic> json) {
    return Dataset(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      metadataSchemaUri: json['metadataSchemaUri'],
      metadata: decodeCustom(json['metadata'], protobuf.Value.fromJson),
      dataItemCount: decodeInt64(json['dataItemCount']),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      savedQueries: decodeListMessage(
        json['savedQueries'],
        SavedQuery.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      metadataArtifact: json['metadataArtifact'],
      modelReference: json['modelReference'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (dataItemCount != null) 'dataItemCount': encodeInt64(dataItemCount),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (savedQueries != null) 'savedQueries': encodeList(savedQueries),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (metadataArtifact != null) 'metadataArtifact': metadataArtifact,
      if (modelReference != null) 'modelReference': modelReference,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (metadataSchemaUri != null) 'metadataSchemaUri=$metadataSchemaUri',
      if (dataItemCount != null) 'dataItemCount=$dataItemCount',
      if (etag != null) 'etag=$etag',
      if (metadataArtifact != null) 'metadataArtifact=$metadataArtifact',
      if (modelReference != null) 'modelReference=$modelReference',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Dataset($contents)';
  }
}

/// Describes the location from where we import data into a Dataset, together
/// with the labels that will be applied to the DataItems and the Annotations.
final class ImportDataConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportDataConfig';

  /// The Google Cloud Storage location for the input content.
  final GcsSource? gcsSource;

  /// Labels that will be applied to newly imported DataItems. If an identical
  /// DataItem as one being imported already exists in the Dataset, then these
  /// labels will be appended to these of the already existing one, and if labels
  /// with identical key is imported before, the old label value will be
  /// overwritten. If two DataItems are identical in the same import data
  /// operation, the labels will be combined and if key collision happens in this
  /// case, one of the values will be picked randomly. Two DataItems are
  /// considered identical if their content bytes are identical (e.g. image bytes
  /// or pdf bytes).
  /// These labels will be overridden by Annotation labels specified inside index
  /// file referenced by
  /// `import_schema_uri`,
  /// e.g. jsonl file.
  final Map<String, String>? dataItemLabels;

  /// Labels that will be applied to newly imported Annotations. If two
  /// Annotations are identical, one of them will be deduped. Two Annotations are
  /// considered identical if their
  /// `payload`,
  /// `payload_schema_uri`
  /// and all of their
  /// `labels` are the same.
  /// These labels will be overridden by Annotation labels specified inside index
  /// file referenced by
  /// `import_schema_uri`,
  /// e.g. jsonl file.
  final Map<String, String>? annotationLabels;

  /// Required. Points to a YAML file stored on Google Cloud Storage describing
  /// the import format. Validation will be done against the schema. The schema
  /// is defined as an [OpenAPI 3.0.2 Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  final String? importSchemaUri;

  ImportDataConfig({
    this.gcsSource,
    this.dataItemLabels,
    this.annotationLabels,
    this.importSchemaUri,
  }) : super(fullyQualifiedName);

  factory ImportDataConfig.fromJson(Map<String, dynamic> json) {
    return ImportDataConfig(
      gcsSource: decode(json['gcsSource'], GcsSource.fromJson),
      dataItemLabels: decodeMap(json['dataItemLabels']),
      annotationLabels: decodeMap(json['annotationLabels']),
      importSchemaUri: json['importSchemaUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
      if (dataItemLabels != null) 'dataItemLabels': dataItemLabels,
      if (annotationLabels != null) 'annotationLabels': annotationLabels,
      if (importSchemaUri != null) 'importSchemaUri': importSchemaUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (importSchemaUri != null) 'importSchemaUri=$importSchemaUri',
    ].join(',');
    return 'ImportDataConfig($contents)';
  }
}

/// Describes what part of the Dataset is to be exported, the destination of
/// the export and how to export.
final class ExportDataConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportDataConfig';

  /// The Google Cloud Storage location where the output is to be written to.
  /// In the given directory a new directory will be created with name:
  /// `export-data-<dataset-display-name>-<timestamp-of-export-call>` where
  /// timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format. All export
  /// output will be written into that directory. Inside that directory,
  /// annotations with the same schema will be grouped into sub directories
  /// which are named with the corresponding annotations' schema title. Inside
  /// these sub directories, a schema.yaml will be created to describe the
  /// output format.
  final GcsDestination? gcsDestination;

  /// Split based on fractions defining the size of each set.
  final ExportFractionSplit? fractionSplit;

  /// An expression for filtering what part of the Dataset is to be exported.
  /// Only Annotations that match this filter will be exported. The filter syntax
  /// is the same as in
  /// `ListAnnotations`.
  final String? annotationsFilter;

  ExportDataConfig({
    this.gcsDestination,
    this.fractionSplit,
    this.annotationsFilter,
  }) : super(fullyQualifiedName);

  factory ExportDataConfig.fromJson(Map<String, dynamic> json) {
    return ExportDataConfig(
      gcsDestination: decode(json['gcsDestination'], GcsDestination.fromJson),
      fractionSplit: decode(
        json['fractionSplit'],
        ExportFractionSplit.fromJson,
      ),
      annotationsFilter: json['annotationsFilter'],
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
      if (fractionSplit != null) 'fractionSplit': fractionSplit!.toJson(),
      if (annotationsFilter != null) 'annotationsFilter': annotationsFilter,
    };
  }

  @override
  String toString() {
    final contents = [
      if (annotationsFilter != null) 'annotationsFilter=$annotationsFilter',
    ].join(',');
    return 'ExportDataConfig($contents)';
  }
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions. Any of `training_fraction`, `validation_fraction` and
/// `test_fraction` may optionally be provided, they must sum to up to 1. If the
/// provided ones sum to less than 1, the remainder is assigned to sets as
/// decided by Vertex AI. If none of the fractions are set, by default roughly
/// 80% of data is used for training, 10% for validation, and 10% for test.
final class ExportFractionSplit extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFractionSplit';

  /// The fraction of the input data that is to be used to train the Model.
  final double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  final double? validationFraction;

  /// The fraction of the input data that is to be used to evaluate the Model.
  final double? testFraction;

  ExportFractionSplit({
    this.trainingFraction,
    this.validationFraction,
    this.testFraction,
  }) : super(fullyQualifiedName);

  factory ExportFractionSplit.fromJson(Map<String, dynamic> json) {
    return ExportFractionSplit(
      trainingFraction: decodeDouble(json['trainingFraction']),
      validationFraction: decodeDouble(json['validationFraction']),
      testFraction: decodeDouble(json['testFraction']),
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingFraction != null)
        'trainingFraction': encodeDouble(trainingFraction),
      if (validationFraction != null)
        'validationFraction': encodeDouble(validationFraction),
      if (testFraction != null) 'testFraction': encodeDouble(testFraction),
    };
  }

  @override
  String toString() {
    final contents = [
      if (trainingFraction != null) 'trainingFraction=$trainingFraction',
      if (validationFraction != null) 'validationFraction=$validationFraction',
      if (testFraction != null) 'testFraction=$testFraction',
    ].join(',');
    return 'ExportFractionSplit($contents)';
  }
}

/// Request message for
/// `DatasetService.CreateDataset`.
final class CreateDatasetRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDatasetRequest';

  /// Required. The resource name of the Location to create the Dataset in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Dataset to create.
  final Dataset dataset;

  CreateDatasetRequest({required this.parent, required this.dataset})
    : super(fullyQualifiedName);

  factory CreateDatasetRequest.fromJson(Map<String, dynamic> json) {
    return CreateDatasetRequest(
      parent: json['parent'],
      dataset: decode(json['dataset'], Dataset.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'dataset': dataset.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateDatasetRequest($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.CreateDataset`.
final class CreateDatasetOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDatasetOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateDatasetOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateDatasetOperationMetadata.fromJson(Map<String, dynamic> json) {
    return CreateDatasetOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateDatasetOperationMetadata()';
}

/// Request message for
/// `DatasetService.GetDataset`.
final class GetDatasetRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetDatasetRequest';

  /// Required. The name of the Dataset resource.
  final String name;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  GetDatasetRequest({required this.name, this.readMask})
    : super(fullyQualifiedName);

  factory GetDatasetRequest.fromJson(Map<String, dynamic> json) {
    return GetDatasetRequest(
      name: json['name'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {'name': name, if (readMask != null) 'readMask': readMask!.toJson()};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetDatasetRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.UpdateDataset`.
final class UpdateDatasetRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateDatasetRequest';

  /// Required. The Dataset which replaces the resource on the server.
  final Dataset dataset;

  /// Required. The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`. Updatable fields:
  ///
  ///   * `display_name`
  ///   * `description`
  ///   * `labels`
  final protobuf.FieldMask? updateMask;

  UpdateDatasetRequest({required this.dataset, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateDatasetRequest.fromJson(Map<String, dynamic> json) {
    return UpdateDatasetRequest(
      dataset: decode(json['dataset'], Dataset.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'dataset': dataset.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateDatasetRequest()';
}

/// Request message for
/// `DatasetService.UpdateDatasetVersion`.
final class UpdateDatasetVersionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateDatasetVersionRequest';

  /// Required. The DatasetVersion which replaces the resource on the server.
  final DatasetVersion datasetVersion;

  /// Required. The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`. Updatable fields:
  ///
  ///   * `display_name`
  final protobuf.FieldMask? updateMask;

  UpdateDatasetVersionRequest({required this.datasetVersion, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateDatasetVersionRequest.fromJson(Map<String, dynamic> json) {
    return UpdateDatasetVersionRequest(
      datasetVersion: decode(json['datasetVersion'], DatasetVersion.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'datasetVersion': datasetVersion.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateDatasetVersionRequest()';
}

/// Request message for
/// `DatasetService.ListDatasets`.
final class ListDatasetsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDatasetsRequest';

  /// Required. The name of the Dataset's parent resource.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// An expression for filtering the results of the request. For field names
  /// both snake_case and camelCase are supported.
  ///
  ///   * `display_name`: supports = and !=
  ///   * `metadata_schema_uri`: supports = and !=
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:* or labels:key - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///
  /// Some examples:
  ///
  ///   * `displayName="myDisplayName"`
  ///   * `labels.myKey="myValue"`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported fields:
  ///
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  final String? orderBy;

  ListDatasetsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListDatasetsRequest.fromJson(Map<String, dynamic> json) {
    return ListDatasetsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListDatasetsRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListDatasets`.
final class ListDatasetsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDatasetsResponse';

  /// A list of Datasets that matches the specified filter in the request.
  final List<Dataset>? datasets;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListDatasetsResponse({this.datasets, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListDatasetsResponse.fromJson(Map<String, dynamic> json) {
    return ListDatasetsResponse(
      datasets: decodeListMessage(json['datasets'], Dataset.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (datasets != null) 'datasets': encodeList(datasets),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListDatasetsResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.DeleteDataset`.
final class DeleteDatasetRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteDatasetRequest';

  /// Required. The resource name of the Dataset to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  DeleteDatasetRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteDatasetRequest.fromJson(Map<String, dynamic> json) {
    return DeleteDatasetRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteDatasetRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.ImportData`.
final class ImportDataRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportDataRequest';

  /// Required. The name of the Dataset resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  /// Required. The desired input locations. The contents of all input locations
  /// will be imported in one batch.
  final List<ImportDataConfig>? importConfigs;

  ImportDataRequest({required this.name, this.importConfigs})
    : super(fullyQualifiedName);

  factory ImportDataRequest.fromJson(Map<String, dynamic> json) {
    return ImportDataRequest(
      name: json['name'],
      importConfigs: decodeListMessage(
        json['importConfigs'],
        ImportDataConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (importConfigs != null) 'importConfigs': encodeList(importConfigs),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ImportDataRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ImportData`.
final class ImportDataResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportDataResponse';

  ImportDataResponse() : super(fullyQualifiedName);

  factory ImportDataResponse.fromJson(Map<String, dynamic> json) {
    return ImportDataResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'ImportDataResponse()';
}

/// Runtime operation information for
/// `DatasetService.ImportData`.
final class ImportDataOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportDataOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  ImportDataOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ImportDataOperationMetadata.fromJson(Map<String, dynamic> json) {
    return ImportDataOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'ImportDataOperationMetadata()';
}

/// Request message for
/// `DatasetService.ExportData`.
final class ExportDataRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportDataRequest';

  /// Required. The name of the Dataset resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  /// Required. The desired output location.
  final ExportDataConfig? exportConfig;

  ExportDataRequest({required this.name, this.exportConfig})
    : super(fullyQualifiedName);

  factory ExportDataRequest.fromJson(Map<String, dynamic> json) {
    return ExportDataRequest(
      name: json['name'],
      exportConfig: decode(json['exportConfig'], ExportDataConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (exportConfig != null) 'exportConfig': exportConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ExportDataRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ExportData`.
final class ExportDataResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportDataResponse';

  /// All of the files that are exported in this export operation. For custom
  /// code training export, only three (training, validation and test)
  /// Cloud Storage paths in wildcard format are populated
  /// (for example, gs://.../training-*).
  final List<String>? exportedFiles;

  ExportDataResponse({this.exportedFiles}) : super(fullyQualifiedName);

  factory ExportDataResponse.fromJson(Map<String, dynamic> json) {
    return ExportDataResponse(exportedFiles: decodeList(json['exportedFiles']));
  }

  @override
  Object toJson() {
    return {if (exportedFiles != null) 'exportedFiles': exportedFiles};
  }

  @override
  String toString() => 'ExportDataResponse()';
}

/// Runtime operation information for
/// `DatasetService.ExportData`.
final class ExportDataOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportDataOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  /// A Google Cloud Storage directory which path ends with '/'. The exported
  /// data is stored in the directory.
  final String? gcsOutputDirectory;

  ExportDataOperationMetadata({this.genericMetadata, this.gcsOutputDirectory})
    : super(fullyQualifiedName);

  factory ExportDataOperationMetadata.fromJson(Map<String, dynamic> json) {
    return ExportDataOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      gcsOutputDirectory: json['gcsOutputDirectory'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (gcsOutputDirectory != null) 'gcsOutputDirectory': gcsOutputDirectory,
    };
  }

  @override
  String toString() {
    final contents = [
      if (gcsOutputDirectory != null) 'gcsOutputDirectory=$gcsOutputDirectory',
    ].join(',');
    return 'ExportDataOperationMetadata($contents)';
  }
}

/// Request message for
/// `DatasetService.CreateDatasetVersion`.
final class CreateDatasetVersionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDatasetVersionRequest';

  /// Required. The name of the Dataset resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String parent;

  /// Required. The version to be created. The same CMEK policies with the
  /// original Dataset will be applied the dataset version. So here we don't need
  /// to specify the EncryptionSpecType here.
  final DatasetVersion datasetVersion;

  CreateDatasetVersionRequest({
    required this.parent,
    required this.datasetVersion,
  }) : super(fullyQualifiedName);

  factory CreateDatasetVersionRequest.fromJson(Map<String, dynamic> json) {
    return CreateDatasetVersionRequest(
      parent: json['parent'],
      datasetVersion: decode(json['datasetVersion'], DatasetVersion.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'datasetVersion': datasetVersion.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateDatasetVersionRequest($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.CreateDatasetVersion`.
final class CreateDatasetVersionOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDatasetVersionOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateDatasetVersionOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateDatasetVersionOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateDatasetVersionOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateDatasetVersionOperationMetadata()';
}

/// Request message for
/// `DatasetService.DeleteDatasetVersion`.
final class DeleteDatasetVersionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteDatasetVersionRequest';

  /// Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  final String name;

  DeleteDatasetVersionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteDatasetVersionRequest.fromJson(Map<String, dynamic> json) {
    return DeleteDatasetVersionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteDatasetVersionRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.GetDatasetVersion`.
final class GetDatasetVersionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetDatasetVersionRequest';

  /// Required. The resource name of the Dataset version to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  final String name;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  GetDatasetVersionRequest({required this.name, this.readMask})
    : super(fullyQualifiedName);

  factory GetDatasetVersionRequest.fromJson(Map<String, dynamic> json) {
    return GetDatasetVersionRequest(
      name: json['name'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {'name': name, if (readMask != null) 'readMask': readMask!.toJson()};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetDatasetVersionRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.ListDatasetVersions`.
final class ListDatasetVersionsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDatasetVersionsRequest';

  /// Required. The resource name of the Dataset to list DatasetVersions from.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String parent;

  /// Optional. The standard list filter.
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  final String? pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending.
  final String? orderBy;

  ListDatasetVersionsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListDatasetVersionsRequest.fromJson(Map<String, dynamic> json) {
    return ListDatasetVersionsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListDatasetVersionsRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListDatasetVersions`.
final class ListDatasetVersionsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDatasetVersionsResponse';

  /// A list of DatasetVersions that matches the specified filter in the request.
  final List<DatasetVersion>? datasetVersions;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListDatasetVersionsResponse({this.datasetVersions, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListDatasetVersionsResponse.fromJson(Map<String, dynamic> json) {
    return ListDatasetVersionsResponse(
      datasetVersions: decodeListMessage(
        json['datasetVersions'],
        DatasetVersion.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (datasetVersions != null)
        'datasetVersions': encodeList(datasetVersions),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListDatasetVersionsResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.RestoreDatasetVersion`.
final class RestoreDatasetVersionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RestoreDatasetVersionRequest';

  /// Required. The name of the DatasetVersion resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/datasetVersions/{dataset_version}`
  final String name;

  RestoreDatasetVersionRequest({required this.name})
    : super(fullyQualifiedName);

  factory RestoreDatasetVersionRequest.fromJson(Map<String, dynamic> json) {
    return RestoreDatasetVersionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'RestoreDatasetVersionRequest($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.RestoreDatasetVersion`.
final class RestoreDatasetVersionOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RestoreDatasetVersionOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  RestoreDatasetVersionOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory RestoreDatasetVersionOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return RestoreDatasetVersionOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'RestoreDatasetVersionOperationMetadata()';
}

/// Request message for
/// `DatasetService.ListDataItems`.
final class ListDataItemsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDataItemsRequest';

  /// Required. The resource name of the Dataset to list DataItems from.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String parent;

  /// The standard list filter.
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  final String? orderBy;

  ListDataItemsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListDataItemsRequest.fromJson(Map<String, dynamic> json) {
    return ListDataItemsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListDataItemsRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListDataItems`.
final class ListDataItemsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDataItemsResponse';

  /// A list of DataItems that matches the specified filter in the request.
  final List<DataItem>? dataItems;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListDataItemsResponse({this.dataItems, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListDataItemsResponse.fromJson(Map<String, dynamic> json) {
    return ListDataItemsResponse(
      dataItems: decodeListMessage(json['dataItems'], DataItem.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dataItems != null) 'dataItems': encodeList(dataItems),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListDataItemsResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.SearchDataItems`.
final class SearchDataItemsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchDataItemsRequest';

  /// A comma-separated list of data item fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending.
  final String? orderByDataItem;

  /// Expression that allows ranking results based on annotation's property.
  final SearchDataItemsRequest_OrderByAnnotation? orderByAnnotation;

  /// Required. The resource name of the Dataset from which to search DataItems.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String dataset;

  /// The resource name of a SavedQuery(annotation set in UI).
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  /// All of the search will be done in the context of this SavedQuery.
  final String? savedQuery;

  /// The resource name of a DataLabelingJob.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  /// If this field is set, all of the search will be done in the context of
  /// this DataLabelingJob.
  final String? dataLabelingJob;

  /// An expression for filtering the DataItem that will be returned.
  ///
  ///   * `data_item_id` - for = or !=.
  ///   * `labeled` - for = or !=.
  ///   * `has_annotation(ANNOTATION_SPEC_ID)` - true only for DataItem that
  ///     have at least one annotation with annotation_spec_id =
  ///     `ANNOTATION_SPEC_ID` in the context of SavedQuery or DataLabelingJob.
  ///
  /// For example:
  ///
  /// * `data_item=1`
  /// * `has_annotation(5)`
  final String? dataItemFilter;

  /// An expression for filtering the Annotations that will be returned per
  /// DataItem.
  ///   * `annotation_spec_id` - for = or !=.
  final String? annotationsFilter;

  /// An expression that specifies what Annotations will be returned per
  /// DataItem. Annotations satisfied either of the conditions will be returned.
  ///   * `annotation_spec_id` - for = or !=.
  /// Must specify `saved_query_id=` - saved query id that annotations should
  /// belong to.
  final List<String>? annotationFilters;

  /// Mask specifying which fields of
  /// `DataItemView` to read.
  final protobuf.FieldMask? fieldMask;

  /// If set, only up to this many of Annotations will be returned per
  /// DataItemView. The maximum value is 1000. If not set, the maximum value will
  /// be used.
  final int? annotationsLimit;

  /// Requested page size. Server may return fewer results than requested.
  /// Default and maximum page size is 100.
  final int? pageSize;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  final String? orderBy;

  /// A token identifying a page of results for the server to return
  /// Typically obtained via
  /// `SearchDataItemsResponse.next_page_token`
  /// of the previous
  /// `DatasetService.SearchDataItems`
  /// call.
  final String? pageToken;

  SearchDataItemsRequest({
    this.orderByDataItem,
    this.orderByAnnotation,
    required this.dataset,
    this.savedQuery,
    this.dataLabelingJob,
    this.dataItemFilter,
    this.annotationsFilter,
    this.annotationFilters,
    this.fieldMask,
    this.annotationsLimit,
    this.pageSize,
    this.orderBy,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory SearchDataItemsRequest.fromJson(Map<String, dynamic> json) {
    return SearchDataItemsRequest(
      orderByDataItem: json['orderByDataItem'],
      orderByAnnotation: decode(
        json['orderByAnnotation'],
        SearchDataItemsRequest_OrderByAnnotation.fromJson,
      ),
      dataset: json['dataset'],
      savedQuery: json['savedQuery'],
      dataLabelingJob: json['dataLabelingJob'],
      dataItemFilter: json['dataItemFilter'],
      annotationsFilter: json['annotationsFilter'],
      annotationFilters: decodeList(json['annotationFilters']),
      fieldMask: decodeCustom(json['fieldMask'], protobuf.FieldMask.fromJson),
      annotationsLimit: json['annotationsLimit'],
      pageSize: json['pageSize'],
      orderBy: json['orderBy'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (orderByDataItem != null) 'orderByDataItem': orderByDataItem,
      if (orderByAnnotation != null)
        'orderByAnnotation': orderByAnnotation!.toJson(),
      'dataset': dataset,
      if (savedQuery != null) 'savedQuery': savedQuery,
      if (dataLabelingJob != null) 'dataLabelingJob': dataLabelingJob,
      if (dataItemFilter != null) 'dataItemFilter': dataItemFilter,
      if (annotationsFilter != null) 'annotationsFilter': annotationsFilter,
      if (annotationFilters != null) 'annotationFilters': annotationFilters,
      if (fieldMask != null) 'fieldMask': fieldMask!.toJson(),
      if (annotationsLimit != null) 'annotationsLimit': annotationsLimit,
      if (pageSize != null) 'pageSize': pageSize,
      if (orderBy != null) 'orderBy': orderBy,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (orderByDataItem != null) 'orderByDataItem=$orderByDataItem',
      'dataset=$dataset',
      if (savedQuery != null) 'savedQuery=$savedQuery',
      if (dataLabelingJob != null) 'dataLabelingJob=$dataLabelingJob',
      if (dataItemFilter != null) 'dataItemFilter=$dataItemFilter',
      if (annotationsFilter != null) 'annotationsFilter=$annotationsFilter',
      if (annotationsLimit != null) 'annotationsLimit=$annotationsLimit',
      if (pageSize != null) 'pageSize=$pageSize',
      if (orderBy != null) 'orderBy=$orderBy',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'SearchDataItemsRequest($contents)';
  }
}

/// Expression that allows ranking results based on annotation's property.
final class SearchDataItemsRequest_OrderByAnnotation
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchDataItemsRequest.OrderByAnnotation';

  /// Required. Saved query of the Annotation. Only Annotations belong to this
  /// saved query will be considered for ordering.
  final String? savedQuery;

  /// A comma-separated list of annotation fields to order by, sorted in
  /// ascending order. Use "desc" after a field name for descending. Must also
  /// specify saved_query.
  final String? orderBy;

  SearchDataItemsRequest_OrderByAnnotation({this.savedQuery, this.orderBy})
    : super(fullyQualifiedName);

  factory SearchDataItemsRequest_OrderByAnnotation.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchDataItemsRequest_OrderByAnnotation(
      savedQuery: json['savedQuery'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      if (savedQuery != null) 'savedQuery': savedQuery,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      if (savedQuery != null) 'savedQuery=$savedQuery',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'OrderByAnnotation($contents)';
  }
}

/// Response message for
/// `DatasetService.SearchDataItems`.
final class SearchDataItemsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchDataItemsResponse';

  /// The DataItemViews read.
  final List<DataItemView>? dataItemViews;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `SearchDataItemsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  SearchDataItemsResponse({this.dataItemViews, this.nextPageToken})
    : super(fullyQualifiedName);

  factory SearchDataItemsResponse.fromJson(Map<String, dynamic> json) {
    return SearchDataItemsResponse(
      dataItemViews: decodeListMessage(
        json['dataItemViews'],
        DataItemView.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dataItemViews != null) 'dataItemViews': encodeList(dataItemViews),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'SearchDataItemsResponse($contents)';
  }
}

/// A container for a single DataItem and Annotations on it.
final class DataItemView extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DataItemView';

  /// The DataItem.
  final DataItem? dataItem;

  /// The Annotations on the DataItem. If too many Annotations should be returned
  /// for the DataItem, this field will be truncated per annotations_limit in
  /// request. If it was, then the has_truncated_annotations will be set to true.
  final List<Annotation>? annotations;

  /// True if and only if the Annotations field has been truncated. It happens if
  /// more Annotations for this DataItem met the request's annotation_filter than
  /// are allowed to be returned by annotations_limit.
  /// Note that if Annotations field is not being returned due to field mask,
  /// then this field will not be set to true no matter how many Annotations are
  /// there.
  final bool? hasTruncatedAnnotations;

  DataItemView({this.dataItem, this.annotations, this.hasTruncatedAnnotations})
    : super(fullyQualifiedName);

  factory DataItemView.fromJson(Map<String, dynamic> json) {
    return DataItemView(
      dataItem: decode(json['dataItem'], DataItem.fromJson),
      annotations: decodeListMessage(json['annotations'], Annotation.fromJson),
      hasTruncatedAnnotations: json['hasTruncatedAnnotations'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dataItem != null) 'dataItem': dataItem!.toJson(),
      if (annotations != null) 'annotations': encodeList(annotations),
      if (hasTruncatedAnnotations != null)
        'hasTruncatedAnnotations': hasTruncatedAnnotations,
    };
  }

  @override
  String toString() {
    final contents = [
      if (hasTruncatedAnnotations != null)
        'hasTruncatedAnnotations=$hasTruncatedAnnotations',
    ].join(',');
    return 'DataItemView($contents)';
  }
}

/// Request message for
/// `DatasetService.ListSavedQueries`.
final class ListSavedQueriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSavedQueriesRequest';

  /// Required. The resource name of the Dataset to list SavedQueries from.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String parent;

  /// The standard list filter.
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  final String? orderBy;

  ListSavedQueriesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListSavedQueriesRequest.fromJson(Map<String, dynamic> json) {
    return ListSavedQueriesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListSavedQueriesRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListSavedQueries`.
final class ListSavedQueriesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSavedQueriesResponse';

  /// A list of SavedQueries that match the specified filter in the request.
  final List<SavedQuery>? savedQueries;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListSavedQueriesResponse({this.savedQueries, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListSavedQueriesResponse.fromJson(Map<String, dynamic> json) {
    return ListSavedQueriesResponse(
      savedQueries: decodeListMessage(
        json['savedQueries'],
        SavedQuery.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (savedQueries != null) 'savedQueries': encodeList(savedQueries),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListSavedQueriesResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.DeleteSavedQuery`.
final class DeleteSavedQueryRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteSavedQueryRequest';

  /// Required. The resource name of the SavedQuery to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/savedQueries/{saved_query}`
  final String name;

  DeleteSavedQueryRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteSavedQueryRequest.fromJson(Map<String, dynamic> json) {
    return DeleteSavedQueryRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteSavedQueryRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.GetAnnotationSpec`.
final class GetAnnotationSpecRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetAnnotationSpecRequest';

  /// Required. The name of the AnnotationSpec resource.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/annotationSpecs/{annotation_spec}`
  final String name;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  GetAnnotationSpecRequest({required this.name, this.readMask})
    : super(fullyQualifiedName);

  factory GetAnnotationSpecRequest.fromJson(Map<String, dynamic> json) {
    return GetAnnotationSpecRequest(
      name: json['name'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {'name': name, if (readMask != null) 'readMask': readMask!.toJson()};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetAnnotationSpecRequest($contents)';
  }
}

/// Request message for
/// `DatasetService.ListAnnotations`.
final class ListAnnotationsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListAnnotationsRequest';

  /// Required. The resource name of the DataItem to list Annotations from.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}/dataItems/{data_item}`
  final String parent;

  /// The standard list filter.
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  final String? orderBy;

  ListAnnotationsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListAnnotationsRequest.fromJson(Map<String, dynamic> json) {
    return ListAnnotationsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListAnnotationsRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.ListAnnotations`.
final class ListAnnotationsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListAnnotationsResponse';

  /// A list of Annotations that matches the specified filter in the request.
  final List<Annotation>? annotations;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListAnnotationsResponse({this.annotations, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListAnnotationsResponse.fromJson(Map<String, dynamic> json) {
    return ListAnnotationsResponse(
      annotations: decodeListMessage(json['annotations'], Annotation.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (annotations != null) 'annotations': encodeList(annotations),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListAnnotationsResponse($contents)';
  }
}

/// Request message for
/// `DatasetService.AssessData`.
/// Used only for MULTIMODAL datasets.
final class AssessDataRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest';

  /// Optional. Configuration for the tuning validation assessment.
  final AssessDataRequest_TuningValidationAssessmentConfig?
  tuningValidationAssessmentConfig;

  /// Optional. Configuration for the tuning resource usage assessment.
  final AssessDataRequest_TuningResourceUsageAssessmentConfig?
  tuningResourceUsageAssessmentConfig;

  /// Optional. Configuration for the batch prediction validation assessment.
  final AssessDataRequest_BatchPredictionValidationAssessmentConfig?
  batchPredictionValidationAssessmentConfig;

  /// Optional. Configuration for the batch prediction resource usage
  /// assessment.
  final AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig?
  batchPredictionResourceUsageAssessmentConfig;

  /// Required. The name of the Dataset resource. Used only for MULTIMODAL
  /// datasets. Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  /// Optional. The Gemini request read config for the dataset.
  final GeminiRequestReadConfig? geminiRequestReadConfig;

  AssessDataRequest({
    this.tuningValidationAssessmentConfig,
    this.tuningResourceUsageAssessmentConfig,
    this.batchPredictionValidationAssessmentConfig,
    this.batchPredictionResourceUsageAssessmentConfig,
    required this.name,
    this.geminiRequestReadConfig,
  }) : super(fullyQualifiedName);

  factory AssessDataRequest.fromJson(Map<String, dynamic> json) {
    return AssessDataRequest(
      tuningValidationAssessmentConfig: decode(
        json['tuningValidationAssessmentConfig'],
        AssessDataRequest_TuningValidationAssessmentConfig.fromJson,
      ),
      tuningResourceUsageAssessmentConfig: decode(
        json['tuningResourceUsageAssessmentConfig'],
        AssessDataRequest_TuningResourceUsageAssessmentConfig.fromJson,
      ),
      batchPredictionValidationAssessmentConfig: decode(
        json['batchPredictionValidationAssessmentConfig'],
        AssessDataRequest_BatchPredictionValidationAssessmentConfig.fromJson,
      ),
      batchPredictionResourceUsageAssessmentConfig: decode(
        json['batchPredictionResourceUsageAssessmentConfig'],
        AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig.fromJson,
      ),
      name: json['name'],
      geminiRequestReadConfig: decode(
        json['geminiRequestReadConfig'],
        GeminiRequestReadConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (tuningValidationAssessmentConfig != null)
        'tuningValidationAssessmentConfig': tuningValidationAssessmentConfig!
            .toJson(),
      if (tuningResourceUsageAssessmentConfig != null)
        'tuningResourceUsageAssessmentConfig':
            tuningResourceUsageAssessmentConfig!.toJson(),
      if (batchPredictionValidationAssessmentConfig != null)
        'batchPredictionValidationAssessmentConfig':
            batchPredictionValidationAssessmentConfig!.toJson(),
      if (batchPredictionResourceUsageAssessmentConfig != null)
        'batchPredictionResourceUsageAssessmentConfig':
            batchPredictionResourceUsageAssessmentConfig!.toJson(),
      'name': name,
      if (geminiRequestReadConfig != null)
        'geminiRequestReadConfig': geminiRequestReadConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AssessDataRequest($contents)';
  }
}

/// Configuration for the tuning validation assessment.
final class AssessDataRequest_TuningValidationAssessmentConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest.TuningValidationAssessmentConfig';

  /// Required. The name of the model used for tuning.
  final String? modelName;

  /// Required. The dataset usage (e.g. training/validation).
  final AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage?
  datasetUsage;

  AssessDataRequest_TuningValidationAssessmentConfig({
    this.modelName,
    this.datasetUsage,
  }) : super(fullyQualifiedName);

  factory AssessDataRequest_TuningValidationAssessmentConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssessDataRequest_TuningValidationAssessmentConfig(
      modelName: json['modelName'],
      datasetUsage: decodeEnum(
        json['datasetUsage'],
        AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (modelName != null) 'modelName': modelName,
      if (datasetUsage != null) 'datasetUsage': datasetUsage!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (modelName != null) 'modelName=$modelName',
      if (datasetUsage != null) 'datasetUsage=$datasetUsage',
    ].join(',');
    return 'TuningValidationAssessmentConfig($contents)';
  }
}

/// The dataset usage (e.g. training/validation).
final class AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage
    extends protobuf.ProtoEnum {
  /// Default value. Should not be used.
  static const datasetUsageUnspecified =
      AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
        'DATASET_USAGE_UNSPECIFIED',
      );

  /// Supervised fine-tuning training dataset.
  static const sftTraining =
      AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
        'SFT_TRAINING',
      );

  /// Supervised fine-tuning validation dataset.
  static const sftValidation =
      AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
        'SFT_VALIDATION',
      );

  const AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(
    super.value,
  );

  factory AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage.fromJson(
    String json,
  ) => AssessDataRequest_TuningValidationAssessmentConfig_DatasetUsage(json);

  @override
  String toString() => 'DatasetUsage.$value';
}

/// Configuration for the tuning resource usage assessment.
final class AssessDataRequest_TuningResourceUsageAssessmentConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest.TuningResourceUsageAssessmentConfig';

  /// Required. The name of the model used for tuning.
  final String? modelName;

  AssessDataRequest_TuningResourceUsageAssessmentConfig({this.modelName})
    : super(fullyQualifiedName);

  factory AssessDataRequest_TuningResourceUsageAssessmentConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssessDataRequest_TuningResourceUsageAssessmentConfig(
      modelName: json['modelName'],
    );
  }

  @override
  Object toJson() {
    return {if (modelName != null) 'modelName': modelName};
  }

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'TuningResourceUsageAssessmentConfig($contents)';
  }
}

/// Configuration for the batch prediction validation assessment.
final class AssessDataRequest_BatchPredictionValidationAssessmentConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest.BatchPredictionValidationAssessmentConfig';

  /// Required. The name of the model used for batch prediction.
  final String? modelName;

  AssessDataRequest_BatchPredictionValidationAssessmentConfig({this.modelName})
    : super(fullyQualifiedName);

  factory AssessDataRequest_BatchPredictionValidationAssessmentConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssessDataRequest_BatchPredictionValidationAssessmentConfig(
      modelName: json['modelName'],
    );
  }

  @override
  Object toJson() {
    return {if (modelName != null) 'modelName': modelName};
  }

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'BatchPredictionValidationAssessmentConfig($contents)';
  }
}

/// Configuration for the batch prediction resource usage assessment.
final class AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataRequest.BatchPredictionResourceUsageAssessmentConfig';

  /// Required. The name of the model used for batch prediction.
  final String? modelName;

  AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig({
    this.modelName,
  }) : super(fullyQualifiedName);

  factory AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssessDataRequest_BatchPredictionResourceUsageAssessmentConfig(
      modelName: json['modelName'],
    );
  }

  @override
  Object toJson() {
    return {if (modelName != null) 'modelName': modelName};
  }

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'BatchPredictionResourceUsageAssessmentConfig($contents)';
  }
}

/// Response message for
/// `DatasetService.AssessData`.
final class AssessDataResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse';

  /// Optional. The result of the tuning validation assessment.
  final AssessDataResponse_TuningValidationAssessmentResult?
  tuningValidationAssessmentResult;

  /// Optional. The result of the tuning resource usage assessment.
  final AssessDataResponse_TuningResourceUsageAssessmentResult?
  tuningResourceUsageAssessmentResult;

  /// Optional. The result of the batch prediction validation assessment.
  final AssessDataResponse_BatchPredictionValidationAssessmentResult?
  batchPredictionValidationAssessmentResult;

  /// Optional. The result of the batch prediction resource usage assessment.
  final AssessDataResponse_BatchPredictionResourceUsageAssessmentResult?
  batchPredictionResourceUsageAssessmentResult;

  AssessDataResponse({
    this.tuningValidationAssessmentResult,
    this.tuningResourceUsageAssessmentResult,
    this.batchPredictionValidationAssessmentResult,
    this.batchPredictionResourceUsageAssessmentResult,
  }) : super(fullyQualifiedName);

  factory AssessDataResponse.fromJson(Map<String, dynamic> json) {
    return AssessDataResponse(
      tuningValidationAssessmentResult: decode(
        json['tuningValidationAssessmentResult'],
        AssessDataResponse_TuningValidationAssessmentResult.fromJson,
      ),
      tuningResourceUsageAssessmentResult: decode(
        json['tuningResourceUsageAssessmentResult'],
        AssessDataResponse_TuningResourceUsageAssessmentResult.fromJson,
      ),
      batchPredictionValidationAssessmentResult: decode(
        json['batchPredictionValidationAssessmentResult'],
        AssessDataResponse_BatchPredictionValidationAssessmentResult.fromJson,
      ),
      batchPredictionResourceUsageAssessmentResult: decode(
        json['batchPredictionResourceUsageAssessmentResult'],
        AssessDataResponse_BatchPredictionResourceUsageAssessmentResult
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (tuningValidationAssessmentResult != null)
        'tuningValidationAssessmentResult': tuningValidationAssessmentResult!
            .toJson(),
      if (tuningResourceUsageAssessmentResult != null)
        'tuningResourceUsageAssessmentResult':
            tuningResourceUsageAssessmentResult!.toJson(),
      if (batchPredictionValidationAssessmentResult != null)
        'batchPredictionValidationAssessmentResult':
            batchPredictionValidationAssessmentResult!.toJson(),
      if (batchPredictionResourceUsageAssessmentResult != null)
        'batchPredictionResourceUsageAssessmentResult':
            batchPredictionResourceUsageAssessmentResult!.toJson(),
    };
  }

  @override
  String toString() => 'AssessDataResponse()';
}

/// The result of the tuning validation assessment.
final class AssessDataResponse_TuningValidationAssessmentResult
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse.TuningValidationAssessmentResult';

  /// Optional. A list containing the first validation errors.
  final List<String>? errors;

  AssessDataResponse_TuningValidationAssessmentResult({this.errors})
    : super(fullyQualifiedName);

  factory AssessDataResponse_TuningValidationAssessmentResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssessDataResponse_TuningValidationAssessmentResult(
      errors: decodeList(json['errors']),
    );
  }

  @override
  Object toJson() {
    return {if (errors != null) 'errors': errors};
  }

  @override
  String toString() => 'TuningValidationAssessmentResult()';
}

/// The result of the tuning resource usage assessment.
final class AssessDataResponse_TuningResourceUsageAssessmentResult
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse.TuningResourceUsageAssessmentResult';

  /// Number of tokens in the tuning dataset.
  final int? tokenCount;

  /// Number of billable tokens in the tuning dataset.
  final int? billableCharacterCount;

  AssessDataResponse_TuningResourceUsageAssessmentResult({
    this.tokenCount,
    this.billableCharacterCount,
  }) : super(fullyQualifiedName);

  factory AssessDataResponse_TuningResourceUsageAssessmentResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssessDataResponse_TuningResourceUsageAssessmentResult(
      tokenCount: decodeInt64(json['tokenCount']),
      billableCharacterCount: decodeInt64(json['billableCharacterCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (tokenCount != null) 'tokenCount': encodeInt64(tokenCount),
      if (billableCharacterCount != null)
        'billableCharacterCount': encodeInt64(billableCharacterCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (tokenCount != null) 'tokenCount=$tokenCount',
      if (billableCharacterCount != null)
        'billableCharacterCount=$billableCharacterCount',
    ].join(',');
    return 'TuningResourceUsageAssessmentResult($contents)';
  }
}

/// The result of the batch prediction validation assessment.
final class AssessDataResponse_BatchPredictionValidationAssessmentResult
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse.BatchPredictionValidationAssessmentResult';

  AssessDataResponse_BatchPredictionValidationAssessmentResult()
    : super(fullyQualifiedName);

  factory AssessDataResponse_BatchPredictionValidationAssessmentResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssessDataResponse_BatchPredictionValidationAssessmentResult();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'BatchPredictionValidationAssessmentResult()';
}

/// The result of the batch prediction resource usage assessment.
final class AssessDataResponse_BatchPredictionResourceUsageAssessmentResult
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataResponse.BatchPredictionResourceUsageAssessmentResult';

  /// Number of tokens in the batch prediction dataset.
  final int? tokenCount;

  /// Number of audio tokens in the batch prediction dataset.
  final int? audioTokenCount;

  AssessDataResponse_BatchPredictionResourceUsageAssessmentResult({
    this.tokenCount,
    this.audioTokenCount,
  }) : super(fullyQualifiedName);

  factory AssessDataResponse_BatchPredictionResourceUsageAssessmentResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssessDataResponse_BatchPredictionResourceUsageAssessmentResult(
      tokenCount: decodeInt64(json['tokenCount']),
      audioTokenCount: decodeInt64(json['audioTokenCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (tokenCount != null) 'tokenCount': encodeInt64(tokenCount),
      if (audioTokenCount != null)
        'audioTokenCount': encodeInt64(audioTokenCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (tokenCount != null) 'tokenCount=$tokenCount',
      if (audioTokenCount != null) 'audioTokenCount=$audioTokenCount',
    ].join(',');
    return 'BatchPredictionResourceUsageAssessmentResult($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.AssessData`.
final class AssessDataOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssessDataOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  AssessDataOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory AssessDataOperationMetadata.fromJson(Map<String, dynamic> json) {
    return AssessDataOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'AssessDataOperationMetadata()';
}

/// Template configuration to create Gemini examples from a multimodal dataset.
final class GeminiTemplateConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GeminiTemplateConfig';

  /// Required. The template that will be used for assembling the request to use
  /// for downstream applications.
  final GeminiExample? geminiExample;

  /// Required. Map of template parameters to the columns in the dataset table.
  final Map<String, String>? fieldMapping;

  GeminiTemplateConfig({this.geminiExample, this.fieldMapping})
    : super(fullyQualifiedName);

  factory GeminiTemplateConfig.fromJson(Map<String, dynamic> json) {
    return GeminiTemplateConfig(
      geminiExample: decode(json['geminiExample'], GeminiExample.fromJson),
      fieldMapping: decodeMap(json['fieldMapping']),
    );
  }

  @override
  Object toJson() {
    return {
      if (geminiExample != null) 'geminiExample': geminiExample!.toJson(),
      if (fieldMapping != null) 'fieldMapping': fieldMapping,
    };
  }

  @override
  String toString() => 'GeminiTemplateConfig()';
}

/// Configuration for how to read Gemini requests from a multimodal dataset.
final class GeminiRequestReadConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GeminiRequestReadConfig';

  /// Gemini request template with placeholders.
  final GeminiTemplateConfig? templateConfig;

  /// Optional. Column name in the dataset table that contains already fully
  /// assembled Gemini requests.
  final String? assembledRequestColumnName;

  GeminiRequestReadConfig({
    this.templateConfig,
    this.assembledRequestColumnName,
  }) : super(fullyQualifiedName);

  factory GeminiRequestReadConfig.fromJson(Map<String, dynamic> json) {
    return GeminiRequestReadConfig(
      templateConfig: decode(
        json['templateConfig'],
        GeminiTemplateConfig.fromJson,
      ),
      assembledRequestColumnName: json['assembledRequestColumnName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (templateConfig != null) 'templateConfig': templateConfig!.toJson(),
      if (assembledRequestColumnName != null)
        'assembledRequestColumnName': assembledRequestColumnName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (assembledRequestColumnName != null)
        'assembledRequestColumnName=$assembledRequestColumnName',
    ].join(',');
    return 'GeminiRequestReadConfig($contents)';
  }
}

/// Format for Gemini examples used for Vertex Multimodal datasets.
final class GeminiExample extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GeminiExample';

  /// Optional. The fully qualified name of the publisher model or tuned model
  /// endpoint to use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers/*/models/*`
  ///
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? model;

  /// Required. The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn
  /// queries, this is a repeated field that contains conversation history +
  /// latest request.
  final List<Content>? contents;

  /// Optional. The user provided system instructions for the model.
  /// Note: only text should be used in parts and content in each part will be
  /// in a separate paragraph.
  final Content? systemInstruction;

  /// Optional. The name of the cached content used as context to serve the
  /// prediction. Note: only used in explicit caching, where users can have
  /// control over caching (e.g. what content to cache) and enjoy guaranteed cost
  /// savings. Format:
  /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
  final String? cachedContent;

  /// Optional. A list of `Tools` the model may use to generate the next
  /// response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  final List<Tool>? tools;

  /// Optional. Tool config. This config is shared for all tools provided in the
  /// request.
  final ToolConfig? toolConfig;

  /// Optional. The labels with user-defined metadata for the request. It is used
  /// for billing and reporting only.
  ///
  /// Label keys and values can be no longer than 63 characters
  /// (Unicode codepoints) and can only contain lowercase letters, numeric
  /// characters, underscores, and dashes. International characters are
  /// allowed. Label values are optional. Label keys must start with a letter.
  final Map<String, String>? labels;

  /// Optional. Per request settings for blocking unsafe content.
  /// Enforced on GenerateContentResponse.candidates.
  final List<SafetySetting>? safetySettings;

  /// Optional. Generation config.
  final GenerationConfig? generationConfig;

  GeminiExample({
    this.model,
    this.contents,
    this.systemInstruction,
    this.cachedContent,
    this.tools,
    this.toolConfig,
    this.labels,
    this.safetySettings,
    this.generationConfig,
  }) : super(fullyQualifiedName);

  factory GeminiExample.fromJson(Map<String, dynamic> json) {
    return GeminiExample(
      model: json['model'],
      contents: decodeListMessage(json['contents'], Content.fromJson),
      systemInstruction: decode(json['systemInstruction'], Content.fromJson),
      cachedContent: json['cachedContent'],
      tools: decodeListMessage(json['tools'], Tool.fromJson),
      toolConfig: decode(json['toolConfig'], ToolConfig.fromJson),
      labels: decodeMap(json['labels']),
      safetySettings: decodeListMessage(
        json['safetySettings'],
        SafetySetting.fromJson,
      ),
      generationConfig: decode(
        json['generationConfig'],
        GenerationConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      if (contents != null) 'contents': encodeList(contents),
      if (systemInstruction != null)
        'systemInstruction': systemInstruction!.toJson(),
      if (cachedContent != null) 'cachedContent': cachedContent,
      if (tools != null) 'tools': encodeList(tools),
      if (toolConfig != null) 'toolConfig': toolConfig!.toJson(),
      if (labels != null) 'labels': labels,
      if (safetySettings != null) 'safetySettings': encodeList(safetySettings),
      if (generationConfig != null)
        'generationConfig': generationConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (cachedContent != null) 'cachedContent=$cachedContent',
    ].join(',');
    return 'GeminiExample($contents)';
  }
}

/// Request message for
/// `DatasetService.AssembleData`.
/// Used only for MULTIMODAL datasets.
final class AssembleDataRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssembleDataRequest';

  /// Required. The name of the Dataset resource (used only for MULTIMODAL
  /// datasets). Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`
  final String name;

  /// Optional. The read config for the dataset.
  final GeminiRequestReadConfig? geminiRequestReadConfig;

  AssembleDataRequest({required this.name, this.geminiRequestReadConfig})
    : super(fullyQualifiedName);

  factory AssembleDataRequest.fromJson(Map<String, dynamic> json) {
    return AssembleDataRequest(
      name: json['name'],
      geminiRequestReadConfig: decode(
        json['geminiRequestReadConfig'],
        GeminiRequestReadConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (geminiRequestReadConfig != null)
        'geminiRequestReadConfig': geminiRequestReadConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AssembleDataRequest($contents)';
  }
}

/// Response message for
/// `DatasetService.AssembleData`.
final class AssembleDataResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssembleDataResponse';

  /// Destination BigQuery table path containing the assembled data as a single
  /// column.
  final String? bigqueryDestination;

  AssembleDataResponse({this.bigqueryDestination}) : super(fullyQualifiedName);

  factory AssembleDataResponse.fromJson(Map<String, dynamic> json) {
    return AssembleDataResponse(
      bigqueryDestination: json['bigqueryDestination'],
    );
  }

  @override
  Object toJson() {
    return {
      if (bigqueryDestination != null)
        'bigqueryDestination': bigqueryDestination,
    };
  }

  @override
  String toString() {
    final contents = [
      if (bigqueryDestination != null)
        'bigqueryDestination=$bigqueryDestination',
    ].join(',');
    return 'AssembleDataResponse($contents)';
  }
}

/// Runtime operation information for
/// `DatasetService.AssembleData`.
final class AssembleDataOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssembleDataOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  AssembleDataOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory AssembleDataOperationMetadata.fromJson(Map<String, dynamic> json) {
    return AssembleDataOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'AssembleDataOperationMetadata()';
}

/// Describes the dataset version.
final class DatasetVersion extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DatasetVersion';

  /// Output only. Identifier. The resource name of the DatasetVersion.
  final String? name;

  /// Output only. Timestamp when this DatasetVersion was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this DatasetVersion was last updated.
  final protobuf.Timestamp? updateTime;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// Output only. Name of the associated BigQuery dataset.
  final String? bigQueryDatasetName;

  /// The user-defined name of the DatasetVersion.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Required. Output only. Additional information about the DatasetVersion.
  final protobuf.Value? metadata;

  /// Output only. Reference to the public base model last used by the dataset
  /// version. Only set for prompt dataset versions.
  final String? modelReference;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  DatasetVersion({
    this.name,
    this.createTime,
    this.updateTime,
    this.etag,
    this.bigQueryDatasetName,
    this.displayName,
    this.metadata,
    this.modelReference,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory DatasetVersion.fromJson(Map<String, dynamic> json) {
    return DatasetVersion(
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      bigQueryDatasetName: json['bigQueryDatasetName'],
      displayName: json['displayName'],
      metadata: decodeCustom(json['metadata'], protobuf.Value.fromJson),
      modelReference: json['modelReference'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (bigQueryDatasetName != null)
        'bigQueryDatasetName': bigQueryDatasetName,
      if (displayName != null) 'displayName': displayName,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (modelReference != null) 'modelReference': modelReference,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (etag != null) 'etag=$etag',
      if (bigQueryDatasetName != null)
        'bigQueryDatasetName=$bigQueryDatasetName',
      if (displayName != null) 'displayName=$displayName',
      if (modelReference != null) 'modelReference=$modelReference',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'DatasetVersion($contents)';
  }
}

/// Points to a DeployedIndex.
final class DeployedIndexRef extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedIndexRef';

  /// Immutable. A resource name of the IndexEndpoint.
  final String? indexEndpoint;

  /// Immutable. The ID of the DeployedIndex in the above IndexEndpoint.
  final String? deployedIndexId;

  /// Output only. The display name of the DeployedIndex.
  final String? displayName;

  DeployedIndexRef({this.indexEndpoint, this.deployedIndexId, this.displayName})
    : super(fullyQualifiedName);

  factory DeployedIndexRef.fromJson(Map<String, dynamic> json) {
    return DeployedIndexRef(
      indexEndpoint: json['indexEndpoint'],
      deployedIndexId: json['deployedIndexId'],
      displayName: json['displayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (indexEndpoint != null) 'indexEndpoint': indexEndpoint,
      if (deployedIndexId != null) 'deployedIndexId': deployedIndexId,
      if (displayName != null) 'displayName': displayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (indexEndpoint != null) 'indexEndpoint=$indexEndpoint',
      if (deployedIndexId != null) 'deployedIndexId=$deployedIndexId',
      if (displayName != null) 'displayName=$displayName',
    ].join(',');
    return 'DeployedIndexRef($contents)';
  }
}

/// Points to a DeployedModel.
final class DeployedModelRef extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedModelRef';

  /// Immutable. A resource name of an Endpoint.
  final String? endpoint;

  /// Immutable. An ID of a DeployedModel in the above Endpoint.
  final String? deployedModelId;

  DeployedModelRef({this.endpoint, this.deployedModelId})
    : super(fullyQualifiedName);

  factory DeployedModelRef.fromJson(Map<String, dynamic> json) {
    return DeployedModelRef(
      endpoint: json['endpoint'],
      deployedModelId: json['deployedModelId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (endpoint != null) 'endpoint': endpoint,
      if (deployedModelId != null) 'deployedModelId': deployedModelId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (endpoint != null) 'endpoint=$endpoint',
      if (deployedModelId != null) 'deployedModelId=$deployedModelId',
    ].join(',');
    return 'DeployedModelRef($contents)';
  }
}

/// A description of resources that can be shared by multiple DeployedModels,
/// whose underlying specification consists of a DedicatedResources.
final class DeploymentResourcePool extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeploymentResourcePool';

  /// Immutable. The resource name of the DeploymentResourcePool.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String? name;

  /// Required. The underlying DedicatedResources that the DeploymentResourcePool
  /// uses.
  final DedicatedResources? dedicatedResources;

  /// Customer-managed encryption key spec for a DeploymentResourcePool. If set,
  /// this DeploymentResourcePool will be secured by this key. Endpoints and the
  /// DeploymentResourcePool they deploy in need to have the same EncryptionSpec.
  final EncryptionSpec? encryptionSpec;

  /// The service account that the DeploymentResourcePool's container(s) run as.
  /// Specify the email address of the service account. If this service account
  /// is not specified, the container(s) run as a service account that doesn't
  /// have access to the resource project.
  ///
  /// Users deploying the Models to this DeploymentResourcePool must have the
  /// `iam.serviceAccounts.actAs` permission on this service account.
  final String? serviceAccount;

  /// If the DeploymentResourcePool is deployed with custom-trained Models or
  /// AutoML Tabular Models, the container(s) of the DeploymentResourcePool will
  /// send `stderr` and `stdout` streams to Cloud Logging by default.
  /// Please note that the logs incur cost, which are subject to [Cloud Logging
  /// pricing](https://cloud.google.com/logging/pricing).
  ///
  /// User can disable container logging by setting this flag to true.
  final bool? disableContainerLogging;

  /// Output only. Timestamp when this DeploymentResourcePool was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  DeploymentResourcePool({
    this.name,
    this.dedicatedResources,
    this.encryptionSpec,
    this.serviceAccount,
    this.disableContainerLogging,
    this.createTime,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory DeploymentResourcePool.fromJson(Map<String, dynamic> json) {
    return DeploymentResourcePool(
      name: json['name'],
      dedicatedResources: decode(
        json['dedicatedResources'],
        DedicatedResources.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      serviceAccount: json['serviceAccount'],
      disableContainerLogging: json['disableContainerLogging'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (dedicatedResources != null)
        'dedicatedResources': dedicatedResources!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (disableContainerLogging != null)
        'disableContainerLogging': disableContainerLogging,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (disableContainerLogging != null)
        'disableContainerLogging=$disableContainerLogging',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'DeploymentResourcePool($contents)';
  }
}

/// Request message for CreateDeploymentResourcePool method.
final class CreateDeploymentResourcePoolRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDeploymentResourcePoolRequest';

  /// Required. The parent location resource where this DeploymentResourcePool
  /// will be created. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The DeploymentResourcePool to create.
  final DeploymentResourcePool? deploymentResourcePool;

  /// Required. The ID to use for the DeploymentResourcePool, which
  /// will become the final component of the DeploymentResourcePool's resource
  /// name.
  ///
  /// The maximum length is 63 characters, and valid characters
  /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  final String? deploymentResourcePoolId;

  CreateDeploymentResourcePoolRequest({
    required this.parent,
    this.deploymentResourcePool,
    this.deploymentResourcePoolId,
  }) : super(fullyQualifiedName);

  factory CreateDeploymentResourcePoolRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateDeploymentResourcePoolRequest(
      parent: json['parent'],
      deploymentResourcePool: decode(
        json['deploymentResourcePool'],
        DeploymentResourcePool.fromJson,
      ),
      deploymentResourcePoolId: json['deploymentResourcePoolId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (deploymentResourcePool != null)
        'deploymentResourcePool': deploymentResourcePool!.toJson(),
      if (deploymentResourcePoolId != null)
        'deploymentResourcePoolId': deploymentResourcePoolId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (deploymentResourcePoolId != null)
        'deploymentResourcePoolId=$deploymentResourcePoolId',
    ].join(',');
    return 'CreateDeploymentResourcePoolRequest($contents)';
  }
}

/// Runtime operation information for CreateDeploymentResourcePool method.
final class CreateDeploymentResourcePoolOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDeploymentResourcePoolOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateDeploymentResourcePoolOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateDeploymentResourcePoolOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateDeploymentResourcePoolOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateDeploymentResourcePoolOperationMetadata()';
}

/// Request message for GetDeploymentResourcePool method.
final class GetDeploymentResourcePoolRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetDeploymentResourcePoolRequest';

  /// Required. The name of the DeploymentResourcePool to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String name;

  GetDeploymentResourcePoolRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetDeploymentResourcePoolRequest.fromJson(Map<String, dynamic> json) {
    return GetDeploymentResourcePoolRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetDeploymentResourcePoolRequest($contents)';
  }
}

/// Request message for ListDeploymentResourcePools method.
final class ListDeploymentResourcePoolsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDeploymentResourcePoolsRequest';

  /// Required. The parent Location which owns this collection of
  /// DeploymentResourcePools. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The maximum number of DeploymentResourcePools to return. The service may
  /// return fewer than this value.
  final int? pageSize;

  /// A page token, received from a previous `ListDeploymentResourcePools` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `ListDeploymentResourcePools` must match the call that provided the page
  /// token.
  final String? pageToken;

  ListDeploymentResourcePoolsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListDeploymentResourcePoolsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListDeploymentResourcePoolsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListDeploymentResourcePoolsRequest($contents)';
  }
}

/// Response message for ListDeploymentResourcePools method.
final class ListDeploymentResourcePoolsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDeploymentResourcePoolsResponse';

  /// The DeploymentResourcePools from the specified location.
  final List<DeploymentResourcePool>? deploymentResourcePools;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  final String? nextPageToken;

  ListDeploymentResourcePoolsResponse({
    this.deploymentResourcePools,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListDeploymentResourcePoolsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListDeploymentResourcePoolsResponse(
      deploymentResourcePools: decodeListMessage(
        json['deploymentResourcePools'],
        DeploymentResourcePool.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (deploymentResourcePools != null)
        'deploymentResourcePools': encodeList(deploymentResourcePools),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListDeploymentResourcePoolsResponse($contents)';
  }
}

/// Request message for UpdateDeploymentResourcePool method.
final class UpdateDeploymentResourcePoolRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateDeploymentResourcePoolRequest';

  /// Required. The DeploymentResourcePool to update.
  ///
  /// The DeploymentResourcePool's `name` field is used to identify the
  /// DeploymentResourcePool to update.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final DeploymentResourcePool deploymentResourcePool;

  /// Required. The list of fields to update.
  final protobuf.FieldMask? updateMask;

  UpdateDeploymentResourcePoolRequest({
    required this.deploymentResourcePool,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateDeploymentResourcePoolRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateDeploymentResourcePoolRequest(
      deploymentResourcePool: decode(
        json['deploymentResourcePool'],
        DeploymentResourcePool.fromJson,
      )!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'deploymentResourcePool': deploymentResourcePool.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateDeploymentResourcePoolRequest()';
}

/// Runtime operation information for UpdateDeploymentResourcePool method.
final class UpdateDeploymentResourcePoolOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateDeploymentResourcePoolOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateDeploymentResourcePoolOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateDeploymentResourcePoolOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateDeploymentResourcePoolOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateDeploymentResourcePoolOperationMetadata()';
}

/// Request message for DeleteDeploymentResourcePool method.
final class DeleteDeploymentResourcePoolRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteDeploymentResourcePoolRequest';

  /// Required. The name of the DeploymentResourcePool to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String name;

  DeleteDeploymentResourcePoolRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteDeploymentResourcePoolRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteDeploymentResourcePoolRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteDeploymentResourcePoolRequest($contents)';
  }
}

/// Request message for QueryDeployedModels method.
final class QueryDeployedModelsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryDeployedModelsRequest';

  /// Required. The name of the target DeploymentResourcePool to query.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String deploymentResourcePool;

  /// The maximum number of DeployedModels to return. The service may return
  /// fewer than this value.
  final int? pageSize;

  /// A page token, received from a previous `QueryDeployedModels` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `QueryDeployedModels` must match the call that provided the page
  /// token.
  final String? pageToken;

  QueryDeployedModelsRequest({
    required this.deploymentResourcePool,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory QueryDeployedModelsRequest.fromJson(Map<String, dynamic> json) {
    return QueryDeployedModelsRequest(
      deploymentResourcePool: json['deploymentResourcePool'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'deploymentResourcePool': deploymentResourcePool,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'deploymentResourcePool=$deploymentResourcePool',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'QueryDeployedModelsRequest($contents)';
  }
}

/// Response message for QueryDeployedModels method.
final class QueryDeployedModelsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryDeployedModelsResponse';

  /// DEPRECATED Use deployed_model_refs instead.
  final List<DeployedModel>? deployedModels;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  final String? nextPageToken;

  /// References to the DeployedModels that share the specified
  /// deploymentResourcePool.
  final List<DeployedModelRef>? deployedModelRefs;

  /// The total number of DeployedModels on this DeploymentResourcePool.
  final int? totalDeployedModelCount;

  /// The total number of Endpoints that have DeployedModels on this
  /// DeploymentResourcePool.
  final int? totalEndpointCount;

  QueryDeployedModelsResponse({
    this.deployedModels,
    this.nextPageToken,
    this.deployedModelRefs,
    this.totalDeployedModelCount,
    this.totalEndpointCount,
  }) : super(fullyQualifiedName);

  factory QueryDeployedModelsResponse.fromJson(Map<String, dynamic> json) {
    return QueryDeployedModelsResponse(
      deployedModels: decodeListMessage(
        json['deployedModels'],
        DeployedModel.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
      deployedModelRefs: decodeListMessage(
        json['deployedModelRefs'],
        DeployedModelRef.fromJson,
      ),
      totalDeployedModelCount: json['totalDeployedModelCount'],
      totalEndpointCount: json['totalEndpointCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (deployedModels != null) 'deployedModels': encodeList(deployedModels),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
      if (deployedModelRefs != null)
        'deployedModelRefs': encodeList(deployedModelRefs),
      if (totalDeployedModelCount != null)
        'totalDeployedModelCount': totalDeployedModelCount,
      if (totalEndpointCount != null) 'totalEndpointCount': totalEndpointCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
      if (totalDeployedModelCount != null)
        'totalDeployedModelCount=$totalDeployedModelCount',
      if (totalEndpointCount != null) 'totalEndpointCount=$totalEndpointCount',
    ].join(',');
    return 'QueryDeployedModelsResponse($contents)';
  }
}

/// Represents a customer-managed encryption key spec that can be applied to
/// a top-level resource.
final class EncryptionSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EncryptionSpec';

  /// Required. The Cloud KMS resource identifier of the customer managed
  /// encryption key used to protect a resource. Has the form:
  /// `projects/my-project/locations/my-region/keyRings/my-kr/cryptoKeys/my-key`.
  /// The key needs to be in the same region as where the compute resource is
  /// created.
  final String? kmsKeyName;

  EncryptionSpec({this.kmsKeyName}) : super(fullyQualifiedName);

  factory EncryptionSpec.fromJson(Map<String, dynamic> json) {
    return EncryptionSpec(kmsKeyName: json['kmsKeyName']);
  }

  @override
  Object toJson() {
    return {if (kmsKeyName != null) 'kmsKeyName': kmsKeyName};
  }

  @override
  String toString() {
    final contents = [
      if (kmsKeyName != null) 'kmsKeyName=$kmsKeyName',
    ].join(',');
    return 'EncryptionSpec($contents)';
  }
}

/// Models are deployed into it, and afterwards Endpoint is called to obtain
/// predictions and explanations.
final class Endpoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Endpoint';

  /// Output only. The resource name of the Endpoint.
  final String? name;

  /// Required. The display name of the Endpoint.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// The description of the Endpoint.
  final String? description;

  /// Output only. The models deployed in this Endpoint.
  /// To add or remove DeployedModels use
  /// `EndpointService.DeployModel`
  /// and
  /// `EndpointService.UndeployModel`
  /// respectively.
  final List<DeployedModel>? deployedModels;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If a DeployedModel's ID is not listed in this map, then it receives no
  /// traffic.
  ///
  /// The traffic percentage values must add up to 100, or map must be empty if
  /// the Endpoint is to not accept any traffic at a moment.
  final Map<String, int>? trafficSplit;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize your Endpoints.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Output only. Timestamp when this Endpoint was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Endpoint was last updated.
  final protobuf.Timestamp? updateTime;

  /// Customer-managed encryption key spec for an Endpoint. If set, this
  /// Endpoint and all sub-resources of this Endpoint will be secured by
  /// this key.
  final EncryptionSpec? encryptionSpec;

  /// Optional. The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  /// to which the Endpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If left
  /// unspecified, the Endpoint is not peered with any network.
  ///
  /// Only one of the fields,
  /// `network` or
  /// `enable_private_service_connect`,
  /// can be set.
  ///
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`.
  /// Where `{project}` is a project number, as in `12345`, and `{network}` is
  /// network name.
  final String? network;

  /// Deprecated: If true, expose the Endpoint via private service connect.
  ///
  /// Only one of the fields,
  /// `network` or
  /// `enable_private_service_connect`,
  /// can be set.
  final bool? enablePrivateServiceConnect;

  /// Optional. Configuration for private service connect.
  ///
  /// `network` and
  /// `private_service_connect_config`
  /// are mutually exclusive.
  final PrivateServiceConnectConfig? privateServiceConnectConfig;

  /// Output only. Resource name of the Model Monitoring job associated with this
  /// Endpoint if monitoring is enabled by
  /// `JobService.CreateModelDeploymentMonitoringJob`.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String? modelDeploymentMonitoringJob;

  /// Configures the request-response logging for online prediction.
  final PredictRequestResponseLoggingConfig?
  predictRequestResponseLoggingConfig;

  /// If true, the endpoint will be exposed through a dedicated
  /// DNS [Endpoint.dedicated_endpoint_dns]. Your request to the dedicated DNS
  /// will be isolated from other users' traffic and will have better performance
  /// and reliability.
  /// Note: Once you enabled dedicated endpoint, you won't be able to send
  /// request to the shared DNS {region}-aiplatform.googleapis.com. The
  /// limitation will be removed soon.
  final bool? dedicatedEndpointEnabled;

  /// Output only. DNS of the dedicated endpoint. Will only be populated if
  /// dedicated_endpoint_enabled is true. Depending on the features enabled, uid
  /// might be a random number or a string. For example, if fast_tryout is
  /// enabled, uid will be fasttryout. Format:
  /// `https://{endpoint_id}.{region}-{uid}.prediction.vertexai.goog`.
  final String? dedicatedEndpointDns;

  /// Configurations that are applied to the endpoint for online prediction.
  final ClientConnectionConfig? clientConnectionConfig;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  /// Optional. Configuration for GenAiAdvancedFeatures. If the endpoint is
  /// serving GenAI models, advanced features like native RAG integration can be
  /// configured. Currently, only Model Garden models are supported.
  final GenAiAdvancedFeaturesConfig? genAiAdvancedFeaturesConfig;

  /// If true, the model server will be isolated from the external internet.
  final bool? privateModelServerEnabled;

  Endpoint({
    this.name,
    this.displayName,
    this.description,
    this.deployedModels,
    this.trafficSplit,
    this.etag,
    this.labels,
    this.createTime,
    this.updateTime,
    this.encryptionSpec,
    this.network,
    this.enablePrivateServiceConnect,
    this.privateServiceConnectConfig,
    this.modelDeploymentMonitoringJob,
    this.predictRequestResponseLoggingConfig,
    this.dedicatedEndpointEnabled,
    this.dedicatedEndpointDns,
    this.clientConnectionConfig,
    this.satisfiesPzs,
    this.satisfiesPzi,
    this.genAiAdvancedFeaturesConfig,
    this.privateModelServerEnabled,
  }) : super(fullyQualifiedName);

  factory Endpoint.fromJson(Map<String, dynamic> json) {
    return Endpoint(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      deployedModels: decodeListMessage(
        json['deployedModels'],
        DeployedModel.fromJson,
      ),
      trafficSplit: decodeMap(json['trafficSplit']),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      network: json['network'],
      enablePrivateServiceConnect: json['enablePrivateServiceConnect'],
      privateServiceConnectConfig: decode(
        json['privateServiceConnectConfig'],
        PrivateServiceConnectConfig.fromJson,
      ),
      modelDeploymentMonitoringJob: json['modelDeploymentMonitoringJob'],
      predictRequestResponseLoggingConfig: decode(
        json['predictRequestResponseLoggingConfig'],
        PredictRequestResponseLoggingConfig.fromJson,
      ),
      dedicatedEndpointEnabled: json['dedicatedEndpointEnabled'],
      dedicatedEndpointDns: json['dedicatedEndpointDns'],
      clientConnectionConfig: decode(
        json['clientConnectionConfig'],
        ClientConnectionConfig.fromJson,
      ),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
      genAiAdvancedFeaturesConfig: decode(
        json['genAiAdvancedFeaturesConfig'],
        GenAiAdvancedFeaturesConfig.fromJson,
      ),
      privateModelServerEnabled: json['privateModelServerEnabled'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (deployedModels != null) 'deployedModels': encodeList(deployedModels),
      if (trafficSplit != null) 'trafficSplit': trafficSplit,
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (network != null) 'network': network,
      if (enablePrivateServiceConnect != null)
        'enablePrivateServiceConnect': enablePrivateServiceConnect,
      if (privateServiceConnectConfig != null)
        'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
      if (modelDeploymentMonitoringJob != null)
        'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob,
      if (predictRequestResponseLoggingConfig != null)
        'predictRequestResponseLoggingConfig':
            predictRequestResponseLoggingConfig!.toJson(),
      if (dedicatedEndpointEnabled != null)
        'dedicatedEndpointEnabled': dedicatedEndpointEnabled,
      if (dedicatedEndpointDns != null)
        'dedicatedEndpointDns': dedicatedEndpointDns,
      if (clientConnectionConfig != null)
        'clientConnectionConfig': clientConnectionConfig!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
      if (genAiAdvancedFeaturesConfig != null)
        'genAiAdvancedFeaturesConfig': genAiAdvancedFeaturesConfig!.toJson(),
      if (privateModelServerEnabled != null)
        'privateModelServerEnabled': privateModelServerEnabled,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (etag != null) 'etag=$etag',
      if (network != null) 'network=$network',
      if (enablePrivateServiceConnect != null)
        'enablePrivateServiceConnect=$enablePrivateServiceConnect',
      if (modelDeploymentMonitoringJob != null)
        'modelDeploymentMonitoringJob=$modelDeploymentMonitoringJob',
      if (dedicatedEndpointEnabled != null)
        'dedicatedEndpointEnabled=$dedicatedEndpointEnabled',
      if (dedicatedEndpointDns != null)
        'dedicatedEndpointDns=$dedicatedEndpointDns',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
      if (privateModelServerEnabled != null)
        'privateModelServerEnabled=$privateModelServerEnabled',
    ].join(',');
    return 'Endpoint($contents)';
  }
}

/// A deployment of a Model. Endpoints contain one or more DeployedModels.
final class DeployedModel extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedModel';

  /// A description of resources that are dedicated to the DeployedModel, and
  /// that need a higher degree of manual configuration.
  final DedicatedResources? dedicatedResources;

  /// A description of resources that to large degree are decided by Vertex
  /// AI, and require only a modest additional configuration.
  final AutomaticResources? automaticResources;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String? sharedResources;

  /// Immutable. The ID of the DeployedModel. If not provided upon deployment,
  /// Vertex AI will generate a value for this ID.
  ///
  /// This value should be 1-10 characters, and valid characters are `/[0-9]/`.
  final String? id;

  /// The resource name of the Model that this is the deployment of. Note that
  /// the Model may be in a different location than the DeployedModel's Endpoint.
  ///
  /// The resource name may contain version id or version alias to specify the
  /// version.
  ///  Example: `projects/{project}/locations/{location}/models/{model}@2`
  ///              or
  ///            `projects/{project}/locations/{location}/models/{model}@golden`
  /// if no version is specified, the default version will be deployed.
  final String? model;

  /// Output only. The version ID of the model that is deployed.
  final String? modelVersionId;

  /// The display name of the DeployedModel. If not provided upon creation,
  /// the Model's display_name is used.
  final String? displayName;

  /// Output only. Timestamp when the DeployedModel was created.
  final protobuf.Timestamp? createTime;

  /// Explanation configuration for this DeployedModel.
  ///
  /// When deploying a Model using
  /// `EndpointService.DeployModel`,
  /// this value overrides the value of
  /// `Model.explanation_spec`.
  /// All fields of
  /// `explanation_spec`
  /// are optional in the request. If a field of
  /// `explanation_spec`
  /// is not populated, the value of the same field of
  /// `Model.explanation_spec`
  /// is inherited. If the corresponding
  /// `Model.explanation_spec`
  /// is not populated, all fields of the
  /// `explanation_spec`
  /// will be used for the explanation configuration.
  final ExplanationSpec? explanationSpec;

  /// If true, deploy the model without explainable feature, regardless the
  /// existence of
  /// `Model.explanation_spec`
  /// or
  /// `explanation_spec`.
  final bool? disableExplanations;

  /// The service account that the DeployedModel's container runs as. Specify the
  /// email address of the service account. If this service account is not
  /// specified, the container runs as a service account that doesn't have access
  /// to the resource project.
  ///
  /// Users deploying the Model must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  final String? serviceAccount;

  /// If true, the container of the DeployedModel instances will send `stderr`
  /// and `stdout` streams to Cloud Logging.
  ///
  /// Only supported for custom-trained Models and AutoML Tabular Models.
  final bool? enableContainerLogging;

  /// For custom-trained Models and AutoML Tabular Models, the container of the
  /// DeployedModel instances will send `stderr` and `stdout` streams to
  /// Cloud Logging by default. Please note that the logs incur cost,
  /// which are subject to [Cloud Logging
  /// pricing](https://cloud.google.com/logging/pricing).
  ///
  /// User can disable container logging by setting this flag to true.
  final bool? disableContainerLogging;

  /// If true, online prediction access logs are sent to Cloud
  /// Logging.
  /// These logs are like standard server access logs, containing
  /// information like timestamp and latency for each prediction request.
  ///
  /// Note that logs may incur a cost, especially if your project
  /// receives prediction requests at a high queries per second rate (QPS).
  /// Estimate your costs before enabling this option.
  final bool? enableAccessLogging;

  /// Output only. Provide paths for users to send predict/explain/health
  /// requests directly to the deployed model services running on Cloud via
  /// private services access. This field is populated if
  /// `network` is configured.
  final PrivateEndpoints? privateEndpoints;

  /// Configuration for faster model deployment.
  final FasterDeploymentConfig? fasterDeploymentConfig;

  /// Options for configuring rolling deployments.
  final RolloutOptions? rolloutOptions;

  /// Output only. Runtime status of the deployed model.
  final DeployedModel_Status? status;

  /// System labels to apply to Model Garden deployments.
  /// System labels are managed by Google for internal use only.
  final Map<String, String>? systemLabels;

  /// The checkpoint id of the model.
  final String? checkpointId;

  /// Optional. Spec for configuring speculative decoding.
  final SpeculativeDecodingSpec? speculativeDecodingSpec;

  DeployedModel({
    this.dedicatedResources,
    this.automaticResources,
    this.sharedResources,
    this.id,
    this.model,
    this.modelVersionId,
    this.displayName,
    this.createTime,
    this.explanationSpec,
    this.disableExplanations,
    this.serviceAccount,
    this.enableContainerLogging,
    this.disableContainerLogging,
    this.enableAccessLogging,
    this.privateEndpoints,
    this.fasterDeploymentConfig,
    this.rolloutOptions,
    this.status,
    this.systemLabels,
    this.checkpointId,
    this.speculativeDecodingSpec,
  }) : super(fullyQualifiedName);

  factory DeployedModel.fromJson(Map<String, dynamic> json) {
    return DeployedModel(
      dedicatedResources: decode(
        json['dedicatedResources'],
        DedicatedResources.fromJson,
      ),
      automaticResources: decode(
        json['automaticResources'],
        AutomaticResources.fromJson,
      ),
      sharedResources: json['sharedResources'],
      id: json['id'],
      model: json['model'],
      modelVersionId: json['modelVersionId'],
      displayName: json['displayName'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      explanationSpec: decode(
        json['explanationSpec'],
        ExplanationSpec.fromJson,
      ),
      disableExplanations: json['disableExplanations'],
      serviceAccount: json['serviceAccount'],
      enableContainerLogging: json['enableContainerLogging'],
      disableContainerLogging: json['disableContainerLogging'],
      enableAccessLogging: json['enableAccessLogging'],
      privateEndpoints: decode(
        json['privateEndpoints'],
        PrivateEndpoints.fromJson,
      ),
      fasterDeploymentConfig: decode(
        json['fasterDeploymentConfig'],
        FasterDeploymentConfig.fromJson,
      ),
      rolloutOptions: decode(json['rolloutOptions'], RolloutOptions.fromJson),
      status: decode(json['status'], DeployedModel_Status.fromJson),
      systemLabels: decodeMap(json['systemLabels']),
      checkpointId: json['checkpointId'],
      speculativeDecodingSpec: decode(
        json['speculativeDecodingSpec'],
        SpeculativeDecodingSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dedicatedResources != null)
        'dedicatedResources': dedicatedResources!.toJson(),
      if (automaticResources != null)
        'automaticResources': automaticResources!.toJson(),
      if (sharedResources != null) 'sharedResources': sharedResources,
      if (id != null) 'id': id,
      if (model != null) 'model': model,
      if (modelVersionId != null) 'modelVersionId': modelVersionId,
      if (displayName != null) 'displayName': displayName,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
      if (disableExplanations != null)
        'disableExplanations': disableExplanations,
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (enableContainerLogging != null)
        'enableContainerLogging': enableContainerLogging,
      if (disableContainerLogging != null)
        'disableContainerLogging': disableContainerLogging,
      if (enableAccessLogging != null)
        'enableAccessLogging': enableAccessLogging,
      if (privateEndpoints != null)
        'privateEndpoints': privateEndpoints!.toJson(),
      if (fasterDeploymentConfig != null)
        'fasterDeploymentConfig': fasterDeploymentConfig!.toJson(),
      if (rolloutOptions != null) 'rolloutOptions': rolloutOptions!.toJson(),
      if (status != null) 'status': status!.toJson(),
      if (systemLabels != null) 'systemLabels': systemLabels,
      if (checkpointId != null) 'checkpointId': checkpointId,
      if (speculativeDecodingSpec != null)
        'speculativeDecodingSpec': speculativeDecodingSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (sharedResources != null) 'sharedResources=$sharedResources',
      if (id != null) 'id=$id',
      if (model != null) 'model=$model',
      if (modelVersionId != null) 'modelVersionId=$modelVersionId',
      if (displayName != null) 'displayName=$displayName',
      if (disableExplanations != null)
        'disableExplanations=$disableExplanations',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (enableContainerLogging != null)
        'enableContainerLogging=$enableContainerLogging',
      if (disableContainerLogging != null)
        'disableContainerLogging=$disableContainerLogging',
      if (enableAccessLogging != null)
        'enableAccessLogging=$enableAccessLogging',
      if (checkpointId != null) 'checkpointId=$checkpointId',
    ].join(',');
    return 'DeployedModel($contents)';
  }
}

/// Runtime status of the deployed model.
final class DeployedModel_Status extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedModel.Status';

  /// Output only. The latest deployed model's status message (if any).
  final String? message;

  /// Output only. The time at which the status was last updated.
  final protobuf.Timestamp? lastUpdateTime;

  /// Output only. The number of available replicas of the deployed model.
  final int? availableReplicaCount;

  DeployedModel_Status({
    this.message,
    this.lastUpdateTime,
    this.availableReplicaCount,
  }) : super(fullyQualifiedName);

  factory DeployedModel_Status.fromJson(Map<String, dynamic> json) {
    return DeployedModel_Status(
      message: json['message'],
      lastUpdateTime: decodeCustom(
        json['lastUpdateTime'],
        protobuf.Timestamp.fromJson,
      ),
      availableReplicaCount: json['availableReplicaCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (message != null) 'message': message,
      if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!.toJson(),
      if (availableReplicaCount != null)
        'availableReplicaCount': availableReplicaCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (message != null) 'message=$message',
      if (availableReplicaCount != null)
        'availableReplicaCount=$availableReplicaCount',
    ].join(',');
    return 'Status($contents)';
  }
}

/// PrivateEndpoints proto is used to provide paths for users to send
/// requests privately.
/// To send request via private service access, use predict_http_uri,
/// explain_http_uri or health_http_uri. To send request via private service
/// connect, use service_attachment.
final class PrivateEndpoints extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PrivateEndpoints';

  /// Output only. Http(s) path to send prediction requests.
  final String? predictHttpUri;

  /// Output only. Http(s) path to send explain requests.
  final String? explainHttpUri;

  /// Output only. Http(s) path to send health check requests.
  final String? healthHttpUri;

  /// Output only. The name of the service attachment resource. Populated if
  /// private service connect is enabled.
  final String? serviceAttachment;

  PrivateEndpoints({
    this.predictHttpUri,
    this.explainHttpUri,
    this.healthHttpUri,
    this.serviceAttachment,
  }) : super(fullyQualifiedName);

  factory PrivateEndpoints.fromJson(Map<String, dynamic> json) {
    return PrivateEndpoints(
      predictHttpUri: json['predictHttpUri'],
      explainHttpUri: json['explainHttpUri'],
      healthHttpUri: json['healthHttpUri'],
      serviceAttachment: json['serviceAttachment'],
    );
  }

  @override
  Object toJson() {
    return {
      if (predictHttpUri != null) 'predictHttpUri': predictHttpUri,
      if (explainHttpUri != null) 'explainHttpUri': explainHttpUri,
      if (healthHttpUri != null) 'healthHttpUri': healthHttpUri,
      if (serviceAttachment != null) 'serviceAttachment': serviceAttachment,
    };
  }

  @override
  String toString() {
    final contents = [
      if (predictHttpUri != null) 'predictHttpUri=$predictHttpUri',
      if (explainHttpUri != null) 'explainHttpUri=$explainHttpUri',
      if (healthHttpUri != null) 'healthHttpUri=$healthHttpUri',
      if (serviceAttachment != null) 'serviceAttachment=$serviceAttachment',
    ].join(',');
    return 'PrivateEndpoints($contents)';
  }
}

/// Configuration for logging request-response to a BigQuery table.
final class PredictRequestResponseLoggingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictRequestResponseLoggingConfig';

  /// If logging is enabled or not.
  final bool? enabled;

  /// Percentage of requests to be logged, expressed as a fraction in
  /// range(0,1].
  final double? samplingRate;

  /// BigQuery table for logging.
  /// If only given a project, a new dataset will be created with name
  /// `logging_<endpoint-display-name>_<endpoint-id>` where
  /// <endpoint-display-name> will be made BigQuery-dataset-name compatible (e.g.
  /// most special characters will become underscores). If no table name is
  /// given, a new table will be created with name `request_response_logging`
  final BigQueryDestination? bigqueryDestination;

  /// Output only. The schema version used in creating the BigQuery table for the
  /// request response logging. The versions are "v1" and "v2". The current
  /// default version is "v1".
  final String? requestResponseLoggingSchemaVersion;

  /// This field is used for large models. If true, in addition to the
  /// original large model logs, logs will be converted in OTel schema format,
  /// and saved in otel_log column. Default value is false.
  final bool? enableOtelLogging;

  PredictRequestResponseLoggingConfig({
    this.enabled,
    this.samplingRate,
    this.bigqueryDestination,
    this.requestResponseLoggingSchemaVersion,
    this.enableOtelLogging,
  }) : super(fullyQualifiedName);

  factory PredictRequestResponseLoggingConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return PredictRequestResponseLoggingConfig(
      enabled: json['enabled'],
      samplingRate: decodeDouble(json['samplingRate']),
      bigqueryDestination: decode(
        json['bigqueryDestination'],
        BigQueryDestination.fromJson,
      ),
      requestResponseLoggingSchemaVersion:
          json['requestResponseLoggingSchemaVersion'],
      enableOtelLogging: json['enableOtelLogging'],
    );
  }

  @override
  Object toJson() {
    return {
      if (enabled != null) 'enabled': enabled,
      if (samplingRate != null) 'samplingRate': encodeDouble(samplingRate),
      if (bigqueryDestination != null)
        'bigqueryDestination': bigqueryDestination!.toJson(),
      if (requestResponseLoggingSchemaVersion != null)
        'requestResponseLoggingSchemaVersion':
            requestResponseLoggingSchemaVersion,
      if (enableOtelLogging != null) 'enableOtelLogging': enableOtelLogging,
    };
  }

  @override
  String toString() {
    final contents = [
      if (enabled != null) 'enabled=$enabled',
      if (samplingRate != null) 'samplingRate=$samplingRate',
      if (requestResponseLoggingSchemaVersion != null)
        'requestResponseLoggingSchemaVersion=$requestResponseLoggingSchemaVersion',
      if (enableOtelLogging != null) 'enableOtelLogging=$enableOtelLogging',
    ].join(',');
    return 'PredictRequestResponseLoggingConfig($contents)';
  }
}

/// This message contains configs of a publisher model.
final class PublisherModelConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModelConfig';

  /// The prediction request/response logging config.
  final PredictRequestResponseLoggingConfig? loggingConfig;

  PublisherModelConfig({this.loggingConfig}) : super(fullyQualifiedName);

  factory PublisherModelConfig.fromJson(Map<String, dynamic> json) {
    return PublisherModelConfig(
      loggingConfig: decode(
        json['loggingConfig'],
        PredictRequestResponseLoggingConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (loggingConfig != null) 'loggingConfig': loggingConfig!.toJson(),
    };
  }

  @override
  String toString() => 'PublisherModelConfig()';
}

/// Configurations (e.g. inference timeout) that are applied on your endpoints.
final class ClientConnectionConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ClientConnectionConfig';

  /// Customizable online prediction request timeout.
  final protobuf.Duration? inferenceTimeout;

  ClientConnectionConfig({this.inferenceTimeout}) : super(fullyQualifiedName);

  factory ClientConnectionConfig.fromJson(Map<String, dynamic> json) {
    return ClientConnectionConfig(
      inferenceTimeout: decodeCustom(
        json['inferenceTimeout'],
        protobuf.Duration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (inferenceTimeout != null)
        'inferenceTimeout': inferenceTimeout!.toJson(),
    };
  }

  @override
  String toString() => 'ClientConnectionConfig()';
}

/// Configuration for faster model deployment.
final class FasterDeploymentConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FasterDeploymentConfig';

  /// If true, enable fast tryout feature for this deployed model.
  final bool? fastTryoutEnabled;

  FasterDeploymentConfig({this.fastTryoutEnabled}) : super(fullyQualifiedName);

  factory FasterDeploymentConfig.fromJson(Map<String, dynamic> json) {
    return FasterDeploymentConfig(fastTryoutEnabled: json['fastTryoutEnabled']);
  }

  @override
  Object toJson() {
    return {
      if (fastTryoutEnabled != null) 'fastTryoutEnabled': fastTryoutEnabled,
    };
  }

  @override
  String toString() {
    final contents = [
      if (fastTryoutEnabled != null) 'fastTryoutEnabled=$fastTryoutEnabled',
    ].join(',');
    return 'FasterDeploymentConfig($contents)';
  }
}

/// Configuration for rolling deployments.
final class RolloutOptions extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RolloutOptions';

  /// Absolute count of replicas allowed to be unavailable.
  final int? maxUnavailableReplicas;

  /// Percentage of replicas allowed to be unavailable.
  /// For autoscaling deployments, this refers to the target replica count.
  final int? maxUnavailablePercentage;

  /// Absolute count of allowed additional replicas.
  final int? maxSurgeReplicas;

  /// Percentage of allowed additional replicas.
  /// For autoscaling deployments, this refers to the target replica count.
  final int? maxSurgePercentage;

  /// ID of the DeployedModel that this deployment should replace.
  final String? previousDeployedModel;

  /// Output only. Read-only. Revision number determines the relative priority of
  /// DeployedModels in the same rollout. The DeployedModel with the largest
  /// revision number specifies the intended state of the deployment.
  final int? revisionNumber;

  RolloutOptions({
    this.maxUnavailableReplicas,
    this.maxUnavailablePercentage,
    this.maxSurgeReplicas,
    this.maxSurgePercentage,
    this.previousDeployedModel,
    this.revisionNumber,
  }) : super(fullyQualifiedName);

  factory RolloutOptions.fromJson(Map<String, dynamic> json) {
    return RolloutOptions(
      maxUnavailableReplicas: json['maxUnavailableReplicas'],
      maxUnavailablePercentage: json['maxUnavailablePercentage'],
      maxSurgeReplicas: json['maxSurgeReplicas'],
      maxSurgePercentage: json['maxSurgePercentage'],
      previousDeployedModel: json['previousDeployedModel'],
      revisionNumber: json['revisionNumber'],
    );
  }

  @override
  Object toJson() {
    return {
      if (maxUnavailableReplicas != null)
        'maxUnavailableReplicas': maxUnavailableReplicas,
      if (maxUnavailablePercentage != null)
        'maxUnavailablePercentage': maxUnavailablePercentage,
      if (maxSurgeReplicas != null) 'maxSurgeReplicas': maxSurgeReplicas,
      if (maxSurgePercentage != null) 'maxSurgePercentage': maxSurgePercentage,
      if (previousDeployedModel != null)
        'previousDeployedModel': previousDeployedModel,
      if (revisionNumber != null) 'revisionNumber': revisionNumber,
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxUnavailableReplicas != null)
        'maxUnavailableReplicas=$maxUnavailableReplicas',
      if (maxUnavailablePercentage != null)
        'maxUnavailablePercentage=$maxUnavailablePercentage',
      if (maxSurgeReplicas != null) 'maxSurgeReplicas=$maxSurgeReplicas',
      if (maxSurgePercentage != null) 'maxSurgePercentage=$maxSurgePercentage',
      if (previousDeployedModel != null)
        'previousDeployedModel=$previousDeployedModel',
      if (revisionNumber != null) 'revisionNumber=$revisionNumber',
    ].join(',');
    return 'RolloutOptions($contents)';
  }
}

/// Configuration for GenAiAdvancedFeatures.
final class GenAiAdvancedFeaturesConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenAiAdvancedFeaturesConfig';

  /// Configuration for Retrieval Augmented Generation feature.
  final GenAiAdvancedFeaturesConfig_RagConfig? ragConfig;

  GenAiAdvancedFeaturesConfig({this.ragConfig}) : super(fullyQualifiedName);

  factory GenAiAdvancedFeaturesConfig.fromJson(Map<String, dynamic> json) {
    return GenAiAdvancedFeaturesConfig(
      ragConfig: decode(
        json['ragConfig'],
        GenAiAdvancedFeaturesConfig_RagConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (ragConfig != null) 'ragConfig': ragConfig!.toJson()};
  }

  @override
  String toString() => 'GenAiAdvancedFeaturesConfig()';
}

/// Configuration for Retrieval Augmented Generation feature.
final class GenAiAdvancedFeaturesConfig_RagConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenAiAdvancedFeaturesConfig.RagConfig';

  /// If true, enable Retrieval Augmented Generation in ChatCompletion request.
  /// Once enabled, the endpoint will be identified as GenAI endpoint and
  /// Arthedain router will be used.
  final bool? enableRag;

  GenAiAdvancedFeaturesConfig_RagConfig({this.enableRag})
    : super(fullyQualifiedName);

  factory GenAiAdvancedFeaturesConfig_RagConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenAiAdvancedFeaturesConfig_RagConfig(enableRag: json['enableRag']);
  }

  @override
  Object toJson() {
    return {if (enableRag != null) 'enableRag': enableRag};
  }

  @override
  String toString() {
    final contents = [if (enableRag != null) 'enableRag=$enableRag'].join(',');
    return 'RagConfig($contents)';
  }
}

/// Configuration for Speculative Decoding.
final class SpeculativeDecodingSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpeculativeDecodingSpec';

  /// draft model speculation.
  final SpeculativeDecodingSpec_DraftModelSpeculation? draftModelSpeculation;

  /// N-Gram speculation.
  final SpeculativeDecodingSpec_NgramSpeculation? ngramSpeculation;

  /// The number of speculative tokens to generate at each step.
  final int? speculativeTokenCount;

  SpeculativeDecodingSpec({
    this.draftModelSpeculation,
    this.ngramSpeculation,
    this.speculativeTokenCount,
  }) : super(fullyQualifiedName);

  factory SpeculativeDecodingSpec.fromJson(Map<String, dynamic> json) {
    return SpeculativeDecodingSpec(
      draftModelSpeculation: decode(
        json['draftModelSpeculation'],
        SpeculativeDecodingSpec_DraftModelSpeculation.fromJson,
      ),
      ngramSpeculation: decode(
        json['ngramSpeculation'],
        SpeculativeDecodingSpec_NgramSpeculation.fromJson,
      ),
      speculativeTokenCount: json['speculativeTokenCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (draftModelSpeculation != null)
        'draftModelSpeculation': draftModelSpeculation!.toJson(),
      if (ngramSpeculation != null)
        'ngramSpeculation': ngramSpeculation!.toJson(),
      if (speculativeTokenCount != null)
        'speculativeTokenCount': speculativeTokenCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (speculativeTokenCount != null)
        'speculativeTokenCount=$speculativeTokenCount',
    ].join(',');
    return 'SpeculativeDecodingSpec($contents)';
  }
}

/// Draft model speculation works by using the smaller model to generate
/// candidate tokens for speculative decoding.
final class SpeculativeDecodingSpec_DraftModelSpeculation
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpeculativeDecodingSpec.DraftModelSpeculation';

  /// Required. The resource name of the draft model.
  final String? draftModel;

  SpeculativeDecodingSpec_DraftModelSpeculation({this.draftModel})
    : super(fullyQualifiedName);

  factory SpeculativeDecodingSpec_DraftModelSpeculation.fromJson(
    Map<String, dynamic> json,
  ) {
    return SpeculativeDecodingSpec_DraftModelSpeculation(
      draftModel: json['draftModel'],
    );
  }

  @override
  Object toJson() {
    return {if (draftModel != null) 'draftModel': draftModel};
  }

  @override
  String toString() {
    final contents = [
      if (draftModel != null) 'draftModel=$draftModel',
    ].join(',');
    return 'DraftModelSpeculation($contents)';
  }
}

/// N-Gram speculation works by trying to find matching tokens in the
/// previous prompt sequence and use those as speculation for generating
/// new tokens.
final class SpeculativeDecodingSpec_NgramSpeculation
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpeculativeDecodingSpec.NgramSpeculation';

  /// The number of last N input tokens used as ngram to search/match
  /// against the previous prompt sequence.
  /// This is equal to the N in N-Gram.
  /// The default value is 3 if not specified.
  final int? ngramSize;

  SpeculativeDecodingSpec_NgramSpeculation({this.ngramSize})
    : super(fullyQualifiedName);

  factory SpeculativeDecodingSpec_NgramSpeculation.fromJson(
    Map<String, dynamic> json,
  ) {
    return SpeculativeDecodingSpec_NgramSpeculation(
      ngramSize: json['ngramSize'],
    );
  }

  @override
  Object toJson() {
    return {if (ngramSize != null) 'ngramSize': ngramSize};
  }

  @override
  String toString() {
    final contents = [if (ngramSize != null) 'ngramSize=$ngramSize'].join(',');
    return 'NgramSpeculation($contents)';
  }
}

/// Request message for
/// `EndpointService.CreateEndpoint`.
final class CreateEndpointRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateEndpointRequest';

  /// Required. The resource name of the Location to create the Endpoint in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Endpoint to create.
  final Endpoint endpoint;

  /// Immutable. The ID to use for endpoint, which will become the final
  /// component of the endpoint resource name.
  /// If not provided, Vertex AI will generate a value for this ID.
  ///
  /// If the first character is a letter, this value may be up to 63 characters,
  /// and valid characters are `[a-z0-9-]`. The last character must be a letter
  /// or number.
  ///
  /// If the first character is a number, this value may be up to 9 characters,
  /// and valid characters are `[0-9]` with no leading zeros.
  ///
  /// When using HTTP/JSON, this field is populated
  /// based on a query string argument, such as `?endpoint_id=12345`. This is the
  /// fallback for fields that are not included in either the URI or the body.
  final String? endpointId;

  CreateEndpointRequest({
    required this.parent,
    required this.endpoint,
    this.endpointId,
  }) : super(fullyQualifiedName);

  factory CreateEndpointRequest.fromJson(Map<String, dynamic> json) {
    return CreateEndpointRequest(
      parent: json['parent'],
      endpoint: decode(json['endpoint'], Endpoint.fromJson)!,
      endpointId: json['endpointId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'endpoint': endpoint.toJson(),
      if (endpointId != null) 'endpointId': endpointId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (endpointId != null) 'endpointId=$endpointId',
    ].join(',');
    return 'CreateEndpointRequest($contents)';
  }
}

/// Runtime operation information for
/// `EndpointService.CreateEndpoint`.
final class CreateEndpointOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateEndpointOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. The deployment stage of the model. Only populated if this
  /// CreateEndpoint request deploys a model at the same time.
  final DeploymentStage? deploymentStage;

  CreateEndpointOperationMetadata({this.genericMetadata, this.deploymentStage})
    : super(fullyQualifiedName);

  factory CreateEndpointOperationMetadata.fromJson(Map<String, dynamic> json) {
    return CreateEndpointOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      deploymentStage: decodeEnum(
        json['deploymentStage'],
        DeploymentStage.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (deploymentStage != null) 'deploymentStage': deploymentStage!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (deploymentStage != null) 'deploymentStage=$deploymentStage',
    ].join(',');
    return 'CreateEndpointOperationMetadata($contents)';
  }
}

/// Request message for
/// `EndpointService.GetEndpoint`
final class GetEndpointRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetEndpointRequest';

  /// Required. The name of the Endpoint resource.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String name;

  GetEndpointRequest({required this.name}) : super(fullyQualifiedName);

  factory GetEndpointRequest.fromJson(Map<String, dynamic> json) {
    return GetEndpointRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetEndpointRequest($contents)';
  }
}

/// Request message for
/// `EndpointService.ListEndpoints`.
final class ListEndpointsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEndpointsRequest';

  /// Required. The resource name of the Location from which to list the
  /// Endpoints. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `endpoint` supports `=` and `!=`. `endpoint` represents the Endpoint
  ///     ID, i.e. the last segment of the Endpoint's
  ///     [resource name][google.cloud.aiplatform.v1beta1.Endpoint.name].
  ///   * `display_name` supports `=` and `!=`.
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:*` or `labels:key` - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///   * `base_model_name` only supports `=`.
  ///
  /// Some examples:
  ///
  ///   * `endpoint=1`
  ///   * `displayName="myDisplayName"`
  ///   * `labels.myKey="myValue"`
  ///   * `baseModelName="text-bison"`
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListEndpointsResponse.next_page_token`
  /// of the previous
  /// `EndpointService.ListEndpoints`
  /// call.
  final String? pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListEndpointsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListEndpointsRequest.fromJson(Map<String, dynamic> json) {
    return ListEndpointsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListEndpointsRequest($contents)';
  }
}

/// Response message for
/// `EndpointService.ListEndpoints`.
final class ListEndpointsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEndpointsResponse';

  /// List of Endpoints in the requested page.
  final List<Endpoint>? endpoints;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListEndpointsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListEndpointsResponse({this.endpoints, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListEndpointsResponse.fromJson(Map<String, dynamic> json) {
    return ListEndpointsResponse(
      endpoints: decodeListMessage(json['endpoints'], Endpoint.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (endpoints != null) 'endpoints': encodeList(endpoints),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListEndpointsResponse($contents)';
  }
}

/// Request message for
/// `EndpointService.UpdateEndpoint`.
final class UpdateEndpointRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateEndpointRequest';

  /// Required. The Endpoint which replaces the resource on the server.
  final Endpoint endpoint;

  /// Required. The update mask applies to the resource. See
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateEndpointRequest({required this.endpoint, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateEndpointRequest.fromJson(Map<String, dynamic> json) {
    return UpdateEndpointRequest(
      endpoint: decode(json['endpoint'], Endpoint.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateEndpointRequest()';
}

/// Request message for
/// `EndpointService.UpdateEndpointLongRunning`.
final class UpdateEndpointLongRunningRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateEndpointLongRunningRequest';

  /// Required. The Endpoint which replaces the resource on the server. Currently
  /// we only support updating the `client_connection_config` field, all the
  /// other fields' update will be blocked.
  final Endpoint endpoint;

  UpdateEndpointLongRunningRequest({required this.endpoint})
    : super(fullyQualifiedName);

  factory UpdateEndpointLongRunningRequest.fromJson(Map<String, dynamic> json) {
    return UpdateEndpointLongRunningRequest(
      endpoint: decode(json['endpoint'], Endpoint.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'endpoint': endpoint.toJson()};
  }

  @override
  String toString() => 'UpdateEndpointLongRunningRequest()';
}

/// Runtime operation information for
/// `EndpointService.UpdateEndpointLongRunning`.
final class UpdateEndpointOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateEndpointOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateEndpointOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateEndpointOperationMetadata.fromJson(Map<String, dynamic> json) {
    return UpdateEndpointOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateEndpointOperationMetadata()';
}

/// Request message for
/// `EndpointService.DeleteEndpoint`.
final class DeleteEndpointRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteEndpointRequest';

  /// Required. The name of the Endpoint resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String name;

  DeleteEndpointRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteEndpointRequest.fromJson(Map<String, dynamic> json) {
    return DeleteEndpointRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteEndpointRequest($contents)';
  }
}

/// Request message for
/// `EndpointService.DeployModel`.
final class DeployModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployModelRequest';

  /// Required. The name of the Endpoint resource into which to deploy a Model.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The DeployedModel to be created within the Endpoint. Note that
  /// `Endpoint.traffic_split`
  /// must be updated for the DeployedModel to start receiving traffic, either as
  /// part of this call, or via
  /// `EndpointService.UpdateEndpoint`.
  final DeployedModel? deployedModel;

  /// A map from a DeployedModel's ID to the percentage of this Endpoint's
  /// traffic that should be forwarded to that DeployedModel.
  ///
  /// If this field is non-empty, then the Endpoint's
  /// `traffic_split`
  /// will be overwritten with it. To refer to the ID of the just being deployed
  /// Model, a "0" should be used, and the actual ID of the new DeployedModel
  /// will be filled in its place by this method. The traffic percentage values
  /// must add up to 100.
  ///
  /// If this field is empty, then the Endpoint's
  /// `traffic_split` is
  /// not updated.
  final Map<String, int>? trafficSplit;

  DeployModelRequest({
    required this.endpoint,
    this.deployedModel,
    this.trafficSplit,
  }) : super(fullyQualifiedName);

  factory DeployModelRequest.fromJson(Map<String, dynamic> json) {
    return DeployModelRequest(
      endpoint: json['endpoint'],
      deployedModel: decode(json['deployedModel'], DeployedModel.fromJson),
      trafficSplit: decodeMap(json['trafficSplit']),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (deployedModel != null) 'deployedModel': deployedModel!.toJson(),
      if (trafficSplit != null) 'trafficSplit': trafficSplit,
    };
  }

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'DeployModelRequest($contents)';
  }
}

/// Response message for
/// `EndpointService.DeployModel`.
final class DeployModelResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployModelResponse';

  /// The DeployedModel that had been deployed in the Endpoint.
  final DeployedModel? deployedModel;

  DeployModelResponse({this.deployedModel}) : super(fullyQualifiedName);

  factory DeployModelResponse.fromJson(Map<String, dynamic> json) {
    return DeployModelResponse(
      deployedModel: decode(json['deployedModel'], DeployedModel.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (deployedModel != null) 'deployedModel': deployedModel!.toJson(),
    };
  }

  @override
  String toString() => 'DeployModelResponse()';
}

/// Runtime operation information for
/// `EndpointService.DeployModel`.
final class DeployModelOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. The deployment stage of the model.
  final DeploymentStage? deploymentStage;

  DeployModelOperationMetadata({this.genericMetadata, this.deploymentStage})
    : super(fullyQualifiedName);

  factory DeployModelOperationMetadata.fromJson(Map<String, dynamic> json) {
    return DeployModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      deploymentStage: decodeEnum(
        json['deploymentStage'],
        DeploymentStage.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (deploymentStage != null) 'deploymentStage': deploymentStage!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (deploymentStage != null) 'deploymentStage=$deploymentStage',
    ].join(',');
    return 'DeployModelOperationMetadata($contents)';
  }
}

/// Request message for
/// `EndpointService.UndeployModel`.
final class UndeployModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployModelRequest';

  /// Required. The name of the Endpoint resource from which to undeploy a Model.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The ID of the DeployedModel to be undeployed from the Endpoint.
  final String? deployedModelId;

  /// If this field is provided, then the Endpoint's
  /// `traffic_split`
  /// will be overwritten with it. If last DeployedModel is being undeployed from
  /// the Endpoint, the [Endpoint.traffic_split] will always end up empty when
  /// this call returns. A DeployedModel will be successfully undeployed only if
  /// it doesn't have any traffic assigned to it when this method executes, or if
  /// this field unassigns any traffic to it.
  final Map<String, int>? trafficSplit;

  UndeployModelRequest({
    required this.endpoint,
    this.deployedModelId,
    this.trafficSplit,
  }) : super(fullyQualifiedName);

  factory UndeployModelRequest.fromJson(Map<String, dynamic> json) {
    return UndeployModelRequest(
      endpoint: json['endpoint'],
      deployedModelId: json['deployedModelId'],
      trafficSplit: decodeMap(json['trafficSplit']),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (deployedModelId != null) 'deployedModelId': deployedModelId,
      if (trafficSplit != null) 'trafficSplit': trafficSplit,
    };
  }

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      if (deployedModelId != null) 'deployedModelId=$deployedModelId',
    ].join(',');
    return 'UndeployModelRequest($contents)';
  }
}

/// Response message for
/// `EndpointService.UndeployModel`.
final class UndeployModelResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployModelResponse';

  UndeployModelResponse() : super(fullyQualifiedName);

  factory UndeployModelResponse.fromJson(Map<String, dynamic> json) {
    return UndeployModelResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'UndeployModelResponse()';
}

/// Request message for
/// `EndpointService.SetPublisherModelConfig`.
final class SetPublisherModelConfigRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SetPublisherModelConfigRequest';

  /// Required. The name of the publisher model, in the format of
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`.
  final String name;

  /// Required. The publisher model config.
  final PublisherModelConfig? publisherModelConfig;

  SetPublisherModelConfigRequest({
    required this.name,
    this.publisherModelConfig,
  }) : super(fullyQualifiedName);

  factory SetPublisherModelConfigRequest.fromJson(Map<String, dynamic> json) {
    return SetPublisherModelConfigRequest(
      name: json['name'],
      publisherModelConfig: decode(
        json['publisherModelConfig'],
        PublisherModelConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (publisherModelConfig != null)
        'publisherModelConfig': publisherModelConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'SetPublisherModelConfigRequest($contents)';
  }
}

/// Runtime operation information for
/// `EndpointService.SetPublisherModelConfig`.
final class SetPublisherModelConfigOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SetPublisherModelConfigOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  SetPublisherModelConfigOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory SetPublisherModelConfigOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return SetPublisherModelConfigOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'SetPublisherModelConfigOperationMetadata()';
}

/// Request message for
/// `EndpointService.FetchPublisherModelConfig`.
final class FetchPublisherModelConfigRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchPublisherModelConfigRequest';

  /// Required. The name of the publisher model, in the format of
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`.
  final String name;

  FetchPublisherModelConfigRequest({required this.name})
    : super(fullyQualifiedName);

  factory FetchPublisherModelConfigRequest.fromJson(Map<String, dynamic> json) {
    return FetchPublisherModelConfigRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'FetchPublisherModelConfigRequest($contents)';
  }
}

/// Runtime operation information for
/// `EndpointService.UndeployModel`.
final class UndeployModelOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UndeployModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UndeployModelOperationMetadata.fromJson(Map<String, dynamic> json) {
    return UndeployModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UndeployModelOperationMetadata()';
}

/// Request message for
/// `EndpointService.MutateDeployedModel`.
final class MutateDeployedModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedModelRequest';

  /// Required. The name of the Endpoint resource into which to mutate a
  /// DeployedModel. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The DeployedModel to be mutated within the Endpoint. Only the
  /// following fields can be mutated:
  ///
  /// * `min_replica_count` in either
  /// `DedicatedResources` or
  /// `AutomaticResources`
  /// * `max_replica_count` in either
  /// `DedicatedResources` or
  /// `AutomaticResources`
  /// * `required_replica_count` in
  /// `DedicatedResources`
  /// * `autoscaling_metric_specs`
  /// * `disable_container_logging` (v1 only)
  /// * `enable_container_logging` (v1beta1 only)
  final DeployedModel? deployedModel;

  /// Required. The update mask applies to the resource. See
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  MutateDeployedModelRequest({
    required this.endpoint,
    this.deployedModel,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory MutateDeployedModelRequest.fromJson(Map<String, dynamic> json) {
    return MutateDeployedModelRequest(
      endpoint: json['endpoint'],
      deployedModel: decode(json['deployedModel'], DeployedModel.fromJson),
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (deployedModel != null) 'deployedModel': deployedModel!.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'MutateDeployedModelRequest($contents)';
  }
}

/// Response message for
/// `EndpointService.MutateDeployedModel`.
final class MutateDeployedModelResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedModelResponse';

  /// The DeployedModel that's being mutated.
  final DeployedModel? deployedModel;

  MutateDeployedModelResponse({this.deployedModel}) : super(fullyQualifiedName);

  factory MutateDeployedModelResponse.fromJson(Map<String, dynamic> json) {
    return MutateDeployedModelResponse(
      deployedModel: decode(json['deployedModel'], DeployedModel.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (deployedModel != null) 'deployedModel': deployedModel!.toJson(),
    };
  }

  @override
  String toString() => 'MutateDeployedModelResponse()';
}

/// Runtime operation information for
/// `EndpointService.MutateDeployedModel`.
final class MutateDeployedModelOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  MutateDeployedModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory MutateDeployedModelOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return MutateDeployedModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'MutateDeployedModelOperationMetadata()';
}

/// An entity type is a type of object in a system that needs to be modeled and
/// have stored information about. For example, driver is an entity type, and
/// driver0 is an instance of an entity type driver.
final class EntityType extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EntityType';

  /// Immutable. Name of the EntityType.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  ///
  /// The last part entity_type is assigned by the client. The entity_type can be
  /// up to 64 characters long and can consist only of ASCII Latin letters A-Z
  /// and a-z and underscore(_), and ASCII digits 0-9 starting with a letter. The
  /// value will be unique given a featurestore.
  final String? name;

  /// Optional. Description of the EntityType.
  final String? description;

  /// Output only. Timestamp when this EntityType was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this EntityType was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The labels with user-defined metadata to organize your
  /// EntityTypes.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one EntityType (System
  /// labels are excluded)."
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? labels;

  /// Optional. Used to perform a consistent read-modify-write updates. If not
  /// set, a blind "overwrite" update happens.
  final String? etag;

  /// Optional. The default monitoring configuration for all Features with value
  /// type
  /// (`Feature.ValueType`)
  /// BOOL, STRING, DOUBLE or INT64 under this EntityType.
  ///
  /// If this is populated with
  /// [FeaturestoreMonitoringConfig.monitoring_interval] specified, snapshot
  /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring is
  /// disabled.
  final FeaturestoreMonitoringConfig? monitoringConfig;

  /// Optional. Config for data retention policy in offline storage.
  /// TTL in days for feature values that will be stored in offline storage.
  /// The Feature Store offline storage periodically removes obsolete feature
  /// values older than `offline_storage_ttl_days` since the feature generation
  /// time. If unset (or explicitly set to 0), default to 4000 days TTL.
  final int? offlineStorageTtlDays;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  EntityType({
    this.name,
    this.description,
    this.createTime,
    this.updateTime,
    this.labels,
    this.etag,
    this.monitoringConfig,
    this.offlineStorageTtlDays,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory EntityType.fromJson(Map<String, dynamic> json) {
    return EntityType(
      name: json['name'],
      description: json['description'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      etag: json['etag'],
      monitoringConfig: decode(
        json['monitoringConfig'],
        FeaturestoreMonitoringConfig.fromJson,
      ),
      offlineStorageTtlDays: json['offlineStorageTtlDays'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (etag != null) 'etag': etag,
      if (monitoringConfig != null)
        'monitoringConfig': monitoringConfig!.toJson(),
      if (offlineStorageTtlDays != null)
        'offlineStorageTtlDays': offlineStorageTtlDays,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
      if (etag != null) 'etag=$etag',
      if (offlineStorageTtlDays != null)
        'offlineStorageTtlDays=$offlineStorageTtlDays',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'EntityType($contents)';
  }
}

/// Represents an environment variable present in a Container or Python Module.
final class EnvVar extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EnvVar';

  /// Required. Name of the environment variable. Must be a valid C identifier.
  final String? name;

  /// Required. Variables that reference a $(VAR_NAME) are expanded
  /// using the previous defined environment variables in the container and
  /// any service environment variables. If a variable cannot be resolved,
  /// the reference in the input string will be unchanged. The $(VAR_NAME)
  /// syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  /// references will never be expanded, regardless of whether the variable
  /// exists or not.
  final String? value;

  EnvVar({this.name, this.value}) : super(fullyQualifiedName);

  factory EnvVar.fromJson(Map<String, dynamic> json) {
    return EnvVar(name: json['name'], value: json['value']);
  }

  @override
  Object toJson() {
    return {if (name != null) 'name': name, if (value != null) 'value': value};
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (value != null) 'value=$value',
    ].join(',');
    return 'EnvVar($contents)';
  }
}

/// Reference to a secret stored in the Cloud Secret Manager that will
/// provide the value for this environment variable.
final class SecretRef extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SecretRef';

  /// Required. The name of the secret in Cloud Secret Manager.
  /// Format: {secret_name}.
  final String? secret;

  /// The Cloud Secret Manager secret version.
  /// Can be 'latest' for the latest version, an integer for a specific
  /// version, or a version alias.
  final String? version;

  SecretRef({this.secret, this.version}) : super(fullyQualifiedName);

  factory SecretRef.fromJson(Map<String, dynamic> json) {
    return SecretRef(secret: json['secret'], version: json['version']);
  }

  @override
  Object toJson() {
    return {
      if (secret != null) 'secret': secret,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (secret != null) 'secret=$secret',
      if (version != null) 'version=$version',
    ].join(',');
    return 'SecretRef($contents)';
  }
}

/// Represents an environment variable where the value is a secret in Cloud
/// Secret Manager.
final class SecretEnvVar extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SecretEnvVar';

  /// Required. Name of the secret environment variable.
  final String? name;

  /// Required. Reference to a secret stored in the Cloud Secret Manager that
  /// will provide the value for this environment variable.
  final SecretRef? secretRef;

  SecretEnvVar({this.name, this.secretRef}) : super(fullyQualifiedName);

  factory SecretEnvVar.fromJson(Map<String, dynamic> json) {
    return SecretEnvVar(
      name: json['name'],
      secretRef: decode(json['secretRef'], SecretRef.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (secretRef != null) 'secretRef': secretRef!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (name != null) 'name=$name'].join(',');
    return 'SecretEnvVar($contents)';
  }
}

/// True positive, false positive, or false negative.
///
/// EvaluatedAnnotation is only available under ModelEvaluationSlice with slice
/// of `annotationSpec` dimension.
final class EvaluatedAnnotation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluatedAnnotation';

  /// Output only. Type of the EvaluatedAnnotation.
  final EvaluatedAnnotation_EvaluatedAnnotationType? type;

  /// Output only. The model predicted annotations.
  ///
  /// For true positive, there is one and only one prediction, which matches the
  /// only one ground truth annotation in
  /// `ground_truths`.
  ///
  /// For false positive, there is one and only one prediction, which doesn't
  /// match any ground truth annotation of the corresponding
  /// `data_item_view_id`.
  ///
  /// For false negative, there are zero or more predictions which are similar to
  /// the only ground truth annotation in
  /// `ground_truths`
  /// but not enough for a match.
  ///
  /// The schema of the prediction is stored in
  /// `ModelEvaluation.annotation_schema_uri`
  final List<protobuf.Value>? predictions;

  /// Output only. The ground truth Annotations, i.e. the Annotations that exist
  /// in the test data the Model is evaluated on.
  ///
  /// For true positive, there is one and only one ground truth annotation, which
  /// matches the only prediction in
  /// `predictions`.
  ///
  /// For false positive, there are zero or more ground truth annotations that
  /// are similar to the only prediction in
  /// `predictions`,
  /// but not enough for a match.
  ///
  /// For false negative, there is one and only one ground truth annotation,
  /// which doesn't match any predictions created by the model.
  ///
  /// The schema of the ground truth is stored in
  /// `ModelEvaluation.annotation_schema_uri`
  final List<protobuf.Value>? groundTruths;

  /// Output only. The data item payload that the Model predicted this
  /// EvaluatedAnnotation on.
  final protobuf.Value? dataItemPayload;

  /// Output only. ID of the EvaluatedDataItemView under the same ancestor
  /// ModelEvaluation. The EvaluatedDataItemView consists of all ground truths
  /// and predictions on
  /// `data_item_payload`.
  final String? evaluatedDataItemViewId;

  /// Explanations of
  /// `predictions`.
  /// Each element of the explanations indicates the explanation for one
  /// explanation Method.
  ///
  /// The attributions list in the
  /// `EvaluatedAnnotationExplanation.explanation`
  /// object corresponds to the
  /// `predictions`
  /// list. For example, the second element in the attributions list explains the
  /// second element in the predictions list.
  final List<EvaluatedAnnotationExplanation>? explanations;

  /// Annotations of model error analysis results.
  final List<ErrorAnalysisAnnotation>? errorAnalysisAnnotations;

  EvaluatedAnnotation({
    this.type,
    this.predictions,
    this.groundTruths,
    this.dataItemPayload,
    this.evaluatedDataItemViewId,
    this.explanations,
    this.errorAnalysisAnnotations,
  }) : super(fullyQualifiedName);

  factory EvaluatedAnnotation.fromJson(Map<String, dynamic> json) {
    return EvaluatedAnnotation(
      type: decodeEnum(
        json['type'],
        EvaluatedAnnotation_EvaluatedAnnotationType.fromJson,
      ),
      predictions: decodeListMessageCustom(
        json['predictions'],
        protobuf.Value.fromJson,
      ),
      groundTruths: decodeListMessageCustom(
        json['groundTruths'],
        protobuf.Value.fromJson,
      ),
      dataItemPayload: decodeCustom(
        json['dataItemPayload'],
        protobuf.Value.fromJson,
      ),
      evaluatedDataItemViewId: json['evaluatedDataItemViewId'],
      explanations: decodeListMessage(
        json['explanations'],
        EvaluatedAnnotationExplanation.fromJson,
      ),
      errorAnalysisAnnotations: decodeListMessage(
        json['errorAnalysisAnnotations'],
        ErrorAnalysisAnnotation.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (type != null) 'type': type!.toJson(),
      if (predictions != null) 'predictions': encodeList(predictions),
      if (groundTruths != null) 'groundTruths': encodeList(groundTruths),
      if (dataItemPayload != null) 'dataItemPayload': dataItemPayload!.toJson(),
      if (evaluatedDataItemViewId != null)
        'evaluatedDataItemViewId': evaluatedDataItemViewId,
      if (explanations != null) 'explanations': encodeList(explanations),
      if (errorAnalysisAnnotations != null)
        'errorAnalysisAnnotations': encodeList(errorAnalysisAnnotations),
    };
  }

  @override
  String toString() {
    final contents = [
      if (type != null) 'type=$type',
      if (evaluatedDataItemViewId != null)
        'evaluatedDataItemViewId=$evaluatedDataItemViewId',
    ].join(',');
    return 'EvaluatedAnnotation($contents)';
  }
}

/// Describes the type of the EvaluatedAnnotation. The type is determined
final class EvaluatedAnnotation_EvaluatedAnnotationType
    extends protobuf.ProtoEnum {
  /// Invalid value.
  static const evaluatedAnnotationTypeUnspecified =
      EvaluatedAnnotation_EvaluatedAnnotationType(
        'EVALUATED_ANNOTATION_TYPE_UNSPECIFIED',
      );

  /// The EvaluatedAnnotation is a true positive. It has a prediction created
  /// by the Model and a ground truth Annotation which the prediction matches.
  static const truePositive = EvaluatedAnnotation_EvaluatedAnnotationType(
    'TRUE_POSITIVE',
  );

  /// The EvaluatedAnnotation is false positive. It has a prediction created by
  /// the Model which does not match any ground truth annotation.
  static const falsePositive = EvaluatedAnnotation_EvaluatedAnnotationType(
    'FALSE_POSITIVE',
  );

  /// The EvaluatedAnnotation is false negative. It has a ground truth
  /// annotation which is not matched by any of the model created predictions.
  static const falseNegative = EvaluatedAnnotation_EvaluatedAnnotationType(
    'FALSE_NEGATIVE',
  );

  const EvaluatedAnnotation_EvaluatedAnnotationType(super.value);

  factory EvaluatedAnnotation_EvaluatedAnnotationType.fromJson(String json) =>
      EvaluatedAnnotation_EvaluatedAnnotationType(json);

  @override
  String toString() => 'EvaluatedAnnotationType.$value';
}

/// Explanation result of the prediction produced by the Model.
final class EvaluatedAnnotationExplanation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluatedAnnotationExplanation';

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are:
  ///
  ///   * `image-integrated-gradients`
  ///   * `image-xrai`
  final String? explanationType;

  /// Explanation attribution response details.
  final Explanation? explanation;

  EvaluatedAnnotationExplanation({this.explanationType, this.explanation})
    : super(fullyQualifiedName);

  factory EvaluatedAnnotationExplanation.fromJson(Map<String, dynamic> json) {
    return EvaluatedAnnotationExplanation(
      explanationType: json['explanationType'],
      explanation: decode(json['explanation'], Explanation.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (explanationType != null) 'explanationType': explanationType,
      if (explanation != null) 'explanation': explanation!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (explanationType != null) 'explanationType=$explanationType',
    ].join(',');
    return 'EvaluatedAnnotationExplanation($contents)';
  }
}

/// Model error analysis for each annotation.
final class ErrorAnalysisAnnotation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ErrorAnalysisAnnotation';

  /// Attributed items for a given annotation, typically representing neighbors
  /// from the training sets constrained by the query type.
  final List<ErrorAnalysisAnnotation_AttributedItem>? attributedItems;

  /// The query type used for finding the attributed items.
  final ErrorAnalysisAnnotation_QueryType? queryType;

  /// The outlier score of this annotated item. Usually defined as the min of all
  /// distances from attributed items.
  final double? outlierScore;

  /// The threshold used to determine if this annotation is an outlier or not.
  final double? outlierThreshold;

  ErrorAnalysisAnnotation({
    this.attributedItems,
    this.queryType,
    this.outlierScore,
    this.outlierThreshold,
  }) : super(fullyQualifiedName);

  factory ErrorAnalysisAnnotation.fromJson(Map<String, dynamic> json) {
    return ErrorAnalysisAnnotation(
      attributedItems: decodeListMessage(
        json['attributedItems'],
        ErrorAnalysisAnnotation_AttributedItem.fromJson,
      ),
      queryType: decodeEnum(
        json['queryType'],
        ErrorAnalysisAnnotation_QueryType.fromJson,
      ),
      outlierScore: decodeDouble(json['outlierScore']),
      outlierThreshold: decodeDouble(json['outlierThreshold']),
    );
  }

  @override
  Object toJson() {
    return {
      if (attributedItems != null)
        'attributedItems': encodeList(attributedItems),
      if (queryType != null) 'queryType': queryType!.toJson(),
      if (outlierScore != null) 'outlierScore': encodeDouble(outlierScore),
      if (outlierThreshold != null)
        'outlierThreshold': encodeDouble(outlierThreshold),
    };
  }

  @override
  String toString() {
    final contents = [
      if (queryType != null) 'queryType=$queryType',
      if (outlierScore != null) 'outlierScore=$outlierScore',
      if (outlierThreshold != null) 'outlierThreshold=$outlierThreshold',
    ].join(',');
    return 'ErrorAnalysisAnnotation($contents)';
  }
}

/// Attributed items for a given annotation, typically representing neighbors
/// from the training sets constrained by the query type.
final class ErrorAnalysisAnnotation_AttributedItem
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ErrorAnalysisAnnotation.AttributedItem';

  /// The unique ID for each annotation. Used by FE to allocate the annotation
  /// in DB.
  final String? annotationResourceName;

  /// The distance of this item to the annotation.
  final double? distance;

  ErrorAnalysisAnnotation_AttributedItem({
    this.annotationResourceName,
    this.distance,
  }) : super(fullyQualifiedName);

  factory ErrorAnalysisAnnotation_AttributedItem.fromJson(
    Map<String, dynamic> json,
  ) {
    return ErrorAnalysisAnnotation_AttributedItem(
      annotationResourceName: json['annotationResourceName'],
      distance: decodeDouble(json['distance']),
    );
  }

  @override
  Object toJson() {
    return {
      if (annotationResourceName != null)
        'annotationResourceName': annotationResourceName,
      if (distance != null) 'distance': encodeDouble(distance),
    };
  }

  @override
  String toString() {
    final contents = [
      if (annotationResourceName != null)
        'annotationResourceName=$annotationResourceName',
      if (distance != null) 'distance=$distance',
    ].join(',');
    return 'AttributedItem($contents)';
  }
}

/// The query type used for finding the attributed items.
final class ErrorAnalysisAnnotation_QueryType extends protobuf.ProtoEnum {
  /// Unspecified query type for model error analysis.
  static const queryTypeUnspecified = ErrorAnalysisAnnotation_QueryType(
    'QUERY_TYPE_UNSPECIFIED',
  );

  /// Query similar samples across all classes in the dataset.
  static const allSimilar = ErrorAnalysisAnnotation_QueryType('ALL_SIMILAR');

  /// Query similar samples from the same class of the input sample.
  static const sameClassSimilar = ErrorAnalysisAnnotation_QueryType(
    'SAME_CLASS_SIMILAR',
  );

  /// Query dissimilar samples from the same class of the input sample.
  static const sameClassDissimilar = ErrorAnalysisAnnotation_QueryType(
    'SAME_CLASS_DISSIMILAR',
  );

  const ErrorAnalysisAnnotation_QueryType(super.value);

  factory ErrorAnalysisAnnotation_QueryType.fromJson(String json) =>
      ErrorAnalysisAnnotation_QueryType(json);

  @override
  String toString() => 'QueryType.$value';
}

/// Operation metadata for Dataset Evaluation.
final class EvaluateDatasetOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateDatasetOperationMetadata';

  /// Generic operation metadata.
  final GenericOperationMetadata? genericMetadata;

  EvaluateDatasetOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory EvaluateDatasetOperationMetadata.fromJson(Map<String, dynamic> json) {
    return EvaluateDatasetOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'EvaluateDatasetOperationMetadata()';
}

/// Response in LRO for EvaluationService.EvaluateDataset.
final class EvaluateDatasetResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateDatasetResponse';

  /// Output only. Aggregation statistics derived from results of
  /// EvaluationService.EvaluateDataset.
  final AggregationOutput? aggregationOutput;

  /// Output only. Output info for EvaluationService.EvaluateDataset.
  final OutputInfo? outputInfo;

  EvaluateDatasetResponse({this.aggregationOutput, this.outputInfo})
    : super(fullyQualifiedName);

  factory EvaluateDatasetResponse.fromJson(Map<String, dynamic> json) {
    return EvaluateDatasetResponse(
      aggregationOutput: decode(
        json['aggregationOutput'],
        AggregationOutput.fromJson,
      ),
      outputInfo: decode(json['outputInfo'], OutputInfo.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (aggregationOutput != null)
        'aggregationOutput': aggregationOutput!.toJson(),
      if (outputInfo != null) 'outputInfo': outputInfo!.toJson(),
    };
  }

  @override
  String toString() => 'EvaluateDatasetResponse()';
}

/// Describes the info for output of EvaluationService.EvaluateDataset.
final class OutputInfo extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.OutputInfo';

  /// Output only. The full path of the Cloud Storage directory created, into
  /// which the evaluation results and aggregation results are written.
  final String? gcsOutputDirectory;

  OutputInfo({this.gcsOutputDirectory}) : super(fullyQualifiedName);

  factory OutputInfo.fromJson(Map<String, dynamic> json) {
    return OutputInfo(gcsOutputDirectory: json['gcsOutputDirectory']);
  }

  @override
  Object toJson() {
    return {
      if (gcsOutputDirectory != null) 'gcsOutputDirectory': gcsOutputDirectory,
    };
  }

  @override
  String toString() {
    final contents = [
      if (gcsOutputDirectory != null) 'gcsOutputDirectory=$gcsOutputDirectory',
    ].join(',');
    return 'OutputInfo($contents)';
  }
}

/// The aggregation result for the entire dataset and all metrics.
final class AggregationOutput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AggregationOutput';

  /// The dataset used for evaluation & aggregation.
  final EvaluationDataset? dataset;

  /// One AggregationResult per metric.
  final List<AggregationResult>? aggregationResults;

  AggregationOutput({this.dataset, this.aggregationResults})
    : super(fullyQualifiedName);

  factory AggregationOutput.fromJson(Map<String, dynamic> json) {
    return AggregationOutput(
      dataset: decode(json['dataset'], EvaluationDataset.fromJson),
      aggregationResults: decodeListMessage(
        json['aggregationResults'],
        AggregationResult.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataset != null) 'dataset': dataset!.toJson(),
      if (aggregationResults != null)
        'aggregationResults': encodeList(aggregationResults),
    };
  }

  @override
  String toString() => 'AggregationOutput()';
}

/// The aggregation result for a single metric.
final class AggregationResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AggregationResult';

  /// Result for pointwise metric.
  final PointwiseMetricResult? pointwiseMetricResult;

  /// Result for pairwise metric.
  final PairwiseMetricResult? pairwiseMetricResult;

  /// Results for exact match metric.
  final ExactMatchMetricValue? exactMatchMetricValue;

  /// Results for bleu metric.
  final BleuMetricValue? bleuMetricValue;

  /// Results for rouge metric.
  final RougeMetricValue? rougeMetricValue;

  /// Aggregation metric.
  final Metric_AggregationMetric? aggregationMetric;

  AggregationResult({
    this.pointwiseMetricResult,
    this.pairwiseMetricResult,
    this.exactMatchMetricValue,
    this.bleuMetricValue,
    this.rougeMetricValue,
    this.aggregationMetric,
  }) : super(fullyQualifiedName);

  factory AggregationResult.fromJson(Map<String, dynamic> json) {
    return AggregationResult(
      pointwiseMetricResult: decode(
        json['pointwiseMetricResult'],
        PointwiseMetricResult.fromJson,
      ),
      pairwiseMetricResult: decode(
        json['pairwiseMetricResult'],
        PairwiseMetricResult.fromJson,
      ),
      exactMatchMetricValue: decode(
        json['exactMatchMetricValue'],
        ExactMatchMetricValue.fromJson,
      ),
      bleuMetricValue: decode(
        json['bleuMetricValue'],
        BleuMetricValue.fromJson,
      ),
      rougeMetricValue: decode(
        json['rougeMetricValue'],
        RougeMetricValue.fromJson,
      ),
      aggregationMetric: decodeEnum(
        json['aggregationMetric'],
        Metric_AggregationMetric.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (pointwiseMetricResult != null)
        'pointwiseMetricResult': pointwiseMetricResult!.toJson(),
      if (pairwiseMetricResult != null)
        'pairwiseMetricResult': pairwiseMetricResult!.toJson(),
      if (exactMatchMetricValue != null)
        'exactMatchMetricValue': exactMatchMetricValue!.toJson(),
      if (bleuMetricValue != null) 'bleuMetricValue': bleuMetricValue!.toJson(),
      if (rougeMetricValue != null)
        'rougeMetricValue': rougeMetricValue!.toJson(),
      if (aggregationMetric != null)
        'aggregationMetric': aggregationMetric!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (aggregationMetric != null) 'aggregationMetric=$aggregationMetric',
    ].join(',');
    return 'AggregationResult($contents)';
  }
}

/// Request message for EvaluationService.EvaluateDataset.
final class EvaluateDatasetRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateDatasetRequest';

  /// Required. The resource name of the Location to evaluate the dataset.
  /// Format: `projects/{project}/locations/{location}`
  final String location;

  /// Required. The dataset used for evaluation.
  final EvaluationDataset? dataset;

  /// Required. The metrics used for evaluation.
  final List<Metric>? metrics;

  /// Required. Config for evaluation output.
  final OutputConfig? outputConfig;

  /// Optional. Autorater config used for evaluation. Currently only publisher
  /// Gemini models are supported. Format:
  /// `projects/{PROJECT}/locations/{LOCATION}/publishers/google/models/{MODEL}.`
  final AutoraterConfig? autoraterConfig;

  EvaluateDatasetRequest({
    required this.location,
    this.dataset,
    this.metrics,
    this.outputConfig,
    this.autoraterConfig,
  }) : super(fullyQualifiedName);

  factory EvaluateDatasetRequest.fromJson(Map<String, dynamic> json) {
    return EvaluateDatasetRequest(
      location: json['location'],
      dataset: decode(json['dataset'], EvaluationDataset.fromJson),
      metrics: decodeListMessage(json['metrics'], Metric.fromJson),
      outputConfig: decode(json['outputConfig'], OutputConfig.fromJson),
      autoraterConfig: decode(
        json['autoraterConfig'],
        AutoraterConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'location': location,
      if (dataset != null) 'dataset': dataset!.toJson(),
      if (metrics != null) 'metrics': encodeList(metrics),
      if (outputConfig != null) 'outputConfig': outputConfig!.toJson(),
      if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['location=$location'].join(',');
    return 'EvaluateDatasetRequest($contents)';
  }
}

/// Config for evaluation output.
final class OutputConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.OutputConfig';

  /// Cloud storage destination for evaluation output.
  final GcsDestination? gcsDestination;

  OutputConfig({this.gcsDestination}) : super(fullyQualifiedName);

  factory OutputConfig.fromJson(Map<String, dynamic> json) {
    return OutputConfig(
      gcsDestination: decode(json['gcsDestination'], GcsDestination.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
    };
  }

  @override
  String toString() => 'OutputConfig()';
}

/// The metric used for dataset level evaluation.
final class Metric extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Metric';

  /// Spec for pointwise metric.
  final PointwiseMetricSpec? pointwiseMetricSpec;

  /// Spec for pairwise metric.
  final PairwiseMetricSpec? pairwiseMetricSpec;

  /// Spec for exact match metric.
  final ExactMatchSpec? exactMatchSpec;

  /// Spec for bleu metric.
  final BleuSpec? bleuSpec;

  /// Spec for rouge metric.
  final RougeSpec? rougeSpec;

  /// Optional. The aggregation metrics to use.
  final List<Metric_AggregationMetric>? aggregationMetrics;

  Metric({
    this.pointwiseMetricSpec,
    this.pairwiseMetricSpec,
    this.exactMatchSpec,
    this.bleuSpec,
    this.rougeSpec,
    this.aggregationMetrics,
  }) : super(fullyQualifiedName);

  factory Metric.fromJson(Map<String, dynamic> json) {
    return Metric(
      pointwiseMetricSpec: decode(
        json['pointwiseMetricSpec'],
        PointwiseMetricSpec.fromJson,
      ),
      pairwiseMetricSpec: decode(
        json['pairwiseMetricSpec'],
        PairwiseMetricSpec.fromJson,
      ),
      exactMatchSpec: decode(json['exactMatchSpec'], ExactMatchSpec.fromJson),
      bleuSpec: decode(json['bleuSpec'], BleuSpec.fromJson),
      rougeSpec: decode(json['rougeSpec'], RougeSpec.fromJson),
      aggregationMetrics: decodeListEnum(
        json['aggregationMetrics'],
        Metric_AggregationMetric.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (pointwiseMetricSpec != null)
        'pointwiseMetricSpec': pointwiseMetricSpec!.toJson(),
      if (pairwiseMetricSpec != null)
        'pairwiseMetricSpec': pairwiseMetricSpec!.toJson(),
      if (exactMatchSpec != null) 'exactMatchSpec': exactMatchSpec!.toJson(),
      if (bleuSpec != null) 'bleuSpec': bleuSpec!.toJson(),
      if (rougeSpec != null) 'rougeSpec': rougeSpec!.toJson(),
      if (aggregationMetrics != null)
        'aggregationMetrics': encodeList(aggregationMetrics),
    };
  }

  @override
  String toString() => 'Metric()';
}

/// The aggregation metrics supported by EvaluationService.EvaluateDataset.
final class Metric_AggregationMetric extends protobuf.ProtoEnum {
  /// Unspecified aggregation metric.
  static const aggregationMetricUnspecified = Metric_AggregationMetric(
    'AGGREGATION_METRIC_UNSPECIFIED',
  );

  /// Average aggregation metric. Not supported for Pairwise metric.
  static const average = Metric_AggregationMetric('AVERAGE');

  /// Mode aggregation metric.
  static const mode = Metric_AggregationMetric('MODE');

  /// Standard deviation aggregation metric. Not supported for pairwise metric.
  static const standardDeviation = Metric_AggregationMetric(
    'STANDARD_DEVIATION',
  );

  /// Variance aggregation metric. Not supported for pairwise metric.
  static const variance = Metric_AggregationMetric('VARIANCE');

  /// Minimum aggregation metric. Not supported for pairwise metric.
  static const minimum = Metric_AggregationMetric('MINIMUM');

  /// Maximum aggregation metric. Not supported for pairwise metric.
  static const maximum = Metric_AggregationMetric('MAXIMUM');

  /// Median aggregation metric. Not supported for pairwise metric.
  static const median = Metric_AggregationMetric('MEDIAN');

  /// 90th percentile aggregation metric. Not supported for pairwise metric.
  static const percentileP90 = Metric_AggregationMetric('PERCENTILE_P90');

  /// 95th percentile aggregation metric. Not supported for pairwise metric.
  static const percentileP95 = Metric_AggregationMetric('PERCENTILE_P95');

  /// 99th percentile aggregation metric. Not supported for pairwise metric.
  static const percentileP99 = Metric_AggregationMetric('PERCENTILE_P99');

  const Metric_AggregationMetric(super.value);

  factory Metric_AggregationMetric.fromJson(String json) =>
      Metric_AggregationMetric(json);

  @override
  String toString() => 'AggregationMetric.$value';
}

/// The dataset used for evaluation.
final class EvaluationDataset extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluationDataset';

  /// Cloud storage source holds the dataset. Currently only one Cloud Storage
  /// file path is supported.
  final GcsSource? gcsSource;

  /// BigQuery source holds the dataset.
  final BigQuerySource? bigquerySource;

  EvaluationDataset({this.gcsSource, this.bigquerySource})
    : super(fullyQualifiedName);

  factory EvaluationDataset.fromJson(Map<String, dynamic> json) {
    return EvaluationDataset(
      gcsSource: decode(json['gcsSource'], GcsSource.fromJson),
      bigquerySource: decode(json['bigquerySource'], BigQuerySource.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
      if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
    };
  }

  @override
  String toString() => 'EvaluationDataset()';
}

/// The configs for autorater. This is applicable to both EvaluateInstances and
/// EvaluateDataset.
final class AutoraterConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AutoraterConfig';

  /// Optional. Number of samples for each instance in the dataset.
  /// If not specified, the default is 4. Minimum value is 1, maximum value
  /// is 32.
  final int? samplingCount;

  /// Optional. Default is true. Whether to flip the candidate and baseline
  /// responses. This is only applicable to the pairwise metric. If enabled, also
  /// provide PairwiseMetricSpec.candidate_response_field_name and
  /// PairwiseMetricSpec.baseline_response_field_name. When rendering
  /// PairwiseMetricSpec.metric_prompt_template, the candidate and baseline
  /// fields will be flipped for half of the samples to reduce bias.
  final bool? flipEnabled;

  /// Optional. The fully qualified name of the publisher model or tuned
  /// autorater endpoint to use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers/*/models/*`
  ///
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? autoraterModel;

  AutoraterConfig({this.samplingCount, this.flipEnabled, this.autoraterModel})
    : super(fullyQualifiedName);

  factory AutoraterConfig.fromJson(Map<String, dynamic> json) {
    return AutoraterConfig(
      samplingCount: json['samplingCount'],
      flipEnabled: json['flipEnabled'],
      autoraterModel: json['autoraterModel'],
    );
  }

  @override
  Object toJson() {
    return {
      if (samplingCount != null) 'samplingCount': samplingCount,
      if (flipEnabled != null) 'flipEnabled': flipEnabled,
      if (autoraterModel != null) 'autoraterModel': autoraterModel,
    };
  }

  @override
  String toString() {
    final contents = [
      if (samplingCount != null) 'samplingCount=$samplingCount',
      if (flipEnabled != null) 'flipEnabled=$flipEnabled',
      if (autoraterModel != null) 'autoraterModel=$autoraterModel',
    ].join(',');
    return 'AutoraterConfig($contents)';
  }
}

/// Request message for EvaluationService.EvaluateInstances.
final class EvaluateInstancesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateInstancesRequest';

  /// Auto metric instances.
  /// Instances and metric spec for exact match metric.
  final ExactMatchInput? exactMatchInput;

  /// Instances and metric spec for bleu metric.
  final BleuInput? bleuInput;

  /// Instances and metric spec for rouge metric.
  final RougeInput? rougeInput;

  /// LLM-based metric instance.
  /// General text generation metrics, applicable to other categories.
  /// Input for fluency metric.
  final FluencyInput? fluencyInput;

  /// Input for coherence metric.
  final CoherenceInput? coherenceInput;

  /// Input for safety metric.
  final SafetyInput? safetyInput;

  /// Input for groundedness metric.
  final GroundednessInput? groundednessInput;

  /// Input for fulfillment metric.
  final FulfillmentInput? fulfillmentInput;

  /// Input for summarization quality metric.
  final SummarizationQualityInput? summarizationQualityInput;

  /// Input for pairwise summarization quality metric.
  final PairwiseSummarizationQualityInput? pairwiseSummarizationQualityInput;

  /// Input for summarization helpfulness metric.
  final SummarizationHelpfulnessInput? summarizationHelpfulnessInput;

  /// Input for summarization verbosity metric.
  final SummarizationVerbosityInput? summarizationVerbosityInput;

  /// Input for question answering quality metric.
  final QuestionAnsweringQualityInput? questionAnsweringQualityInput;

  /// Input for pairwise question answering quality metric.
  final PairwiseQuestionAnsweringQualityInput?
  pairwiseQuestionAnsweringQualityInput;

  /// Input for question answering relevance metric.
  final QuestionAnsweringRelevanceInput? questionAnsweringRelevanceInput;

  /// Input for question answering helpfulness
  /// metric.
  final QuestionAnsweringHelpfulnessInput? questionAnsweringHelpfulnessInput;

  /// Input for question answering correctness
  /// metric.
  final QuestionAnsweringCorrectnessInput? questionAnsweringCorrectnessInput;

  /// Input for pointwise metric.
  final PointwiseMetricInput? pointwiseMetricInput;

  /// Input for pairwise metric.
  final PairwiseMetricInput? pairwiseMetricInput;

  /// Tool call metric instances.
  /// Input for tool call valid metric.
  final ToolCallValidInput? toolCallValidInput;

  /// Input for tool name match metric.
  final ToolNameMatchInput? toolNameMatchInput;

  /// Input for tool parameter key match metric.
  final ToolParameterKeyMatchInput? toolParameterKeyMatchInput;

  /// Input for tool parameter key value match metric.
  final ToolParameterKvmatchInput? toolParameterKvMatchInput;

  /// Translation metrics.
  /// Input for Comet metric.
  final CometInput? cometInput;

  /// Input for Metricx metric.
  final MetricxInput? metricxInput;

  /// Input for trajectory exact match metric.
  final TrajectoryExactMatchInput? trajectoryExactMatchInput;

  /// Input for trajectory in order match metric.
  final TrajectoryInOrderMatchInput? trajectoryInOrderMatchInput;

  /// Input for trajectory match any order metric.
  final TrajectoryAnyOrderMatchInput? trajectoryAnyOrderMatchInput;

  /// Input for trajectory precision metric.
  final TrajectoryPrecisionInput? trajectoryPrecisionInput;

  /// Input for trajectory recall metric.
  final TrajectoryRecallInput? trajectoryRecallInput;

  /// Input for trajectory single tool use metric.
  final TrajectorySingleToolUseInput? trajectorySingleToolUseInput;

  /// Rubric Based Instruction Following metric.
  final RubricBasedInstructionFollowingInput?
  rubricBasedInstructionFollowingInput;

  /// Required. The resource name of the Location to evaluate the instances.
  /// Format: `projects/{project}/locations/{location}`
  final String location;

  /// Optional. Autorater config used for evaluation.
  final AutoraterConfig? autoraterConfig;

  EvaluateInstancesRequest({
    this.exactMatchInput,
    this.bleuInput,
    this.rougeInput,
    this.fluencyInput,
    this.coherenceInput,
    this.safetyInput,
    this.groundednessInput,
    this.fulfillmentInput,
    this.summarizationQualityInput,
    this.pairwiseSummarizationQualityInput,
    this.summarizationHelpfulnessInput,
    this.summarizationVerbosityInput,
    this.questionAnsweringQualityInput,
    this.pairwiseQuestionAnsweringQualityInput,
    this.questionAnsweringRelevanceInput,
    this.questionAnsweringHelpfulnessInput,
    this.questionAnsweringCorrectnessInput,
    this.pointwiseMetricInput,
    this.pairwiseMetricInput,
    this.toolCallValidInput,
    this.toolNameMatchInput,
    this.toolParameterKeyMatchInput,
    this.toolParameterKvMatchInput,
    this.cometInput,
    this.metricxInput,
    this.trajectoryExactMatchInput,
    this.trajectoryInOrderMatchInput,
    this.trajectoryAnyOrderMatchInput,
    this.trajectoryPrecisionInput,
    this.trajectoryRecallInput,
    this.trajectorySingleToolUseInput,
    this.rubricBasedInstructionFollowingInput,
    required this.location,
    this.autoraterConfig,
  }) : super(fullyQualifiedName);

  factory EvaluateInstancesRequest.fromJson(Map<String, dynamic> json) {
    return EvaluateInstancesRequest(
      exactMatchInput: decode(
        json['exactMatchInput'],
        ExactMatchInput.fromJson,
      ),
      bleuInput: decode(json['bleuInput'], BleuInput.fromJson),
      rougeInput: decode(json['rougeInput'], RougeInput.fromJson),
      fluencyInput: decode(json['fluencyInput'], FluencyInput.fromJson),
      coherenceInput: decode(json['coherenceInput'], CoherenceInput.fromJson),
      safetyInput: decode(json['safetyInput'], SafetyInput.fromJson),
      groundednessInput: decode(
        json['groundednessInput'],
        GroundednessInput.fromJson,
      ),
      fulfillmentInput: decode(
        json['fulfillmentInput'],
        FulfillmentInput.fromJson,
      ),
      summarizationQualityInput: decode(
        json['summarizationQualityInput'],
        SummarizationQualityInput.fromJson,
      ),
      pairwiseSummarizationQualityInput: decode(
        json['pairwiseSummarizationQualityInput'],
        PairwiseSummarizationQualityInput.fromJson,
      ),
      summarizationHelpfulnessInput: decode(
        json['summarizationHelpfulnessInput'],
        SummarizationHelpfulnessInput.fromJson,
      ),
      summarizationVerbosityInput: decode(
        json['summarizationVerbosityInput'],
        SummarizationVerbosityInput.fromJson,
      ),
      questionAnsweringQualityInput: decode(
        json['questionAnsweringQualityInput'],
        QuestionAnsweringQualityInput.fromJson,
      ),
      pairwiseQuestionAnsweringQualityInput: decode(
        json['pairwiseQuestionAnsweringQualityInput'],
        PairwiseQuestionAnsweringQualityInput.fromJson,
      ),
      questionAnsweringRelevanceInput: decode(
        json['questionAnsweringRelevanceInput'],
        QuestionAnsweringRelevanceInput.fromJson,
      ),
      questionAnsweringHelpfulnessInput: decode(
        json['questionAnsweringHelpfulnessInput'],
        QuestionAnsweringHelpfulnessInput.fromJson,
      ),
      questionAnsweringCorrectnessInput: decode(
        json['questionAnsweringCorrectnessInput'],
        QuestionAnsweringCorrectnessInput.fromJson,
      ),
      pointwiseMetricInput: decode(
        json['pointwiseMetricInput'],
        PointwiseMetricInput.fromJson,
      ),
      pairwiseMetricInput: decode(
        json['pairwiseMetricInput'],
        PairwiseMetricInput.fromJson,
      ),
      toolCallValidInput: decode(
        json['toolCallValidInput'],
        ToolCallValidInput.fromJson,
      ),
      toolNameMatchInput: decode(
        json['toolNameMatchInput'],
        ToolNameMatchInput.fromJson,
      ),
      toolParameterKeyMatchInput: decode(
        json['toolParameterKeyMatchInput'],
        ToolParameterKeyMatchInput.fromJson,
      ),
      toolParameterKvMatchInput: decode(
        json['toolParameterKvMatchInput'],
        ToolParameterKvmatchInput.fromJson,
      ),
      cometInput: decode(json['cometInput'], CometInput.fromJson),
      metricxInput: decode(json['metricxInput'], MetricxInput.fromJson),
      trajectoryExactMatchInput: decode(
        json['trajectoryExactMatchInput'],
        TrajectoryExactMatchInput.fromJson,
      ),
      trajectoryInOrderMatchInput: decode(
        json['trajectoryInOrderMatchInput'],
        TrajectoryInOrderMatchInput.fromJson,
      ),
      trajectoryAnyOrderMatchInput: decode(
        json['trajectoryAnyOrderMatchInput'],
        TrajectoryAnyOrderMatchInput.fromJson,
      ),
      trajectoryPrecisionInput: decode(
        json['trajectoryPrecisionInput'],
        TrajectoryPrecisionInput.fromJson,
      ),
      trajectoryRecallInput: decode(
        json['trajectoryRecallInput'],
        TrajectoryRecallInput.fromJson,
      ),
      trajectorySingleToolUseInput: decode(
        json['trajectorySingleToolUseInput'],
        TrajectorySingleToolUseInput.fromJson,
      ),
      rubricBasedInstructionFollowingInput: decode(
        json['rubricBasedInstructionFollowingInput'],
        RubricBasedInstructionFollowingInput.fromJson,
      ),
      location: json['location'],
      autoraterConfig: decode(
        json['autoraterConfig'],
        AutoraterConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (exactMatchInput != null) 'exactMatchInput': exactMatchInput!.toJson(),
      if (bleuInput != null) 'bleuInput': bleuInput!.toJson(),
      if (rougeInput != null) 'rougeInput': rougeInput!.toJson(),
      if (fluencyInput != null) 'fluencyInput': fluencyInput!.toJson(),
      if (coherenceInput != null) 'coherenceInput': coherenceInput!.toJson(),
      if (safetyInput != null) 'safetyInput': safetyInput!.toJson(),
      if (groundednessInput != null)
        'groundednessInput': groundednessInput!.toJson(),
      if (fulfillmentInput != null)
        'fulfillmentInput': fulfillmentInput!.toJson(),
      if (summarizationQualityInput != null)
        'summarizationQualityInput': summarizationQualityInput!.toJson(),
      if (pairwiseSummarizationQualityInput != null)
        'pairwiseSummarizationQualityInput': pairwiseSummarizationQualityInput!
            .toJson(),
      if (summarizationHelpfulnessInput != null)
        'summarizationHelpfulnessInput': summarizationHelpfulnessInput!
            .toJson(),
      if (summarizationVerbosityInput != null)
        'summarizationVerbosityInput': summarizationVerbosityInput!.toJson(),
      if (questionAnsweringQualityInput != null)
        'questionAnsweringQualityInput': questionAnsweringQualityInput!
            .toJson(),
      if (pairwiseQuestionAnsweringQualityInput != null)
        'pairwiseQuestionAnsweringQualityInput':
            pairwiseQuestionAnsweringQualityInput!.toJson(),
      if (questionAnsweringRelevanceInput != null)
        'questionAnsweringRelevanceInput': questionAnsweringRelevanceInput!
            .toJson(),
      if (questionAnsweringHelpfulnessInput != null)
        'questionAnsweringHelpfulnessInput': questionAnsweringHelpfulnessInput!
            .toJson(),
      if (questionAnsweringCorrectnessInput != null)
        'questionAnsweringCorrectnessInput': questionAnsweringCorrectnessInput!
            .toJson(),
      if (pointwiseMetricInput != null)
        'pointwiseMetricInput': pointwiseMetricInput!.toJson(),
      if (pairwiseMetricInput != null)
        'pairwiseMetricInput': pairwiseMetricInput!.toJson(),
      if (toolCallValidInput != null)
        'toolCallValidInput': toolCallValidInput!.toJson(),
      if (toolNameMatchInput != null)
        'toolNameMatchInput': toolNameMatchInput!.toJson(),
      if (toolParameterKeyMatchInput != null)
        'toolParameterKeyMatchInput': toolParameterKeyMatchInput!.toJson(),
      if (toolParameterKvMatchInput != null)
        'toolParameterKvMatchInput': toolParameterKvMatchInput!.toJson(),
      if (cometInput != null) 'cometInput': cometInput!.toJson(),
      if (metricxInput != null) 'metricxInput': metricxInput!.toJson(),
      if (trajectoryExactMatchInput != null)
        'trajectoryExactMatchInput': trajectoryExactMatchInput!.toJson(),
      if (trajectoryInOrderMatchInput != null)
        'trajectoryInOrderMatchInput': trajectoryInOrderMatchInput!.toJson(),
      if (trajectoryAnyOrderMatchInput != null)
        'trajectoryAnyOrderMatchInput': trajectoryAnyOrderMatchInput!.toJson(),
      if (trajectoryPrecisionInput != null)
        'trajectoryPrecisionInput': trajectoryPrecisionInput!.toJson(),
      if (trajectoryRecallInput != null)
        'trajectoryRecallInput': trajectoryRecallInput!.toJson(),
      if (trajectorySingleToolUseInput != null)
        'trajectorySingleToolUseInput': trajectorySingleToolUseInput!.toJson(),
      if (rubricBasedInstructionFollowingInput != null)
        'rubricBasedInstructionFollowingInput':
            rubricBasedInstructionFollowingInput!.toJson(),
      'location': location,
      if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['location=$location'].join(',');
    return 'EvaluateInstancesRequest($contents)';
  }
}

/// Response message for EvaluationService.EvaluateInstances.
final class EvaluateInstancesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateInstancesResponse';

  /// Auto metric evaluation results.
  /// Results for exact match metric.
  final ExactMatchResults? exactMatchResults;

  /// Results for bleu metric.
  final BleuResults? bleuResults;

  /// Results for rouge metric.
  final RougeResults? rougeResults;

  /// LLM-based metric evaluation result.
  /// General text generation metrics, applicable to other categories.
  /// Result for fluency metric.
  final FluencyResult? fluencyResult;

  /// Result for coherence metric.
  final CoherenceResult? coherenceResult;

  /// Result for safety metric.
  final SafetyResult? safetyResult;

  /// Result for groundedness metric.
  final GroundednessResult? groundednessResult;

  /// Result for fulfillment metric.
  final FulfillmentResult? fulfillmentResult;

  /// Summarization only metrics.
  /// Result for summarization quality metric.
  final SummarizationQualityResult? summarizationQualityResult;

  /// Result for pairwise summarization quality metric.
  final PairwiseSummarizationQualityResult? pairwiseSummarizationQualityResult;

  /// Result for summarization helpfulness metric.
  final SummarizationHelpfulnessResult? summarizationHelpfulnessResult;

  /// Result for summarization verbosity metric.
  final SummarizationVerbosityResult? summarizationVerbosityResult;

  /// Question answering only metrics.
  /// Result for question answering quality metric.
  final QuestionAnsweringQualityResult? questionAnsweringQualityResult;

  /// Result for pairwise question answering quality metric.
  final PairwiseQuestionAnsweringQualityResult?
  pairwiseQuestionAnsweringQualityResult;

  /// Result for question answering relevance metric.
  final QuestionAnsweringRelevanceResult? questionAnsweringRelevanceResult;

  /// Result for question answering helpfulness metric.
  final QuestionAnsweringHelpfulnessResult? questionAnsweringHelpfulnessResult;

  /// Result for question answering correctness metric.
  final QuestionAnsweringCorrectnessResult? questionAnsweringCorrectnessResult;

  /// Generic metrics.
  /// Result for pointwise metric.
  final PointwiseMetricResult? pointwiseMetricResult;

  /// Result for pairwise metric.
  final PairwiseMetricResult? pairwiseMetricResult;

  /// Tool call metrics.
  ///  Results for tool call valid metric.
  final ToolCallValidResults? toolCallValidResults;

  /// Results for tool name match metric.
  final ToolNameMatchResults? toolNameMatchResults;

  /// Results for tool parameter key match  metric.
  final ToolParameterKeyMatchResults? toolParameterKeyMatchResults;

  /// Results for tool parameter key value match metric.
  final ToolParameterKvmatchResults? toolParameterKvMatchResults;

  /// Translation metrics.
  /// Result for Comet metric.
  final CometResult? cometResult;

  /// Result for Metricx metric.
  final MetricxResult? metricxResult;

  /// Result for trajectory exact match metric.
  final TrajectoryExactMatchResults? trajectoryExactMatchResults;

  /// Result for trajectory in order match metric.
  final TrajectoryInOrderMatchResults? trajectoryInOrderMatchResults;

  /// Result for trajectory any order match metric.
  final TrajectoryAnyOrderMatchResults? trajectoryAnyOrderMatchResults;

  /// Result for trajectory precision metric.
  final TrajectoryPrecisionResults? trajectoryPrecisionResults;

  /// Results for trajectory recall metric.
  final TrajectoryRecallResults? trajectoryRecallResults;

  /// Results for trajectory single tool use metric.
  final TrajectorySingleToolUseResults? trajectorySingleToolUseResults;

  /// Result for rubric based instruction following metric.
  final RubricBasedInstructionFollowingResult?
  rubricBasedInstructionFollowingResult;

  EvaluateInstancesResponse({
    this.exactMatchResults,
    this.bleuResults,
    this.rougeResults,
    this.fluencyResult,
    this.coherenceResult,
    this.safetyResult,
    this.groundednessResult,
    this.fulfillmentResult,
    this.summarizationQualityResult,
    this.pairwiseSummarizationQualityResult,
    this.summarizationHelpfulnessResult,
    this.summarizationVerbosityResult,
    this.questionAnsweringQualityResult,
    this.pairwiseQuestionAnsweringQualityResult,
    this.questionAnsweringRelevanceResult,
    this.questionAnsweringHelpfulnessResult,
    this.questionAnsweringCorrectnessResult,
    this.pointwiseMetricResult,
    this.pairwiseMetricResult,
    this.toolCallValidResults,
    this.toolNameMatchResults,
    this.toolParameterKeyMatchResults,
    this.toolParameterKvMatchResults,
    this.cometResult,
    this.metricxResult,
    this.trajectoryExactMatchResults,
    this.trajectoryInOrderMatchResults,
    this.trajectoryAnyOrderMatchResults,
    this.trajectoryPrecisionResults,
    this.trajectoryRecallResults,
    this.trajectorySingleToolUseResults,
    this.rubricBasedInstructionFollowingResult,
  }) : super(fullyQualifiedName);

  factory EvaluateInstancesResponse.fromJson(Map<String, dynamic> json) {
    return EvaluateInstancesResponse(
      exactMatchResults: decode(
        json['exactMatchResults'],
        ExactMatchResults.fromJson,
      ),
      bleuResults: decode(json['bleuResults'], BleuResults.fromJson),
      rougeResults: decode(json['rougeResults'], RougeResults.fromJson),
      fluencyResult: decode(json['fluencyResult'], FluencyResult.fromJson),
      coherenceResult: decode(
        json['coherenceResult'],
        CoherenceResult.fromJson,
      ),
      safetyResult: decode(json['safetyResult'], SafetyResult.fromJson),
      groundednessResult: decode(
        json['groundednessResult'],
        GroundednessResult.fromJson,
      ),
      fulfillmentResult: decode(
        json['fulfillmentResult'],
        FulfillmentResult.fromJson,
      ),
      summarizationQualityResult: decode(
        json['summarizationQualityResult'],
        SummarizationQualityResult.fromJson,
      ),
      pairwiseSummarizationQualityResult: decode(
        json['pairwiseSummarizationQualityResult'],
        PairwiseSummarizationQualityResult.fromJson,
      ),
      summarizationHelpfulnessResult: decode(
        json['summarizationHelpfulnessResult'],
        SummarizationHelpfulnessResult.fromJson,
      ),
      summarizationVerbosityResult: decode(
        json['summarizationVerbosityResult'],
        SummarizationVerbosityResult.fromJson,
      ),
      questionAnsweringQualityResult: decode(
        json['questionAnsweringQualityResult'],
        QuestionAnsweringQualityResult.fromJson,
      ),
      pairwiseQuestionAnsweringQualityResult: decode(
        json['pairwiseQuestionAnsweringQualityResult'],
        PairwiseQuestionAnsweringQualityResult.fromJson,
      ),
      questionAnsweringRelevanceResult: decode(
        json['questionAnsweringRelevanceResult'],
        QuestionAnsweringRelevanceResult.fromJson,
      ),
      questionAnsweringHelpfulnessResult: decode(
        json['questionAnsweringHelpfulnessResult'],
        QuestionAnsweringHelpfulnessResult.fromJson,
      ),
      questionAnsweringCorrectnessResult: decode(
        json['questionAnsweringCorrectnessResult'],
        QuestionAnsweringCorrectnessResult.fromJson,
      ),
      pointwiseMetricResult: decode(
        json['pointwiseMetricResult'],
        PointwiseMetricResult.fromJson,
      ),
      pairwiseMetricResult: decode(
        json['pairwiseMetricResult'],
        PairwiseMetricResult.fromJson,
      ),
      toolCallValidResults: decode(
        json['toolCallValidResults'],
        ToolCallValidResults.fromJson,
      ),
      toolNameMatchResults: decode(
        json['toolNameMatchResults'],
        ToolNameMatchResults.fromJson,
      ),
      toolParameterKeyMatchResults: decode(
        json['toolParameterKeyMatchResults'],
        ToolParameterKeyMatchResults.fromJson,
      ),
      toolParameterKvMatchResults: decode(
        json['toolParameterKvMatchResults'],
        ToolParameterKvmatchResults.fromJson,
      ),
      cometResult: decode(json['cometResult'], CometResult.fromJson),
      metricxResult: decode(json['metricxResult'], MetricxResult.fromJson),
      trajectoryExactMatchResults: decode(
        json['trajectoryExactMatchResults'],
        TrajectoryExactMatchResults.fromJson,
      ),
      trajectoryInOrderMatchResults: decode(
        json['trajectoryInOrderMatchResults'],
        TrajectoryInOrderMatchResults.fromJson,
      ),
      trajectoryAnyOrderMatchResults: decode(
        json['trajectoryAnyOrderMatchResults'],
        TrajectoryAnyOrderMatchResults.fromJson,
      ),
      trajectoryPrecisionResults: decode(
        json['trajectoryPrecisionResults'],
        TrajectoryPrecisionResults.fromJson,
      ),
      trajectoryRecallResults: decode(
        json['trajectoryRecallResults'],
        TrajectoryRecallResults.fromJson,
      ),
      trajectorySingleToolUseResults: decode(
        json['trajectorySingleToolUseResults'],
        TrajectorySingleToolUseResults.fromJson,
      ),
      rubricBasedInstructionFollowingResult: decode(
        json['rubricBasedInstructionFollowingResult'],
        RubricBasedInstructionFollowingResult.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (exactMatchResults != null)
        'exactMatchResults': exactMatchResults!.toJson(),
      if (bleuResults != null) 'bleuResults': bleuResults!.toJson(),
      if (rougeResults != null) 'rougeResults': rougeResults!.toJson(),
      if (fluencyResult != null) 'fluencyResult': fluencyResult!.toJson(),
      if (coherenceResult != null) 'coherenceResult': coherenceResult!.toJson(),
      if (safetyResult != null) 'safetyResult': safetyResult!.toJson(),
      if (groundednessResult != null)
        'groundednessResult': groundednessResult!.toJson(),
      if (fulfillmentResult != null)
        'fulfillmentResult': fulfillmentResult!.toJson(),
      if (summarizationQualityResult != null)
        'summarizationQualityResult': summarizationQualityResult!.toJson(),
      if (pairwiseSummarizationQualityResult != null)
        'pairwiseSummarizationQualityResult':
            pairwiseSummarizationQualityResult!.toJson(),
      if (summarizationHelpfulnessResult != null)
        'summarizationHelpfulnessResult': summarizationHelpfulnessResult!
            .toJson(),
      if (summarizationVerbosityResult != null)
        'summarizationVerbosityResult': summarizationVerbosityResult!.toJson(),
      if (questionAnsweringQualityResult != null)
        'questionAnsweringQualityResult': questionAnsweringQualityResult!
            .toJson(),
      if (pairwiseQuestionAnsweringQualityResult != null)
        'pairwiseQuestionAnsweringQualityResult':
            pairwiseQuestionAnsweringQualityResult!.toJson(),
      if (questionAnsweringRelevanceResult != null)
        'questionAnsweringRelevanceResult': questionAnsweringRelevanceResult!
            .toJson(),
      if (questionAnsweringHelpfulnessResult != null)
        'questionAnsweringHelpfulnessResult':
            questionAnsweringHelpfulnessResult!.toJson(),
      if (questionAnsweringCorrectnessResult != null)
        'questionAnsweringCorrectnessResult':
            questionAnsweringCorrectnessResult!.toJson(),
      if (pointwiseMetricResult != null)
        'pointwiseMetricResult': pointwiseMetricResult!.toJson(),
      if (pairwiseMetricResult != null)
        'pairwiseMetricResult': pairwiseMetricResult!.toJson(),
      if (toolCallValidResults != null)
        'toolCallValidResults': toolCallValidResults!.toJson(),
      if (toolNameMatchResults != null)
        'toolNameMatchResults': toolNameMatchResults!.toJson(),
      if (toolParameterKeyMatchResults != null)
        'toolParameterKeyMatchResults': toolParameterKeyMatchResults!.toJson(),
      if (toolParameterKvMatchResults != null)
        'toolParameterKvMatchResults': toolParameterKvMatchResults!.toJson(),
      if (cometResult != null) 'cometResult': cometResult!.toJson(),
      if (metricxResult != null) 'metricxResult': metricxResult!.toJson(),
      if (trajectoryExactMatchResults != null)
        'trajectoryExactMatchResults': trajectoryExactMatchResults!.toJson(),
      if (trajectoryInOrderMatchResults != null)
        'trajectoryInOrderMatchResults': trajectoryInOrderMatchResults!
            .toJson(),
      if (trajectoryAnyOrderMatchResults != null)
        'trajectoryAnyOrderMatchResults': trajectoryAnyOrderMatchResults!
            .toJson(),
      if (trajectoryPrecisionResults != null)
        'trajectoryPrecisionResults': trajectoryPrecisionResults!.toJson(),
      if (trajectoryRecallResults != null)
        'trajectoryRecallResults': trajectoryRecallResults!.toJson(),
      if (trajectorySingleToolUseResults != null)
        'trajectorySingleToolUseResults': trajectorySingleToolUseResults!
            .toJson(),
      if (rubricBasedInstructionFollowingResult != null)
        'rubricBasedInstructionFollowingResult':
            rubricBasedInstructionFollowingResult!.toJson(),
    };
  }

  @override
  String toString() => 'EvaluateInstancesResponse()';
}

/// Input for exact match metric.
final class ExactMatchInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchInput';

  /// Required. Spec for exact match metric.
  final ExactMatchSpec? metricSpec;

  /// Required. Repeated exact match instances.
  final List<ExactMatchInstance>? instances;

  ExactMatchInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory ExactMatchInput.fromJson(Map<String, dynamic> json) {
    return ExactMatchInput(
      metricSpec: decode(json['metricSpec'], ExactMatchSpec.fromJson),
      instances: decodeListMessage(
        json['instances'],
        ExactMatchInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'ExactMatchInput()';
}

/// Spec for exact match instance.
final class ExactMatchInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ExactMatchInstance({this.prediction, this.reference})
    : super(fullyQualifiedName);

  factory ExactMatchInstance.fromJson(Map<String, dynamic> json) {
    return ExactMatchInstance(
      prediction: json['prediction'],
      reference: json['reference'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ExactMatchInstance($contents)';
  }
}

/// Spec for exact match metric - returns 1 if prediction and reference exactly
/// matches, otherwise 0.
final class ExactMatchSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchSpec';

  ExactMatchSpec() : super(fullyQualifiedName);

  factory ExactMatchSpec.fromJson(Map<String, dynamic> json) {
    return ExactMatchSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'ExactMatchSpec()';
}

/// Results for exact match metric.
final class ExactMatchResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchResults';

  /// Output only. Exact match metric values.
  final List<ExactMatchMetricValue>? exactMatchMetricValues;

  ExactMatchResults({this.exactMatchMetricValues}) : super(fullyQualifiedName);

  factory ExactMatchResults.fromJson(Map<String, dynamic> json) {
    return ExactMatchResults(
      exactMatchMetricValues: decodeListMessage(
        json['exactMatchMetricValues'],
        ExactMatchMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (exactMatchMetricValues != null)
        'exactMatchMetricValues': encodeList(exactMatchMetricValues),
    };
  }

  @override
  String toString() => 'ExactMatchResults()';
}

/// Exact match metric value for an instance.
final class ExactMatchMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExactMatchMetricValue';

  /// Output only. Exact match score.
  final double? score;

  ExactMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory ExactMatchMetricValue.fromJson(Map<String, dynamic> json) {
    return ExactMatchMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ExactMatchMetricValue($contents)';
  }
}

/// Input for bleu metric.
final class BleuInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuInput';

  /// Required. Spec for bleu score metric.
  final BleuSpec? metricSpec;

  /// Required. Repeated bleu instances.
  final List<BleuInstance>? instances;

  BleuInput({this.metricSpec, this.instances}) : super(fullyQualifiedName);

  factory BleuInput.fromJson(Map<String, dynamic> json) {
    return BleuInput(
      metricSpec: decode(json['metricSpec'], BleuSpec.fromJson),
      instances: decodeListMessage(json['instances'], BleuInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'BleuInput()';
}

/// Spec for bleu instance.
final class BleuInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  BleuInstance({this.prediction, this.reference}) : super(fullyQualifiedName);

  factory BleuInstance.fromJson(Map<String, dynamic> json) {
    return BleuInstance(
      prediction: json['prediction'],
      reference: json['reference'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'BleuInstance($contents)';
  }
}

/// Spec for bleu score metric - calculates the precision of n-grams in the
/// prediction as compared to reference - returns a score ranging between 0 to 1.
final class BleuSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuSpec';

  /// Optional. Whether to use_effective_order to compute bleu score.
  final bool? useEffectiveOrder;

  BleuSpec({this.useEffectiveOrder}) : super(fullyQualifiedName);

  factory BleuSpec.fromJson(Map<String, dynamic> json) {
    return BleuSpec(useEffectiveOrder: json['useEffectiveOrder']);
  }

  @override
  Object toJson() {
    return {
      if (useEffectiveOrder != null) 'useEffectiveOrder': useEffectiveOrder,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useEffectiveOrder != null) 'useEffectiveOrder=$useEffectiveOrder',
    ].join(',');
    return 'BleuSpec($contents)';
  }
}

/// Results for bleu metric.
final class BleuResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuResults';

  /// Output only. Bleu metric values.
  final List<BleuMetricValue>? bleuMetricValues;

  BleuResults({this.bleuMetricValues}) : super(fullyQualifiedName);

  factory BleuResults.fromJson(Map<String, dynamic> json) {
    return BleuResults(
      bleuMetricValues: decodeListMessage(
        json['bleuMetricValues'],
        BleuMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (bleuMetricValues != null)
        'bleuMetricValues': encodeList(bleuMetricValues),
    };
  }

  @override
  String toString() => 'BleuResults()';
}

/// Bleu metric value for an instance.
final class BleuMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BleuMetricValue';

  /// Output only. Bleu score.
  final double? score;

  BleuMetricValue({this.score}) : super(fullyQualifiedName);

  factory BleuMetricValue.fromJson(Map<String, dynamic> json) {
    return BleuMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'BleuMetricValue($contents)';
  }
}

/// Input for rouge metric.
final class RougeInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeInput';

  /// Required. Spec for rouge score metric.
  final RougeSpec? metricSpec;

  /// Required. Repeated rouge instances.
  final List<RougeInstance>? instances;

  RougeInput({this.metricSpec, this.instances}) : super(fullyQualifiedName);

  factory RougeInput.fromJson(Map<String, dynamic> json) {
    return RougeInput(
      metricSpec: decode(json['metricSpec'], RougeSpec.fromJson),
      instances: decodeListMessage(json['instances'], RougeInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'RougeInput()';
}

/// Spec for rouge instance.
final class RougeInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  RougeInstance({this.prediction, this.reference}) : super(fullyQualifiedName);

  factory RougeInstance.fromJson(Map<String, dynamic> json) {
    return RougeInstance(
      prediction: json['prediction'],
      reference: json['reference'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'RougeInstance($contents)';
  }
}

/// Spec for rouge score metric - calculates the recall of n-grams in prediction
/// as compared to reference - returns a score ranging between 0 and 1.
final class RougeSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeSpec';

  /// Optional. Supported rouge types are rougen[1-9], rougeL, and rougeLsum.
  final String? rougeType;

  /// Optional. Whether to use stemmer to compute rouge score.
  final bool? useStemmer;

  /// Optional. Whether to split summaries while using rougeLsum.
  final bool? splitSummaries;

  RougeSpec({this.rougeType, this.useStemmer, this.splitSummaries})
    : super(fullyQualifiedName);

  factory RougeSpec.fromJson(Map<String, dynamic> json) {
    return RougeSpec(
      rougeType: json['rougeType'],
      useStemmer: json['useStemmer'],
      splitSummaries: json['splitSummaries'],
    );
  }

  @override
  Object toJson() {
    return {
      if (rougeType != null) 'rougeType': rougeType,
      if (useStemmer != null) 'useStemmer': useStemmer,
      if (splitSummaries != null) 'splitSummaries': splitSummaries,
    };
  }

  @override
  String toString() {
    final contents = [
      if (rougeType != null) 'rougeType=$rougeType',
      if (useStemmer != null) 'useStemmer=$useStemmer',
      if (splitSummaries != null) 'splitSummaries=$splitSummaries',
    ].join(',');
    return 'RougeSpec($contents)';
  }
}

/// Results for rouge metric.
final class RougeResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeResults';

  /// Output only. Rouge metric values.
  final List<RougeMetricValue>? rougeMetricValues;

  RougeResults({this.rougeMetricValues}) : super(fullyQualifiedName);

  factory RougeResults.fromJson(Map<String, dynamic> json) {
    return RougeResults(
      rougeMetricValues: decodeListMessage(
        json['rougeMetricValues'],
        RougeMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (rougeMetricValues != null)
        'rougeMetricValues': encodeList(rougeMetricValues),
    };
  }

  @override
  String toString() => 'RougeResults()';
}

/// Rouge metric value for an instance.
final class RougeMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RougeMetricValue';

  /// Output only. Rouge score.
  final double? score;

  RougeMetricValue({this.score}) : super(fullyQualifiedName);

  factory RougeMetricValue.fromJson(Map<String, dynamic> json) {
    return RougeMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'RougeMetricValue($contents)';
  }
}

/// Input for coherence metric.
final class CoherenceInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CoherenceInput';

  /// Required. Spec for coherence score metric.
  final CoherenceSpec? metricSpec;

  /// Required. Coherence instance.
  final CoherenceInstance? instance;

  CoherenceInput({this.metricSpec, this.instance}) : super(fullyQualifiedName);

  factory CoherenceInput.fromJson(Map<String, dynamic> json) {
    return CoherenceInput(
      metricSpec: decode(json['metricSpec'], CoherenceSpec.fromJson),
      instance: decode(json['instance'], CoherenceInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'CoherenceInput()';
}

/// Spec for coherence instance.
final class CoherenceInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CoherenceInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  CoherenceInstance({this.prediction}) : super(fullyQualifiedName);

  factory CoherenceInstance.fromJson(Map<String, dynamic> json) {
    return CoherenceInstance(prediction: json['prediction']);
  }

  @override
  Object toJson() {
    return {if (prediction != null) 'prediction': prediction};
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
    ].join(',');
    return 'CoherenceInstance($contents)';
  }
}

/// Spec for coherence score metric.
final class CoherenceSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CoherenceSpec';

  /// Optional. Which version to use for evaluation.
  final int? version;

  CoherenceSpec({this.version}) : super(fullyQualifiedName);

  factory CoherenceSpec.fromJson(Map<String, dynamic> json) {
    return CoherenceSpec(version: json['version']);
  }

  @override
  Object toJson() {
    return {if (version != null) 'version': version};
  }

  @override
  String toString() {
    final contents = [if (version != null) 'version=$version'].join(',');
    return 'CoherenceSpec($contents)';
  }
}

/// Spec for coherence result.
final class CoherenceResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CoherenceResult';

  /// Output only. Coherence score.
  final double? score;

  /// Output only. Explanation for coherence score.
  final String? explanation;

  /// Output only. Confidence for coherence score.
  final double? confidence;

  CoherenceResult({this.score, this.explanation, this.confidence})
    : super(fullyQualifiedName);

  factory CoherenceResult.fromJson(Map<String, dynamic> json) {
    return CoherenceResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'CoherenceResult($contents)';
  }
}

/// Input for fluency metric.
final class FluencyInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FluencyInput';

  /// Required. Spec for fluency score metric.
  final FluencySpec? metricSpec;

  /// Required. Fluency instance.
  final FluencyInstance? instance;

  FluencyInput({this.metricSpec, this.instance}) : super(fullyQualifiedName);

  factory FluencyInput.fromJson(Map<String, dynamic> json) {
    return FluencyInput(
      metricSpec: decode(json['metricSpec'], FluencySpec.fromJson),
      instance: decode(json['instance'], FluencyInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'FluencyInput()';
}

/// Spec for fluency instance.
final class FluencyInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FluencyInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  FluencyInstance({this.prediction}) : super(fullyQualifiedName);

  factory FluencyInstance.fromJson(Map<String, dynamic> json) {
    return FluencyInstance(prediction: json['prediction']);
  }

  @override
  Object toJson() {
    return {if (prediction != null) 'prediction': prediction};
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
    ].join(',');
    return 'FluencyInstance($contents)';
  }
}

/// Spec for fluency score metric.
final class FluencySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FluencySpec';

  /// Optional. Which version to use for evaluation.
  final int? version;

  FluencySpec({this.version}) : super(fullyQualifiedName);

  factory FluencySpec.fromJson(Map<String, dynamic> json) {
    return FluencySpec(version: json['version']);
  }

  @override
  Object toJson() {
    return {if (version != null) 'version': version};
  }

  @override
  String toString() {
    final contents = [if (version != null) 'version=$version'].join(',');
    return 'FluencySpec($contents)';
  }
}

/// Spec for fluency result.
final class FluencyResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FluencyResult';

  /// Output only. Fluency score.
  final double? score;

  /// Output only. Explanation for fluency score.
  final String? explanation;

  /// Output only. Confidence for fluency score.
  final double? confidence;

  FluencyResult({this.score, this.explanation, this.confidence})
    : super(fullyQualifiedName);

  factory FluencyResult.fromJson(Map<String, dynamic> json) {
    return FluencyResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'FluencyResult($contents)';
  }
}

/// Input for safety metric.
final class SafetyInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetyInput';

  /// Required. Spec for safety metric.
  final SafetySpec? metricSpec;

  /// Required. Safety instance.
  final SafetyInstance? instance;

  SafetyInput({this.metricSpec, this.instance}) : super(fullyQualifiedName);

  factory SafetyInput.fromJson(Map<String, dynamic> json) {
    return SafetyInput(
      metricSpec: decode(json['metricSpec'], SafetySpec.fromJson),
      instance: decode(json['instance'], SafetyInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'SafetyInput()';
}

/// Spec for safety instance.
final class SafetyInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetyInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  SafetyInstance({this.prediction}) : super(fullyQualifiedName);

  factory SafetyInstance.fromJson(Map<String, dynamic> json) {
    return SafetyInstance(prediction: json['prediction']);
  }

  @override
  Object toJson() {
    return {if (prediction != null) 'prediction': prediction};
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
    ].join(',');
    return 'SafetyInstance($contents)';
  }
}

/// Spec for safety metric.
final class SafetySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetySpec';

  /// Optional. Which version to use for evaluation.
  final int? version;

  SafetySpec({this.version}) : super(fullyQualifiedName);

  factory SafetySpec.fromJson(Map<String, dynamic> json) {
    return SafetySpec(version: json['version']);
  }

  @override
  Object toJson() {
    return {if (version != null) 'version': version};
  }

  @override
  String toString() {
    final contents = [if (version != null) 'version=$version'].join(',');
    return 'SafetySpec($contents)';
  }
}

/// Spec for safety result.
final class SafetyResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SafetyResult';

  /// Output only. Safety score.
  final double? score;

  /// Output only. Explanation for safety score.
  final String? explanation;

  /// Output only. Confidence for safety score.
  final double? confidence;

  SafetyResult({this.score, this.explanation, this.confidence})
    : super(fullyQualifiedName);

  factory SafetyResult.fromJson(Map<String, dynamic> json) {
    return SafetyResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'SafetyResult($contents)';
  }
}

/// Input for groundedness metric.
final class GroundednessInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundednessInput';

  /// Required. Spec for groundedness metric.
  final GroundednessSpec? metricSpec;

  /// Required. Groundedness instance.
  final GroundednessInstance? instance;

  GroundednessInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory GroundednessInput.fromJson(Map<String, dynamic> json) {
    return GroundednessInput(
      metricSpec: decode(json['metricSpec'], GroundednessSpec.fromJson),
      instance: decode(json['instance'], GroundednessInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'GroundednessInput()';
}

/// Spec for groundedness instance.
final class GroundednessInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundednessInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Background information provided in context used to compare
  /// against the prediction.
  final String? context;

  GroundednessInstance({this.prediction, this.context})
    : super(fullyQualifiedName);

  factory GroundednessInstance.fromJson(Map<String, dynamic> json) {
    return GroundednessInstance(
      prediction: json['prediction'],
      context: json['context'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (context != null) 'context': context,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (context != null) 'context=$context',
    ].join(',');
    return 'GroundednessInstance($contents)';
  }
}

/// Spec for groundedness metric.
final class GroundednessSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundednessSpec';

  /// Optional. Which version to use for evaluation.
  final int? version;

  GroundednessSpec({this.version}) : super(fullyQualifiedName);

  factory GroundednessSpec.fromJson(Map<String, dynamic> json) {
    return GroundednessSpec(version: json['version']);
  }

  @override
  Object toJson() {
    return {if (version != null) 'version': version};
  }

  @override
  String toString() {
    final contents = [if (version != null) 'version=$version'].join(',');
    return 'GroundednessSpec($contents)';
  }
}

/// Spec for groundedness result.
final class GroundednessResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GroundednessResult';

  /// Output only. Groundedness score.
  final double? score;

  /// Output only. Explanation for groundedness score.
  final String? explanation;

  /// Output only. Confidence for groundedness score.
  final double? confidence;

  GroundednessResult({this.score, this.explanation, this.confidence})
    : super(fullyQualifiedName);

  factory GroundednessResult.fromJson(Map<String, dynamic> json) {
    return GroundednessResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'GroundednessResult($contents)';
  }
}

/// Input for fulfillment metric.
final class FulfillmentInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FulfillmentInput';

  /// Required. Spec for fulfillment score metric.
  final FulfillmentSpec? metricSpec;

  /// Required. Fulfillment instance.
  final FulfillmentInstance? instance;

  FulfillmentInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory FulfillmentInput.fromJson(Map<String, dynamic> json) {
    return FulfillmentInput(
      metricSpec: decode(json['metricSpec'], FulfillmentSpec.fromJson),
      instance: decode(json['instance'], FulfillmentInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'FulfillmentInput()';
}

/// Spec for fulfillment instance.
final class FulfillmentInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FulfillmentInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Inference instruction prompt to compare prediction with.
  final String? instruction;

  FulfillmentInstance({this.prediction, this.instruction})
    : super(fullyQualifiedName);

  factory FulfillmentInstance.fromJson(Map<String, dynamic> json) {
    return FulfillmentInstance(
      prediction: json['prediction'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'FulfillmentInstance($contents)';
  }
}

/// Spec for fulfillment metric.
final class FulfillmentSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FulfillmentSpec';

  /// Optional. Which version to use for evaluation.
  final int? version;

  FulfillmentSpec({this.version}) : super(fullyQualifiedName);

  factory FulfillmentSpec.fromJson(Map<String, dynamic> json) {
    return FulfillmentSpec(version: json['version']);
  }

  @override
  Object toJson() {
    return {if (version != null) 'version': version};
  }

  @override
  String toString() {
    final contents = [if (version != null) 'version=$version'].join(',');
    return 'FulfillmentSpec($contents)';
  }
}

/// Spec for fulfillment result.
final class FulfillmentResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FulfillmentResult';

  /// Output only. Fulfillment score.
  final double? score;

  /// Output only. Explanation for fulfillment score.
  final String? explanation;

  /// Output only. Confidence for fulfillment score.
  final double? confidence;

  FulfillmentResult({this.score, this.explanation, this.confidence})
    : super(fullyQualifiedName);

  factory FulfillmentResult.fromJson(Map<String, dynamic> json) {
    return FulfillmentResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'FulfillmentResult($contents)';
  }
}

/// Input for summarization quality metric.
final class SummarizationQualityInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationQualityInput';

  /// Required. Spec for summarization quality score metric.
  final SummarizationQualitySpec? metricSpec;

  /// Required. Summarization quality instance.
  final SummarizationQualityInstance? instance;

  SummarizationQualityInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory SummarizationQualityInput.fromJson(Map<String, dynamic> json) {
    return SummarizationQualityInput(
      metricSpec: decode(json['metricSpec'], SummarizationQualitySpec.fromJson),
      instance: decode(json['instance'], SummarizationQualityInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'SummarizationQualityInput()';
}

/// Spec for summarization quality instance.
final class SummarizationQualityInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationQualityInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to be summarized.
  final String? context;

  /// Required. Summarization prompt for LLM.
  final String? instruction;

  SummarizationQualityInstance({
    this.prediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory SummarizationQualityInstance.fromJson(Map<String, dynamic> json) {
    return SummarizationQualityInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'SummarizationQualityInstance($contents)';
  }
}

/// Spec for summarization quality score metric.
final class SummarizationQualitySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationQualitySpec';

  /// Optional. Whether to use instance.reference to compute summarization
  /// quality.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  SummarizationQualitySpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory SummarizationQualitySpec.fromJson(Map<String, dynamic> json) {
    return SummarizationQualitySpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'SummarizationQualitySpec($contents)';
  }
}

/// Spec for summarization quality result.
final class SummarizationQualityResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationQualityResult';

  /// Output only. Summarization Quality score.
  final double? score;

  /// Output only. Explanation for summarization quality score.
  final String? explanation;

  /// Output only. Confidence for summarization quality score.
  final double? confidence;

  SummarizationQualityResult({this.score, this.explanation, this.confidence})
    : super(fullyQualifiedName);

  factory SummarizationQualityResult.fromJson(Map<String, dynamic> json) {
    return SummarizationQualityResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'SummarizationQualityResult($contents)';
  }
}

/// Input for pairwise summarization quality metric.
final class PairwiseSummarizationQualityInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseSummarizationQualityInput';

  /// Required. Spec for pairwise summarization quality score metric.
  final PairwiseSummarizationQualitySpec? metricSpec;

  /// Required. Pairwise summarization quality instance.
  final PairwiseSummarizationQualityInstance? instance;

  PairwiseSummarizationQualityInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory PairwiseSummarizationQualityInput.fromJson(
    Map<String, dynamic> json,
  ) {
    return PairwiseSummarizationQualityInput(
      metricSpec: decode(
        json['metricSpec'],
        PairwiseSummarizationQualitySpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        PairwiseSummarizationQualityInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'PairwiseSummarizationQualityInput()';
}

/// Spec for pairwise summarization quality instance.
final class PairwiseSummarizationQualityInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseSummarizationQualityInstance';

  /// Required. Output of the candidate model.
  final String? prediction;

  /// Required. Output of the baseline model.
  final String? baselinePrediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to be summarized.
  final String? context;

  /// Required. Summarization prompt for LLM.
  final String? instruction;

  PairwiseSummarizationQualityInstance({
    this.prediction,
    this.baselinePrediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory PairwiseSummarizationQualityInstance.fromJson(
    Map<String, dynamic> json,
  ) {
    return PairwiseSummarizationQualityInstance(
      prediction: json['prediction'],
      baselinePrediction: json['baselinePrediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (baselinePrediction != null) 'baselinePrediction': baselinePrediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (baselinePrediction != null) 'baselinePrediction=$baselinePrediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'PairwiseSummarizationQualityInstance($contents)';
  }
}

/// Spec for pairwise summarization quality score metric.
final class PairwiseSummarizationQualitySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseSummarizationQualitySpec';

  /// Optional. Whether to use instance.reference to compute pairwise
  /// summarization quality.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  PairwiseSummarizationQualitySpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory PairwiseSummarizationQualitySpec.fromJson(Map<String, dynamic> json) {
    return PairwiseSummarizationQualitySpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'PairwiseSummarizationQualitySpec($contents)';
  }
}

/// Spec for pairwise summarization quality result.
final class PairwiseSummarizationQualityResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseSummarizationQualityResult';

  /// Output only. Pairwise summarization prediction choice.
  final PairwiseChoice? pairwiseChoice;

  /// Output only. Explanation for summarization quality score.
  final String? explanation;

  /// Output only. Confidence for summarization quality score.
  final double? confidence;

  PairwiseSummarizationQualityResult({
    this.pairwiseChoice,
    this.explanation,
    this.confidence,
  }) : super(fullyQualifiedName);

  factory PairwiseSummarizationQualityResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return PairwiseSummarizationQualityResult(
      pairwiseChoice: decodeEnum(
        json['pairwiseChoice'],
        PairwiseChoice.fromJson,
      ),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!.toJson(),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (pairwiseChoice != null) 'pairwiseChoice=$pairwiseChoice',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'PairwiseSummarizationQualityResult($contents)';
  }
}

/// Input for summarization helpfulness metric.
final class SummarizationHelpfulnessInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationHelpfulnessInput';

  /// Required. Spec for summarization helpfulness score metric.
  final SummarizationHelpfulnessSpec? metricSpec;

  /// Required. Summarization helpfulness instance.
  final SummarizationHelpfulnessInstance? instance;

  SummarizationHelpfulnessInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory SummarizationHelpfulnessInput.fromJson(Map<String, dynamic> json) {
    return SummarizationHelpfulnessInput(
      metricSpec: decode(
        json['metricSpec'],
        SummarizationHelpfulnessSpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        SummarizationHelpfulnessInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'SummarizationHelpfulnessInput()';
}

/// Spec for summarization helpfulness instance.
final class SummarizationHelpfulnessInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationHelpfulnessInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to be summarized.
  final String? context;

  /// Optional. Summarization prompt for LLM.
  final String? instruction;

  SummarizationHelpfulnessInstance({
    this.prediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory SummarizationHelpfulnessInstance.fromJson(Map<String, dynamic> json) {
    return SummarizationHelpfulnessInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'SummarizationHelpfulnessInstance($contents)';
  }
}

/// Spec for summarization helpfulness score metric.
final class SummarizationHelpfulnessSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationHelpfulnessSpec';

  /// Optional. Whether to use instance.reference to compute summarization
  /// helpfulness.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  SummarizationHelpfulnessSpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory SummarizationHelpfulnessSpec.fromJson(Map<String, dynamic> json) {
    return SummarizationHelpfulnessSpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'SummarizationHelpfulnessSpec($contents)';
  }
}

/// Spec for summarization helpfulness result.
final class SummarizationHelpfulnessResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationHelpfulnessResult';

  /// Output only. Summarization Helpfulness score.
  final double? score;

  /// Output only. Explanation for summarization helpfulness score.
  final String? explanation;

  /// Output only. Confidence for summarization helpfulness score.
  final double? confidence;

  SummarizationHelpfulnessResult({
    this.score,
    this.explanation,
    this.confidence,
  }) : super(fullyQualifiedName);

  factory SummarizationHelpfulnessResult.fromJson(Map<String, dynamic> json) {
    return SummarizationHelpfulnessResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'SummarizationHelpfulnessResult($contents)';
  }
}

/// Input for summarization verbosity metric.
final class SummarizationVerbosityInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationVerbosityInput';

  /// Required. Spec for summarization verbosity score metric.
  final SummarizationVerbositySpec? metricSpec;

  /// Required. Summarization verbosity instance.
  final SummarizationVerbosityInstance? instance;

  SummarizationVerbosityInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory SummarizationVerbosityInput.fromJson(Map<String, dynamic> json) {
    return SummarizationVerbosityInput(
      metricSpec: decode(
        json['metricSpec'],
        SummarizationVerbositySpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        SummarizationVerbosityInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'SummarizationVerbosityInput()';
}

/// Spec for summarization verbosity instance.
final class SummarizationVerbosityInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationVerbosityInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to be summarized.
  final String? context;

  /// Optional. Summarization prompt for LLM.
  final String? instruction;

  SummarizationVerbosityInstance({
    this.prediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory SummarizationVerbosityInstance.fromJson(Map<String, dynamic> json) {
    return SummarizationVerbosityInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'SummarizationVerbosityInstance($contents)';
  }
}

/// Spec for summarization verbosity score metric.
final class SummarizationVerbositySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationVerbositySpec';

  /// Optional. Whether to use instance.reference to compute summarization
  /// verbosity.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  SummarizationVerbositySpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory SummarizationVerbositySpec.fromJson(Map<String, dynamic> json) {
    return SummarizationVerbositySpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'SummarizationVerbositySpec($contents)';
  }
}

/// Spec for summarization verbosity result.
final class SummarizationVerbosityResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SummarizationVerbosityResult';

  /// Output only. Summarization Verbosity score.
  final double? score;

  /// Output only. Explanation for summarization verbosity score.
  final String? explanation;

  /// Output only. Confidence for summarization verbosity score.
  final double? confidence;

  SummarizationVerbosityResult({this.score, this.explanation, this.confidence})
    : super(fullyQualifiedName);

  factory SummarizationVerbosityResult.fromJson(Map<String, dynamic> json) {
    return SummarizationVerbosityResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'SummarizationVerbosityResult($contents)';
  }
}

/// Input for question answering quality metric.
final class QuestionAnsweringQualityInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringQualityInput';

  /// Required. Spec for question answering quality score metric.
  final QuestionAnsweringQualitySpec? metricSpec;

  /// Required. Question answering quality instance.
  final QuestionAnsweringQualityInstance? instance;

  QuestionAnsweringQualityInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory QuestionAnsweringQualityInput.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringQualityInput(
      metricSpec: decode(
        json['metricSpec'],
        QuestionAnsweringQualitySpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        QuestionAnsweringQualityInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'QuestionAnsweringQualityInput()';
}

/// Spec for question answering quality instance.
final class QuestionAnsweringQualityInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringQualityInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to answer the question.
  final String? context;

  /// Required. Question Answering prompt for LLM.
  final String? instruction;

  QuestionAnsweringQualityInstance({
    this.prediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringQualityInstance.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringQualityInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'QuestionAnsweringQualityInstance($contents)';
  }
}

/// Spec for question answering quality score metric.
final class QuestionAnsweringQualitySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringQualitySpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// quality.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  QuestionAnsweringQualitySpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory QuestionAnsweringQualitySpec.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringQualitySpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'QuestionAnsweringQualitySpec($contents)';
  }
}

/// Spec for question answering quality result.
final class QuestionAnsweringQualityResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringQualityResult';

  /// Output only. Question Answering Quality score.
  final double? score;

  /// Output only. Explanation for question answering quality score.
  final String? explanation;

  /// Output only. Confidence for question answering quality score.
  final double? confidence;

  QuestionAnsweringQualityResult({
    this.score,
    this.explanation,
    this.confidence,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringQualityResult.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringQualityResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'QuestionAnsweringQualityResult($contents)';
  }
}

/// Input for pairwise question answering quality metric.
final class PairwiseQuestionAnsweringQualityInput
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseQuestionAnsweringQualityInput';

  /// Required. Spec for pairwise question answering quality score metric.
  final PairwiseQuestionAnsweringQualitySpec? metricSpec;

  /// Required. Pairwise question answering quality instance.
  final PairwiseQuestionAnsweringQualityInstance? instance;

  PairwiseQuestionAnsweringQualityInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory PairwiseQuestionAnsweringQualityInput.fromJson(
    Map<String, dynamic> json,
  ) {
    return PairwiseQuestionAnsweringQualityInput(
      metricSpec: decode(
        json['metricSpec'],
        PairwiseQuestionAnsweringQualitySpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        PairwiseQuestionAnsweringQualityInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'PairwiseQuestionAnsweringQualityInput()';
}

/// Spec for pairwise question answering quality instance.
final class PairwiseQuestionAnsweringQualityInstance
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseQuestionAnsweringQualityInstance';

  /// Required. Output of the candidate model.
  final String? prediction;

  /// Required. Output of the baseline model.
  final String? baselinePrediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Required. Text to answer the question.
  final String? context;

  /// Required. Question Answering prompt for LLM.
  final String? instruction;

  PairwiseQuestionAnsweringQualityInstance({
    this.prediction,
    this.baselinePrediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory PairwiseQuestionAnsweringQualityInstance.fromJson(
    Map<String, dynamic> json,
  ) {
    return PairwiseQuestionAnsweringQualityInstance(
      prediction: json['prediction'],
      baselinePrediction: json['baselinePrediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (baselinePrediction != null) 'baselinePrediction': baselinePrediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (baselinePrediction != null) 'baselinePrediction=$baselinePrediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'PairwiseQuestionAnsweringQualityInstance($contents)';
  }
}

/// Spec for pairwise question answering quality score metric.
final class PairwiseQuestionAnsweringQualitySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseQuestionAnsweringQualitySpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// quality.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  PairwiseQuestionAnsweringQualitySpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory PairwiseQuestionAnsweringQualitySpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return PairwiseQuestionAnsweringQualitySpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'PairwiseQuestionAnsweringQualitySpec($contents)';
  }
}

/// Spec for pairwise question answering quality result.
final class PairwiseQuestionAnsweringQualityResult
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseQuestionAnsweringQualityResult';

  /// Output only. Pairwise question answering prediction choice.
  final PairwiseChoice? pairwiseChoice;

  /// Output only. Explanation for question answering quality score.
  final String? explanation;

  /// Output only. Confidence for question answering quality score.
  final double? confidence;

  PairwiseQuestionAnsweringQualityResult({
    this.pairwiseChoice,
    this.explanation,
    this.confidence,
  }) : super(fullyQualifiedName);

  factory PairwiseQuestionAnsweringQualityResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return PairwiseQuestionAnsweringQualityResult(
      pairwiseChoice: decodeEnum(
        json['pairwiseChoice'],
        PairwiseChoice.fromJson,
      ),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!.toJson(),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (pairwiseChoice != null) 'pairwiseChoice=$pairwiseChoice',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'PairwiseQuestionAnsweringQualityResult($contents)';
  }
}

/// Input for question answering relevance metric.
final class QuestionAnsweringRelevanceInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringRelevanceInput';

  /// Required. Spec for question answering relevance score metric.
  final QuestionAnsweringRelevanceSpec? metricSpec;

  /// Required. Question answering relevance instance.
  final QuestionAnsweringRelevanceInstance? instance;

  QuestionAnsweringRelevanceInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory QuestionAnsweringRelevanceInput.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringRelevanceInput(
      metricSpec: decode(
        json['metricSpec'],
        QuestionAnsweringRelevanceSpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        QuestionAnsweringRelevanceInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'QuestionAnsweringRelevanceInput()';
}

/// Spec for question answering relevance instance.
final class QuestionAnsweringRelevanceInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringRelevanceInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Text provided as context to answer the question.
  final String? context;

  /// Required. The question asked and other instruction in the inference prompt.
  final String? instruction;

  QuestionAnsweringRelevanceInstance({
    this.prediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringRelevanceInstance.fromJson(
    Map<String, dynamic> json,
  ) {
    return QuestionAnsweringRelevanceInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'QuestionAnsweringRelevanceInstance($contents)';
  }
}

/// Spec for question answering relevance metric.
final class QuestionAnsweringRelevanceSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringRelevanceSpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// relevance.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  QuestionAnsweringRelevanceSpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory QuestionAnsweringRelevanceSpec.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringRelevanceSpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'QuestionAnsweringRelevanceSpec($contents)';
  }
}

/// Spec for question answering relevance result.
final class QuestionAnsweringRelevanceResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringRelevanceResult';

  /// Output only. Question Answering Relevance score.
  final double? score;

  /// Output only. Explanation for question answering relevance score.
  final String? explanation;

  /// Output only. Confidence for question answering relevance score.
  final double? confidence;

  QuestionAnsweringRelevanceResult({
    this.score,
    this.explanation,
    this.confidence,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringRelevanceResult.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringRelevanceResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'QuestionAnsweringRelevanceResult($contents)';
  }
}

/// Input for question answering helpfulness metric.
final class QuestionAnsweringHelpfulnessInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringHelpfulnessInput';

  /// Required. Spec for question answering helpfulness score metric.
  final QuestionAnsweringHelpfulnessSpec? metricSpec;

  /// Required. Question answering helpfulness instance.
  final QuestionAnsweringHelpfulnessInstance? instance;

  QuestionAnsweringHelpfulnessInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory QuestionAnsweringHelpfulnessInput.fromJson(
    Map<String, dynamic> json,
  ) {
    return QuestionAnsweringHelpfulnessInput(
      metricSpec: decode(
        json['metricSpec'],
        QuestionAnsweringHelpfulnessSpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        QuestionAnsweringHelpfulnessInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'QuestionAnsweringHelpfulnessInput()';
}

/// Spec for question answering helpfulness instance.
final class QuestionAnsweringHelpfulnessInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringHelpfulnessInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Text provided as context to answer the question.
  final String? context;

  /// Required. The question asked and other instruction in the inference prompt.
  final String? instruction;

  QuestionAnsweringHelpfulnessInstance({
    this.prediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringHelpfulnessInstance.fromJson(
    Map<String, dynamic> json,
  ) {
    return QuestionAnsweringHelpfulnessInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'QuestionAnsweringHelpfulnessInstance($contents)';
  }
}

/// Spec for question answering helpfulness metric.
final class QuestionAnsweringHelpfulnessSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringHelpfulnessSpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// helpfulness.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  QuestionAnsweringHelpfulnessSpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory QuestionAnsweringHelpfulnessSpec.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringHelpfulnessSpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'QuestionAnsweringHelpfulnessSpec($contents)';
  }
}

/// Spec for question answering helpfulness result.
final class QuestionAnsweringHelpfulnessResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringHelpfulnessResult';

  /// Output only. Question Answering Helpfulness score.
  final double? score;

  /// Output only. Explanation for question answering helpfulness score.
  final String? explanation;

  /// Output only. Confidence for question answering helpfulness score.
  final double? confidence;

  QuestionAnsweringHelpfulnessResult({
    this.score,
    this.explanation,
    this.confidence,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringHelpfulnessResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return QuestionAnsweringHelpfulnessResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'QuestionAnsweringHelpfulnessResult($contents)';
  }
}

/// Input for question answering correctness metric.
final class QuestionAnsweringCorrectnessInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringCorrectnessInput';

  /// Required. Spec for question answering correctness score metric.
  final QuestionAnsweringCorrectnessSpec? metricSpec;

  /// Required. Question answering correctness instance.
  final QuestionAnsweringCorrectnessInstance? instance;

  QuestionAnsweringCorrectnessInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory QuestionAnsweringCorrectnessInput.fromJson(
    Map<String, dynamic> json,
  ) {
    return QuestionAnsweringCorrectnessInput(
      metricSpec: decode(
        json['metricSpec'],
        QuestionAnsweringCorrectnessSpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        QuestionAnsweringCorrectnessInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'QuestionAnsweringCorrectnessInput()';
}

/// Spec for question answering correctness instance.
final class QuestionAnsweringCorrectnessInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringCorrectnessInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Text provided as context to answer the question.
  final String? context;

  /// Required. The question asked and other instruction in the inference prompt.
  final String? instruction;

  QuestionAnsweringCorrectnessInstance({
    this.prediction,
    this.reference,
    this.context,
    this.instruction,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringCorrectnessInstance.fromJson(
    Map<String, dynamic> json,
  ) {
    return QuestionAnsweringCorrectnessInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      context: json['context'],
      instruction: json['instruction'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (context != null) 'context': context,
      if (instruction != null) 'instruction': instruction,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (context != null) 'context=$context',
      if (instruction != null) 'instruction=$instruction',
    ].join(',');
    return 'QuestionAnsweringCorrectnessInstance($contents)';
  }
}

/// Spec for question answering correctness metric.
final class QuestionAnsweringCorrectnessSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringCorrectnessSpec';

  /// Optional. Whether to use instance.reference to compute question answering
  /// correctness.
  final bool? useReference;

  /// Optional. Which version to use for evaluation.
  final int? version;

  QuestionAnsweringCorrectnessSpec({this.useReference, this.version})
    : super(fullyQualifiedName);

  factory QuestionAnsweringCorrectnessSpec.fromJson(Map<String, dynamic> json) {
    return QuestionAnsweringCorrectnessSpec(
      useReference: json['useReference'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useReference != null) 'useReference': useReference,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useReference != null) 'useReference=$useReference',
      if (version != null) 'version=$version',
    ].join(',');
    return 'QuestionAnsweringCorrectnessSpec($contents)';
  }
}

/// Spec for question answering correctness result.
final class QuestionAnsweringCorrectnessResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QuestionAnsweringCorrectnessResult';

  /// Output only. Question Answering Correctness score.
  final double? score;

  /// Output only. Explanation for question answering correctness score.
  final String? explanation;

  /// Output only. Confidence for question answering correctness score.
  final double? confidence;

  QuestionAnsweringCorrectnessResult({
    this.score,
    this.explanation,
    this.confidence,
  }) : super(fullyQualifiedName);

  factory QuestionAnsweringCorrectnessResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return QuestionAnsweringCorrectnessResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      confidence: decodeDouble(json['confidence']),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (confidence != null) 'confidence': encodeDouble(confidence),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
      if (confidence != null) 'confidence=$confidence',
    ].join(',');
    return 'QuestionAnsweringCorrectnessResult($contents)';
  }
}

/// Input for pointwise metric.
final class PointwiseMetricInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PointwiseMetricInput';

  /// Required. Spec for pointwise metric.
  final PointwiseMetricSpec? metricSpec;

  /// Required. Pointwise metric instance.
  final PointwiseMetricInstance? instance;

  PointwiseMetricInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory PointwiseMetricInput.fromJson(Map<String, dynamic> json) {
    return PointwiseMetricInput(
      metricSpec: decode(json['metricSpec'], PointwiseMetricSpec.fromJson),
      instance: decode(json['instance'], PointwiseMetricInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'PointwiseMetricInput()';
}

/// Pointwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
final class PointwiseMetricInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PointwiseMetricInstance';

  /// Instance specified as a json string. String key-value pairs are expected
  /// in the json_instance to render
  /// PointwiseMetricSpec.instance_prompt_template.
  final String? jsonInstance;

  /// Key-value contents for the mutlimodality input, including text, image,
  /// video, audio, and pdf, etc. The key is placeholder in metric prompt
  /// template, and the value is the multimodal content.
  final ContentMap? contentMapInstance;

  PointwiseMetricInstance({this.jsonInstance, this.contentMapInstance})
    : super(fullyQualifiedName);

  factory PointwiseMetricInstance.fromJson(Map<String, dynamic> json) {
    return PointwiseMetricInstance(
      jsonInstance: json['jsonInstance'],
      contentMapInstance: decode(
        json['contentMapInstance'],
        ContentMap.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (jsonInstance != null) 'jsonInstance': jsonInstance,
      if (contentMapInstance != null)
        'contentMapInstance': contentMapInstance!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (jsonInstance != null) 'jsonInstance=$jsonInstance',
    ].join(',');
    return 'PointwiseMetricInstance($contents)';
  }
}

/// Spec for pointwise metric.
final class PointwiseMetricSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PointwiseMetricSpec';

  /// Required. Metric prompt template for pointwise metric.
  final String? metricPromptTemplate;

  /// Optional. System instructions for pointwise metric.
  final String? systemInstruction;

  /// Optional. CustomOutputFormatConfig allows customization of metric output.
  /// By default, metrics return a score and explanation.
  /// When this config is set, the default output is replaced with either:
  ///  - The raw output string.
  ///  - A parsed output based on a user-defined schema.
  /// If a custom format is chosen, the `score` and `explanation` fields in the
  /// corresponding metric result will be empty.
  final CustomOutputFormatConfig? customOutputFormatConfig;

  PointwiseMetricSpec({
    this.metricPromptTemplate,
    this.systemInstruction,
    this.customOutputFormatConfig,
  }) : super(fullyQualifiedName);

  factory PointwiseMetricSpec.fromJson(Map<String, dynamic> json) {
    return PointwiseMetricSpec(
      metricPromptTemplate: json['metricPromptTemplate'],
      systemInstruction: json['systemInstruction'],
      customOutputFormatConfig: decode(
        json['customOutputFormatConfig'],
        CustomOutputFormatConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricPromptTemplate != null)
        'metricPromptTemplate': metricPromptTemplate,
      if (systemInstruction != null) 'systemInstruction': systemInstruction,
      if (customOutputFormatConfig != null)
        'customOutputFormatConfig': customOutputFormatConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (metricPromptTemplate != null)
        'metricPromptTemplate=$metricPromptTemplate',
      if (systemInstruction != null) 'systemInstruction=$systemInstruction',
    ].join(',');
    return 'PointwiseMetricSpec($contents)';
  }
}

/// Spec for custom output format configuration.
final class CustomOutputFormatConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CustomOutputFormatConfig';

  /// Optional. Whether to return raw output.
  final bool? returnRawOutput;

  CustomOutputFormatConfig({this.returnRawOutput}) : super(fullyQualifiedName);

  factory CustomOutputFormatConfig.fromJson(Map<String, dynamic> json) {
    return CustomOutputFormatConfig(returnRawOutput: json['returnRawOutput']);
  }

  @override
  Object toJson() {
    return {if (returnRawOutput != null) 'returnRawOutput': returnRawOutput};
  }

  @override
  String toString() {
    final contents = [
      if (returnRawOutput != null) 'returnRawOutput=$returnRawOutput',
    ].join(',');
    return 'CustomOutputFormatConfig($contents)';
  }
}

/// Spec for pointwise metric result.
final class PointwiseMetricResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PointwiseMetricResult';

  /// Output only. Pointwise metric score.
  final double? score;

  /// Output only. Explanation for pointwise metric score.
  final String? explanation;

  /// Output only. Spec for custom output.
  final CustomOutput? customOutput;

  PointwiseMetricResult({this.score, this.explanation, this.customOutput})
    : super(fullyQualifiedName);

  factory PointwiseMetricResult.fromJson(Map<String, dynamic> json) {
    return PointwiseMetricResult(
      score: decodeDouble(json['score']),
      explanation: json['explanation'],
      customOutput: decode(json['customOutput'], CustomOutput.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (explanation != null) 'explanation': explanation,
      if (customOutput != null) 'customOutput': customOutput!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (explanation != null) 'explanation=$explanation',
    ].join(',');
    return 'PointwiseMetricResult($contents)';
  }
}

/// Spec for custom output.
final class CustomOutput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CustomOutput';

  /// Output only. List of raw output strings.
  final RawOutput? rawOutputs;

  CustomOutput({this.rawOutputs}) : super(fullyQualifiedName);

  factory CustomOutput.fromJson(Map<String, dynamic> json) {
    return CustomOutput(
      rawOutputs: decode(json['rawOutputs'], RawOutput.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (rawOutputs != null) 'rawOutputs': rawOutputs!.toJson()};
  }

  @override
  String toString() => 'CustomOutput()';
}

/// Raw output.
final class RawOutput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RawOutput';

  /// Output only. Raw output string.
  final List<String>? rawOutput;

  RawOutput({this.rawOutput}) : super(fullyQualifiedName);

  factory RawOutput.fromJson(Map<String, dynamic> json) {
    return RawOutput(rawOutput: decodeList(json['rawOutput']));
  }

  @override
  Object toJson() {
    return {if (rawOutput != null) 'rawOutput': rawOutput};
  }

  @override
  String toString() => 'RawOutput()';
}

/// Input for pairwise metric.
final class PairwiseMetricInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseMetricInput';

  /// Required. Spec for pairwise metric.
  final PairwiseMetricSpec? metricSpec;

  /// Required. Pairwise metric instance.
  final PairwiseMetricInstance? instance;

  PairwiseMetricInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory PairwiseMetricInput.fromJson(Map<String, dynamic> json) {
    return PairwiseMetricInput(
      metricSpec: decode(json['metricSpec'], PairwiseMetricSpec.fromJson),
      instance: decode(json['instance'], PairwiseMetricInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'PairwiseMetricInput()';
}

/// Pairwise metric instance. Usually one instance corresponds to one row in an
/// evaluation dataset.
final class PairwiseMetricInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseMetricInstance';

  /// Instance specified as a json string. String key-value pairs are expected
  /// in the json_instance to render
  /// PairwiseMetricSpec.instance_prompt_template.
  final String? jsonInstance;

  /// Key-value contents for the mutlimodality input, including text, image,
  /// video, audio, and pdf, etc. The key is placeholder in metric prompt
  /// template, and the value is the multimodal content.
  final ContentMap? contentMapInstance;

  PairwiseMetricInstance({this.jsonInstance, this.contentMapInstance})
    : super(fullyQualifiedName);

  factory PairwiseMetricInstance.fromJson(Map<String, dynamic> json) {
    return PairwiseMetricInstance(
      jsonInstance: json['jsonInstance'],
      contentMapInstance: decode(
        json['contentMapInstance'],
        ContentMap.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (jsonInstance != null) 'jsonInstance': jsonInstance,
      if (contentMapInstance != null)
        'contentMapInstance': contentMapInstance!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (jsonInstance != null) 'jsonInstance=$jsonInstance',
    ].join(',');
    return 'PairwiseMetricInstance($contents)';
  }
}

/// Spec for pairwise metric.
final class PairwiseMetricSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseMetricSpec';

  /// Required. Metric prompt template for pairwise metric.
  final String? metricPromptTemplate;

  /// Optional. The field name of the candidate response.
  final String? candidateResponseFieldName;

  /// Optional. The field name of the baseline response.
  final String? baselineResponseFieldName;

  /// Optional. System instructions for pairwise metric.
  final String? systemInstruction;

  /// Optional. CustomOutputFormatConfig allows customization of metric output.
  /// When this config is set, the default output is replaced with
  /// the raw output string.
  /// If a custom format is chosen, the `pairwise_choice` and `explanation`
  /// fields in the corresponding metric result will be empty.
  final CustomOutputFormatConfig? customOutputFormatConfig;

  PairwiseMetricSpec({
    this.metricPromptTemplate,
    this.candidateResponseFieldName,
    this.baselineResponseFieldName,
    this.systemInstruction,
    this.customOutputFormatConfig,
  }) : super(fullyQualifiedName);

  factory PairwiseMetricSpec.fromJson(Map<String, dynamic> json) {
    return PairwiseMetricSpec(
      metricPromptTemplate: json['metricPromptTemplate'],
      candidateResponseFieldName: json['candidateResponseFieldName'],
      baselineResponseFieldName: json['baselineResponseFieldName'],
      systemInstruction: json['systemInstruction'],
      customOutputFormatConfig: decode(
        json['customOutputFormatConfig'],
        CustomOutputFormatConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricPromptTemplate != null)
        'metricPromptTemplate': metricPromptTemplate,
      if (candidateResponseFieldName != null)
        'candidateResponseFieldName': candidateResponseFieldName,
      if (baselineResponseFieldName != null)
        'baselineResponseFieldName': baselineResponseFieldName,
      if (systemInstruction != null) 'systemInstruction': systemInstruction,
      if (customOutputFormatConfig != null)
        'customOutputFormatConfig': customOutputFormatConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (metricPromptTemplate != null)
        'metricPromptTemplate=$metricPromptTemplate',
      if (candidateResponseFieldName != null)
        'candidateResponseFieldName=$candidateResponseFieldName',
      if (baselineResponseFieldName != null)
        'baselineResponseFieldName=$baselineResponseFieldName',
      if (systemInstruction != null) 'systemInstruction=$systemInstruction',
    ].join(',');
    return 'PairwiseMetricSpec($contents)';
  }
}

/// Spec for pairwise metric result.
final class PairwiseMetricResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PairwiseMetricResult';

  /// Output only. Pairwise metric choice.
  final PairwiseChoice? pairwiseChoice;

  /// Output only. Explanation for pairwise metric score.
  final String? explanation;

  /// Output only. Spec for custom output.
  final CustomOutput? customOutput;

  PairwiseMetricResult({
    this.pairwiseChoice,
    this.explanation,
    this.customOutput,
  }) : super(fullyQualifiedName);

  factory PairwiseMetricResult.fromJson(Map<String, dynamic> json) {
    return PairwiseMetricResult(
      pairwiseChoice: decodeEnum(
        json['pairwiseChoice'],
        PairwiseChoice.fromJson,
      ),
      explanation: json['explanation'],
      customOutput: decode(json['customOutput'], CustomOutput.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (pairwiseChoice != null) 'pairwiseChoice': pairwiseChoice!.toJson(),
      if (explanation != null) 'explanation': explanation,
      if (customOutput != null) 'customOutput': customOutput!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (pairwiseChoice != null) 'pairwiseChoice=$pairwiseChoice',
      if (explanation != null) 'explanation=$explanation',
    ].join(',');
    return 'PairwiseMetricResult($contents)';
  }
}

/// Input for tool call valid metric.
final class ToolCallValidInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidInput';

  /// Required. Spec for tool call valid metric.
  final ToolCallValidSpec? metricSpec;

  /// Required. Repeated tool call valid instances.
  final List<ToolCallValidInstance>? instances;

  ToolCallValidInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory ToolCallValidInput.fromJson(Map<String, dynamic> json) {
    return ToolCallValidInput(
      metricSpec: decode(json['metricSpec'], ToolCallValidSpec.fromJson),
      instances: decodeListMessage(
        json['instances'],
        ToolCallValidInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'ToolCallValidInput()';
}

/// Spec for tool call valid metric.
final class ToolCallValidSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidSpec';

  ToolCallValidSpec() : super(fullyQualifiedName);

  factory ToolCallValidSpec.fromJson(Map<String, dynamic> json) {
    return ToolCallValidSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'ToolCallValidSpec()';
}

/// Spec for tool call valid instance.
final class ToolCallValidInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ToolCallValidInstance({this.prediction, this.reference})
    : super(fullyQualifiedName);

  factory ToolCallValidInstance.fromJson(Map<String, dynamic> json) {
    return ToolCallValidInstance(
      prediction: json['prediction'],
      reference: json['reference'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ToolCallValidInstance($contents)';
  }
}

/// Results for tool call valid metric.
final class ToolCallValidResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidResults';

  /// Output only. Tool call valid metric values.
  final List<ToolCallValidMetricValue>? toolCallValidMetricValues;

  ToolCallValidResults({this.toolCallValidMetricValues})
    : super(fullyQualifiedName);

  factory ToolCallValidResults.fromJson(Map<String, dynamic> json) {
    return ToolCallValidResults(
      toolCallValidMetricValues: decodeListMessage(
        json['toolCallValidMetricValues'],
        ToolCallValidMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (toolCallValidMetricValues != null)
        'toolCallValidMetricValues': encodeList(toolCallValidMetricValues),
    };
  }

  @override
  String toString() => 'ToolCallValidResults()';
}

/// Tool call valid metric value for an instance.
final class ToolCallValidMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCallValidMetricValue';

  /// Output only. Tool call valid score.
  final double? score;

  ToolCallValidMetricValue({this.score}) : super(fullyQualifiedName);

  factory ToolCallValidMetricValue.fromJson(Map<String, dynamic> json) {
    return ToolCallValidMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ToolCallValidMetricValue($contents)';
  }
}

/// Input for tool name match metric.
final class ToolNameMatchInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchInput';

  /// Required. Spec for tool name match metric.
  final ToolNameMatchSpec? metricSpec;

  /// Required. Repeated tool name match instances.
  final List<ToolNameMatchInstance>? instances;

  ToolNameMatchInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory ToolNameMatchInput.fromJson(Map<String, dynamic> json) {
    return ToolNameMatchInput(
      metricSpec: decode(json['metricSpec'], ToolNameMatchSpec.fromJson),
      instances: decodeListMessage(
        json['instances'],
        ToolNameMatchInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'ToolNameMatchInput()';
}

/// Spec for tool name match metric.
final class ToolNameMatchSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchSpec';

  ToolNameMatchSpec() : super(fullyQualifiedName);

  factory ToolNameMatchSpec.fromJson(Map<String, dynamic> json) {
    return ToolNameMatchSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'ToolNameMatchSpec()';
}

/// Spec for tool name match instance.
final class ToolNameMatchInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ToolNameMatchInstance({this.prediction, this.reference})
    : super(fullyQualifiedName);

  factory ToolNameMatchInstance.fromJson(Map<String, dynamic> json) {
    return ToolNameMatchInstance(
      prediction: json['prediction'],
      reference: json['reference'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ToolNameMatchInstance($contents)';
  }
}

/// Results for tool name match metric.
final class ToolNameMatchResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchResults';

  /// Output only. Tool name match metric values.
  final List<ToolNameMatchMetricValue>? toolNameMatchMetricValues;

  ToolNameMatchResults({this.toolNameMatchMetricValues})
    : super(fullyQualifiedName);

  factory ToolNameMatchResults.fromJson(Map<String, dynamic> json) {
    return ToolNameMatchResults(
      toolNameMatchMetricValues: decodeListMessage(
        json['toolNameMatchMetricValues'],
        ToolNameMatchMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (toolNameMatchMetricValues != null)
        'toolNameMatchMetricValues': encodeList(toolNameMatchMetricValues),
    };
  }

  @override
  String toString() => 'ToolNameMatchResults()';
}

/// Tool name match metric value for an instance.
final class ToolNameMatchMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolNameMatchMetricValue';

  /// Output only. Tool name match score.
  final double? score;

  ToolNameMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory ToolNameMatchMetricValue.fromJson(Map<String, dynamic> json) {
    return ToolNameMatchMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ToolNameMatchMetricValue($contents)';
  }
}

/// Input for tool parameter key match metric.
final class ToolParameterKeyMatchInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchInput';

  /// Required. Spec for tool parameter key match metric.
  final ToolParameterKeyMatchSpec? metricSpec;

  /// Required. Repeated tool parameter key match instances.
  final List<ToolParameterKeyMatchInstance>? instances;

  ToolParameterKeyMatchInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory ToolParameterKeyMatchInput.fromJson(Map<String, dynamic> json) {
    return ToolParameterKeyMatchInput(
      metricSpec: decode(
        json['metricSpec'],
        ToolParameterKeyMatchSpec.fromJson,
      ),
      instances: decodeListMessage(
        json['instances'],
        ToolParameterKeyMatchInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'ToolParameterKeyMatchInput()';
}

/// Spec for tool parameter key match metric.
final class ToolParameterKeyMatchSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchSpec';

  ToolParameterKeyMatchSpec() : super(fullyQualifiedName);

  factory ToolParameterKeyMatchSpec.fromJson(Map<String, dynamic> json) {
    return ToolParameterKeyMatchSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'ToolParameterKeyMatchSpec()';
}

/// Spec for tool parameter key match instance.
final class ToolParameterKeyMatchInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ToolParameterKeyMatchInstance({this.prediction, this.reference})
    : super(fullyQualifiedName);

  factory ToolParameterKeyMatchInstance.fromJson(Map<String, dynamic> json) {
    return ToolParameterKeyMatchInstance(
      prediction: json['prediction'],
      reference: json['reference'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ToolParameterKeyMatchInstance($contents)';
  }
}

/// Results for tool parameter key match metric.
final class ToolParameterKeyMatchResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchResults';

  /// Output only. Tool parameter key match metric values.
  final List<ToolParameterKeyMatchMetricValue>?
  toolParameterKeyMatchMetricValues;

  ToolParameterKeyMatchResults({this.toolParameterKeyMatchMetricValues})
    : super(fullyQualifiedName);

  factory ToolParameterKeyMatchResults.fromJson(Map<String, dynamic> json) {
    return ToolParameterKeyMatchResults(
      toolParameterKeyMatchMetricValues: decodeListMessage(
        json['toolParameterKeyMatchMetricValues'],
        ToolParameterKeyMatchMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (toolParameterKeyMatchMetricValues != null)
        'toolParameterKeyMatchMetricValues': encodeList(
          toolParameterKeyMatchMetricValues,
        ),
    };
  }

  @override
  String toString() => 'ToolParameterKeyMatchResults()';
}

/// Tool parameter key match metric value for an instance.
final class ToolParameterKeyMatchMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKeyMatchMetricValue';

  /// Output only. Tool parameter key match score.
  final double? score;

  ToolParameterKeyMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory ToolParameterKeyMatchMetricValue.fromJson(Map<String, dynamic> json) {
    return ToolParameterKeyMatchMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ToolParameterKeyMatchMetricValue($contents)';
  }
}

/// Input for tool parameter key value match metric.
final class ToolParameterKvmatchInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchInput';

  /// Required. Spec for tool parameter key value match metric.
  final ToolParameterKvmatchSpec? metricSpec;

  /// Required. Repeated tool parameter key value match instances.
  final List<ToolParameterKvmatchInstance>? instances;

  ToolParameterKvmatchInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory ToolParameterKvmatchInput.fromJson(Map<String, dynamic> json) {
    return ToolParameterKvmatchInput(
      metricSpec: decode(json['metricSpec'], ToolParameterKvmatchSpec.fromJson),
      instances: decodeListMessage(
        json['instances'],
        ToolParameterKvmatchInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'ToolParameterKVMatchInput()';
}

/// Spec for tool parameter key value match metric.
final class ToolParameterKvmatchSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchSpec';

  /// Optional. Whether to use STRICT string match on parameter values.
  final bool? useStrictStringMatch;

  ToolParameterKvmatchSpec({this.useStrictStringMatch})
    : super(fullyQualifiedName);

  factory ToolParameterKvmatchSpec.fromJson(Map<String, dynamic> json) {
    return ToolParameterKvmatchSpec(
      useStrictStringMatch: json['useStrictStringMatch'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useStrictStringMatch != null)
        'useStrictStringMatch': useStrictStringMatch,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useStrictStringMatch != null)
        'useStrictStringMatch=$useStrictStringMatch',
    ].join(',');
    return 'ToolParameterKVMatchSpec($contents)';
  }
}

/// Spec for tool parameter key value match instance.
final class ToolParameterKvmatchInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Required. Ground truth used to compare against the prediction.
  final String? reference;

  ToolParameterKvmatchInstance({this.prediction, this.reference})
    : super(fullyQualifiedName);

  factory ToolParameterKvmatchInstance.fromJson(Map<String, dynamic> json) {
    return ToolParameterKvmatchInstance(
      prediction: json['prediction'],
      reference: json['reference'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
    ].join(',');
    return 'ToolParameterKVMatchInstance($contents)';
  }
}

/// Results for tool parameter key value match metric.
final class ToolParameterKvmatchResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchResults';

  /// Output only. Tool parameter key value match metric values.
  final List<ToolParameterKvmatchMetricValue>? toolParameterKvMatchMetricValues;

  ToolParameterKvmatchResults({this.toolParameterKvMatchMetricValues})
    : super(fullyQualifiedName);

  factory ToolParameterKvmatchResults.fromJson(Map<String, dynamic> json) {
    return ToolParameterKvmatchResults(
      toolParameterKvMatchMetricValues: decodeListMessage(
        json['toolParameterKvMatchMetricValues'],
        ToolParameterKvmatchMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (toolParameterKvMatchMetricValues != null)
        'toolParameterKvMatchMetricValues': encodeList(
          toolParameterKvMatchMetricValues,
        ),
    };
  }

  @override
  String toString() => 'ToolParameterKVMatchResults()';
}

/// Tool parameter key value match metric value for an instance.
final class ToolParameterKvmatchMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolParameterKVMatchMetricValue';

  /// Output only. Tool parameter key value match score.
  final double? score;

  ToolParameterKvmatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory ToolParameterKvmatchMetricValue.fromJson(Map<String, dynamic> json) {
    return ToolParameterKvmatchMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'ToolParameterKVMatchMetricValue($contents)';
  }
}

/// Input for Comet metric.
final class CometInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CometInput';

  /// Required. Spec for comet metric.
  final CometSpec? metricSpec;

  /// Required. Comet instance.
  final CometInstance? instance;

  CometInput({this.metricSpec, this.instance}) : super(fullyQualifiedName);

  factory CometInput.fromJson(Map<String, dynamic> json) {
    return CometInput(
      metricSpec: decode(json['metricSpec'], CometSpec.fromJson),
      instance: decode(json['instance'], CometInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'CometInput()';
}

/// Spec for Comet metric.
final class CometSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CometSpec';

  /// Required. Which version to use for evaluation.
  final CometSpec_CometVersion? version;

  /// Optional. Source language in BCP-47 format.
  final String? sourceLanguage;

  /// Optional. Target language in BCP-47 format. Covers both prediction and
  /// reference.
  final String? targetLanguage;

  CometSpec({this.version, this.sourceLanguage, this.targetLanguage})
    : super(fullyQualifiedName);

  factory CometSpec.fromJson(Map<String, dynamic> json) {
    return CometSpec(
      version: decodeEnum(json['version'], CometSpec_CometVersion.fromJson),
      sourceLanguage: json['sourceLanguage'],
      targetLanguage: json['targetLanguage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (version != null) 'version': version!.toJson(),
      if (sourceLanguage != null) 'sourceLanguage': sourceLanguage,
      if (targetLanguage != null) 'targetLanguage': targetLanguage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (version != null) 'version=$version',
      if (sourceLanguage != null) 'sourceLanguage=$sourceLanguage',
      if (targetLanguage != null) 'targetLanguage=$targetLanguage',
    ].join(',');
    return 'CometSpec($contents)';
  }
}

/// Comet version options.
final class CometSpec_CometVersion extends protobuf.ProtoEnum {
  /// Comet version unspecified.
  static const cometVersionUnspecified = CometSpec_CometVersion(
    'COMET_VERSION_UNSPECIFIED',
  );

  /// Comet 22 for translation + source + reference
  /// (source-reference-combined).
  static const comet22SrcRef = CometSpec_CometVersion('COMET_22_SRC_REF');

  const CometSpec_CometVersion(super.value);

  factory CometSpec_CometVersion.fromJson(String json) =>
      CometSpec_CometVersion(json);

  @override
  String toString() => 'CometVersion.$value';
}

/// Spec for Comet instance - The fields used for evaluation are dependent on the
/// comet version.
final class CometInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CometInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Source text in original language.
  final String? source;

  CometInstance({this.prediction, this.reference, this.source})
    : super(fullyQualifiedName);

  factory CometInstance.fromJson(Map<String, dynamic> json) {
    return CometInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      source: json['source'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (source != null) 'source': source,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (source != null) 'source=$source',
    ].join(',');
    return 'CometInstance($contents)';
  }
}

/// Spec for Comet result - calculates the comet score for the given instance
/// using the version specified in the spec.
final class CometResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CometResult';

  /// Output only. Comet score. Range depends on version.
  final double? score;

  CometResult({this.score}) : super(fullyQualifiedName);

  factory CometResult.fromJson(Map<String, dynamic> json) {
    return CometResult(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'CometResult($contents)';
  }
}

/// Input for MetricX metric.
final class MetricxInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetricxInput';

  /// Required. Spec for Metricx metric.
  final MetricxSpec? metricSpec;

  /// Required. Metricx instance.
  final MetricxInstance? instance;

  MetricxInput({this.metricSpec, this.instance}) : super(fullyQualifiedName);

  factory MetricxInput.fromJson(Map<String, dynamic> json) {
    return MetricxInput(
      metricSpec: decode(json['metricSpec'], MetricxSpec.fromJson),
      instance: decode(json['instance'], MetricxInstance.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'MetricxInput()';
}

/// Spec for MetricX metric.
final class MetricxSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetricxSpec';

  /// Required. Which version to use for evaluation.
  final MetricxSpec_MetricxVersion? version;

  /// Optional. Source language in BCP-47 format.
  final String? sourceLanguage;

  /// Optional. Target language in BCP-47 format. Covers both prediction and
  /// reference.
  final String? targetLanguage;

  MetricxSpec({this.version, this.sourceLanguage, this.targetLanguage})
    : super(fullyQualifiedName);

  factory MetricxSpec.fromJson(Map<String, dynamic> json) {
    return MetricxSpec(
      version: decodeEnum(json['version'], MetricxSpec_MetricxVersion.fromJson),
      sourceLanguage: json['sourceLanguage'],
      targetLanguage: json['targetLanguage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (version != null) 'version': version!.toJson(),
      if (sourceLanguage != null) 'sourceLanguage': sourceLanguage,
      if (targetLanguage != null) 'targetLanguage': targetLanguage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (version != null) 'version=$version',
      if (sourceLanguage != null) 'sourceLanguage=$sourceLanguage',
      if (targetLanguage != null) 'targetLanguage=$targetLanguage',
    ].join(',');
    return 'MetricxSpec($contents)';
  }
}

/// MetricX Version options.
final class MetricxSpec_MetricxVersion extends protobuf.ProtoEnum {
  /// MetricX version unspecified.
  static const metricxVersionUnspecified = MetricxSpec_MetricxVersion(
    'METRICX_VERSION_UNSPECIFIED',
  );

  /// MetricX 2024 (2.6) for translation + reference (reference-based).
  static const metricx24Ref = MetricxSpec_MetricxVersion('METRICX_24_REF');

  /// MetricX 2024 (2.6) for translation + source (QE).
  static const metricx24Src = MetricxSpec_MetricxVersion('METRICX_24_SRC');

  /// MetricX 2024 (2.6) for translation + source + reference
  /// (source-reference-combined).
  static const metricx24SrcRef = MetricxSpec_MetricxVersion(
    'METRICX_24_SRC_REF',
  );

  const MetricxSpec_MetricxVersion(super.value);

  factory MetricxSpec_MetricxVersion.fromJson(String json) =>
      MetricxSpec_MetricxVersion(json);

  @override
  String toString() => 'MetricxVersion.$value';
}

/// Spec for MetricX instance - The fields used for evaluation are dependent on
/// the MetricX version.
final class MetricxInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetricxInstance';

  /// Required. Output of the evaluated model.
  final String? prediction;

  /// Optional. Ground truth used to compare against the prediction.
  final String? reference;

  /// Optional. Source text in original language.
  final String? source;

  MetricxInstance({this.prediction, this.reference, this.source})
    : super(fullyQualifiedName);

  factory MetricxInstance.fromJson(Map<String, dynamic> json) {
    return MetricxInstance(
      prediction: json['prediction'],
      reference: json['reference'],
      source: json['source'],
    );
  }

  @override
  Object toJson() {
    return {
      if (prediction != null) 'prediction': prediction,
      if (reference != null) 'reference': reference,
      if (source != null) 'source': source,
    };
  }

  @override
  String toString() {
    final contents = [
      if (prediction != null) 'prediction=$prediction',
      if (reference != null) 'reference=$reference',
      if (source != null) 'source=$source',
    ].join(',');
    return 'MetricxInstance($contents)';
  }
}

/// Spec for MetricX result - calculates the MetricX score for the given instance
/// using the version specified in the spec.
final class MetricxResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetricxResult';

  /// Output only. MetricX score. Range depends on version.
  final double? score;

  MetricxResult({this.score}) : super(fullyQualifiedName);

  factory MetricxResult.fromJson(Map<String, dynamic> json) {
    return MetricxResult(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'MetricxResult($contents)';
  }
}

/// Instance and metric spec for RubricBasedInstructionFollowing metric.
final class RubricBasedInstructionFollowingInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricBasedInstructionFollowingInput';

  /// Required. Spec for RubricBasedInstructionFollowing metric.
  final RubricBasedInstructionFollowingSpec? metricSpec;

  /// Required. Instance for RubricBasedInstructionFollowing metric.
  final RubricBasedInstructionFollowingInstance? instance;

  RubricBasedInstructionFollowingInput({this.metricSpec, this.instance})
    : super(fullyQualifiedName);

  factory RubricBasedInstructionFollowingInput.fromJson(
    Map<String, dynamic> json,
  ) {
    return RubricBasedInstructionFollowingInput(
      metricSpec: decode(
        json['metricSpec'],
        RubricBasedInstructionFollowingSpec.fromJson,
      ),
      instance: decode(
        json['instance'],
        RubricBasedInstructionFollowingInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instance != null) 'instance': instance!.toJson(),
    };
  }

  @override
  String toString() => 'RubricBasedInstructionFollowingInput()';
}

/// Instance for RubricBasedInstructionFollowing metric - one instance
/// corresponds to one row in an evaluation dataset.
final class RubricBasedInstructionFollowingInstance
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricBasedInstructionFollowingInstance';

  /// Required. Instance specified as a json string. String key-value pairs are
  /// expected in the json_instance to render RubricBasedInstructionFollowing
  /// prompt templates.
  final String? jsonInstance;

  RubricBasedInstructionFollowingInstance({this.jsonInstance})
    : super(fullyQualifiedName);

  factory RubricBasedInstructionFollowingInstance.fromJson(
    Map<String, dynamic> json,
  ) {
    return RubricBasedInstructionFollowingInstance(
      jsonInstance: json['jsonInstance'],
    );
  }

  @override
  Object toJson() {
    return {if (jsonInstance != null) 'jsonInstance': jsonInstance};
  }

  @override
  String toString() {
    final contents = [
      if (jsonInstance != null) 'jsonInstance=$jsonInstance',
    ].join(',');
    return 'RubricBasedInstructionFollowingInstance($contents)';
  }
}

/// Spec for RubricBasedInstructionFollowing metric - returns rubrics
/// and verdicts corresponding to rubrics along with overall score.
final class RubricBasedInstructionFollowingSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricBasedInstructionFollowingSpec';

  RubricBasedInstructionFollowingSpec() : super(fullyQualifiedName);

  factory RubricBasedInstructionFollowingSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return RubricBasedInstructionFollowingSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'RubricBasedInstructionFollowingSpec()';
}

/// Result for RubricBasedInstructionFollowing metric.
final class RubricBasedInstructionFollowingResult
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricBasedInstructionFollowingResult';

  /// Output only. Overall score for the instruction following.
  final double? score;

  /// Output only. List of per rubric critique results.
  final List<RubricCritiqueResult>? rubricCritiqueResults;

  RubricBasedInstructionFollowingResult({
    this.score,
    this.rubricCritiqueResults,
  }) : super(fullyQualifiedName);

  factory RubricBasedInstructionFollowingResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return RubricBasedInstructionFollowingResult(
      score: decodeDouble(json['score']),
      rubricCritiqueResults: decodeListMessage(
        json['rubricCritiqueResults'],
        RubricCritiqueResult.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (rubricCritiqueResults != null)
        'rubricCritiqueResults': encodeList(rubricCritiqueResults),
    };
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'RubricBasedInstructionFollowingResult($contents)';
  }
}

/// Rubric critique result.
final class RubricCritiqueResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RubricCritiqueResult';

  /// Output only. Rubric to be evaluated.
  final String? rubric;

  /// Output only. Verdict for the rubric - true if the rubric is met, false
  /// otherwise.
  final bool? verdict;

  RubricCritiqueResult({this.rubric, this.verdict}) : super(fullyQualifiedName);

  factory RubricCritiqueResult.fromJson(Map<String, dynamic> json) {
    return RubricCritiqueResult(
      rubric: json['rubric'],
      verdict: json['verdict'],
    );
  }

  @override
  Object toJson() {
    return {
      if (rubric != null) 'rubric': rubric,
      if (verdict != null) 'verdict': verdict,
    };
  }

  @override
  String toString() {
    final contents = [
      if (rubric != null) 'rubric=$rubric',
      if (verdict != null) 'verdict=$verdict',
    ].join(',');
    return 'RubricCritiqueResult($contents)';
  }
}

/// Instances and metric spec for TrajectoryExactMatch metric.
final class TrajectoryExactMatchInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchInput';

  /// Required. Spec for TrajectoryExactMatch metric.
  final TrajectoryExactMatchSpec? metricSpec;

  /// Required. Repeated TrajectoryExactMatch instance.
  final List<TrajectoryExactMatchInstance>? instances;

  TrajectoryExactMatchInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory TrajectoryExactMatchInput.fromJson(Map<String, dynamic> json) {
    return TrajectoryExactMatchInput(
      metricSpec: decode(json['metricSpec'], TrajectoryExactMatchSpec.fromJson),
      instances: decodeListMessage(
        json['instances'],
        TrajectoryExactMatchInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'TrajectoryExactMatchInput()';
}

/// Spec for TrajectoryExactMatch metric - returns 1 if tool calls in the
/// reference trajectory exactly match the predicted trajectory, else 0.
final class TrajectoryExactMatchSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchSpec';

  TrajectoryExactMatchSpec() : super(fullyQualifiedName);

  factory TrajectoryExactMatchSpec.fromJson(Map<String, dynamic> json) {
    return TrajectoryExactMatchSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'TrajectoryExactMatchSpec()';
}

/// Spec for TrajectoryExactMatch instance.
final class TrajectoryExactMatchInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryExactMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryExactMatchInstance.fromJson(Map<String, dynamic> json) {
    return TrajectoryExactMatchInstance(
      predictedTrajectory: decode(
        json['predictedTrajectory'],
        Trajectory.fromJson,
      ),
      referenceTrajectory: decode(
        json['referenceTrajectory'],
        Trajectory.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (predictedTrajectory != null)
        'predictedTrajectory': predictedTrajectory!.toJson(),
      if (referenceTrajectory != null)
        'referenceTrajectory': referenceTrajectory!.toJson(),
    };
  }

  @override
  String toString() => 'TrajectoryExactMatchInstance()';
}

/// Results for TrajectoryExactMatch metric.
final class TrajectoryExactMatchResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchResults';

  /// Output only. TrajectoryExactMatch metric values.
  final List<TrajectoryExactMatchMetricValue>? trajectoryExactMatchMetricValues;

  TrajectoryExactMatchResults({this.trajectoryExactMatchMetricValues})
    : super(fullyQualifiedName);

  factory TrajectoryExactMatchResults.fromJson(Map<String, dynamic> json) {
    return TrajectoryExactMatchResults(
      trajectoryExactMatchMetricValues: decodeListMessage(
        json['trajectoryExactMatchMetricValues'],
        TrajectoryExactMatchMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trajectoryExactMatchMetricValues != null)
        'trajectoryExactMatchMetricValues': encodeList(
          trajectoryExactMatchMetricValues,
        ),
    };
  }

  @override
  String toString() => 'TrajectoryExactMatchResults()';
}

/// TrajectoryExactMatch metric value for an instance.
final class TrajectoryExactMatchMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryExactMatchMetricValue';

  /// Output only. TrajectoryExactMatch score.
  final double? score;

  TrajectoryExactMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryExactMatchMetricValue.fromJson(Map<String, dynamic> json) {
    return TrajectoryExactMatchMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryExactMatchMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectoryInOrderMatch metric.
final class TrajectoryInOrderMatchInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchInput';

  /// Required. Spec for TrajectoryInOrderMatch metric.
  final TrajectoryInOrderMatchSpec? metricSpec;

  /// Required. Repeated TrajectoryInOrderMatch instance.
  final List<TrajectoryInOrderMatchInstance>? instances;

  TrajectoryInOrderMatchInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchInput.fromJson(Map<String, dynamic> json) {
    return TrajectoryInOrderMatchInput(
      metricSpec: decode(
        json['metricSpec'],
        TrajectoryInOrderMatchSpec.fromJson,
      ),
      instances: decodeListMessage(
        json['instances'],
        TrajectoryInOrderMatchInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'TrajectoryInOrderMatchInput()';
}

/// Spec for TrajectoryInOrderMatch metric - returns 1 if tool calls in the
/// reference trajectory appear in the predicted trajectory in the same order,
/// else 0.
final class TrajectoryInOrderMatchSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchSpec';

  TrajectoryInOrderMatchSpec() : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchSpec.fromJson(Map<String, dynamic> json) {
    return TrajectoryInOrderMatchSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'TrajectoryInOrderMatchSpec()';
}

/// Spec for TrajectoryInOrderMatch instance.
final class TrajectoryInOrderMatchInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryInOrderMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchInstance.fromJson(Map<String, dynamic> json) {
    return TrajectoryInOrderMatchInstance(
      predictedTrajectory: decode(
        json['predictedTrajectory'],
        Trajectory.fromJson,
      ),
      referenceTrajectory: decode(
        json['referenceTrajectory'],
        Trajectory.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (predictedTrajectory != null)
        'predictedTrajectory': predictedTrajectory!.toJson(),
      if (referenceTrajectory != null)
        'referenceTrajectory': referenceTrajectory!.toJson(),
    };
  }

  @override
  String toString() => 'TrajectoryInOrderMatchInstance()';
}

/// Results for TrajectoryInOrderMatch metric.
final class TrajectoryInOrderMatchResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchResults';

  /// Output only. TrajectoryInOrderMatch metric values.
  final List<TrajectoryInOrderMatchMetricValue>?
  trajectoryInOrderMatchMetricValues;

  TrajectoryInOrderMatchResults({this.trajectoryInOrderMatchMetricValues})
    : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchResults.fromJson(Map<String, dynamic> json) {
    return TrajectoryInOrderMatchResults(
      trajectoryInOrderMatchMetricValues: decodeListMessage(
        json['trajectoryInOrderMatchMetricValues'],
        TrajectoryInOrderMatchMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trajectoryInOrderMatchMetricValues != null)
        'trajectoryInOrderMatchMetricValues': encodeList(
          trajectoryInOrderMatchMetricValues,
        ),
    };
  }

  @override
  String toString() => 'TrajectoryInOrderMatchResults()';
}

/// TrajectoryInOrderMatch metric value for an instance.
final class TrajectoryInOrderMatchMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryInOrderMatchMetricValue';

  /// Output only. TrajectoryInOrderMatch score.
  final double? score;

  TrajectoryInOrderMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryInOrderMatchMetricValue.fromJson(
    Map<String, dynamic> json,
  ) {
    return TrajectoryInOrderMatchMetricValue(
      score: decodeDouble(json['score']),
    );
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryInOrderMatchMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectoryAnyOrderMatch metric.
final class TrajectoryAnyOrderMatchInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchInput';

  /// Required. Spec for TrajectoryAnyOrderMatch metric.
  final TrajectoryAnyOrderMatchSpec? metricSpec;

  /// Required. Repeated TrajectoryAnyOrderMatch instance.
  final List<TrajectoryAnyOrderMatchInstance>? instances;

  TrajectoryAnyOrderMatchInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchInput.fromJson(Map<String, dynamic> json) {
    return TrajectoryAnyOrderMatchInput(
      metricSpec: decode(
        json['metricSpec'],
        TrajectoryAnyOrderMatchSpec.fromJson,
      ),
      instances: decodeListMessage(
        json['instances'],
        TrajectoryAnyOrderMatchInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'TrajectoryAnyOrderMatchInput()';
}

/// Spec for TrajectoryAnyOrderMatch metric - returns 1 if all tool calls in the
/// reference trajectory appear in the predicted trajectory in any order, else
/// 0.
final class TrajectoryAnyOrderMatchSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchSpec';

  TrajectoryAnyOrderMatchSpec() : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchSpec.fromJson(Map<String, dynamic> json) {
    return TrajectoryAnyOrderMatchSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'TrajectoryAnyOrderMatchSpec()';
}

/// Spec for TrajectoryAnyOrderMatch instance.
final class TrajectoryAnyOrderMatchInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryAnyOrderMatchInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchInstance.fromJson(Map<String, dynamic> json) {
    return TrajectoryAnyOrderMatchInstance(
      predictedTrajectory: decode(
        json['predictedTrajectory'],
        Trajectory.fromJson,
      ),
      referenceTrajectory: decode(
        json['referenceTrajectory'],
        Trajectory.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (predictedTrajectory != null)
        'predictedTrajectory': predictedTrajectory!.toJson(),
      if (referenceTrajectory != null)
        'referenceTrajectory': referenceTrajectory!.toJson(),
    };
  }

  @override
  String toString() => 'TrajectoryAnyOrderMatchInstance()';
}

/// Results for TrajectoryAnyOrderMatch metric.
final class TrajectoryAnyOrderMatchResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchResults';

  /// Output only. TrajectoryAnyOrderMatch metric values.
  final List<TrajectoryAnyOrderMatchMetricValue>?
  trajectoryAnyOrderMatchMetricValues;

  TrajectoryAnyOrderMatchResults({this.trajectoryAnyOrderMatchMetricValues})
    : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchResults.fromJson(Map<String, dynamic> json) {
    return TrajectoryAnyOrderMatchResults(
      trajectoryAnyOrderMatchMetricValues: decodeListMessage(
        json['trajectoryAnyOrderMatchMetricValues'],
        TrajectoryAnyOrderMatchMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trajectoryAnyOrderMatchMetricValues != null)
        'trajectoryAnyOrderMatchMetricValues': encodeList(
          trajectoryAnyOrderMatchMetricValues,
        ),
    };
  }

  @override
  String toString() => 'TrajectoryAnyOrderMatchResults()';
}

/// TrajectoryAnyOrderMatch metric value for an instance.
final class TrajectoryAnyOrderMatchMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryAnyOrderMatchMetricValue';

  /// Output only. TrajectoryAnyOrderMatch score.
  final double? score;

  TrajectoryAnyOrderMatchMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryAnyOrderMatchMetricValue.fromJson(
    Map<String, dynamic> json,
  ) {
    return TrajectoryAnyOrderMatchMetricValue(
      score: decodeDouble(json['score']),
    );
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryAnyOrderMatchMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectoryPrecision metric.
final class TrajectoryPrecisionInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionInput';

  /// Required. Spec for TrajectoryPrecision metric.
  final TrajectoryPrecisionSpec? metricSpec;

  /// Required. Repeated TrajectoryPrecision instance.
  final List<TrajectoryPrecisionInstance>? instances;

  TrajectoryPrecisionInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory TrajectoryPrecisionInput.fromJson(Map<String, dynamic> json) {
    return TrajectoryPrecisionInput(
      metricSpec: decode(json['metricSpec'], TrajectoryPrecisionSpec.fromJson),
      instances: decodeListMessage(
        json['instances'],
        TrajectoryPrecisionInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'TrajectoryPrecisionInput()';
}

/// Spec for TrajectoryPrecision metric - returns a float score based on average
/// precision of individual tool calls.
final class TrajectoryPrecisionSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionSpec';

  TrajectoryPrecisionSpec() : super(fullyQualifiedName);

  factory TrajectoryPrecisionSpec.fromJson(Map<String, dynamic> json) {
    return TrajectoryPrecisionSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'TrajectoryPrecisionSpec()';
}

/// Spec for TrajectoryPrecision instance.
final class TrajectoryPrecisionInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryPrecisionInstance({
    this.predictedTrajectory,
    this.referenceTrajectory,
  }) : super(fullyQualifiedName);

  factory TrajectoryPrecisionInstance.fromJson(Map<String, dynamic> json) {
    return TrajectoryPrecisionInstance(
      predictedTrajectory: decode(
        json['predictedTrajectory'],
        Trajectory.fromJson,
      ),
      referenceTrajectory: decode(
        json['referenceTrajectory'],
        Trajectory.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (predictedTrajectory != null)
        'predictedTrajectory': predictedTrajectory!.toJson(),
      if (referenceTrajectory != null)
        'referenceTrajectory': referenceTrajectory!.toJson(),
    };
  }

  @override
  String toString() => 'TrajectoryPrecisionInstance()';
}

/// Results for TrajectoryPrecision metric.
final class TrajectoryPrecisionResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionResults';

  /// Output only. TrajectoryPrecision metric values.
  final List<TrajectoryPrecisionMetricValue>? trajectoryPrecisionMetricValues;

  TrajectoryPrecisionResults({this.trajectoryPrecisionMetricValues})
    : super(fullyQualifiedName);

  factory TrajectoryPrecisionResults.fromJson(Map<String, dynamic> json) {
    return TrajectoryPrecisionResults(
      trajectoryPrecisionMetricValues: decodeListMessage(
        json['trajectoryPrecisionMetricValues'],
        TrajectoryPrecisionMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trajectoryPrecisionMetricValues != null)
        'trajectoryPrecisionMetricValues': encodeList(
          trajectoryPrecisionMetricValues,
        ),
    };
  }

  @override
  String toString() => 'TrajectoryPrecisionResults()';
}

/// TrajectoryPrecision metric value for an instance.
final class TrajectoryPrecisionMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryPrecisionMetricValue';

  /// Output only. TrajectoryPrecision score.
  final double? score;

  TrajectoryPrecisionMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryPrecisionMetricValue.fromJson(Map<String, dynamic> json) {
    return TrajectoryPrecisionMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryPrecisionMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectoryRecall metric.
final class TrajectoryRecallInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallInput';

  /// Required. Spec for TrajectoryRecall metric.
  final TrajectoryRecallSpec? metricSpec;

  /// Required. Repeated TrajectoryRecall instance.
  final List<TrajectoryRecallInstance>? instances;

  TrajectoryRecallInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory TrajectoryRecallInput.fromJson(Map<String, dynamic> json) {
    return TrajectoryRecallInput(
      metricSpec: decode(json['metricSpec'], TrajectoryRecallSpec.fromJson),
      instances: decodeListMessage(
        json['instances'],
        TrajectoryRecallInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'TrajectoryRecallInput()';
}

/// Spec for TrajectoryRecall metric - returns a float score based on average
/// recall of individual tool calls.
final class TrajectoryRecallSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallSpec';

  TrajectoryRecallSpec() : super(fullyQualifiedName);

  factory TrajectoryRecallSpec.fromJson(Map<String, dynamic> json) {
    return TrajectoryRecallSpec();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'TrajectoryRecallSpec()';
}

/// Spec for TrajectoryRecall instance.
final class TrajectoryRecallInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  /// Required. Spec for reference tool call trajectory.
  final Trajectory? referenceTrajectory;

  TrajectoryRecallInstance({this.predictedTrajectory, this.referenceTrajectory})
    : super(fullyQualifiedName);

  factory TrajectoryRecallInstance.fromJson(Map<String, dynamic> json) {
    return TrajectoryRecallInstance(
      predictedTrajectory: decode(
        json['predictedTrajectory'],
        Trajectory.fromJson,
      ),
      referenceTrajectory: decode(
        json['referenceTrajectory'],
        Trajectory.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (predictedTrajectory != null)
        'predictedTrajectory': predictedTrajectory!.toJson(),
      if (referenceTrajectory != null)
        'referenceTrajectory': referenceTrajectory!.toJson(),
    };
  }

  @override
  String toString() => 'TrajectoryRecallInstance()';
}

/// Results for TrajectoryRecall metric.
final class TrajectoryRecallResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallResults';

  /// Output only. TrajectoryRecall metric values.
  final List<TrajectoryRecallMetricValue>? trajectoryRecallMetricValues;

  TrajectoryRecallResults({this.trajectoryRecallMetricValues})
    : super(fullyQualifiedName);

  factory TrajectoryRecallResults.fromJson(Map<String, dynamic> json) {
    return TrajectoryRecallResults(
      trajectoryRecallMetricValues: decodeListMessage(
        json['trajectoryRecallMetricValues'],
        TrajectoryRecallMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trajectoryRecallMetricValues != null)
        'trajectoryRecallMetricValues': encodeList(
          trajectoryRecallMetricValues,
        ),
    };
  }

  @override
  String toString() => 'TrajectoryRecallResults()';
}

/// TrajectoryRecall metric value for an instance.
final class TrajectoryRecallMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectoryRecallMetricValue';

  /// Output only. TrajectoryRecall score.
  final double? score;

  TrajectoryRecallMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectoryRecallMetricValue.fromJson(Map<String, dynamic> json) {
    return TrajectoryRecallMetricValue(score: decodeDouble(json['score']));
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectoryRecallMetricValue($contents)';
  }
}

/// Instances and metric spec for TrajectorySingleToolUse metric.
final class TrajectorySingleToolUseInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseInput';

  /// Required. Spec for TrajectorySingleToolUse metric.
  final TrajectorySingleToolUseSpec? metricSpec;

  /// Required. Repeated TrajectorySingleToolUse instance.
  final List<TrajectorySingleToolUseInstance>? instances;

  TrajectorySingleToolUseInput({this.metricSpec, this.instances})
    : super(fullyQualifiedName);

  factory TrajectorySingleToolUseInput.fromJson(Map<String, dynamic> json) {
    return TrajectorySingleToolUseInput(
      metricSpec: decode(
        json['metricSpec'],
        TrajectorySingleToolUseSpec.fromJson,
      ),
      instances: decodeListMessage(
        json['instances'],
        TrajectorySingleToolUseInstance.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricSpec != null) 'metricSpec': metricSpec!.toJson(),
      if (instances != null) 'instances': encodeList(instances),
    };
  }

  @override
  String toString() => 'TrajectorySingleToolUseInput()';
}

/// Spec for TrajectorySingleToolUse metric - returns 1 if tool is present in the
/// predicted trajectory, else 0.
final class TrajectorySingleToolUseSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseSpec';

  /// Required. Spec for tool name to be checked for in the predicted trajectory.
  final String? toolName;

  TrajectorySingleToolUseSpec({this.toolName}) : super(fullyQualifiedName);

  factory TrajectorySingleToolUseSpec.fromJson(Map<String, dynamic> json) {
    return TrajectorySingleToolUseSpec(toolName: json['toolName']);
  }

  @override
  Object toJson() {
    return {if (toolName != null) 'toolName': toolName};
  }

  @override
  String toString() {
    final contents = [if (toolName != null) 'toolName=$toolName'].join(',');
    return 'TrajectorySingleToolUseSpec($contents)';
  }
}

/// Spec for TrajectorySingleToolUse instance.
final class TrajectorySingleToolUseInstance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseInstance';

  /// Required. Spec for predicted tool call trajectory.
  final Trajectory? predictedTrajectory;

  TrajectorySingleToolUseInstance({this.predictedTrajectory})
    : super(fullyQualifiedName);

  factory TrajectorySingleToolUseInstance.fromJson(Map<String, dynamic> json) {
    return TrajectorySingleToolUseInstance(
      predictedTrajectory: decode(
        json['predictedTrajectory'],
        Trajectory.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (predictedTrajectory != null)
        'predictedTrajectory': predictedTrajectory!.toJson(),
    };
  }

  @override
  String toString() => 'TrajectorySingleToolUseInstance()';
}

/// Results for TrajectorySingleToolUse metric.
final class TrajectorySingleToolUseResults extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseResults';

  /// Output only. TrajectorySingleToolUse metric values.
  final List<TrajectorySingleToolUseMetricValue>?
  trajectorySingleToolUseMetricValues;

  TrajectorySingleToolUseResults({this.trajectorySingleToolUseMetricValues})
    : super(fullyQualifiedName);

  factory TrajectorySingleToolUseResults.fromJson(Map<String, dynamic> json) {
    return TrajectorySingleToolUseResults(
      trajectorySingleToolUseMetricValues: decodeListMessage(
        json['trajectorySingleToolUseMetricValues'],
        TrajectorySingleToolUseMetricValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trajectorySingleToolUseMetricValues != null)
        'trajectorySingleToolUseMetricValues': encodeList(
          trajectorySingleToolUseMetricValues,
        ),
    };
  }

  @override
  String toString() => 'TrajectorySingleToolUseResults()';
}

/// TrajectorySingleToolUse metric value for an instance.
final class TrajectorySingleToolUseMetricValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrajectorySingleToolUseMetricValue';

  /// Output only. TrajectorySingleToolUse score.
  final double? score;

  TrajectorySingleToolUseMetricValue({this.score}) : super(fullyQualifiedName);

  factory TrajectorySingleToolUseMetricValue.fromJson(
    Map<String, dynamic> json,
  ) {
    return TrajectorySingleToolUseMetricValue(
      score: decodeDouble(json['score']),
    );
  }

  @override
  Object toJson() {
    return {if (score != null) 'score': encodeDouble(score)};
  }

  @override
  String toString() {
    final contents = [if (score != null) 'score=$score'].join(',');
    return 'TrajectorySingleToolUseMetricValue($contents)';
  }
}

/// Spec for trajectory.
final class Trajectory extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Trajectory';

  /// Required. Tool calls in the trajectory.
  final List<ToolCall>? toolCalls;

  Trajectory({this.toolCalls}) : super(fullyQualifiedName);

  factory Trajectory.fromJson(Map<String, dynamic> json) {
    return Trajectory(
      toolCalls: decodeListMessage(json['toolCalls'], ToolCall.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (toolCalls != null) 'toolCalls': encodeList(toolCalls)};
  }

  @override
  String toString() => 'Trajectory()';
}

/// Spec for tool call.
final class ToolCall extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolCall';

  /// Required. Spec for tool name
  final String? toolName;

  /// Optional. Spec for tool input
  final String? toolInput;

  ToolCall({this.toolName, this.toolInput}) : super(fullyQualifiedName);

  factory ToolCall.fromJson(Map<String, dynamic> json) {
    return ToolCall(toolName: json['toolName'], toolInput: json['toolInput']);
  }

  @override
  Object toJson() {
    return {
      if (toolName != null) 'toolName': toolName,
      if (toolInput != null) 'toolInput': toolInput,
    };
  }

  @override
  String toString() {
    final contents = [
      if (toolName != null) 'toolName=$toolName',
      if (toolInput != null) 'toolInput=$toolInput',
    ].join(',');
    return 'ToolCall($contents)';
  }
}

/// Map of placeholder in metric prompt template to contents of model input.
final class ContentMap extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContentMap';

  /// Optional. Map of placeholder to contents.
  final Map<String, ContentMap_Contents>? values;

  ContentMap({this.values}) : super(fullyQualifiedName);

  factory ContentMap.fromJson(Map<String, dynamic> json) {
    return ContentMap(
      values: decodeMapMessage(json['values'], ContentMap_Contents.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': encodeMap(values)};
  }

  @override
  String toString() => 'ContentMap()';
}

/// Repeated Content type.
final class ContentMap_Contents extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContentMap.Contents';

  /// Optional. Repeated contents.
  final List<Content>? contents;

  ContentMap_Contents({this.contents}) : super(fullyQualifiedName);

  factory ContentMap_Contents.fromJson(Map<String, dynamic> json) {
    return ContentMap_Contents(
      contents: decodeListMessage(json['contents'], Content.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (contents != null) 'contents': encodeList(contents)};
  }

  @override
  String toString() => 'Contents()';
}

/// An edge describing the relationship between an Artifact and an Execution in
/// a lineage graph.
final class Event extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Event';

  /// Required. The relative resource name of the Artifact in the Event.
  final String? artifact;

  /// Output only. The relative resource name of the Execution in the Event.
  final String? execution;

  /// Output only. Time the Event occurred.
  final protobuf.Timestamp? eventTime;

  /// Required. The type of the Event.
  final Event_Type? type;

  /// The labels with user-defined metadata to annotate Events.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Event (System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? labels;

  Event({this.artifact, this.execution, this.eventTime, this.type, this.labels})
    : super(fullyQualifiedName);

  factory Event.fromJson(Map<String, dynamic> json) {
    return Event(
      artifact: json['artifact'],
      execution: json['execution'],
      eventTime: decodeCustom(json['eventTime'], protobuf.Timestamp.fromJson),
      type: decodeEnum(json['type'], Event_Type.fromJson),
      labels: decodeMap(json['labels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (artifact != null) 'artifact': artifact,
      if (execution != null) 'execution': execution,
      if (eventTime != null) 'eventTime': eventTime!.toJson(),
      if (type != null) 'type': type!.toJson(),
      if (labels != null) 'labels': labels,
    };
  }

  @override
  String toString() {
    final contents = [
      if (artifact != null) 'artifact=$artifact',
      if (execution != null) 'execution=$execution',
      if (type != null) 'type=$type',
    ].join(',');
    return 'Event($contents)';
  }
}

/// Describes whether an Event's Artifact is the Execution's input or output.
final class Event_Type extends protobuf.ProtoEnum {
  /// Unspecified whether input or output of the Execution.
  static const typeUnspecified = Event_Type('TYPE_UNSPECIFIED');

  /// An input of the Execution.
  static const input = Event_Type('INPUT');

  /// An output of the Execution.
  static const output = Event_Type('OUTPUT');

  const Event_Type(super.value);

  factory Event_Type.fromJson(String json) => Event_Type(json);

  @override
  String toString() => 'Type.$value';
}

/// A single example of a conversation with the model.
final class ContentsExample extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContentsExample';

  /// Required. The content of the conversation with the model that resulted in
  /// the expected output.
  final List<Content>? contents;

  /// Required. The expected output for the given `contents`. To represent
  /// multi-step reasoning, this is a repeated field that contains the iterative
  /// steps of the expected output.
  final List<ContentsExample_ExpectedContent>? expectedContents;

  ContentsExample({this.contents, this.expectedContents})
    : super(fullyQualifiedName);

  factory ContentsExample.fromJson(Map<String, dynamic> json) {
    return ContentsExample(
      contents: decodeListMessage(json['contents'], Content.fromJson),
      expectedContents: decodeListMessage(
        json['expectedContents'],
        ContentsExample_ExpectedContent.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (contents != null) 'contents': encodeList(contents),
      if (expectedContents != null)
        'expectedContents': encodeList(expectedContents),
    };
  }

  @override
  String toString() => 'ContentsExample()';
}

/// A single step of the expected output.
final class ContentsExample_ExpectedContent extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContentsExample.ExpectedContent';

  /// Required. A single step's content.
  final Content? content;

  ContentsExample_ExpectedContent({this.content}) : super(fullyQualifiedName);

  factory ContentsExample_ExpectedContent.fromJson(Map<String, dynamic> json) {
    return ContentsExample_ExpectedContent(
      content: decode(json['content'], Content.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (content != null) 'content': content!.toJson()};
  }

  @override
  String toString() => 'ExpectedContent()';
}

/// A ContentsExample to be used with GenerateContent alongside information
/// required for storage and retrieval with Example Store.
final class StoredContentsExample extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExample';

  /// Optional. (Optional) the search key used for retrieval. If not provided at
  /// upload-time, the search key will be generated from
  /// `contents_example.contents` using the method provided by
  /// `search_key_generation_method`. The generated search key will be included
  /// in retrieved examples.
  final String? searchKey;

  /// Required. The example to be used with GenerateContent.
  final ContentsExample? contentsExample;

  /// Optional. The method used to generate the search key from
  /// `contents_example.contents`. This is ignored when uploading an example if
  /// `search_key` is provided.
  final StoredContentsExample_SearchKeyGenerationMethod?
  searchKeyGenerationMethod;

  StoredContentsExample({
    this.searchKey,
    this.contentsExample,
    this.searchKeyGenerationMethod,
  }) : super(fullyQualifiedName);

  factory StoredContentsExample.fromJson(Map<String, dynamic> json) {
    return StoredContentsExample(
      searchKey: json['searchKey'],
      contentsExample: decode(
        json['contentsExample'],
        ContentsExample.fromJson,
      ),
      searchKeyGenerationMethod: decode(
        json['searchKeyGenerationMethod'],
        StoredContentsExample_SearchKeyGenerationMethod.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (searchKey != null) 'searchKey': searchKey,
      if (contentsExample != null) 'contentsExample': contentsExample!.toJson(),
      if (searchKeyGenerationMethod != null)
        'searchKeyGenerationMethod': searchKeyGenerationMethod!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (searchKey != null) 'searchKey=$searchKey'].join(',');
    return 'StoredContentsExample($contents)';
  }
}

/// Options for generating the search key from the conversation history.
final class StoredContentsExample_SearchKeyGenerationMethod
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExample.SearchKeyGenerationMethod';

  /// Use only the last entry of the conversation history
  /// (`contents_example.contents`) as the search key.
  final StoredContentsExample_SearchKeyGenerationMethod_LastEntry? lastEntry;

  StoredContentsExample_SearchKeyGenerationMethod({this.lastEntry})
    : super(fullyQualifiedName);

  factory StoredContentsExample_SearchKeyGenerationMethod.fromJson(
    Map<String, dynamic> json,
  ) {
    return StoredContentsExample_SearchKeyGenerationMethod(
      lastEntry: decode(
        json['lastEntry'],
        StoredContentsExample_SearchKeyGenerationMethod_LastEntry.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (lastEntry != null) 'lastEntry': lastEntry!.toJson()};
  }

  @override
  String toString() => 'SearchKeyGenerationMethod()';
}

/// Configuration for using only the last entry of the conversation history
/// as the search key.
final class StoredContentsExample_SearchKeyGenerationMethod_LastEntry
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExample.SearchKeyGenerationMethod.LastEntry';

  StoredContentsExample_SearchKeyGenerationMethod_LastEntry()
    : super(fullyQualifiedName);

  factory StoredContentsExample_SearchKeyGenerationMethod_LastEntry.fromJson(
    Map<String, dynamic> json,
  ) {
    return StoredContentsExample_SearchKeyGenerationMethod_LastEntry();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'LastEntry()';
}

/// Represents an executable service to manage and retrieve examples.
final class ExampleStore extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExampleStore';

  /// Identifier. The resource name of the ExampleStore. This is a unique
  /// identifier. Format:
  /// projects/{project}/locations/{location}/exampleStores/{example_store}
  final String? name;

  /// Required. Display name of the ExampleStore.
  final String? displayName;

  /// Optional. Description of the ExampleStore.
  final String? description;

  /// Output only. Timestamp when this ExampleStore was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ExampleStore was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Required. Example Store config.
  final ExampleStoreConfig? exampleStoreConfig;

  ExampleStore({
    this.name,
    this.displayName,
    this.description,
    this.createTime,
    this.updateTime,
    this.exampleStoreConfig,
  }) : super(fullyQualifiedName);

  factory ExampleStore.fromJson(Map<String, dynamic> json) {
    return ExampleStore(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      exampleStoreConfig: decode(
        json['exampleStoreConfig'],
        ExampleStoreConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (exampleStoreConfig != null)
        'exampleStoreConfig': exampleStoreConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
    ].join(',');
    return 'ExampleStore($contents)';
  }
}

/// Configuration for the Example Store.
final class ExampleStoreConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExampleStoreConfig';

  /// Required. The embedding model to be used for vector embedding.
  /// Immutable.
  /// Supported models:
  /// * "textembedding-gecko@003"
  /// * "text-embedding-004"
  /// * "text-embedding-005"
  /// * "text-multilingual-embedding-002"
  final String? vertexEmbeddingModel;

  ExampleStoreConfig({this.vertexEmbeddingModel}) : super(fullyQualifiedName);

  factory ExampleStoreConfig.fromJson(Map<String, dynamic> json) {
    return ExampleStoreConfig(
      vertexEmbeddingModel: json['vertexEmbeddingModel'],
    );
  }

  @override
  Object toJson() {
    return {
      if (vertexEmbeddingModel != null)
        'vertexEmbeddingModel': vertexEmbeddingModel,
    };
  }

  @override
  String toString() {
    final contents = [
      if (vertexEmbeddingModel != null)
        'vertexEmbeddingModel=$vertexEmbeddingModel',
    ].join(',');
    return 'ExampleStoreConfig($contents)';
  }
}

/// The metadata filters that will be used to remove or fetch
/// StoredContentsExamples. If a field is unspecified, then no filtering for that
/// field will be applied.
final class StoredContentsExampleFilter extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExampleFilter';

  /// Optional. The search keys for filtering. Only examples with one of the
  /// specified search keys
  /// (`StoredContentsExample.search_key`)
  /// are eligible to be returned.
  final List<String>? searchKeys;

  /// Optional. The function names for filtering.
  final ExamplesArrayFilter? functionNames;

  StoredContentsExampleFilter({this.searchKeys, this.functionNames})
    : super(fullyQualifiedName);

  factory StoredContentsExampleFilter.fromJson(Map<String, dynamic> json) {
    return StoredContentsExampleFilter(
      searchKeys: decodeList(json['searchKeys']),
      functionNames: decode(
        json['functionNames'],
        ExamplesArrayFilter.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (searchKeys != null) 'searchKeys': searchKeys,
      if (functionNames != null) 'functionNames': functionNames!.toJson(),
    };
  }

  @override
  String toString() => 'StoredContentsExampleFilter()';
}

/// The metadata filters that will be used to search StoredContentsExamples.
/// If a field is unspecified, then no filtering for that field will be applied
final class StoredContentsExampleParameters extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExampleParameters';

  /// The exact search key to use for retrieval.
  final String? searchKey;

  /// The chat history to use to generate the search key for retrieval.
  final StoredContentsExampleParameters_ContentSearchKey? contentSearchKey;

  /// Optional. The function names for filtering.
  final ExamplesArrayFilter? functionNames;

  StoredContentsExampleParameters({
    this.searchKey,
    this.contentSearchKey,
    this.functionNames,
  }) : super(fullyQualifiedName);

  factory StoredContentsExampleParameters.fromJson(Map<String, dynamic> json) {
    return StoredContentsExampleParameters(
      searchKey: json['searchKey'],
      contentSearchKey: decode(
        json['contentSearchKey'],
        StoredContentsExampleParameters_ContentSearchKey.fromJson,
      ),
      functionNames: decode(
        json['functionNames'],
        ExamplesArrayFilter.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (searchKey != null) 'searchKey': searchKey,
      if (contentSearchKey != null)
        'contentSearchKey': contentSearchKey!.toJson(),
      if (functionNames != null) 'functionNames': functionNames!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (searchKey != null) 'searchKey=$searchKey'].join(',');
    return 'StoredContentsExampleParameters($contents)';
  }
}

/// The chat history to use to generate the search key for retrieval.
final class StoredContentsExampleParameters_ContentSearchKey
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StoredContentsExampleParameters.ContentSearchKey';

  /// Required. The conversation for generating a search key.
  final List<Content>? contents;

  /// Required. The method of generating a search key.
  final StoredContentsExample_SearchKeyGenerationMethod?
  searchKeyGenerationMethod;

  StoredContentsExampleParameters_ContentSearchKey({
    this.contents,
    this.searchKeyGenerationMethod,
  }) : super(fullyQualifiedName);

  factory StoredContentsExampleParameters_ContentSearchKey.fromJson(
    Map<String, dynamic> json,
  ) {
    return StoredContentsExampleParameters_ContentSearchKey(
      contents: decodeListMessage(json['contents'], Content.fromJson),
      searchKeyGenerationMethod: decode(
        json['searchKeyGenerationMethod'],
        StoredContentsExample_SearchKeyGenerationMethod.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (contents != null) 'contents': encodeList(contents),
      if (searchKeyGenerationMethod != null)
        'searchKeyGenerationMethod': searchKeyGenerationMethod!.toJson(),
    };
  }

  @override
  String toString() => 'ContentSearchKey()';
}

/// Filters for examples' array metadata fields. An array field is example
/// metadata where multiple values are attributed to a single example.
final class ExamplesArrayFilter extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExamplesArrayFilter';

  /// Required. The values by which to filter examples.
  final List<String>? values;

  /// Required. The operator logic to use for filtering.
  final ExamplesArrayFilter_ArrayOperator? arrayOperator;

  ExamplesArrayFilter({this.values, this.arrayOperator})
    : super(fullyQualifiedName);

  factory ExamplesArrayFilter.fromJson(Map<String, dynamic> json) {
    return ExamplesArrayFilter(
      values: decodeList(json['values']),
      arrayOperator: decodeEnum(
        json['arrayOperator'],
        ExamplesArrayFilter_ArrayOperator.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (values != null) 'values': values,
      if (arrayOperator != null) 'arrayOperator': arrayOperator!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (arrayOperator != null) 'arrayOperator=$arrayOperator',
    ].join(',');
    return 'ExamplesArrayFilter($contents)';
  }
}

/// The logic to use for filtering.
final class ExamplesArrayFilter_ArrayOperator extends protobuf.ProtoEnum {
  /// Not specified. This value should not be used.
  static const arrayOperatorUnspecified = ExamplesArrayFilter_ArrayOperator(
    'ARRAY_OPERATOR_UNSPECIFIED',
  );

  /// The metadata array field in the example must contain at least one of the
  /// values.
  static const containsAny = ExamplesArrayFilter_ArrayOperator('CONTAINS_ANY');

  /// The metadata array field in the example must contain all of the values.
  static const containsAll = ExamplesArrayFilter_ArrayOperator('CONTAINS_ALL');

  const ExamplesArrayFilter_ArrayOperator(super.value);

  factory ExamplesArrayFilter_ArrayOperator.fromJson(String json) =>
      ExamplesArrayFilter_ArrayOperator(json);

  @override
  String toString() => 'ArrayOperator.$value';
}

/// Request message for
/// `ExampleStoreService.CreateExampleStore`.
final class CreateExampleStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateExampleStoreRequest';

  /// Required. The resource name of the Location to create the ExampleStore in.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Example Store to be created.
  final ExampleStore exampleStore;

  CreateExampleStoreRequest({required this.parent, required this.exampleStore})
    : super(fullyQualifiedName);

  factory CreateExampleStoreRequest.fromJson(Map<String, dynamic> json) {
    return CreateExampleStoreRequest(
      parent: json['parent'],
      exampleStore: decode(json['exampleStore'], ExampleStore.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'exampleStore': exampleStore.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateExampleStoreRequest($contents)';
  }
}

/// Details of
/// `ExampleStoreService.CreateExampleStore`
/// operation.
final class CreateExampleStoreOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateExampleStoreOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateExampleStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateExampleStoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateExampleStoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateExampleStoreOperationMetadata()';
}

/// Request message for
/// `ExampleStoreService.GetExampleStore`.
final class GetExampleStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetExampleStoreRequest';

  /// Required. The resource name of the ExampleStore.
  /// Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String name;

  GetExampleStoreRequest({required this.name}) : super(fullyQualifiedName);

  factory GetExampleStoreRequest.fromJson(Map<String, dynamic> json) {
    return GetExampleStoreRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetExampleStoreRequest($contents)';
  }
}

/// Request message for
/// `ExampleStoreService.UpdateExampleStore`.
final class UpdateExampleStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExampleStoreRequest';

  /// Required. The Example Store which replaces the resource on the server.
  final ExampleStore exampleStore;

  /// Optional. Mask specifying which fields to update.
  /// Supported fields:
  ///
  ///    * `display_name`
  ///    * `description`
  final protobuf.FieldMask? updateMask;

  UpdateExampleStoreRequest({required this.exampleStore, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateExampleStoreRequest.fromJson(Map<String, dynamic> json) {
    return UpdateExampleStoreRequest(
      exampleStore: decode(json['exampleStore'], ExampleStore.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'exampleStore': exampleStore.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateExampleStoreRequest()';
}

/// Details of
/// `ExampleStoreService.UpdateExampleStore`
/// operation.
final class UpdateExampleStoreOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExampleStoreOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UpdateExampleStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateExampleStoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateExampleStoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateExampleStoreOperationMetadata()';
}

/// Request message for
/// `ExampleStoreService.DeleteExampleStore`.
final class DeleteExampleStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteExampleStoreRequest';

  /// Required. The resource name of the ExampleStore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String name;

  DeleteExampleStoreRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteExampleStoreRequest.fromJson(Map<String, dynamic> json) {
    return DeleteExampleStoreRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteExampleStoreRequest($contents)';
  }
}

/// Details of
/// `ExampleStoreService.DeleteExampleStore`
/// operation.
final class DeleteExampleStoreOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteExampleStoreOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  DeleteExampleStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory DeleteExampleStoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteExampleStoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'DeleteExampleStoreOperationMetadata()';
}

/// Request message for
/// `ExampleStoreService.ListExampleStores`.
final class ListExampleStoresRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExampleStoresRequest';

  /// Required. The resource name of the Location to list the ExampleStores from.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  final String? pageToken;

  ListExampleStoresRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListExampleStoresRequest.fromJson(Map<String, dynamic> json) {
    return ListExampleStoresRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListExampleStoresRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.ListExampleStores`.
final class ListExampleStoresResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExampleStoresResponse';

  /// List of ExampleStore in the requested page.
  final List<ExampleStore>? exampleStores;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListExampleStoresRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListExampleStoresResponse({this.exampleStores, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListExampleStoresResponse.fromJson(Map<String, dynamic> json) {
    return ListExampleStoresResponse(
      exampleStores: decodeListMessage(
        json['exampleStores'],
        ExampleStore.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (exampleStores != null) 'exampleStores': encodeList(exampleStores),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListExampleStoresResponse($contents)';
  }
}

/// A single example to upload or read from the Example Store.
final class Example extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Example';

  /// An example of chat history and its expected outcome to be used with
  /// GenerateContent.
  final StoredContentsExample? storedContentsExample;

  /// Optional. The display name for Example.
  final String? displayName;

  /// Optional. Immutable. Unique identifier of an example. If not specified when
  /// upserting new examples, the example_id will be generated.
  final String? exampleId;

  /// Output only. Timestamp when this Example was created.
  final protobuf.Timestamp? createTime;

  Example({
    this.storedContentsExample,
    this.displayName,
    this.exampleId,
    this.createTime,
  }) : super(fullyQualifiedName);

  factory Example.fromJson(Map<String, dynamic> json) {
    return Example(
      storedContentsExample: decode(
        json['storedContentsExample'],
        StoredContentsExample.fromJson,
      ),
      displayName: json['displayName'],
      exampleId: json['exampleId'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (storedContentsExample != null)
        'storedContentsExample': storedContentsExample!.toJson(),
      if (displayName != null) 'displayName': displayName,
      if (exampleId != null) 'exampleId': exampleId,
      if (createTime != null) 'createTime': createTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (displayName != null) 'displayName=$displayName',
      if (exampleId != null) 'exampleId=$exampleId',
    ].join(',');
    return 'Example($contents)';
  }
}

/// Request message for
/// `ExampleStoreService.UpsertExamples`.
final class UpsertExamplesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertExamplesRequest';

  /// Required. The name of the ExampleStore resource that examples are added to
  /// or updated in. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String exampleStore;

  /// Required. A list of examples to be created/updated.
  final List<Example>? examples;

  /// Optional. A flag indicating whether an example can be overwritten if it
  /// already exists. If False (default) and the example already exists, the
  /// example will not be updated. This does not affect behavior if the example
  /// does not exist already.
  final bool? overwrite;

  UpsertExamplesRequest({
    required this.exampleStore,
    this.examples,
    this.overwrite,
  }) : super(fullyQualifiedName);

  factory UpsertExamplesRequest.fromJson(Map<String, dynamic> json) {
    return UpsertExamplesRequest(
      exampleStore: json['exampleStore'],
      examples: decodeListMessage(json['examples'], Example.fromJson),
      overwrite: json['overwrite'],
    );
  }

  @override
  Object toJson() {
    return {
      'exampleStore': exampleStore,
      if (examples != null) 'examples': encodeList(examples),
      if (overwrite != null) 'overwrite': overwrite,
    };
  }

  @override
  String toString() {
    final contents = [
      'exampleStore=$exampleStore',
      if (overwrite != null) 'overwrite=$overwrite',
    ].join(',');
    return 'UpsertExamplesRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.UpsertExamples`.
final class UpsertExamplesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertExamplesResponse';

  /// A list of results for creating/updating. It's either a successfully
  /// created/updated example or a status with an error message.
  final List<UpsertExamplesResponse_UpsertResult>? results;

  UpsertExamplesResponse({this.results}) : super(fullyQualifiedName);

  factory UpsertExamplesResponse.fromJson(Map<String, dynamic> json) {
    return UpsertExamplesResponse(
      results: decodeListMessage(
        json['results'],
        UpsertExamplesResponse_UpsertResult.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (results != null) 'results': encodeList(results)};
  }

  @override
  String toString() => 'UpsertExamplesResponse()';
}

/// The result for creating/updating a single example.
final class UpsertExamplesResponse_UpsertResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertExamplesResponse.UpsertResult';

  /// The example created/updated successfully.
  final Example? example;

  /// The error message of the example that was not created/updated
  /// successfully.
  final Status? status;

  UpsertExamplesResponse_UpsertResult({this.example, this.status})
    : super(fullyQualifiedName);

  factory UpsertExamplesResponse_UpsertResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpsertExamplesResponse_UpsertResult(
      example: decode(json['example'], Example.fromJson),
      status: decode(json['status'], Status.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (example != null) 'example': example!.toJson(),
      if (status != null) 'status': status!.toJson(),
    };
  }

  @override
  String toString() => 'UpsertResult()';
}

/// Request message for
/// `ExampleStoreService.RemoveExamples`.
final class RemoveExamplesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveExamplesRequest';

  /// The metadata filters for StoredContentsExamples.
  final StoredContentsExampleFilter? storedContentsExampleFilter;

  /// Required. The name of the ExampleStore resource that the examples should be
  /// removed from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String exampleStore;

  /// Optional. Example IDs to remove. If both metadata filters and Example IDs
  /// are specified, the metadata filters will be applied to the specified
  /// examples in order to identify which should be removed.
  final List<String>? exampleIds;

  RemoveExamplesRequest({
    this.storedContentsExampleFilter,
    required this.exampleStore,
    this.exampleIds,
  }) : super(fullyQualifiedName);

  factory RemoveExamplesRequest.fromJson(Map<String, dynamic> json) {
    return RemoveExamplesRequest(
      storedContentsExampleFilter: decode(
        json['storedContentsExampleFilter'],
        StoredContentsExampleFilter.fromJson,
      ),
      exampleStore: json['exampleStore'],
      exampleIds: decodeList(json['exampleIds']),
    );
  }

  @override
  Object toJson() {
    return {
      if (storedContentsExampleFilter != null)
        'storedContentsExampleFilter': storedContentsExampleFilter!.toJson(),
      'exampleStore': exampleStore,
      if (exampleIds != null) 'exampleIds': exampleIds,
    };
  }

  @override
  String toString() {
    final contents = ['exampleStore=$exampleStore'].join(',');
    return 'RemoveExamplesRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.RemoveExamples`.
final class RemoveExamplesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveExamplesResponse';

  /// The IDs for the removed examples.
  final List<String>? exampleIds;

  RemoveExamplesResponse({this.exampleIds}) : super(fullyQualifiedName);

  factory RemoveExamplesResponse.fromJson(Map<String, dynamic> json) {
    return RemoveExamplesResponse(exampleIds: decodeList(json['exampleIds']));
  }

  @override
  Object toJson() {
    return {if (exampleIds != null) 'exampleIds': exampleIds};
  }

  @override
  String toString() => 'RemoveExamplesResponse()';
}

/// Request message for
/// `ExampleStoreService.SearchExamples`.
final class SearchExamplesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchExamplesRequest';

  /// The parameters of StoredContentsExamples to be searched.
  final StoredContentsExampleParameters? storedContentsExampleParameters;

  /// Required. The name of the ExampleStore resource that examples are retrieved
  /// from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String exampleStore;

  /// Optional. The number of similar examples to return.
  final int? topK;

  SearchExamplesRequest({
    this.storedContentsExampleParameters,
    required this.exampleStore,
    this.topK,
  }) : super(fullyQualifiedName);

  factory SearchExamplesRequest.fromJson(Map<String, dynamic> json) {
    return SearchExamplesRequest(
      storedContentsExampleParameters: decode(
        json['storedContentsExampleParameters'],
        StoredContentsExampleParameters.fromJson,
      ),
      exampleStore: json['exampleStore'],
      topK: decodeInt64(json['topK']),
    );
  }

  @override
  Object toJson() {
    return {
      if (storedContentsExampleParameters != null)
        'storedContentsExampleParameters': storedContentsExampleParameters!
            .toJson(),
      'exampleStore': exampleStore,
      if (topK != null) 'topK': encodeInt64(topK),
    };
  }

  @override
  String toString() {
    final contents = [
      'exampleStore=$exampleStore',
      if (topK != null) 'topK=$topK',
    ].join(',');
    return 'SearchExamplesRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.SearchExamples`.
final class SearchExamplesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchExamplesResponse';

  /// The results of searching for similar examples.
  final List<SearchExamplesResponse_SimilarExample>? results;

  SearchExamplesResponse({this.results}) : super(fullyQualifiedName);

  factory SearchExamplesResponse.fromJson(Map<String, dynamic> json) {
    return SearchExamplesResponse(
      results: decodeListMessage(
        json['results'],
        SearchExamplesResponse_SimilarExample.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (results != null) 'results': encodeList(results)};
  }

  @override
  String toString() => 'SearchExamplesResponse()';
}

/// The result of the similar example.
final class SearchExamplesResponse_SimilarExample
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchExamplesResponse.SimilarExample';

  /// The example that is similar to the searched query.
  final Example? example;

  /// The similarity score of this example.
  final double? similarityScore;

  SearchExamplesResponse_SimilarExample({this.example, this.similarityScore})
    : super(fullyQualifiedName);

  factory SearchExamplesResponse_SimilarExample.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchExamplesResponse_SimilarExample(
      example: decode(json['example'], Example.fromJson),
      similarityScore: decodeDouble(json['similarityScore']),
    );
  }

  @override
  Object toJson() {
    return {
      if (example != null) 'example': example!.toJson(),
      if (similarityScore != null)
        'similarityScore': encodeDouble(similarityScore),
    };
  }

  @override
  String toString() {
    final contents = [
      if (similarityScore != null) 'similarityScore=$similarityScore',
    ].join(',');
    return 'SimilarExample($contents)';
  }
}

/// Request message for
/// `ExampleStoreService.FetchExamples`.
final class FetchExamplesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchExamplesRequest';

  /// The metadata filters for StoredContentsExamples.
  final StoredContentsExampleFilter? storedContentsExampleFilter;

  /// Required. The name of the ExampleStore resource that the examples should be
  /// fetched from. Format:
  /// `projects/{project}/locations/{location}/exampleStores/{example_store}`
  final String exampleStore;

  /// Optional. The maximum number of examples to return. The service may return
  /// fewer than this value. If unspecified, at most 100 examples will be
  /// returned.
  final int? pageSize;

  /// Optional. The
  /// `next_page_token`
  /// value returned from a previous list
  /// `ExampleStoreService.FetchExamplesResponse` call.
  final String? pageToken;

  /// Optional. Example IDs to fetch. If both metadata filters and Example IDs
  /// are specified, then both ID and metadata filtering will be applied.
  final List<String>? exampleIds;

  FetchExamplesRequest({
    this.storedContentsExampleFilter,
    required this.exampleStore,
    this.pageSize,
    this.pageToken,
    this.exampleIds,
  }) : super(fullyQualifiedName);

  factory FetchExamplesRequest.fromJson(Map<String, dynamic> json) {
    return FetchExamplesRequest(
      storedContentsExampleFilter: decode(
        json['storedContentsExampleFilter'],
        StoredContentsExampleFilter.fromJson,
      ),
      exampleStore: json['exampleStore'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      exampleIds: decodeList(json['exampleIds']),
    );
  }

  @override
  Object toJson() {
    return {
      if (storedContentsExampleFilter != null)
        'storedContentsExampleFilter': storedContentsExampleFilter!.toJson(),
      'exampleStore': exampleStore,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (exampleIds != null) 'exampleIds': exampleIds,
    };
  }

  @override
  String toString() {
    final contents = [
      'exampleStore=$exampleStore',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'FetchExamplesRequest($contents)';
  }
}

/// Response message for
/// `ExampleStoreService.FetchExamples`.
final class FetchExamplesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchExamplesResponse';

  /// The examples in the Example Store that satisfy the metadata filters.
  final List<Example>? examples;

  /// A token, which can be sent as `FetchExamplesRequest.page_token` to
  /// retrieve the next page. Absence of this field indicates there are no
  /// subsequent pages.
  final String? nextPageToken;

  FetchExamplesResponse({this.examples, this.nextPageToken})
    : super(fullyQualifiedName);

  factory FetchExamplesResponse.fromJson(Map<String, dynamic> json) {
    return FetchExamplesResponse(
      examples: decodeListMessage(json['examples'], Example.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (examples != null) 'examples': encodeList(examples),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'FetchExamplesResponse($contents)';
  }
}

/// Instance of a general execution.
final class Execution extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Execution';

  /// Output only. The resource name of the Execution.
  final String? name;

  /// User provided display name of the Execution.
  /// May be up to 128 Unicode characters.
  final String? displayName;

  /// The state of this Execution. This is a property of the Execution, and does
  /// not imply or capture any ongoing process. This property is managed by
  /// clients (such as Vertex AI Pipelines) and the system does not prescribe
  /// or check the validity of state transitions.
  final Execution_State? state;

  /// An eTag used to perform consistent read-modify-write updates. If not set, a
  /// blind "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize your Executions.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Execution (System
  /// labels are excluded).
  final Map<String, String>? labels;

  /// Output only. Timestamp when this Execution was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Execution was last updated.
  final protobuf.Timestamp? updateTime;

  /// The title of the schema describing the metadata.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String? schemaTitle;

  /// The version of the schema in `schema_title` to use.
  ///
  /// Schema title and version is expected to be registered in earlier Create
  /// Schema calls. And both are used together as unique identifiers to identify
  /// schemas within the local metadata store.
  final String? schemaVersion;

  /// Properties of the Execution.
  /// Top level metadata keys' heading and trailing spaces will be trimmed.
  /// The size of this field should not exceed 200KB.
  final protobuf.Struct? metadata;

  /// Description of the Execution
  final String? description;

  Execution({
    this.name,
    this.displayName,
    this.state,
    this.etag,
    this.labels,
    this.createTime,
    this.updateTime,
    this.schemaTitle,
    this.schemaVersion,
    this.metadata,
    this.description,
  }) : super(fullyQualifiedName);

  factory Execution.fromJson(Map<String, dynamic> json) {
    return Execution(
      name: json['name'],
      displayName: json['displayName'],
      state: decodeEnum(json['state'], Execution_State.fromJson),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      schemaTitle: json['schemaTitle'],
      schemaVersion: json['schemaVersion'],
      metadata: decodeCustom(json['metadata'], protobuf.Struct.fromJson),
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (state != null) 'state': state!.toJson(),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (schemaTitle != null) 'schemaTitle': schemaTitle,
      if (schemaVersion != null) 'schemaVersion': schemaVersion,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (state != null) 'state=$state',
      if (etag != null) 'etag=$etag',
      if (schemaTitle != null) 'schemaTitle=$schemaTitle',
      if (schemaVersion != null) 'schemaVersion=$schemaVersion',
      if (description != null) 'description=$description',
    ].join(',');
    return 'Execution($contents)';
  }
}

/// Describes the state of the Execution.
final class Execution_State extends protobuf.ProtoEnum {
  /// Unspecified Execution state
  static const stateUnspecified = Execution_State('STATE_UNSPECIFIED');

  /// The Execution is new
  static const new$ = Execution_State('NEW');

  /// The Execution is running
  static const running = Execution_State('RUNNING');

  /// The Execution has finished running
  static const complete = Execution_State('COMPLETE');

  /// The Execution has failed
  static const failed = Execution_State('FAILED');

  /// The Execution completed through Cache hit.
  static const cached = Execution_State('CACHED');

  /// The Execution was cancelled.
  static const cancelled = Execution_State('CANCELLED');

  const Execution_State(super.value);

  factory Execution_State.fromJson(String json) => Execution_State(json);

  @override
  String toString() => 'State.$value';
}

/// Explanation of a prediction (provided in
/// `PredictResponse.predictions`)
/// produced by the Model on a given
/// `instance`.
final class Explanation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Explanation';

  /// Output only. Feature attributions grouped by predicted outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item.
  /// `Attribution.output_index`
  /// can be used to identify which output this attribution is explaining.
  ///
  /// By default, we provide Shapley values for the predicted class. However,
  /// you can configure the explanation request to generate Shapley values for
  /// any other classes too. For example, if a model predicts a probability of
  /// `0.4` for approving a loan application, the model's decision is to reject
  /// the application since `p(reject) = 0.6 > p(approve) = 0.4`, and the default
  /// Shapley values would be computed for rejection decision and not approval,
  /// even though the latter might be the positive class.
  ///
  /// If users set
  /// `ExplanationParameters.top_k`,
  /// the attributions are sorted by
  /// `instance_output_value` in descending
  /// order. If
  /// `ExplanationParameters.output_indices`
  /// is specified, the attributions are stored by
  /// `Attribution.output_index`
  /// in the same order as they appear in the output_indices.
  final List<Attribution>? attributions;

  /// Output only. List of the nearest neighbors for example-based explanations.
  ///
  /// For models deployed with the examples explanations feature enabled, the
  /// attributions field is empty and instead the neighbors field is populated.
  final List<Neighbor>? neighbors;

  Explanation({this.attributions, this.neighbors}) : super(fullyQualifiedName);

  factory Explanation.fromJson(Map<String, dynamic> json) {
    return Explanation(
      attributions: decodeListMessage(
        json['attributions'],
        Attribution.fromJson,
      ),
      neighbors: decodeListMessage(json['neighbors'], Neighbor.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (attributions != null) 'attributions': encodeList(attributions),
      if (neighbors != null) 'neighbors': encodeList(neighbors),
    };
  }

  @override
  String toString() => 'Explanation()';
}

/// Aggregated explanation metrics for a Model over a set of instances.
final class ModelExplanation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelExplanation';

  /// Output only. Aggregated attributions explaining the Model's prediction
  /// outputs over the set of instances. The attributions are grouped by outputs.
  ///
  /// For Models that predict only one output, such as regression Models that
  /// predict only one score, there is only one attibution that explains the
  /// predicted output. For Models that predict multiple outputs, such as
  /// multiclass Models that predict multiple classes, each element explains one
  /// specific item.
  /// `Attribution.output_index`
  /// can be used to identify which output this attribution is explaining.
  ///
  /// The
  /// `baselineOutputValue`,
  /// `instanceOutputValue`
  /// and
  /// `featureAttributions`
  /// fields are averaged over the test data.
  ///
  /// NOTE: Currently AutoML tabular classification Models produce only one
  /// attribution, which averages attributions over all the classes it predicts.
  /// `Attribution.approximation_error`
  /// is not populated.
  final List<Attribution>? meanAttributions;

  ModelExplanation({this.meanAttributions}) : super(fullyQualifiedName);

  factory ModelExplanation.fromJson(Map<String, dynamic> json) {
    return ModelExplanation(
      meanAttributions: decodeListMessage(
        json['meanAttributions'],
        Attribution.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (meanAttributions != null)
        'meanAttributions': encodeList(meanAttributions),
    };
  }

  @override
  String toString() => 'ModelExplanation()';
}

/// Attribution that explains a particular prediction output.
final class Attribution extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Attribution';

  /// Output only. Model predicted output if the input instance is constructed
  /// from the baselines of all the features defined in
  /// `ExplanationMetadata.inputs`.
  /// The field name of the output is determined by the key in
  /// `ExplanationMetadata.outputs`.
  ///
  /// If the Model's predicted output has multiple dimensions (rank > 1), this is
  /// the value in the output located by
  /// `output_index`.
  ///
  /// If there are multiple baselines, their output values are averaged.
  final double? baselineOutputValue;

  /// Output only. Model predicted output on the corresponding [explanation
  /// instance][ExplainRequest.instances]. The field name of the output is
  /// determined by the key in
  /// `ExplanationMetadata.outputs`.
  ///
  /// If the Model predicted output has multiple dimensions, this is the value in
  /// the output located by
  /// `output_index`.
  final double? instanceOutputValue;

  /// Output only. Attributions of each explained feature. Features are extracted
  /// from the [prediction
  /// instances][google.cloud.aiplatform.v1beta1.ExplainRequest.instances]
  /// according to [explanation metadata for
  /// inputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs].
  ///
  /// The value is a struct, whose keys are the name of the feature. The values
  /// are how much the feature in the
  /// `instance`
  /// contributed to the predicted result.
  ///
  /// The format of the value is determined by the feature's input format:
  ///
  ///   * If the feature is a scalar value, the attribution value is a
  ///     [floating number][google.protobuf.Value.number_value].
  ///
  ///   * If the feature is an array of scalar values, the attribution value is
  ///     an `array`.
  ///
  ///   * If the feature is a struct, the attribution value is a
  ///     `struct`. The keys in the
  ///     attribution value struct are the same as the keys in the feature
  ///     struct. The formats of the values in the attribution struct are
  ///     determined by the formats of the values in the feature struct.
  ///
  /// The
  /// `ExplanationMetadata.feature_attributions_schema_uri`
  /// field, pointed to by the
  /// `ExplanationSpec` field of
  /// the
  /// `Endpoint.deployed_models`
  /// object, points to the schema file that describes the features and their
  /// attribution values (if it is populated).
  final protobuf.Value? featureAttributions;

  /// Output only. The index that locates the explained prediction output.
  ///
  /// If the prediction output is a scalar value, output_index is not populated.
  /// If the prediction output has multiple dimensions, the length of the
  /// output_index list is the same as the number of dimensions of the output.
  /// The i-th element in output_index is the element index of the i-th dimension
  /// of the output vector. Indices start from 0.
  final List<int>? outputIndex;

  /// Output only. The display name of the output identified by
  /// `output_index`.
  /// For example, the predicted class name by a multi-classification Model.
  ///
  /// This field is only populated iff the Model predicts display names as a
  /// separate field along with the explained output. The predicted display name
  /// must has the same shape of the explained output, and can be located using
  /// output_index.
  final String? outputDisplayName;

  /// Output only. Error of
  /// `feature_attributions`
  /// caused by approximation used in the explanation method. Lower value means
  /// more precise attributions.
  ///
  /// * For Sampled Shapley
  /// `attribution`,
  /// increasing
  /// `path_count`
  /// might reduce the error.
  /// * For Integrated Gradients
  /// `attribution`,
  /// increasing
  /// `step_count`
  /// might reduce the error.
  /// * For [XRAI
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.xrai_attribution],
  /// increasing
  /// `step_count`
  /// might reduce the error.
  ///
  /// See [this introduction](/vertex-ai/docs/explainable-ai/overview)
  /// for more information.
  final double? approximationError;

  /// Output only. Name of the explain output. Specified as the key in
  /// `ExplanationMetadata.outputs`.
  final String? outputName;

  Attribution({
    this.baselineOutputValue,
    this.instanceOutputValue,
    this.featureAttributions,
    this.outputIndex,
    this.outputDisplayName,
    this.approximationError,
    this.outputName,
  }) : super(fullyQualifiedName);

  factory Attribution.fromJson(Map<String, dynamic> json) {
    return Attribution(
      baselineOutputValue: decodeDouble(json['baselineOutputValue']),
      instanceOutputValue: decodeDouble(json['instanceOutputValue']),
      featureAttributions: decodeCustom(
        json['featureAttributions'],
        protobuf.Value.fromJson,
      ),
      outputIndex: decodeList(json['outputIndex']),
      outputDisplayName: json['outputDisplayName'],
      approximationError: decodeDouble(json['approximationError']),
      outputName: json['outputName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (baselineOutputValue != null)
        'baselineOutputValue': encodeDouble(baselineOutputValue),
      if (instanceOutputValue != null)
        'instanceOutputValue': encodeDouble(instanceOutputValue),
      if (featureAttributions != null)
        'featureAttributions': featureAttributions!.toJson(),
      if (outputIndex != null) 'outputIndex': outputIndex,
      if (outputDisplayName != null) 'outputDisplayName': outputDisplayName,
      if (approximationError != null)
        'approximationError': encodeDouble(approximationError),
      if (outputName != null) 'outputName': outputName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (baselineOutputValue != null)
        'baselineOutputValue=$baselineOutputValue',
      if (instanceOutputValue != null)
        'instanceOutputValue=$instanceOutputValue',
      if (outputDisplayName != null) 'outputDisplayName=$outputDisplayName',
      if (approximationError != null) 'approximationError=$approximationError',
      if (outputName != null) 'outputName=$outputName',
    ].join(',');
    return 'Attribution($contents)';
  }
}

/// Neighbors for example-based explanations.
final class Neighbor extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Neighbor';

  /// Output only. The neighbor id.
  final String? neighborId;

  /// Output only. The neighbor distance.
  final double? neighborDistance;

  Neighbor({this.neighborId, this.neighborDistance})
    : super(fullyQualifiedName);

  factory Neighbor.fromJson(Map<String, dynamic> json) {
    return Neighbor(
      neighborId: json['neighborId'],
      neighborDistance: decodeDouble(json['neighborDistance']),
    );
  }

  @override
  Object toJson() {
    return {
      if (neighborId != null) 'neighborId': neighborId,
      if (neighborDistance != null)
        'neighborDistance': encodeDouble(neighborDistance),
    };
  }

  @override
  String toString() {
    final contents = [
      if (neighborId != null) 'neighborId=$neighborId',
      if (neighborDistance != null) 'neighborDistance=$neighborDistance',
    ].join(',');
    return 'Neighbor($contents)';
  }
}

/// Specification of Model explanation.
final class ExplanationSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationSpec';

  /// Required. Parameters that configure explaining of the Model's predictions.
  final ExplanationParameters? parameters;

  /// Optional. Metadata describing the Model's input and output for explanation.
  final ExplanationMetadata? metadata;

  ExplanationSpec({this.parameters, this.metadata}) : super(fullyQualifiedName);

  factory ExplanationSpec.fromJson(Map<String, dynamic> json) {
    return ExplanationSpec(
      parameters: decode(json['parameters'], ExplanationParameters.fromJson),
      metadata: decode(json['metadata'], ExplanationMetadata.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (parameters != null) 'parameters': parameters!.toJson(),
      if (metadata != null) 'metadata': metadata!.toJson(),
    };
  }

  @override
  String toString() => 'ExplanationSpec()';
}

/// Parameters to configure explaining for Model's predictions.
final class ExplanationParameters extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationParameters';

  /// An attribution method that approximates Shapley values for features that
  /// contribute to the label being predicted. A sampling strategy is used to
  /// approximate the value rather than considering all subsets of features.
  /// Refer to this paper for model details: https://arxiv.org/abs/1306.4265.
  final SampledShapleyAttribution? sampledShapleyAttribution;

  /// An attribution method that computes Aumann-Shapley values taking
  /// advantage of the model's fully differentiable structure. Refer to this
  /// paper for more details: https://arxiv.org/abs/1703.01365
  final IntegratedGradientsAttribution? integratedGradientsAttribution;

  /// An attribution method that redistributes Integrated Gradients
  /// attribution to segmented regions, taking advantage of the model's fully
  /// differentiable structure. Refer to this paper for
  /// more details: https://arxiv.org/abs/1906.02825
  ///
  /// XRAI currently performs better on natural images, like a picture of a
  /// house or an animal. If the images are taken in artificial environments,
  /// like a lab or manufacturing line, or from diagnostic equipment, like
  /// x-rays or quality-control cameras, use Integrated Gradients instead.
  final XraiAttribution? xraiAttribution;

  /// Example-based explanations that returns the nearest neighbors from the
  /// provided dataset.
  final Examples? examples;

  /// If populated, returns attributions for top K indices of outputs
  /// (defaults to 1). Only applies to Models that predicts more than one outputs
  /// (e,g, multi-class Models). When set to -1, returns explanations for all
  /// outputs.
  final int? topK;

  /// If populated, only returns attributions that have
  /// `output_index`
  /// contained in output_indices. It must be an ndarray of integers, with the
  /// same shape of the output it's explaining.
  ///
  /// If not populated, returns attributions for
  /// `top_k`
  /// indices of outputs. If neither top_k nor output_indices is populated,
  /// returns the argmax index of the outputs.
  ///
  /// Only applicable to Models that predict multiple outputs (e,g, multi-class
  /// Models that predict multiple classes).
  final protobuf.ListValue? outputIndices;

  ExplanationParameters({
    this.sampledShapleyAttribution,
    this.integratedGradientsAttribution,
    this.xraiAttribution,
    this.examples,
    this.topK,
    this.outputIndices,
  }) : super(fullyQualifiedName);

  factory ExplanationParameters.fromJson(Map<String, dynamic> json) {
    return ExplanationParameters(
      sampledShapleyAttribution: decode(
        json['sampledShapleyAttribution'],
        SampledShapleyAttribution.fromJson,
      ),
      integratedGradientsAttribution: decode(
        json['integratedGradientsAttribution'],
        IntegratedGradientsAttribution.fromJson,
      ),
      xraiAttribution: decode(
        json['xraiAttribution'],
        XraiAttribution.fromJson,
      ),
      examples: decode(json['examples'], Examples.fromJson),
      topK: json['topK'],
      outputIndices: decodeCustom(
        json['outputIndices'],
        protobuf.ListValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (sampledShapleyAttribution != null)
        'sampledShapleyAttribution': sampledShapleyAttribution!.toJson(),
      if (integratedGradientsAttribution != null)
        'integratedGradientsAttribution': integratedGradientsAttribution!
            .toJson(),
      if (xraiAttribution != null) 'xraiAttribution': xraiAttribution!.toJson(),
      if (examples != null) 'examples': examples!.toJson(),
      if (topK != null) 'topK': topK,
      if (outputIndices != null) 'outputIndices': outputIndices!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (topK != null) 'topK=$topK'].join(',');
    return 'ExplanationParameters($contents)';
  }
}

/// An attribution method that approximates Shapley values for features that
/// contribute to the label being predicted. A sampling strategy is used to
/// approximate the value rather than considering all subsets of features.
final class SampledShapleyAttribution extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SampledShapleyAttribution';

  /// Required. The number of feature permutations to consider when approximating
  /// the Shapley values.
  ///
  /// Valid range of its value is [1, 50], inclusively.
  final int? pathCount;

  SampledShapleyAttribution({this.pathCount}) : super(fullyQualifiedName);

  factory SampledShapleyAttribution.fromJson(Map<String, dynamic> json) {
    return SampledShapleyAttribution(pathCount: json['pathCount']);
  }

  @override
  Object toJson() {
    return {if (pathCount != null) 'pathCount': pathCount};
  }

  @override
  String toString() {
    final contents = [if (pathCount != null) 'pathCount=$pathCount'].join(',');
    return 'SampledShapleyAttribution($contents)';
  }
}

/// An attribution method that computes the Aumann-Shapley value taking advantage
/// of the model's fully differentiable structure. Refer to this paper for
/// more details: https://arxiv.org/abs/1703.01365
final class IntegratedGradientsAttribution extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IntegratedGradientsAttribution';

  /// Required. The number of steps for approximating the path integral.
  /// A good value to start is 50 and gradually increase until the
  /// sum to diff property is within the desired error range.
  ///
  /// Valid range of its value is [1, 100], inclusively.
  final int? stepCount;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding
  /// noise can help improve the computed gradients. Refer to this paper for more
  /// details: https://arxiv.org/pdf/1706.03825.pdf
  final SmoothGradConfig? smoothGradConfig;

  /// Config for IG with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image) is
  /// motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  final BlurBaselineConfig? blurBaselineConfig;

  IntegratedGradientsAttribution({
    this.stepCount,
    this.smoothGradConfig,
    this.blurBaselineConfig,
  }) : super(fullyQualifiedName);

  factory IntegratedGradientsAttribution.fromJson(Map<String, dynamic> json) {
    return IntegratedGradientsAttribution(
      stepCount: json['stepCount'],
      smoothGradConfig: decode(
        json['smoothGradConfig'],
        SmoothGradConfig.fromJson,
      ),
      blurBaselineConfig: decode(
        json['blurBaselineConfig'],
        BlurBaselineConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (stepCount != null) 'stepCount': stepCount,
      if (smoothGradConfig != null)
        'smoothGradConfig': smoothGradConfig!.toJson(),
      if (blurBaselineConfig != null)
        'blurBaselineConfig': blurBaselineConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (stepCount != null) 'stepCount=$stepCount'].join(',');
    return 'IntegratedGradientsAttribution($contents)';
  }
}

/// An explanation method that redistributes Integrated Gradients
/// attributions to segmented regions, taking advantage of the model's fully
/// differentiable structure. Refer to this paper for more details:
/// https://arxiv.org/abs/1906.02825
///
/// Supported only by image Models.
final class XraiAttribution extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.XraiAttribution';

  /// Required. The number of steps for approximating the path integral.
  /// A good value to start is 50 and gradually increase until the
  /// sum to diff property is met within the desired error range.
  ///
  /// Valid range of its value is [1, 100], inclusively.
  final int? stepCount;

  /// Config for SmoothGrad approximation of gradients.
  ///
  /// When enabled, the gradients are approximated by averaging the gradients
  /// from noisy samples in the vicinity of the inputs. Adding
  /// noise can help improve the computed gradients. Refer to this paper for more
  /// details: https://arxiv.org/pdf/1706.03825.pdf
  final SmoothGradConfig? smoothGradConfig;

  /// Config for XRAI with blur baseline.
  ///
  /// When enabled, a linear path from the maximally blurred image to the input
  /// image is created. Using a blurred baseline instead of zero (black image) is
  /// motivated by the BlurIG approach explained here:
  /// https://arxiv.org/abs/2004.03383
  final BlurBaselineConfig? blurBaselineConfig;

  XraiAttribution({
    this.stepCount,
    this.smoothGradConfig,
    this.blurBaselineConfig,
  }) : super(fullyQualifiedName);

  factory XraiAttribution.fromJson(Map<String, dynamic> json) {
    return XraiAttribution(
      stepCount: json['stepCount'],
      smoothGradConfig: decode(
        json['smoothGradConfig'],
        SmoothGradConfig.fromJson,
      ),
      blurBaselineConfig: decode(
        json['blurBaselineConfig'],
        BlurBaselineConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (stepCount != null) 'stepCount': stepCount,
      if (smoothGradConfig != null)
        'smoothGradConfig': smoothGradConfig!.toJson(),
      if (blurBaselineConfig != null)
        'blurBaselineConfig': blurBaselineConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (stepCount != null) 'stepCount=$stepCount'].join(',');
    return 'XraiAttribution($contents)';
  }
}

/// Config for SmoothGrad approximation of gradients.
///
/// When enabled, the gradients are approximated by averaging the gradients from
/// noisy samples in the vicinity of the inputs. Adding noise can help improve
/// the computed gradients. Refer to this paper for more details:
/// https://arxiv.org/pdf/1706.03825.pdf
final class SmoothGradConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SmoothGradConfig';

  /// This is a single float value and will be used to add noise to all the
  /// features. Use this field when all features are normalized to have the
  /// same distribution: scale to range [0, 1], [-1, 1] or z-scoring, where
  /// features are normalized to have 0-mean and 1-variance. Learn more about
  /// [normalization](https://developers.google.com/machine-learning/data-prep/transform/normalization).
  ///
  /// For best results the recommended value is about 10% - 20% of the standard
  /// deviation of the input feature. Refer to section 3.2 of the SmoothGrad
  /// paper: https://arxiv.org/pdf/1706.03825.pdf. Defaults to 0.1.
  ///
  /// If the distribution is different per feature, set
  /// `feature_noise_sigma`
  /// instead for each feature.
  final double? noiseSigma;

  /// This is similar to
  /// `noise_sigma`,
  /// but provides additional flexibility. A separate noise sigma can be
  /// provided for each feature, which is useful if their distributions are
  /// different. No noise is added to features that are not set. If this field
  /// is unset,
  /// `noise_sigma`
  /// will be used for all features.
  final FeatureNoiseSigma? featureNoiseSigma;

  /// The number of gradient samples to use for
  /// approximation. The higher this number, the more accurate the gradient
  /// is, but the runtime complexity increases by this factor as well.
  /// Valid range of its value is [1, 50]. Defaults to 3.
  final int? noisySampleCount;

  SmoothGradConfig({
    this.noiseSigma,
    this.featureNoiseSigma,
    this.noisySampleCount,
  }) : super(fullyQualifiedName);

  factory SmoothGradConfig.fromJson(Map<String, dynamic> json) {
    return SmoothGradConfig(
      noiseSigma: decodeDouble(json['noiseSigma']),
      featureNoiseSigma: decode(
        json['featureNoiseSigma'],
        FeatureNoiseSigma.fromJson,
      ),
      noisySampleCount: json['noisySampleCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (noiseSigma != null) 'noiseSigma': encodeDouble(noiseSigma),
      if (featureNoiseSigma != null)
        'featureNoiseSigma': featureNoiseSigma!.toJson(),
      if (noisySampleCount != null) 'noisySampleCount': noisySampleCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (noiseSigma != null) 'noiseSigma=$noiseSigma',
      if (noisySampleCount != null) 'noisySampleCount=$noisySampleCount',
    ].join(',');
    return 'SmoothGradConfig($contents)';
  }
}

/// Noise sigma by features. Noise sigma represents the standard deviation of the
/// gaussian kernel that will be used to add noise to interpolated inputs prior
/// to computing gradients.
final class FeatureNoiseSigma extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureNoiseSigma';

  /// Noise sigma per feature. No noise is added to features that are not set.
  final List<FeatureNoiseSigma_NoiseSigmaForFeature>? noiseSigma;

  FeatureNoiseSigma({this.noiseSigma}) : super(fullyQualifiedName);

  factory FeatureNoiseSigma.fromJson(Map<String, dynamic> json) {
    return FeatureNoiseSigma(
      noiseSigma: decodeListMessage(
        json['noiseSigma'],
        FeatureNoiseSigma_NoiseSigmaForFeature.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (noiseSigma != null) 'noiseSigma': encodeList(noiseSigma)};
  }

  @override
  String toString() => 'FeatureNoiseSigma()';
}

/// Noise sigma for a single feature.
final class FeatureNoiseSigma_NoiseSigmaForFeature
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureNoiseSigma.NoiseSigmaForFeature';

  /// The name of the input feature for which noise sigma is provided. The
  /// features are defined in
  /// [explanation metadata
  /// inputs][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs].
  final String? name;

  /// This represents the standard deviation of the Gaussian kernel that will
  /// be used to add noise to the feature prior to computing gradients. Similar
  /// to
  /// `noise_sigma`
  /// but represents the noise added to the current feature. Defaults to 0.1.
  final double? sigma;

  FeatureNoiseSigma_NoiseSigmaForFeature({this.name, this.sigma})
    : super(fullyQualifiedName);

  factory FeatureNoiseSigma_NoiseSigmaForFeature.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureNoiseSigma_NoiseSigmaForFeature(
      name: json['name'],
      sigma: decodeDouble(json['sigma']),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (sigma != null) 'sigma': encodeDouble(sigma),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (sigma != null) 'sigma=$sigma',
    ].join(',');
    return 'NoiseSigmaForFeature($contents)';
  }
}

/// Config for blur baseline.
///
/// When enabled, a linear path from the maximally blurred image to the input
/// image is created. Using a blurred baseline instead of zero (black image) is
/// motivated by the BlurIG approach explained here:
/// https://arxiv.org/abs/2004.03383
final class BlurBaselineConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BlurBaselineConfig';

  /// The standard deviation of the blur kernel for the blurred baseline. The
  /// same blurring parameter is used for both the height and the width
  /// dimension. If not set, the method defaults to the zero (i.e. black for
  /// images) baseline.
  final double? maxBlurSigma;

  BlurBaselineConfig({this.maxBlurSigma}) : super(fullyQualifiedName);

  factory BlurBaselineConfig.fromJson(Map<String, dynamic> json) {
    return BlurBaselineConfig(maxBlurSigma: decodeDouble(json['maxBlurSigma']));
  }

  @override
  Object toJson() {
    return {
      if (maxBlurSigma != null) 'maxBlurSigma': encodeDouble(maxBlurSigma),
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxBlurSigma != null) 'maxBlurSigma=$maxBlurSigma',
    ].join(',');
    return 'BlurBaselineConfig($contents)';
  }
}

/// Example-based explainability that returns the nearest neighbors from the
/// provided dataset.
final class Examples extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Examples';

  /// The Cloud Storage input instances.
  final Examples_ExampleGcsSource? exampleGcsSource;

  /// The full configuration for the generated index, the semantics are the
  /// same as `metadata` and
  /// should match
  /// [NearestNeighborSearchConfig](https://cloud.google.com/vertex-ai/docs/explainable-ai/configuring-explanations-example-based#nearest-neighbor-search-config).
  final protobuf.Value? nearestNeighborSearchConfig;

  /// Simplified preset configuration, which automatically sets configuration
  /// values based on the desired query speed-precision trade-off and modality.
  final Presets? presets;

  /// The Cloud Storage locations that contain the instances to be
  /// indexed for approximate nearest neighbor search.
  final GcsSource? gcsSource;

  /// The number of neighbors to return when querying for examples.
  final int? neighborCount;

  Examples({
    this.exampleGcsSource,
    this.nearestNeighborSearchConfig,
    this.presets,
    this.gcsSource,
    this.neighborCount,
  }) : super(fullyQualifiedName);

  factory Examples.fromJson(Map<String, dynamic> json) {
    return Examples(
      exampleGcsSource: decode(
        json['exampleGcsSource'],
        Examples_ExampleGcsSource.fromJson,
      ),
      nearestNeighborSearchConfig: decodeCustom(
        json['nearestNeighborSearchConfig'],
        protobuf.Value.fromJson,
      ),
      presets: decode(json['presets'], Presets.fromJson),
      gcsSource: decode(json['gcsSource'], GcsSource.fromJson),
      neighborCount: json['neighborCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (exampleGcsSource != null)
        'exampleGcsSource': exampleGcsSource!.toJson(),
      if (nearestNeighborSearchConfig != null)
        'nearestNeighborSearchConfig': nearestNeighborSearchConfig!.toJson(),
      if (presets != null) 'presets': presets!.toJson(),
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
      if (neighborCount != null) 'neighborCount': neighborCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (neighborCount != null) 'neighborCount=$neighborCount',
    ].join(',');
    return 'Examples($contents)';
  }
}

/// The Cloud Storage input instances.
final class Examples_ExampleGcsSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Examples.ExampleGcsSource';

  /// The format in which instances are given, if not specified, assume it's
  /// JSONL format. Currently only JSONL format is supported.
  final Examples_ExampleGcsSource_DataFormat? dataFormat;

  /// The Cloud Storage location for the input instances.
  final GcsSource? gcsSource;

  Examples_ExampleGcsSource({this.dataFormat, this.gcsSource})
    : super(fullyQualifiedName);

  factory Examples_ExampleGcsSource.fromJson(Map<String, dynamic> json) {
    return Examples_ExampleGcsSource(
      dataFormat: decodeEnum(
        json['dataFormat'],
        Examples_ExampleGcsSource_DataFormat.fromJson,
      ),
      gcsSource: decode(json['gcsSource'], GcsSource.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataFormat != null) 'dataFormat': dataFormat!.toJson(),
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataFormat != null) 'dataFormat=$dataFormat',
    ].join(',');
    return 'ExampleGcsSource($contents)';
  }
}

/// The format of the input example instances.
final class Examples_ExampleGcsSource_DataFormat extends protobuf.ProtoEnum {
  /// Format unspecified, used when unset.
  static const dataFormatUnspecified = Examples_ExampleGcsSource_DataFormat(
    'DATA_FORMAT_UNSPECIFIED',
  );

  /// Examples are stored in JSONL files.
  static const jsonl = Examples_ExampleGcsSource_DataFormat('JSONL');

  const Examples_ExampleGcsSource_DataFormat(super.value);

  factory Examples_ExampleGcsSource_DataFormat.fromJson(String json) =>
      Examples_ExampleGcsSource_DataFormat(json);

  @override
  String toString() => 'DataFormat.$value';
}

/// Preset configuration for example-based explanations
final class Presets extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Presets';

  /// Preset option controlling parameters for speed-precision trade-off when
  /// querying for examples. If omitted, defaults to `PRECISE`.
  final Presets_Query? query;

  /// The modality of the uploaded model, which automatically configures the
  /// distance measurement and feature normalization for the underlying example
  /// index and queries. If your model does not precisely fit one of these types,
  /// it is okay to choose the closest type.
  final Presets_Modality? modality;

  Presets({this.query, this.modality}) : super(fullyQualifiedName);

  factory Presets.fromJson(Map<String, dynamic> json) {
    return Presets(
      query: decodeEnum(json['query'], Presets_Query.fromJson),
      modality: decodeEnum(json['modality'], Presets_Modality.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (query != null) 'query': query!.toJson(),
      if (modality != null) 'modality': modality!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (query != null) 'query=$query',
      if (modality != null) 'modality=$modality',
    ].join(',');
    return 'Presets($contents)';
  }
}

/// Preset option controlling parameters for query speed-precision trade-off
final class Presets_Query extends protobuf.ProtoEnum {
  /// More precise neighbors as a trade-off against slower response.
  static const precise = Presets_Query('PRECISE');

  /// Faster response as a trade-off against less precise neighbors.
  static const fast = Presets_Query('FAST');

  const Presets_Query(super.value);

  factory Presets_Query.fromJson(String json) => Presets_Query(json);

  @override
  String toString() => 'Query.$value';
}

/// Preset option controlling parameters for different modalities
final class Presets_Modality extends protobuf.ProtoEnum {
  /// Should not be set. Added as a recommended best practice for enums
  static const modalityUnspecified = Presets_Modality('MODALITY_UNSPECIFIED');

  /// IMAGE modality
  static const image = Presets_Modality('IMAGE');

  /// TEXT modality
  static const text = Presets_Modality('TEXT');

  /// TABULAR modality
  static const tabular = Presets_Modality('TABULAR');

  const Presets_Modality(super.value);

  factory Presets_Modality.fromJson(String json) => Presets_Modality(json);

  @override
  String toString() => 'Modality.$value';
}

/// The `ExplanationSpec`
/// entries that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1beta1.PredictionService.Explain] time.
final class ExplanationSpecOverride extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationSpecOverride';

  /// The parameters to be overridden. Note that the
  /// attribution method cannot be changed. If not specified,
  /// no parameter is overridden.
  final ExplanationParameters? parameters;

  /// The metadata to be overridden. If not specified, no metadata is overridden.
  final ExplanationMetadataOverride? metadata;

  /// The example-based explanations parameter overrides.
  final ExamplesOverride? examplesOverride;

  ExplanationSpecOverride({
    this.parameters,
    this.metadata,
    this.examplesOverride,
  }) : super(fullyQualifiedName);

  factory ExplanationSpecOverride.fromJson(Map<String, dynamic> json) {
    return ExplanationSpecOverride(
      parameters: decode(json['parameters'], ExplanationParameters.fromJson),
      metadata: decode(json['metadata'], ExplanationMetadataOverride.fromJson),
      examplesOverride: decode(
        json['examplesOverride'],
        ExamplesOverride.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (parameters != null) 'parameters': parameters!.toJson(),
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (examplesOverride != null)
        'examplesOverride': examplesOverride!.toJson(),
    };
  }

  @override
  String toString() => 'ExplanationSpecOverride()';
}

/// The
/// `ExplanationMetadata`
/// entries that can be overridden at [online
/// explanation][google.cloud.aiplatform.v1beta1.PredictionService.Explain] time.
final class ExplanationMetadataOverride extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadataOverride';

  /// Required. Overrides the [input
  /// metadata][google.cloud.aiplatform.v1beta1.ExplanationMetadata.inputs] of
  /// the features. The key is the name of the feature to be overridden. The keys
  /// specified here must exist in the input metadata to be overridden. If a
  /// feature is not specified here, the corresponding feature's input metadata
  /// is not overridden.
  final Map<String, ExplanationMetadataOverride_InputMetadataOverride>? inputs;

  ExplanationMetadataOverride({this.inputs}) : super(fullyQualifiedName);

  factory ExplanationMetadataOverride.fromJson(Map<String, dynamic> json) {
    return ExplanationMetadataOverride(
      inputs: decodeMapMessage(
        json['inputs'],
        ExplanationMetadataOverride_InputMetadataOverride.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (inputs != null) 'inputs': encodeMap(inputs)};
  }

  @override
  String toString() => 'ExplanationMetadataOverride()';
}

/// The [input
/// metadata][google.cloud.aiplatform.v1beta1.ExplanationMetadata.InputMetadata]
/// entries to be overridden.
final class ExplanationMetadataOverride_InputMetadataOverride
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadataOverride.InputMetadataOverride';

  /// Baseline inputs for this feature.
  ///
  /// This overrides the `input_baseline` field of the
  /// `ExplanationMetadata.InputMetadata`
  /// object of the corresponding feature's input metadata. If it's not
  /// specified, the original baselines are not overridden.
  final List<protobuf.Value>? inputBaselines;

  ExplanationMetadataOverride_InputMetadataOverride({this.inputBaselines})
    : super(fullyQualifiedName);

  factory ExplanationMetadataOverride_InputMetadataOverride.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExplanationMetadataOverride_InputMetadataOverride(
      inputBaselines: decodeListMessageCustom(
        json['inputBaselines'],
        protobuf.Value.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (inputBaselines != null) 'inputBaselines': encodeList(inputBaselines),
    };
  }

  @override
  String toString() => 'InputMetadataOverride()';
}

/// Overrides for example-based explanations.
final class ExamplesOverride extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExamplesOverride';

  /// The number of neighbors to return.
  final int? neighborCount;

  /// The number of neighbors to return that have the same crowding tag.
  final int? crowdingCount;

  /// Restrict the resulting nearest neighbors to respect these constraints.
  final List<ExamplesRestrictionsNamespace>? restrictions;

  /// If true, return the embeddings instead of neighbors.
  final bool? returnEmbeddings;

  /// The format of the data being provided with each call.
  final ExamplesOverride_DataFormat? dataFormat;

  ExamplesOverride({
    this.neighborCount,
    this.crowdingCount,
    this.restrictions,
    this.returnEmbeddings,
    this.dataFormat,
  }) : super(fullyQualifiedName);

  factory ExamplesOverride.fromJson(Map<String, dynamic> json) {
    return ExamplesOverride(
      neighborCount: json['neighborCount'],
      crowdingCount: json['crowdingCount'],
      restrictions: decodeListMessage(
        json['restrictions'],
        ExamplesRestrictionsNamespace.fromJson,
      ),
      returnEmbeddings: json['returnEmbeddings'],
      dataFormat: decodeEnum(
        json['dataFormat'],
        ExamplesOverride_DataFormat.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (neighborCount != null) 'neighborCount': neighborCount,
      if (crowdingCount != null) 'crowdingCount': crowdingCount,
      if (restrictions != null) 'restrictions': encodeList(restrictions),
      if (returnEmbeddings != null) 'returnEmbeddings': returnEmbeddings,
      if (dataFormat != null) 'dataFormat': dataFormat!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (neighborCount != null) 'neighborCount=$neighborCount',
      if (crowdingCount != null) 'crowdingCount=$crowdingCount',
      if (returnEmbeddings != null) 'returnEmbeddings=$returnEmbeddings',
      if (dataFormat != null) 'dataFormat=$dataFormat',
    ].join(',');
    return 'ExamplesOverride($contents)';
  }
}

/// Data format enum.
final class ExamplesOverride_DataFormat extends protobuf.ProtoEnum {
  /// Unspecified format. Must not be used.
  static const dataFormatUnspecified = ExamplesOverride_DataFormat(
    'DATA_FORMAT_UNSPECIFIED',
  );

  /// Provided data is a set of model inputs.
  static const instances = ExamplesOverride_DataFormat('INSTANCES');

  /// Provided data is a set of embeddings.
  static const embeddings = ExamplesOverride_DataFormat('EMBEDDINGS');

  const ExamplesOverride_DataFormat(super.value);

  factory ExamplesOverride_DataFormat.fromJson(String json) =>
      ExamplesOverride_DataFormat(json);

  @override
  String toString() => 'DataFormat.$value';
}

/// Restrictions namespace for example-based explanations overrides.
final class ExamplesRestrictionsNamespace extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExamplesRestrictionsNamespace';

  /// The namespace name.
  final String? namespaceName;

  /// The list of allowed tags.
  final List<String>? allow;

  /// The list of deny tags.
  final List<String>? deny;

  ExamplesRestrictionsNamespace({this.namespaceName, this.allow, this.deny})
    : super(fullyQualifiedName);

  factory ExamplesRestrictionsNamespace.fromJson(Map<String, dynamic> json) {
    return ExamplesRestrictionsNamespace(
      namespaceName: json['namespaceName'],
      allow: decodeList(json['allow']),
      deny: decodeList(json['deny']),
    );
  }

  @override
  Object toJson() {
    return {
      if (namespaceName != null) 'namespaceName': namespaceName,
      if (allow != null) 'allow': allow,
      if (deny != null) 'deny': deny,
    };
  }

  @override
  String toString() {
    final contents = [
      if (namespaceName != null) 'namespaceName=$namespaceName',
    ].join(',');
    return 'ExamplesRestrictionsNamespace($contents)';
  }
}

/// Metadata describing the Model's input and output for explanation.
final class ExplanationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata';

  /// Required. Map from feature names to feature input metadata. Keys are the
  /// name of the features. Values are the specification of the feature.
  ///
  /// An empty InputMetadata is valid. It describes a text feature which has the
  /// name specified as the key in
  /// `ExplanationMetadata.inputs`.
  /// The baseline of the empty feature is chosen by Vertex AI.
  ///
  /// For Vertex AI-provided Tensorflow images, the key can be any friendly
  /// name of the feature. Once specified,
  /// `featureAttributions`
  /// are keyed by this key (if not grouped with another feature).
  ///
  /// For custom images, the key must match with the key in
  /// `instance`.
  final Map<String, ExplanationMetadata_InputMetadata>? inputs;

  /// Required. Map from output names to output metadata.
  ///
  /// For Vertex AI-provided Tensorflow images, keys can be any user defined
  /// string that consists of any UTF-8 characters.
  ///
  /// For custom images, keys are the name of the output field in the prediction
  /// to be explained.
  ///
  /// Currently only one key is allowed.
  final Map<String, ExplanationMetadata_OutputMetadata>? outputs;

  /// Points to a YAML file stored on Google Cloud Storage describing the format
  /// of the [feature
  /// attributions][google.cloud.aiplatform.v1beta1.Attribution.feature_attributions].
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML tabular Models always have this field populated by Vertex AI.
  /// Note: The URI given on output may be different, including the URI scheme,
  /// than the one given on input. The output URI will point to a location where
  /// the user only has a read access.
  final String? featureAttributionsSchemaUri;

  /// Name of the source to generate embeddings for example based explanations.
  final String? latentSpaceSource;

  ExplanationMetadata({
    this.inputs,
    this.outputs,
    this.featureAttributionsSchemaUri,
    this.latentSpaceSource,
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata.fromJson(Map<String, dynamic> json) {
    return ExplanationMetadata(
      inputs: decodeMapMessage(
        json['inputs'],
        ExplanationMetadata_InputMetadata.fromJson,
      ),
      outputs: decodeMapMessage(
        json['outputs'],
        ExplanationMetadata_OutputMetadata.fromJson,
      ),
      featureAttributionsSchemaUri: json['featureAttributionsSchemaUri'],
      latentSpaceSource: json['latentSpaceSource'],
    );
  }

  @override
  Object toJson() {
    return {
      if (inputs != null) 'inputs': encodeMap(inputs),
      if (outputs != null) 'outputs': encodeMap(outputs),
      if (featureAttributionsSchemaUri != null)
        'featureAttributionsSchemaUri': featureAttributionsSchemaUri,
      if (latentSpaceSource != null) 'latentSpaceSource': latentSpaceSource,
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureAttributionsSchemaUri != null)
        'featureAttributionsSchemaUri=$featureAttributionsSchemaUri',
      if (latentSpaceSource != null) 'latentSpaceSource=$latentSpaceSource',
    ].join(',');
    return 'ExplanationMetadata($contents)';
  }
}

/// Metadata of the input of a feature.
///
/// Fields other than
/// `InputMetadata.input_baselines`
/// are applicable only for Models that are using Vertex AI-provided images for
/// Tensorflow.
final class ExplanationMetadata_InputMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata.InputMetadata';

  /// Baseline inputs for this feature.
  ///
  /// If no baseline is specified, Vertex AI chooses the baseline for this
  /// feature. If multiple baselines are specified, Vertex AI returns the
  /// average attributions across them in
  /// `Attribution.feature_attributions`.
  ///
  /// For Vertex AI-provided Tensorflow images (both 1.x and 2.x), the shape
  /// of each baseline must match the shape of the input tensor. If a scalar is
  /// provided, we broadcast to the same shape as the input tensor.
  ///
  /// For custom images, the element of the baselines must be in the same
  /// format as the feature's input in the
  /// `instance`[].
  /// The schema of any single instance may be specified via Endpoint's
  /// DeployedModels'
  /// [Model's][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`.
  final List<protobuf.Value>? inputBaselines;

  /// Name of the input tensor for this feature. Required and is only
  /// applicable to Vertex AI-provided images for Tensorflow.
  final String? inputTensorName;

  /// Defines how the feature is encoded into the input tensor. Defaults to
  /// IDENTITY.
  final ExplanationMetadata_InputMetadata_Encoding? encoding;

  /// Modality of the feature. Valid values are: numeric, image. Defaults to
  /// numeric.
  final String? modality;

  /// The domain details of the input feature value. Like min/max, original
  /// mean or standard deviation if normalized.
  final ExplanationMetadata_InputMetadata_FeatureValueDomain?
  featureValueDomain;

  /// Specifies the index of the values of the input tensor.
  /// Required when the input tensor is a sparse representation. Refer to
  /// Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  final String? indicesTensorName;

  /// Specifies the shape of the values of the input if the input is a sparse
  /// representation. Refer to Tensorflow documentation for more details:
  /// https://www.tensorflow.org/api_docs/python/tf/sparse/SparseTensor.
  final String? denseShapeTensorName;

  /// A list of feature names for each index in the input tensor.
  /// Required when the input
  /// `InputMetadata.encoding`
  /// is BAG_OF_FEATURES, BAG_OF_FEATURES_SPARSE, INDICATOR.
  final List<String>? indexFeatureMapping;

  /// Encoded tensor is a transformation of the input tensor. Must be provided
  /// if choosing
  /// [Integrated Gradients
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.integrated_gradients_attribution]
  /// or [XRAI
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.xrai_attribution]
  /// and the input tensor is not differentiable.
  ///
  /// An encoded tensor is generated if the input tensor is encoded by a lookup
  /// table.
  final String? encodedTensorName;

  /// A list of baselines for the encoded tensor.
  ///
  /// The shape of each baseline should match the shape of the encoded tensor.
  /// If a scalar is provided, Vertex AI broadcasts to the same shape as the
  /// encoded tensor.
  final List<protobuf.Value>? encodedBaselines;

  /// Visualization configurations for image explanation.
  final ExplanationMetadata_InputMetadata_Visualization? visualization;

  /// Name of the group that the input belongs to. Features with the same group
  /// name will be treated as one feature when computing attributions. Features
  /// grouped together can have different shapes in value. If provided, there
  /// will be one single attribution generated in
  /// `Attribution.feature_attributions`,
  /// keyed by the group name.
  final String? groupName;

  ExplanationMetadata_InputMetadata({
    this.inputBaselines,
    this.inputTensorName,
    this.encoding,
    this.modality,
    this.featureValueDomain,
    this.indicesTensorName,
    this.denseShapeTensorName,
    this.indexFeatureMapping,
    this.encodedTensorName,
    this.encodedBaselines,
    this.visualization,
    this.groupName,
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata_InputMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExplanationMetadata_InputMetadata(
      inputBaselines: decodeListMessageCustom(
        json['inputBaselines'],
        protobuf.Value.fromJson,
      ),
      inputTensorName: json['inputTensorName'],
      encoding: decodeEnum(
        json['encoding'],
        ExplanationMetadata_InputMetadata_Encoding.fromJson,
      ),
      modality: json['modality'],
      featureValueDomain: decode(
        json['featureValueDomain'],
        ExplanationMetadata_InputMetadata_FeatureValueDomain.fromJson,
      ),
      indicesTensorName: json['indicesTensorName'],
      denseShapeTensorName: json['denseShapeTensorName'],
      indexFeatureMapping: decodeList(json['indexFeatureMapping']),
      encodedTensorName: json['encodedTensorName'],
      encodedBaselines: decodeListMessageCustom(
        json['encodedBaselines'],
        protobuf.Value.fromJson,
      ),
      visualization: decode(
        json['visualization'],
        ExplanationMetadata_InputMetadata_Visualization.fromJson,
      ),
      groupName: json['groupName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (inputBaselines != null) 'inputBaselines': encodeList(inputBaselines),
      if (inputTensorName != null) 'inputTensorName': inputTensorName,
      if (encoding != null) 'encoding': encoding!.toJson(),
      if (modality != null) 'modality': modality,
      if (featureValueDomain != null)
        'featureValueDomain': featureValueDomain!.toJson(),
      if (indicesTensorName != null) 'indicesTensorName': indicesTensorName,
      if (denseShapeTensorName != null)
        'denseShapeTensorName': denseShapeTensorName,
      if (indexFeatureMapping != null)
        'indexFeatureMapping': indexFeatureMapping,
      if (encodedTensorName != null) 'encodedTensorName': encodedTensorName,
      if (encodedBaselines != null)
        'encodedBaselines': encodeList(encodedBaselines),
      if (visualization != null) 'visualization': visualization!.toJson(),
      if (groupName != null) 'groupName': groupName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (inputTensorName != null) 'inputTensorName=$inputTensorName',
      if (encoding != null) 'encoding=$encoding',
      if (modality != null) 'modality=$modality',
      if (indicesTensorName != null) 'indicesTensorName=$indicesTensorName',
      if (denseShapeTensorName != null)
        'denseShapeTensorName=$denseShapeTensorName',
      if (encodedTensorName != null) 'encodedTensorName=$encodedTensorName',
      if (groupName != null) 'groupName=$groupName',
    ].join(',');
    return 'InputMetadata($contents)';
  }
}

/// Domain details of the input feature value. Provides numeric information
/// about the feature, such as its range (min, max). If the feature has been
/// pre-processed, for example with z-scoring, then it provides information
/// about how to recover the original feature. For example, if the input
/// feature is an image and it has been pre-processed to obtain 0-mean and
/// stddev = 1 values, then original_mean, and original_stddev refer to the
/// mean and stddev of the original feature (e.g. image tensor) from which
/// input feature (with mean = 0 and stddev = 1) was obtained.
final class ExplanationMetadata_InputMetadata_FeatureValueDomain
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata.InputMetadata.FeatureValueDomain';

  /// The minimum permissible value for this feature.
  final double? minValue;

  /// The maximum permissible value for this feature.
  final double? maxValue;

  /// If this input feature has been normalized to a mean value of 0,
  /// the original_mean specifies the mean value of the domain prior to
  /// normalization.
  final double? originalMean;

  /// If this input feature has been normalized to a standard deviation of
  /// 1.0, the original_stddev specifies the standard deviation of the domain
  /// prior to normalization.
  final double? originalStddev;

  ExplanationMetadata_InputMetadata_FeatureValueDomain({
    this.minValue,
    this.maxValue,
    this.originalMean,
    this.originalStddev,
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata_InputMetadata_FeatureValueDomain.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExplanationMetadata_InputMetadata_FeatureValueDomain(
      minValue: decodeDouble(json['minValue']),
      maxValue: decodeDouble(json['maxValue']),
      originalMean: decodeDouble(json['originalMean']),
      originalStddev: decodeDouble(json['originalStddev']),
    );
  }

  @override
  Object toJson() {
    return {
      if (minValue != null) 'minValue': encodeDouble(minValue),
      if (maxValue != null) 'maxValue': encodeDouble(maxValue),
      if (originalMean != null) 'originalMean': encodeDouble(originalMean),
      if (originalStddev != null)
        'originalStddev': encodeDouble(originalStddev),
    };
  }

  @override
  String toString() {
    final contents = [
      if (minValue != null) 'minValue=$minValue',
      if (maxValue != null) 'maxValue=$maxValue',
      if (originalMean != null) 'originalMean=$originalMean',
      if (originalStddev != null) 'originalStddev=$originalStddev',
    ].join(',');
    return 'FeatureValueDomain($contents)';
  }
}

/// Visualization configurations for image explanation.
final class ExplanationMetadata_InputMetadata_Visualization
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata.InputMetadata.Visualization';

  /// Type of the image visualization. Only applicable to
  /// [Integrated Gradients
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.integrated_gradients_attribution].
  /// OUTLINES shows regions of attribution, while PIXELS shows per-pixel
  /// attribution. Defaults to OUTLINES.
  final ExplanationMetadata_InputMetadata_Visualization_Type? type;

  /// Whether to only highlight pixels with positive contributions, negative
  /// or both. Defaults to POSITIVE.
  final ExplanationMetadata_InputMetadata_Visualization_Polarity? polarity;

  /// The color scheme used for the highlighted areas.
  ///
  /// Defaults to PINK_GREEN for
  /// [Integrated Gradients
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.integrated_gradients_attribution],
  /// which shows positive attributions in green and negative in pink.
  ///
  /// Defaults to VIRIDIS for
  /// [XRAI
  /// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.xrai_attribution],
  /// which highlights the most influential regions in yellow and the least
  /// influential in blue.
  final ExplanationMetadata_InputMetadata_Visualization_ColorMap? colorMap;

  /// Excludes attributions above the specified percentile from the
  /// highlighted areas. Using the clip_percent_upperbound and
  /// clip_percent_lowerbound together can be useful for filtering out noise
  /// and making it easier to see areas of strong attribution. Defaults to
  /// 99.9.
  final double? clipPercentUpperbound;

  /// Excludes attributions below the specified percentile, from the
  /// highlighted areas. Defaults to 62.
  final double? clipPercentLowerbound;

  /// How the original image is displayed in the visualization.
  /// Adjusting the overlay can help increase visual clarity if the original
  /// image makes it difficult to view the visualization. Defaults to NONE.
  final ExplanationMetadata_InputMetadata_Visualization_OverlayType?
  overlayType;

  ExplanationMetadata_InputMetadata_Visualization({
    this.type,
    this.polarity,
    this.colorMap,
    this.clipPercentUpperbound,
    this.clipPercentLowerbound,
    this.overlayType,
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata_InputMetadata_Visualization.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExplanationMetadata_InputMetadata_Visualization(
      type: decodeEnum(
        json['type'],
        ExplanationMetadata_InputMetadata_Visualization_Type.fromJson,
      ),
      polarity: decodeEnum(
        json['polarity'],
        ExplanationMetadata_InputMetadata_Visualization_Polarity.fromJson,
      ),
      colorMap: decodeEnum(
        json['colorMap'],
        ExplanationMetadata_InputMetadata_Visualization_ColorMap.fromJson,
      ),
      clipPercentUpperbound: decodeDouble(json['clipPercentUpperbound']),
      clipPercentLowerbound: decodeDouble(json['clipPercentLowerbound']),
      overlayType: decodeEnum(
        json['overlayType'],
        ExplanationMetadata_InputMetadata_Visualization_OverlayType.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (type != null) 'type': type!.toJson(),
      if (polarity != null) 'polarity': polarity!.toJson(),
      if (colorMap != null) 'colorMap': colorMap!.toJson(),
      if (clipPercentUpperbound != null)
        'clipPercentUpperbound': encodeDouble(clipPercentUpperbound),
      if (clipPercentLowerbound != null)
        'clipPercentLowerbound': encodeDouble(clipPercentLowerbound),
      if (overlayType != null) 'overlayType': overlayType!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (type != null) 'type=$type',
      if (polarity != null) 'polarity=$polarity',
      if (colorMap != null) 'colorMap=$colorMap',
      if (clipPercentUpperbound != null)
        'clipPercentUpperbound=$clipPercentUpperbound',
      if (clipPercentLowerbound != null)
        'clipPercentLowerbound=$clipPercentLowerbound',
      if (overlayType != null) 'overlayType=$overlayType',
    ].join(',');
    return 'Visualization($contents)';
  }
}

/// Type of the image visualization. Only applicable to
/// [Integrated Gradients
/// attribution][google.cloud.aiplatform.v1beta1.ExplanationParameters.integrated_gradients_attribution].
final class ExplanationMetadata_InputMetadata_Visualization_Type
    extends protobuf.ProtoEnum {
  /// Should not be used.
  static const typeUnspecified =
      ExplanationMetadata_InputMetadata_Visualization_Type('TYPE_UNSPECIFIED');

  /// Shows which pixel contributed to the image prediction.
  static const pixels = ExplanationMetadata_InputMetadata_Visualization_Type(
    'PIXELS',
  );

  /// Shows which region contributed to the image prediction by outlining
  /// the region.
  static const outlines = ExplanationMetadata_InputMetadata_Visualization_Type(
    'OUTLINES',
  );

  const ExplanationMetadata_InputMetadata_Visualization_Type(super.value);

  factory ExplanationMetadata_InputMetadata_Visualization_Type.fromJson(
    String json,
  ) => ExplanationMetadata_InputMetadata_Visualization_Type(json);

  @override
  String toString() => 'Type.$value';
}

/// Whether to only highlight pixels with positive contributions, negative
/// or both. Defaults to POSITIVE.
final class ExplanationMetadata_InputMetadata_Visualization_Polarity
    extends protobuf.ProtoEnum {
  /// Default value. This is the same as POSITIVE.
  static const polarityUnspecified =
      ExplanationMetadata_InputMetadata_Visualization_Polarity(
        'POLARITY_UNSPECIFIED',
      );

  /// Highlights the pixels/outlines that were most influential to the
  /// model's prediction.
  static const positive =
      ExplanationMetadata_InputMetadata_Visualization_Polarity('POSITIVE');

  /// Setting polarity to negative highlights areas that does not lead to
  /// the models's current prediction.
  static const negative =
      ExplanationMetadata_InputMetadata_Visualization_Polarity('NEGATIVE');

  /// Shows both positive and negative attributions.
  static const both = ExplanationMetadata_InputMetadata_Visualization_Polarity(
    'BOTH',
  );

  const ExplanationMetadata_InputMetadata_Visualization_Polarity(super.value);

  factory ExplanationMetadata_InputMetadata_Visualization_Polarity.fromJson(
    String json,
  ) => ExplanationMetadata_InputMetadata_Visualization_Polarity(json);

  @override
  String toString() => 'Polarity.$value';
}

/// The color scheme used for highlighting areas.
final class ExplanationMetadata_InputMetadata_Visualization_ColorMap
    extends protobuf.ProtoEnum {
  /// Should not be used.
  static const colorMapUnspecified =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap(
        'COLOR_MAP_UNSPECIFIED',
      );

  /// Positive: green. Negative: pink.
  static const pinkGreen =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap('PINK_GREEN');

  /// Viridis color map: A perceptually uniform color mapping which is
  /// easier to see by those with colorblindness and progresses from yellow
  /// to green to blue. Positive: yellow. Negative: blue.
  static const viridis =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap('VIRIDIS');

  /// Positive: red. Negative: red.
  static const red = ExplanationMetadata_InputMetadata_Visualization_ColorMap(
    'RED',
  );

  /// Positive: green. Negative: green.
  static const green = ExplanationMetadata_InputMetadata_Visualization_ColorMap(
    'GREEN',
  );

  /// Positive: green. Negative: red.
  static const redGreen =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap('RED_GREEN');

  /// PiYG palette.
  static const pinkWhiteGreen =
      ExplanationMetadata_InputMetadata_Visualization_ColorMap(
        'PINK_WHITE_GREEN',
      );

  const ExplanationMetadata_InputMetadata_Visualization_ColorMap(super.value);

  factory ExplanationMetadata_InputMetadata_Visualization_ColorMap.fromJson(
    String json,
  ) => ExplanationMetadata_InputMetadata_Visualization_ColorMap(json);

  @override
  String toString() => 'ColorMap.$value';
}

/// How the original image is displayed in the visualization.
final class ExplanationMetadata_InputMetadata_Visualization_OverlayType
    extends protobuf.ProtoEnum {
  /// Default value. This is the same as NONE.
  static const overlayTypeUnspecified =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType(
        'OVERLAY_TYPE_UNSPECIFIED',
      );

  /// No overlay.
  static const none =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType('NONE');

  /// The attributions are shown on top of the original image.
  static const original =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType('ORIGINAL');

  /// The attributions are shown on top of grayscaled version of the
  /// original image.
  static const grayscale =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType('GRAYSCALE');

  /// The attributions are used as a mask to reveal predictive parts of
  /// the image and hide the un-predictive parts.
  static const maskBlack =
      ExplanationMetadata_InputMetadata_Visualization_OverlayType('MASK_BLACK');

  const ExplanationMetadata_InputMetadata_Visualization_OverlayType(
    super.value,
  );

  factory ExplanationMetadata_InputMetadata_Visualization_OverlayType.fromJson(
    String json,
  ) => ExplanationMetadata_InputMetadata_Visualization_OverlayType(json);

  @override
  String toString() => 'OverlayType.$value';
}

/// Defines how a feature is encoded. Defaults to IDENTITY.
final class ExplanationMetadata_InputMetadata_Encoding
    extends protobuf.ProtoEnum {
  /// Default value. This is the same as IDENTITY.
  static const encodingUnspecified = ExplanationMetadata_InputMetadata_Encoding(
    'ENCODING_UNSPECIFIED',
  );

  /// The tensor represents one feature.
  static const identity = ExplanationMetadata_InputMetadata_Encoding(
    'IDENTITY',
  );

  /// The tensor represents a bag of features where each index maps to
  /// a feature.
  /// `InputMetadata.index_feature_mapping`
  /// must be provided for this encoding. For example:
  /// ```
  /// input = [27, 6.0, 150]
  /// index_feature_mapping = ["age", "height", "weight"]
  /// ```
  static const bagOfFeatures = ExplanationMetadata_InputMetadata_Encoding(
    'BAG_OF_FEATURES',
  );

  /// The tensor represents a bag of features where each index maps to a
  /// feature. Zero values in the tensor indicates feature being
  /// non-existent.
  /// `InputMetadata.index_feature_mapping`
  /// must be provided for this encoding. For example:
  /// ```
  /// input = [2, 0, 5, 0, 1]
  /// index_feature_mapping = ["a", "b", "c", "d", "e"]
  /// ```
  static const bagOfFeaturesSparse = ExplanationMetadata_InputMetadata_Encoding(
    'BAG_OF_FEATURES_SPARSE',
  );

  /// The tensor is a list of binaries representing whether a feature exists
  /// or not (1 indicates existence).
  /// `InputMetadata.index_feature_mapping`
  /// must be provided for this encoding. For example:
  /// ```
  /// input = [1, 0, 1, 0, 1]
  /// index_feature_mapping = ["a", "b", "c", "d", "e"]
  /// ```
  static const indicator = ExplanationMetadata_InputMetadata_Encoding(
    'INDICATOR',
  );

  /// The tensor is encoded into a 1-dimensional array represented by an
  /// encoded tensor.
  /// `InputMetadata.encoded_tensor_name`
  /// must be provided for this encoding. For example:
  /// ```
  /// input = ["This", "is", "a", "test", "."]
  /// encoded = [0.1, 0.2, 0.3, 0.4, 0.5]
  /// ```
  static const combinedEmbedding = ExplanationMetadata_InputMetadata_Encoding(
    'COMBINED_EMBEDDING',
  );

  /// Select this encoding when the input tensor is encoded into a
  /// 2-dimensional array represented by an encoded tensor.
  /// `InputMetadata.encoded_tensor_name`
  /// must be provided for this encoding. The first dimension of the encoded
  /// tensor's shape is the same as the input tensor's shape. For example:
  /// ```
  /// input = ["This", "is", "a", "test", "."]
  /// encoded = [[0.1, 0.2, 0.3, 0.4, 0.5],
  ///            [0.2, 0.1, 0.4, 0.3, 0.5],
  ///            [0.5, 0.1, 0.3, 0.5, 0.4],
  ///            [0.5, 0.3, 0.1, 0.2, 0.4],
  ///            [0.4, 0.3, 0.2, 0.5, 0.1]]
  /// ```
  static const concatEmbedding = ExplanationMetadata_InputMetadata_Encoding(
    'CONCAT_EMBEDDING',
  );

  const ExplanationMetadata_InputMetadata_Encoding(super.value);

  factory ExplanationMetadata_InputMetadata_Encoding.fromJson(String json) =>
      ExplanationMetadata_InputMetadata_Encoding(json);

  @override
  String toString() => 'Encoding.$value';
}

/// Metadata of the prediction output to be explained.
final class ExplanationMetadata_OutputMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplanationMetadata.OutputMetadata';

  /// Static mapping between the index and display name.
  ///
  /// Use this if the outputs are a deterministic n-dimensional array, e.g. a
  /// list of scores of all the classes in a pre-defined order for a
  /// multi-classification Model. It's not feasible if the outputs are
  /// non-deterministic, e.g. the Model produces top-k classes or sort the
  /// outputs by their values.
  ///
  /// The shape of the value must be an n-dimensional array of strings. The
  /// number of dimensions must match that of the outputs to be explained.
  /// The
  /// `Attribution.output_display_name`
  /// is populated by locating in the mapping with
  /// `Attribution.output_index`.
  final protobuf.Value? indexDisplayNameMapping;

  /// Specify a field name in the prediction to look for the display name.
  ///
  /// Use this if the prediction contains the display names for the outputs.
  ///
  /// The display names in the prediction must have the same shape of the
  /// outputs, so that it can be located by
  /// `Attribution.output_index`
  /// for a specific output.
  final String? displayNameMappingKey;

  /// Name of the output tensor. Required and is only applicable to Vertex
  /// AI provided images for Tensorflow.
  final String? outputTensorName;

  ExplanationMetadata_OutputMetadata({
    this.indexDisplayNameMapping,
    this.displayNameMappingKey,
    this.outputTensorName,
  }) : super(fullyQualifiedName);

  factory ExplanationMetadata_OutputMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExplanationMetadata_OutputMetadata(
      indexDisplayNameMapping: decodeCustom(
        json['indexDisplayNameMapping'],
        protobuf.Value.fromJson,
      ),
      displayNameMappingKey: json['displayNameMappingKey'],
      outputTensorName: json['outputTensorName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (indexDisplayNameMapping != null)
        'indexDisplayNameMapping': indexDisplayNameMapping!.toJson(),
      if (displayNameMappingKey != null)
        'displayNameMappingKey': displayNameMappingKey,
      if (outputTensorName != null) 'outputTensorName': outputTensorName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (displayNameMappingKey != null)
        'displayNameMappingKey=$displayNameMappingKey',
      if (outputTensorName != null) 'outputTensorName=$outputTensorName',
    ].join(',');
    return 'OutputMetadata($contents)';
  }
}

/// Extensions are tools for large language models to access external data, run
/// computations, etc.
final class Extension extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Extension';

  /// Identifier. The resource name of the Extension.
  final String? name;

  /// Required. The display name of the Extension.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Optional. The description of the Extension.
  final String? description;

  /// Output only. Timestamp when this Extension was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Extension was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Required. Manifest of the Extension.
  final ExtensionManifest? manifest;

  /// Output only. Supported operations.
  final List<ExtensionOperation>? extensionOperations;

  /// Optional. Runtime config controlling the runtime behavior of this
  /// Extension.
  final RuntimeConfig? runtimeConfig;

  /// Optional. Examples to illustrate the usage of the extension as a tool.
  final List<ToolUseExample>? toolUseExamples;

  /// Optional. The PrivateServiceConnect config for the extension.
  /// If specified, the service endpoints associated with the
  /// Extension should be registered with private network access in the provided
  /// Service Directory
  /// (https://cloud.google.com/service-directory/docs/configuring-private-network-access).
  ///
  /// If the service contains more than one endpoint with a network, the service
  /// will arbitrarilty choose one of the endpoints to use for extension
  /// execution.
  final ExtensionPrivateServiceConnectConfig? privateServiceConnectConfig;

  Extension({
    this.name,
    this.displayName,
    this.description,
    this.createTime,
    this.updateTime,
    this.etag,
    this.manifest,
    this.extensionOperations,
    this.runtimeConfig,
    this.toolUseExamples,
    this.privateServiceConnectConfig,
  }) : super(fullyQualifiedName);

  factory Extension.fromJson(Map<String, dynamic> json) {
    return Extension(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      manifest: decode(json['manifest'], ExtensionManifest.fromJson),
      extensionOperations: decodeListMessage(
        json['extensionOperations'],
        ExtensionOperation.fromJson,
      ),
      runtimeConfig: decode(json['runtimeConfig'], RuntimeConfig.fromJson),
      toolUseExamples: decodeListMessage(
        json['toolUseExamples'],
        ToolUseExample.fromJson,
      ),
      privateServiceConnectConfig: decode(
        json['privateServiceConnectConfig'],
        ExtensionPrivateServiceConnectConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (manifest != null) 'manifest': manifest!.toJson(),
      if (extensionOperations != null)
        'extensionOperations': encodeList(extensionOperations),
      if (runtimeConfig != null) 'runtimeConfig': runtimeConfig!.toJson(),
      if (toolUseExamples != null)
        'toolUseExamples': encodeList(toolUseExamples),
      if (privateServiceConnectConfig != null)
        'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'Extension($contents)';
  }
}

/// Manifest spec of an Extension needed for runtime execution.
final class ExtensionManifest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExtensionManifest';

  /// Required. Extension name shown to the LLM.
  /// The name can be up to 128 characters long.
  final String? name;

  /// Required. The natural language description shown to the LLM.
  /// It should describe the usage of the extension, and is essential for the LLM
  /// to perform reasoning. e.g., if the extension is a data store, you can let
  /// the LLM know what data it contains.
  final String? description;

  /// Required. Immutable. The API specification shown to the LLM.
  final ExtensionManifest_ApiSpec? apiSpec;

  /// Required. Immutable. Type of auth supported by this extension.
  final AuthConfig? authConfig;

  ExtensionManifest({
    this.name,
    this.description,
    this.apiSpec,
    this.authConfig,
  }) : super(fullyQualifiedName);

  factory ExtensionManifest.fromJson(Map<String, dynamic> json) {
    return ExtensionManifest(
      name: json['name'],
      description: json['description'],
      apiSpec: decode(json['apiSpec'], ExtensionManifest_ApiSpec.fromJson),
      authConfig: decode(json['authConfig'], AuthConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (apiSpec != null) 'apiSpec': apiSpec!.toJson(),
      if (authConfig != null) 'authConfig': authConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
    ].join(',');
    return 'ExtensionManifest($contents)';
  }
}

/// The API specification shown to the LLM.
final class ExtensionManifest_ApiSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExtensionManifest.ApiSpec';

  /// The API spec in Open API standard and YAML format.
  final String? openApiYaml;

  /// Cloud Storage URI pointing to the OpenAPI spec.
  final String? openApiGcsUri;

  ExtensionManifest_ApiSpec({this.openApiYaml, this.openApiGcsUri})
    : super(fullyQualifiedName);

  factory ExtensionManifest_ApiSpec.fromJson(Map<String, dynamic> json) {
    return ExtensionManifest_ApiSpec(
      openApiYaml: json['openApiYaml'],
      openApiGcsUri: json['openApiGcsUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (openApiYaml != null) 'openApiYaml': openApiYaml,
      if (openApiGcsUri != null) 'openApiGcsUri': openApiGcsUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (openApiYaml != null) 'openApiYaml=$openApiYaml',
      if (openApiGcsUri != null) 'openApiGcsUri=$openApiGcsUri',
    ].join(',');
    return 'ApiSpec($contents)';
  }
}

/// Operation of an extension.
final class ExtensionOperation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExtensionOperation';

  /// Operation ID that uniquely identifies the operations among the extension.
  /// See: "Operation Object" in https://swagger.io/specification/.
  ///
  /// This field is parsed from the OpenAPI spec. For HTTP extensions, if it does
  /// not exist in the spec, we will generate one from the HTTP method and path.
  final String? operationId;

  /// Output only. Structured representation of a function declaration as defined
  /// by the OpenAPI Spec.
  final FunctionDeclaration? functionDeclaration;

  ExtensionOperation({this.operationId, this.functionDeclaration})
    : super(fullyQualifiedName);

  factory ExtensionOperation.fromJson(Map<String, dynamic> json) {
    return ExtensionOperation(
      operationId: json['operationId'],
      functionDeclaration: decode(
        json['functionDeclaration'],
        FunctionDeclaration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (operationId != null) 'operationId': operationId,
      if (functionDeclaration != null)
        'functionDeclaration': functionDeclaration!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (operationId != null) 'operationId=$operationId',
    ].join(',');
    return 'ExtensionOperation($contents)';
  }
}

/// Auth configuration to run the extension.
final class AuthConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig';

  /// Config for API key auth.
  final AuthConfig_ApiKeyConfig? apiKeyConfig;

  /// Config for HTTP Basic auth.
  final AuthConfig_HttpBasicAuthConfig? httpBasicAuthConfig;

  /// Config for Google Service Account auth.
  final AuthConfig_GoogleServiceAccountConfig? googleServiceAccountConfig;

  /// Config for user oauth.
  final AuthConfig_OauthConfig? oauthConfig;

  /// Config for user OIDC auth.
  final AuthConfig_OidcConfig? oidcConfig;

  /// Type of auth scheme.
  final AuthType? authType;

  AuthConfig({
    this.apiKeyConfig,
    this.httpBasicAuthConfig,
    this.googleServiceAccountConfig,
    this.oauthConfig,
    this.oidcConfig,
    this.authType,
  }) : super(fullyQualifiedName);

  factory AuthConfig.fromJson(Map<String, dynamic> json) {
    return AuthConfig(
      apiKeyConfig: decode(
        json['apiKeyConfig'],
        AuthConfig_ApiKeyConfig.fromJson,
      ),
      httpBasicAuthConfig: decode(
        json['httpBasicAuthConfig'],
        AuthConfig_HttpBasicAuthConfig.fromJson,
      ),
      googleServiceAccountConfig: decode(
        json['googleServiceAccountConfig'],
        AuthConfig_GoogleServiceAccountConfig.fromJson,
      ),
      oauthConfig: decode(json['oauthConfig'], AuthConfig_OauthConfig.fromJson),
      oidcConfig: decode(json['oidcConfig'], AuthConfig_OidcConfig.fromJson),
      authType: decodeEnum(json['authType'], AuthType.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!.toJson(),
      if (httpBasicAuthConfig != null)
        'httpBasicAuthConfig': httpBasicAuthConfig!.toJson(),
      if (googleServiceAccountConfig != null)
        'googleServiceAccountConfig': googleServiceAccountConfig!.toJson(),
      if (oauthConfig != null) 'oauthConfig': oauthConfig!.toJson(),
      if (oidcConfig != null) 'oidcConfig': oidcConfig!.toJson(),
      if (authType != null) 'authType': authType!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (authType != null) 'authType=$authType'].join(',');
    return 'AuthConfig($contents)';
  }
}

/// Config for authentication with API key.
final class AuthConfig_ApiKeyConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.ApiKeyConfig';

  /// Required. The parameter name of the API key.
  /// E.g. If the API request is "https://example.com/act?api_key=<API KEY>",
  /// "api_key" would be the parameter name.
  final String? name;

  /// Required. The name of the SecretManager secret version resource storing
  /// the API key. Format:
  /// `projects/{project}/secrets/{secrete}/versions/{version}`
  ///
  /// - If specified, the `secretmanager.versions.access` permission should be
  /// granted to Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified resource.
  final String? apiKeySecret;

  /// Required. The location of the API key.
  final HttpElementLocation? httpElementLocation;

  AuthConfig_ApiKeyConfig({
    this.name,
    this.apiKeySecret,
    this.httpElementLocation,
  }) : super(fullyQualifiedName);

  factory AuthConfig_ApiKeyConfig.fromJson(Map<String, dynamic> json) {
    return AuthConfig_ApiKeyConfig(
      name: json['name'],
      apiKeySecret: json['apiKeySecret'],
      httpElementLocation: decodeEnum(
        json['httpElementLocation'],
        HttpElementLocation.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (apiKeySecret != null) 'apiKeySecret': apiKeySecret,
      if (httpElementLocation != null)
        'httpElementLocation': httpElementLocation!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (apiKeySecret != null) 'apiKeySecret=$apiKeySecret',
      if (httpElementLocation != null)
        'httpElementLocation=$httpElementLocation',
    ].join(',');
    return 'ApiKeyConfig($contents)';
  }
}

/// Config for HTTP Basic Authentication.
final class AuthConfig_HttpBasicAuthConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.HttpBasicAuthConfig';

  /// Required. The name of the SecretManager secret version resource storing
  /// the base64 encoded credentials. Format:
  /// `projects/{project}/secrets/{secrete}/versions/{version}`
  ///
  /// - If specified, the `secretmanager.versions.access` permission should be
  /// granted to Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified resource.
  final String? credentialSecret;

  AuthConfig_HttpBasicAuthConfig({this.credentialSecret})
    : super(fullyQualifiedName);

  factory AuthConfig_HttpBasicAuthConfig.fromJson(Map<String, dynamic> json) {
    return AuthConfig_HttpBasicAuthConfig(
      credentialSecret: json['credentialSecret'],
    );
  }

  @override
  Object toJson() {
    return {if (credentialSecret != null) 'credentialSecret': credentialSecret};
  }

  @override
  String toString() {
    final contents = [
      if (credentialSecret != null) 'credentialSecret=$credentialSecret',
    ].join(',');
    return 'HttpBasicAuthConfig($contents)';
  }
}

/// Config for Google Service Account Authentication.
final class AuthConfig_GoogleServiceAccountConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.GoogleServiceAccountConfig';

  /// Optional. The service account that the extension execution service runs
  /// as.
  ///
  /// - If the service account is specified,
  /// the `iam.serviceAccounts.getAccessToken` permission should be granted to
  /// Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the specified service account.
  ///
  /// - If not specified, the Vertex AI Extension Service Agent
  /// will be used to execute the Extension.
  final String? serviceAccount;

  AuthConfig_GoogleServiceAccountConfig({this.serviceAccount})
    : super(fullyQualifiedName);

  factory AuthConfig_GoogleServiceAccountConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return AuthConfig_GoogleServiceAccountConfig(
      serviceAccount: json['serviceAccount'],
    );
  }

  @override
  Object toJson() {
    return {if (serviceAccount != null) 'serviceAccount': serviceAccount};
  }

  @override
  String toString() {
    final contents = [
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
    ].join(',');
    return 'GoogleServiceAccountConfig($contents)';
  }
}

/// Config for user oauth.
final class AuthConfig_OauthConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.OauthConfig';

  /// Access token for extension endpoint.
  /// Only used to propagate token from
  /// [[ExecuteExtensionRequest.runtime_auth_config]] at request time.
  final String? accessToken;

  /// The service account used to generate access tokens for executing the
  /// Extension.
  ///
  /// - If the service account is specified,
  /// the `iam.serviceAccounts.getAccessToken` permission should be granted
  /// to Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// on the provided service account.
  final String? serviceAccount;

  AuthConfig_OauthConfig({this.accessToken, this.serviceAccount})
    : super(fullyQualifiedName);

  factory AuthConfig_OauthConfig.fromJson(Map<String, dynamic> json) {
    return AuthConfig_OauthConfig(
      accessToken: json['accessToken'],
      serviceAccount: json['serviceAccount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (accessToken != null) 'accessToken': accessToken,
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (accessToken != null) 'accessToken=$accessToken',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
    ].join(',');
    return 'OauthConfig($contents)';
  }
}

/// Config for user OIDC auth.
final class AuthConfig_OidcConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AuthConfig.OidcConfig';

  /// OpenID Connect formatted ID token for extension endpoint.
  /// Only used to propagate token from
  /// [[ExecuteExtensionRequest.runtime_auth_config]] at request time.
  final String? idToken;

  /// The service account used to generate an OpenID Connect
  /// (OIDC)-compatible JWT token signed by the Google OIDC Provider
  /// (accounts.google.com) for extension endpoint
  /// (https://cloud.google.com/iam/docs/create-short-lived-credentials-direct#sa-credentials-oidc).
  ///
  /// - The audience for the token will be set to the URL in the server url
  /// defined in the OpenApi spec.
  ///
  /// - If the service account is provided, the service account should grant
  /// `iam.serviceAccounts.getOpenIdToken` permission to Vertex AI Extension
  /// Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  final String? serviceAccount;

  AuthConfig_OidcConfig({this.idToken, this.serviceAccount})
    : super(fullyQualifiedName);

  factory AuthConfig_OidcConfig.fromJson(Map<String, dynamic> json) {
    return AuthConfig_OidcConfig(
      idToken: json['idToken'],
      serviceAccount: json['serviceAccount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (idToken != null) 'idToken': idToken,
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (idToken != null) 'idToken=$idToken',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
    ].join(',');
    return 'OidcConfig($contents)';
  }
}

/// Runtime configuration to run the extension.
final class RuntimeConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RuntimeConfig';

  /// Code execution runtime configurations for code interpreter extension.
  final RuntimeConfig_CodeInterpreterRuntimeConfig?
  codeInterpreterRuntimeConfig;

  /// Runtime configuration for Vertex AI Search extension.
  final RuntimeConfig_VertexAisearchRuntimeConfig? vertexAiSearchRuntimeConfig;

  /// Optional. Default parameters that will be set for all the execution of this
  /// extension. If specified, the parameter values can be overridden by values
  /// in [[ExecuteExtensionRequest.operation_params]] at request time.
  ///
  /// The struct should be in a form of map with param name as the key and actual
  /// param value as the value.
  /// E.g. If this operation requires a param "name" to be set to "abc". you can
  /// set this to something like {"name": "abc"}.
  final protobuf.Struct? defaultParams;

  RuntimeConfig({
    this.codeInterpreterRuntimeConfig,
    this.vertexAiSearchRuntimeConfig,
    this.defaultParams,
  }) : super(fullyQualifiedName);

  factory RuntimeConfig.fromJson(Map<String, dynamic> json) {
    return RuntimeConfig(
      codeInterpreterRuntimeConfig: decode(
        json['codeInterpreterRuntimeConfig'],
        RuntimeConfig_CodeInterpreterRuntimeConfig.fromJson,
      ),
      vertexAiSearchRuntimeConfig: decode(
        json['vertexAiSearchRuntimeConfig'],
        RuntimeConfig_VertexAisearchRuntimeConfig.fromJson,
      ),
      defaultParams: decodeCustom(
        json['defaultParams'],
        protobuf.Struct.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (codeInterpreterRuntimeConfig != null)
        'codeInterpreterRuntimeConfig': codeInterpreterRuntimeConfig!.toJson(),
      if (vertexAiSearchRuntimeConfig != null)
        'vertexAiSearchRuntimeConfig': vertexAiSearchRuntimeConfig!.toJson(),
      if (defaultParams != null) 'defaultParams': defaultParams!.toJson(),
    };
  }

  @override
  String toString() => 'RuntimeConfig()';
}

final class RuntimeConfig_CodeInterpreterRuntimeConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RuntimeConfig.CodeInterpreterRuntimeConfig';

  /// Optional. The Cloud Storage bucket for file input of this Extension.
  /// If specified, support input from the Cloud Storage bucket.
  /// Vertex Extension Custom Code Service Agent should be granted
  /// file reader to this bucket.
  /// If not specified, the extension will only accept file contents from
  /// request body and reject Cloud Storage file inputs.
  final String? fileInputGcsBucket;

  /// Optional. The Cloud Storage bucket for file output of this Extension.
  /// If specified, write all output files to the Cloud Storage bucket.
  /// Vertex Extension Custom Code Service Agent should be granted
  /// file writer to this bucket.
  /// If not specified, the file content will be output in response body.
  final String? fileOutputGcsBucket;

  RuntimeConfig_CodeInterpreterRuntimeConfig({
    this.fileInputGcsBucket,
    this.fileOutputGcsBucket,
  }) : super(fullyQualifiedName);

  factory RuntimeConfig_CodeInterpreterRuntimeConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return RuntimeConfig_CodeInterpreterRuntimeConfig(
      fileInputGcsBucket: json['fileInputGcsBucket'],
      fileOutputGcsBucket: json['fileOutputGcsBucket'],
    );
  }

  @override
  Object toJson() {
    return {
      if (fileInputGcsBucket != null) 'fileInputGcsBucket': fileInputGcsBucket,
      if (fileOutputGcsBucket != null)
        'fileOutputGcsBucket': fileOutputGcsBucket,
    };
  }

  @override
  String toString() {
    final contents = [
      if (fileInputGcsBucket != null) 'fileInputGcsBucket=$fileInputGcsBucket',
      if (fileOutputGcsBucket != null)
        'fileOutputGcsBucket=$fileOutputGcsBucket',
    ].join(',');
    return 'CodeInterpreterRuntimeConfig($contents)';
  }
}

final class RuntimeConfig_VertexAisearchRuntimeConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RuntimeConfig.VertexAISearchRuntimeConfig';

  /// Optional. Vertex AI Search serving config name. Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config}`
  final String? servingConfigName;

  /// Optional. Vertex AI Search engine ID. This is used to construct the
  /// search request. By setting this engine_id, API will construct the serving
  /// config using the default value to call search API for the user. The
  /// engine_id and serving_config_name cannot both be empty at the same time.
  final String? engineId;

  RuntimeConfig_VertexAisearchRuntimeConfig({
    this.servingConfigName,
    this.engineId,
  }) : super(fullyQualifiedName);

  factory RuntimeConfig_VertexAisearchRuntimeConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return RuntimeConfig_VertexAisearchRuntimeConfig(
      servingConfigName: json['servingConfigName'],
      engineId: json['engineId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (servingConfigName != null) 'servingConfigName': servingConfigName,
      if (engineId != null) 'engineId': engineId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (servingConfigName != null) 'servingConfigName=$servingConfigName',
      if (engineId != null) 'engineId=$engineId',
    ].join(',');
    return 'VertexAISearchRuntimeConfig($contents)';
  }
}

/// PrivateExtensionConfig configuration for the extension.
final class ExtensionPrivateServiceConnectConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExtensionPrivateServiceConnectConfig';

  /// Required. The Service Directory resource name in which the service
  /// endpoints associated to the extension are registered. Format:
  /// `projects/{project_id}/locations/{location_id}/namespaces/{namespace_id}/services/{service_id}`
  ///
  /// - The Vertex AI Extension Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// should be granted `servicedirectory.viewer` and
  /// `servicedirectory.pscAuthorizedService` roles on the resource.
  final String? serviceDirectory;

  ExtensionPrivateServiceConnectConfig({this.serviceDirectory})
    : super(fullyQualifiedName);

  factory ExtensionPrivateServiceConnectConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExtensionPrivateServiceConnectConfig(
      serviceDirectory: json['serviceDirectory'],
    );
  }

  @override
  Object toJson() {
    return {if (serviceDirectory != null) 'serviceDirectory': serviceDirectory};
  }

  @override
  String toString() {
    final contents = [
      if (serviceDirectory != null) 'serviceDirectory=$serviceDirectory',
    ].join(',');
    return 'ExtensionPrivateServiceConnectConfig($contents)';
  }
}

/// Request message for
/// `ExtensionExecutionService.ExecuteExtension`.
final class ExecuteExtensionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExecuteExtensionRequest';

  /// Required. Name (identifier) of the extension;
  /// Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  final String name;

  /// Required. The desired ID of the operation to be executed in this extension
  ///  as defined in
  ///  `ExtensionOperation.operation_id`.
  final String? operationId;

  /// Optional. Request parameters that will be used for executing this
  /// operation.
  ///
  /// The struct should be in a form of map with param name as the key and actual
  /// param value as the value.
  /// E.g. If this operation requires a param "name" to be set to "abc". you can
  /// set this to something like {"name": "abc"}.
  final protobuf.Struct? operationParams;

  /// Optional. Auth config provided at runtime to override the default value in
  /// `Extension.manifest.auth_config`.
  /// The AuthConfig.auth_type should match the value in
  /// `Extension.manifest.auth_config`.
  final AuthConfig? runtimeAuthConfig;

  ExecuteExtensionRequest({
    required this.name,
    this.operationId,
    this.operationParams,
    this.runtimeAuthConfig,
  }) : super(fullyQualifiedName);

  factory ExecuteExtensionRequest.fromJson(Map<String, dynamic> json) {
    return ExecuteExtensionRequest(
      name: json['name'],
      operationId: json['operationId'],
      operationParams: decodeCustom(
        json['operationParams'],
        protobuf.Struct.fromJson,
      ),
      runtimeAuthConfig: decode(json['runtimeAuthConfig'], AuthConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (operationId != null) 'operationId': operationId,
      if (operationParams != null) 'operationParams': operationParams!.toJson(),
      if (runtimeAuthConfig != null)
        'runtimeAuthConfig': runtimeAuthConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (operationId != null) 'operationId=$operationId',
    ].join(',');
    return 'ExecuteExtensionRequest($contents)';
  }
}

/// Response message for
/// `ExtensionExecutionService.ExecuteExtension`.
final class ExecuteExtensionResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExecuteExtensionResponse';

  /// Response content from the extension. The content should be conformant to
  /// the response.content schema in the extension's manifest/OpenAPI spec.
  final String? content;

  ExecuteExtensionResponse({this.content}) : super(fullyQualifiedName);

  factory ExecuteExtensionResponse.fromJson(Map<String, dynamic> json) {
    return ExecuteExtensionResponse(content: json['content']);
  }

  @override
  Object toJson() {
    return {if (content != null) 'content': content};
  }

  @override
  String toString() {
    final contents = [if (content != null) 'content=$content'].join(',');
    return 'ExecuteExtensionResponse($contents)';
  }
}

/// Request message for
/// `ExtensionExecutionService.QueryExtension`.
final class QueryExtensionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryExtensionRequest';

  /// Required. Name (identifier) of the extension;
  /// Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  final String name;

  /// Required. The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn queries,
  /// this is a repeated field that contains conversation history + latest
  /// request.
  final List<Content>? contents;

  QueryExtensionRequest({required this.name, this.contents})
    : super(fullyQualifiedName);

  factory QueryExtensionRequest.fromJson(Map<String, dynamic> json) {
    return QueryExtensionRequest(
      name: json['name'],
      contents: decodeListMessage(json['contents'], Content.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (contents != null) 'contents': encodeList(contents),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'QueryExtensionRequest($contents)';
  }
}

/// Response message for
/// `ExtensionExecutionService.QueryExtension`.
final class QueryExtensionResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryExtensionResponse';

  /// Steps of extension or LLM interaction, can contain function call,
  /// function response, or text response. The last step contains the final
  /// response to the query.
  final List<Content>? steps;

  /// Failure message if any.
  final String? failureMessage;

  QueryExtensionResponse({this.steps, this.failureMessage})
    : super(fullyQualifiedName);

  factory QueryExtensionResponse.fromJson(Map<String, dynamic> json) {
    return QueryExtensionResponse(
      steps: decodeListMessage(json['steps'], Content.fromJson),
      failureMessage: json['failureMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (steps != null) 'steps': encodeList(steps),
      if (failureMessage != null) 'failureMessage': failureMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (failureMessage != null) 'failureMessage=$failureMessage',
    ].join(',');
    return 'QueryExtensionResponse($contents)';
  }
}

/// Request message for
/// `ExtensionRegistryService.ImportExtension`.
final class ImportExtensionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportExtensionRequest';

  /// Required. The resource name of the Location to import the Extension in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Extension to import.
  final Extension extension;

  ImportExtensionRequest({required this.parent, required this.extension})
    : super(fullyQualifiedName);

  factory ImportExtensionRequest.fromJson(Map<String, dynamic> json) {
    return ImportExtensionRequest(
      parent: json['parent'],
      extension: decode(json['extension'], Extension.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'extension': extension.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ImportExtensionRequest($contents)';
  }
}

/// Details of
/// `ExtensionRegistryService.ImportExtension`
/// operation.
final class ImportExtensionOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportExtensionOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  ImportExtensionOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ImportExtensionOperationMetadata.fromJson(Map<String, dynamic> json) {
    return ImportExtensionOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'ImportExtensionOperationMetadata()';
}

/// Request message for
/// `ExtensionRegistryService.GetExtension`.
final class GetExtensionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetExtensionRequest';

  /// Required. The name of the Extension resource.
  /// Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  final String name;

  GetExtensionRequest({required this.name}) : super(fullyQualifiedName);

  factory GetExtensionRequest.fromJson(Map<String, dynamic> json) {
    return GetExtensionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetExtensionRequest($contents)';
  }
}

/// Request message for
/// `ExtensionRegistryService.UpdateExtension`.
final class UpdateExtensionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExtensionRequest';

  /// Required. The Extension which replaces the resource on the server.
  final Extension extension;

  /// Required. Mask specifying which fields to update.
  /// Supported fields:
  ///
  ///    * `display_name`
  ///    * `description`
  ///    * `runtime_config`
  ///    * `tool_use_examples`
  ///    * `manifest.description`
  final protobuf.FieldMask? updateMask;

  UpdateExtensionRequest({required this.extension, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateExtensionRequest.fromJson(Map<String, dynamic> json) {
    return UpdateExtensionRequest(
      extension: decode(json['extension'], Extension.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'extension': extension.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateExtensionRequest()';
}

/// Request message for
/// `ExtensionRegistryService.ListExtensions`.
final class ListExtensionsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExtensionsRequest';

  /// Required. The resource name of the Location to list the Extensions from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list filter.
  /// Supported fields:
  ///    * `display_name`
  ///    * `create_time`
  ///    * `update_time`
  ///
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  final String? pageToken;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `display_name, create_time desc`.
  final String? orderBy;

  ListExtensionsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListExtensionsRequest.fromJson(Map<String, dynamic> json) {
    return ListExtensionsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListExtensionsRequest($contents)';
  }
}

/// Response message for
/// `ExtensionRegistryService.ListExtensions`
final class ListExtensionsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExtensionsResponse';

  /// List of Extension in the requested page.
  final List<Extension>? extensions;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListExtensionsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListExtensionsResponse({this.extensions, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListExtensionsResponse.fromJson(Map<String, dynamic> json) {
    return ListExtensionsResponse(
      extensions: decodeListMessage(json['extensions'], Extension.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (extensions != null) 'extensions': encodeList(extensions),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListExtensionsResponse($contents)';
  }
}

/// Request message for
/// `ExtensionRegistryService.DeleteExtension`.
final class DeleteExtensionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteExtensionRequest';

  /// Required. The name of the Extension resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/extensions/{extension}`
  final String name;

  DeleteExtensionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteExtensionRequest.fromJson(Map<String, dynamic> json) {
    return DeleteExtensionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteExtensionRequest($contents)';
  }
}

/// Feature Metadata information.
/// For example, color is a feature that describes an apple.
final class Feature extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Feature';

  /// Immutable. Name of the Feature.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  ///
  /// The last part feature is assigned by the client. The feature can be up to
  /// 64 characters long and can consist only of ASCII Latin letters A-Z and a-z,
  /// underscore(_), and ASCII digits 0-9 starting with a letter. The value will
  /// be unique given an entity type.
  final String? name;

  /// Description of the Feature.
  final String? description;

  /// Immutable. Only applicable for Vertex AI Feature Store (Legacy).
  /// Type of Feature value.
  final Feature_ValueType? valueType;

  /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
  /// Timestamp when this EntityType was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
  /// Timestamp when this EntityType was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The labels with user-defined metadata to organize your Features.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one Feature (System
  /// labels are excluded)."
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? labels;

  /// Used to perform a consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// Optional. Only applicable for Vertex AI Feature Store (Legacy).
  /// Deprecated: The custom monitoring configuration for this Feature, if not
  /// set, use the monitoring_config defined for the EntityType this Feature
  /// belongs to.
  /// Only Features with type
  /// (`Feature.ValueType`)
  /// BOOL, STRING, DOUBLE or INT64 can enable monitoring.
  ///
  /// If this is populated with
  /// `FeaturestoreMonitoringConfig.disabled` = true, snapshot analysis
  /// monitoring is disabled; if
  /// `FeaturestoreMonitoringConfig.monitoring_interval` specified, snapshot
  /// analysis monitoring is enabled. Otherwise, snapshot analysis monitoring
  /// config is same as the EntityType's this Feature belongs to.
  final FeaturestoreMonitoringConfig? monitoringConfig;

  /// Optional. Only applicable for Vertex AI Feature Store (Legacy).
  /// If not set, use the monitoring_config defined for the EntityType this
  /// Feature belongs to.
  /// Only Features with type
  /// (`Feature.ValueType`)
  /// BOOL, STRING, DOUBLE or INT64 can enable monitoring.
  ///
  /// If set to true, all types of data monitoring are disabled despite the
  /// config on EntityType.
  final bool? disableMonitoring;

  /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
  /// A list of historical
  /// `SnapshotAnalysis`
  /// stats requested by user, sorted by
  /// `FeatureStatsAnomaly.start_time`
  /// descending.
  final List<FeatureStatsAnomaly>? monitoringStats;

  /// Output only. Only applicable for Vertex AI Feature Store (Legacy).
  /// The list of historical stats and anomalies with specified objectives.
  final List<Feature_MonitoringStatsAnomaly>? monitoringStatsAnomalies;

  /// Output only. Only applicable for Vertex AI Feature Store.
  /// The list of historical stats and anomalies.
  final List<FeatureStatsAndAnomaly>? featureStatsAndAnomaly;

  /// Only applicable for Vertex AI Feature Store.
  /// The name of the BigQuery Table/View column hosting data for this version.
  /// If no value is provided, will use feature_id.
  final String? versionColumnName;

  /// Entity responsible for maintaining this feature. Can be comma separated
  /// list of email addresses or URIs.
  final String? pointOfContact;

  Feature({
    this.name,
    this.description,
    this.valueType,
    this.createTime,
    this.updateTime,
    this.labels,
    this.etag,
    this.monitoringConfig,
    this.disableMonitoring,
    this.monitoringStats,
    this.monitoringStatsAnomalies,
    this.featureStatsAndAnomaly,
    this.versionColumnName,
    this.pointOfContact,
  }) : super(fullyQualifiedName);

  factory Feature.fromJson(Map<String, dynamic> json) {
    return Feature(
      name: json['name'],
      description: json['description'],
      valueType: decodeEnum(json['valueType'], Feature_ValueType.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      etag: json['etag'],
      monitoringConfig: decode(
        json['monitoringConfig'],
        FeaturestoreMonitoringConfig.fromJson,
      ),
      disableMonitoring: json['disableMonitoring'],
      monitoringStats: decodeListMessage(
        json['monitoringStats'],
        FeatureStatsAnomaly.fromJson,
      ),
      monitoringStatsAnomalies: decodeListMessage(
        json['monitoringStatsAnomalies'],
        Feature_MonitoringStatsAnomaly.fromJson,
      ),
      featureStatsAndAnomaly: decodeListMessage(
        json['featureStatsAndAnomaly'],
        FeatureStatsAndAnomaly.fromJson,
      ),
      versionColumnName: json['versionColumnName'],
      pointOfContact: json['pointOfContact'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (valueType != null) 'valueType': valueType!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (etag != null) 'etag': etag,
      if (monitoringConfig != null)
        'monitoringConfig': monitoringConfig!.toJson(),
      if (disableMonitoring != null) 'disableMonitoring': disableMonitoring,
      if (monitoringStats != null)
        'monitoringStats': encodeList(monitoringStats),
      if (monitoringStatsAnomalies != null)
        'monitoringStatsAnomalies': encodeList(monitoringStatsAnomalies),
      if (featureStatsAndAnomaly != null)
        'featureStatsAndAnomaly': encodeList(featureStatsAndAnomaly),
      if (versionColumnName != null) 'versionColumnName': versionColumnName,
      if (pointOfContact != null) 'pointOfContact': pointOfContact,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
      if (valueType != null) 'valueType=$valueType',
      if (etag != null) 'etag=$etag',
      if (disableMonitoring != null) 'disableMonitoring=$disableMonitoring',
      if (versionColumnName != null) 'versionColumnName=$versionColumnName',
      if (pointOfContact != null) 'pointOfContact=$pointOfContact',
    ].join(',');
    return 'Feature($contents)';
  }
}

/// A list of historical
/// `SnapshotAnalysis`
/// or
/// `ImportFeaturesAnalysis`
/// stats requested by user, sorted by
/// `FeatureStatsAnomaly.start_time`
/// descending.
final class Feature_MonitoringStatsAnomaly extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Feature.MonitoringStatsAnomaly';

  /// Output only. The objective for each stats.
  final Feature_MonitoringStatsAnomaly_Objective? objective;

  /// Output only. The stats and anomalies generated at specific timestamp.
  final FeatureStatsAnomaly? featureStatsAnomaly;

  Feature_MonitoringStatsAnomaly({this.objective, this.featureStatsAnomaly})
    : super(fullyQualifiedName);

  factory Feature_MonitoringStatsAnomaly.fromJson(Map<String, dynamic> json) {
    return Feature_MonitoringStatsAnomaly(
      objective: decodeEnum(
        json['objective'],
        Feature_MonitoringStatsAnomaly_Objective.fromJson,
      ),
      featureStatsAnomaly: decode(
        json['featureStatsAnomaly'],
        FeatureStatsAnomaly.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (objective != null) 'objective': objective!.toJson(),
      if (featureStatsAnomaly != null)
        'featureStatsAnomaly': featureStatsAnomaly!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (objective != null) 'objective=$objective'].join(',');
    return 'MonitoringStatsAnomaly($contents)';
  }
}

/// If the objective in the request is both
/// Import Feature Analysis and Snapshot Analysis, this objective could be
/// one of them. Otherwise, this objective should be the same as the
/// objective in the request.
final class Feature_MonitoringStatsAnomaly_Objective
    extends protobuf.ProtoEnum {
  /// If it's OBJECTIVE_UNSPECIFIED, monitoring_stats will be empty.
  static const objectiveUnspecified = Feature_MonitoringStatsAnomaly_Objective(
    'OBJECTIVE_UNSPECIFIED',
  );

  /// Stats are generated by Import Feature Analysis.
  static const importFeatureAnalysis = Feature_MonitoringStatsAnomaly_Objective(
    'IMPORT_FEATURE_ANALYSIS',
  );

  /// Stats are generated by Snapshot Analysis.
  static const snapshotAnalysis = Feature_MonitoringStatsAnomaly_Objective(
    'SNAPSHOT_ANALYSIS',
  );

  const Feature_MonitoringStatsAnomaly_Objective(super.value);

  factory Feature_MonitoringStatsAnomaly_Objective.fromJson(String json) =>
      Feature_MonitoringStatsAnomaly_Objective(json);

  @override
  String toString() => 'Objective.$value';
}

/// Only applicable for Vertex AI Legacy Feature Store.
/// An enum representing the value type of a feature.
final class Feature_ValueType extends protobuf.ProtoEnum {
  /// The value type is unspecified.
  static const valueTypeUnspecified = Feature_ValueType(
    'VALUE_TYPE_UNSPECIFIED',
  );

  /// Used for Feature that is a boolean.
  static const bool = Feature_ValueType('BOOL');

  /// Used for Feature that is a list of boolean.
  static const boolArray = Feature_ValueType('BOOL_ARRAY');

  /// Used for Feature that is double.
  static const double = Feature_ValueType('DOUBLE');

  /// Used for Feature that is a list of double.
  static const doubleArray = Feature_ValueType('DOUBLE_ARRAY');

  /// Used for Feature that is INT64.
  static const int64 = Feature_ValueType('INT64');

  /// Used for Feature that is a list of INT64.
  static const int64Array = Feature_ValueType('INT64_ARRAY');

  /// Used for Feature that is string.
  static const string = Feature_ValueType('STRING');

  /// Used for Feature that is a list of String.
  static const stringArray = Feature_ValueType('STRING_ARRAY');

  /// Used for Feature that is bytes.
  static const bytes = Feature_ValueType('BYTES');

  /// Used for Feature that is struct.
  static const struct = Feature_ValueType('STRUCT');

  const Feature_ValueType(super.value);

  factory Feature_ValueType.fromJson(String json) => Feature_ValueType(json);

  @override
  String toString() => 'ValueType.$value';
}

/// Vertex AI Feature Group.
final class FeatureGroup extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureGroup';

  /// Indicates that features for this group come from BigQuery Table/View.
  /// By default treats the source as a sparse time series source. The BigQuery
  /// source table or view must have at least one entity ID column and a column
  /// named `feature_timestamp`.
  final FeatureGroup_BigQuery? bigQuery;

  /// Identifier. Name of the FeatureGroup. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  final String? name;

  /// Output only. Timestamp when this FeatureGroup was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this FeatureGroup was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureGroup.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureGroup(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String>? labels;

  /// Optional. Description of the FeatureGroup.
  final String? description;

  /// Optional. Service agent type used during jobs under a FeatureGroup. By
  /// default, the Vertex AI Service Agent is used. When using an IAM Policy to
  /// isolate this FeatureGroup within a project, a separate service account
  /// should be provisioned by setting this field to
  /// `SERVICE_AGENT_TYPE_FEATURE_GROUP`. This will generate a separate service
  /// account to access the BigQuery source table.
  final FeatureGroup_ServiceAgentType? serviceAgentType;

  /// Output only. A Service Account unique to this FeatureGroup. The role
  /// bigquery.dataViewer should be granted to this service account to allow
  /// Vertex AI Feature Store to access source data while running jobs under this
  /// FeatureGroup.
  final String? serviceAccountEmail;

  FeatureGroup({
    this.bigQuery,
    this.name,
    this.createTime,
    this.updateTime,
    this.etag,
    this.labels,
    this.description,
    this.serviceAgentType,
    this.serviceAccountEmail,
  }) : super(fullyQualifiedName);

  factory FeatureGroup.fromJson(Map<String, dynamic> json) {
    return FeatureGroup(
      bigQuery: decode(json['bigQuery'], FeatureGroup_BigQuery.fromJson),
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      description: json['description'],
      serviceAgentType: decodeEnum(
        json['serviceAgentType'],
        FeatureGroup_ServiceAgentType.fromJson,
      ),
      serviceAccountEmail: json['serviceAccountEmail'],
    );
  }

  @override
  Object toJson() {
    return {
      if (bigQuery != null) 'bigQuery': bigQuery!.toJson(),
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (description != null) 'description': description,
      if (serviceAgentType != null)
        'serviceAgentType': serviceAgentType!.toJson(),
      if (serviceAccountEmail != null)
        'serviceAccountEmail': serviceAccountEmail,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (etag != null) 'etag=$etag',
      if (description != null) 'description=$description',
      if (serviceAgentType != null) 'serviceAgentType=$serviceAgentType',
      if (serviceAccountEmail != null)
        'serviceAccountEmail=$serviceAccountEmail',
    ].join(',');
    return 'FeatureGroup($contents)';
  }
}

/// Input source type for BigQuery Tables and Views.
final class FeatureGroup_BigQuery extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureGroup.BigQuery';

  /// Required. Immutable. The BigQuery source URI that points to either a
  /// BigQuery Table or View.
  final BigQuerySource? bigQuerySource;

  /// Optional. Columns to construct entity_id / row keys.
  /// If not provided defaults to `entity_id`.
  final List<String>? entityIdColumns;

  /// Optional. Set if the data source is not a time-series.
  final bool? staticDataSource;

  /// Optional. If the source is a time-series source, this can be set to
  /// control how downstream sources (ex:
  /// `FeatureView` ) will treat
  /// time-series sources. If not set, will treat the source as a time-series
  /// source with `feature_timestamp` as timestamp column and no scan boundary.
  final FeatureGroup_BigQuery_TimeSeries? timeSeries;

  /// Optional. If set, all feature values will be fetched
  /// from a single row per unique entityId including nulls.
  /// If not set, will collapse all rows for each unique entityId into a singe
  /// row with any non-null values if present, if no non-null values are
  /// present will sync null.
  /// ex: If source has schema
  /// `(entity_id, feature_timestamp, f0, f1)` and the following rows:
  /// `(e1, 2020-01-01T10:00:00.123Z, 10, 15)`
  /// `(e1, 2020-02-01T10:00:00.123Z, 20, null)`
  /// If dense is set, `(e1, 20, null)` is synced to online stores. If dense is
  /// not set, `(e1, 20, 15)` is synced to online stores.
  final bool? dense;

  FeatureGroup_BigQuery({
    this.bigQuerySource,
    this.entityIdColumns,
    this.staticDataSource,
    this.timeSeries,
    this.dense,
  }) : super(fullyQualifiedName);

  factory FeatureGroup_BigQuery.fromJson(Map<String, dynamic> json) {
    return FeatureGroup_BigQuery(
      bigQuerySource: decode(json['bigQuerySource'], BigQuerySource.fromJson),
      entityIdColumns: decodeList(json['entityIdColumns']),
      staticDataSource: json['staticDataSource'],
      timeSeries: decode(
        json['timeSeries'],
        FeatureGroup_BigQuery_TimeSeries.fromJson,
      ),
      dense: json['dense'],
    );
  }

  @override
  Object toJson() {
    return {
      if (bigQuerySource != null) 'bigQuerySource': bigQuerySource!.toJson(),
      if (entityIdColumns != null) 'entityIdColumns': entityIdColumns,
      if (staticDataSource != null) 'staticDataSource': staticDataSource,
      if (timeSeries != null) 'timeSeries': timeSeries!.toJson(),
      if (dense != null) 'dense': dense,
    };
  }

  @override
  String toString() {
    final contents = [
      if (staticDataSource != null) 'staticDataSource=$staticDataSource',
      if (dense != null) 'dense=$dense',
    ].join(',');
    return 'BigQuery($contents)';
  }
}

final class FeatureGroup_BigQuery_TimeSeries extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureGroup.BigQuery.TimeSeries';

  /// Optional. Column hosting timestamp values for a time-series source.
  /// Will be used to determine the latest `feature_values` for each entity.
  /// Optional. If not provided, column named `feature_timestamp` of
  /// type `TIMESTAMP` will be used.
  final String? timestampColumn;

  FeatureGroup_BigQuery_TimeSeries({this.timestampColumn})
    : super(fullyQualifiedName);

  factory FeatureGroup_BigQuery_TimeSeries.fromJson(Map<String, dynamic> json) {
    return FeatureGroup_BigQuery_TimeSeries(
      timestampColumn: json['timestampColumn'],
    );
  }

  @override
  Object toJson() {
    return {if (timestampColumn != null) 'timestampColumn': timestampColumn};
  }

  @override
  String toString() {
    final contents = [
      if (timestampColumn != null) 'timestampColumn=$timestampColumn',
    ].join(',');
    return 'TimeSeries($contents)';
  }
}

/// Service agent type used during jobs under a FeatureGroup.
final class FeatureGroup_ServiceAgentType extends protobuf.ProtoEnum {
  /// By default, the project-level Vertex AI Service Agent is enabled.
  static const serviceAgentTypeUnspecified = FeatureGroup_ServiceAgentType(
    'SERVICE_AGENT_TYPE_UNSPECIFIED',
  );

  /// Specifies the project-level Vertex AI Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  static const serviceAgentTypeProject = FeatureGroup_ServiceAgentType(
    'SERVICE_AGENT_TYPE_PROJECT',
  );

  /// Enable a FeatureGroup service account to be created by Vertex AI and
  /// output in the field `service_account_email`. This service account will
  /// be used to read from the source BigQuery table during jobs under a
  /// FeatureGroup.
  static const serviceAgentTypeFeatureGroup = FeatureGroup_ServiceAgentType(
    'SERVICE_AGENT_TYPE_FEATURE_GROUP',
  );

  const FeatureGroup_ServiceAgentType(super.value);

  factory FeatureGroup_ServiceAgentType.fromJson(String json) =>
      FeatureGroup_ServiceAgentType(json);

  @override
  String toString() => 'ServiceAgentType.$value';
}

/// Vertex AI Feature Monitor.
final class FeatureMonitor extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureMonitor';

  /// Identifier. Name of the FeatureMonitor. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}/featureMonitors/{featureMonitor}`
  final String? name;

  /// Output only. Timestamp when this FeatureMonitor was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this FeatureMonitor was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureMonitor.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureMonitor(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String>? labels;

  /// Optional. Description of the FeatureMonitor.
  final String? description;

  /// Required. Schedule config for the FeatureMonitor.
  final ScheduleConfig? scheduleConfig;

  /// Required. Feature selection config for the FeatureMonitor.
  final FeatureSelectionConfig? featureSelectionConfig;

  FeatureMonitor({
    this.name,
    this.createTime,
    this.updateTime,
    this.etag,
    this.labels,
    this.description,
    this.scheduleConfig,
    this.featureSelectionConfig,
  }) : super(fullyQualifiedName);

  factory FeatureMonitor.fromJson(Map<String, dynamic> json) {
    return FeatureMonitor(
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      description: json['description'],
      scheduleConfig: decode(json['scheduleConfig'], ScheduleConfig.fromJson),
      featureSelectionConfig: decode(
        json['featureSelectionConfig'],
        FeatureSelectionConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (description != null) 'description': description,
      if (scheduleConfig != null) 'scheduleConfig': scheduleConfig!.toJson(),
      if (featureSelectionConfig != null)
        'featureSelectionConfig': featureSelectionConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (etag != null) 'etag=$etag',
      if (description != null) 'description=$description',
    ].join(',');
    return 'FeatureMonitor($contents)';
  }
}

/// Schedule configuration for the FeatureMonitor.
final class ScheduleConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ScheduleConfig';

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs. To explicitly set a timezone to the cron tab, apply a prefix in
  /// the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
  /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
  /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
  /// "TZ=America/New_York 1 * * * *".
  final String? cron;

  ScheduleConfig({this.cron}) : super(fullyQualifiedName);

  factory ScheduleConfig.fromJson(Map<String, dynamic> json) {
    return ScheduleConfig(cron: json['cron']);
  }

  @override
  Object toJson() {
    return {if (cron != null) 'cron': cron};
  }

  @override
  String toString() {
    final contents = [if (cron != null) 'cron=$cron'].join(',');
    return 'ScheduleConfig($contents)';
  }
}

/// Feature selection configuration for the FeatureMonitor.
final class FeatureSelectionConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureSelectionConfig';

  /// Optional. A list of features to be monitored and each feature's drift
  /// threshold.
  final List<FeatureSelectionConfig_FeatureConfig>? featureConfigs;

  FeatureSelectionConfig({this.featureConfigs}) : super(fullyQualifiedName);

  factory FeatureSelectionConfig.fromJson(Map<String, dynamic> json) {
    return FeatureSelectionConfig(
      featureConfigs: decodeListMessage(
        json['featureConfigs'],
        FeatureSelectionConfig_FeatureConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureConfigs != null) 'featureConfigs': encodeList(featureConfigs),
    };
  }

  @override
  String toString() => 'FeatureSelectionConfig()';
}

/// Feature configuration.
final class FeatureSelectionConfig_FeatureConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureSelectionConfig.FeatureConfig';

  /// Required. The ID of the feature resource. Final component of the
  /// Feature's resource name.
  final String? featureId;

  /// Optional. Drift threshold. If calculated difference with baseline data
  /// larger than threshold, it will be considered as the feature has drift. If
  /// not present, the threshold will be default to 0.3.
  final double? driftThreshold;

  FeatureSelectionConfig_FeatureConfig({this.featureId, this.driftThreshold})
    : super(fullyQualifiedName);

  factory FeatureSelectionConfig_FeatureConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureSelectionConfig_FeatureConfig(
      featureId: json['featureId'],
      driftThreshold: decodeDouble(json['driftThreshold']),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureId != null) 'featureId': featureId,
      if (driftThreshold != null)
        'driftThreshold': encodeDouble(driftThreshold),
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureId != null) 'featureId=$featureId',
      if (driftThreshold != null) 'driftThreshold=$driftThreshold',
    ].join(',');
    return 'FeatureConfig($contents)';
  }
}

/// Stats and Anomaly generated by FeatureMonitorJobs. Anomaly only includes
/// Drift.
final class FeatureStatsAndAnomaly extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureStatsAndAnomaly';

  /// Feature Id.
  final String? featureId;

  /// Feature stats. e.g. histogram buckets.
  /// In the format of tensorflow.metadata.v0.DatasetFeatureStatistics.
  final protobuf.Value? featureStats;

  /// Deviation from the current stats to baseline stats.
  ///   1. For categorical feature, the distribution distance is calculated by
  ///      L-inifinity norm.
  ///   2. For numerical feature, the distribution distance is calculated by
  ///      JensenShannon divergence.
  final double? distributionDeviation;

  /// This is the threshold used when detecting drifts, which is set in
  /// FeatureMonitor.FeatureSelectionConfig.FeatureConfig.drift_threshold
  final double? driftDetectionThreshold;

  /// If set to true, indicates current stats is detected as and comparing
  /// with baseline stats.
  final bool? driftDetected;

  /// The timestamp we take snapshot for feature values to generate stats.
  final protobuf.Timestamp? statsTime;

  /// The ID of the FeatureMonitorJob that generated this FeatureStatsAndAnomaly.
  final int? featureMonitorJobId;

  /// The ID of the FeatureMonitor that this FeatureStatsAndAnomaly generated
  /// according to.
  final String? featureMonitorId;

  FeatureStatsAndAnomaly({
    this.featureId,
    this.featureStats,
    this.distributionDeviation,
    this.driftDetectionThreshold,
    this.driftDetected,
    this.statsTime,
    this.featureMonitorJobId,
    this.featureMonitorId,
  }) : super(fullyQualifiedName);

  factory FeatureStatsAndAnomaly.fromJson(Map<String, dynamic> json) {
    return FeatureStatsAndAnomaly(
      featureId: json['featureId'],
      featureStats: decodeCustom(json['featureStats'], protobuf.Value.fromJson),
      distributionDeviation: decodeDouble(json['distributionDeviation']),
      driftDetectionThreshold: decodeDouble(json['driftDetectionThreshold']),
      driftDetected: json['driftDetected'],
      statsTime: decodeCustom(json['statsTime'], protobuf.Timestamp.fromJson),
      featureMonitorJobId: decodeInt64(json['featureMonitorJobId']),
      featureMonitorId: json['featureMonitorId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureId != null) 'featureId': featureId,
      if (featureStats != null) 'featureStats': featureStats!.toJson(),
      if (distributionDeviation != null)
        'distributionDeviation': encodeDouble(distributionDeviation),
      if (driftDetectionThreshold != null)
        'driftDetectionThreshold': encodeDouble(driftDetectionThreshold),
      if (driftDetected != null) 'driftDetected': driftDetected,
      if (statsTime != null) 'statsTime': statsTime!.toJson(),
      if (featureMonitorJobId != null)
        'featureMonitorJobId': encodeInt64(featureMonitorJobId),
      if (featureMonitorId != null) 'featureMonitorId': featureMonitorId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureId != null) 'featureId=$featureId',
      if (distributionDeviation != null)
        'distributionDeviation=$distributionDeviation',
      if (driftDetectionThreshold != null)
        'driftDetectionThreshold=$driftDetectionThreshold',
      if (driftDetected != null) 'driftDetected=$driftDetected',
      if (featureMonitorJobId != null)
        'featureMonitorJobId=$featureMonitorJobId',
      if (featureMonitorId != null) 'featureMonitorId=$featureMonitorId',
    ].join(',');
    return 'FeatureStatsAndAnomaly($contents)';
  }
}

/// Defines how to select FeatureStatsAndAnomaly to be populated in response.
/// If set, retrieves FeatureStatsAndAnomaly generated by FeatureMonitors based
/// on this spec.
final class FeatureStatsAndAnomalySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureStatsAndAnomalySpec';

  /// Optional. If set, returns the most recent count of stats. Valid value is
  /// [0, 100]. If stats_time_range is set, return most recent count of stats
  /// within the stats_time_range.
  final int? latestStatsCount;

  /// Optional. If set, return all stats generated between [start_time,
  /// end_time). If latest_stats_count is set, return the most recent count of
  /// stats within the stats_time_range.
  final Interval? statsTimeRange;

  FeatureStatsAndAnomalySpec({this.latestStatsCount, this.statsTimeRange})
    : super(fullyQualifiedName);

  factory FeatureStatsAndAnomalySpec.fromJson(Map<String, dynamic> json) {
    return FeatureStatsAndAnomalySpec(
      latestStatsCount: json['latestStatsCount'],
      statsTimeRange: decode(json['statsTimeRange'], Interval.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (latestStatsCount != null) 'latestStatsCount': latestStatsCount,
      if (statsTimeRange != null) 'statsTimeRange': statsTimeRange!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (latestStatsCount != null) 'latestStatsCount=$latestStatsCount',
    ].join(',');
    return 'FeatureStatsAndAnomalySpec($contents)';
  }
}

/// Vertex AI Feature Monitor Job.
final class FeatureMonitorJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureMonitorJob';

  /// Identifier. Name of the FeatureMonitorJob. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}/featureMonitorJobs/{feature_monitor_job}`.
  final String? name;

  /// Output only. Timestamp when this FeatureMonitorJob was created. Creation of
  /// a FeatureMonitorJob means that the job is pending / waiting for sufficient
  /// resources but may not have started running yet.
  final protobuf.Timestamp? createTime;

  /// Output only. Final status of the FeatureMonitorJob.
  final Status? finalStatus;

  /// Output only. Summary from the FeatureMonitorJob.
  final FeatureMonitorJob_JobSummary? jobSummary;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureMonitorJob.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureMonitor(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String>? labels;

  /// Optional. Description of the FeatureMonitor.
  final String? description;

  /// Output only. FeatureMonitorJob ID comparing to which the drift is
  /// calculated.
  final int? driftBaseFeatureMonitorJobId;

  /// Output only. Data snapshot time comparing to which the drift is calculated.
  final protobuf.Timestamp? driftBaseSnapshotTime;

  /// Output only. Feature selection config used when creating FeatureMonitorJob.
  final FeatureSelectionConfig? featureSelectionConfig;

  /// Output only. Trigger type of the Feature Monitor Job.
  final FeatureMonitorJob_FeatureMonitorJobTrigger? triggerType;

  FeatureMonitorJob({
    this.name,
    this.createTime,
    this.finalStatus,
    this.jobSummary,
    this.labels,
    this.description,
    this.driftBaseFeatureMonitorJobId,
    this.driftBaseSnapshotTime,
    this.featureSelectionConfig,
    this.triggerType,
  }) : super(fullyQualifiedName);

  factory FeatureMonitorJob.fromJson(Map<String, dynamic> json) {
    return FeatureMonitorJob(
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      finalStatus: decode(json['finalStatus'], Status.fromJson),
      jobSummary: decode(
        json['jobSummary'],
        FeatureMonitorJob_JobSummary.fromJson,
      ),
      labels: decodeMap(json['labels']),
      description: json['description'],
      driftBaseFeatureMonitorJobId: decodeInt64(
        json['driftBaseFeatureMonitorJobId'],
      ),
      driftBaseSnapshotTime: decodeCustom(
        json['driftBaseSnapshotTime'],
        protobuf.Timestamp.fromJson,
      ),
      featureSelectionConfig: decode(
        json['featureSelectionConfig'],
        FeatureSelectionConfig.fromJson,
      ),
      triggerType: decodeEnum(
        json['triggerType'],
        FeatureMonitorJob_FeatureMonitorJobTrigger.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (finalStatus != null) 'finalStatus': finalStatus!.toJson(),
      if (jobSummary != null) 'jobSummary': jobSummary!.toJson(),
      if (labels != null) 'labels': labels,
      if (description != null) 'description': description,
      if (driftBaseFeatureMonitorJobId != null)
        'driftBaseFeatureMonitorJobId': encodeInt64(
          driftBaseFeatureMonitorJobId,
        ),
      if (driftBaseSnapshotTime != null)
        'driftBaseSnapshotTime': driftBaseSnapshotTime!.toJson(),
      if (featureSelectionConfig != null)
        'featureSelectionConfig': featureSelectionConfig!.toJson(),
      if (triggerType != null) 'triggerType': triggerType!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
      if (driftBaseFeatureMonitorJobId != null)
        'driftBaseFeatureMonitorJobId=$driftBaseFeatureMonitorJobId',
      if (triggerType != null) 'triggerType=$triggerType',
    ].join(',');
    return 'FeatureMonitorJob($contents)';
  }
}

/// Summary from the FeatureMonitorJob.
final class FeatureMonitorJob_JobSummary extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureMonitorJob.JobSummary';

  /// Output only. BigQuery slot milliseconds consumed.
  final int? totalSlotMs;

  /// Output only. Features and their stats and anomalies
  final List<FeatureStatsAndAnomaly>? featureStatsAndAnomalies;

  FeatureMonitorJob_JobSummary({
    this.totalSlotMs,
    this.featureStatsAndAnomalies,
  }) : super(fullyQualifiedName);

  factory FeatureMonitorJob_JobSummary.fromJson(Map<String, dynamic> json) {
    return FeatureMonitorJob_JobSummary(
      totalSlotMs: decodeInt64(json['totalSlotMs']),
      featureStatsAndAnomalies: decodeListMessage(
        json['featureStatsAndAnomalies'],
        FeatureStatsAndAnomaly.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (totalSlotMs != null) 'totalSlotMs': encodeInt64(totalSlotMs),
      if (featureStatsAndAnomalies != null)
        'featureStatsAndAnomalies': encodeList(featureStatsAndAnomalies),
    };
  }

  @override
  String toString() {
    final contents = [
      if (totalSlotMs != null) 'totalSlotMs=$totalSlotMs',
    ].join(',');
    return 'JobSummary($contents)';
  }
}

/// Choices of the trigger type.
final class FeatureMonitorJob_FeatureMonitorJobTrigger
    extends protobuf.ProtoEnum {
  /// Trigger type unspecified.
  static const featureMonitorJobTriggerUnspecified =
      FeatureMonitorJob_FeatureMonitorJobTrigger(
        'FEATURE_MONITOR_JOB_TRIGGER_UNSPECIFIED',
      );

  /// Triggered by periodic schedule.
  static const featureMonitorJobTriggerPeriodic =
      FeatureMonitorJob_FeatureMonitorJobTrigger(
        'FEATURE_MONITOR_JOB_TRIGGER_PERIODIC',
      );

  /// Triggered on demand by CreateFeatureMonitorJob request.
  static const featureMonitorJobTriggerOnDemand =
      FeatureMonitorJob_FeatureMonitorJobTrigger(
        'FEATURE_MONITOR_JOB_TRIGGER_ON_DEMAND',
      );

  const FeatureMonitorJob_FeatureMonitorJobTrigger(super.value);

  factory FeatureMonitorJob_FeatureMonitorJobTrigger.fromJson(String json) =>
      FeatureMonitorJob_FeatureMonitorJobTrigger(json);

  @override
  String toString() => 'FeatureMonitorJobTrigger.$value';
}

/// Stats and Anomaly generated at specific timestamp for specific Feature.
/// The start_time and end_time are used to define the time range of the dataset
/// that current stats belongs to, e.g. prediction traffic is bucketed into
/// prediction datasets by time window. If the Dataset is not defined by time
/// window, start_time = end_time. Timestamp of the stats and anomalies always
/// refers to end_time. Raw stats and anomalies are stored in stats_uri or
/// anomaly_uri in the tensorflow defined protos. Field data_stats contains
/// almost identical information with the raw stats in Vertex AI
/// defined proto, for UI to display.
final class FeatureStatsAnomaly extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureStatsAnomaly';

  /// Feature importance score, only populated when cross-feature monitoring is
  /// enabled. For now only used to represent feature attribution score within
  /// range [0, 1] for
  /// `ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_SKEW`
  /// and
  /// `ModelDeploymentMonitoringObjectiveType.FEATURE_ATTRIBUTION_DRIFT`.
  final double? score;

  /// Path of the stats file for current feature values in Cloud Storage bucket.
  /// Format: gs://<bucket_name>/<object_name>/stats.
  /// Example: gs://monitoring_bucket/feature_name/stats.
  /// Stats are stored as binary format with Protobuf message
  /// [tensorflow.metadata.v0.FeatureNameStatistics](https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/statistics.proto).
  final String? statsUri;

  /// Path of the anomaly file for current feature values in Cloud Storage
  /// bucket.
  /// Format: gs://<bucket_name>/<object_name>/anomalies.
  /// Example: gs://monitoring_bucket/feature_name/anomalies.
  /// Stats are stored as binary format with Protobuf message
  /// Anoamlies are stored as binary format with Protobuf message
  /// [tensorflow.metadata.v0.AnomalyInfo]
  /// (https://github.com/tensorflow/metadata/blob/master/tensorflow_metadata/proto/v0/anomalies.proto).
  final String? anomalyUri;

  /// Deviation from the current stats to baseline stats.
  ///   1. For categorical feature, the distribution distance is calculated by
  ///      L-inifinity norm.
  ///   2. For numerical feature, the distribution distance is calculated by
  ///      JensenShannon divergence.
  final double? distributionDeviation;

  /// This is the threshold used when detecting anomalies.
  /// The threshold can be changed by user, so this one might be different from
  /// `ThresholdConfig.value`.
  final double? anomalyDetectionThreshold;

  /// The start timestamp of window where stats were generated.
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), start_time is only used to indicate the monitoring
  /// intervals, so it always equals to (end_time - monitoring_interval).
  final protobuf.Timestamp? startTime;

  /// The end timestamp of window where stats were generated.
  /// For objectives where time window doesn't make sense (e.g. Featurestore
  /// Snapshot Monitoring), end_time indicates the timestamp of the data used to
  /// generate stats (e.g. timestamp we take snapshots for feature values).
  final protobuf.Timestamp? endTime;

  FeatureStatsAnomaly({
    this.score,
    this.statsUri,
    this.anomalyUri,
    this.distributionDeviation,
    this.anomalyDetectionThreshold,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory FeatureStatsAnomaly.fromJson(Map<String, dynamic> json) {
    return FeatureStatsAnomaly(
      score: decodeDouble(json['score']),
      statsUri: json['statsUri'],
      anomalyUri: json['anomalyUri'],
      distributionDeviation: decodeDouble(json['distributionDeviation']),
      anomalyDetectionThreshold: decodeDouble(
        json['anomalyDetectionThreshold'],
      ),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (score != null) 'score': encodeDouble(score),
      if (statsUri != null) 'statsUri': statsUri,
      if (anomalyUri != null) 'anomalyUri': anomalyUri,
      if (distributionDeviation != null)
        'distributionDeviation': encodeDouble(distributionDeviation),
      if (anomalyDetectionThreshold != null)
        'anomalyDetectionThreshold': encodeDouble(anomalyDetectionThreshold),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (score != null) 'score=$score',
      if (statsUri != null) 'statsUri=$statsUri',
      if (anomalyUri != null) 'anomalyUri=$anomalyUri',
      if (distributionDeviation != null)
        'distributionDeviation=$distributionDeviation',
      if (anomalyDetectionThreshold != null)
        'anomalyDetectionThreshold=$anomalyDetectionThreshold',
    ].join(',');
    return 'FeatureStatsAnomaly($contents)';
  }
}

/// Vertex AI Feature Online Store provides a centralized repository for serving
/// ML features and embedding indexes at low latency. The Feature Online Store is
/// a top-level container.
final class FeatureOnlineStore extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore';

  /// Contains settings for the Cloud Bigtable instance that will be created
  /// to serve featureValues for all FeatureViews under this
  /// FeatureOnlineStore.
  final FeatureOnlineStore_Bigtable? bigtable;

  /// Contains settings for the Optimized store that will be created
  /// to serve featureValues for all FeatureViews under this
  /// FeatureOnlineStore. When choose Optimized storage type, need to set
  /// `PrivateServiceConnectConfig.enable_private_service_connect`
  /// to use private endpoint. Otherwise will use public endpoint by default.
  final FeatureOnlineStore_Optimized? optimized;

  /// Identifier. Name of the FeatureOnlineStore. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}`
  final String? name;

  /// Output only. Timestamp when this FeatureOnlineStore was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this FeatureOnlineStore was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureOnlineStore.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String>? labels;

  /// Output only. State of the featureOnlineStore.
  final FeatureOnlineStore_State? state;

  /// Optional. The dedicated serving endpoint for this FeatureOnlineStore, which
  /// is different from common Vertex service endpoint.
  final FeatureOnlineStore_DedicatedServingEndpoint? dedicatedServingEndpoint;

  /// Optional. Deprecated: This field is no longer needed anymore and embedding
  /// management is automatically enabled when specifying Optimized storage type.
  final FeatureOnlineStore_EmbeddingManagement? embeddingManagement;

  /// Optional. Customer-managed encryption key spec for data storage. If set,
  /// online store will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  FeatureOnlineStore({
    this.bigtable,
    this.optimized,
    this.name,
    this.createTime,
    this.updateTime,
    this.etag,
    this.labels,
    this.state,
    this.dedicatedServingEndpoint,
    this.embeddingManagement,
    this.encryptionSpec,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore.fromJson(Map<String, dynamic> json) {
    return FeatureOnlineStore(
      bigtable: decode(json['bigtable'], FeatureOnlineStore_Bigtable.fromJson),
      optimized: decode(
        json['optimized'],
        FeatureOnlineStore_Optimized.fromJson,
      ),
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      state: decodeEnum(json['state'], FeatureOnlineStore_State.fromJson),
      dedicatedServingEndpoint: decode(
        json['dedicatedServingEndpoint'],
        FeatureOnlineStore_DedicatedServingEndpoint.fromJson,
      ),
      embeddingManagement: decode(
        json['embeddingManagement'],
        FeatureOnlineStore_EmbeddingManagement.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (bigtable != null) 'bigtable': bigtable!.toJson(),
      if (optimized != null) 'optimized': optimized!.toJson(),
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (state != null) 'state': state!.toJson(),
      if (dedicatedServingEndpoint != null)
        'dedicatedServingEndpoint': dedicatedServingEndpoint!.toJson(),
      if (embeddingManagement != null)
        'embeddingManagement': embeddingManagement!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (etag != null) 'etag=$etag',
      if (state != null) 'state=$state',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'FeatureOnlineStore($contents)';
  }
}

final class FeatureOnlineStore_Bigtable extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.Bigtable';

  /// Required. Autoscaling config applied to Bigtable Instance.
  final FeatureOnlineStore_Bigtable_AutoScaling? autoScaling;

  /// If true, enable direct access to the Bigtable instance.
  final bool? enableDirectBigtableAccess;

  /// Metadata of the Bigtable instance. Output only.
  final FeatureOnlineStore_Bigtable_BigtableMetadata? bigtableMetadata;

  FeatureOnlineStore_Bigtable({
    this.autoScaling,
    this.enableDirectBigtableAccess,
    this.bigtableMetadata,
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore_Bigtable.fromJson(Map<String, dynamic> json) {
    return FeatureOnlineStore_Bigtable(
      autoScaling: decode(
        json['autoScaling'],
        FeatureOnlineStore_Bigtable_AutoScaling.fromJson,
      ),
      enableDirectBigtableAccess: json['enableDirectBigtableAccess'],
      bigtableMetadata: decode(
        json['bigtableMetadata'],
        FeatureOnlineStore_Bigtable_BigtableMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (autoScaling != null) 'autoScaling': autoScaling!.toJson(),
      if (enableDirectBigtableAccess != null)
        'enableDirectBigtableAccess': enableDirectBigtableAccess,
      if (bigtableMetadata != null)
        'bigtableMetadata': bigtableMetadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (enableDirectBigtableAccess != null)
        'enableDirectBigtableAccess=$enableDirectBigtableAccess',
    ].join(',');
    return 'Bigtable($contents)';
  }
}

final class FeatureOnlineStore_Bigtable_AutoScaling
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.Bigtable.AutoScaling';

  /// Required. The minimum number of nodes to scale down to. Must be greater
  /// than or equal to 1.
  final int? minNodeCount;

  /// Required. The maximum number of nodes to scale up to. Must be greater
  /// than or equal to min_node_count, and less than or equal to 10 times of
  /// 'min_node_count'.
  final int? maxNodeCount;

  /// Optional. A percentage of the cluster's CPU capacity. Can be from 10%
  /// to 80%. When a cluster's CPU utilization exceeds the target that you
  /// have set, Bigtable immediately adds nodes to the cluster. When CPU
  /// utilization is substantially lower than the target, Bigtable removes
  /// nodes. If not set will default to 50%.
  final int? cpuUtilizationTarget;

  FeatureOnlineStore_Bigtable_AutoScaling({
    this.minNodeCount,
    this.maxNodeCount,
    this.cpuUtilizationTarget,
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore_Bigtable_AutoScaling.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureOnlineStore_Bigtable_AutoScaling(
      minNodeCount: json['minNodeCount'],
      maxNodeCount: json['maxNodeCount'],
      cpuUtilizationTarget: json['cpuUtilizationTarget'],
    );
  }

  @override
  Object toJson() {
    return {
      if (minNodeCount != null) 'minNodeCount': minNodeCount,
      if (maxNodeCount != null) 'maxNodeCount': maxNodeCount,
      if (cpuUtilizationTarget != null)
        'cpuUtilizationTarget': cpuUtilizationTarget,
    };
  }

  @override
  String toString() {
    final contents = [
      if (minNodeCount != null) 'minNodeCount=$minNodeCount',
      if (maxNodeCount != null) 'maxNodeCount=$maxNodeCount',
      if (cpuUtilizationTarget != null)
        'cpuUtilizationTarget=$cpuUtilizationTarget',
    ].join(',');
    return 'AutoScaling($contents)';
  }
}

/// Metadata of the Bigtable instance. This is used by direct read access to
/// the Bigtable in tenant project.
final class FeatureOnlineStore_Bigtable_BigtableMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.Bigtable.BigtableMetadata';

  /// Tenant project ID.
  final String? tenantProjectId;

  /// The Cloud Bigtable instance id.
  final String? instanceId;

  /// The Cloud Bigtable table id.
  final String? tableId;

  FeatureOnlineStore_Bigtable_BigtableMetadata({
    this.tenantProjectId,
    this.instanceId,
    this.tableId,
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore_Bigtable_BigtableMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureOnlineStore_Bigtable_BigtableMetadata(
      tenantProjectId: json['tenantProjectId'],
      instanceId: json['instanceId'],
      tableId: json['tableId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tenantProjectId != null) 'tenantProjectId': tenantProjectId,
      if (instanceId != null) 'instanceId': instanceId,
      if (tableId != null) 'tableId': tableId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (tenantProjectId != null) 'tenantProjectId=$tenantProjectId',
      if (instanceId != null) 'instanceId=$instanceId',
      if (tableId != null) 'tableId=$tableId',
    ].join(',');
    return 'BigtableMetadata($contents)';
  }
}

/// Optimized storage type
final class FeatureOnlineStore_Optimized extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.Optimized';

  FeatureOnlineStore_Optimized() : super(fullyQualifiedName);

  factory FeatureOnlineStore_Optimized.fromJson(Map<String, dynamic> json) {
    return FeatureOnlineStore_Optimized();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'Optimized()';
}

/// The dedicated serving endpoint for this FeatureOnlineStore. Only need to
/// set when you choose Optimized storage type. Public endpoint is provisioned
/// by default.
final class FeatureOnlineStore_DedicatedServingEndpoint
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.DedicatedServingEndpoint';

  /// Output only. This field will be populated with the domain name to use for
  /// this FeatureOnlineStore
  final String? publicEndpointDomainName;

  /// Optional. Private service connect config. The private service connection
  /// is available only for Optimized storage type, not for embedding
  /// management now. If
  /// `PrivateServiceConnectConfig.enable_private_service_connect`
  /// set to true, customers will use private service connection to send
  /// request. Otherwise, the connection will set to public endpoint.
  final PrivateServiceConnectConfig? privateServiceConnectConfig;

  /// Output only. The name of the service attachment resource. Populated if
  /// private service connect is enabled and after FeatureViewSync is created.
  final String? serviceAttachment;

  FeatureOnlineStore_DedicatedServingEndpoint({
    this.publicEndpointDomainName,
    this.privateServiceConnectConfig,
    this.serviceAttachment,
  }) : super(fullyQualifiedName);

  factory FeatureOnlineStore_DedicatedServingEndpoint.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureOnlineStore_DedicatedServingEndpoint(
      publicEndpointDomainName: json['publicEndpointDomainName'],
      privateServiceConnectConfig: decode(
        json['privateServiceConnectConfig'],
        PrivateServiceConnectConfig.fromJson,
      ),
      serviceAttachment: json['serviceAttachment'],
    );
  }

  @override
  Object toJson() {
    return {
      if (publicEndpointDomainName != null)
        'publicEndpointDomainName': publicEndpointDomainName,
      if (privateServiceConnectConfig != null)
        'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
      if (serviceAttachment != null) 'serviceAttachment': serviceAttachment,
    };
  }

  @override
  String toString() {
    final contents = [
      if (publicEndpointDomainName != null)
        'publicEndpointDomainName=$publicEndpointDomainName',
      if (serviceAttachment != null) 'serviceAttachment=$serviceAttachment',
    ].join(',');
    return 'DedicatedServingEndpoint($contents)';
  }
}

/// Deprecated: This sub message is no longer needed anymore and embedding
/// management is automatically enabled when specifying Optimized storage type.
/// Contains settings for embedding management.
final class FeatureOnlineStore_EmbeddingManagement
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureOnlineStore.EmbeddingManagement';

  /// Optional. Immutable. Whether to enable embedding management in this
  /// FeatureOnlineStore. It's immutable after creation to ensure the
  /// FeatureOnlineStore availability.
  final bool? enabled;

  FeatureOnlineStore_EmbeddingManagement({this.enabled})
    : super(fullyQualifiedName);

  factory FeatureOnlineStore_EmbeddingManagement.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureOnlineStore_EmbeddingManagement(enabled: json['enabled']);
  }

  @override
  Object toJson() {
    return {if (enabled != null) 'enabled': enabled};
  }

  @override
  String toString() {
    final contents = [if (enabled != null) 'enabled=$enabled'].join(',');
    return 'EmbeddingManagement($contents)';
  }
}

/// Possible states a featureOnlineStore can have.
final class FeatureOnlineStore_State extends protobuf.ProtoEnum {
  /// Default value. This value is unused.
  static const stateUnspecified = FeatureOnlineStore_State('STATE_UNSPECIFIED');

  /// State when the featureOnlineStore configuration is not being updated and
  /// the fields reflect the current configuration of the featureOnlineStore.
  /// The featureOnlineStore is usable in this state.
  static const stable = FeatureOnlineStore_State('STABLE');

  /// The state of the featureOnlineStore configuration when it is being
  /// updated. During an update, the fields reflect either the original
  /// configuration or the updated configuration of the featureOnlineStore. The
  /// featureOnlineStore is still usable in this state.
  static const updating = FeatureOnlineStore_State('UPDATING');

  const FeatureOnlineStore_State(super.value);

  factory FeatureOnlineStore_State.fromJson(String json) =>
      FeatureOnlineStore_State(json);

  @override
  String toString() => 'State.$value';
}

/// Request message for
/// `FeatureOnlineStoreAdminService.CreateFeatureOnlineStore`.
final class CreateFeatureOnlineStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureOnlineStoreRequest';

  /// Required. The resource name of the Location to create FeatureOnlineStores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The FeatureOnlineStore to create.
  final FeatureOnlineStore featureOnlineStore;

  /// Required. The ID to use for this FeatureOnlineStore, which will become the
  /// final component of the FeatureOnlineStore's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the project and location.
  final String? featureOnlineStoreId;

  CreateFeatureOnlineStoreRequest({
    required this.parent,
    required this.featureOnlineStore,
    this.featureOnlineStoreId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureOnlineStoreRequest.fromJson(Map<String, dynamic> json) {
    return CreateFeatureOnlineStoreRequest(
      parent: json['parent'],
      featureOnlineStore: decode(
        json['featureOnlineStore'],
        FeatureOnlineStore.fromJson,
      )!,
      featureOnlineStoreId: json['featureOnlineStoreId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'featureOnlineStore': featureOnlineStore.toJson(),
      if (featureOnlineStoreId != null)
        'featureOnlineStoreId': featureOnlineStoreId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (featureOnlineStoreId != null)
        'featureOnlineStoreId=$featureOnlineStoreId',
    ].join(',');
    return 'CreateFeatureOnlineStoreRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.GetFeatureOnlineStore`.
final class GetFeatureOnlineStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureOnlineStoreRequest';

  /// Required. The name of the FeatureOnlineStore resource.
  final String name;

  GetFeatureOnlineStoreRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetFeatureOnlineStoreRequest.fromJson(Map<String, dynamic> json) {
    return GetFeatureOnlineStoreRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureOnlineStoreRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.ListFeatureOnlineStores`.
final class ListFeatureOnlineStoresRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureOnlineStoresRequest';

  /// Required. The resource name of the Location to list FeatureOnlineStores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the FeatureOnlineStores that match the filter expression. The
  /// following fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    FeatureOnlineStores created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    FeatureOnlineStores with label "env" set to "prod".
  final String? filter;

  /// The maximum number of FeatureOnlineStores to return. The service may return
  /// fewer than this value. If unspecified, at most 100 FeatureOnlineStores will
  /// be returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `FeatureOnlineStoreAdminService.ListFeatureOnlineStores`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureOnlineStoreAdminService.ListFeatureOnlineStores`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  final String? orderBy;

  ListFeatureOnlineStoresRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListFeatureOnlineStoresRequest.fromJson(Map<String, dynamic> json) {
    return ListFeatureOnlineStoresRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureOnlineStoresRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreAdminService.ListFeatureOnlineStores`.
final class ListFeatureOnlineStoresResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureOnlineStoresResponse';

  /// The FeatureOnlineStores matching the request.
  final List<FeatureOnlineStore>? featureOnlineStores;

  /// A token, which can be sent as
  /// `ListFeatureOnlineStoresRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListFeatureOnlineStoresResponse({
    this.featureOnlineStores,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListFeatureOnlineStoresResponse.fromJson(Map<String, dynamic> json) {
    return ListFeatureOnlineStoresResponse(
      featureOnlineStores: decodeListMessage(
        json['featureOnlineStores'],
        FeatureOnlineStore.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureOnlineStores != null)
        'featureOnlineStores': encodeList(featureOnlineStores),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFeatureOnlineStoresResponse($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.UpdateFeatureOnlineStore`.
final class UpdateFeatureOnlineStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureOnlineStoreRequest';

  /// Required. The FeatureOnlineStore's `name` field is used to identify the
  /// FeatureOnlineStore to be updated. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  final FeatureOnlineStore featureOnlineStore;

  /// Field mask is used to specify the fields to be overwritten in the
  /// FeatureOnlineStore resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `description`
  ///   * `bigtable`
  ///   * `bigtable.auto_scaling`
  ///   * `bigtable.enable_multi_region_replica`
  final protobuf.FieldMask? updateMask;

  UpdateFeatureOnlineStoreRequest({
    required this.featureOnlineStore,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateFeatureOnlineStoreRequest.fromJson(Map<String, dynamic> json) {
    return UpdateFeatureOnlineStoreRequest(
      featureOnlineStore: decode(
        json['featureOnlineStore'],
        FeatureOnlineStore.fromJson,
      )!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'featureOnlineStore': featureOnlineStore.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureOnlineStoreRequest()';
}

/// Request message for
/// `FeatureOnlineStoreAdminService.DeleteFeatureOnlineStore`.
final class DeleteFeatureOnlineStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureOnlineStoreRequest';

  /// Required. The name of the FeatureOnlineStore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  final String name;

  /// If set to true, any FeatureViews and Features for this FeatureOnlineStore
  /// will also be deleted. (Otherwise, the request will only work if the
  /// FeatureOnlineStore has no FeatureViews.)
  final bool? force;

  DeleteFeatureOnlineStoreRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteFeatureOnlineStoreRequest.fromJson(Map<String, dynamic> json) {
    return DeleteFeatureOnlineStoreRequest(
      name: json['name'],
      force: json['force'],
    );
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteFeatureOnlineStoreRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.CreateFeatureView`.
final class CreateFeatureViewRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureViewRequest';

  /// Required. The resource name of the FeatureOnlineStore to create
  /// FeatureViews. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  final String parent;

  /// Required. The FeatureView to create.
  final FeatureView featureView;

  /// Required. The ID to use for the FeatureView, which will become the final
  /// component of the FeatureView's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within a FeatureOnlineStore.
  final String? featureViewId;

  /// Immutable. If set to true, one on demand sync will be run immediately,
  /// regardless whether the
  /// `FeatureView.sync_config`
  /// is configured or not.
  final bool? runSyncImmediately;

  CreateFeatureViewRequest({
    required this.parent,
    required this.featureView,
    this.featureViewId,
    this.runSyncImmediately,
  }) : super(fullyQualifiedName);

  factory CreateFeatureViewRequest.fromJson(Map<String, dynamic> json) {
    return CreateFeatureViewRequest(
      parent: json['parent'],
      featureView: decode(json['featureView'], FeatureView.fromJson)!,
      featureViewId: json['featureViewId'],
      runSyncImmediately: json['runSyncImmediately'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'featureView': featureView.toJson(),
      if (featureViewId != null) 'featureViewId': featureViewId,
      if (runSyncImmediately != null) 'runSyncImmediately': runSyncImmediately,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (featureViewId != null) 'featureViewId=$featureViewId',
      if (runSyncImmediately != null) 'runSyncImmediately=$runSyncImmediately',
    ].join(',');
    return 'CreateFeatureViewRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.GetFeatureView`.
final class GetFeatureViewRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureViewRequest';

  /// Required. The name of the FeatureView resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String name;

  GetFeatureViewRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureViewRequest.fromJson(Map<String, dynamic> json) {
    return GetFeatureViewRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureViewRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.ListFeatureViews`.
final class ListFeatureViewsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureViewsRequest';

  /// Required. The resource name of the FeatureOnlineStore to list FeatureViews.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}`
  final String parent;

  /// Lists the FeatureViews that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `labels`: Supports key-value equality as well as key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
  ///      update_time > \"2020-01-31T15:30:00.000000Z\"` --> FeatureViews
  ///      created or updated after 2020-01-31T15:30:00.000000Z.
  /// * `labels.active = yes AND labels.env = prod` --> FeatureViews having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any FeatureView which has a label with 'env' as the
  ///   key.
  final String? filter;

  /// The maximum number of FeatureViews to return. The service may return fewer
  /// than this value. If unspecified, at most 1000 FeatureViews will be
  /// returned. The maximum value is 1000; any value greater than 1000 will be
  /// coerced to 1000.
  final int? pageSize;

  /// A page token, received from a previous
  /// `FeatureOnlineStoreAdminService.ListFeatureViews`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureOnlineStoreAdminService.ListFeatureViews`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  ///
  /// Supported fields:
  ///
  ///   * `feature_view_id`
  ///   * `create_time`
  ///   * `update_time`
  final String? orderBy;

  ListFeatureViewsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListFeatureViewsRequest.fromJson(Map<String, dynamic> json) {
    return ListFeatureViewsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureViewsRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreAdminService.ListFeatureViews`.
final class ListFeatureViewsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureViewsResponse';

  /// The FeatureViews matching the request.
  final List<FeatureView>? featureViews;

  /// A token, which can be sent as
  /// `ListFeatureViewsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListFeatureViewsResponse({this.featureViews, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListFeatureViewsResponse.fromJson(Map<String, dynamic> json) {
    return ListFeatureViewsResponse(
      featureViews: decodeListMessage(
        json['featureViews'],
        FeatureView.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureViews != null) 'featureViews': encodeList(featureViews),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFeatureViewsResponse($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.UpdateFeatureView`.
final class UpdateFeatureViewRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureViewRequest';

  /// Required. The FeatureView's `name` field is used to identify the
  /// FeatureView to be updated. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final FeatureView featureView;

  /// Field mask is used to specify the fields to be overwritten in the
  /// FeatureView resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `service_agent_type`
  ///   * `big_query_source`
  ///   * `big_query_source.uri`
  ///   * `big_query_source.entity_id_columns`
  ///   * `feature_registry_source`
  ///   * `feature_registry_source.feature_groups`
  ///   * `sync_config`
  ///   * `sync_config.cron`
  final protobuf.FieldMask? updateMask;

  UpdateFeatureViewRequest({required this.featureView, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeatureViewRequest.fromJson(Map<String, dynamic> json) {
    return UpdateFeatureViewRequest(
      featureView: decode(json['featureView'], FeatureView.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'featureView': featureView.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureViewRequest()';
}

/// Request message for `FeatureOnlineStoreAdminService.DeleteFeatureViews`.
final class DeleteFeatureViewRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureViewRequest';

  /// Required. The name of the FeatureView to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String name;

  DeleteFeatureViewRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteFeatureViewRequest.fromJson(Map<String, dynamic> json) {
    return DeleteFeatureViewRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteFeatureViewRequest($contents)';
  }
}

/// Details of operations that perform create FeatureOnlineStore.
final class CreateFeatureOnlineStoreOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureOnlineStoreOperationMetadata';

  /// Operation metadata for FeatureOnlineStore.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureOnlineStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureOnlineStoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateFeatureOnlineStoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateFeatureOnlineStoreOperationMetadata()';
}

/// Details of operations that perform update FeatureOnlineStore.
final class UpdateFeatureOnlineStoreOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureOnlineStoreOperationMetadata';

  /// Operation metadata for FeatureOnlineStore.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureOnlineStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureOnlineStoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateFeatureOnlineStoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureOnlineStoreOperationMetadata()';
}

/// Details of operations that perform create FeatureView.
final class CreateFeatureViewOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureViewOperationMetadata';

  /// Operation metadata for FeatureView Create.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureViewOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureViewOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateFeatureViewOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateFeatureViewOperationMetadata()';
}

/// Details of operations that perform update FeatureView.
final class UpdateFeatureViewOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureViewOperationMetadata';

  /// Operation metadata for FeatureView Update.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureViewOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureViewOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateFeatureViewOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureViewOperationMetadata()';
}

/// Request message for
/// `FeatureOnlineStoreAdminService.SyncFeatureView`.
final class SyncFeatureViewRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SyncFeatureViewRequest';

  /// Required. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String featureView;

  SyncFeatureViewRequest({required this.featureView})
    : super(fullyQualifiedName);

  factory SyncFeatureViewRequest.fromJson(Map<String, dynamic> json) {
    return SyncFeatureViewRequest(featureView: json['featureView']);
  }

  @override
  Object toJson() {
    return {'featureView': featureView};
  }

  @override
  String toString() {
    final contents = ['featureView=$featureView'].join(',');
    return 'SyncFeatureViewRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreAdminService.SyncFeatureView`.
final class SyncFeatureViewResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SyncFeatureViewResponse';

  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  final String? featureViewSync;

  SyncFeatureViewResponse({this.featureViewSync}) : super(fullyQualifiedName);

  factory SyncFeatureViewResponse.fromJson(Map<String, dynamic> json) {
    return SyncFeatureViewResponse(featureViewSync: json['featureViewSync']);
  }

  @override
  Object toJson() {
    return {if (featureViewSync != null) 'featureViewSync': featureViewSync};
  }

  @override
  String toString() {
    final contents = [
      if (featureViewSync != null) 'featureViewSync=$featureViewSync',
    ].join(',');
    return 'SyncFeatureViewResponse($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.GetFeatureViewSync`.
final class GetFeatureViewSyncRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureViewSyncRequest';

  /// Required. The name of the FeatureViewSync resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  final String name;

  GetFeatureViewSyncRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureViewSyncRequest.fromJson(Map<String, dynamic> json) {
    return GetFeatureViewSyncRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureViewSyncRequest($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreAdminService.ListFeatureViewSyncs`.
final class ListFeatureViewSyncsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureViewSyncsRequest';

  /// Required. The resource name of the FeatureView to list FeatureViewSyncs.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String parent;

  /// Lists the FeatureViewSyncs that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  ///
  /// Examples:
  ///
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\"` --> FeatureViewSyncs
  ///      created after 2020-01-31T15:30:00.000000Z.
  final String? filter;

  /// The maximum number of FeatureViewSyncs to return. The service may return
  /// fewer than this value. If unspecified, at most 1000 FeatureViewSyncs will
  /// be returned. The maximum value is 1000; any value greater than 1000 will be
  /// coerced to 1000.
  final int? pageSize;

  /// A page token, received from a previous
  /// `FeatureOnlineStoreAdminService.ListFeatureViewSyncs`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureOnlineStoreAdminService.ListFeatureViewSyncs`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  ///
  /// Supported fields:
  ///
  ///   * `create_time`
  final String? orderBy;

  ListFeatureViewSyncsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListFeatureViewSyncsRequest.fromJson(Map<String, dynamic> json) {
    return ListFeatureViewSyncsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureViewSyncsRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreAdminService.ListFeatureViewSyncs`.
final class ListFeatureViewSyncsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureViewSyncsResponse';

  /// The FeatureViewSyncs matching the request.
  final List<FeatureViewSync>? featureViewSyncs;

  /// A token, which can be sent as
  /// `ListFeatureViewSyncsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListFeatureViewSyncsResponse({this.featureViewSyncs, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListFeatureViewSyncsResponse.fromJson(Map<String, dynamic> json) {
    return ListFeatureViewSyncsResponse(
      featureViewSyncs: decodeListMessage(
        json['featureViewSyncs'],
        FeatureViewSync.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureViewSyncs != null)
        'featureViewSyncs': encodeList(featureViewSyncs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFeatureViewSyncsResponse($contents)';
  }
}

/// Lookup key for a feature view.
final class FeatureViewDataKey extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDataKey';

  /// String key to use for lookup.
  final String? key;

  /// The actual Entity ID will be composed from this struct. This should match
  /// with the way ID is defined in the FeatureView spec.
  final FeatureViewDataKey_CompositeKey? compositeKey;

  FeatureViewDataKey({this.key, this.compositeKey}) : super(fullyQualifiedName);

  factory FeatureViewDataKey.fromJson(Map<String, dynamic> json) {
    return FeatureViewDataKey(
      key: json['key'],
      compositeKey: decode(
        json['compositeKey'],
        FeatureViewDataKey_CompositeKey.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (key != null) 'key': key,
      if (compositeKey != null) 'compositeKey': compositeKey!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (key != null) 'key=$key'].join(',');
    return 'FeatureViewDataKey($contents)';
  }
}

/// ID that is comprised from several parts (columns).
final class FeatureViewDataKey_CompositeKey extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDataKey.CompositeKey';

  /// Parts to construct Entity ID. Should match with the same ID columns as
  /// defined in FeatureView in the same order.
  final List<String>? parts;

  FeatureViewDataKey_CompositeKey({this.parts}) : super(fullyQualifiedName);

  factory FeatureViewDataKey_CompositeKey.fromJson(Map<String, dynamic> json) {
    return FeatureViewDataKey_CompositeKey(parts: decodeList(json['parts']));
  }

  @override
  Object toJson() {
    return {if (parts != null) 'parts': parts};
  }

  @override
  String toString() => 'CompositeKey()';
}

/// Request message for
/// `FeatureOnlineStoreService.FetchFeatureValues`.
/// All the features under the requested feature view will be returned.
final class FetchFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchFeatureValuesRequest';

  /// Simple ID. The whole string will be used as is to identify Entity to
  /// fetch feature values for.
  final String? id;

  /// Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String featureView;

  /// Optional. The request key to fetch feature values for.
  final FeatureViewDataKey? dataKey;

  /// Optional. Response data format. If not set,
  /// `FeatureViewDataFormat.KEY_VALUE`
  /// will be used.
  final FeatureViewDataFormat? dataFormat;

  /// Specify response data format. If not set, KeyValue format will be used.
  /// Deprecated. Use
  /// `FetchFeatureValuesRequest.data_format`.
  final FetchFeatureValuesRequest_Format? format;

  FetchFeatureValuesRequest({
    this.id,
    required this.featureView,
    this.dataKey,
    this.dataFormat,
    this.format,
  }) : super(fullyQualifiedName);

  factory FetchFeatureValuesRequest.fromJson(Map<String, dynamic> json) {
    return FetchFeatureValuesRequest(
      id: json['id'],
      featureView: json['featureView'],
      dataKey: decode(json['dataKey'], FeatureViewDataKey.fromJson),
      dataFormat: decodeEnum(
        json['dataFormat'],
        FeatureViewDataFormat.fromJson,
      ),
      format: decodeEnum(
        json['format'],
        FetchFeatureValuesRequest_Format.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      'featureView': featureView,
      if (dataKey != null) 'dataKey': dataKey!.toJson(),
      if (dataFormat != null) 'dataFormat': dataFormat!.toJson(),
      if (format != null) 'format': format!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      'featureView=$featureView',
      if (dataFormat != null) 'dataFormat=$dataFormat',
      if (format != null) 'format=$format',
    ].join(',');
    return 'FetchFeatureValuesRequest($contents)';
  }
}

/// Format of the response data.
final class FetchFeatureValuesRequest_Format extends protobuf.ProtoEnum {
  /// Not set. Will be treated as the KeyValue format.
  static const formatUnspecified = FetchFeatureValuesRequest_Format(
    'FORMAT_UNSPECIFIED',
  );

  /// Return response data in key-value format.
  static const keyValue = FetchFeatureValuesRequest_Format('KEY_VALUE');

  /// Return response data in proto Struct format.
  static const protoStruct = FetchFeatureValuesRequest_Format('PROTO_STRUCT');

  const FetchFeatureValuesRequest_Format(super.value);

  factory FetchFeatureValuesRequest_Format.fromJson(String json) =>
      FetchFeatureValuesRequest_Format(json);

  @override
  String toString() => 'Format.$value';
}

/// Response message for
/// `FeatureOnlineStoreService.FetchFeatureValues`
final class FetchFeatureValuesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchFeatureValuesResponse';

  /// Feature values in KeyValue format.
  final FetchFeatureValuesResponse_FeatureNameValuePairList? keyValues;

  /// Feature values in proto Struct format.
  final protobuf.Struct? protoStruct;

  /// The data key associated with this response.
  /// Will only be populated for
  /// `FeatureOnlineStoreService.StreamingFetchFeatureValues`
  /// RPCs.
  final FeatureViewDataKey? dataKey;

  FetchFeatureValuesResponse({this.keyValues, this.protoStruct, this.dataKey})
    : super(fullyQualifiedName);

  factory FetchFeatureValuesResponse.fromJson(Map<String, dynamic> json) {
    return FetchFeatureValuesResponse(
      keyValues: decode(
        json['keyValues'],
        FetchFeatureValuesResponse_FeatureNameValuePairList.fromJson,
      ),
      protoStruct: decodeCustom(json['protoStruct'], protobuf.Struct.fromJson),
      dataKey: decode(json['dataKey'], FeatureViewDataKey.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (keyValues != null) 'keyValues': keyValues!.toJson(),
      if (protoStruct != null) 'protoStruct': protoStruct!.toJson(),
      if (dataKey != null) 'dataKey': dataKey!.toJson(),
    };
  }

  @override
  String toString() => 'FetchFeatureValuesResponse()';
}

/// Response structure in the format of key (feature name) and (feature) value
/// pair.
final class FetchFeatureValuesResponse_FeatureNameValuePairList
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchFeatureValuesResponse.FeatureNameValuePairList';

  /// List of feature names and values.
  final List<
    FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair
  >?
  features;

  FetchFeatureValuesResponse_FeatureNameValuePairList({this.features})
    : super(fullyQualifiedName);

  factory FetchFeatureValuesResponse_FeatureNameValuePairList.fromJson(
    Map<String, dynamic> json,
  ) {
    return FetchFeatureValuesResponse_FeatureNameValuePairList(
      features: decodeListMessage(
        json['features'],
        FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (features != null) 'features': encodeList(features)};
  }

  @override
  String toString() => 'FeatureNameValuePairList()';
}

/// Feature name & value pair.
final class FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FetchFeatureValuesResponse.FeatureNameValuePairList.FeatureNameValuePair';

  /// Feature value.
  final FeatureValue? value;

  /// Feature short name.
  final String? name;

  FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair({
    this.value,
    this.name,
  }) : super(fullyQualifiedName);

  factory FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair.fromJson(
    Map<String, dynamic> json,
  ) {
    return FetchFeatureValuesResponse_FeatureNameValuePairList_FeatureNameValuePair(
      value: decode(json['value'], FeatureValue.fromJson),
      name: json['name'],
    );
  }

  @override
  Object toJson() {
    return {
      if (value != null) 'value': value!.toJson(),
      if (name != null) 'name': name,
    };
  }

  @override
  String toString() {
    final contents = [if (name != null) 'name=$name'].join(',');
    return 'FeatureNameValuePair($contents)';
  }
}

/// Request message for
/// `FeatureOnlineStoreService.StreamingFetchFeatureValues`.
/// For the entities requested, all features under the requested feature view
/// will be returned.
final class StreamingFetchFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingFetchFeatureValuesRequest';

  /// Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String? featureView;

  final List<FeatureViewDataKey>? dataKeys;

  /// Specify response data format. If not set, KeyValue format will be used.
  final FeatureViewDataFormat? dataFormat;

  StreamingFetchFeatureValuesRequest({
    this.featureView,
    this.dataKeys,
    this.dataFormat,
  }) : super(fullyQualifiedName);

  factory StreamingFetchFeatureValuesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return StreamingFetchFeatureValuesRequest(
      featureView: json['featureView'],
      dataKeys: decodeListMessage(
        json['dataKeys'],
        FeatureViewDataKey.fromJson,
      ),
      dataFormat: decodeEnum(
        json['dataFormat'],
        FeatureViewDataFormat.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureView != null) 'featureView': featureView,
      if (dataKeys != null) 'dataKeys': encodeList(dataKeys),
      if (dataFormat != null) 'dataFormat': dataFormat!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureView != null) 'featureView=$featureView',
      if (dataFormat != null) 'dataFormat=$dataFormat',
    ].join(',');
    return 'StreamingFetchFeatureValuesRequest($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreService.StreamingFetchFeatureValues`.
final class StreamingFetchFeatureValuesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingFetchFeatureValuesResponse';

  /// Response status.
  /// If OK, then
  /// `StreamingFetchFeatureValuesResponse.data`
  /// will be populated. Otherwise
  /// `StreamingFetchFeatureValuesResponse.data_keys_with_error`
  /// will be populated with the appropriate data keys. The error only applies to
  /// the listed data keys - the stream will remain open for further
  /// `FeatureOnlineStoreService.StreamingFetchFeatureValuesRequest` requests.
  final Status? status;

  final List<FetchFeatureValuesResponse>? data;

  final List<FeatureViewDataKey>? dataKeysWithError;

  StreamingFetchFeatureValuesResponse({
    this.status,
    this.data,
    this.dataKeysWithError,
  }) : super(fullyQualifiedName);

  factory StreamingFetchFeatureValuesResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return StreamingFetchFeatureValuesResponse(
      status: decode(json['status'], Status.fromJson),
      data: decodeListMessage(
        json['data'],
        FetchFeatureValuesResponse.fromJson,
      ),
      dataKeysWithError: decodeListMessage(
        json['dataKeysWithError'],
        FeatureViewDataKey.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (status != null) 'status': status!.toJson(),
      if (data != null) 'data': encodeList(data),
      if (dataKeysWithError != null)
        'dataKeysWithError': encodeList(dataKeysWithError),
    };
  }

  @override
  String toString() => 'StreamingFetchFeatureValuesResponse()';
}

/// A query to find a number of similar entities.
final class NearestNeighborQuery extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery';

  /// Optional. The entity id whose similar entities should be searched for.
  /// If embedding is set, search will use embedding instead of
  /// entity_id.
  final String? entityId;

  /// Optional. The embedding vector that be used for similar search.
  final NearestNeighborQuery_Embedding? embedding;

  /// Optional. The number of similar entities to be retrieved from feature view
  /// for each query.
  final int? neighborCount;

  /// Optional. The list of string filters.
  final List<NearestNeighborQuery_StringFilter>? stringFilters;

  /// Optional. The list of numeric filters.
  final List<NearestNeighborQuery_NumericFilter>? numericFilters;

  /// Optional. Crowding is a constraint on a neighbor list produced by nearest
  /// neighbor search requiring that no more than
  /// sper_crowding_attribute_neighbor_count of the k neighbors returned have the
  /// same value of crowding_attribute. It's used for improving result diversity.
  final int? perCrowdingAttributeNeighborCount;

  /// Optional. Parameters that can be set to tune query on the fly.
  final NearestNeighborQuery_Parameters? parameters;

  NearestNeighborQuery({
    this.entityId,
    this.embedding,
    this.neighborCount,
    this.stringFilters,
    this.numericFilters,
    this.perCrowdingAttributeNeighborCount,
    this.parameters,
  }) : super(fullyQualifiedName);

  factory NearestNeighborQuery.fromJson(Map<String, dynamic> json) {
    return NearestNeighborQuery(
      entityId: json['entityId'],
      embedding: decode(
        json['embedding'],
        NearestNeighborQuery_Embedding.fromJson,
      ),
      neighborCount: json['neighborCount'],
      stringFilters: decodeListMessage(
        json['stringFilters'],
        NearestNeighborQuery_StringFilter.fromJson,
      ),
      numericFilters: decodeListMessage(
        json['numericFilters'],
        NearestNeighborQuery_NumericFilter.fromJson,
      ),
      perCrowdingAttributeNeighborCount:
          json['perCrowdingAttributeNeighborCount'],
      parameters: decode(
        json['parameters'],
        NearestNeighborQuery_Parameters.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (entityId != null) 'entityId': entityId,
      if (embedding != null) 'embedding': embedding!.toJson(),
      if (neighborCount != null) 'neighborCount': neighborCount,
      if (stringFilters != null) 'stringFilters': encodeList(stringFilters),
      if (numericFilters != null) 'numericFilters': encodeList(numericFilters),
      if (perCrowdingAttributeNeighborCount != null)
        'perCrowdingAttributeNeighborCount': perCrowdingAttributeNeighborCount,
      if (parameters != null) 'parameters': parameters!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (entityId != null) 'entityId=$entityId',
      if (neighborCount != null) 'neighborCount=$neighborCount',
      if (perCrowdingAttributeNeighborCount != null)
        'perCrowdingAttributeNeighborCount=$perCrowdingAttributeNeighborCount',
    ].join(',');
    return 'NearestNeighborQuery($contents)';
  }
}

/// The embedding vector.
final class NearestNeighborQuery_Embedding extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery.Embedding';

  /// Optional. Individual value in the embedding.
  final List<double>? value;

  NearestNeighborQuery_Embedding({this.value}) : super(fullyQualifiedName);

  factory NearestNeighborQuery_Embedding.fromJson(Map<String, dynamic> json) {
    return NearestNeighborQuery_Embedding(value: decodeList(json['value']));
  }

  @override
  Object toJson() {
    return {if (value != null) 'value': value};
  }

  @override
  String toString() => 'Embedding()';
}

/// String filter is used to search a subset of the entities by using boolean
/// rules on string columns.
/// For example: if a query specifies string filter
/// with 'name = color, allow_tokens = {red, blue}, deny_tokens = {purple}','
/// then that query will match entities that are red or blue, but if those
/// points are also purple, then they will be excluded even if they are
/// red/blue. Only string filter is supported for now, numeric filter will be
/// supported in the near future.
final class NearestNeighborQuery_StringFilter extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery.StringFilter';

  /// Required. Column names in BigQuery that used as filters.
  final String? name;

  /// Optional. The allowed tokens.
  final List<String>? allowTokens;

  /// Optional. The denied tokens.
  final List<String>? denyTokens;

  NearestNeighborQuery_StringFilter({
    this.name,
    this.allowTokens,
    this.denyTokens,
  }) : super(fullyQualifiedName);

  factory NearestNeighborQuery_StringFilter.fromJson(
    Map<String, dynamic> json,
  ) {
    return NearestNeighborQuery_StringFilter(
      name: json['name'],
      allowTokens: decodeList(json['allowTokens']),
      denyTokens: decodeList(json['denyTokens']),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (allowTokens != null) 'allowTokens': allowTokens,
      if (denyTokens != null) 'denyTokens': denyTokens,
    };
  }

  @override
  String toString() {
    final contents = [if (name != null) 'name=$name'].join(',');
    return 'StringFilter($contents)';
  }
}

/// Numeric filter is used to search a subset of the entities by using boolean
/// rules on numeric columns.
/// For example:
/// Database Point 0: {name: a value_int: 42} {name: b value_float: 1.0}
/// Database Point 1:  {name: a value_int: 10} {name: b value_float: 2.0}
/// Database Point 2: {name: a value_int: -1} {name: b value_float: 3.0}
/// Query: {name: a value_int: 12 operator: LESS}    // Matches Point 1, 2
/// {name: b value_float: 2.0 operator: EQUAL} // Matches Point 1
final class NearestNeighborQuery_NumericFilter extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery.NumericFilter';

  /// int value type.
  final int? valueInt;

  /// float value type.
  final double? valueFloat;

  /// double value type.
  final double? valueDouble;

  /// Required. Column name in BigQuery that used as filters.
  final String? name;

  /// Optional. This MUST be specified for queries and must NOT be specified
  /// for database points.
  final NearestNeighborQuery_NumericFilter_Operator? op;

  NearestNeighborQuery_NumericFilter({
    this.valueInt,
    this.valueFloat,
    this.valueDouble,
    this.name,
    this.op,
  }) : super(fullyQualifiedName);

  factory NearestNeighborQuery_NumericFilter.fromJson(
    Map<String, dynamic> json,
  ) {
    return NearestNeighborQuery_NumericFilter(
      valueInt: decodeInt64(json['valueInt']),
      valueFloat: decodeDouble(json['valueFloat']),
      valueDouble: decodeDouble(json['valueDouble']),
      name: json['name'],
      op: decodeEnum(
        json['op'],
        NearestNeighborQuery_NumericFilter_Operator.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (valueInt != null) 'valueInt': encodeInt64(valueInt),
      if (valueFloat != null) 'valueFloat': encodeDouble(valueFloat),
      if (valueDouble != null) 'valueDouble': encodeDouble(valueDouble),
      if (name != null) 'name': name,
      if (op != null) 'op': op!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (valueInt != null) 'valueInt=$valueInt',
      if (valueFloat != null) 'valueFloat=$valueFloat',
      if (valueDouble != null) 'valueDouble=$valueDouble',
      if (name != null) 'name=$name',
      if (op != null) 'op=$op',
    ].join(',');
    return 'NumericFilter($contents)';
  }
}

/// Datapoints for which Operator is true relative to the querys Value
/// field will be allowlisted.
final class NearestNeighborQuery_NumericFilter_Operator
    extends protobuf.ProtoEnum {
  /// Unspecified operator.
  static const operatorUnspecified =
      NearestNeighborQuery_NumericFilter_Operator('OPERATOR_UNSPECIFIED');

  /// Entities are eligible if their value is < the query's.
  static const less = NearestNeighborQuery_NumericFilter_Operator('LESS');

  /// Entities are eligible if their value is <= the query's.
  static const lessEqual = NearestNeighborQuery_NumericFilter_Operator(
    'LESS_EQUAL',
  );

  /// Entities are eligible if their value is == the query's.
  static const equal = NearestNeighborQuery_NumericFilter_Operator('EQUAL');

  /// Entities are eligible if their value is >= the query's.
  static const greaterEqual = NearestNeighborQuery_NumericFilter_Operator(
    'GREATER_EQUAL',
  );

  /// Entities are eligible if their value is > the query's.
  static const greater = NearestNeighborQuery_NumericFilter_Operator('GREATER');

  /// Entities are eligible if their value is != the query's.
  static const notEqual = NearestNeighborQuery_NumericFilter_Operator(
    'NOT_EQUAL',
  );

  const NearestNeighborQuery_NumericFilter_Operator(super.value);

  factory NearestNeighborQuery_NumericFilter_Operator.fromJson(String json) =>
      NearestNeighborQuery_NumericFilter_Operator(json);

  @override
  String toString() => 'Operator.$value';
}

/// Parameters that can be overrided in each query to tune query latency and
/// recall.
final class NearestNeighborQuery_Parameters extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborQuery.Parameters';

  /// Optional. The number of neighbors to find via approximate search before
  /// exact reordering is performed; if set, this value must be >
  /// neighbor_count.
  final int? approximateNeighborCandidates;

  /// Optional. The fraction of the number of leaves to search, set at query
  /// time allows user to tune search performance. This value increase result
  /// in both search accuracy and latency increase. The value should be between
  /// 0.0 and 1.0.
  final double? leafNodesSearchFraction;

  NearestNeighborQuery_Parameters({
    this.approximateNeighborCandidates,
    this.leafNodesSearchFraction,
  }) : super(fullyQualifiedName);

  factory NearestNeighborQuery_Parameters.fromJson(Map<String, dynamic> json) {
    return NearestNeighborQuery_Parameters(
      approximateNeighborCandidates: json['approximateNeighborCandidates'],
      leafNodesSearchFraction: decodeDouble(json['leafNodesSearchFraction']),
    );
  }

  @override
  Object toJson() {
    return {
      if (approximateNeighborCandidates != null)
        'approximateNeighborCandidates': approximateNeighborCandidates,
      if (leafNodesSearchFraction != null)
        'leafNodesSearchFraction': encodeDouble(leafNodesSearchFraction),
    };
  }

  @override
  String toString() {
    final contents = [
      if (approximateNeighborCandidates != null)
        'approximateNeighborCandidates=$approximateNeighborCandidates',
      if (leafNodesSearchFraction != null)
        'leafNodesSearchFraction=$leafNodesSearchFraction',
    ].join(',');
    return 'Parameters($contents)';
  }
}

/// The request message for
/// `FeatureOnlineStoreService.SearchNearestEntities`.
final class SearchNearestEntitiesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchNearestEntitiesRequest';

  /// Required. FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String featureView;

  /// Required. The query.
  final NearestNeighborQuery? query;

  /// Optional. If set to true, the full entities (including all vector values
  /// and metadata) of the nearest neighbors are returned; otherwise only entity
  /// id of the nearest neighbors will be returned. Note that returning full
  /// entities will significantly increase the latency and cost of the query.
  final bool? returnFullEntity;

  SearchNearestEntitiesRequest({
    required this.featureView,
    this.query,
    this.returnFullEntity,
  }) : super(fullyQualifiedName);

  factory SearchNearestEntitiesRequest.fromJson(Map<String, dynamic> json) {
    return SearchNearestEntitiesRequest(
      featureView: json['featureView'],
      query: decode(json['query'], NearestNeighborQuery.fromJson),
      returnFullEntity: json['returnFullEntity'],
    );
  }

  @override
  Object toJson() {
    return {
      'featureView': featureView,
      if (query != null) 'query': query!.toJson(),
      if (returnFullEntity != null) 'returnFullEntity': returnFullEntity,
    };
  }

  @override
  String toString() {
    final contents = [
      'featureView=$featureView',
      if (returnFullEntity != null) 'returnFullEntity=$returnFullEntity',
    ].join(',');
    return 'SearchNearestEntitiesRequest($contents)';
  }
}

/// Nearest neighbors for one query.
final class NearestNeighbors extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighbors';

  /// All its neighbors.
  final List<NearestNeighbors_Neighbor>? neighbors;

  NearestNeighbors({this.neighbors}) : super(fullyQualifiedName);

  factory NearestNeighbors.fromJson(Map<String, dynamic> json) {
    return NearestNeighbors(
      neighbors: decodeListMessage(
        json['neighbors'],
        NearestNeighbors_Neighbor.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (neighbors != null) 'neighbors': encodeList(neighbors)};
  }

  @override
  String toString() => 'NearestNeighbors()';
}

/// A neighbor of the query vector.
final class NearestNeighbors_Neighbor extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighbors.Neighbor';

  /// The id of the similar entity.
  final String? entityId;

  /// The distance between the neighbor and the query vector.
  final double? distance;

  /// The attributes of the neighbor, e.g. filters, crowding and metadata
  /// Note that full entities are returned only when "return_full_entity"
  /// is set to true. Otherwise, only the "entity_id" and "distance" fields
  /// are populated.
  final FetchFeatureValuesResponse? entityKeyValues;

  NearestNeighbors_Neighbor({
    this.entityId,
    this.distance,
    this.entityKeyValues,
  }) : super(fullyQualifiedName);

  factory NearestNeighbors_Neighbor.fromJson(Map<String, dynamic> json) {
    return NearestNeighbors_Neighbor(
      entityId: json['entityId'],
      distance: decodeDouble(json['distance']),
      entityKeyValues: decode(
        json['entityKeyValues'],
        FetchFeatureValuesResponse.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (entityId != null) 'entityId': entityId,
      if (distance != null) 'distance': encodeDouble(distance),
      if (entityKeyValues != null) 'entityKeyValues': entityKeyValues!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (entityId != null) 'entityId=$entityId',
      if (distance != null) 'distance=$distance',
    ].join(',');
    return 'Neighbor($contents)';
  }
}

/// Response message for
/// `FeatureOnlineStoreService.SearchNearestEntities`
final class SearchNearestEntitiesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchNearestEntitiesResponse';

  /// The nearest neighbors of the query entity.
  final NearestNeighbors? nearestNeighbors;

  SearchNearestEntitiesResponse({this.nearestNeighbors})
    : super(fullyQualifiedName);

  factory SearchNearestEntitiesResponse.fromJson(Map<String, dynamic> json) {
    return SearchNearestEntitiesResponse(
      nearestNeighbors: decode(
        json['nearestNeighbors'],
        NearestNeighbors.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (nearestNeighbors != null)
        'nearestNeighbors': nearestNeighbors!.toJson(),
    };
  }

  @override
  String toString() => 'SearchNearestEntitiesResponse()';
}

/// Request message for
/// `FeatureOnlineStoreService.FeatureViewDirectWrite`.
final class FeatureViewDirectWriteRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteRequest';

  /// FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String? featureView;

  /// Required. The data keys and associated feature values.
  final List<FeatureViewDirectWriteRequest_DataKeyAndFeatureValues>?
  dataKeyAndFeatureValues;

  FeatureViewDirectWriteRequest({
    this.featureView,
    this.dataKeyAndFeatureValues,
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteRequest.fromJson(Map<String, dynamic> json) {
    return FeatureViewDirectWriteRequest(
      featureView: json['featureView'],
      dataKeyAndFeatureValues: decodeListMessage(
        json['dataKeyAndFeatureValues'],
        FeatureViewDirectWriteRequest_DataKeyAndFeatureValues.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureView != null) 'featureView': featureView,
      if (dataKeyAndFeatureValues != null)
        'dataKeyAndFeatureValues': encodeList(dataKeyAndFeatureValues),
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureView != null) 'featureView=$featureView',
    ].join(',');
    return 'FeatureViewDirectWriteRequest($contents)';
  }
}

/// A data key and associated feature values to write to the feature view.
final class FeatureViewDirectWriteRequest_DataKeyAndFeatureValues
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues';

  /// The data key.
  final FeatureViewDataKey? dataKey;

  /// List of features to write.
  final List<FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature>?
  features;

  FeatureViewDirectWriteRequest_DataKeyAndFeatureValues({
    this.dataKey,
    this.features,
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteRequest_DataKeyAndFeatureValues.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureViewDirectWriteRequest_DataKeyAndFeatureValues(
      dataKey: decode(json['dataKey'], FeatureViewDataKey.fromJson),
      features: decodeListMessage(
        json['features'],
        FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataKey != null) 'dataKey': dataKey!.toJson(),
      if (features != null) 'features': encodeList(features),
    };
  }

  @override
  String toString() => 'DataKeyAndFeatureValues()';
}

/// Feature name & value pair.
final class FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues.Feature';

  /// Feature value. A user provided timestamp may be set in the
  /// `FeatureValue.metadata.generate_time` field.
  final FeatureValue? value;

  /// Feature value and timestamp.
  final FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp?
  valueAndTimestamp;

  /// Feature short name.
  final String? name;

  FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature({
    this.value,
    this.valueAndTimestamp,
    this.name,
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature(
      value: decode(json['value'], FeatureValue.fromJson),
      valueAndTimestamp: decode(
        json['valueAndTimestamp'],
        FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp
            .fromJson,
      ),
      name: json['name'],
    );
  }

  @override
  Object toJson() {
    return {
      if (value != null) 'value': value!.toJson(),
      if (valueAndTimestamp != null)
        'valueAndTimestamp': valueAndTimestamp!.toJson(),
      if (name != null) 'name': name,
    };
  }

  @override
  String toString() {
    final contents = [if (name != null) 'name=$name'].join(',');
    return 'Feature($contents)';
  }
}

/// Feature value and timestamp.
final class FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteRequest.DataKeyAndFeatureValues.Feature.FeatureValueAndTimestamp';

  /// The feature value.
  final FeatureValue? value;

  /// The feature timestamp to store with this value.
  /// If not set, then the Feature Store server will generate a timestamp
  /// when it receives the write request.
  final protobuf.Timestamp? timestamp;

  FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp({
    this.value,
    this.timestamp,
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureViewDirectWriteRequest_DataKeyAndFeatureValues_Feature_FeatureValueAndTimestamp(
      value: decode(json['value'], FeatureValue.fromJson),
      timestamp: decodeCustom(json['timestamp'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (value != null) 'value': value!.toJson(),
      if (timestamp != null) 'timestamp': timestamp!.toJson(),
    };
  }

  @override
  String toString() => 'FeatureValueAndTimestamp()';
}

/// Response message for
/// `FeatureOnlineStoreService.FeatureViewDirectWrite`.
final class FeatureViewDirectWriteResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteResponse';

  /// Response status for the keys listed in
  /// `FeatureViewDirectWriteResponse.write_responses`.
  ///
  /// The error only applies to the
  /// listed data keys - the stream will remain open for further
  /// `FeatureOnlineStoreService.FeatureViewDirectWriteRequest` requests.
  ///
  /// Partial failures (e.g. if the first 10 keys of a request fail, but the
  /// rest succeed) from a single request may result in multiple responses -
  /// there will be one response for the successful request keys and one response
  /// for the failing request keys.
  final Status? status;

  /// Details about write for each key. If status is not OK,
  /// `WriteResponse.data_key`
  /// will have the key with error, but
  /// `WriteResponse.online_store_write_time`
  /// will not be present.
  final List<FeatureViewDirectWriteResponse_WriteResponse>? writeResponses;

  FeatureViewDirectWriteResponse({this.status, this.writeResponses})
    : super(fullyQualifiedName);

  factory FeatureViewDirectWriteResponse.fromJson(Map<String, dynamic> json) {
    return FeatureViewDirectWriteResponse(
      status: decode(json['status'], Status.fromJson),
      writeResponses: decodeListMessage(
        json['writeResponses'],
        FeatureViewDirectWriteResponse_WriteResponse.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (status != null) 'status': status!.toJson(),
      if (writeResponses != null) 'writeResponses': encodeList(writeResponses),
    };
  }

  @override
  String toString() => 'FeatureViewDirectWriteResponse()';
}

/// Details about the write for each key.
final class FeatureViewDirectWriteResponse_WriteResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewDirectWriteResponse.WriteResponse';

  /// What key is this write response associated with.
  final FeatureViewDataKey? dataKey;

  /// When the feature values were written to the online store.
  /// If
  /// `FeatureViewDirectWriteResponse.status`
  /// is not OK, this field is not populated.
  final protobuf.Timestamp? onlineStoreWriteTime;

  FeatureViewDirectWriteResponse_WriteResponse({
    this.dataKey,
    this.onlineStoreWriteTime,
  }) : super(fullyQualifiedName);

  factory FeatureViewDirectWriteResponse_WriteResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureViewDirectWriteResponse_WriteResponse(
      dataKey: decode(json['dataKey'], FeatureViewDataKey.fromJson),
      onlineStoreWriteTime: decodeCustom(
        json['onlineStoreWriteTime'],
        protobuf.Timestamp.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataKey != null) 'dataKey': dataKey!.toJson(),
      if (onlineStoreWriteTime != null)
        'onlineStoreWriteTime': onlineStoreWriteTime!.toJson(),
    };
  }

  @override
  String toString() => 'WriteResponse()';
}

/// Request message for `FeatureOnlineStoreService.GenerateFetchAccessToken`.
final class GenerateFetchAccessTokenRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateFetchAccessTokenRequest';

  /// FeatureView resource format
  /// `projects/{project}/locations/{location}/featureOnlineStores/{featureOnlineStore}/featureViews/{featureView}`
  final String featureView;

  GenerateFetchAccessTokenRequest({required this.featureView})
    : super(fullyQualifiedName);

  factory GenerateFetchAccessTokenRequest.fromJson(Map<String, dynamic> json) {
    return GenerateFetchAccessTokenRequest(featureView: json['featureView']);
  }

  @override
  Object toJson() {
    return {'featureView': featureView};
  }

  @override
  String toString() {
    final contents = ['featureView=$featureView'].join(',');
    return 'GenerateFetchAccessTokenRequest($contents)';
  }
}

/// Response message for `FeatureOnlineStoreService.GenerateFetchAccessToken`.
final class GenerateFetchAccessTokenResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateFetchAccessTokenResponse';

  /// The OAuth 2.0 access token.
  final String? accessToken;

  /// Token expiration time. This is always set
  final protobuf.Timestamp? expireTime;

  GenerateFetchAccessTokenResponse({this.accessToken, this.expireTime})
    : super(fullyQualifiedName);

  factory GenerateFetchAccessTokenResponse.fromJson(Map<String, dynamic> json) {
    return GenerateFetchAccessTokenResponse(
      accessToken: json['accessToken'],
      expireTime: decodeCustom(json['expireTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (accessToken != null) 'accessToken': accessToken,
      if (expireTime != null) 'expireTime': expireTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (accessToken != null) 'accessToken=$accessToken',
    ].join(',');
    return 'GenerateFetchAccessTokenResponse($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.CreateFeatureGroup`.
final class CreateFeatureGroupRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureGroupRequest';

  /// Required. The resource name of the Location to create FeatureGroups.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The FeatureGroup to create.
  final FeatureGroup featureGroup;

  /// Required. The ID to use for this FeatureGroup, which will become the final
  /// component of the FeatureGroup's resource name.
  ///
  /// This value may be up to 128 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the project and location.
  final String? featureGroupId;

  CreateFeatureGroupRequest({
    required this.parent,
    required this.featureGroup,
    this.featureGroupId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureGroupRequest.fromJson(Map<String, dynamic> json) {
    return CreateFeatureGroupRequest(
      parent: json['parent'],
      featureGroup: decode(json['featureGroup'], FeatureGroup.fromJson)!,
      featureGroupId: json['featureGroupId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'featureGroup': featureGroup.toJson(),
      if (featureGroupId != null) 'featureGroupId': featureGroupId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (featureGroupId != null) 'featureGroupId=$featureGroupId',
    ].join(',');
    return 'CreateFeatureGroupRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.GetFeatureGroup`.
final class GetFeatureGroupRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureGroupRequest';

  /// Required. The name of the FeatureGroup resource.
  final String name;

  GetFeatureGroupRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureGroupRequest.fromJson(Map<String, dynamic> json) {
    return GetFeatureGroupRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureGroupRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.ListFeatureGroups`.
final class ListFeatureGroupsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureGroupsRequest';

  /// Required. The resource name of the Location to list FeatureGroups.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the FeatureGroups that match the filter expression. The
  /// following fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    FeatureGroups created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    FeatureGroups with label "env" set to "prod".
  final String? filter;

  /// The maximum number of FeatureGroups to return. The service may return
  /// fewer than this value. If unspecified, at most 100 FeatureGroups will
  /// be returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `FeatureGroupAdminService.ListFeatureGroups` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureGroupAdminService.ListFeatureGroups` must
  /// match the call that provided the page token.
  final String? pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  final String? orderBy;

  ListFeatureGroupsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListFeatureGroupsRequest.fromJson(Map<String, dynamic> json) {
    return ListFeatureGroupsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureGroupsRequest($contents)';
  }
}

/// Response message for
/// `FeatureRegistryService.ListFeatureGroups`.
final class ListFeatureGroupsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureGroupsResponse';

  /// The FeatureGroups matching the request.
  final List<FeatureGroup>? featureGroups;

  /// A token, which can be sent as
  /// `ListFeatureGroupsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListFeatureGroupsResponse({this.featureGroups, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListFeatureGroupsResponse.fromJson(Map<String, dynamic> json) {
    return ListFeatureGroupsResponse(
      featureGroups: decodeListMessage(
        json['featureGroups'],
        FeatureGroup.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureGroups != null) 'featureGroups': encodeList(featureGroups),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFeatureGroupsResponse($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.UpdateFeatureGroup`.
final class UpdateFeatureGroupRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureGroupRequest';

  /// Required. The FeatureGroup's `name` field is used to identify the
  /// FeatureGroup to be updated. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final FeatureGroup featureGroup;

  /// Field mask is used to specify the fields to be overwritten in the
  /// FeatureGroup resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `description`
  ///   * `big_query`
  ///   * `big_query.entity_id_columns`
  final protobuf.FieldMask? updateMask;

  UpdateFeatureGroupRequest({required this.featureGroup, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeatureGroupRequest.fromJson(Map<String, dynamic> json) {
    return UpdateFeatureGroupRequest(
      featureGroup: decode(json['featureGroup'], FeatureGroup.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'featureGroup': featureGroup.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureGroupRequest()';
}

/// Request message for
/// `FeatureRegistryService.DeleteFeatureGroup`.
final class DeleteFeatureGroupRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureGroupRequest';

  /// Required. The name of the FeatureGroup to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String name;

  /// If set to true, any Features under this FeatureGroup
  /// will also be deleted. (Otherwise, the request will only work if the
  /// FeatureGroup has no Features.)
  final bool? force;

  DeleteFeatureGroupRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteFeatureGroupRequest.fromJson(Map<String, dynamic> json) {
    return DeleteFeatureGroupRequest(name: json['name'], force: json['force']);
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteFeatureGroupRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.CreateFeatureMonitorRequest`.
final class CreateFeatureMonitorRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureMonitorRequest';

  /// Required. The resource name of FeatureGroup to create FeatureMonitor.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featuregroup}`
  final String parent;

  /// Required. The Monitor to create.
  final FeatureMonitor featureMonitor;

  /// Required. The ID to use for this FeatureMonitor, which will become the
  /// final component of the FeatureGroup's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the FeatureGroup.
  final String? featureMonitorId;

  CreateFeatureMonitorRequest({
    required this.parent,
    required this.featureMonitor,
    this.featureMonitorId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureMonitorRequest.fromJson(Map<String, dynamic> json) {
    return CreateFeatureMonitorRequest(
      parent: json['parent'],
      featureMonitor: decode(json['featureMonitor'], FeatureMonitor.fromJson)!,
      featureMonitorId: json['featureMonitorId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'featureMonitor': featureMonitor.toJson(),
      if (featureMonitorId != null) 'featureMonitorId': featureMonitorId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (featureMonitorId != null) 'featureMonitorId=$featureMonitorId',
    ].join(',');
    return 'CreateFeatureMonitorRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.GetFeatureMonitor`.
final class GetFeatureMonitorRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureMonitorRequest';

  /// Required. The name of the FeatureMonitor resource.
  final String name;

  GetFeatureMonitorRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureMonitorRequest.fromJson(Map<String, dynamic> json) {
    return GetFeatureMonitorRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureMonitorRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.ListFeatureMonitors`.
final class ListFeatureMonitorsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureMonitorsRequest';

  /// Required. The resource name of the FeatureGroup to list FeatureMonitors.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{featureGroup}`
  final String parent;

  /// Optional. Lists the FeatureMonitors that match the filter expression. The
  /// following fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    FeatureMonitors created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    FeatureGroups with label "env" set to "prod".
  final String? filter;

  /// Optional. The maximum number of FeatureGroups to return. The service may
  /// return fewer than this value. If unspecified, at most 100 FeatureMonitors
  /// will be returned. The maximum value is 100; any value greater than 100 will
  /// be coerced to 100.
  final int? pageSize;

  /// Optional. A page token, received from a previous
  /// `FeatureRegistryService.ListFeatureMonitors`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureRegistryService.ListFeatureMonitors`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  final String? orderBy;

  ListFeatureMonitorsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListFeatureMonitorsRequest.fromJson(Map<String, dynamic> json) {
    return ListFeatureMonitorsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureMonitorsRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.UpdateFeatureMonitor`.
final class UpdateFeatureMonitorRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureMonitorRequest';

  /// Required. The FeatureMonitor's `name` field is used to identify the
  /// FeatureMonitor to be updated. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  final FeatureMonitor featureMonitor;

  /// Optional. Field mask is used to specify the fields to be overwritten in the
  /// FeatureMonitor resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  final protobuf.FieldMask? updateMask;

  UpdateFeatureMonitorRequest({required this.featureMonitor, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeatureMonitorRequest.fromJson(Map<String, dynamic> json) {
    return UpdateFeatureMonitorRequest(
      featureMonitor: decode(json['featureMonitor'], FeatureMonitor.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'featureMonitor': featureMonitor.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureMonitorRequest()';
}

/// Request message for
/// `FeatureRegistryService.DeleteFeatureMonitor`.
final class DeleteFeatureMonitorRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureMonitorRequest';

  /// Required. The name of the FeatureMonitor to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  final String name;

  DeleteFeatureMonitorRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteFeatureMonitorRequest.fromJson(Map<String, dynamic> json) {
    return DeleteFeatureMonitorRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteFeatureMonitorRequest($contents)';
  }
}

/// Response message for
/// `FeatureRegistryService.ListFeatureMonitors`.
final class ListFeatureMonitorsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureMonitorsResponse';

  /// The FeatureMonitors matching the request.
  final List<FeatureMonitor>? featureMonitors;

  /// A token, which can be sent as
  /// `ListFeatureMonitorsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListFeatureMonitorsResponse({this.featureMonitors, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListFeatureMonitorsResponse.fromJson(Map<String, dynamic> json) {
    return ListFeatureMonitorsResponse(
      featureMonitors: decodeListMessage(
        json['featureMonitors'],
        FeatureMonitor.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureMonitors != null)
        'featureMonitors': encodeList(featureMonitors),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFeatureMonitorsResponse($contents)';
  }
}

/// Details of operations that perform create FeatureGroup.
final class CreateFeatureGroupOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureGroupOperationMetadata';

  /// Operation metadata for FeatureGroup.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureGroupOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureGroupOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateFeatureGroupOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateFeatureGroupOperationMetadata()';
}

/// Details of operations that perform update FeatureGroup.
final class UpdateFeatureGroupOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureGroupOperationMetadata';

  /// Operation metadata for FeatureGroup.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureGroupOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureGroupOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateFeatureGroupOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureGroupOperationMetadata()';
}

/// Details of operations that perform create FeatureGroup.
final class CreateRegistryFeatureOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateRegistryFeatureOperationMetadata';

  /// Operation metadata for Feature.
  final GenericOperationMetadata? genericMetadata;

  CreateRegistryFeatureOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateRegistryFeatureOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateRegistryFeatureOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateRegistryFeatureOperationMetadata()';
}

/// Details of operations that perform update Feature.
final class UpdateFeatureOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureOperationMetadata';

  /// Operation metadata for Feature Update.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureOperationMetadata.fromJson(Map<String, dynamic> json) {
    return UpdateFeatureOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureOperationMetadata()';
}

/// Details of operations that perform create FeatureMonitor.
final class CreateFeatureMonitorOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureMonitorOperationMetadata';

  /// Operation metadata for Feature.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureMonitorOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureMonitorOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateFeatureMonitorOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateFeatureMonitorOperationMetadata()';
}

/// Details of operations that perform update FeatureMonitor.
final class UpdateFeatureMonitorOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureMonitorOperationMetadata';

  /// Operation metadata for FeatureMonitor.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeatureMonitorOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeatureMonitorOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateFeatureMonitorOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureMonitorOperationMetadata()';
}

/// Request message for
/// `FeatureRegistryService.CreateFeatureMonitorJobRequest`.
final class CreateFeatureMonitorJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureMonitorJobRequest';

  /// Required. The resource name of FeatureMonitor to create FeatureMonitorJob.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  final String parent;

  /// Required. The Monitor to create.
  final FeatureMonitorJob featureMonitorJob;

  /// Optional. Output only. System-generated ID for feature monitor job.
  final int? featureMonitorJobId;

  CreateFeatureMonitorJobRequest({
    required this.parent,
    required this.featureMonitorJob,
    this.featureMonitorJobId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureMonitorJobRequest.fromJson(Map<String, dynamic> json) {
    return CreateFeatureMonitorJobRequest(
      parent: json['parent'],
      featureMonitorJob: decode(
        json['featureMonitorJob'],
        FeatureMonitorJob.fromJson,
      )!,
      featureMonitorJobId: decodeInt64(json['featureMonitorJobId']),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'featureMonitorJob': featureMonitorJob.toJson(),
      if (featureMonitorJobId != null)
        'featureMonitorJobId': encodeInt64(featureMonitorJobId),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (featureMonitorJobId != null)
        'featureMonitorJobId=$featureMonitorJobId',
    ].join(',');
    return 'CreateFeatureMonitorJobRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.GetFeatureMonitorJob`.
final class GetFeatureMonitorJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureMonitorJobRequest';

  /// Required. The name of the FeatureMonitorJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}/featureMonitorJobs/{feature_monitor_job}`
  final String name;

  GetFeatureMonitorJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeatureMonitorJobRequest.fromJson(Map<String, dynamic> json) {
    return GetFeatureMonitorJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureMonitorJobRequest($contents)';
  }
}

/// Request message for
/// `FeatureRegistryService.ListFeatureMonitorJobs`.
final class ListFeatureMonitorJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureMonitorJobsRequest';

  /// Required. The resource name of the FeatureMonitor to list
  /// FeatureMonitorJobs. Format:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/featureMonitors/{feature_monitor}`
  final String parent;

  /// Optional. Lists the FeatureMonitorJobs that match the filter expression.
  /// The following fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01"`
  ///    FeatureMonitorJobs created after 2020-01-01.
  final String? filter;

  /// Optional. The maximum number of FeatureMonitorJobs to return. The service
  /// may return fewer than this value. If unspecified, at most 100
  /// FeatureMonitorJobs will be returned. The maximum value is 100; any value
  /// greater than 100 will be coerced to 100.
  final int? pageSize;

  /// Optional. A page token, received from a previous
  /// `FeatureRegistryService.ListFeatureMonitorJobs`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeatureRegistryService.ListFeatureMonitorJobs`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported Fields:
  ///
  ///   * `create_time`
  final String? orderBy;

  ListFeatureMonitorJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListFeatureMonitorJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListFeatureMonitorJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListFeatureMonitorJobsRequest($contents)';
  }
}

/// Response message for
/// `FeatureRegistryService.ListFeatureMonitorJobs`.
final class ListFeatureMonitorJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeatureMonitorJobsResponse';

  /// The FeatureMonitorJobs matching the request.
  final List<FeatureMonitorJob>? featureMonitorJobs;

  /// A token, which can be sent as
  /// `ListFeatureMonitorJobsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListFeatureMonitorJobsResponse({this.featureMonitorJobs, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListFeatureMonitorJobsResponse.fromJson(Map<String, dynamic> json) {
    return ListFeatureMonitorJobsResponse(
      featureMonitorJobs: decodeListMessage(
        json['featureMonitorJobs'],
        FeatureMonitorJob.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureMonitorJobs != null)
        'featureMonitorJobs': encodeList(featureMonitorJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFeatureMonitorJobsResponse($contents)';
  }
}

/// Matcher for Features of an EntityType by Feature ID.
final class IdMatcher extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IdMatcher';

  /// Required. The following are accepted as `ids`:
  ///
  ///  * A single-element list containing only `*`, which selects all Features
  ///  in the target EntityType, or
  ///  * A list containing only Feature IDs, which selects only Features with
  ///  those IDs in the target EntityType.
  final List<String>? ids;

  IdMatcher({this.ids}) : super(fullyQualifiedName);

  factory IdMatcher.fromJson(Map<String, dynamic> json) {
    return IdMatcher(ids: decodeList(json['ids']));
  }

  @override
  Object toJson() {
    return {if (ids != null) 'ids': ids};
  }

  @override
  String toString() => 'IdMatcher()';
}

/// Selector for Features of an EntityType.
final class FeatureSelector extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureSelector';

  /// Required. Matches Features based on ID.
  final IdMatcher? idMatcher;

  FeatureSelector({this.idMatcher}) : super(fullyQualifiedName);

  factory FeatureSelector.fromJson(Map<String, dynamic> json) {
    return FeatureSelector(
      idMatcher: decode(json['idMatcher'], IdMatcher.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (idMatcher != null) 'idMatcher': idMatcher!.toJson()};
  }

  @override
  String toString() => 'FeatureSelector()';
}

/// FeatureView is representation of values that the FeatureOnlineStore will
/// serve based on its syncConfig.
final class FeatureView extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView';

  /// Optional. Configures how data is supposed to be extracted from a BigQuery
  /// source to be loaded onto the FeatureOnlineStore.
  final FeatureView_BigQuerySource? bigQuerySource;

  /// Optional. Configures the features from a Feature Registry source that
  /// need to be loaded onto the FeatureOnlineStore.
  final FeatureView_FeatureRegistrySource? featureRegistrySource;

  /// Optional. The Vertex RAG Source that the FeatureView is linked to.
  final FeatureView_VertexRagSource? vertexRagSource;

  /// Identifier. Name of the FeatureView. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String? name;

  /// Output only. Timestamp when this FeatureView was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this FeatureView was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// FeatureViews.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one
  /// FeatureOnlineStore(System labels are excluded)." System reserved label keys
  /// are prefixed with "aiplatform.googleapis.com/" and are immutable.
  final Map<String, String>? labels;

  /// Configures when data is to be synced/updated for this FeatureView. At the
  /// end of the sync the latest featureValues for each entityId of this
  /// FeatureView are made ready for online serving.
  final FeatureView_SyncConfig? syncConfig;

  /// Optional. Deprecated: please use
  /// `FeatureView.index_config`
  /// instead.
  final FeatureView_VectorSearchConfig? vectorSearchConfig;

  /// Optional. Configuration for index preparation for vector search. It
  /// contains the required configurations to create an index from source data,
  /// so that approximate nearest neighbor (a.k.a ANN) algorithms search can be
  /// performed during online serving.
  final FeatureView_IndexConfig? indexConfig;

  /// Optional. Configuration for FeatureView created under Optimized
  /// FeatureOnlineStore.
  final FeatureView_OptimizedConfig? optimizedConfig;

  /// Optional. Service agent type used during data sync. By default, the Vertex
  /// AI Service Agent is used. When using an IAM Policy to isolate this
  /// FeatureView within a project, a separate service account should be
  /// provisioned by setting this field to `SERVICE_AGENT_TYPE_FEATURE_VIEW`.
  /// This will generate a separate service account to access the BigQuery source
  /// table.
  final FeatureView_ServiceAgentType? serviceAgentType;

  /// Output only. A Service Account unique to this FeatureView. The role
  /// bigquery.dataViewer should be granted to this service account to allow
  /// Vertex AI Feature Store to sync data to the online store.
  final String? serviceAccountEmail;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  /// Metadata containing information about the Cloud Bigtable.
  final FeatureView_BigtableMetadata? bigtableMetadata;

  FeatureView({
    this.bigQuerySource,
    this.featureRegistrySource,
    this.vertexRagSource,
    this.name,
    this.createTime,
    this.updateTime,
    this.etag,
    this.labels,
    this.syncConfig,
    this.vectorSearchConfig,
    this.indexConfig,
    this.optimizedConfig,
    this.serviceAgentType,
    this.serviceAccountEmail,
    this.satisfiesPzs,
    this.satisfiesPzi,
    this.bigtableMetadata,
  }) : super(fullyQualifiedName);

  factory FeatureView.fromJson(Map<String, dynamic> json) {
    return FeatureView(
      bigQuerySource: decode(
        json['bigQuerySource'],
        FeatureView_BigQuerySource.fromJson,
      ),
      featureRegistrySource: decode(
        json['featureRegistrySource'],
        FeatureView_FeatureRegistrySource.fromJson,
      ),
      vertexRagSource: decode(
        json['vertexRagSource'],
        FeatureView_VertexRagSource.fromJson,
      ),
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      syncConfig: decode(json['syncConfig'], FeatureView_SyncConfig.fromJson),
      vectorSearchConfig: decode(
        json['vectorSearchConfig'],
        FeatureView_VectorSearchConfig.fromJson,
      ),
      indexConfig: decode(
        json['indexConfig'],
        FeatureView_IndexConfig.fromJson,
      ),
      optimizedConfig: decode(
        json['optimizedConfig'],
        FeatureView_OptimizedConfig.fromJson,
      ),
      serviceAgentType: decodeEnum(
        json['serviceAgentType'],
        FeatureView_ServiceAgentType.fromJson,
      ),
      serviceAccountEmail: json['serviceAccountEmail'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
      bigtableMetadata: decode(
        json['bigtableMetadata'],
        FeatureView_BigtableMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (bigQuerySource != null) 'bigQuerySource': bigQuerySource!.toJson(),
      if (featureRegistrySource != null)
        'featureRegistrySource': featureRegistrySource!.toJson(),
      if (vertexRagSource != null) 'vertexRagSource': vertexRagSource!.toJson(),
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (syncConfig != null) 'syncConfig': syncConfig!.toJson(),
      if (vectorSearchConfig != null)
        'vectorSearchConfig': vectorSearchConfig!.toJson(),
      if (indexConfig != null) 'indexConfig': indexConfig!.toJson(),
      if (optimizedConfig != null) 'optimizedConfig': optimizedConfig!.toJson(),
      if (serviceAgentType != null)
        'serviceAgentType': serviceAgentType!.toJson(),
      if (serviceAccountEmail != null)
        'serviceAccountEmail': serviceAccountEmail,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
      if (bigtableMetadata != null)
        'bigtableMetadata': bigtableMetadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (etag != null) 'etag=$etag',
      if (serviceAgentType != null) 'serviceAgentType=$serviceAgentType',
      if (serviceAccountEmail != null)
        'serviceAccountEmail=$serviceAccountEmail',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'FeatureView($contents)';
  }
}

final class FeatureView_BigQuerySource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.BigQuerySource';

  /// Required. The BigQuery view URI that will be materialized on each sync
  /// trigger based on FeatureView.SyncConfig.
  final String? uri;

  /// Required. Columns to construct entity_id / row keys.
  final List<String>? entityIdColumns;

  FeatureView_BigQuerySource({this.uri, this.entityIdColumns})
    : super(fullyQualifiedName);

  factory FeatureView_BigQuerySource.fromJson(Map<String, dynamic> json) {
    return FeatureView_BigQuerySource(
      uri: json['uri'],
      entityIdColumns: decodeList(json['entityIdColumns']),
    );
  }

  @override
  Object toJson() {
    return {
      if (uri != null) 'uri': uri,
      if (entityIdColumns != null) 'entityIdColumns': entityIdColumns,
    };
  }

  @override
  String toString() {
    final contents = [if (uri != null) 'uri=$uri'].join(',');
    return 'BigQuerySource($contents)';
  }
}

/// Configuration for Sync. Only one option is set.
final class FeatureView_SyncConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.SyncConfig';

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs. To explicitly set a timezone to the cron tab, apply a prefix in
  /// the cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
  /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
  /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
  /// "TZ=America/New_York 1 * * * *".
  final String? cron;

  FeatureView_SyncConfig({this.cron}) : super(fullyQualifiedName);

  factory FeatureView_SyncConfig.fromJson(Map<String, dynamic> json) {
    return FeatureView_SyncConfig(cron: json['cron']);
  }

  @override
  Object toJson() {
    return {if (cron != null) 'cron': cron};
  }

  @override
  String toString() {
    final contents = [if (cron != null) 'cron=$cron'].join(',');
    return 'SyncConfig($contents)';
  }
}

/// Deprecated. Use
/// `IndexConfig`
/// instead.
final class FeatureView_VectorSearchConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.VectorSearchConfig';

  /// Optional. Configuration options for the tree-AH algorithm (Shallow tree
  /// + Asymmetric Hashing). Please refer to this paper for more details:
  /// https://arxiv.org/abs/1908.10396
  final FeatureView_VectorSearchConfig_TreeAhconfig? treeAhConfig;

  /// Optional. Configuration options for using brute force search, which
  /// simply implements the standard linear search in the database for each
  /// query. It is primarily meant for benchmarking and to generate the
  /// ground truth for approximate search.
  final FeatureView_VectorSearchConfig_BruteForceConfig? bruteForceConfig;

  /// Optional. Column of embedding. This column contains the source data to
  /// create index for vector search. embedding_column must be set when using
  /// vector search.
  final String? embeddingColumn;

  /// Optional. Columns of features that're used to filter vector search
  /// results.
  final List<String>? filterColumns;

  /// Optional. Column of crowding. This column contains crowding attribute
  /// which is a constraint on a neighbor list produced by
  /// `FeatureOnlineStoreService.SearchNearestEntities`
  /// to diversify search results. If
  /// `NearestNeighborQuery.per_crowding_attribute_neighbor_count`
  /// is set to K in
  /// `SearchNearestEntitiesRequest`,
  /// it's guaranteed that no more than K entities of the same crowding
  /// attribute are returned in the response.
  final String? crowdingColumn;

  /// Optional. The number of dimensions of the input embedding.
  final int? embeddingDimension;

  /// Optional. The distance measure used in nearest neighbor search.
  final FeatureView_VectorSearchConfig_DistanceMeasureType? distanceMeasureType;

  FeatureView_VectorSearchConfig({
    this.treeAhConfig,
    this.bruteForceConfig,
    this.embeddingColumn,
    this.filterColumns,
    this.crowdingColumn,
    this.embeddingDimension,
    this.distanceMeasureType,
  }) : super(fullyQualifiedName);

  factory FeatureView_VectorSearchConfig.fromJson(Map<String, dynamic> json) {
    return FeatureView_VectorSearchConfig(
      treeAhConfig: decode(
        json['treeAhConfig'],
        FeatureView_VectorSearchConfig_TreeAhconfig.fromJson,
      ),
      bruteForceConfig: decode(
        json['bruteForceConfig'],
        FeatureView_VectorSearchConfig_BruteForceConfig.fromJson,
      ),
      embeddingColumn: json['embeddingColumn'],
      filterColumns: decodeList(json['filterColumns']),
      crowdingColumn: json['crowdingColumn'],
      embeddingDimension: json['embeddingDimension'],
      distanceMeasureType: decodeEnum(
        json['distanceMeasureType'],
        FeatureView_VectorSearchConfig_DistanceMeasureType.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (treeAhConfig != null) 'treeAhConfig': treeAhConfig!.toJson(),
      if (bruteForceConfig != null)
        'bruteForceConfig': bruteForceConfig!.toJson(),
      if (embeddingColumn != null) 'embeddingColumn': embeddingColumn,
      if (filterColumns != null) 'filterColumns': filterColumns,
      if (crowdingColumn != null) 'crowdingColumn': crowdingColumn,
      if (embeddingDimension != null) 'embeddingDimension': embeddingDimension,
      if (distanceMeasureType != null)
        'distanceMeasureType': distanceMeasureType!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (embeddingColumn != null) 'embeddingColumn=$embeddingColumn',
      if (crowdingColumn != null) 'crowdingColumn=$crowdingColumn',
      if (embeddingDimension != null) 'embeddingDimension=$embeddingDimension',
      if (distanceMeasureType != null)
        'distanceMeasureType=$distanceMeasureType',
    ].join(',');
    return 'VectorSearchConfig($contents)';
  }
}

final class FeatureView_VectorSearchConfig_BruteForceConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.VectorSearchConfig.BruteForceConfig';

  FeatureView_VectorSearchConfig_BruteForceConfig() : super(fullyQualifiedName);

  factory FeatureView_VectorSearchConfig_BruteForceConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureView_VectorSearchConfig_BruteForceConfig();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'BruteForceConfig()';
}

final class FeatureView_VectorSearchConfig_TreeAhconfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.VectorSearchConfig.TreeAHConfig';

  /// Optional. Number of embeddings on each leaf node. The default value is
  /// 1000 if not set.
  final int? leafNodeEmbeddingCount;

  FeatureView_VectorSearchConfig_TreeAhconfig({this.leafNodeEmbeddingCount})
    : super(fullyQualifiedName);

  factory FeatureView_VectorSearchConfig_TreeAhconfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureView_VectorSearchConfig_TreeAhconfig(
      leafNodeEmbeddingCount: decodeInt64(json['leafNodeEmbeddingCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (leafNodeEmbeddingCount != null)
        'leafNodeEmbeddingCount': encodeInt64(leafNodeEmbeddingCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (leafNodeEmbeddingCount != null)
        'leafNodeEmbeddingCount=$leafNodeEmbeddingCount',
    ].join(',');
    return 'TreeAHConfig($contents)';
  }
}

final class FeatureView_VectorSearchConfig_DistanceMeasureType
    extends protobuf.ProtoEnum {
  /// Should not be set.
  static const distanceMeasureTypeUnspecified =
      FeatureView_VectorSearchConfig_DistanceMeasureType(
        'DISTANCE_MEASURE_TYPE_UNSPECIFIED',
      );

  /// Euclidean (L_2) Distance.
  static const squaredL2Distance =
      FeatureView_VectorSearchConfig_DistanceMeasureType('SQUARED_L2_DISTANCE');

  /// Cosine Distance. Defined as 1 - cosine similarity.
  ///
  /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead
  /// of COSINE distance. Our algorithms have been more optimized for
  /// DOT_PRODUCT distance which, when combined with UNIT_L2_NORM, is
  /// mathematically equivalent to COSINE distance and results in the same
  /// ranking.
  static const cosineDistance =
      FeatureView_VectorSearchConfig_DistanceMeasureType('COSINE_DISTANCE');

  /// Dot Product Distance. Defined as a negative of the dot product.
  static const dotProductDistance =
      FeatureView_VectorSearchConfig_DistanceMeasureType(
        'DOT_PRODUCT_DISTANCE',
      );

  const FeatureView_VectorSearchConfig_DistanceMeasureType(super.value);

  factory FeatureView_VectorSearchConfig_DistanceMeasureType.fromJson(
    String json,
  ) => FeatureView_VectorSearchConfig_DistanceMeasureType(json);

  @override
  String toString() => 'DistanceMeasureType.$value';
}

/// Configuration for vector indexing.
final class FeatureView_IndexConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.IndexConfig';

  /// Optional. Configuration options for the tree-AH algorithm (Shallow tree
  /// + Asymmetric Hashing). Please refer to this paper for more details:
  /// https://arxiv.org/abs/1908.10396
  final FeatureView_IndexConfig_TreeAhconfig? treeAhConfig;

  /// Optional. Configuration options for using brute force search, which
  /// simply implements the standard linear search in the database for each
  /// query. It is primarily meant for benchmarking and to generate the
  /// ground truth for approximate search.
  final FeatureView_IndexConfig_BruteForceConfig? bruteForceConfig;

  /// Optional. Column of embedding. This column contains the source data to
  /// create index for vector search. embedding_column must be set when using
  /// vector search.
  final String? embeddingColumn;

  /// Optional. Columns of features that're used to filter vector search
  /// results.
  final List<String>? filterColumns;

  /// Optional. Column of crowding. This column contains crowding attribute
  /// which is a constraint on a neighbor list produced by
  /// `FeatureOnlineStoreService.SearchNearestEntities`
  /// to diversify search results. If
  /// `NearestNeighborQuery.per_crowding_attribute_neighbor_count`
  /// is set to K in
  /// `SearchNearestEntitiesRequest`,
  /// it's guaranteed that no more than K entities of the same crowding
  /// attribute are returned in the response.
  final String? crowdingColumn;

  /// Optional. The number of dimensions of the input embedding.
  final int? embeddingDimension;

  /// Optional. The distance measure used in nearest neighbor search.
  final FeatureView_IndexConfig_DistanceMeasureType? distanceMeasureType;

  FeatureView_IndexConfig({
    this.treeAhConfig,
    this.bruteForceConfig,
    this.embeddingColumn,
    this.filterColumns,
    this.crowdingColumn,
    this.embeddingDimension,
    this.distanceMeasureType,
  }) : super(fullyQualifiedName);

  factory FeatureView_IndexConfig.fromJson(Map<String, dynamic> json) {
    return FeatureView_IndexConfig(
      treeAhConfig: decode(
        json['treeAhConfig'],
        FeatureView_IndexConfig_TreeAhconfig.fromJson,
      ),
      bruteForceConfig: decode(
        json['bruteForceConfig'],
        FeatureView_IndexConfig_BruteForceConfig.fromJson,
      ),
      embeddingColumn: json['embeddingColumn'],
      filterColumns: decodeList(json['filterColumns']),
      crowdingColumn: json['crowdingColumn'],
      embeddingDimension: json['embeddingDimension'],
      distanceMeasureType: decodeEnum(
        json['distanceMeasureType'],
        FeatureView_IndexConfig_DistanceMeasureType.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (treeAhConfig != null) 'treeAhConfig': treeAhConfig!.toJson(),
      if (bruteForceConfig != null)
        'bruteForceConfig': bruteForceConfig!.toJson(),
      if (embeddingColumn != null) 'embeddingColumn': embeddingColumn,
      if (filterColumns != null) 'filterColumns': filterColumns,
      if (crowdingColumn != null) 'crowdingColumn': crowdingColumn,
      if (embeddingDimension != null) 'embeddingDimension': embeddingDimension,
      if (distanceMeasureType != null)
        'distanceMeasureType': distanceMeasureType!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (embeddingColumn != null) 'embeddingColumn=$embeddingColumn',
      if (crowdingColumn != null) 'crowdingColumn=$crowdingColumn',
      if (embeddingDimension != null) 'embeddingDimension=$embeddingDimension',
      if (distanceMeasureType != null)
        'distanceMeasureType=$distanceMeasureType',
    ].join(',');
    return 'IndexConfig($contents)';
  }
}

/// Configuration options for using brute force search.
final class FeatureView_IndexConfig_BruteForceConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.IndexConfig.BruteForceConfig';

  FeatureView_IndexConfig_BruteForceConfig() : super(fullyQualifiedName);

  factory FeatureView_IndexConfig_BruteForceConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureView_IndexConfig_BruteForceConfig();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'BruteForceConfig()';
}

/// Configuration options for the tree-AH algorithm.
final class FeatureView_IndexConfig_TreeAhconfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.IndexConfig.TreeAHConfig';

  /// Optional. Number of embeddings on each leaf node. The default value is
  /// 1000 if not set.
  final int? leafNodeEmbeddingCount;

  FeatureView_IndexConfig_TreeAhconfig({this.leafNodeEmbeddingCount})
    : super(fullyQualifiedName);

  factory FeatureView_IndexConfig_TreeAhconfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureView_IndexConfig_TreeAhconfig(
      leafNodeEmbeddingCount: decodeInt64(json['leafNodeEmbeddingCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (leafNodeEmbeddingCount != null)
        'leafNodeEmbeddingCount': encodeInt64(leafNodeEmbeddingCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (leafNodeEmbeddingCount != null)
        'leafNodeEmbeddingCount=$leafNodeEmbeddingCount',
    ].join(',');
    return 'TreeAHConfig($contents)';
  }
}

/// The distance measure used in nearest neighbor search.
final class FeatureView_IndexConfig_DistanceMeasureType
    extends protobuf.ProtoEnum {
  /// Should not be set.
  static const distanceMeasureTypeUnspecified =
      FeatureView_IndexConfig_DistanceMeasureType(
        'DISTANCE_MEASURE_TYPE_UNSPECIFIED',
      );

  /// Euclidean (L_2) Distance.
  static const squaredL2Distance = FeatureView_IndexConfig_DistanceMeasureType(
    'SQUARED_L2_DISTANCE',
  );

  /// Cosine Distance. Defined as 1 - cosine similarity.
  ///
  /// We strongly suggest using DOT_PRODUCT_DISTANCE + UNIT_L2_NORM instead
  /// of COSINE distance. Our algorithms have been more optimized for
  /// DOT_PRODUCT distance which, when combined with UNIT_L2_NORM, is
  /// mathematically equivalent to COSINE distance and results in the same
  /// ranking.
  static const cosineDistance = FeatureView_IndexConfig_DistanceMeasureType(
    'COSINE_DISTANCE',
  );

  /// Dot Product Distance. Defined as a negative of the dot product.
  static const dotProductDistance = FeatureView_IndexConfig_DistanceMeasureType(
    'DOT_PRODUCT_DISTANCE',
  );

  const FeatureView_IndexConfig_DistanceMeasureType(super.value);

  factory FeatureView_IndexConfig_DistanceMeasureType.fromJson(String json) =>
      FeatureView_IndexConfig_DistanceMeasureType(json);

  @override
  String toString() => 'DistanceMeasureType.$value';
}

/// A Feature Registry source for features that need to be synced to Online
/// Store.
final class FeatureView_FeatureRegistrySource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.FeatureRegistrySource';

  /// Required. List of features that need to be synced to Online Store.
  final List<FeatureView_FeatureRegistrySource_FeatureGroup>? featureGroups;

  /// Optional. The project number of the parent project of the Feature Groups.
  final int? projectNumber;

  FeatureView_FeatureRegistrySource({this.featureGroups, this.projectNumber})
    : super(fullyQualifiedName);

  factory FeatureView_FeatureRegistrySource.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureView_FeatureRegistrySource(
      featureGroups: decodeListMessage(
        json['featureGroups'],
        FeatureView_FeatureRegistrySource_FeatureGroup.fromJson,
      ),
      projectNumber: decodeInt64(json['projectNumber']),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureGroups != null) 'featureGroups': encodeList(featureGroups),
      if (projectNumber != null) 'projectNumber': encodeInt64(projectNumber),
    };
  }

  @override
  String toString() {
    final contents = [
      if (projectNumber != null) 'projectNumber=$projectNumber',
    ].join(',');
    return 'FeatureRegistrySource($contents)';
  }
}

/// Features belonging to a single feature group that will be
/// synced to Online Store.
final class FeatureView_FeatureRegistrySource_FeatureGroup
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.FeatureRegistrySource.FeatureGroup';

  /// Required. Identifier of the feature group.
  final String? featureGroupId;

  /// Required. Identifiers of features under the feature group.
  final List<String>? featureIds;

  FeatureView_FeatureRegistrySource_FeatureGroup({
    this.featureGroupId,
    this.featureIds,
  }) : super(fullyQualifiedName);

  factory FeatureView_FeatureRegistrySource_FeatureGroup.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeatureView_FeatureRegistrySource_FeatureGroup(
      featureGroupId: json['featureGroupId'],
      featureIds: decodeList(json['featureIds']),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureGroupId != null) 'featureGroupId': featureGroupId,
      if (featureIds != null) 'featureIds': featureIds,
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureGroupId != null) 'featureGroupId=$featureGroupId',
    ].join(',');
    return 'FeatureGroup($contents)';
  }
}

/// A Vertex Rag source for features that need to be synced to Online
/// Store.
final class FeatureView_VertexRagSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.VertexRagSource';

  /// Required. The BigQuery view/table URI that will be materialized on each
  /// manual sync trigger. The table/view is expected to have the following
  /// columns and types at least:
  ///  - `corpus_id` (STRING, NULLABLE/REQUIRED)
  ///  - `file_id` (STRING, NULLABLE/REQUIRED)
  ///  - `chunk_id` (STRING, NULLABLE/REQUIRED)
  ///  - `chunk_data_type` (STRING, NULLABLE/REQUIRED)
  ///  - `chunk_data` (STRING, NULLABLE/REQUIRED)
  ///  - `embeddings` (FLOAT, REPEATED)
  ///  - `file_original_uri` (STRING, NULLABLE/REQUIRED)
  final String? uri;

  /// Optional. The RAG corpus id corresponding to this FeatureView.
  final int? ragCorpusId;

  FeatureView_VertexRagSource({this.uri, this.ragCorpusId})
    : super(fullyQualifiedName);

  factory FeatureView_VertexRagSource.fromJson(Map<String, dynamic> json) {
    return FeatureView_VertexRagSource(
      uri: json['uri'],
      ragCorpusId: decodeInt64(json['ragCorpusId']),
    );
  }

  @override
  Object toJson() {
    return {
      if (uri != null) 'uri': uri,
      if (ragCorpusId != null) 'ragCorpusId': encodeInt64(ragCorpusId),
    };
  }

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (ragCorpusId != null) 'ragCorpusId=$ragCorpusId',
    ].join(',');
    return 'VertexRagSource($contents)';
  }
}

/// Configuration for FeatureViews created in Optimized FeatureOnlineStore.
final class FeatureView_OptimizedConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.OptimizedConfig';

  /// Optional. A description of resources that the FeatureView uses, which to
  /// large degree are decided by Vertex AI, and optionally allows only a
  /// modest additional configuration. If min_replica_count is not set, the
  /// default value is 2. If max_replica_count is not set, the default value
  /// is 6. The max allowed replica count is 1000.
  final AutomaticResources? automaticResources;

  FeatureView_OptimizedConfig({this.automaticResources})
    : super(fullyQualifiedName);

  factory FeatureView_OptimizedConfig.fromJson(Map<String, dynamic> json) {
    return FeatureView_OptimizedConfig(
      automaticResources: decode(
        json['automaticResources'],
        AutomaticResources.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (automaticResources != null)
        'automaticResources': automaticResources!.toJson(),
    };
  }

  @override
  String toString() => 'OptimizedConfig()';
}

/// Metadata for the Cloud Bigtable that supports directly interacting Bigtable
/// instances.
final class FeatureView_BigtableMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureView.BigtableMetadata';

  /// The Bigtable App Profile to use for reading from Bigtable.
  final String? readAppProfile;

  FeatureView_BigtableMetadata({this.readAppProfile})
    : super(fullyQualifiedName);

  factory FeatureView_BigtableMetadata.fromJson(Map<String, dynamic> json) {
    return FeatureView_BigtableMetadata(readAppProfile: json['readAppProfile']);
  }

  @override
  Object toJson() {
    return {if (readAppProfile != null) 'readAppProfile': readAppProfile};
  }

  @override
  String toString() {
    final contents = [
      if (readAppProfile != null) 'readAppProfile=$readAppProfile',
    ].join(',');
    return 'BigtableMetadata($contents)';
  }
}

/// Service agent type used during data sync.
final class FeatureView_ServiceAgentType extends protobuf.ProtoEnum {
  /// By default, the project-level Vertex AI Service Agent is enabled.
  static const serviceAgentTypeUnspecified = FeatureView_ServiceAgentType(
    'SERVICE_AGENT_TYPE_UNSPECIFIED',
  );

  /// Indicates the project-level Vertex AI Service Agent
  /// (https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used during sync jobs.
  static const serviceAgentTypeProject = FeatureView_ServiceAgentType(
    'SERVICE_AGENT_TYPE_PROJECT',
  );

  /// Enable a FeatureView service account to be created by Vertex AI and
  /// output in the field `service_account_email`. This service account will
  /// be used to read from the source BigQuery table during sync.
  static const serviceAgentTypeFeatureView = FeatureView_ServiceAgentType(
    'SERVICE_AGENT_TYPE_FEATURE_VIEW',
  );

  const FeatureView_ServiceAgentType(super.value);

  factory FeatureView_ServiceAgentType.fromJson(String json) =>
      FeatureView_ServiceAgentType(json);

  @override
  String toString() => 'ServiceAgentType.$value';
}

/// FeatureViewSync is a representation of sync operation which copies data from
/// data source to Feature View in Online Store.
final class FeatureViewSync extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewSync';

  /// Identifier. Name of the FeatureViewSync. Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}/featureViewSyncs/{feature_view_sync}`
  final String? name;

  /// Output only. Time when this FeatureViewSync is created. Creation of a
  /// FeatureViewSync means that the job is pending / waiting for sufficient
  /// resources but may not have started the actual data transfer yet.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when this FeatureViewSync is finished.
  final Interval? runTime;

  /// Output only. Final status of the FeatureViewSync.
  final Status? finalStatus;

  /// Output only. Summary of the sync job.
  final FeatureViewSync_SyncSummary? syncSummary;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  FeatureViewSync({
    this.name,
    this.createTime,
    this.runTime,
    this.finalStatus,
    this.syncSummary,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory FeatureViewSync.fromJson(Map<String, dynamic> json) {
    return FeatureViewSync(
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      runTime: decode(json['runTime'], Interval.fromJson),
      finalStatus: decode(json['finalStatus'], Status.fromJson),
      syncSummary: decode(
        json['syncSummary'],
        FeatureViewSync_SyncSummary.fromJson,
      ),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (runTime != null) 'runTime': runTime!.toJson(),
      if (finalStatus != null) 'finalStatus': finalStatus!.toJson(),
      if (syncSummary != null) 'syncSummary': syncSummary!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'FeatureViewSync($contents)';
  }
}

/// Summary from the Sync job. For continuous syncs, the summary is updated
/// periodically. For batch syncs, it gets updated on completion of the sync.
final class FeatureViewSync_SyncSummary extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureViewSync.SyncSummary';

  /// Output only. Total number of rows synced.
  final int? rowSynced;

  /// Output only. BigQuery slot milliseconds consumed for the sync job.
  final int? totalSlot;

  /// Lower bound of the system time watermark for the sync job. This is only
  /// set for continuously syncing feature views.
  final protobuf.Timestamp? systemWatermarkTime;

  FeatureViewSync_SyncSummary({
    this.rowSynced,
    this.totalSlot,
    this.systemWatermarkTime,
  }) : super(fullyQualifiedName);

  factory FeatureViewSync_SyncSummary.fromJson(Map<String, dynamic> json) {
    return FeatureViewSync_SyncSummary(
      rowSynced: decodeInt64(json['rowSynced']),
      totalSlot: decodeInt64(json['totalSlot']),
      systemWatermarkTime: decodeCustom(
        json['systemWatermarkTime'],
        protobuf.Timestamp.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (rowSynced != null) 'rowSynced': encodeInt64(rowSynced),
      if (totalSlot != null) 'totalSlot': encodeInt64(totalSlot),
      if (systemWatermarkTime != null)
        'systemWatermarkTime': systemWatermarkTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (rowSynced != null) 'rowSynced=$rowSynced',
      if (totalSlot != null) 'totalSlot=$totalSlot',
    ].join(',');
    return 'SyncSummary($contents)';
  }
}

/// Vertex AI Feature Store provides a centralized repository for organizing,
/// storing, and serving ML features. The Featurestore is a top-level container
/// for your features and their values.
final class Featurestore extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Featurestore';

  /// Output only. Name of the Featurestore. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String? name;

  /// Output only. Timestamp when this Featurestore was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Featurestore was last updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Optional. The labels with user-defined metadata to organize your
  /// Featurestore.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information on and examples of labels.
  /// No more than 64 user labels can be associated with one Featurestore(System
  /// labels are excluded)."
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? labels;

  /// Optional. Config for online storage resources. The field should not
  /// co-exist with the field of `OnlineStoreReplicationConfig`. If both of it
  /// and OnlineStoreReplicationConfig are unset, the feature store will not have
  /// an online store and cannot be used for online serving.
  final Featurestore_OnlineServingConfig? onlineServingConfig;

  /// Output only. State of the featurestore.
  final Featurestore_State? state;

  /// Optional. TTL in days for feature values that will be stored in online
  /// serving storage. The Feature Store online storage periodically removes
  /// obsolete feature values older than `online_storage_ttl_days` since the
  /// feature generation time. Note that `online_storage_ttl_days` should be less
  /// than or equal to `offline_storage_ttl_days` for each EntityType under a
  /// featurestore. If not set, default to 4000 days
  final int? onlineStorageTtlDays;

  /// Optional. Customer-managed encryption key spec for data storage. If set,
  /// both of the online and offline data storage will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  Featurestore({
    this.name,
    this.createTime,
    this.updateTime,
    this.etag,
    this.labels,
    this.onlineServingConfig,
    this.state,
    this.onlineStorageTtlDays,
    this.encryptionSpec,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory Featurestore.fromJson(Map<String, dynamic> json) {
    return Featurestore(
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      onlineServingConfig: decode(
        json['onlineServingConfig'],
        Featurestore_OnlineServingConfig.fromJson,
      ),
      state: decodeEnum(json['state'], Featurestore_State.fromJson),
      onlineStorageTtlDays: json['onlineStorageTtlDays'],
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (onlineServingConfig != null)
        'onlineServingConfig': onlineServingConfig!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (onlineStorageTtlDays != null)
        'onlineStorageTtlDays': onlineStorageTtlDays,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (etag != null) 'etag=$etag',
      if (state != null) 'state=$state',
      if (onlineStorageTtlDays != null)
        'onlineStorageTtlDays=$onlineStorageTtlDays',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Featurestore($contents)';
  }
}

/// OnlineServingConfig specifies the details for provisioning online serving
/// resources.
final class Featurestore_OnlineServingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Featurestore.OnlineServingConfig';

  /// The number of nodes for the online store. The number of nodes doesn't
  /// scale automatically, but you can manually update the number of
  /// nodes. If set to 0, the featurestore will not have an
  /// online store and cannot be used for online serving.
  final int? fixedNodeCount;

  /// Online serving scaling configuration.
  /// Only one of `fixed_node_count` and `scaling` can be set. Setting one will
  /// reset the other.
  final Featurestore_OnlineServingConfig_Scaling? scaling;

  Featurestore_OnlineServingConfig({this.fixedNodeCount, this.scaling})
    : super(fullyQualifiedName);

  factory Featurestore_OnlineServingConfig.fromJson(Map<String, dynamic> json) {
    return Featurestore_OnlineServingConfig(
      fixedNodeCount: json['fixedNodeCount'],
      scaling: decode(
        json['scaling'],
        Featurestore_OnlineServingConfig_Scaling.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (fixedNodeCount != null) 'fixedNodeCount': fixedNodeCount,
      if (scaling != null) 'scaling': scaling!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (fixedNodeCount != null) 'fixedNodeCount=$fixedNodeCount',
    ].join(',');
    return 'OnlineServingConfig($contents)';
  }
}

/// Online serving scaling configuration. If min_node_count and
/// max_node_count are set to the same value, the cluster will be configured
/// with the fixed number of node (no auto-scaling).
final class Featurestore_OnlineServingConfig_Scaling
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Featurestore.OnlineServingConfig.Scaling';

  /// Required. The minimum number of nodes to scale down to. Must be greater
  /// than or equal to 1.
  final int? minNodeCount;

  /// The maximum number of nodes to scale up to. Must be greater than
  /// min_node_count, and less than or equal to 10 times of 'min_node_count'.
  final int? maxNodeCount;

  /// Optional. The cpu utilization that the Autoscaler should be trying to
  /// achieve. This number is on a scale from 0 (no utilization) to 100
  /// (total utilization), and is limited between 10 and 80. When a cluster's
  /// CPU utilization exceeds the target that you have set, Bigtable
  /// immediately adds nodes to the cluster. When CPU utilization is
  /// substantially lower than the target, Bigtable removes nodes. If not set
  /// or set to 0, default to 50.
  final int? cpuUtilizationTarget;

  Featurestore_OnlineServingConfig_Scaling({
    this.minNodeCount,
    this.maxNodeCount,
    this.cpuUtilizationTarget,
  }) : super(fullyQualifiedName);

  factory Featurestore_OnlineServingConfig_Scaling.fromJson(
    Map<String, dynamic> json,
  ) {
    return Featurestore_OnlineServingConfig_Scaling(
      minNodeCount: json['minNodeCount'],
      maxNodeCount: json['maxNodeCount'],
      cpuUtilizationTarget: json['cpuUtilizationTarget'],
    );
  }

  @override
  Object toJson() {
    return {
      if (minNodeCount != null) 'minNodeCount': minNodeCount,
      if (maxNodeCount != null) 'maxNodeCount': maxNodeCount,
      if (cpuUtilizationTarget != null)
        'cpuUtilizationTarget': cpuUtilizationTarget,
    };
  }

  @override
  String toString() {
    final contents = [
      if (minNodeCount != null) 'minNodeCount=$minNodeCount',
      if (maxNodeCount != null) 'maxNodeCount=$maxNodeCount',
      if (cpuUtilizationTarget != null)
        'cpuUtilizationTarget=$cpuUtilizationTarget',
    ].join(',');
    return 'Scaling($contents)';
  }
}

/// Possible states a featurestore can have.
final class Featurestore_State extends protobuf.ProtoEnum {
  /// Default value. This value is unused.
  static const stateUnspecified = Featurestore_State('STATE_UNSPECIFIED');

  /// State when the featurestore configuration is not being updated and the
  /// fields reflect the current configuration of the featurestore. The
  /// featurestore is usable in this state.
  static const stable = Featurestore_State('STABLE');

  /// The state of the featurestore configuration when it is being updated.
  /// During an update, the fields reflect either the original configuration
  /// or the updated configuration of the featurestore. For example,
  /// `online_serving_config.fixed_node_count` can take minutes to update.
  /// While the update is in progress, the featurestore is in the UPDATING
  /// state, and the value of `fixed_node_count` can be the original value or
  /// the updated value, depending on the progress of the operation. Until the
  /// update completes, the actual number of nodes can still be the original
  /// value of `fixed_node_count`. The featurestore is still usable in this
  /// state.
  static const updating = Featurestore_State('UPDATING');

  const Featurestore_State(super.value);

  factory Featurestore_State.fromJson(String json) => Featurestore_State(json);

  @override
  String toString() => 'State.$value';
}

/// Configuration of how features in Featurestore are monitored.
final class FeaturestoreMonitoringConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeaturestoreMonitoringConfig';

  /// The config for Snapshot Analysis Based Feature Monitoring.
  final FeaturestoreMonitoringConfig_SnapshotAnalysis? snapshotAnalysis;

  /// The config for ImportFeatures Analysis Based Feature Monitoring.
  final FeaturestoreMonitoringConfig_ImportFeaturesAnalysis?
  importFeaturesAnalysis;

  /// Threshold for numerical features of anomaly detection.
  /// This is shared by all objectives of Featurestore Monitoring for numerical
  /// features (i.e. Features with type
  /// (`Feature.ValueType`)
  /// DOUBLE or INT64).
  final FeaturestoreMonitoringConfig_ThresholdConfig? numericalThresholdConfig;

  /// Threshold for categorical features of anomaly detection.
  /// This is shared by all types of Featurestore Monitoring for categorical
  /// features (i.e. Features with type
  /// (`Feature.ValueType`)
  /// BOOL or STRING).
  final FeaturestoreMonitoringConfig_ThresholdConfig?
  categoricalThresholdConfig;

  FeaturestoreMonitoringConfig({
    this.snapshotAnalysis,
    this.importFeaturesAnalysis,
    this.numericalThresholdConfig,
    this.categoricalThresholdConfig,
  }) : super(fullyQualifiedName);

  factory FeaturestoreMonitoringConfig.fromJson(Map<String, dynamic> json) {
    return FeaturestoreMonitoringConfig(
      snapshotAnalysis: decode(
        json['snapshotAnalysis'],
        FeaturestoreMonitoringConfig_SnapshotAnalysis.fromJson,
      ),
      importFeaturesAnalysis: decode(
        json['importFeaturesAnalysis'],
        FeaturestoreMonitoringConfig_ImportFeaturesAnalysis.fromJson,
      ),
      numericalThresholdConfig: decode(
        json['numericalThresholdConfig'],
        FeaturestoreMonitoringConfig_ThresholdConfig.fromJson,
      ),
      categoricalThresholdConfig: decode(
        json['categoricalThresholdConfig'],
        FeaturestoreMonitoringConfig_ThresholdConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (snapshotAnalysis != null)
        'snapshotAnalysis': snapshotAnalysis!.toJson(),
      if (importFeaturesAnalysis != null)
        'importFeaturesAnalysis': importFeaturesAnalysis!.toJson(),
      if (numericalThresholdConfig != null)
        'numericalThresholdConfig': numericalThresholdConfig!.toJson(),
      if (categoricalThresholdConfig != null)
        'categoricalThresholdConfig': categoricalThresholdConfig!.toJson(),
    };
  }

  @override
  String toString() => 'FeaturestoreMonitoringConfig()';
}

/// Configuration of the Featurestore's Snapshot Analysis Based Monitoring.
/// This type of analysis generates statistics for each Feature based on a
/// snapshot of the latest feature value of each entities every
/// monitoring_interval.
final class FeaturestoreMonitoringConfig_SnapshotAnalysis
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeaturestoreMonitoringConfig.SnapshotAnalysis';

  /// The monitoring schedule for snapshot analysis.
  /// For EntityType-level config:
  ///   unset / disabled = true indicates disabled by
  ///   default for Features under it; otherwise by default enable snapshot
  ///   analysis monitoring with monitoring_interval for Features under it.
  /// Feature-level config:
  ///   disabled = true indicates disabled regardless of the EntityType-level
  ///   config; unset monitoring_interval indicates going with EntityType-level
  ///   config; otherwise run snapshot analysis monitoring with
  ///   monitoring_interval regardless of the EntityType-level config.
  /// Explicitly Disable the snapshot analysis based monitoring.
  final bool? disabled;

  /// Configuration of the snapshot analysis based monitoring pipeline running
  /// interval. The value is rolled up to full day.
  /// If both
  /// `monitoring_interval_days`
  /// and the deprecated `monitoring_interval` field
  /// are set when creating/updating EntityTypes/Features,
  /// `monitoring_interval_days`
  /// will be used.
  final protobuf.Duration? monitoringInterval;

  /// Configuration of the snapshot analysis based monitoring pipeline
  /// running interval. The value indicates number of days.
  final int? monitoringIntervalDays;

  /// Customized export features time window for snapshot analysis. Unit is one
  /// day. Default value is 3 weeks. Minimum value is 1 day. Maximum value is
  /// 4000 days.
  final int? stalenessDays;

  FeaturestoreMonitoringConfig_SnapshotAnalysis({
    this.disabled,
    this.monitoringInterval,
    this.monitoringIntervalDays,
    this.stalenessDays,
  }) : super(fullyQualifiedName);

  factory FeaturestoreMonitoringConfig_SnapshotAnalysis.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeaturestoreMonitoringConfig_SnapshotAnalysis(
      disabled: json['disabled'],
      monitoringInterval: decodeCustom(
        json['monitoringInterval'],
        protobuf.Duration.fromJson,
      ),
      monitoringIntervalDays: json['monitoringIntervalDays'],
      stalenessDays: json['stalenessDays'],
    );
  }

  @override
  Object toJson() {
    return {
      if (disabled != null) 'disabled': disabled,
      if (monitoringInterval != null)
        'monitoringInterval': monitoringInterval!.toJson(),
      if (monitoringIntervalDays != null)
        'monitoringIntervalDays': monitoringIntervalDays,
      if (stalenessDays != null) 'stalenessDays': stalenessDays,
    };
  }

  @override
  String toString() {
    final contents = [
      if (disabled != null) 'disabled=$disabled',
      if (monitoringIntervalDays != null)
        'monitoringIntervalDays=$monitoringIntervalDays',
      if (stalenessDays != null) 'stalenessDays=$stalenessDays',
    ].join(',');
    return 'SnapshotAnalysis($contents)';
  }
}

/// Configuration of the Featurestore's ImportFeature Analysis Based
/// Monitoring. This type of analysis generates statistics for values of each
/// Feature imported by every
/// `ImportFeatureValues`
/// operation.
final class FeaturestoreMonitoringConfig_ImportFeaturesAnalysis
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeaturestoreMonitoringConfig.ImportFeaturesAnalysis';

  /// Whether to enable / disable / inherite default hebavior for import
  /// features analysis.
  final FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State? state;

  /// The baseline used to do anomaly detection for the statistics generated by
  /// import features analysis.
  final FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline?
  anomalyDetectionBaseline;

  FeaturestoreMonitoringConfig_ImportFeaturesAnalysis({
    this.state,
    this.anomalyDetectionBaseline,
  }) : super(fullyQualifiedName);

  factory FeaturestoreMonitoringConfig_ImportFeaturesAnalysis.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeaturestoreMonitoringConfig_ImportFeaturesAnalysis(
      state: decodeEnum(
        json['state'],
        FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State.fromJson,
      ),
      anomalyDetectionBaseline: decodeEnum(
        json['anomalyDetectionBaseline'],
        FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (state != null) 'state': state!.toJson(),
      if (anomalyDetectionBaseline != null)
        'anomalyDetectionBaseline': anomalyDetectionBaseline!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (state != null) 'state=$state',
      if (anomalyDetectionBaseline != null)
        'anomalyDetectionBaseline=$anomalyDetectionBaseline',
    ].join(',');
    return 'ImportFeaturesAnalysis($contents)';
  }
}

/// The state defines whether to enable ImportFeature analysis.
final class FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State
    extends protobuf.ProtoEnum {
  /// Should not be used.
  static const stateUnspecified =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State(
        'STATE_UNSPECIFIED',
      );

  /// The default behavior of whether to enable the monitoring.
  /// EntityType-level config: disabled.
  /// Feature-level config: inherited from the configuration of EntityType
  /// this Feature belongs to.
  static const default$ =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State('DEFAULT');

  /// Explicitly enables import features analysis.
  /// EntityType-level config: by default enables import features analysis
  /// for all Features under it. Feature-level config: enables import
  /// features analysis regardless of the EntityType-level config.
  static const enabled =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State('ENABLED');

  /// Explicitly disables import features analysis.
  /// EntityType-level config: by default disables import features analysis
  /// for all Features under it. Feature-level config: disables import
  /// features analysis regardless of the EntityType-level config.
  static const disabled =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State('DISABLED');

  const FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State(super.value);

  factory FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State.fromJson(
    String json,
  ) => FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_State(json);

  @override
  String toString() => 'State.$value';
}

/// Defines the baseline to do anomaly detection for feature values imported
/// by each
/// `ImportFeatureValues`
/// operation.
final class FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline
    extends protobuf.ProtoEnum {
  /// Should not be used.
  static const baselineUnspecified =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
        'BASELINE_UNSPECIFIED',
      );

  /// Choose the later one statistics generated by either most recent
  /// snapshot analysis or previous import features analysis. If non of them
  /// exists, skip anomaly detection and only generate a statistics.
  static const latestStats =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
        'LATEST_STATS',
      );

  /// Use the statistics generated by the most recent snapshot analysis if
  /// exists.
  static const mostRecentSnapshotStats =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
        'MOST_RECENT_SNAPSHOT_STATS',
      );

  /// Use the statistics generated by the previous import features analysis
  /// if exists.
  static const previousImportFeaturesStats =
      FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
        'PREVIOUS_IMPORT_FEATURES_STATS',
      );

  const FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(
    super.value,
  );

  factory FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline.fromJson(
    String json,
  ) => FeaturestoreMonitoringConfig_ImportFeaturesAnalysis_Baseline(json);

  @override
  String toString() => 'Baseline.$value';
}

/// The config for Featurestore Monitoring threshold.
final class FeaturestoreMonitoringConfig_ThresholdConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeaturestoreMonitoringConfig.ThresholdConfig';

  /// Specify a threshold value that can trigger the alert.
  /// 1. For categorical feature, the distribution distance is calculated by
  /// L-inifinity norm.
  /// 2. For numerical feature, the distribution distance is calculated by
  /// JensenShannon divergence. Each feature must have a non-zero threshold
  /// if they need to be monitored. Otherwise no alert will be triggered for
  /// that feature.
  final double? value;

  FeaturestoreMonitoringConfig_ThresholdConfig({this.value})
    : super(fullyQualifiedName);

  factory FeaturestoreMonitoringConfig_ThresholdConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return FeaturestoreMonitoringConfig_ThresholdConfig(
      value: decodeDouble(json['value']),
    );
  }

  @override
  Object toJson() {
    return {if (value != null) 'value': encodeDouble(value)};
  }

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'ThresholdConfig($contents)';
  }
}

/// Request message for
/// `FeaturestoreOnlineServingService.WriteFeatureValues`.
final class WriteFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteFeatureValuesRequest';

  /// Required. The resource name of the EntityType for the entities being
  /// written. Value format:
  /// `projects/{project}/locations/{location}/featurestores/
  /// {featurestore}/entityTypes/{entityType}`. For example,
  /// for a machine learning model predicting user clicks on a website, an
  /// EntityType ID could be `user`.
  final String entityType;

  /// Required. The entities to be written. Up to 100,000 feature values can be
  /// written across all `payloads`.
  final List<WriteFeatureValuesPayload>? payloads;

  WriteFeatureValuesRequest({required this.entityType, this.payloads})
    : super(fullyQualifiedName);

  factory WriteFeatureValuesRequest.fromJson(Map<String, dynamic> json) {
    return WriteFeatureValuesRequest(
      entityType: json['entityType'],
      payloads: decodeListMessage(
        json['payloads'],
        WriteFeatureValuesPayload.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'entityType': entityType,
      if (payloads != null) 'payloads': encodeList(payloads),
    };
  }

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'WriteFeatureValuesRequest($contents)';
  }
}

/// Contains Feature values to be written for a specific entity.
final class WriteFeatureValuesPayload extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteFeatureValuesPayload';

  /// Required. The ID of the entity.
  final String? entityId;

  /// Required. Feature values to be written, mapping from Feature ID to value.
  /// Up to 100,000 `feature_values` entries may be written across all payloads.
  /// The feature generation time, aligned by days, must be no older than five
  /// years (1825 days) and no later than one year (366 days) in the future.
  final Map<String, FeatureValue>? featureValues;

  WriteFeatureValuesPayload({this.entityId, this.featureValues})
    : super(fullyQualifiedName);

  factory WriteFeatureValuesPayload.fromJson(Map<String, dynamic> json) {
    return WriteFeatureValuesPayload(
      entityId: json['entityId'],
      featureValues: decodeMapMessage(
        json['featureValues'],
        FeatureValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (entityId != null) 'entityId': entityId,
      if (featureValues != null) 'featureValues': encodeMap(featureValues),
    };
  }

  @override
  String toString() {
    final contents = [if (entityId != null) 'entityId=$entityId'].join(',');
    return 'WriteFeatureValuesPayload($contents)';
  }
}

/// Response message for
/// `FeaturestoreOnlineServingService.WriteFeatureValues`.
final class WriteFeatureValuesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteFeatureValuesResponse';

  WriteFeatureValuesResponse() : super(fullyQualifiedName);

  factory WriteFeatureValuesResponse.fromJson(Map<String, dynamic> json) {
    return WriteFeatureValuesResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'WriteFeatureValuesResponse()';
}

/// Request message for
/// `FeaturestoreOnlineServingService.ReadFeatureValues`.
final class ReadFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesRequest';

  /// Required. The resource name of the EntityType for the entity being read.
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example, for a machine learning model predicting user clicks on a
  /// website, an EntityType ID could be `user`.
  final String entityType;

  /// Required. ID for a specific entity. For example,
  /// for a machine learning model predicting user clicks on a website, an entity
  /// ID could be `user_123`.
  final String? entityId;

  /// Required. Selector choosing Features of the target EntityType.
  final FeatureSelector? featureSelector;

  ReadFeatureValuesRequest({
    required this.entityType,
    this.entityId,
    this.featureSelector,
  }) : super(fullyQualifiedName);

  factory ReadFeatureValuesRequest.fromJson(Map<String, dynamic> json) {
    return ReadFeatureValuesRequest(
      entityType: json['entityType'],
      entityId: json['entityId'],
      featureSelector: decode(
        json['featureSelector'],
        FeatureSelector.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'entityType': entityType,
      if (entityId != null) 'entityId': entityId,
      if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'entityType=$entityType',
      if (entityId != null) 'entityId=$entityId',
    ].join(',');
    return 'ReadFeatureValuesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreOnlineServingService.ReadFeatureValues`.
final class ReadFeatureValuesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse';

  /// Response header.
  final ReadFeatureValuesResponse_Header? header;

  /// Entity view with Feature values. This may be the entity in the
  /// Featurestore if values for all Features were requested, or a projection
  /// of the entity in the Featurestore if values for only some Features were
  /// requested.
  final ReadFeatureValuesResponse_EntityView? entityView;

  ReadFeatureValuesResponse({this.header, this.entityView})
    : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse.fromJson(Map<String, dynamic> json) {
    return ReadFeatureValuesResponse(
      header: decode(json['header'], ReadFeatureValuesResponse_Header.fromJson),
      entityView: decode(
        json['entityView'],
        ReadFeatureValuesResponse_EntityView.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (header != null) 'header': header!.toJson(),
      if (entityView != null) 'entityView': entityView!.toJson(),
    };
  }

  @override
  String toString() => 'ReadFeatureValuesResponse()';
}

/// Metadata for requested Features.
final class ReadFeatureValuesResponse_FeatureDescriptor
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse.FeatureDescriptor';

  /// Feature ID.
  final String? id;

  ReadFeatureValuesResponse_FeatureDescriptor({this.id})
    : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse_FeatureDescriptor.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReadFeatureValuesResponse_FeatureDescriptor(id: json['id']);
  }

  @override
  Object toJson() {
    return {if (id != null) 'id': id};
  }

  @override
  String toString() {
    final contents = [if (id != null) 'id=$id'].join(',');
    return 'FeatureDescriptor($contents)';
  }
}

/// Response header with metadata for the requested
/// `ReadFeatureValuesRequest.entity_type`
/// and Features.
final class ReadFeatureValuesResponse_Header extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse.Header';

  /// The resource name of the EntityType from the
  /// `ReadFeatureValuesRequest`.
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  final String? entityType;

  /// List of Feature metadata corresponding to each piece of
  /// `ReadFeatureValuesResponse.EntityView.data`.
  final List<ReadFeatureValuesResponse_FeatureDescriptor>? featureDescriptors;

  ReadFeatureValuesResponse_Header({this.entityType, this.featureDescriptors})
    : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse_Header.fromJson(Map<String, dynamic> json) {
    return ReadFeatureValuesResponse_Header(
      entityType: json['entityType'],
      featureDescriptors: decodeListMessage(
        json['featureDescriptors'],
        ReadFeatureValuesResponse_FeatureDescriptor.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (entityType != null) 'entityType': entityType,
      if (featureDescriptors != null)
        'featureDescriptors': encodeList(featureDescriptors),
    };
  }

  @override
  String toString() {
    final contents = [
      if (entityType != null) 'entityType=$entityType',
    ].join(',');
    return 'Header($contents)';
  }
}

/// Entity view with Feature values.
final class ReadFeatureValuesResponse_EntityView extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse.EntityView';

  /// ID of the requested entity.
  final String? entityId;

  /// Each piece of data holds the k
  /// requested values for one requested Feature. If no values
  /// for the requested Feature exist, the corresponding cell will be empty.
  /// This has the same size and is in the same order as the features from the
  /// header
  /// `ReadFeatureValuesResponse.header`.
  final List<ReadFeatureValuesResponse_EntityView_Data>? data;

  ReadFeatureValuesResponse_EntityView({this.entityId, this.data})
    : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse_EntityView.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReadFeatureValuesResponse_EntityView(
      entityId: json['entityId'],
      data: decodeListMessage(
        json['data'],
        ReadFeatureValuesResponse_EntityView_Data.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (entityId != null) 'entityId': entityId,
      if (data != null) 'data': encodeList(data),
    };
  }

  @override
  String toString() {
    final contents = [if (entityId != null) 'entityId=$entityId'].join(',');
    return 'EntityView($contents)';
  }
}

/// Container to hold value(s), successive in time, for one Feature from the
/// request.
final class ReadFeatureValuesResponse_EntityView_Data
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadFeatureValuesResponse.EntityView.Data';

  /// Feature value if a single value is requested.
  final FeatureValue? value;

  /// Feature values list if values, successive in time, are requested.
  /// If the requested number of values is greater than the number of
  /// existing Feature values, nonexistent values are omitted instead of
  /// being returned as empty.
  final FeatureValueList? values;

  ReadFeatureValuesResponse_EntityView_Data({this.value, this.values})
    : super(fullyQualifiedName);

  factory ReadFeatureValuesResponse_EntityView_Data.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReadFeatureValuesResponse_EntityView_Data(
      value: decode(json['value'], FeatureValue.fromJson),
      values: decode(json['values'], FeatureValueList.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (value != null) 'value': value!.toJson(),
      if (values != null) 'values': values!.toJson(),
    };
  }

  @override
  String toString() => 'Data()';
}

/// Request message for
/// `FeaturestoreOnlineServingService.StreamingReadFeatureValues`.
final class StreamingReadFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingReadFeatureValuesRequest';

  /// Required. The resource name of the entities' type.
  /// Value format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`.
  /// For example,
  /// for a machine learning model predicting user clicks on a website, an
  /// EntityType ID could be `user`.
  final String entityType;

  /// Required. IDs of entities to read Feature values of. The maximum number of
  /// IDs is 100. For example, for a machine learning model predicting user
  /// clicks on a website, an entity ID could be `user_123`.
  final List<String>? entityIds;

  /// Required. Selector choosing Features of the target EntityType. Feature IDs
  /// will be deduplicated.
  final FeatureSelector? featureSelector;

  StreamingReadFeatureValuesRequest({
    required this.entityType,
    this.entityIds,
    this.featureSelector,
  }) : super(fullyQualifiedName);

  factory StreamingReadFeatureValuesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return StreamingReadFeatureValuesRequest(
      entityType: json['entityType'],
      entityIds: decodeList(json['entityIds']),
      featureSelector: decode(
        json['featureSelector'],
        FeatureSelector.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'entityType': entityType,
      if (entityIds != null) 'entityIds': entityIds,
      if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'StreamingReadFeatureValuesRequest($contents)';
  }
}

/// Value for a feature.
final class FeatureValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureValue';

  /// Bool type feature value.
  final bool? boolValue;

  /// Double type feature value.
  final double? doubleValue;

  /// Int64 feature value.
  final int? int64Value;

  /// String feature value.
  final String? stringValue;

  /// A list of bool type feature value.
  final BoolArray? boolArrayValue;

  /// A list of double type feature value.
  final DoubleArray? doubleArrayValue;

  /// A list of int64 type feature value.
  final Int64Array? int64ArrayValue;

  /// A list of string type feature value.
  final StringArray? stringArrayValue;

  /// Bytes feature value.
  final Uint8List? bytesValue;

  /// A struct type feature value.
  final StructValue? structValue;

  /// Metadata of feature value.
  final FeatureValue_Metadata? metadata;

  FeatureValue({
    this.boolValue,
    this.doubleValue,
    this.int64Value,
    this.stringValue,
    this.boolArrayValue,
    this.doubleArrayValue,
    this.int64ArrayValue,
    this.stringArrayValue,
    this.bytesValue,
    this.structValue,
    this.metadata,
  }) : super(fullyQualifiedName);

  factory FeatureValue.fromJson(Map<String, dynamic> json) {
    return FeatureValue(
      boolValue: json['boolValue'],
      doubleValue: decodeDouble(json['doubleValue']),
      int64Value: decodeInt64(json['int64Value']),
      stringValue: json['stringValue'],
      boolArrayValue: decode(json['boolArrayValue'], BoolArray.fromJson),
      doubleArrayValue: decode(json['doubleArrayValue'], DoubleArray.fromJson),
      int64ArrayValue: decode(json['int64ArrayValue'], Int64Array.fromJson),
      stringArrayValue: decode(json['stringArrayValue'], StringArray.fromJson),
      bytesValue: decodeBytes(json['bytesValue']),
      structValue: decode(json['structValue'], StructValue.fromJson),
      metadata: decode(json['metadata'], FeatureValue_Metadata.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (boolValue != null) 'boolValue': boolValue,
      if (doubleValue != null) 'doubleValue': encodeDouble(doubleValue),
      if (int64Value != null) 'int64Value': encodeInt64(int64Value),
      if (stringValue != null) 'stringValue': stringValue,
      if (boolArrayValue != null) 'boolArrayValue': boolArrayValue!.toJson(),
      if (doubleArrayValue != null)
        'doubleArrayValue': doubleArrayValue!.toJson(),
      if (int64ArrayValue != null) 'int64ArrayValue': int64ArrayValue!.toJson(),
      if (stringArrayValue != null)
        'stringArrayValue': stringArrayValue!.toJson(),
      if (bytesValue != null) 'bytesValue': encodeBytes(bytesValue),
      if (structValue != null) 'structValue': structValue!.toJson(),
      if (metadata != null) 'metadata': metadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (boolValue != null) 'boolValue=$boolValue',
      if (doubleValue != null) 'doubleValue=$doubleValue',
      if (int64Value != null) 'int64Value=$int64Value',
      if (stringValue != null) 'stringValue=$stringValue',
      if (bytesValue != null) 'bytesValue=$bytesValue',
    ].join(',');
    return 'FeatureValue($contents)';
  }
}

/// Metadata of feature value.
final class FeatureValue_Metadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureValue.Metadata';

  /// Feature generation timestamp. Typically, it is provided by user at
  /// feature ingestion time. If not, feature store
  /// will use the system timestamp when the data is ingested into feature
  /// store.
  ///
  /// Legacy Feature Store: For streaming ingestion, the time, aligned by days,
  /// must be no older than five years (1825 days) and no later than one year
  /// (366 days) in the future.
  final protobuf.Timestamp? generateTime;

  FeatureValue_Metadata({this.generateTime}) : super(fullyQualifiedName);

  factory FeatureValue_Metadata.fromJson(Map<String, dynamic> json) {
    return FeatureValue_Metadata(
      generateTime: decodeCustom(
        json['generateTime'],
        protobuf.Timestamp.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (generateTime != null) 'generateTime': generateTime!.toJson()};
  }

  @override
  String toString() => 'Metadata()';
}

/// Struct (or object) type feature value.
final class StructValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StructValue';

  /// A list of field values.
  final List<StructFieldValue>? values;

  StructValue({this.values}) : super(fullyQualifiedName);

  factory StructValue.fromJson(Map<String, dynamic> json) {
    return StructValue(
      values: decodeListMessage(json['values'], StructFieldValue.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': encodeList(values)};
  }

  @override
  String toString() => 'StructValue()';
}

/// One field of a Struct (or object) type feature value.
final class StructFieldValue extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StructFieldValue';

  /// Name of the field in the struct feature.
  final String? name;

  /// The value for this field.
  final FeatureValue? value;

  StructFieldValue({this.name, this.value}) : super(fullyQualifiedName);

  factory StructFieldValue.fromJson(Map<String, dynamic> json) {
    return StructFieldValue(
      name: json['name'],
      value: decode(json['value'], FeatureValue.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (value != null) 'value': value!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (name != null) 'name=$name'].join(',');
    return 'StructFieldValue($contents)';
  }
}

/// Container for list of values.
final class FeatureValueList extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureValueList';

  /// A list of feature values. All of them should be the same data type.
  final List<FeatureValue>? values;

  FeatureValueList({this.values}) : super(fullyQualifiedName);

  factory FeatureValueList.fromJson(Map<String, dynamic> json) {
    return FeatureValueList(
      values: decodeListMessage(json['values'], FeatureValue.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': encodeList(values)};
  }

  @override
  String toString() => 'FeatureValueList()';
}

/// Request message for
/// `FeaturestoreService.CreateFeaturestore`.
final class CreateFeaturestoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeaturestoreRequest';

  /// Required. The resource name of the Location to create Featurestores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Featurestore to create.
  final Featurestore featurestore;

  /// Required. The ID to use for this Featurestore, which will become the final
  /// component of the Featurestore's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within the project and location.
  final String? featurestoreId;

  CreateFeaturestoreRequest({
    required this.parent,
    required this.featurestore,
    this.featurestoreId,
  }) : super(fullyQualifiedName);

  factory CreateFeaturestoreRequest.fromJson(Map<String, dynamic> json) {
    return CreateFeaturestoreRequest(
      parent: json['parent'],
      featurestore: decode(json['featurestore'], Featurestore.fromJson)!,
      featurestoreId: json['featurestoreId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'featurestore': featurestore.toJson(),
      if (featurestoreId != null) 'featurestoreId': featurestoreId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (featurestoreId != null) 'featurestoreId=$featurestoreId',
    ].join(',');
    return 'CreateFeaturestoreRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.GetFeaturestore`.
final class GetFeaturestoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeaturestoreRequest';

  /// Required. The name of the Featurestore resource.
  final String name;

  GetFeaturestoreRequest({required this.name}) : super(fullyQualifiedName);

  factory GetFeaturestoreRequest.fromJson(Map<String, dynamic> json) {
    return GetFeaturestoreRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeaturestoreRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ListFeaturestores`.
final class ListFeaturestoresRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeaturestoresRequest';

  /// Required. The resource name of the Location to list Featurestores.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the featurestores that match the filter expression. The following
  /// fields are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  /// Values must be
  ///   in RFC 3339 format.
  /// * `online_serving_config.fixed_node_count`: Supports `=`, `!=`, `<`, `>`,
  /// `<=`, and `>=` comparisons.
  /// * `labels`: Supports key-value equality and key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > "2020-01-01" OR update_time > "2020-01-01"`
  ///    Featurestores created or updated after 2020-01-01.
  /// * `labels.env = "prod"`
  ///    Featurestores with label "env" set to "prod".
  final String? filter;

  /// The maximum number of Featurestores to return. The service may return fewer
  /// than this value. If unspecified, at most 100 Featurestores will be
  /// returned. The maximum value is 100; any value greater than 100 will be
  /// coerced to 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `FeaturestoreService.ListFeaturestores`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeaturestoreService.ListFeaturestores`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported Fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  ///   * `online_serving_config.fixed_node_count`
  final String? orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListFeaturestoresRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListFeaturestoresRequest.fromJson(Map<String, dynamic> json) {
    return ListFeaturestoresRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListFeaturestoresRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.ListFeaturestores`.
final class ListFeaturestoresResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeaturestoresResponse';

  /// The Featurestores matching the request.
  final List<Featurestore>? featurestores;

  /// A token, which can be sent as
  /// `ListFeaturestoresRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListFeaturestoresResponse({this.featurestores, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListFeaturestoresResponse.fromJson(Map<String, dynamic> json) {
    return ListFeaturestoresResponse(
      featurestores: decodeListMessage(
        json['featurestores'],
        Featurestore.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featurestores != null) 'featurestores': encodeList(featurestores),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFeaturestoresResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.UpdateFeaturestore`.
final class UpdateFeaturestoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeaturestoreRequest';

  /// Required. The Featurestore's `name` field is used to identify the
  /// Featurestore to be updated. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final Featurestore featurestore;

  /// Field mask is used to specify the fields to be overwritten in the
  /// Featurestore resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `labels`
  ///   * `online_serving_config.fixed_node_count`
  ///   * `online_serving_config.scaling`
  ///   * `online_storage_ttl_days`
  final protobuf.FieldMask? updateMask;

  UpdateFeaturestoreRequest({required this.featurestore, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeaturestoreRequest.fromJson(Map<String, dynamic> json) {
    return UpdateFeaturestoreRequest(
      featurestore: decode(json['featurestore'], Featurestore.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'featurestore': featurestore.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeaturestoreRequest()';
}

/// Request message for
/// `FeaturestoreService.DeleteFeaturestore`.
final class DeleteFeaturestoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeaturestoreRequest';

  /// Required. The name of the Featurestore to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String name;

  /// If set to true, any EntityTypes and Features for this Featurestore will
  /// also be deleted. (Otherwise, the request will only work if the Featurestore
  /// has no EntityTypes.)
  final bool? force;

  DeleteFeaturestoreRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteFeaturestoreRequest.fromJson(Map<String, dynamic> json) {
    return DeleteFeaturestoreRequest(name: json['name'], force: json['force']);
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteFeaturestoreRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ImportFeatureValues`.
final class ImportFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportFeatureValuesRequest';

  final AvroSource? avroSource;

  final BigQuerySource? bigquerySource;

  final CsvSource? csvSource;

  /// Source column that holds the Feature timestamp for all Feature
  /// values in each entity.
  final String? featureTimeField;

  /// Single Feature timestamp for all entities being imported. The
  /// timestamp must not have higher than millisecond precision.
  final protobuf.Timestamp? featureTime;

  /// Required. The resource name of the EntityType grouping the Features for
  /// which values are being imported. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  final String entityType;

  /// Source column that holds entity IDs. If not provided, entity IDs are
  /// extracted from the column named entity_id.
  final String? entityIdField;

  /// Required. Specifications defining which Feature values to import from the
  /// entity. The request fails if no feature_specs are provided, and having
  /// multiple feature_specs for one Feature is not allowed.
  final List<ImportFeatureValuesRequest_FeatureSpec>? featureSpecs;

  /// If set, data will not be imported for online serving. This
  /// is typically used for backfilling, where Feature generation timestamps are
  /// not in the timestamp range needed for online serving.
  final bool? disableOnlineServing;

  /// Specifies the number of workers that are used to write data to the
  /// Featurestore. Consider the online serving capacity that you require to
  /// achieve the desired import throughput without interfering with online
  /// serving. The value must be positive, and less than or equal to 100.
  /// If not set, defaults to using 1 worker. The low count ensures minimal
  /// impact on online serving performance.
  final int? workerCount;

  /// If true, API doesn't start ingestion analysis pipeline.
  final bool? disableIngestionAnalysis;

  ImportFeatureValuesRequest({
    this.avroSource,
    this.bigquerySource,
    this.csvSource,
    this.featureTimeField,
    this.featureTime,
    required this.entityType,
    this.entityIdField,
    this.featureSpecs,
    this.disableOnlineServing,
    this.workerCount,
    this.disableIngestionAnalysis,
  }) : super(fullyQualifiedName);

  factory ImportFeatureValuesRequest.fromJson(Map<String, dynamic> json) {
    return ImportFeatureValuesRequest(
      avroSource: decode(json['avroSource'], AvroSource.fromJson),
      bigquerySource: decode(json['bigquerySource'], BigQuerySource.fromJson),
      csvSource: decode(json['csvSource'], CsvSource.fromJson),
      featureTimeField: json['featureTimeField'],
      featureTime: decodeCustom(
        json['featureTime'],
        protobuf.Timestamp.fromJson,
      ),
      entityType: json['entityType'],
      entityIdField: json['entityIdField'],
      featureSpecs: decodeListMessage(
        json['featureSpecs'],
        ImportFeatureValuesRequest_FeatureSpec.fromJson,
      ),
      disableOnlineServing: json['disableOnlineServing'],
      workerCount: json['workerCount'],
      disableIngestionAnalysis: json['disableIngestionAnalysis'],
    );
  }

  @override
  Object toJson() {
    return {
      if (avroSource != null) 'avroSource': avroSource!.toJson(),
      if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
      if (csvSource != null) 'csvSource': csvSource!.toJson(),
      if (featureTimeField != null) 'featureTimeField': featureTimeField,
      if (featureTime != null) 'featureTime': featureTime!.toJson(),
      'entityType': entityType,
      if (entityIdField != null) 'entityIdField': entityIdField,
      if (featureSpecs != null) 'featureSpecs': encodeList(featureSpecs),
      if (disableOnlineServing != null)
        'disableOnlineServing': disableOnlineServing,
      if (workerCount != null) 'workerCount': workerCount,
      if (disableIngestionAnalysis != null)
        'disableIngestionAnalysis': disableIngestionAnalysis,
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureTimeField != null) 'featureTimeField=$featureTimeField',
      'entityType=$entityType',
      if (entityIdField != null) 'entityIdField=$entityIdField',
      if (disableOnlineServing != null)
        'disableOnlineServing=$disableOnlineServing',
      if (workerCount != null) 'workerCount=$workerCount',
      if (disableIngestionAnalysis != null)
        'disableIngestionAnalysis=$disableIngestionAnalysis',
    ].join(',');
    return 'ImportFeatureValuesRequest($contents)';
  }
}

/// Defines the Feature value(s) to import.
final class ImportFeatureValuesRequest_FeatureSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportFeatureValuesRequest.FeatureSpec';

  /// Required. ID of the Feature to import values of. This Feature must exist
  /// in the target EntityType, or the request will fail.
  final String? id;

  /// Source column to get the Feature values from. If not set, uses the column
  /// with the same name as the Feature ID.
  final String? sourceField;

  ImportFeatureValuesRequest_FeatureSpec({this.id, this.sourceField})
    : super(fullyQualifiedName);

  factory ImportFeatureValuesRequest_FeatureSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return ImportFeatureValuesRequest_FeatureSpec(
      id: json['id'],
      sourceField: json['sourceField'],
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (sourceField != null) 'sourceField': sourceField,
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      if (sourceField != null) 'sourceField=$sourceField',
    ].join(',');
    return 'FeatureSpec($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.ImportFeatureValues`.
final class ImportFeatureValuesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportFeatureValuesResponse';

  /// Number of entities that have been imported by the operation.
  final int? importedEntityCount;

  /// Number of Feature values that have been imported by the operation.
  final int? importedFeatureValueCount;

  /// The number of rows in input source that weren't imported due to either
  /// * Not having any featureValues.
  /// * Having a null entityId.
  /// * Having a null timestamp.
  /// * Not being parsable (applicable for CSV sources).
  final int? invalidRowCount;

  /// The number rows that weren't ingested due to having feature timestamps
  /// outside the retention boundary.
  final int? timestampOutsideRetentionRowsCount;

  ImportFeatureValuesResponse({
    this.importedEntityCount,
    this.importedFeatureValueCount,
    this.invalidRowCount,
    this.timestampOutsideRetentionRowsCount,
  }) : super(fullyQualifiedName);

  factory ImportFeatureValuesResponse.fromJson(Map<String, dynamic> json) {
    return ImportFeatureValuesResponse(
      importedEntityCount: decodeInt64(json['importedEntityCount']),
      importedFeatureValueCount: decodeInt64(json['importedFeatureValueCount']),
      invalidRowCount: decodeInt64(json['invalidRowCount']),
      timestampOutsideRetentionRowsCount: decodeInt64(
        json['timestampOutsideRetentionRowsCount'],
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (importedEntityCount != null)
        'importedEntityCount': encodeInt64(importedEntityCount),
      if (importedFeatureValueCount != null)
        'importedFeatureValueCount': encodeInt64(importedFeatureValueCount),
      if (invalidRowCount != null)
        'invalidRowCount': encodeInt64(invalidRowCount),
      if (timestampOutsideRetentionRowsCount != null)
        'timestampOutsideRetentionRowsCount': encodeInt64(
          timestampOutsideRetentionRowsCount,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (importedEntityCount != null)
        'importedEntityCount=$importedEntityCount',
      if (importedFeatureValueCount != null)
        'importedFeatureValueCount=$importedFeatureValueCount',
      if (invalidRowCount != null) 'invalidRowCount=$invalidRowCount',
      if (timestampOutsideRetentionRowsCount != null)
        'timestampOutsideRetentionRowsCount=$timestampOutsideRetentionRowsCount',
    ].join(',');
    return 'ImportFeatureValuesResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.BatchReadFeatureValues`.
final class BatchReadFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesRequest';

  /// Each read instance consists of exactly one read timestamp and one or more
  /// entity IDs identifying entities of the corresponding EntityTypes whose
  /// Features are requested.
  ///
  /// Each output instance contains Feature values of requested entities
  /// concatenated together as of the read time.
  ///
  /// An example read instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z`.
  ///
  /// An example output instance may be `foo_entity_id, bar_entity_id,
  /// 2020-01-01T10:00:00.123Z, foo_entity_feature1_value,
  /// bar_entity_feature2_value`.
  ///
  /// Timestamp in each read instance must be millisecond-aligned.
  ///
  /// `csv_read_instances` are read instances stored in a plain-text CSV file.
  /// The header should be:
  ///     [ENTITY_TYPE_ID1], [ENTITY_TYPE_ID2], ..., timestamp
  ///
  /// The columns can be in any order.
  ///
  /// Values in the timestamp column must use the RFC 3339 format, e.g.
  /// `2012-07-30T10:43:17.123Z`.
  final CsvSource? csvReadInstances;

  /// Similar to csv_read_instances, but from BigQuery source.
  final BigQuerySource? bigqueryReadInstances;

  /// Required. The resource name of the Featurestore from which to query Feature
  /// values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String featurestore;

  /// Required. Specifies output location and format.
  final FeatureValueDestination? destination;

  /// When not empty, the specified fields in the *_read_instances source will be
  /// joined as-is in the output, in addition to those fields from the
  /// Featurestore Entity.
  ///
  /// For BigQuery source, the type of the pass-through values will be
  /// automatically inferred. For CSV source, the pass-through values will be
  /// passed as opaque bytes.
  final List<BatchReadFeatureValuesRequest_PassThroughField>? passThroughFields;

  /// Required. Specifies EntityType grouping Features to read values of and
  /// settings.
  final List<BatchReadFeatureValuesRequest_EntityTypeSpec>? entityTypeSpecs;

  /// Optional. Excludes Feature values with feature generation timestamp before
  /// this timestamp. If not set, retrieve oldest values kept in Feature Store.
  /// Timestamp, if present, must not have higher than millisecond precision.
  final protobuf.Timestamp? startTime;

  BatchReadFeatureValuesRequest({
    this.csvReadInstances,
    this.bigqueryReadInstances,
    required this.featurestore,
    this.destination,
    this.passThroughFields,
    this.entityTypeSpecs,
    this.startTime,
  }) : super(fullyQualifiedName);

  factory BatchReadFeatureValuesRequest.fromJson(Map<String, dynamic> json) {
    return BatchReadFeatureValuesRequest(
      csvReadInstances: decode(json['csvReadInstances'], CsvSource.fromJson),
      bigqueryReadInstances: decode(
        json['bigqueryReadInstances'],
        BigQuerySource.fromJson,
      ),
      featurestore: json['featurestore'],
      destination: decode(
        json['destination'],
        FeatureValueDestination.fromJson,
      ),
      passThroughFields: decodeListMessage(
        json['passThroughFields'],
        BatchReadFeatureValuesRequest_PassThroughField.fromJson,
      ),
      entityTypeSpecs: decodeListMessage(
        json['entityTypeSpecs'],
        BatchReadFeatureValuesRequest_EntityTypeSpec.fromJson,
      ),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (csvReadInstances != null)
        'csvReadInstances': csvReadInstances!.toJson(),
      if (bigqueryReadInstances != null)
        'bigqueryReadInstances': bigqueryReadInstances!.toJson(),
      'featurestore': featurestore,
      if (destination != null) 'destination': destination!.toJson(),
      if (passThroughFields != null)
        'passThroughFields': encodeList(passThroughFields),
      if (entityTypeSpecs != null)
        'entityTypeSpecs': encodeList(entityTypeSpecs),
      if (startTime != null) 'startTime': startTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['featurestore=$featurestore'].join(',');
    return 'BatchReadFeatureValuesRequest($contents)';
  }
}

/// Describe pass-through fields in read_instance source.
final class BatchReadFeatureValuesRequest_PassThroughField
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesRequest.PassThroughField';

  /// Required. The name of the field in the CSV header or the name of the
  /// column in BigQuery table. The naming restriction is the same as
  /// `Feature.name`.
  final String? fieldName;

  BatchReadFeatureValuesRequest_PassThroughField({this.fieldName})
    : super(fullyQualifiedName);

  factory BatchReadFeatureValuesRequest_PassThroughField.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchReadFeatureValuesRequest_PassThroughField(
      fieldName: json['fieldName'],
    );
  }

  @override
  Object toJson() {
    return {if (fieldName != null) 'fieldName': fieldName};
  }

  @override
  String toString() {
    final contents = [if (fieldName != null) 'fieldName=$fieldName'].join(',');
    return 'PassThroughField($contents)';
  }
}

/// Selects Features of an EntityType to read values of and specifies read
/// settings.
final class BatchReadFeatureValuesRequest_EntityTypeSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesRequest.EntityTypeSpec';

  /// Required. ID of the EntityType to select Features. The EntityType id is
  /// the
  /// `entity_type_id`
  /// specified during EntityType creation.
  final String? entityTypeId;

  /// Required. Selectors choosing which Feature values to read from the
  /// EntityType.
  final FeatureSelector? featureSelector;

  /// Per-Feature settings for the batch read.
  final List<DestinationFeatureSetting>? settings;

  BatchReadFeatureValuesRequest_EntityTypeSpec({
    this.entityTypeId,
    this.featureSelector,
    this.settings,
  }) : super(fullyQualifiedName);

  factory BatchReadFeatureValuesRequest_EntityTypeSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchReadFeatureValuesRequest_EntityTypeSpec(
      entityTypeId: json['entityTypeId'],
      featureSelector: decode(
        json['featureSelector'],
        FeatureSelector.fromJson,
      ),
      settings: decodeListMessage(
        json['settings'],
        DestinationFeatureSetting.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (entityTypeId != null) 'entityTypeId': entityTypeId,
      if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
      if (settings != null) 'settings': encodeList(settings),
    };
  }

  @override
  String toString() {
    final contents = [
      if (entityTypeId != null) 'entityTypeId=$entityTypeId',
    ].join(',');
    return 'EntityTypeSpec($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ExportFeatureValues`.
final class ExportFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesRequest';

  /// Exports the latest Feature values of all entities of the EntityType
  /// within a time range.
  final ExportFeatureValuesRequest_SnapshotExport? snapshotExport;

  /// Exports all historical values of all entities of the EntityType within a
  /// time range
  final ExportFeatureValuesRequest_FullExport? fullExport;

  /// Required. The resource name of the EntityType from which to export Feature
  /// values. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  final String entityType;

  /// Required. Specifies destination location and format.
  final FeatureValueDestination? destination;

  /// Required. Selects Features to export values of.
  final FeatureSelector? featureSelector;

  /// Per-Feature export settings.
  final List<DestinationFeatureSetting>? settings;

  ExportFeatureValuesRequest({
    this.snapshotExport,
    this.fullExport,
    required this.entityType,
    this.destination,
    this.featureSelector,
    this.settings,
  }) : super(fullyQualifiedName);

  factory ExportFeatureValuesRequest.fromJson(Map<String, dynamic> json) {
    return ExportFeatureValuesRequest(
      snapshotExport: decode(
        json['snapshotExport'],
        ExportFeatureValuesRequest_SnapshotExport.fromJson,
      ),
      fullExport: decode(
        json['fullExport'],
        ExportFeatureValuesRequest_FullExport.fromJson,
      ),
      entityType: json['entityType'],
      destination: decode(
        json['destination'],
        FeatureValueDestination.fromJson,
      ),
      featureSelector: decode(
        json['featureSelector'],
        FeatureSelector.fromJson,
      ),
      settings: decodeListMessage(
        json['settings'],
        DestinationFeatureSetting.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (snapshotExport != null) 'snapshotExport': snapshotExport!.toJson(),
      if (fullExport != null) 'fullExport': fullExport!.toJson(),
      'entityType': entityType,
      if (destination != null) 'destination': destination!.toJson(),
      if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
      if (settings != null) 'settings': encodeList(settings),
    };
  }

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'ExportFeatureValuesRequest($contents)';
  }
}

/// Describes exporting the latest Feature values of all entities of the
/// EntityType between [start_time, snapshot_time].
final class ExportFeatureValuesRequest_SnapshotExport
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesRequest.SnapshotExport';

  /// Exports Feature values as of this timestamp. If not set,
  /// retrieve values as of now. Timestamp, if present, must not have higher
  /// than millisecond precision.
  final protobuf.Timestamp? snapshotTime;

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp. If not set, retrieve oldest values kept in Feature Store.
  /// Timestamp, if present, must not have higher than millisecond precision.
  final protobuf.Timestamp? startTime;

  ExportFeatureValuesRequest_SnapshotExport({this.snapshotTime, this.startTime})
    : super(fullyQualifiedName);

  factory ExportFeatureValuesRequest_SnapshotExport.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExportFeatureValuesRequest_SnapshotExport(
      snapshotTime: decodeCustom(
        json['snapshotTime'],
        protobuf.Timestamp.fromJson,
      ),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (snapshotTime != null) 'snapshotTime': snapshotTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
    };
  }

  @override
  String toString() => 'SnapshotExport()';
}

/// Describes exporting all historical Feature values of all entities of the
/// EntityType between [start_time, end_time].
final class ExportFeatureValuesRequest_FullExport
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesRequest.FullExport';

  /// Excludes Feature values with feature generation timestamp before this
  /// timestamp. If not set, retrieve oldest values kept in Feature Store.
  /// Timestamp, if present, must not have higher than millisecond precision.
  final protobuf.Timestamp? startTime;

  /// Exports Feature values as of this timestamp. If not set,
  /// retrieve values as of now. Timestamp, if present, must not have higher
  /// than millisecond precision.
  final protobuf.Timestamp? endTime;

  ExportFeatureValuesRequest_FullExport({this.startTime, this.endTime})
    : super(fullyQualifiedName);

  factory ExportFeatureValuesRequest_FullExport.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExportFeatureValuesRequest_FullExport(
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
    };
  }

  @override
  String toString() => 'FullExport()';
}

final class DestinationFeatureSetting extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DestinationFeatureSetting';

  /// Required. The ID of the Feature to apply the setting to.
  final String? featureId;

  /// Specify the field name in the export destination. If not specified,
  /// Feature ID is used.
  final String? destinationField;

  DestinationFeatureSetting({this.featureId, this.destinationField})
    : super(fullyQualifiedName);

  factory DestinationFeatureSetting.fromJson(Map<String, dynamic> json) {
    return DestinationFeatureSetting(
      featureId: json['featureId'],
      destinationField: json['destinationField'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureId != null) 'featureId': featureId,
      if (destinationField != null) 'destinationField': destinationField,
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureId != null) 'featureId=$featureId',
      if (destinationField != null) 'destinationField=$destinationField',
    ].join(',');
    return 'DestinationFeatureSetting($contents)';
  }
}

/// A destination location for Feature values and format.
final class FeatureValueDestination extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FeatureValueDestination';

  /// Output in BigQuery format.
  /// `BigQueryDestination.output_uri`
  /// in
  /// `FeatureValueDestination.bigquery_destination`
  /// must refer to a table.
  final BigQueryDestination? bigqueryDestination;

  /// Output in TFRecord format.
  ///
  /// Below are the mapping from Feature value type
  /// in Featurestore to Feature value type in TFRecord:
  ///
  ///     Value type in Featurestore                 | Value type in TFRecord
  ///     DOUBLE, DOUBLE_ARRAY                       | FLOAT_LIST
  ///     INT64, INT64_ARRAY                         | INT64_LIST
  ///     STRING, STRING_ARRAY, BYTES                | BYTES_LIST
  ///     true -> byte_string("true"), false -> byte_string("false")
  ///     BOOL, BOOL_ARRAY (true, false)             | BYTES_LIST
  final TfrecordDestination? tfrecordDestination;

  /// Output in CSV format. Array Feature value types are not allowed in CSV
  /// format.
  final CsvDestination? csvDestination;

  FeatureValueDestination({
    this.bigqueryDestination,
    this.tfrecordDestination,
    this.csvDestination,
  }) : super(fullyQualifiedName);

  factory FeatureValueDestination.fromJson(Map<String, dynamic> json) {
    return FeatureValueDestination(
      bigqueryDestination: decode(
        json['bigqueryDestination'],
        BigQueryDestination.fromJson,
      ),
      tfrecordDestination: decode(
        json['tfrecordDestination'],
        TfrecordDestination.fromJson,
      ),
      csvDestination: decode(json['csvDestination'], CsvDestination.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (bigqueryDestination != null)
        'bigqueryDestination': bigqueryDestination!.toJson(),
      if (tfrecordDestination != null)
        'tfrecordDestination': tfrecordDestination!.toJson(),
      if (csvDestination != null) 'csvDestination': csvDestination!.toJson(),
    };
  }

  @override
  String toString() => 'FeatureValueDestination()';
}

/// Response message for
/// `FeaturestoreService.ExportFeatureValues`.
final class ExportFeatureValuesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesResponse';

  ExportFeatureValuesResponse() : super(fullyQualifiedName);

  factory ExportFeatureValuesResponse.fromJson(Map<String, dynamic> json) {
    return ExportFeatureValuesResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'ExportFeatureValuesResponse()';
}

/// Response message for
/// `FeaturestoreService.BatchReadFeatureValues`.
final class BatchReadFeatureValuesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesResponse';

  BatchReadFeatureValuesResponse() : super(fullyQualifiedName);

  factory BatchReadFeatureValuesResponse.fromJson(Map<String, dynamic> json) {
    return BatchReadFeatureValuesResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'BatchReadFeatureValuesResponse()';
}

/// Request message for
/// `FeaturestoreService.CreateEntityType`.
final class CreateEntityTypeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateEntityTypeRequest';

  /// Required. The resource name of the Featurestore to create EntityTypes.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String parent;

  /// The EntityType to create.
  final EntityType entityType;

  /// Required. The ID to use for the EntityType, which will become the final
  /// component of the EntityType's resource name.
  ///
  /// This value may be up to 60 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within a featurestore.
  final String? entityTypeId;

  CreateEntityTypeRequest({
    required this.parent,
    required this.entityType,
    this.entityTypeId,
  }) : super(fullyQualifiedName);

  factory CreateEntityTypeRequest.fromJson(Map<String, dynamic> json) {
    return CreateEntityTypeRequest(
      parent: json['parent'],
      entityType: decode(json['entityType'], EntityType.fromJson)!,
      entityTypeId: json['entityTypeId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'entityType': entityType.toJson(),
      if (entityTypeId != null) 'entityTypeId': entityTypeId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (entityTypeId != null) 'entityTypeId=$entityTypeId',
    ].join(',');
    return 'CreateEntityTypeRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.GetEntityType`.
final class GetEntityTypeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetEntityTypeRequest';

  /// Required. The name of the EntityType resource.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  final String name;

  GetEntityTypeRequest({required this.name}) : super(fullyQualifiedName);

  factory GetEntityTypeRequest.fromJson(Map<String, dynamic> json) {
    return GetEntityTypeRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetEntityTypeRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ListEntityTypes`.
final class ListEntityTypesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEntityTypesRequest';

  /// Required. The resource name of the Featurestore to list EntityTypes.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}`
  final String parent;

  /// Lists the EntityTypes that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `>=`, and `<=` comparisons.
  /// Values must be in RFC 3339 format.
  /// * `labels`: Supports key-value equality as well as key presence.
  ///
  /// Examples:
  ///
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
  ///      update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
  ///      or updated after 2020-01-31T15:30:00.000000Z.
  /// * `labels.active = yes AND labels.env = prod` --> EntityTypes having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any EntityType which has a label with 'env' as the
  ///   key.
  final String? filter;

  /// The maximum number of EntityTypes to return. The service may return fewer
  /// than this value. If unspecified, at most 1000 EntityTypes will be returned.
  /// The maximum value is 1000; any value greater than 1000 will be coerced to
  /// 1000.
  final int? pageSize;

  /// A page token, received from a previous
  /// `FeaturestoreService.ListEntityTypes`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeaturestoreService.ListEntityTypes`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  ///
  /// Supported fields:
  ///
  ///   * `entity_type_id`
  ///   * `create_time`
  ///   * `update_time`
  final String? orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListEntityTypesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListEntityTypesRequest.fromJson(Map<String, dynamic> json) {
    return ListEntityTypesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListEntityTypesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.ListEntityTypes`.
final class ListEntityTypesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEntityTypesResponse';

  /// The EntityTypes matching the request.
  final List<EntityType>? entityTypes;

  /// A token, which can be sent as
  /// `ListEntityTypesRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListEntityTypesResponse({this.entityTypes, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListEntityTypesResponse.fromJson(Map<String, dynamic> json) {
    return ListEntityTypesResponse(
      entityTypes: decodeListMessage(json['entityTypes'], EntityType.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (entityTypes != null) 'entityTypes': encodeList(entityTypes),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListEntityTypesResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.UpdateEntityType`.
final class UpdateEntityTypeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateEntityTypeRequest';

  /// Required. The EntityType's `name` field is used to identify the EntityType
  /// to be updated. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  final EntityType entityType;

  /// Field mask is used to specify the fields to be overwritten in the
  /// EntityType resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `description`
  ///   * `labels`
  ///   * `monitoring_config.snapshot_analysis.disabled`
  ///   * `monitoring_config.snapshot_analysis.monitoring_interval_days`
  ///   * `monitoring_config.snapshot_analysis.staleness_days`
  ///   * `monitoring_config.import_features_analysis.state`
  ///   * `monitoring_config.import_features_analysis.anomaly_detection_baseline`
  ///   * `monitoring_config.numerical_threshold_config.value`
  ///   * `monitoring_config.categorical_threshold_config.value`
  ///   * `offline_storage_ttl_days`
  final protobuf.FieldMask? updateMask;

  UpdateEntityTypeRequest({required this.entityType, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateEntityTypeRequest.fromJson(Map<String, dynamic> json) {
    return UpdateEntityTypeRequest(
      entityType: decode(json['entityType'], EntityType.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'entityType': entityType.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateEntityTypeRequest()';
}

/// Request message for `FeaturestoreService.DeleteEntityTypes`.
final class DeleteEntityTypeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteEntityTypeRequest';

  /// Required. The name of the EntityType to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  final String name;

  /// If set to true, any Features for this EntityType will also be deleted.
  /// (Otherwise, the request will only work if the EntityType has no Features.)
  final bool? force;

  DeleteEntityTypeRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteEntityTypeRequest.fromJson(Map<String, dynamic> json) {
    return DeleteEntityTypeRequest(name: json['name'], force: json['force']);
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteEntityTypeRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.CreateFeature`.
/// Request message for
/// `FeatureRegistryService.CreateFeature`.
final class CreateFeatureRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureRequest';

  /// Required. The resource name of the EntityType or FeatureGroup to create a
  /// Feature. Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String parent;

  /// Required. The Feature to create.
  final Feature feature;

  /// Required. The ID to use for the Feature, which will become the final
  /// component of the Feature's resource name.
  ///
  /// This value may be up to 128 characters, and valid characters are
  /// `[a-z0-9_]`. The first character cannot be a number.
  ///
  /// The value must be unique within an EntityType/FeatureGroup.
  final String? featureId;

  CreateFeatureRequest({
    required this.parent,
    required this.feature,
    this.featureId,
  }) : super(fullyQualifiedName);

  factory CreateFeatureRequest.fromJson(Map<String, dynamic> json) {
    return CreateFeatureRequest(
      parent: json['parent'],
      feature: decode(json['feature'], Feature.fromJson)!,
      featureId: json['featureId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'feature': feature.toJson(),
      if (featureId != null) 'featureId': featureId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (featureId != null) 'featureId=$featureId',
    ].join(',');
    return 'CreateFeatureRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.BatchCreateFeatures`.
/// Request message for
/// `FeatureRegistryService.BatchCreateFeatures`.
final class BatchCreateFeaturesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateFeaturesRequest';

  /// Required. The resource name of the EntityType/FeatureGroup to create the
  /// batch of Features under. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String parent;

  /// Required. The request message specifying the Features to create. All
  /// Features must be created under the same parent EntityType / FeatureGroup.
  /// The `parent` field in each child request message can be omitted. If
  /// `parent` is set in a child request, then the value must match the `parent`
  /// value in this request message.
  final List<CreateFeatureRequest>? requests;

  BatchCreateFeaturesRequest({required this.parent, this.requests})
    : super(fullyQualifiedName);

  factory BatchCreateFeaturesRequest.fromJson(Map<String, dynamic> json) {
    return BatchCreateFeaturesRequest(
      parent: json['parent'],
      requests: decodeListMessage(
        json['requests'],
        CreateFeatureRequest.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (requests != null) 'requests': encodeList(requests),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchCreateFeaturesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.BatchCreateFeatures`.
final class BatchCreateFeaturesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateFeaturesResponse';

  /// The Features created.
  final List<Feature>? features;

  BatchCreateFeaturesResponse({this.features}) : super(fullyQualifiedName);

  factory BatchCreateFeaturesResponse.fromJson(Map<String, dynamic> json) {
    return BatchCreateFeaturesResponse(
      features: decodeListMessage(json['features'], Feature.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (features != null) 'features': encodeList(features)};
  }

  @override
  String toString() => 'BatchCreateFeaturesResponse()';
}

/// Request message for
/// `FeaturestoreService.GetFeature`.
/// Request message for
/// `FeatureRegistryService.GetFeature`.
final class GetFeatureRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetFeatureRequest';

  /// Required. The name of the Feature resource.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String name;

  /// Optional. Only applicable for Vertex AI Feature Store.
  /// If set, retrieves FeatureStatsAndAnomaly generated by FeatureMonitors based
  /// on this spec.
  final FeatureStatsAndAnomalySpec? featureStatsAndAnomalySpec;

  GetFeatureRequest({required this.name, this.featureStatsAndAnomalySpec})
    : super(fullyQualifiedName);

  factory GetFeatureRequest.fromJson(Map<String, dynamic> json) {
    return GetFeatureRequest(
      name: json['name'],
      featureStatsAndAnomalySpec: decode(
        json['featureStatsAndAnomalySpec'],
        FeatureStatsAndAnomalySpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (featureStatsAndAnomalySpec != null)
        'featureStatsAndAnomalySpec': featureStatsAndAnomalySpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetFeatureRequest($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.ListFeatures`.
/// Request message for
/// `FeatureRegistryService.ListFeatures`.
final class ListFeaturesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeaturesRequest';

  /// Required. The resource name of the Location to list Features.
  /// Format for entity_type as parent:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}`
  /// Format for feature_group as parent:
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}`
  final String parent;

  /// Lists the Features that match the filter expression. The following
  /// filters are supported:
  ///
  /// * `value_type`: Supports = and != comparisons.
  /// * `create_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
  /// be in RFC 3339 format.
  /// * `update_time`: Supports =, !=, <, >, >=, and <= comparisons. Values must
  /// be in RFC 3339 format.
  /// * `labels`: Supports key-value equality as well as key presence.
  ///
  /// Examples:
  ///
  /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
  /// * `create_time > \"2020-01-31T15:30:00.000000Z\" OR
  ///      update_time > \"2020-01-31T15:30:00.000000Z\"` --> EntityTypes created
  ///      or updated after 2020-01-31T15:30:00.000000Z.
  /// * `labels.active = yes AND labels.env = prod` --> Features having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any Feature which has a label with 'env' as the
  ///   key.
  final String? filter;

  /// The maximum number of Features to return. The service may return fewer
  /// than this value. If unspecified, at most 1000 Features will be returned.
  /// The maximum value is 1000; any value greater than 1000 will be coerced to
  /// 1000.
  final int? pageSize;

  /// A page token, received from a previous
  /// `FeaturestoreService.ListFeatures`
  /// call or
  /// `FeatureRegistryService.ListFeatures`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeaturestoreService.ListFeatures`
  /// or
  /// `FeatureRegistryService.ListFeatures`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported fields:
  ///
  ///   * `feature_id`
  ///   * `value_type` (Not supported for FeatureRegistry Feature)
  ///   * `create_time`
  ///   * `update_time`
  final String? orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// Only applicable for Vertex AI Feature Store (Legacy).
  /// If set, return the most recent
  /// `ListFeaturesRequest.latest_stats_count`
  /// of stats for each Feature in response. Valid value is [0, 10]. If number of
  /// stats exists <
  /// `ListFeaturesRequest.latest_stats_count`,
  /// return all existing stats.
  final int? latestStatsCount;

  ListFeaturesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.readMask,
    this.latestStatsCount,
  }) : super(fullyQualifiedName);

  factory ListFeaturesRequest.fromJson(Map<String, dynamic> json) {
    return ListFeaturesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      latestStatsCount: json['latestStatsCount'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (latestStatsCount != null) 'latestStatsCount': latestStatsCount,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
      if (latestStatsCount != null) 'latestStatsCount=$latestStatsCount',
    ].join(',');
    return 'ListFeaturesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.ListFeatures`.
/// Response message for
/// `FeatureRegistryService.ListFeatures`.
final class ListFeaturesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListFeaturesResponse';

  /// The Features matching the request.
  final List<Feature>? features;

  /// A token, which can be sent as
  /// `ListFeaturesRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListFeaturesResponse({this.features, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListFeaturesResponse.fromJson(Map<String, dynamic> json) {
    return ListFeaturesResponse(
      features: decodeListMessage(json['features'], Feature.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (features != null) 'features': encodeList(features),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListFeaturesResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.SearchFeatures`.
final class SearchFeaturesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchFeaturesRequest';

  /// Required. The resource name of the Location to search Features.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String location;

  /// Query string that is a conjunction of field-restricted queries and/or
  /// field-restricted filters.  Field-restricted queries and filters can be
  /// combined using `AND` to form a conjunction.
  ///
  /// A field query is in the form FIELD:QUERY. This implicitly checks if QUERY
  /// exists as a substring within Feature's FIELD. The QUERY
  /// and the FIELD are converted to a sequence of words (i.e. tokens) for
  /// comparison. This is done by:
  ///
  ///   * Removing leading/trailing whitespace and tokenizing the search value.
  ///   Characters that are not one of alphanumeric `[a-zA-Z0-9]`, underscore
  ///   `_`, or asterisk `*` are treated as delimiters for tokens. `*` is treated
  ///   as a wildcard that matches characters within a token.
  ///   * Ignoring case.
  ///   * Prepending an asterisk to the first and appending an asterisk to the
  ///   last token in QUERY.
  ///
  /// A QUERY must be either a singular token or a phrase. A phrase is one or
  /// multiple words enclosed in double quotation marks ("). With phrases, the
  /// order of the words is important. Words in the phrase must be matching in
  /// order and consecutively.
  ///
  /// Supported FIELDs for field-restricted queries:
  ///
  /// * `feature_id`
  /// * `description`
  /// * `entity_type_id`
  ///
  /// Examples:
  ///
  /// * `feature_id: foo` --> Matches a Feature with ID containing the substring
  /// `foo` (eg. `foo`, `foofeature`, `barfoo`).
  /// * `feature_id: foo*feature` --> Matches a Feature with ID containing the
  /// substring `foo*feature` (eg. `foobarfeature`).
  /// * `feature_id: foo AND description: bar` --> Matches a Feature with ID
  /// containing the substring `foo` and description containing the substring
  /// `bar`.
  ///
  ///
  /// Besides field queries, the following exact-match filters are
  /// supported. The exact-match filters do not support wildcards. Unlike
  /// field-restricted queries, exact-match filters are case-sensitive.
  ///
  /// * `feature_id`: Supports = comparisons.
  /// * `description`: Supports = comparisons. Multi-token filters should be
  /// enclosed in quotes.
  /// * `entity_type_id`: Supports = comparisons.
  /// * `value_type`: Supports = and != comparisons.
  /// * `labels`: Supports key-value equality as well as key presence.
  /// * `featurestore_id`: Supports = comparisons.
  ///
  /// Examples:
  ///
  /// * `description = "foo bar"` --> Any Feature with description exactly equal
  /// to `foo bar`
  /// * `value_type = DOUBLE` --> Features whose type is DOUBLE.
  /// * `labels.active = yes AND labels.env = prod` --> Features having both
  ///     (active: yes) and (env: prod) labels.
  /// * `labels.env: *` --> Any Feature which has a label with `env` as the
  ///   key.
  final String? query;

  /// The maximum number of Features to return. The service may return fewer
  /// than this value. If unspecified, at most 100 Features will be returned.
  /// The maximum value is 100; any value greater than 100 will be coerced to
  /// 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `FeaturestoreService.SearchFeatures`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `FeaturestoreService.SearchFeatures`,
  /// except `page_size`, must match the call that provided the page token.
  final String? pageToken;

  SearchFeaturesRequest({
    required this.location,
    this.query,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory SearchFeaturesRequest.fromJson(Map<String, dynamic> json) {
    return SearchFeaturesRequest(
      location: json['location'],
      query: json['query'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'location': location,
      if (query != null) 'query': query,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'location=$location',
      if (query != null) 'query=$query',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'SearchFeaturesRequest($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.SearchFeatures`.
final class SearchFeaturesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchFeaturesResponse';

  /// The Features matching the request.
  ///
  /// Fields returned:
  ///
  ///  * `name`
  ///  * `description`
  ///  * `labels`
  ///  * `create_time`
  ///  * `update_time`
  final List<Feature>? features;

  /// A token, which can be sent as
  /// `SearchFeaturesRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  SearchFeaturesResponse({this.features, this.nextPageToken})
    : super(fullyQualifiedName);

  factory SearchFeaturesResponse.fromJson(Map<String, dynamic> json) {
    return SearchFeaturesResponse(
      features: decodeListMessage(json['features'], Feature.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (features != null) 'features': encodeList(features),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'SearchFeaturesResponse($contents)';
  }
}

/// Request message for
/// `FeaturestoreService.UpdateFeature`.
/// Request message for
/// `FeatureRegistryService.UpdateFeature`.
final class UpdateFeatureRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeatureRequest';

  /// Required. The Feature's `name` field is used to identify the Feature to be
  /// updated.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  final Feature feature;

  /// Field mask is used to specify the fields to be overwritten in the
  /// Features resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field will be overwritten if it is in the mask. If the
  /// user does not provide a mask then only the non-empty fields present in the
  /// request will be overwritten. Set the update_mask to `*` to override all
  /// fields.
  ///
  /// Updatable fields:
  ///
  ///   * `description`
  ///   * `labels`
  ///   * `disable_monitoring` (Not supported for FeatureRegistryService Feature)
  ///   * `point_of_contact` (Not supported for FeaturestoreService FeatureStore)
  final protobuf.FieldMask? updateMask;

  UpdateFeatureRequest({required this.feature, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFeatureRequest.fromJson(Map<String, dynamic> json) {
    return UpdateFeatureRequest(
      feature: decode(json['feature'], Feature.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'feature': feature.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeatureRequest()';
}

/// Request message for
/// `FeaturestoreService.DeleteFeature`.
/// Request message for
/// `FeatureRegistryService.DeleteFeature`.
final class DeleteFeatureRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureRequest';

  /// Required. The name of the Features to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entity_type}/features/{feature}`
  /// `projects/{project}/locations/{location}/featureGroups/{feature_group}/features/{feature}`
  final String name;

  DeleteFeatureRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteFeatureRequest.fromJson(Map<String, dynamic> json) {
    return DeleteFeatureRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteFeatureRequest($contents)';
  }
}

/// Details of operations that perform create Featurestore.
final class CreateFeaturestoreOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeaturestoreOperationMetadata';

  /// Operation metadata for Featurestore.
  final GenericOperationMetadata? genericMetadata;

  CreateFeaturestoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeaturestoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateFeaturestoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateFeaturestoreOperationMetadata()';
}

/// Details of operations that perform update Featurestore.
final class UpdateFeaturestoreOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateFeaturestoreOperationMetadata';

  /// Operation metadata for Featurestore.
  final GenericOperationMetadata? genericMetadata;

  UpdateFeaturestoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateFeaturestoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateFeaturestoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateFeaturestoreOperationMetadata()';
}

/// Details of operations that perform import Feature values.
final class ImportFeatureValuesOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportFeatureValuesOperationMetadata';

  /// Operation metadata for Featurestore import Feature values.
  final GenericOperationMetadata? genericMetadata;

  /// Number of entities that have been imported by the operation.
  final int? importedEntityCount;

  /// Number of Feature values that have been imported by the operation.
  final int? importedFeatureValueCount;

  /// The source URI from where Feature values are imported.
  final List<String>? sourceUris;

  /// The number of rows in input source that weren't imported due to either
  /// * Not having any featureValues.
  /// * Having a null entityId.
  /// * Having a null timestamp.
  /// * Not being parsable (applicable for CSV sources).
  final int? invalidRowCount;

  /// The number rows that weren't ingested due to having timestamps outside the
  /// retention boundary.
  final int? timestampOutsideRetentionRowsCount;

  /// List of ImportFeatureValues operations running under a single EntityType
  /// that are blocking this operation.
  final List<int>? blockingOperationIds;

  ImportFeatureValuesOperationMetadata({
    this.genericMetadata,
    this.importedEntityCount,
    this.importedFeatureValueCount,
    this.sourceUris,
    this.invalidRowCount,
    this.timestampOutsideRetentionRowsCount,
    this.blockingOperationIds,
  }) : super(fullyQualifiedName);

  factory ImportFeatureValuesOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return ImportFeatureValuesOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      importedEntityCount: decodeInt64(json['importedEntityCount']),
      importedFeatureValueCount: decodeInt64(json['importedFeatureValueCount']),
      sourceUris: decodeList(json['sourceUris']),
      invalidRowCount: decodeInt64(json['invalidRowCount']),
      timestampOutsideRetentionRowsCount: decodeInt64(
        json['timestampOutsideRetentionRowsCount'],
      ),
      blockingOperationIds: decodeList(json['blockingOperationIds']),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (importedEntityCount != null)
        'importedEntityCount': encodeInt64(importedEntityCount),
      if (importedFeatureValueCount != null)
        'importedFeatureValueCount': encodeInt64(importedFeatureValueCount),
      if (sourceUris != null) 'sourceUris': sourceUris,
      if (invalidRowCount != null)
        'invalidRowCount': encodeInt64(invalidRowCount),
      if (timestampOutsideRetentionRowsCount != null)
        'timestampOutsideRetentionRowsCount': encodeInt64(
          timestampOutsideRetentionRowsCount,
        ),
      if (blockingOperationIds != null)
        'blockingOperationIds': blockingOperationIds,
    };
  }

  @override
  String toString() {
    final contents = [
      if (importedEntityCount != null)
        'importedEntityCount=$importedEntityCount',
      if (importedFeatureValueCount != null)
        'importedFeatureValueCount=$importedFeatureValueCount',
      if (invalidRowCount != null) 'invalidRowCount=$invalidRowCount',
      if (timestampOutsideRetentionRowsCount != null)
        'timestampOutsideRetentionRowsCount=$timestampOutsideRetentionRowsCount',
    ].join(',');
    return 'ImportFeatureValuesOperationMetadata($contents)';
  }
}

/// Details of operations that exports Features values.
final class ExportFeatureValuesOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportFeatureValuesOperationMetadata';

  /// Operation metadata for Featurestore export Feature values.
  final GenericOperationMetadata? genericMetadata;

  ExportFeatureValuesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ExportFeatureValuesOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExportFeatureValuesOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'ExportFeatureValuesOperationMetadata()';
}

/// Details of operations that batch reads Feature values.
final class BatchReadFeatureValuesOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadFeatureValuesOperationMetadata';

  /// Operation metadata for Featurestore batch read Features values.
  final GenericOperationMetadata? genericMetadata;

  BatchReadFeatureValuesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory BatchReadFeatureValuesOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchReadFeatureValuesOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'BatchReadFeatureValuesOperationMetadata()';
}

/// Details of operations that delete Feature values.
final class DeleteFeatureValuesOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesOperationMetadata';

  /// Operation metadata for Featurestore delete Features values.
  final GenericOperationMetadata? genericMetadata;

  DeleteFeatureValuesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory DeleteFeatureValuesOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteFeatureValuesOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'DeleteFeatureValuesOperationMetadata()';
}

/// Details of operations that perform create EntityType.
final class CreateEntityTypeOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateEntityTypeOperationMetadata';

  /// Operation metadata for EntityType.
  final GenericOperationMetadata? genericMetadata;

  CreateEntityTypeOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateEntityTypeOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateEntityTypeOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateEntityTypeOperationMetadata()';
}

/// Details of operations that perform create Feature.
final class CreateFeatureOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateFeatureOperationMetadata';

  /// Operation metadata for Feature.
  final GenericOperationMetadata? genericMetadata;

  CreateFeatureOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateFeatureOperationMetadata.fromJson(Map<String, dynamic> json) {
    return CreateFeatureOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateFeatureOperationMetadata()';
}

/// Details of operations that perform batch create Features.
final class BatchCreateFeaturesOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateFeaturesOperationMetadata';

  /// Operation metadata for Feature.
  final GenericOperationMetadata? genericMetadata;

  BatchCreateFeaturesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory BatchCreateFeaturesOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchCreateFeaturesOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'BatchCreateFeaturesOperationMetadata()';
}

/// Request message for
/// `FeaturestoreService.DeleteFeatureValues`.
final class DeleteFeatureValuesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesRequest';

  /// Select feature values to be deleted by specifying entities.
  final DeleteFeatureValuesRequest_SelectEntity? selectEntity;

  /// Select feature values to be deleted by specifying time range and
  /// features.
  final DeleteFeatureValuesRequest_SelectTimeRangeAndFeature?
  selectTimeRangeAndFeature;

  /// Required. The resource name of the EntityType grouping the Features for
  /// which values are being deleted from. Format:
  /// `projects/{project}/locations/{location}/featurestores/{featurestore}/entityTypes/{entityType}`
  final String entityType;

  DeleteFeatureValuesRequest({
    this.selectEntity,
    this.selectTimeRangeAndFeature,
    required this.entityType,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesRequest.fromJson(Map<String, dynamic> json) {
    return DeleteFeatureValuesRequest(
      selectEntity: decode(
        json['selectEntity'],
        DeleteFeatureValuesRequest_SelectEntity.fromJson,
      ),
      selectTimeRangeAndFeature: decode(
        json['selectTimeRangeAndFeature'],
        DeleteFeatureValuesRequest_SelectTimeRangeAndFeature.fromJson,
      ),
      entityType: json['entityType'],
    );
  }

  @override
  Object toJson() {
    return {
      if (selectEntity != null) 'selectEntity': selectEntity!.toJson(),
      if (selectTimeRangeAndFeature != null)
        'selectTimeRangeAndFeature': selectTimeRangeAndFeature!.toJson(),
      'entityType': entityType,
    };
  }

  @override
  String toString() {
    final contents = ['entityType=$entityType'].join(',');
    return 'DeleteFeatureValuesRequest($contents)';
  }
}

/// Message to select entity.
/// If an entity id is selected, all the feature values corresponding to the
/// entity id will be deleted, including the entityId.
final class DeleteFeatureValuesRequest_SelectEntity
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesRequest.SelectEntity';

  /// Required. Selectors choosing feature values of which entity id to be
  /// deleted from the EntityType.
  final EntityIdSelector? entityIdSelector;

  DeleteFeatureValuesRequest_SelectEntity({this.entityIdSelector})
    : super(fullyQualifiedName);

  factory DeleteFeatureValuesRequest_SelectEntity.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteFeatureValuesRequest_SelectEntity(
      entityIdSelector: decode(
        json['entityIdSelector'],
        EntityIdSelector.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (entityIdSelector != null)
        'entityIdSelector': entityIdSelector!.toJson(),
    };
  }

  @override
  String toString() => 'SelectEntity()';
}

/// Message to select time range and feature.
/// Values of the selected feature generated within an inclusive time range
/// will be deleted. Using this option permanently deletes the feature values
/// from the specified feature IDs within the specified time range.
/// This might include data from the online storage. If you want to retain
/// any deleted historical data in the online storage, you must re-ingest it.
final class DeleteFeatureValuesRequest_SelectTimeRangeAndFeature
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesRequest.SelectTimeRangeAndFeature';

  /// Required. Select feature generated within a half-inclusive time range.
  /// The time range is lower inclusive and upper exclusive.
  final Interval? timeRange;

  /// Required. Selectors choosing which feature values to be deleted from the
  /// EntityType.
  final FeatureSelector? featureSelector;

  /// If set, data will not be deleted from online storage.
  /// When time range is older than the data in online storage, setting this to
  /// be true will make the deletion have no impact on online serving.
  final bool? skipOnlineStorageDelete;

  DeleteFeatureValuesRequest_SelectTimeRangeAndFeature({
    this.timeRange,
    this.featureSelector,
    this.skipOnlineStorageDelete,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesRequest_SelectTimeRangeAndFeature.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteFeatureValuesRequest_SelectTimeRangeAndFeature(
      timeRange: decode(json['timeRange'], Interval.fromJson),
      featureSelector: decode(
        json['featureSelector'],
        FeatureSelector.fromJson,
      ),
      skipOnlineStorageDelete: json['skipOnlineStorageDelete'],
    );
  }

  @override
  Object toJson() {
    return {
      if (timeRange != null) 'timeRange': timeRange!.toJson(),
      if (featureSelector != null) 'featureSelector': featureSelector!.toJson(),
      if (skipOnlineStorageDelete != null)
        'skipOnlineStorageDelete': skipOnlineStorageDelete,
    };
  }

  @override
  String toString() {
    final contents = [
      if (skipOnlineStorageDelete != null)
        'skipOnlineStorageDelete=$skipOnlineStorageDelete',
    ].join(',');
    return 'SelectTimeRangeAndFeature($contents)';
  }
}

/// Response message for
/// `FeaturestoreService.DeleteFeatureValues`.
final class DeleteFeatureValuesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesResponse';

  /// Response for request specifying the entities to delete
  final DeleteFeatureValuesResponse_SelectEntity? selectEntity;

  /// Response for request specifying time range and feature
  final DeleteFeatureValuesResponse_SelectTimeRangeAndFeature?
  selectTimeRangeAndFeature;

  DeleteFeatureValuesResponse({
    this.selectEntity,
    this.selectTimeRangeAndFeature,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesResponse.fromJson(Map<String, dynamic> json) {
    return DeleteFeatureValuesResponse(
      selectEntity: decode(
        json['selectEntity'],
        DeleteFeatureValuesResponse_SelectEntity.fromJson,
      ),
      selectTimeRangeAndFeature: decode(
        json['selectTimeRangeAndFeature'],
        DeleteFeatureValuesResponse_SelectTimeRangeAndFeature.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (selectEntity != null) 'selectEntity': selectEntity!.toJson(),
      if (selectTimeRangeAndFeature != null)
        'selectTimeRangeAndFeature': selectTimeRangeAndFeature!.toJson(),
    };
  }

  @override
  String toString() => 'DeleteFeatureValuesResponse()';
}

/// Response message if the request uses the SelectEntity option.
final class DeleteFeatureValuesResponse_SelectEntity
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesResponse.SelectEntity';

  /// The count of deleted entity rows in the offline storage.
  /// Each row corresponds to the combination of an entity ID and a timestamp.
  /// One entity ID can have multiple rows in the offline storage.
  final int? offlineStorageDeletedEntityRowCount;

  /// The count of deleted entities in the online storage.
  /// Each entity ID corresponds to one entity.
  final int? onlineStorageDeletedEntityCount;

  DeleteFeatureValuesResponse_SelectEntity({
    this.offlineStorageDeletedEntityRowCount,
    this.onlineStorageDeletedEntityCount,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesResponse_SelectEntity.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteFeatureValuesResponse_SelectEntity(
      offlineStorageDeletedEntityRowCount: decodeInt64(
        json['offlineStorageDeletedEntityRowCount'],
      ),
      onlineStorageDeletedEntityCount: decodeInt64(
        json['onlineStorageDeletedEntityCount'],
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (offlineStorageDeletedEntityRowCount != null)
        'offlineStorageDeletedEntityRowCount': encodeInt64(
          offlineStorageDeletedEntityRowCount,
        ),
      if (onlineStorageDeletedEntityCount != null)
        'onlineStorageDeletedEntityCount': encodeInt64(
          onlineStorageDeletedEntityCount,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (offlineStorageDeletedEntityRowCount != null)
        'offlineStorageDeletedEntityRowCount=$offlineStorageDeletedEntityRowCount',
      if (onlineStorageDeletedEntityCount != null)
        'onlineStorageDeletedEntityCount=$onlineStorageDeletedEntityCount',
    ].join(',');
    return 'SelectEntity($contents)';
  }
}

/// Response message if the request uses the SelectTimeRangeAndFeature option.
final class DeleteFeatureValuesResponse_SelectTimeRangeAndFeature
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteFeatureValuesResponse.SelectTimeRangeAndFeature';

  /// The count of the features or columns impacted.
  /// This is the same as the feature count in the request.
  final int? impactedFeatureCount;

  /// The count of modified entity rows in the offline storage.
  /// Each row corresponds to the combination of an entity ID and a timestamp.
  /// One entity ID can have multiple rows in the offline storage.
  /// Within each row, only the features specified in the request are
  /// deleted.
  final int? offlineStorageModifiedEntityRowCount;

  /// The count of modified entities in the online storage.
  /// Each entity ID corresponds to one entity.
  /// Within each entity, only the features specified in the request are
  /// deleted.
  final int? onlineStorageModifiedEntityCount;

  DeleteFeatureValuesResponse_SelectTimeRangeAndFeature({
    this.impactedFeatureCount,
    this.offlineStorageModifiedEntityRowCount,
    this.onlineStorageModifiedEntityCount,
  }) : super(fullyQualifiedName);

  factory DeleteFeatureValuesResponse_SelectTimeRangeAndFeature.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteFeatureValuesResponse_SelectTimeRangeAndFeature(
      impactedFeatureCount: decodeInt64(json['impactedFeatureCount']),
      offlineStorageModifiedEntityRowCount: decodeInt64(
        json['offlineStorageModifiedEntityRowCount'],
      ),
      onlineStorageModifiedEntityCount: decodeInt64(
        json['onlineStorageModifiedEntityCount'],
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (impactedFeatureCount != null)
        'impactedFeatureCount': encodeInt64(impactedFeatureCount),
      if (offlineStorageModifiedEntityRowCount != null)
        'offlineStorageModifiedEntityRowCount': encodeInt64(
          offlineStorageModifiedEntityRowCount,
        ),
      if (onlineStorageModifiedEntityCount != null)
        'onlineStorageModifiedEntityCount': encodeInt64(
          onlineStorageModifiedEntityCount,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (impactedFeatureCount != null)
        'impactedFeatureCount=$impactedFeatureCount',
      if (offlineStorageModifiedEntityRowCount != null)
        'offlineStorageModifiedEntityRowCount=$offlineStorageModifiedEntityRowCount',
      if (onlineStorageModifiedEntityCount != null)
        'onlineStorageModifiedEntityCount=$onlineStorageModifiedEntityCount',
    ].join(',');
    return 'SelectTimeRangeAndFeature($contents)';
  }
}

/// Selector for entityId. Getting ids from the given source.
final class EntityIdSelector extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EntityIdSelector';

  /// Source of Csv
  final CsvSource? csvSource;

  /// Source column that holds entity IDs. If not provided, entity IDs are
  /// extracted from the column named entity_id.
  final String? entityIdField;

  EntityIdSelector({this.csvSource, this.entityIdField})
    : super(fullyQualifiedName);

  factory EntityIdSelector.fromJson(Map<String, dynamic> json) {
    return EntityIdSelector(
      csvSource: decode(json['csvSource'], CsvSource.fromJson),
      entityIdField: json['entityIdField'],
    );
  }

  @override
  Object toJson() {
    return {
      if (csvSource != null) 'csvSource': csvSource!.toJson(),
      if (entityIdField != null) 'entityIdField': entityIdField,
    };
  }

  @override
  String toString() {
    final contents = [
      if (entityIdField != null) 'entityIdField=$entityIdField',
    ].join(',');
    return 'EntityIdSelector($contents)';
  }
}

/// Request message for
/// `GenAiCacheService.CreateCachedContent`.
final class CreateCachedContentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateCachedContentRequest';

  /// Required. The parent resource where the cached content will be created
  final String parent;

  /// Required. The cached content to create
  final CachedContent cachedContent;

  CreateCachedContentRequest({
    required this.parent,
    required this.cachedContent,
  }) : super(fullyQualifiedName);

  factory CreateCachedContentRequest.fromJson(Map<String, dynamic> json) {
    return CreateCachedContentRequest(
      parent: json['parent'],
      cachedContent: decode(json['cachedContent'], CachedContent.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'cachedContent': cachedContent.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateCachedContentRequest($contents)';
  }
}

/// Request message for
/// `GenAiCacheService.GetCachedContent`.
final class GetCachedContentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetCachedContentRequest';

  /// Required. The resource name referring to the cached content
  final String name;

  GetCachedContentRequest({required this.name}) : super(fullyQualifiedName);

  factory GetCachedContentRequest.fromJson(Map<String, dynamic> json) {
    return GetCachedContentRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetCachedContentRequest($contents)';
  }
}

/// Request message for
/// `GenAiCacheService.UpdateCachedContent`.
/// Only expire_time or ttl can be updated.
final class UpdateCachedContentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateCachedContentRequest';

  /// Required. The cached content to update
  final CachedContent cachedContent;

  /// Required. The list of fields to update.
  final protobuf.FieldMask? updateMask;

  UpdateCachedContentRequest({required this.cachedContent, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateCachedContentRequest.fromJson(Map<String, dynamic> json) {
    return UpdateCachedContentRequest(
      cachedContent: decode(json['cachedContent'], CachedContent.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'cachedContent': cachedContent.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateCachedContentRequest()';
}

/// Request message for
/// `GenAiCacheService.DeleteCachedContent`.
final class DeleteCachedContentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteCachedContentRequest';

  /// Required. The resource name referring to the cached content
  final String name;

  DeleteCachedContentRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteCachedContentRequest.fromJson(Map<String, dynamic> json) {
    return DeleteCachedContentRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteCachedContentRequest($contents)';
  }
}

/// Request to list CachedContents.
final class ListCachedContentsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListCachedContentsRequest';

  /// Required. The parent, which owns this collection of cached contents.
  final String parent;

  /// Optional. The maximum number of cached contents to return. The service may
  /// return fewer than this value. If unspecified, some default (under maximum)
  /// number of items will be returned. The maximum value is 1000; values above
  /// 1000 will be coerced to 1000.
  final int? pageSize;

  /// Optional. A page token, received from a previous `ListCachedContents` call.
  /// Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to `ListCachedContents` must
  /// match the call that provided the page token.
  final String? pageToken;

  ListCachedContentsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListCachedContentsRequest.fromJson(Map<String, dynamic> json) {
    return ListCachedContentsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListCachedContentsRequest($contents)';
  }
}

/// Response with a list of CachedContents.
final class ListCachedContentsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListCachedContentsResponse';

  /// List of cached contents.
  final List<CachedContent>? cachedContents;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  final String? nextPageToken;

  ListCachedContentsResponse({this.cachedContents, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListCachedContentsResponse.fromJson(Map<String, dynamic> json) {
    return ListCachedContentsResponse(
      cachedContents: decodeListMessage(
        json['cachedContents'],
        CachedContent.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (cachedContents != null) 'cachedContents': encodeList(cachedContents),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListCachedContentsResponse($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.CreateTuningJob`.
final class CreateTuningJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTuningJobRequest';

  /// Required. The resource name of the Location to create the TuningJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The TuningJob to create.
  final TuningJob tuningJob;

  CreateTuningJobRequest({required this.parent, required this.tuningJob})
    : super(fullyQualifiedName);

  factory CreateTuningJobRequest.fromJson(Map<String, dynamic> json) {
    return CreateTuningJobRequest(
      parent: json['parent'],
      tuningJob: decode(json['tuningJob'], TuningJob.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'tuningJob': tuningJob.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateTuningJobRequest($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.GetTuningJob`.
final class GetTuningJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTuningJobRequest';

  /// Required. The name of the TuningJob resource. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  final String name;

  GetTuningJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTuningJobRequest.fromJson(Map<String, dynamic> json) {
    return GetTuningJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTuningJobRequest($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.ListTuningJobs`.
final class ListTuningJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTuningJobsRequest';

  /// Required. The resource name of the Location to list the TuningJobs from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list filter.
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via `ListTuningJob.next_page_token` of the
  /// previous GenAiTuningService.ListTuningJob][] call.
  final String? pageToken;

  ListTuningJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListTuningJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListTuningJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListTuningJobsRequest($contents)';
  }
}

/// Response message for
/// `GenAiTuningService.ListTuningJobs`
final class ListTuningJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTuningJobsResponse';

  /// List of TuningJobs in the requested page.
  final List<TuningJob>? tuningJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListTuningJobsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListTuningJobsResponse({this.tuningJobs, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListTuningJobsResponse.fromJson(Map<String, dynamic> json) {
    return ListTuningJobsResponse(
      tuningJobs: decodeListMessage(json['tuningJobs'], TuningJob.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tuningJobs != null) 'tuningJobs': encodeList(tuningJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListTuningJobsResponse($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.CancelTuningJob`.
final class CancelTuningJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelTuningJobRequest';

  /// Required. The name of the TuningJob to cancel. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  final String name;

  CancelTuningJobRequest({required this.name}) : super(fullyQualifiedName);

  factory CancelTuningJobRequest.fromJson(Map<String, dynamic> json) {
    return CancelTuningJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelTuningJobRequest($contents)';
  }
}

/// Request message for
/// `GenAiTuningService.RebaseTunedModel`.
final class RebaseTunedModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RebaseTunedModelRequest';

  /// Required. The resource name of the Location into which to rebase the Model.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. TunedModel reference to retrieve the legacy model information.
  final TunedModelRef? tunedModelRef;

  /// Optional. The TuningJob to be updated. Users can use this TuningJob field
  /// to overwrite tuning configs.
  final TuningJob? tuningJob;

  /// Optional. The Google Cloud Storage location to write the artifacts.
  final GcsDestination? artifactDestination;

  /// Optional. By default, bison to gemini migration will always create new
  /// model/endpoint, but for gemini-1.0 to gemini-1.5 migration, we default
  /// deploy to the same endpoint. See details in this Section.
  final bool? deployToSameEndpoint;

  RebaseTunedModelRequest({
    required this.parent,
    this.tunedModelRef,
    this.tuningJob,
    this.artifactDestination,
    this.deployToSameEndpoint,
  }) : super(fullyQualifiedName);

  factory RebaseTunedModelRequest.fromJson(Map<String, dynamic> json) {
    return RebaseTunedModelRequest(
      parent: json['parent'],
      tunedModelRef: decode(json['tunedModelRef'], TunedModelRef.fromJson),
      tuningJob: decode(json['tuningJob'], TuningJob.fromJson),
      artifactDestination: decode(
        json['artifactDestination'],
        GcsDestination.fromJson,
      ),
      deployToSameEndpoint: json['deployToSameEndpoint'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (tunedModelRef != null) 'tunedModelRef': tunedModelRef!.toJson(),
      if (tuningJob != null) 'tuningJob': tuningJob!.toJson(),
      if (artifactDestination != null)
        'artifactDestination': artifactDestination!.toJson(),
      if (deployToSameEndpoint != null)
        'deployToSameEndpoint': deployToSameEndpoint,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (deployToSameEndpoint != null)
        'deployToSameEndpoint=$deployToSameEndpoint',
    ].join(',');
    return 'RebaseTunedModelRequest($contents)';
  }
}

/// Runtime operation information for
/// `GenAiTuningService.RebaseTunedModel`.
final class RebaseTunedModelOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RebaseTunedModelOperationMetadata';

  /// The common part of the operation generic information.
  final GenericOperationMetadata? genericMetadata;

  RebaseTunedModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory RebaseTunedModelOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return RebaseTunedModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'RebaseTunedModelOperationMetadata()';
}

/// Represents a HyperparameterTuningJob. A HyperparameterTuningJob
/// has a Study specification and multiple CustomJobs with identical
/// CustomJob specification.
final class HyperparameterTuningJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.HyperparameterTuningJob';

  /// Output only. Resource name of the HyperparameterTuningJob.
  final String? name;

  /// Required. The display name of the HyperparameterTuningJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Required. Study configuration of the HyperparameterTuningJob.
  final StudySpec? studySpec;

  /// Required. The desired total number of Trials.
  final int? maxTrialCount;

  /// Required. The desired number of Trials to run in parallel.
  final int? parallelTrialCount;

  /// The number of failed Trials that need to be seen before failing
  /// the HyperparameterTuningJob.
  ///
  /// If set to 0, Vertex AI decides how many Trials must fail
  /// before the whole job fails.
  final int? maxFailedTrialCount;

  /// Required. The spec of a trial job. The same spec applies to the CustomJobs
  /// created in all the trials.
  final CustomJobSpec? trialJobSpec;

  /// Output only. Trials of the HyperparameterTuningJob.
  final List<Trial>? trials;

  /// Output only. The detailed state of the job.
  final JobState? state;

  /// Output only. Time when the HyperparameterTuningJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the HyperparameterTuningJob for the first time
  /// entered the `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the HyperparameterTuningJob entered any of the
  /// following states: `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`,
  /// `JOB_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the HyperparameterTuningJob was most recently
  /// updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  final Status? error;

  /// The labels with user-defined metadata to organize HyperparameterTuningJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Customer-managed encryption key options for a HyperparameterTuningJob.
  /// If this is set, then all resources created by the HyperparameterTuningJob
  /// will be encrypted with the provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  HyperparameterTuningJob({
    this.name,
    this.displayName,
    this.studySpec,
    this.maxTrialCount,
    this.parallelTrialCount,
    this.maxFailedTrialCount,
    this.trialJobSpec,
    this.trials,
    this.state,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.error,
    this.labels,
    this.encryptionSpec,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory HyperparameterTuningJob.fromJson(Map<String, dynamic> json) {
    return HyperparameterTuningJob(
      name: json['name'],
      displayName: json['displayName'],
      studySpec: decode(json['studySpec'], StudySpec.fromJson),
      maxTrialCount: json['maxTrialCount'],
      parallelTrialCount: json['parallelTrialCount'],
      maxFailedTrialCount: json['maxFailedTrialCount'],
      trialJobSpec: decode(json['trialJobSpec'], CustomJobSpec.fromJson),
      trials: decodeListMessage(json['trials'], Trial.fromJson),
      state: decodeEnum(json['state'], JobState.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      error: decode(json['error'], Status.fromJson),
      labels: decodeMap(json['labels']),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (studySpec != null) 'studySpec': studySpec!.toJson(),
      if (maxTrialCount != null) 'maxTrialCount': maxTrialCount,
      if (parallelTrialCount != null) 'parallelTrialCount': parallelTrialCount,
      if (maxFailedTrialCount != null)
        'maxFailedTrialCount': maxFailedTrialCount,
      if (trialJobSpec != null) 'trialJobSpec': trialJobSpec!.toJson(),
      if (trials != null) 'trials': encodeList(trials),
      if (state != null) 'state': state!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (labels != null) 'labels': labels,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (maxTrialCount != null) 'maxTrialCount=$maxTrialCount',
      if (parallelTrialCount != null) 'parallelTrialCount=$parallelTrialCount',
      if (maxFailedTrialCount != null)
        'maxFailedTrialCount=$maxFailedTrialCount',
      if (state != null) 'state=$state',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'HyperparameterTuningJob($contents)';
  }
}

/// A representation of a collection of database items organized in a way that
/// allows for approximate nearest neighbor (a.k.a ANN) algorithms search.
final class Index extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Index';

  /// Output only. The resource name of the Index.
  final String? name;

  /// Required. The display name of the Index.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// The description of the Index.
  final String? description;

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// additional information about the Index, that is specific to it. Unset if
  /// the Index does not have any additional information. The schema is defined
  /// as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String? metadataSchemaUri;

  /// An additional information about the Index; the schema of the metadata can
  /// be found in
  /// `metadata_schema`.
  final protobuf.Value? metadata;

  /// Output only. The pointers to DeployedIndexes created from this Index.
  /// An Index can be only deleted if all its DeployedIndexes had been undeployed
  /// first.
  final List<DeployedIndexRef>? deployedIndexes;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize your Indexes.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Output only. Timestamp when this Index was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Index was most recently updated.
  /// This also includes any update to the contents of the Index.
  /// Note that Operations working on this Index may have their
  /// [Operations.metadata.generic_metadata.update_time]
  /// [google.cloud.aiplatform.v1beta1.GenericOperationMetadata.update_time] a
  /// little after the value of this timestamp, yet that does not mean their
  /// results are not already reflected in the Index. Result of any successfully
  /// completed Operation on the Index is reflected in it.
  final protobuf.Timestamp? updateTime;

  /// Output only. Stats of the index resource.
  final IndexStats? indexStats;

  /// Immutable. The update method to use with this Index. If not set,
  /// BATCH_UPDATE will be used by default.
  final Index_IndexUpdateMethod? indexUpdateMethod;

  /// Immutable. Customer-managed encryption key spec for an Index. If set, this
  /// Index and all sub-resources of this Index will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  Index({
    this.name,
    this.displayName,
    this.description,
    this.metadataSchemaUri,
    this.metadata,
    this.deployedIndexes,
    this.etag,
    this.labels,
    this.createTime,
    this.updateTime,
    this.indexStats,
    this.indexUpdateMethod,
    this.encryptionSpec,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory Index.fromJson(Map<String, dynamic> json) {
    return Index(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      metadataSchemaUri: json['metadataSchemaUri'],
      metadata: decodeCustom(json['metadata'], protobuf.Value.fromJson),
      deployedIndexes: decodeListMessage(
        json['deployedIndexes'],
        DeployedIndexRef.fromJson,
      ),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      indexStats: decode(json['indexStats'], IndexStats.fromJson),
      indexUpdateMethod: decodeEnum(
        json['indexUpdateMethod'],
        Index_IndexUpdateMethod.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (deployedIndexes != null)
        'deployedIndexes': encodeList(deployedIndexes),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (indexStats != null) 'indexStats': indexStats!.toJson(),
      if (indexUpdateMethod != null)
        'indexUpdateMethod': indexUpdateMethod!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (metadataSchemaUri != null) 'metadataSchemaUri=$metadataSchemaUri',
      if (etag != null) 'etag=$etag',
      if (indexUpdateMethod != null) 'indexUpdateMethod=$indexUpdateMethod',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Index($contents)';
  }
}

/// The update method of an Index.
final class Index_IndexUpdateMethod extends protobuf.ProtoEnum {
  /// Should not be used.
  static const indexUpdateMethodUnspecified = Index_IndexUpdateMethod(
    'INDEX_UPDATE_METHOD_UNSPECIFIED',
  );

  /// BatchUpdate: user can call UpdateIndex with files on Cloud Storage of
  /// Datapoints to update.
  static const batchUpdate = Index_IndexUpdateMethod('BATCH_UPDATE');

  /// StreamUpdate: user can call UpsertDatapoints/DeleteDatapoints to update
  /// the Index and the updates will be applied in corresponding
  /// DeployedIndexes in nearly real-time.
  static const streamUpdate = Index_IndexUpdateMethod('STREAM_UPDATE');

  const Index_IndexUpdateMethod(super.value);

  factory Index_IndexUpdateMethod.fromJson(String json) =>
      Index_IndexUpdateMethod(json);

  @override
  String toString() => 'IndexUpdateMethod.$value';
}

/// A datapoint of Index.
final class IndexDatapoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint';

  /// Required. Unique identifier of the datapoint.
  final String? datapointId;

  /// Required. Feature embedding vector for dense index. An array of numbers
  /// with the length of [NearestNeighborSearchConfig.dimensions].
  final List<double>? featureVector;

  /// Optional. Feature embedding vector for sparse index.
  final IndexDatapoint_SparseEmbedding? sparseEmbedding;

  /// Optional. List of Restrict of the datapoint, used to perform "restricted
  /// searches" where boolean rule are used to filter the subset of the database
  /// eligible for matching. This uses categorical tokens. See:
  /// https://cloud.google.com/vertex-ai/docs/matching-engine/filtering
  final List<IndexDatapoint_Restriction>? restricts;

  /// Optional. List of Restrict of the datapoint, used to perform "restricted
  /// searches" where boolean rule are used to filter the subset of the database
  /// eligible for matching. This uses numeric comparisons.
  final List<IndexDatapoint_NumericRestriction>? numericRestricts;

  /// Optional. CrowdingTag of the datapoint, the number of neighbors to return
  /// in each crowding can be configured during query.
  final IndexDatapoint_CrowdingTag? crowdingTag;

  /// Optional. The key-value map of additional metadata for the datapoint.
  final protobuf.Struct? embeddingMetadata;

  IndexDatapoint({
    this.datapointId,
    this.featureVector,
    this.sparseEmbedding,
    this.restricts,
    this.numericRestricts,
    this.crowdingTag,
    this.embeddingMetadata,
  }) : super(fullyQualifiedName);

  factory IndexDatapoint.fromJson(Map<String, dynamic> json) {
    return IndexDatapoint(
      datapointId: json['datapointId'],
      featureVector: decodeList(json['featureVector']),
      sparseEmbedding: decode(
        json['sparseEmbedding'],
        IndexDatapoint_SparseEmbedding.fromJson,
      ),
      restricts: decodeListMessage(
        json['restricts'],
        IndexDatapoint_Restriction.fromJson,
      ),
      numericRestricts: decodeListMessage(
        json['numericRestricts'],
        IndexDatapoint_NumericRestriction.fromJson,
      ),
      crowdingTag: decode(
        json['crowdingTag'],
        IndexDatapoint_CrowdingTag.fromJson,
      ),
      embeddingMetadata: decodeCustom(
        json['embeddingMetadata'],
        protobuf.Struct.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (datapointId != null) 'datapointId': datapointId,
      if (featureVector != null) 'featureVector': featureVector,
      if (sparseEmbedding != null) 'sparseEmbedding': sparseEmbedding!.toJson(),
      if (restricts != null) 'restricts': encodeList(restricts),
      if (numericRestricts != null)
        'numericRestricts': encodeList(numericRestricts),
      if (crowdingTag != null) 'crowdingTag': crowdingTag!.toJson(),
      if (embeddingMetadata != null)
        'embeddingMetadata': embeddingMetadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (datapointId != null) 'datapointId=$datapointId',
    ].join(',');
    return 'IndexDatapoint($contents)';
  }
}

/// Feature embedding vector for sparse index. An array of numbers whose values
/// are located in the specified dimensions.
final class IndexDatapoint_SparseEmbedding extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint.SparseEmbedding';

  /// Required. The list of embedding values of the sparse vector.
  final List<double>? values;

  /// Required. The list of indexes for the embedding values of the sparse
  /// vector.
  final List<int>? dimensions;

  IndexDatapoint_SparseEmbedding({this.values, this.dimensions})
    : super(fullyQualifiedName);

  factory IndexDatapoint_SparseEmbedding.fromJson(Map<String, dynamic> json) {
    return IndexDatapoint_SparseEmbedding(
      values: decodeList(json['values']),
      dimensions: decodeList(json['dimensions']),
    );
  }

  @override
  Object toJson() {
    return {
      if (values != null) 'values': values,
      if (dimensions != null) 'dimensions': dimensions,
    };
  }

  @override
  String toString() => 'SparseEmbedding()';
}

/// Restriction of a datapoint which describe its attributes(tokens) from each
/// of several attribute categories(namespaces).
final class IndexDatapoint_Restriction extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint.Restriction';

  /// The namespace of this restriction. e.g.: color.
  final String? namespace;

  /// The attributes to allow in this namespace. e.g.: 'red'
  final List<String>? allowList;

  /// The attributes to deny in this namespace. e.g.: 'blue'
  final List<String>? denyList;

  IndexDatapoint_Restriction({this.namespace, this.allowList, this.denyList})
    : super(fullyQualifiedName);

  factory IndexDatapoint_Restriction.fromJson(Map<String, dynamic> json) {
    return IndexDatapoint_Restriction(
      namespace: json['namespace'],
      allowList: decodeList(json['allowList']),
      denyList: decodeList(json['denyList']),
    );
  }

  @override
  Object toJson() {
    return {
      if (namespace != null) 'namespace': namespace,
      if (allowList != null) 'allowList': allowList,
      if (denyList != null) 'denyList': denyList,
    };
  }

  @override
  String toString() {
    final contents = [if (namespace != null) 'namespace=$namespace'].join(',');
    return 'Restriction($contents)';
  }
}

/// This field allows restricts to be based on numeric comparisons rather
/// than categorical tokens.
final class IndexDatapoint_NumericRestriction extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint.NumericRestriction';

  /// Represents 64 bit integer.
  final int? valueInt;

  /// Represents 32 bit float.
  final double? valueFloat;

  /// Represents 64 bit float.
  final double? valueDouble;

  /// The namespace of this restriction. e.g.: cost.
  final String? namespace;

  /// This MUST be specified for queries and must NOT be specified for
  /// datapoints.
  final IndexDatapoint_NumericRestriction_Operator? op;

  IndexDatapoint_NumericRestriction({
    this.valueInt,
    this.valueFloat,
    this.valueDouble,
    this.namespace,
    this.op,
  }) : super(fullyQualifiedName);

  factory IndexDatapoint_NumericRestriction.fromJson(
    Map<String, dynamic> json,
  ) {
    return IndexDatapoint_NumericRestriction(
      valueInt: decodeInt64(json['valueInt']),
      valueFloat: decodeDouble(json['valueFloat']),
      valueDouble: decodeDouble(json['valueDouble']),
      namespace: json['namespace'],
      op: decodeEnum(
        json['op'],
        IndexDatapoint_NumericRestriction_Operator.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (valueInt != null) 'valueInt': encodeInt64(valueInt),
      if (valueFloat != null) 'valueFloat': encodeDouble(valueFloat),
      if (valueDouble != null) 'valueDouble': encodeDouble(valueDouble),
      if (namespace != null) 'namespace': namespace,
      if (op != null) 'op': op!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (valueInt != null) 'valueInt=$valueInt',
      if (valueFloat != null) 'valueFloat=$valueFloat',
      if (valueDouble != null) 'valueDouble=$valueDouble',
      if (namespace != null) 'namespace=$namespace',
      if (op != null) 'op=$op',
    ].join(',');
    return 'NumericRestriction($contents)';
  }
}

/// Which comparison operator to use.  Should be specified for queries only;
/// specifying this for a datapoint is an error.
///
/// Datapoints for which Operator is true relative to the query's Value
/// field will be allowlisted.
final class IndexDatapoint_NumericRestriction_Operator
    extends protobuf.ProtoEnum {
  /// Default value of the enum.
  static const operatorUnspecified = IndexDatapoint_NumericRestriction_Operator(
    'OPERATOR_UNSPECIFIED',
  );

  /// Datapoints are eligible iff their value is < the query's.
  static const less = IndexDatapoint_NumericRestriction_Operator('LESS');

  /// Datapoints are eligible iff their value is <= the query's.
  static const lessEqual = IndexDatapoint_NumericRestriction_Operator(
    'LESS_EQUAL',
  );

  /// Datapoints are eligible iff their value is == the query's.
  static const equal = IndexDatapoint_NumericRestriction_Operator('EQUAL');

  /// Datapoints are eligible iff their value is >= the query's.
  static const greaterEqual = IndexDatapoint_NumericRestriction_Operator(
    'GREATER_EQUAL',
  );

  /// Datapoints are eligible iff their value is > the query's.
  static const greater = IndexDatapoint_NumericRestriction_Operator('GREATER');

  /// Datapoints are eligible iff their value is != the query's.
  static const notEqual = IndexDatapoint_NumericRestriction_Operator(
    'NOT_EQUAL',
  );

  const IndexDatapoint_NumericRestriction_Operator(super.value);

  factory IndexDatapoint_NumericRestriction_Operator.fromJson(String json) =>
      IndexDatapoint_NumericRestriction_Operator(json);

  @override
  String toString() => 'Operator.$value';
}

/// Crowding tag is a constraint on a neighbor list produced by nearest
/// neighbor search requiring that no more than some value k' of the k
/// neighbors returned have the same value of crowding_attribute.
final class IndexDatapoint_CrowdingTag extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexDatapoint.CrowdingTag';

  /// The attribute value used for crowding.  The maximum number of neighbors
  /// to return per crowding attribute value
  /// (per_crowding_attribute_num_neighbors) is configured per-query. This
  /// field is ignored if per_crowding_attribute_num_neighbors is larger than
  /// the total number of neighbors to return for a given query.
  final String? crowdingAttribute;

  IndexDatapoint_CrowdingTag({this.crowdingAttribute})
    : super(fullyQualifiedName);

  factory IndexDatapoint_CrowdingTag.fromJson(Map<String, dynamic> json) {
    return IndexDatapoint_CrowdingTag(
      crowdingAttribute: json['crowdingAttribute'],
    );
  }

  @override
  Object toJson() {
    return {
      if (crowdingAttribute != null) 'crowdingAttribute': crowdingAttribute,
    };
  }

  @override
  String toString() {
    final contents = [
      if (crowdingAttribute != null) 'crowdingAttribute=$crowdingAttribute',
    ].join(',');
    return 'CrowdingTag($contents)';
  }
}

/// Stats of the Index.
final class IndexStats extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexStats';

  /// Output only. The number of dense vectors in the Index.
  final int? vectorsCount;

  /// Output only. The number of sparse vectors in the Index.
  final int? sparseVectorsCount;

  /// Output only. The number of shards in the Index.
  final int? shardsCount;

  IndexStats({this.vectorsCount, this.sparseVectorsCount, this.shardsCount})
    : super(fullyQualifiedName);

  factory IndexStats.fromJson(Map<String, dynamic> json) {
    return IndexStats(
      vectorsCount: decodeInt64(json['vectorsCount']),
      sparseVectorsCount: decodeInt64(json['sparseVectorsCount']),
      shardsCount: json['shardsCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (vectorsCount != null) 'vectorsCount': encodeInt64(vectorsCount),
      if (sparseVectorsCount != null)
        'sparseVectorsCount': encodeInt64(sparseVectorsCount),
      if (shardsCount != null) 'shardsCount': shardsCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (vectorsCount != null) 'vectorsCount=$vectorsCount',
      if (sparseVectorsCount != null) 'sparseVectorsCount=$sparseVectorsCount',
      if (shardsCount != null) 'shardsCount=$shardsCount',
    ].join(',');
    return 'IndexStats($contents)';
  }
}

/// Indexes are deployed into it. An IndexEndpoint can have multiple
/// DeployedIndexes.
final class IndexEndpoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexEndpoint';

  /// Output only. The resource name of the IndexEndpoint.
  final String? name;

  /// Required. The display name of the IndexEndpoint.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// The description of the IndexEndpoint.
  final String? description;

  /// Output only. The indexes deployed in this endpoint.
  final List<DeployedIndex>? deployedIndexes;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize your IndexEndpoints.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Output only. Timestamp when this IndexEndpoint was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this IndexEndpoint was last updated.
  /// This timestamp is not updated when the endpoint's DeployedIndexes are
  /// updated, e.g. due to updates of the original Indexes they are the
  /// deployments of.
  final protobuf.Timestamp? updateTime;

  /// Optional. The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks)
  /// to which the IndexEndpoint should be peered.
  ///
  /// Private services access must already be configured for the network. If left
  /// unspecified, the Endpoint is not peered with any network.
  ///
  /// `network` and
  /// `private_service_connect_config`
  /// are mutually exclusive.
  ///
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/insert):
  /// `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in '12345', and {network} is
  /// network name.
  final String? network;

  /// Optional. Deprecated: If true, expose the IndexEndpoint via private service
  /// connect.
  ///
  /// Only one of the fields,
  /// `network` or
  /// `enable_private_service_connect`,
  /// can be set.
  final bool? enablePrivateServiceConnect;

  /// Optional. Configuration for private service connect.
  ///
  /// `network` and
  /// `private_service_connect_config`
  /// are mutually exclusive.
  final PrivateServiceConnectConfig? privateServiceConnectConfig;

  /// Optional. If true, the deployed index will be accessible through public
  /// endpoint.
  final bool? publicEndpointEnabled;

  /// Output only. If
  /// `public_endpoint_enabled`
  /// is true, this field will be populated with the domain name to use for this
  /// index endpoint.
  final String? publicEndpointDomainName;

  /// Immutable. Customer-managed encryption key spec for an IndexEndpoint. If
  /// set, this IndexEndpoint and all sub-resources of this IndexEndpoint will be
  /// secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  IndexEndpoint({
    this.name,
    this.displayName,
    this.description,
    this.deployedIndexes,
    this.etag,
    this.labels,
    this.createTime,
    this.updateTime,
    this.network,
    this.enablePrivateServiceConnect,
    this.privateServiceConnectConfig,
    this.publicEndpointEnabled,
    this.publicEndpointDomainName,
    this.encryptionSpec,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory IndexEndpoint.fromJson(Map<String, dynamic> json) {
    return IndexEndpoint(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      deployedIndexes: decodeListMessage(
        json['deployedIndexes'],
        DeployedIndex.fromJson,
      ),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      network: json['network'],
      enablePrivateServiceConnect: json['enablePrivateServiceConnect'],
      privateServiceConnectConfig: decode(
        json['privateServiceConnectConfig'],
        PrivateServiceConnectConfig.fromJson,
      ),
      publicEndpointEnabled: json['publicEndpointEnabled'],
      publicEndpointDomainName: json['publicEndpointDomainName'],
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (deployedIndexes != null)
        'deployedIndexes': encodeList(deployedIndexes),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (network != null) 'network': network,
      if (enablePrivateServiceConnect != null)
        'enablePrivateServiceConnect': enablePrivateServiceConnect,
      if (privateServiceConnectConfig != null)
        'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
      if (publicEndpointEnabled != null)
        'publicEndpointEnabled': publicEndpointEnabled,
      if (publicEndpointDomainName != null)
        'publicEndpointDomainName': publicEndpointDomainName,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (etag != null) 'etag=$etag',
      if (network != null) 'network=$network',
      if (enablePrivateServiceConnect != null)
        'enablePrivateServiceConnect=$enablePrivateServiceConnect',
      if (publicEndpointEnabled != null)
        'publicEndpointEnabled=$publicEndpointEnabled',
      if (publicEndpointDomainName != null)
        'publicEndpointDomainName=$publicEndpointDomainName',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'IndexEndpoint($contents)';
  }
}

/// A deployment of an Index. IndexEndpoints contain one or more DeployedIndexes.
final class DeployedIndex extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedIndex';

  /// Required. The user specified ID of the DeployedIndex.
  /// The ID can be up to 128 characters long and must start with a letter and
  /// only contain letters, numbers, and underscores.
  /// The ID must be unique within the project it is created in.
  final String? id;

  /// Required. The name of the Index this is the deployment of.
  /// We may refer to this Index as the DeployedIndex's "original" Index.
  final String? index;

  /// The display name of the DeployedIndex. If not provided upon creation,
  /// the Index's display_name is used.
  final String? displayName;

  /// Output only. Timestamp when the DeployedIndex was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Provides paths for users to send requests directly to the
  /// deployed index services running on Cloud via private services access. This
  /// field is populated if
  /// `network` is
  /// configured.
  final IndexPrivateEndpoints? privateEndpoints;

  /// Output only. The DeployedIndex may depend on various data on its original
  /// Index. Additionally when certain changes to the original Index are being
  /// done (e.g. when what the Index contains is being changed) the DeployedIndex
  /// may be asynchronously updated in the background to reflect these changes.
  /// If this timestamp's value is at least the
  /// `Index.update_time` of
  /// the original Index, it means that this DeployedIndex and the original Index
  /// are in sync. If this timestamp is older, then to see which updates this
  /// DeployedIndex already contains (and which it does not), one must
  /// `list` the operations that
  /// are running on the original Index. Only the successfully completed
  /// Operations with
  /// `update_time`
  /// equal or before this sync time are contained in this DeployedIndex.
  final protobuf.Timestamp? indexSyncTime;

  /// Optional. A description of resources that the DeployedIndex uses, which to
  /// large degree are decided by Vertex AI, and optionally allows only a modest
  /// additional configuration.
  /// If min_replica_count is not set, the default value is 2 (we don't provide
  /// SLA when min_replica_count=1). If max_replica_count is not set, the
  /// default value is min_replica_count. The max allowed replica count is
  /// 1000.
  final AutomaticResources? automaticResources;

  /// Optional. A description of resources that are dedicated to the
  /// DeployedIndex, and that need a higher degree of manual configuration. The
  /// field min_replica_count must be set to a value strictly greater than 0, or
  /// else validation will fail. We don't provide SLA when min_replica_count=1.
  /// If max_replica_count is not set, the default value is min_replica_count.
  /// The max allowed replica count is 1000.
  ///
  /// Available machine types for SMALL shard:
  /// e2-standard-2 and all machine types available for MEDIUM and LARGE shard.
  ///
  /// Available machine types for MEDIUM shard:
  /// e2-standard-16 and all machine types available for LARGE shard.
  ///
  /// Available machine types for LARGE shard:
  /// e2-highmem-16, n2d-standard-32.
  ///
  /// n1-standard-16 and n1-standard-32 are still available, but we recommend
  /// e2-standard-16 and e2-highmem-16 for cost efficiency.
  final DedicatedResources? dedicatedResources;

  /// Optional. If true, private endpoint's access logs are sent to Cloud
  /// Logging.
  ///
  /// These logs are like standard server access logs, containing
  /// information like timestamp and latency for each MatchRequest.
  ///
  /// Note that logs may incur a cost, especially if the deployed
  /// index receives a high queries per second rate (QPS).
  /// Estimate your costs before enabling this option.
  final bool? enableAccessLogging;

  /// Optional. If true, logs to Cloud Logging errors relating to datapoint
  /// upserts.
  ///
  /// Under normal operation conditions, these log entries should be very rare.
  /// However, if incompatible datapoint updates are being uploaded to an index,
  /// a high volume of log entries may be generated in a short period of time.
  ///
  /// Note that logs may incur a cost, especially if the deployed index receives
  /// a high volume of datapoint upserts. Estimate your costs before enabling
  /// this option.
  final bool? enableDatapointUpsertLogging;

  /// Optional. If set, the authentication is enabled for the private endpoint.
  final DeployedIndexAuthConfig? deployedIndexAuthConfig;

  /// Optional. A list of reserved ip ranges under the VPC network that can be
  /// used for this DeployedIndex.
  ///
  /// If set, we will deploy the index within the provided ip ranges. Otherwise,
  /// the index might be deployed to any ip ranges under the provided VPC
  /// network.
  ///
  /// The value should be the name of the address
  /// (https://cloud.google.com/compute/docs/reference/rest/v1/addresses)
  /// Example: ['vertex-ai-ip-range'].
  ///
  /// For more information about subnets and network IP ranges, please see
  /// https://cloud.google.com/vpc/docs/subnets#manually_created_subnet_ip_ranges.
  final List<String>? reservedIpRanges;

  /// Optional. The deployment group can be no longer than 64 characters (eg:
  /// 'test', 'prod'). If not set, we will use the 'default' deployment group.
  ///
  /// Creating `deployment_groups` with `reserved_ip_ranges` is a recommended
  /// practice when the peered network has multiple peering ranges. This creates
  /// your deployments from predictable IP spaces for easier traffic
  /// administration. Also, one deployment_group (except 'default') can only be
  /// used with the same reserved_ip_ranges which means if the deployment_group
  /// has been used with reserved_ip_ranges: [a, b, c], using it with [a, b] or
  /// [d, e] is disallowed.
  ///
  /// Note: we only support up to 5 deployment groups(not including 'default').
  final String? deploymentGroup;

  /// Optional. If set for PSC deployed index, PSC connection will be
  /// automatically created after deployment is done and the endpoint information
  /// is populated in private_endpoints.psc_automated_endpoints.
  final List<PscautomationConfig>? pscAutomationConfigs;

  DeployedIndex({
    this.id,
    this.index,
    this.displayName,
    this.createTime,
    this.privateEndpoints,
    this.indexSyncTime,
    this.automaticResources,
    this.dedicatedResources,
    this.enableAccessLogging,
    this.enableDatapointUpsertLogging,
    this.deployedIndexAuthConfig,
    this.reservedIpRanges,
    this.deploymentGroup,
    this.pscAutomationConfigs,
  }) : super(fullyQualifiedName);

  factory DeployedIndex.fromJson(Map<String, dynamic> json) {
    return DeployedIndex(
      id: json['id'],
      index: json['index'],
      displayName: json['displayName'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      privateEndpoints: decode(
        json['privateEndpoints'],
        IndexPrivateEndpoints.fromJson,
      ),
      indexSyncTime: decodeCustom(
        json['indexSyncTime'],
        protobuf.Timestamp.fromJson,
      ),
      automaticResources: decode(
        json['automaticResources'],
        AutomaticResources.fromJson,
      ),
      dedicatedResources: decode(
        json['dedicatedResources'],
        DedicatedResources.fromJson,
      ),
      enableAccessLogging: json['enableAccessLogging'],
      enableDatapointUpsertLogging: json['enableDatapointUpsertLogging'],
      deployedIndexAuthConfig: decode(
        json['deployedIndexAuthConfig'],
        DeployedIndexAuthConfig.fromJson,
      ),
      reservedIpRanges: decodeList(json['reservedIpRanges']),
      deploymentGroup: json['deploymentGroup'],
      pscAutomationConfigs: decodeListMessage(
        json['pscAutomationConfigs'],
        PscautomationConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (index != null) 'index': index,
      if (displayName != null) 'displayName': displayName,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (privateEndpoints != null)
        'privateEndpoints': privateEndpoints!.toJson(),
      if (indexSyncTime != null) 'indexSyncTime': indexSyncTime!.toJson(),
      if (automaticResources != null)
        'automaticResources': automaticResources!.toJson(),
      if (dedicatedResources != null)
        'dedicatedResources': dedicatedResources!.toJson(),
      if (enableAccessLogging != null)
        'enableAccessLogging': enableAccessLogging,
      if (enableDatapointUpsertLogging != null)
        'enableDatapointUpsertLogging': enableDatapointUpsertLogging,
      if (deployedIndexAuthConfig != null)
        'deployedIndexAuthConfig': deployedIndexAuthConfig!.toJson(),
      if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges,
      if (deploymentGroup != null) 'deploymentGroup': deploymentGroup,
      if (pscAutomationConfigs != null)
        'pscAutomationConfigs': encodeList(pscAutomationConfigs),
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      if (index != null) 'index=$index',
      if (displayName != null) 'displayName=$displayName',
      if (enableAccessLogging != null)
        'enableAccessLogging=$enableAccessLogging',
      if (enableDatapointUpsertLogging != null)
        'enableDatapointUpsertLogging=$enableDatapointUpsertLogging',
      if (deploymentGroup != null) 'deploymentGroup=$deploymentGroup',
    ].join(',');
    return 'DeployedIndex($contents)';
  }
}

/// Used to set up the auth on the DeployedIndex's private endpoint.
final class DeployedIndexAuthConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedIndexAuthConfig';

  /// Defines the authentication provider that the DeployedIndex uses.
  final DeployedIndexAuthConfig_AuthProvider? authProvider;

  DeployedIndexAuthConfig({this.authProvider}) : super(fullyQualifiedName);

  factory DeployedIndexAuthConfig.fromJson(Map<String, dynamic> json) {
    return DeployedIndexAuthConfig(
      authProvider: decode(
        json['authProvider'],
        DeployedIndexAuthConfig_AuthProvider.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (authProvider != null) 'authProvider': authProvider!.toJson()};
  }

  @override
  String toString() => 'DeployedIndexAuthConfig()';
}

/// Configuration for an authentication provider, including support for
/// [JSON Web Token
/// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
final class DeployedIndexAuthConfig_AuthProvider extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployedIndexAuthConfig.AuthProvider';

  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted.
  final List<String>? audiences;

  /// A list of allowed JWT issuers. Each entry must be a valid Google
  /// service account, in the following format:
  ///
  /// `service-account-name@project-id.iam.gserviceaccount.com`
  final List<String>? allowedIssuers;

  DeployedIndexAuthConfig_AuthProvider({this.audiences, this.allowedIssuers})
    : super(fullyQualifiedName);

  factory DeployedIndexAuthConfig_AuthProvider.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeployedIndexAuthConfig_AuthProvider(
      audiences: decodeList(json['audiences']),
      allowedIssuers: decodeList(json['allowedIssuers']),
    );
  }

  @override
  Object toJson() {
    return {
      if (audiences != null) 'audiences': audiences,
      if (allowedIssuers != null) 'allowedIssuers': allowedIssuers,
    };
  }

  @override
  String toString() => 'AuthProvider()';
}

/// IndexPrivateEndpoints proto is used to provide paths for users to send
/// requests via private endpoints (e.g. private service access, private service
/// connect).
/// To send request via private service access, use match_grpc_address.
/// To send request via private service connect, use service_attachment.
final class IndexPrivateEndpoints extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.IndexPrivateEndpoints';

  /// Output only. The ip address used to send match gRPC requests.
  final String? matchGrpcAddress;

  /// Output only. The name of the service attachment resource. Populated if
  /// private service connect is enabled.
  final String? serviceAttachment;

  /// Output only. PscAutomatedEndpoints is populated if private service connect
  /// is enabled if PscAutomatedConfig is set.
  final List<PscAutomatedEndpoints>? pscAutomatedEndpoints;

  IndexPrivateEndpoints({
    this.matchGrpcAddress,
    this.serviceAttachment,
    this.pscAutomatedEndpoints,
  }) : super(fullyQualifiedName);

  factory IndexPrivateEndpoints.fromJson(Map<String, dynamic> json) {
    return IndexPrivateEndpoints(
      matchGrpcAddress: json['matchGrpcAddress'],
      serviceAttachment: json['serviceAttachment'],
      pscAutomatedEndpoints: decodeListMessage(
        json['pscAutomatedEndpoints'],
        PscAutomatedEndpoints.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (matchGrpcAddress != null) 'matchGrpcAddress': matchGrpcAddress,
      if (serviceAttachment != null) 'serviceAttachment': serviceAttachment,
      if (pscAutomatedEndpoints != null)
        'pscAutomatedEndpoints': encodeList(pscAutomatedEndpoints),
    };
  }

  @override
  String toString() {
    final contents = [
      if (matchGrpcAddress != null) 'matchGrpcAddress=$matchGrpcAddress',
      if (serviceAttachment != null) 'serviceAttachment=$serviceAttachment',
    ].join(',');
    return 'IndexPrivateEndpoints($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.CreateIndexEndpoint`.
final class CreateIndexEndpointRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateIndexEndpointRequest';

  /// Required. The resource name of the Location to create the IndexEndpoint in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The IndexEndpoint to create.
  final IndexEndpoint indexEndpoint;

  CreateIndexEndpointRequest({
    required this.parent,
    required this.indexEndpoint,
  }) : super(fullyQualifiedName);

  factory CreateIndexEndpointRequest.fromJson(Map<String, dynamic> json) {
    return CreateIndexEndpointRequest(
      parent: json['parent'],
      indexEndpoint: decode(json['indexEndpoint'], IndexEndpoint.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'indexEndpoint': indexEndpoint.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateIndexEndpointRequest($contents)';
  }
}

/// Runtime operation information for
/// `IndexEndpointService.CreateIndexEndpoint`.
final class CreateIndexEndpointOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateIndexEndpointOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateIndexEndpointOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateIndexEndpointOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateIndexEndpointOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateIndexEndpointOperationMetadata()';
}

/// Request message for
/// `IndexEndpointService.GetIndexEndpoint`
final class GetIndexEndpointRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetIndexEndpointRequest';

  /// Required. The name of the IndexEndpoint resource.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String name;

  GetIndexEndpointRequest({required this.name}) : super(fullyQualifiedName);

  factory GetIndexEndpointRequest.fromJson(Map<String, dynamic> json) {
    return GetIndexEndpointRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetIndexEndpointRequest($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.ListIndexEndpoints`.
final class ListIndexEndpointsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListIndexEndpointsRequest';

  /// Required. The resource name of the Location from which to list the
  /// IndexEndpoints. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `index_endpoint` supports = and !=. `index_endpoint` represents the
  ///      IndexEndpoint ID, ie. the last segment of the IndexEndpoint's
  ///      `resourcename`.
  ///   * `display_name` supports =, != and regex()
  ///             (uses [re2](https://github.com/google/re2/wiki/Syntax) syntax)
  ///   * `labels` supports general map functions that is:
  ///             `labels.key=value` - key:value equality
  ///             `labels.key:* or labels:key - key existence
  ///              A key including a space must be quoted. `labels."a key"`.
  ///
  /// Some examples:
  ///   * `index_endpoint="1"`
  ///   * `display_name="myDisplayName"`
  ///   * `regex(display_name, "^A") -> The display name starts with an A.
  ///   * `labels.myKey="myValue"`
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListIndexEndpointsResponse.next_page_token`
  /// of the previous
  /// `IndexEndpointService.ListIndexEndpoints`
  /// call.
  final String? pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListIndexEndpointsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListIndexEndpointsRequest.fromJson(Map<String, dynamic> json) {
    return ListIndexEndpointsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListIndexEndpointsRequest($contents)';
  }
}

/// Response message for
/// `IndexEndpointService.ListIndexEndpoints`.
final class ListIndexEndpointsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListIndexEndpointsResponse';

  /// List of IndexEndpoints in the requested page.
  final List<IndexEndpoint>? indexEndpoints;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListIndexEndpointsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListIndexEndpointsResponse({this.indexEndpoints, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListIndexEndpointsResponse.fromJson(Map<String, dynamic> json) {
    return ListIndexEndpointsResponse(
      indexEndpoints: decodeListMessage(
        json['indexEndpoints'],
        IndexEndpoint.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (indexEndpoints != null) 'indexEndpoints': encodeList(indexEndpoints),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListIndexEndpointsResponse($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.UpdateIndexEndpoint`.
final class UpdateIndexEndpointRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateIndexEndpointRequest';

  /// Required. The IndexEndpoint which replaces the resource on the server.
  final IndexEndpoint indexEndpoint;

  /// Required. The update mask applies to the resource. See
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateIndexEndpointRequest({required this.indexEndpoint, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateIndexEndpointRequest.fromJson(Map<String, dynamic> json) {
    return UpdateIndexEndpointRequest(
      indexEndpoint: decode(json['indexEndpoint'], IndexEndpoint.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'indexEndpoint': indexEndpoint.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateIndexEndpointRequest()';
}

/// Request message for
/// `IndexEndpointService.DeleteIndexEndpoint`.
final class DeleteIndexEndpointRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteIndexEndpointRequest';

  /// Required. The name of the IndexEndpoint resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String name;

  DeleteIndexEndpointRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteIndexEndpointRequest.fromJson(Map<String, dynamic> json) {
    return DeleteIndexEndpointRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteIndexEndpointRequest($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.DeployIndex`.
final class DeployIndexRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployIndexRequest';

  /// Required. The name of the IndexEndpoint resource into which to deploy an
  /// Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// Required. The DeployedIndex to be created within the IndexEndpoint.
  final DeployedIndex? deployedIndex;

  DeployIndexRequest({required this.indexEndpoint, this.deployedIndex})
    : super(fullyQualifiedName);

  factory DeployIndexRequest.fromJson(Map<String, dynamic> json) {
    return DeployIndexRequest(
      indexEndpoint: json['indexEndpoint'],
      deployedIndex: decode(json['deployedIndex'], DeployedIndex.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'indexEndpoint': indexEndpoint,
      if (deployedIndex != null) 'deployedIndex': deployedIndex!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['indexEndpoint=$indexEndpoint'].join(',');
    return 'DeployIndexRequest($contents)';
  }
}

/// Response message for
/// `IndexEndpointService.DeployIndex`.
final class DeployIndexResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployIndexResponse';

  /// The DeployedIndex that had been deployed in the IndexEndpoint.
  final DeployedIndex? deployedIndex;

  DeployIndexResponse({this.deployedIndex}) : super(fullyQualifiedName);

  factory DeployIndexResponse.fromJson(Map<String, dynamic> json) {
    return DeployIndexResponse(
      deployedIndex: decode(json['deployedIndex'], DeployedIndex.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (deployedIndex != null) 'deployedIndex': deployedIndex!.toJson(),
    };
  }

  @override
  String toString() => 'DeployIndexResponse()';
}

/// Runtime operation information for
/// `IndexEndpointService.DeployIndex`.
final class DeployIndexOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The unique index id specified by user
  final String? deployedIndexId;

  DeployIndexOperationMetadata({this.genericMetadata, this.deployedIndexId})
    : super(fullyQualifiedName);

  factory DeployIndexOperationMetadata.fromJson(Map<String, dynamic> json) {
    return DeployIndexOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      deployedIndexId: json['deployedIndexId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (deployedIndexId != null) 'deployedIndexId': deployedIndexId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (deployedIndexId != null) 'deployedIndexId=$deployedIndexId',
    ].join(',');
    return 'DeployIndexOperationMetadata($contents)';
  }
}

/// Request message for
/// `IndexEndpointService.UndeployIndex`.
final class UndeployIndexRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployIndexRequest';

  /// Required. The name of the IndexEndpoint resource from which to undeploy an
  /// Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// Required. The ID of the DeployedIndex to be undeployed from the
  /// IndexEndpoint.
  final String? deployedIndexId;

  UndeployIndexRequest({required this.indexEndpoint, this.deployedIndexId})
    : super(fullyQualifiedName);

  factory UndeployIndexRequest.fromJson(Map<String, dynamic> json) {
    return UndeployIndexRequest(
      indexEndpoint: json['indexEndpoint'],
      deployedIndexId: json['deployedIndexId'],
    );
  }

  @override
  Object toJson() {
    return {
      'indexEndpoint': indexEndpoint,
      if (deployedIndexId != null) 'deployedIndexId': deployedIndexId,
    };
  }

  @override
  String toString() {
    final contents = [
      'indexEndpoint=$indexEndpoint',
      if (deployedIndexId != null) 'deployedIndexId=$deployedIndexId',
    ].join(',');
    return 'UndeployIndexRequest($contents)';
  }
}

/// Response message for
/// `IndexEndpointService.UndeployIndex`.
final class UndeployIndexResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployIndexResponse';

  UndeployIndexResponse() : super(fullyQualifiedName);

  factory UndeployIndexResponse.fromJson(Map<String, dynamic> json) {
    return UndeployIndexResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'UndeployIndexResponse()';
}

/// Runtime operation information for
/// `IndexEndpointService.UndeployIndex`.
final class UndeployIndexOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UndeployIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UndeployIndexOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UndeployIndexOperationMetadata.fromJson(Map<String, dynamic> json) {
    return UndeployIndexOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UndeployIndexOperationMetadata()';
}

/// Request message for
/// `IndexEndpointService.MutateDeployedIndex`.
final class MutateDeployedIndexRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedIndexRequest';

  /// Required. The name of the IndexEndpoint resource into which to deploy an
  /// Index. Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// Required. The DeployedIndex to be updated within the IndexEndpoint.
  /// Currently, the updatable fields are `DeployedIndex`
  /// and `DeployedIndex`
  final DeployedIndex deployedIndex;

  MutateDeployedIndexRequest({
    required this.indexEndpoint,
    required this.deployedIndex,
  }) : super(fullyQualifiedName);

  factory MutateDeployedIndexRequest.fromJson(Map<String, dynamic> json) {
    return MutateDeployedIndexRequest(
      indexEndpoint: json['indexEndpoint'],
      deployedIndex: decode(json['deployedIndex'], DeployedIndex.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {
      'indexEndpoint': indexEndpoint,
      'deployedIndex': deployedIndex.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['indexEndpoint=$indexEndpoint'].join(',');
    return 'MutateDeployedIndexRequest($contents)';
  }
}

/// Response message for
/// `IndexEndpointService.MutateDeployedIndex`.
final class MutateDeployedIndexResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedIndexResponse';

  /// The DeployedIndex that had been updated in the IndexEndpoint.
  final DeployedIndex? deployedIndex;

  MutateDeployedIndexResponse({this.deployedIndex}) : super(fullyQualifiedName);

  factory MutateDeployedIndexResponse.fromJson(Map<String, dynamic> json) {
    return MutateDeployedIndexResponse(
      deployedIndex: decode(json['deployedIndex'], DeployedIndex.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (deployedIndex != null) 'deployedIndex': deployedIndex!.toJson(),
    };
  }

  @override
  String toString() => 'MutateDeployedIndexResponse()';
}

/// Runtime operation information for
/// `IndexEndpointService.MutateDeployedIndex`.
final class MutateDeployedIndexOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MutateDeployedIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The unique index id specified by user
  final String? deployedIndexId;

  MutateDeployedIndexOperationMetadata({
    this.genericMetadata,
    this.deployedIndexId,
  }) : super(fullyQualifiedName);

  factory MutateDeployedIndexOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return MutateDeployedIndexOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      deployedIndexId: json['deployedIndexId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (deployedIndexId != null) 'deployedIndexId': deployedIndexId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (deployedIndexId != null) 'deployedIndexId=$deployedIndexId',
    ].join(',');
    return 'MutateDeployedIndexOperationMetadata($contents)';
  }
}

/// Request message for
/// `IndexService.CreateIndex`.
final class CreateIndexRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateIndexRequest';

  /// Required. The resource name of the Location to create the Index in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Index to create.
  final Index index;

  CreateIndexRequest({required this.parent, required this.index})
    : super(fullyQualifiedName);

  factory CreateIndexRequest.fromJson(Map<String, dynamic> json) {
    return CreateIndexRequest(
      parent: json['parent'],
      index: decode(json['index'], Index.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'index': index.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateIndexRequest($contents)';
  }
}

/// Runtime operation information for
/// `IndexService.CreateIndex`.
final class CreateIndexOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The operation metadata with regard to Matching Engine Index operation.
  final NearestNeighborSearchOperationMetadata?
  nearestNeighborSearchOperationMetadata;

  CreateIndexOperationMetadata({
    this.genericMetadata,
    this.nearestNeighborSearchOperationMetadata,
  }) : super(fullyQualifiedName);

  factory CreateIndexOperationMetadata.fromJson(Map<String, dynamic> json) {
    return CreateIndexOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      nearestNeighborSearchOperationMetadata: decode(
        json['nearestNeighborSearchOperationMetadata'],
        NearestNeighborSearchOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (nearestNeighborSearchOperationMetadata != null)
        'nearestNeighborSearchOperationMetadata':
            nearestNeighborSearchOperationMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateIndexOperationMetadata()';
}

/// Request message for
/// `IndexService.GetIndex`
final class GetIndexRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetIndexRequest';

  /// Required. The name of the Index resource.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String name;

  GetIndexRequest({required this.name}) : super(fullyQualifiedName);

  factory GetIndexRequest.fromJson(Map<String, dynamic> json) {
    return GetIndexRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetIndexRequest($contents)';
  }
}

/// Request message for
/// `IndexService.ListIndexes`.
final class ListIndexesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListIndexesRequest';

  /// Required. The resource name of the Location from which to list the Indexes.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListIndexesResponse.next_page_token`
  /// of the previous
  /// `IndexService.ListIndexes`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListIndexesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListIndexesRequest.fromJson(Map<String, dynamic> json) {
    return ListIndexesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListIndexesRequest($contents)';
  }
}

/// Response message for
/// `IndexService.ListIndexes`.
final class ListIndexesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListIndexesResponse';

  /// List of indexes in the requested page.
  final List<Index>? indexes;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListIndexesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListIndexesResponse({this.indexes, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListIndexesResponse.fromJson(Map<String, dynamic> json) {
    return ListIndexesResponse(
      indexes: decodeListMessage(json['indexes'], Index.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (indexes != null) 'indexes': encodeList(indexes),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListIndexesResponse($contents)';
  }
}

/// Request message for
/// `IndexService.UpdateIndex`.
final class UpdateIndexRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateIndexRequest';

  /// Required. The Index which updates the resource on the server.
  final Index index;

  /// The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateIndexRequest({required this.index, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateIndexRequest.fromJson(Map<String, dynamic> json) {
    return UpdateIndexRequest(
      index: decode(json['index'], Index.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'index': index.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateIndexRequest()';
}

/// Runtime operation information for
/// `IndexService.UpdateIndex`.
final class UpdateIndexOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The operation metadata with regard to Matching Engine Index operation.
  final NearestNeighborSearchOperationMetadata?
  nearestNeighborSearchOperationMetadata;

  UpdateIndexOperationMetadata({
    this.genericMetadata,
    this.nearestNeighborSearchOperationMetadata,
  }) : super(fullyQualifiedName);

  factory UpdateIndexOperationMetadata.fromJson(Map<String, dynamic> json) {
    return UpdateIndexOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      nearestNeighborSearchOperationMetadata: decode(
        json['nearestNeighborSearchOperationMetadata'],
        NearestNeighborSearchOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (nearestNeighborSearchOperationMetadata != null)
        'nearestNeighborSearchOperationMetadata':
            nearestNeighborSearchOperationMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateIndexOperationMetadata()';
}

/// Request message for
/// `IndexService.ImportIndex`.
final class ImportIndexRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest';

  /// Required. The name of the Index resource to import data to.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String name;

  /// Optional. If true, completely replace existing index data. Must be true for
  /// streaming update indexes.
  final bool? isCompleteOverwrite;

  /// Required. Configuration for importing data from an external source.
  final ImportIndexRequest_ConnectorConfig? config;

  ImportIndexRequest({
    required this.name,
    this.isCompleteOverwrite,
    this.config,
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest.fromJson(Map<String, dynamic> json) {
    return ImportIndexRequest(
      name: json['name'],
      isCompleteOverwrite: json['isCompleteOverwrite'],
      config: decode(
        json['config'],
        ImportIndexRequest_ConnectorConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (isCompleteOverwrite != null)
        'isCompleteOverwrite': isCompleteOverwrite,
      if (config != null) 'config': config!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (isCompleteOverwrite != null)
        'isCompleteOverwrite=$isCompleteOverwrite',
    ].join(',');
    return 'ImportIndexRequest($contents)';
  }
}

/// Configuration for importing data from an external source.
final class ImportIndexRequest_ConnectorConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig';

  /// Configuration for importing data from a BigQuery table.
  final ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig?
  bigQuerySourceConfig;

  ImportIndexRequest_ConnectorConfig({this.bigQuerySourceConfig})
    : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ImportIndexRequest_ConnectorConfig(
      bigQuerySourceConfig: decode(
        json['bigQuerySourceConfig'],
        ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (bigQuerySourceConfig != null)
        'bigQuerySourceConfig': bigQuerySourceConfig!.toJson(),
    };
  }

  @override
  String toString() => 'ConnectorConfig()';
}

/// Mapping of datapoint fields to column names for columnar data sources.
final class ImportIndexRequest_ConnectorConfig_DatapointFieldMapping
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig.DatapointFieldMapping';

  /// Required. The column with unique identifiers for each data point.
  final String? idColumn;

  /// Required. The column with the vector embeddings for each data point.
  final String? embeddingColumn;

  /// Optional. List of restricts for string values.
  final List<ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict>?
  restricts;

  /// Optional. List of restricts for numeric values.
  final List<
    ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict
  >?
  numericRestricts;

  /// Optional. List of columns containing metadata to be included in the
  /// index.
  final List<String>? metadataColumns;

  ImportIndexRequest_ConnectorConfig_DatapointFieldMapping({
    this.idColumn,
    this.embeddingColumn,
    this.restricts,
    this.numericRestricts,
    this.metadataColumns,
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig_DatapointFieldMapping.fromJson(
    Map<String, dynamic> json,
  ) {
    return ImportIndexRequest_ConnectorConfig_DatapointFieldMapping(
      idColumn: json['idColumn'],
      embeddingColumn: json['embeddingColumn'],
      restricts: decodeListMessage(
        json['restricts'],
        ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict
            .fromJson,
      ),
      numericRestricts: decodeListMessage(
        json['numericRestricts'],
        ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict
            .fromJson,
      ),
      metadataColumns: decodeList(json['metadataColumns']),
    );
  }

  @override
  Object toJson() {
    return {
      if (idColumn != null) 'idColumn': idColumn,
      if (embeddingColumn != null) 'embeddingColumn': embeddingColumn,
      if (restricts != null) 'restricts': encodeList(restricts),
      if (numericRestricts != null)
        'numericRestricts': encodeList(numericRestricts),
      if (metadataColumns != null) 'metadataColumns': metadataColumns,
    };
  }

  @override
  String toString() {
    final contents = [
      if (idColumn != null) 'idColumn=$idColumn',
      if (embeddingColumn != null) 'embeddingColumn=$embeddingColumn',
    ].join(',');
    return 'DatapointFieldMapping($contents)';
  }
}

/// Restrictions on string values.
final class ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig.DatapointFieldMapping.Restrict';

  /// Required. The namespace of the restrict in the index.
  final String? namespace;

  /// Optional. The columns containing the allow values.
  final List<String>? allowColumn;

  /// Optional. The columns containing the deny values.
  final List<String>? denyColumn;

  ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict({
    this.namespace,
    this.allowColumn,
    this.denyColumn,
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict.fromJson(
    Map<String, dynamic> json,
  ) {
    return ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_Restrict(
      namespace: json['namespace'],
      allowColumn: decodeList(json['allowColumn']),
      denyColumn: decodeList(json['denyColumn']),
    );
  }

  @override
  Object toJson() {
    return {
      if (namespace != null) 'namespace': namespace,
      if (allowColumn != null) 'allowColumn': allowColumn,
      if (denyColumn != null) 'denyColumn': denyColumn,
    };
  }

  @override
  String toString() {
    final contents = [if (namespace != null) 'namespace=$namespace'].join(',');
    return 'Restrict($contents)';
  }
}

/// Restrictions on numeric values.
final class ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig.DatapointFieldMapping.NumericRestrict';

  /// Required. The namespace of the restrict.
  final String? namespace;

  /// Optional. The column containing the numeric value.
  final String? valueColumn;

  /// Required. Numeric type of the restrict. Must be consistent for
  /// all datapoints within the namespace.
  final ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType?
  valueType;

  ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict({
    this.namespace,
    this.valueColumn,
    this.valueType,
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict.fromJson(
    Map<String, dynamic> json,
  ) {
    return ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict(
      namespace: json['namespace'],
      valueColumn: json['valueColumn'],
      valueType: decodeEnum(
        json['valueType'],
        ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (namespace != null) 'namespace': namespace,
      if (valueColumn != null) 'valueColumn': valueColumn,
      if (valueType != null) 'valueType': valueType!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (namespace != null) 'namespace=$namespace',
      if (valueColumn != null) 'valueColumn=$valueColumn',
      if (valueType != null) 'valueType=$valueType',
    ].join(',');
    return 'NumericRestrict($contents)';
  }
}

/// The type of numeric value for the restrict.
final class ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType
    extends protobuf.ProtoEnum {
  /// Should not be used.
  static const valueTypeUnspecified =
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        'VALUE_TYPE_UNSPECIFIED',
      );

  /// Represents 64 bit integer.
  static const int =
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        'INT',
      );

  /// Represents 32 bit float.
  static const float =
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        'FLOAT',
      );

  /// Represents 64 bit float.
  static const double =
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        'DOUBLE',
      );

  const ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
    super.value,
  );

  factory ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType.fromJson(
    String json,
  ) =>
      ImportIndexRequest_ConnectorConfig_DatapointFieldMapping_NumericRestrict_ValueType(
        json,
      );

  @override
  String toString() => 'ValueType.$value';
}

/// Configuration for importing data from a BigQuery table.
final class ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexRequest.ConnectorConfig.BigQuerySourceConfig';

  /// Required. The path to the BigQuery table containing the index data, in
  /// the format of `bq://<project_id>.<dataset_id>.<table>`.
  final String? tablePath;

  /// Required. Mapping of datapoint fields to BigQuery column names.
  final ImportIndexRequest_ConnectorConfig_DatapointFieldMapping?
  datapointFieldMapping;

  ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig({
    this.tablePath,
    this.datapointFieldMapping,
  }) : super(fullyQualifiedName);

  factory ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ImportIndexRequest_ConnectorConfig_BigQuerySourceConfig(
      tablePath: json['tablePath'],
      datapointFieldMapping: decode(
        json['datapointFieldMapping'],
        ImportIndexRequest_ConnectorConfig_DatapointFieldMapping.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (tablePath != null) 'tablePath': tablePath,
      if (datapointFieldMapping != null)
        'datapointFieldMapping': datapointFieldMapping!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (tablePath != null) 'tablePath=$tablePath'].join(',');
    return 'BigQuerySourceConfig($contents)';
  }
}

/// Runtime operation information for
/// `IndexService.ImportIndex`.
final class ImportIndexOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportIndexOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  ImportIndexOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ImportIndexOperationMetadata.fromJson(Map<String, dynamic> json) {
    return ImportIndexOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'ImportIndexOperationMetadata()';
}

/// Request message for
/// `IndexService.DeleteIndex`.
final class DeleteIndexRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteIndexRequest';

  /// Required. The name of the Index resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String name;

  DeleteIndexRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteIndexRequest.fromJson(Map<String, dynamic> json) {
    return DeleteIndexRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteIndexRequest($contents)';
  }
}

/// Request message for
/// `IndexService.UpsertDatapoints`
final class UpsertDatapointsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertDatapointsRequest';

  /// Required. The name of the Index resource to be updated.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String index;

  /// A list of datapoints to be created/updated.
  final List<IndexDatapoint>? datapoints;

  /// Optional. Update mask is used to specify the fields to be overwritten in
  /// the datapoints by the update. The fields specified in the update_mask are
  /// relative to each IndexDatapoint inside datapoints, not the full request.
  ///
  /// Updatable fields:
  ///
  ///   * Use `all_restricts` to update both restricts and numeric_restricts.
  final protobuf.FieldMask? updateMask;

  UpsertDatapointsRequest({
    required this.index,
    this.datapoints,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpsertDatapointsRequest.fromJson(Map<String, dynamic> json) {
    return UpsertDatapointsRequest(
      index: json['index'],
      datapoints: decodeListMessage(
        json['datapoints'],
        IndexDatapoint.fromJson,
      ),
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'index': index,
      if (datapoints != null) 'datapoints': encodeList(datapoints),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['index=$index'].join(',');
    return 'UpsertDatapointsRequest($contents)';
  }
}

/// Response message for
/// `IndexService.UpsertDatapoints`
final class UpsertDatapointsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpsertDatapointsResponse';

  UpsertDatapointsResponse() : super(fullyQualifiedName);

  factory UpsertDatapointsResponse.fromJson(Map<String, dynamic> json) {
    return UpsertDatapointsResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'UpsertDatapointsResponse()';
}

/// Request message for
/// `IndexService.RemoveDatapoints`
final class RemoveDatapointsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveDatapointsRequest';

  /// Required. The name of the Index resource to be updated.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String index;

  /// A list of datapoint ids to be deleted.
  final List<String>? datapointIds;

  RemoveDatapointsRequest({required this.index, this.datapointIds})
    : super(fullyQualifiedName);

  factory RemoveDatapointsRequest.fromJson(Map<String, dynamic> json) {
    return RemoveDatapointsRequest(
      index: json['index'],
      datapointIds: decodeList(json['datapointIds']),
    );
  }

  @override
  Object toJson() {
    return {
      'index': index,
      if (datapointIds != null) 'datapointIds': datapointIds,
    };
  }

  @override
  String toString() {
    final contents = ['index=$index'].join(',');
    return 'RemoveDatapointsRequest($contents)';
  }
}

/// Response message for
/// `IndexService.RemoveDatapoints`
final class RemoveDatapointsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveDatapointsResponse';

  RemoveDatapointsResponse() : super(fullyQualifiedName);

  factory RemoveDatapointsResponse.fromJson(Map<String, dynamic> json) {
    return RemoveDatapointsResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'RemoveDatapointsResponse()';
}

/// Runtime operation metadata with regard to Matching Engine Index.
final class NearestNeighborSearchOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborSearchOperationMetadata';

  /// The validation stats of the content (per file) to be inserted or
  /// updated on the Matching Engine Index resource. Populated if
  /// contentsDeltaUri is provided as part of
  /// `Index.metadata`. Please
  /// note that, currently for those files that are broken or has unsupported
  /// file format, we will not have the stats for those files.
  final List<NearestNeighborSearchOperationMetadata_ContentValidationStats>?
  contentValidationStats;

  /// The ingested data size in bytes.
  final int? dataBytesCount;

  NearestNeighborSearchOperationMetadata({
    this.contentValidationStats,
    this.dataBytesCount,
  }) : super(fullyQualifiedName);

  factory NearestNeighborSearchOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return NearestNeighborSearchOperationMetadata(
      contentValidationStats: decodeListMessage(
        json['contentValidationStats'],
        NearestNeighborSearchOperationMetadata_ContentValidationStats.fromJson,
      ),
      dataBytesCount: decodeInt64(json['dataBytesCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (contentValidationStats != null)
        'contentValidationStats': encodeList(contentValidationStats),
      if (dataBytesCount != null) 'dataBytesCount': encodeInt64(dataBytesCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataBytesCount != null) 'dataBytesCount=$dataBytesCount',
    ].join(',');
    return 'NearestNeighborSearchOperationMetadata($contents)';
  }
}

final class NearestNeighborSearchOperationMetadata_RecordError
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborSearchOperationMetadata.RecordError';

  /// The error type of this record.
  final NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType?
  errorType;

  /// A human-readable message that is shown to the user to help them fix the
  /// error. Note that this message may change from time to time, your code
  /// should check against error_type as the source of truth.
  final String? errorMessage;

  /// Cloud Storage URI pointing to the original file in user's bucket.
  final String? sourceGcsUri;

  /// Empty if the embedding id is failed to parse.
  final String? embeddingId;

  /// The original content of this record.
  final String? rawRecord;

  NearestNeighborSearchOperationMetadata_RecordError({
    this.errorType,
    this.errorMessage,
    this.sourceGcsUri,
    this.embeddingId,
    this.rawRecord,
  }) : super(fullyQualifiedName);

  factory NearestNeighborSearchOperationMetadata_RecordError.fromJson(
    Map<String, dynamic> json,
  ) {
    return NearestNeighborSearchOperationMetadata_RecordError(
      errorType: decodeEnum(
        json['errorType'],
        NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType
            .fromJson,
      ),
      errorMessage: json['errorMessage'],
      sourceGcsUri: json['sourceGcsUri'],
      embeddingId: json['embeddingId'],
      rawRecord: json['rawRecord'],
    );
  }

  @override
  Object toJson() {
    return {
      if (errorType != null) 'errorType': errorType!.toJson(),
      if (errorMessage != null) 'errorMessage': errorMessage,
      if (sourceGcsUri != null) 'sourceGcsUri': sourceGcsUri,
      if (embeddingId != null) 'embeddingId': embeddingId,
      if (rawRecord != null) 'rawRecord': rawRecord,
    };
  }

  @override
  String toString() {
    final contents = [
      if (errorType != null) 'errorType=$errorType',
      if (errorMessage != null) 'errorMessage=$errorMessage',
      if (sourceGcsUri != null) 'sourceGcsUri=$sourceGcsUri',
      if (embeddingId != null) 'embeddingId=$embeddingId',
      if (rawRecord != null) 'rawRecord=$rawRecord',
    ].join(',');
    return 'RecordError($contents)';
  }
}

final class NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType
    extends protobuf.ProtoEnum {
  /// Default, shall not be used.
  static const errorTypeUnspecified =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'ERROR_TYPE_UNSPECIFIED',
      );

  /// The record is empty.
  static const emptyLine =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'EMPTY_LINE',
      );

  /// Invalid json format.
  static const invalidJsonSyntax =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_JSON_SYNTAX',
      );

  /// Invalid csv format.
  static const invalidCsvSyntax =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_CSV_SYNTAX',
      );

  /// Invalid avro format.
  static const invalidAvroSyntax =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_AVRO_SYNTAX',
      );

  /// The embedding id is not valid.
  static const invalidEmbeddingId =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_EMBEDDING_ID',
      );

  /// The size of the dense embedding vectors does not match with the
  /// specified dimension.
  static const embeddingSizeMismatch =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'EMBEDDING_SIZE_MISMATCH',
      );

  /// The `namespace` field is missing.
  static const namespaceMissing =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'NAMESPACE_MISSING',
      );

  /// Generic catch-all error. Only used for validation failure where the
  /// root cause cannot be easily retrieved programmatically.
  static const parsingError =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'PARSING_ERROR',
      );

  /// There are multiple restricts with the same `namespace` value.
  static const duplicateNamespace =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'DUPLICATE_NAMESPACE',
      );

  /// Numeric restrict has operator specified in datapoint.
  static const opInDatapoint =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'OP_IN_DATAPOINT',
      );

  /// Numeric restrict has multiple values specified.
  static const multipleValues =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'MULTIPLE_VALUES',
      );

  /// Numeric restrict has invalid numeric value specified.
  static const invalidNumericValue =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_NUMERIC_VALUE',
      );

  /// File is not in UTF_8 format.
  static const invalidEncoding =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_ENCODING',
      );

  /// Error parsing sparse dimensions field.
  static const invalidSparseDimensions =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_SPARSE_DIMENSIONS',
      );

  /// Token restrict value is invalid.
  static const invalidTokenValue =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_TOKEN_VALUE',
      );

  /// Invalid sparse embedding.
  static const invalidSparseEmbedding =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_SPARSE_EMBEDDING',
      );

  /// Invalid dense embedding.
  static const invalidEmbedding =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_EMBEDDING',
      );

  /// Invalid embedding metadata.
  static const invalidEmbeddingMetadata =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'INVALID_EMBEDDING_METADATA',
      );

  /// Embedding metadata exceeds size limit.
  static const embeddingMetadataExceedsSizeLimit =
      NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
        'EMBEDDING_METADATA_EXCEEDS_SIZE_LIMIT',
      );

  const NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(
    super.value,
  );

  factory NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType.fromJson(
    String json,
  ) => NearestNeighborSearchOperationMetadata_RecordError_RecordErrorType(json);

  @override
  String toString() => 'RecordErrorType.$value';
}

final class NearestNeighborSearchOperationMetadata_ContentValidationStats
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NearestNeighborSearchOperationMetadata.ContentValidationStats';

  /// Cloud Storage URI pointing to the original file in user's bucket.
  final String? sourceGcsUri;

  /// Number of records in this file that were successfully processed.
  final int? validRecordCount;

  /// Number of records in this file we skipped due to validate errors.
  final int? invalidRecordCount;

  /// The detail information of the partial failures encountered for those
  /// invalid records that couldn't be parsed.
  /// Up to 50 partial errors will be reported.
  final List<NearestNeighborSearchOperationMetadata_RecordError>? partialErrors;

  /// Number of sparse records in this file that were successfully processed.
  final int? validSparseRecordCount;

  /// Number of sparse records in this file we skipped due to validate errors.
  final int? invalidSparseRecordCount;

  NearestNeighborSearchOperationMetadata_ContentValidationStats({
    this.sourceGcsUri,
    this.validRecordCount,
    this.invalidRecordCount,
    this.partialErrors,
    this.validSparseRecordCount,
    this.invalidSparseRecordCount,
  }) : super(fullyQualifiedName);

  factory NearestNeighborSearchOperationMetadata_ContentValidationStats.fromJson(
    Map<String, dynamic> json,
  ) {
    return NearestNeighborSearchOperationMetadata_ContentValidationStats(
      sourceGcsUri: json['sourceGcsUri'],
      validRecordCount: decodeInt64(json['validRecordCount']),
      invalidRecordCount: decodeInt64(json['invalidRecordCount']),
      partialErrors: decodeListMessage(
        json['partialErrors'],
        NearestNeighborSearchOperationMetadata_RecordError.fromJson,
      ),
      validSparseRecordCount: decodeInt64(json['validSparseRecordCount']),
      invalidSparseRecordCount: decodeInt64(json['invalidSparseRecordCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (sourceGcsUri != null) 'sourceGcsUri': sourceGcsUri,
      if (validRecordCount != null)
        'validRecordCount': encodeInt64(validRecordCount),
      if (invalidRecordCount != null)
        'invalidRecordCount': encodeInt64(invalidRecordCount),
      if (partialErrors != null) 'partialErrors': encodeList(partialErrors),
      if (validSparseRecordCount != null)
        'validSparseRecordCount': encodeInt64(validSparseRecordCount),
      if (invalidSparseRecordCount != null)
        'invalidSparseRecordCount': encodeInt64(invalidSparseRecordCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (sourceGcsUri != null) 'sourceGcsUri=$sourceGcsUri',
      if (validRecordCount != null) 'validRecordCount=$validRecordCount',
      if (invalidRecordCount != null) 'invalidRecordCount=$invalidRecordCount',
      if (validSparseRecordCount != null)
        'validSparseRecordCount=$validSparseRecordCount',
      if (invalidSparseRecordCount != null)
        'invalidSparseRecordCount=$invalidSparseRecordCount',
    ].join(',');
    return 'ContentValidationStats($contents)';
  }
}

/// The storage details for Avro input content.
final class AvroSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AvroSource';

  /// Required. Google Cloud Storage location.
  final GcsSource? gcsSource;

  AvroSource({this.gcsSource}) : super(fullyQualifiedName);

  factory AvroSource.fromJson(Map<String, dynamic> json) {
    return AvroSource(gcsSource: decode(json['gcsSource'], GcsSource.fromJson));
  }

  @override
  Object toJson() {
    return {if (gcsSource != null) 'gcsSource': gcsSource!.toJson()};
  }

  @override
  String toString() => 'AvroSource()';
}

/// The storage details for CSV input content.
final class CsvSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CsvSource';

  /// Required. Google Cloud Storage location.
  final GcsSource? gcsSource;

  CsvSource({this.gcsSource}) : super(fullyQualifiedName);

  factory CsvSource.fromJson(Map<String, dynamic> json) {
    return CsvSource(gcsSource: decode(json['gcsSource'], GcsSource.fromJson));
  }

  @override
  Object toJson() {
    return {if (gcsSource != null) 'gcsSource': gcsSource!.toJson()};
  }

  @override
  String toString() => 'CsvSource()';
}

/// The Google Cloud Storage location for the input content.
final class GcsSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GcsSource';

  /// Required. Google Cloud Storage URI(-s) to the input file(s). May contain
  /// wildcards. For more information on wildcards, see
  /// https://cloud.google.com/storage/docs/wildcards.
  final List<String>? uris;

  GcsSource({this.uris}) : super(fullyQualifiedName);

  factory GcsSource.fromJson(Map<String, dynamic> json) {
    return GcsSource(uris: decodeList(json['uris']));
  }

  @override
  Object toJson() {
    return {if (uris != null) 'uris': uris};
  }

  @override
  String toString() => 'GcsSource()';
}

/// The Google Cloud Storage location where the output is to be written to.
final class GcsDestination extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GcsDestination';

  /// Required. Google Cloud Storage URI to output directory. If the uri doesn't
  /// end with
  /// '/', a '/' will be automatically appended. The directory is created if it
  /// doesn't exist.
  final String? outputUriPrefix;

  GcsDestination({this.outputUriPrefix}) : super(fullyQualifiedName);

  factory GcsDestination.fromJson(Map<String, dynamic> json) {
    return GcsDestination(outputUriPrefix: json['outputUriPrefix']);
  }

  @override
  Object toJson() {
    return {if (outputUriPrefix != null) 'outputUriPrefix': outputUriPrefix};
  }

  @override
  String toString() {
    final contents = [
      if (outputUriPrefix != null) 'outputUriPrefix=$outputUriPrefix',
    ].join(',');
    return 'GcsDestination($contents)';
  }
}

/// The BigQuery location for the input content.
final class BigQuerySource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BigQuerySource';

  /// Required. BigQuery URI to a table, up to 2000 characters long.
  /// Accepted forms:
  ///
  /// *  BigQuery path. For example: `bq://projectId.bqDatasetId.bqTableId`.
  final String? inputUri;

  BigQuerySource({this.inputUri}) : super(fullyQualifiedName);

  factory BigQuerySource.fromJson(Map<String, dynamic> json) {
    return BigQuerySource(inputUri: json['inputUri']);
  }

  @override
  Object toJson() {
    return {if (inputUri != null) 'inputUri': inputUri};
  }

  @override
  String toString() {
    final contents = [if (inputUri != null) 'inputUri=$inputUri'].join(',');
    return 'BigQuerySource($contents)';
  }
}

/// The BigQuery location for the output content.
final class BigQueryDestination extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BigQueryDestination';

  /// Required. BigQuery URI to a project or table, up to 2000 characters long.
  ///
  /// When only the project is specified, the Dataset and Table is created.
  /// When the full table reference is specified, the Dataset must exist and
  /// table must not exist.
  ///
  /// Accepted forms:
  ///
  /// *  BigQuery path. For example:
  /// `bq://projectId` or `bq://projectId.bqDatasetId` or
  /// `bq://projectId.bqDatasetId.bqTableId`.
  final String? outputUri;

  BigQueryDestination({this.outputUri}) : super(fullyQualifiedName);

  factory BigQueryDestination.fromJson(Map<String, dynamic> json) {
    return BigQueryDestination(outputUri: json['outputUri']);
  }

  @override
  Object toJson() {
    return {if (outputUri != null) 'outputUri': outputUri};
  }

  @override
  String toString() {
    final contents = [if (outputUri != null) 'outputUri=$outputUri'].join(',');
    return 'BigQueryDestination($contents)';
  }
}

/// The storage details for CSV output content.
final class CsvDestination extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CsvDestination';

  /// Required. Google Cloud Storage location.
  final GcsDestination? gcsDestination;

  CsvDestination({this.gcsDestination}) : super(fullyQualifiedName);

  factory CsvDestination.fromJson(Map<String, dynamic> json) {
    return CsvDestination(
      gcsDestination: decode(json['gcsDestination'], GcsDestination.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
    };
  }

  @override
  String toString() => 'CsvDestination()';
}

/// The storage details for TFRecord output content.
final class TfrecordDestination extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TFRecordDestination';

  /// Required. Google Cloud Storage location.
  final GcsDestination? gcsDestination;

  TfrecordDestination({this.gcsDestination}) : super(fullyQualifiedName);

  factory TfrecordDestination.fromJson(Map<String, dynamic> json) {
    return TfrecordDestination(
      gcsDestination: decode(json['gcsDestination'], GcsDestination.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
    };
  }

  @override
  String toString() => 'TFRecordDestination()';
}

/// The Container Registry location for the container image.
final class ContainerRegistryDestination extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ContainerRegistryDestination';

  /// Required. Container Registry URI of a container image.
  /// Only Google Container Registry and Artifact Registry are supported now.
  /// Accepted forms:
  ///
  /// *  Google Container Registry path. For example:
  ///    `gcr.io/projectId/imageName:tag`.
  ///
  /// *  Artifact Registry path. For example:
  ///    `us-central1-docker.pkg.dev/projectId/repoName/imageName:tag`.
  ///
  /// If a tag is not specified, "latest" will be used as the default tag.
  final String? outputUri;

  ContainerRegistryDestination({this.outputUri}) : super(fullyQualifiedName);

  factory ContainerRegistryDestination.fromJson(Map<String, dynamic> json) {
    return ContainerRegistryDestination(outputUri: json['outputUri']);
  }

  @override
  Object toJson() {
    return {if (outputUri != null) 'outputUri': outputUri};
  }

  @override
  String toString() {
    final contents = [if (outputUri != null) 'outputUri=$outputUri'].join(',');
    return 'ContainerRegistryDestination($contents)';
  }
}

/// The Google Drive location for the input content.
final class GoogleDriveSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GoogleDriveSource';

  /// Required. Google Drive resource IDs.
  final List<GoogleDriveSource_ResourceId>? resourceIds;

  GoogleDriveSource({this.resourceIds}) : super(fullyQualifiedName);

  factory GoogleDriveSource.fromJson(Map<String, dynamic> json) {
    return GoogleDriveSource(
      resourceIds: decodeListMessage(
        json['resourceIds'],
        GoogleDriveSource_ResourceId.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (resourceIds != null) 'resourceIds': encodeList(resourceIds)};
  }

  @override
  String toString() => 'GoogleDriveSource()';
}

/// The type and ID of the Google Drive resource.
final class GoogleDriveSource_ResourceId extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GoogleDriveSource.ResourceId';

  /// Required. The type of the Google Drive resource.
  final GoogleDriveSource_ResourceId_ResourceType? resourceType;

  /// Required. The ID of the Google Drive resource.
  final String? resourceId;

  GoogleDriveSource_ResourceId({this.resourceType, this.resourceId})
    : super(fullyQualifiedName);

  factory GoogleDriveSource_ResourceId.fromJson(Map<String, dynamic> json) {
    return GoogleDriveSource_ResourceId(
      resourceType: decodeEnum(
        json['resourceType'],
        GoogleDriveSource_ResourceId_ResourceType.fromJson,
      ),
      resourceId: json['resourceId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (resourceType != null) 'resourceType': resourceType!.toJson(),
      if (resourceId != null) 'resourceId': resourceId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (resourceType != null) 'resourceType=$resourceType',
      if (resourceId != null) 'resourceId=$resourceId',
    ].join(',');
    return 'ResourceId($contents)';
  }
}

/// The type of the Google Drive resource.
final class GoogleDriveSource_ResourceId_ResourceType
    extends protobuf.ProtoEnum {
  /// Unspecified resource type.
  static const resourceTypeUnspecified =
      GoogleDriveSource_ResourceId_ResourceType('RESOURCE_TYPE_UNSPECIFIED');

  /// File resource type.
  static const resourceTypeFile = GoogleDriveSource_ResourceId_ResourceType(
    'RESOURCE_TYPE_FILE',
  );

  /// Folder resource type.
  static const resourceTypeFolder = GoogleDriveSource_ResourceId_ResourceType(
    'RESOURCE_TYPE_FOLDER',
  );

  const GoogleDriveSource_ResourceId_ResourceType(super.value);

  factory GoogleDriveSource_ResourceId_ResourceType.fromJson(String json) =>
      GoogleDriveSource_ResourceId_ResourceType(json);

  @override
  String toString() => 'ResourceType.$value';
}

/// The input content is encapsulated and uploaded in the request.
final class DirectUploadSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectUploadSource';

  DirectUploadSource() : super(fullyQualifiedName);

  factory DirectUploadSource.fromJson(Map<String, dynamic> json) {
    return DirectUploadSource();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'DirectUploadSource()';
}

/// The Slack source for the ImportRagFilesRequest.
final class SlackSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SlackSource';

  /// Required. The Slack channels.
  final List<SlackSource_SlackChannels>? channels;

  SlackSource({this.channels}) : super(fullyQualifiedName);

  factory SlackSource.fromJson(Map<String, dynamic> json) {
    return SlackSource(
      channels: decodeListMessage(
        json['channels'],
        SlackSource_SlackChannels.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (channels != null) 'channels': encodeList(channels)};
  }

  @override
  String toString() => 'SlackSource()';
}

/// SlackChannels contains the Slack channels and corresponding access token.
final class SlackSource_SlackChannels extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SlackSource.SlackChannels';

  /// Required. The Slack channel IDs.
  final List<SlackSource_SlackChannels_SlackChannel>? channels;

  /// Required. The SecretManager secret version resource name (e.g.
  /// projects/{project}/secrets/{secret}/versions/{version}) storing the
  /// Slack channel access token that has access to the slack channel IDs.
  /// See: https://api.slack.com/tutorials/tracks/getting-a-token.
  final ApiAuth_ApiKeyConfig? apiKeyConfig;

  SlackSource_SlackChannels({this.channels, this.apiKeyConfig})
    : super(fullyQualifiedName);

  factory SlackSource_SlackChannels.fromJson(Map<String, dynamic> json) {
    return SlackSource_SlackChannels(
      channels: decodeListMessage(
        json['channels'],
        SlackSource_SlackChannels_SlackChannel.fromJson,
      ),
      apiKeyConfig: decode(json['apiKeyConfig'], ApiAuth_ApiKeyConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (channels != null) 'channels': encodeList(channels),
      if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!.toJson(),
    };
  }

  @override
  String toString() => 'SlackChannels()';
}

/// SlackChannel contains the Slack channel ID and the time range to import.
final class SlackSource_SlackChannels_SlackChannel
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SlackSource.SlackChannels.SlackChannel';

  /// Required. The Slack channel ID.
  final String? channelId;

  /// Optional. The starting timestamp for messages to import.
  final protobuf.Timestamp? startTime;

  /// Optional. The ending timestamp for messages to import.
  final protobuf.Timestamp? endTime;

  SlackSource_SlackChannels_SlackChannel({
    this.channelId,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory SlackSource_SlackChannels_SlackChannel.fromJson(
    Map<String, dynamic> json,
  ) {
    return SlackSource_SlackChannels_SlackChannel(
      channelId: json['channelId'],
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (channelId != null) 'channelId': channelId,
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (channelId != null) 'channelId=$channelId'].join(',');
    return 'SlackChannel($contents)';
  }
}

/// The Jira source for the ImportRagFilesRequest.
final class JiraSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.JiraSource';

  /// Required. The Jira queries.
  final List<JiraSource_JiraQueries>? jiraQueries;

  JiraSource({this.jiraQueries}) : super(fullyQualifiedName);

  factory JiraSource.fromJson(Map<String, dynamic> json) {
    return JiraSource(
      jiraQueries: decodeListMessage(
        json['jiraQueries'],
        JiraSource_JiraQueries.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (jiraQueries != null) 'jiraQueries': encodeList(jiraQueries)};
  }

  @override
  String toString() => 'JiraSource()';
}

/// JiraQueries contains the Jira queries and corresponding authentication.
final class JiraSource_JiraQueries extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.JiraSource.JiraQueries';

  /// A list of Jira projects to import in their entirety.
  final List<String>? projects;

  /// A list of custom Jira queries to import. For information about JQL (Jira
  /// Query Language), see
  /// https://support.atlassian.com/jira-service-management-cloud/docs/use-advanced-search-with-jira-query-language-jql/
  final List<String>? customQueries;

  /// Required. The Jira email address.
  final String? email;

  /// Required. The Jira server URI.
  final String? serverUri;

  /// Required. The SecretManager secret version resource name (e.g.
  /// projects/{project}/secrets/{secret}/versions/{version}) storing the
  /// Jira API key. See [Manage API tokens for your Atlassian
  /// account](https://support.atlassian.com/atlassian-account/docs/manage-api-tokens-for-your-atlassian-account/).
  final ApiAuth_ApiKeyConfig? apiKeyConfig;

  JiraSource_JiraQueries({
    this.projects,
    this.customQueries,
    this.email,
    this.serverUri,
    this.apiKeyConfig,
  }) : super(fullyQualifiedName);

  factory JiraSource_JiraQueries.fromJson(Map<String, dynamic> json) {
    return JiraSource_JiraQueries(
      projects: decodeList(json['projects']),
      customQueries: decodeList(json['customQueries']),
      email: json['email'],
      serverUri: json['serverUri'],
      apiKeyConfig: decode(json['apiKeyConfig'], ApiAuth_ApiKeyConfig.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (projects != null) 'projects': projects,
      if (customQueries != null) 'customQueries': customQueries,
      if (email != null) 'email': email,
      if (serverUri != null) 'serverUri': serverUri,
      if (apiKeyConfig != null) 'apiKeyConfig': apiKeyConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (email != null) 'email=$email',
      if (serverUri != null) 'serverUri=$serverUri',
    ].join(',');
    return 'JiraQueries($contents)';
  }
}

/// The SharePointSources to pass to ImportRagFiles.
final class SharePointSources extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SharePointSources';

  /// The SharePoint sources.
  final List<SharePointSources_SharePointSource>? sharePointSources;

  SharePointSources({this.sharePointSources}) : super(fullyQualifiedName);

  factory SharePointSources.fromJson(Map<String, dynamic> json) {
    return SharePointSources(
      sharePointSources: decodeListMessage(
        json['sharePointSources'],
        SharePointSources_SharePointSource.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (sharePointSources != null)
        'sharePointSources': encodeList(sharePointSources),
    };
  }

  @override
  String toString() => 'SharePointSources()';
}

/// An individual SharePointSource.
final class SharePointSources_SharePointSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SharePointSources.SharePointSource';

  /// The path of the SharePoint folder to download from.
  final String? sharepointFolderPath;

  /// The ID of the SharePoint folder to download from.
  final String? sharepointFolderId;

  /// The name of the drive to download from.
  final String? driveName;

  /// The ID of the drive to download from.
  final String? driveId;

  /// The Application ID for the app registered in Microsoft Azure Portal.
  /// The application must also be configured with MS Graph permissions
  /// "Files.ReadAll", "Sites.ReadAll" and BrowserSiteLists.Read.All.
  final String? clientId;

  /// The application secret for the app registered in Azure.
  final ApiAuth_ApiKeyConfig? clientSecret;

  /// Unique identifier of the Azure Active Directory Instance.
  final String? tenantId;

  /// The name of the SharePoint site to download from. This can be the site
  /// name or the site id.
  final String? sharepointSiteName;

  /// Output only. The SharePoint file id. Output only.
  final String? fileId;

  SharePointSources_SharePointSource({
    this.sharepointFolderPath,
    this.sharepointFolderId,
    this.driveName,
    this.driveId,
    this.clientId,
    this.clientSecret,
    this.tenantId,
    this.sharepointSiteName,
    this.fileId,
  }) : super(fullyQualifiedName);

  factory SharePointSources_SharePointSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return SharePointSources_SharePointSource(
      sharepointFolderPath: json['sharepointFolderPath'],
      sharepointFolderId: json['sharepointFolderId'],
      driveName: json['driveName'],
      driveId: json['driveId'],
      clientId: json['clientId'],
      clientSecret: decode(json['clientSecret'], ApiAuth_ApiKeyConfig.fromJson),
      tenantId: json['tenantId'],
      sharepointSiteName: json['sharepointSiteName'],
      fileId: json['fileId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (sharepointFolderPath != null)
        'sharepointFolderPath': sharepointFolderPath,
      if (sharepointFolderId != null) 'sharepointFolderId': sharepointFolderId,
      if (driveName != null) 'driveName': driveName,
      if (driveId != null) 'driveId': driveId,
      if (clientId != null) 'clientId': clientId,
      if (clientSecret != null) 'clientSecret': clientSecret!.toJson(),
      if (tenantId != null) 'tenantId': tenantId,
      if (sharepointSiteName != null) 'sharepointSiteName': sharepointSiteName,
      if (fileId != null) 'fileId': fileId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (sharepointFolderPath != null)
        'sharepointFolderPath=$sharepointFolderPath',
      if (sharepointFolderId != null) 'sharepointFolderId=$sharepointFolderId',
      if (driveName != null) 'driveName=$driveName',
      if (driveId != null) 'driveId=$driveId',
      if (clientId != null) 'clientId=$clientId',
      if (tenantId != null) 'tenantId=$tenantId',
      if (sharepointSiteName != null) 'sharepointSiteName=$sharepointSiteName',
      if (fileId != null) 'fileId=$fileId',
    ].join(',');
    return 'SharePointSource($contents)';
  }
}

/// Request message for
/// `JobService.CreateCustomJob`.
final class CreateCustomJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateCustomJobRequest';

  /// Required. The resource name of the Location to create the CustomJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The CustomJob to create.
  final CustomJob customJob;

  CreateCustomJobRequest({required this.parent, required this.customJob})
    : super(fullyQualifiedName);

  factory CreateCustomJobRequest.fromJson(Map<String, dynamic> json) {
    return CreateCustomJobRequest(
      parent: json['parent'],
      customJob: decode(json['customJob'], CustomJob.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'customJob': customJob.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateCustomJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetCustomJob`.
final class GetCustomJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetCustomJobRequest';

  /// Required. The name of the CustomJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  final String name;

  GetCustomJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetCustomJobRequest.fromJson(Map<String, dynamic> json) {
    return GetCustomJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetCustomJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListCustomJobs`.
final class ListCustomJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListCustomJobsRequest';

  /// Required. The resource name of the Location to list the CustomJobs from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListCustomJobsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListCustomJobs`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListCustomJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListCustomJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListCustomJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListCustomJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListCustomJobs`
final class ListCustomJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListCustomJobsResponse';

  /// List of CustomJobs in the requested page.
  final List<CustomJob>? customJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListCustomJobsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListCustomJobsResponse({this.customJobs, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListCustomJobsResponse.fromJson(Map<String, dynamic> json) {
    return ListCustomJobsResponse(
      customJobs: decodeListMessage(json['customJobs'], CustomJob.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (customJobs != null) 'customJobs': encodeList(customJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListCustomJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteCustomJob`.
final class DeleteCustomJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteCustomJobRequest';

  /// Required. The name of the CustomJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  final String name;

  DeleteCustomJobRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteCustomJobRequest.fromJson(Map<String, dynamic> json) {
    return DeleteCustomJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteCustomJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelCustomJob`.
final class CancelCustomJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelCustomJobRequest';

  /// Required. The name of the CustomJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/customJobs/{custom_job}`
  final String name;

  CancelCustomJobRequest({required this.name}) : super(fullyQualifiedName);

  factory CancelCustomJobRequest.fromJson(Map<String, dynamic> json) {
    return CancelCustomJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelCustomJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CreateDataLabelingJob`.
final class CreateDataLabelingJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateDataLabelingJobRequest';

  /// Required. The parent of the DataLabelingJob.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The DataLabelingJob to create.
  final DataLabelingJob dataLabelingJob;

  CreateDataLabelingJobRequest({
    required this.parent,
    required this.dataLabelingJob,
  }) : super(fullyQualifiedName);

  factory CreateDataLabelingJobRequest.fromJson(Map<String, dynamic> json) {
    return CreateDataLabelingJobRequest(
      parent: json['parent'],
      dataLabelingJob: decode(
        json['dataLabelingJob'],
        DataLabelingJob.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'dataLabelingJob': dataLabelingJob.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateDataLabelingJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetDataLabelingJob`.
final class GetDataLabelingJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetDataLabelingJobRequest';

  /// Required. The name of the DataLabelingJob.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  final String name;

  GetDataLabelingJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetDataLabelingJobRequest.fromJson(Map<String, dynamic> json) {
    return GetDataLabelingJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetDataLabelingJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListDataLabelingJobs`.
final class ListDataLabelingJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDataLabelingJobsRequest';

  /// Required. The parent of the DataLabelingJob.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  final String? pageToken;

  /// Mask specifying which fields to read. FieldMask represents a set of
  /// symbolic field paths. For example, the mask can be `paths: "name"`. The
  /// "name" here is a field in DataLabelingJob.
  /// If this field is not set, all fields of the DataLabelingJob are returned.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order by
  /// default.
  /// Use `desc` after a field name for descending.
  final String? orderBy;

  ListDataLabelingJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListDataLabelingJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListDataLabelingJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListDataLabelingJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListDataLabelingJobs`.
final class ListDataLabelingJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListDataLabelingJobsResponse';

  /// A list of DataLabelingJobs that matches the specified filter in the
  /// request.
  final List<DataLabelingJob>? dataLabelingJobs;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListDataLabelingJobsResponse({this.dataLabelingJobs, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListDataLabelingJobsResponse.fromJson(Map<String, dynamic> json) {
    return ListDataLabelingJobsResponse(
      dataLabelingJobs: decodeListMessage(
        json['dataLabelingJobs'],
        DataLabelingJob.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dataLabelingJobs != null)
        'dataLabelingJobs': encodeList(dataLabelingJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListDataLabelingJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteDataLabelingJob`.
final class DeleteDataLabelingJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteDataLabelingJobRequest';

  /// Required. The name of the DataLabelingJob to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  final String name;

  DeleteDataLabelingJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteDataLabelingJobRequest.fromJson(Map<String, dynamic> json) {
    return DeleteDataLabelingJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteDataLabelingJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelDataLabelingJob`.
final class CancelDataLabelingJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelDataLabelingJobRequest';

  /// Required. The name of the DataLabelingJob.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  final String name;

  CancelDataLabelingJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory CancelDataLabelingJobRequest.fromJson(Map<String, dynamic> json) {
    return CancelDataLabelingJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelDataLabelingJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CreateHyperparameterTuningJob`.
final class CreateHyperparameterTuningJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateHyperparameterTuningJobRequest';

  /// Required. The resource name of the Location to create the
  /// HyperparameterTuningJob in. Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The HyperparameterTuningJob to create.
  final HyperparameterTuningJob hyperparameterTuningJob;

  CreateHyperparameterTuningJobRequest({
    required this.parent,
    required this.hyperparameterTuningJob,
  }) : super(fullyQualifiedName);

  factory CreateHyperparameterTuningJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateHyperparameterTuningJobRequest(
      parent: json['parent'],
      hyperparameterTuningJob: decode(
        json['hyperparameterTuningJob'],
        HyperparameterTuningJob.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'hyperparameterTuningJob': hyperparameterTuningJob.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateHyperparameterTuningJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetHyperparameterTuningJob`.
final class GetHyperparameterTuningJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetHyperparameterTuningJobRequest';

  /// Required. The name of the HyperparameterTuningJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  final String name;

  GetHyperparameterTuningJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetHyperparameterTuningJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return GetHyperparameterTuningJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetHyperparameterTuningJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListHyperparameterTuningJobs`.
final class ListHyperparameterTuningJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListHyperparameterTuningJobsRequest';

  /// Required. The resource name of the Location to list the
  /// HyperparameterTuningJobs from. Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListHyperparameterTuningJobsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListHyperparameterTuningJobs`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListHyperparameterTuningJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListHyperparameterTuningJobsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListHyperparameterTuningJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListHyperparameterTuningJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListHyperparameterTuningJobs`
final class ListHyperparameterTuningJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListHyperparameterTuningJobsResponse';

  /// List of HyperparameterTuningJobs in the requested page.
  /// `HyperparameterTuningJob.trials`
  /// of the jobs will be not be returned.
  final List<HyperparameterTuningJob>? hyperparameterTuningJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListHyperparameterTuningJobsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListHyperparameterTuningJobsResponse({
    this.hyperparameterTuningJobs,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListHyperparameterTuningJobsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListHyperparameterTuningJobsResponse(
      hyperparameterTuningJobs: decodeListMessage(
        json['hyperparameterTuningJobs'],
        HyperparameterTuningJob.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (hyperparameterTuningJobs != null)
        'hyperparameterTuningJobs': encodeList(hyperparameterTuningJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListHyperparameterTuningJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteHyperparameterTuningJob`.
final class DeleteHyperparameterTuningJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteHyperparameterTuningJobRequest';

  /// Required. The name of the HyperparameterTuningJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  final String name;

  DeleteHyperparameterTuningJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteHyperparameterTuningJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteHyperparameterTuningJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteHyperparameterTuningJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelHyperparameterTuningJob`.
final class CancelHyperparameterTuningJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelHyperparameterTuningJobRequest';

  /// Required. The name of the HyperparameterTuningJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/hyperparameterTuningJobs/{hyperparameter_tuning_job}`
  final String name;

  CancelHyperparameterTuningJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory CancelHyperparameterTuningJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CancelHyperparameterTuningJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelHyperparameterTuningJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CreateNasJob`.
final class CreateNasJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNasJobRequest';

  /// Required. The resource name of the Location to create the NasJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The NasJob to create.
  final NasJob nasJob;

  CreateNasJobRequest({required this.parent, required this.nasJob})
    : super(fullyQualifiedName);

  factory CreateNasJobRequest.fromJson(Map<String, dynamic> json) {
    return CreateNasJobRequest(
      parent: json['parent'],
      nasJob: decode(json['nasJob'], NasJob.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'nasJob': nasJob.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateNasJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetNasJob`.
final class GetNasJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNasJobRequest';

  /// Required. The name of the NasJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  final String name;

  GetNasJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetNasJobRequest.fromJson(Map<String, dynamic> json) {
    return GetNasJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetNasJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListNasJobs`.
final class ListNasJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNasJobsRequest';

  /// Required. The resource name of the Location to list the NasJobs
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListNasJobsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListNasJobs`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListNasJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListNasJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListNasJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListNasJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListNasJobs`
final class ListNasJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNasJobsResponse';

  /// List of NasJobs in the requested page.
  /// `NasJob.nas_job_output`
  /// of the jobs will not be returned.
  final List<NasJob>? nasJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListNasJobsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListNasJobsResponse({this.nasJobs, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListNasJobsResponse.fromJson(Map<String, dynamic> json) {
    return ListNasJobsResponse(
      nasJobs: decodeListMessage(json['nasJobs'], NasJob.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (nasJobs != null) 'nasJobs': encodeList(nasJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListNasJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteNasJob`.
final class DeleteNasJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteNasJobRequest';

  /// Required. The name of the NasJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  final String name;

  DeleteNasJobRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteNasJobRequest.fromJson(Map<String, dynamic> json) {
    return DeleteNasJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteNasJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelNasJob`.
final class CancelNasJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelNasJobRequest';

  /// Required. The name of the NasJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  final String name;

  CancelNasJobRequest({required this.name}) : super(fullyQualifiedName);

  factory CancelNasJobRequest.fromJson(Map<String, dynamic> json) {
    return CancelNasJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelNasJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetNasTrialDetail`.
final class GetNasTrialDetailRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNasTrialDetailRequest';

  /// Required. The name of the NasTrialDetail resource.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}/nasTrialDetails/{nas_trial_detail}`
  final String name;

  GetNasTrialDetailRequest({required this.name}) : super(fullyQualifiedName);

  factory GetNasTrialDetailRequest.fromJson(Map<String, dynamic> json) {
    return GetNasTrialDetailRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetNasTrialDetailRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListNasTrialDetails`.
final class ListNasTrialDetailsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNasTrialDetailsRequest';

  /// Required. The name of the NasJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/nasJobs/{nas_job}`
  final String parent;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListNasTrialDetailsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListNasTrialDetails`
  /// call.
  final String? pageToken;

  ListNasTrialDetailsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListNasTrialDetailsRequest.fromJson(Map<String, dynamic> json) {
    return ListNasTrialDetailsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListNasTrialDetailsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListNasTrialDetails`
final class ListNasTrialDetailsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNasTrialDetailsResponse';

  /// List of top NasTrials in the requested page.
  final List<NasTrialDetail>? nasTrialDetails;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListNasTrialDetailsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListNasTrialDetailsResponse({this.nasTrialDetails, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListNasTrialDetailsResponse.fromJson(Map<String, dynamic> json) {
    return ListNasTrialDetailsResponse(
      nasTrialDetails: decodeListMessage(
        json['nasTrialDetails'],
        NasTrialDetail.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (nasTrialDetails != null)
        'nasTrialDetails': encodeList(nasTrialDetails),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListNasTrialDetailsResponse($contents)';
  }
}

/// Request message for
/// `JobService.CreateBatchPredictionJob`.
final class CreateBatchPredictionJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateBatchPredictionJobRequest';

  /// Required. The resource name of the Location to create the
  /// BatchPredictionJob in. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The BatchPredictionJob to create.
  final BatchPredictionJob batchPredictionJob;

  CreateBatchPredictionJobRequest({
    required this.parent,
    required this.batchPredictionJob,
  }) : super(fullyQualifiedName);

  factory CreateBatchPredictionJobRequest.fromJson(Map<String, dynamic> json) {
    return CreateBatchPredictionJobRequest(
      parent: json['parent'],
      batchPredictionJob: decode(
        json['batchPredictionJob'],
        BatchPredictionJob.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'batchPredictionJob': batchPredictionJob.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateBatchPredictionJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.GetBatchPredictionJob`.
final class GetBatchPredictionJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetBatchPredictionJobRequest';

  /// Required. The name of the BatchPredictionJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  final String name;

  GetBatchPredictionJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetBatchPredictionJobRequest.fromJson(Map<String, dynamic> json) {
    return GetBatchPredictionJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetBatchPredictionJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListBatchPredictionJobs`.
final class ListBatchPredictionJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListBatchPredictionJobsRequest';

  /// Required. The resource name of the Location to list the BatchPredictionJobs
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `model_display_name` supports `=`, `!=` comparisons.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListBatchPredictionJobsResponse.next_page_token`
  /// of the previous
  /// `JobService.ListBatchPredictionJobs`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListBatchPredictionJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListBatchPredictionJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListBatchPredictionJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListBatchPredictionJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListBatchPredictionJobs`
final class ListBatchPredictionJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListBatchPredictionJobsResponse';

  /// List of BatchPredictionJobs in the requested page.
  final List<BatchPredictionJob>? batchPredictionJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListBatchPredictionJobsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListBatchPredictionJobsResponse({
    this.batchPredictionJobs,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListBatchPredictionJobsResponse.fromJson(Map<String, dynamic> json) {
    return ListBatchPredictionJobsResponse(
      batchPredictionJobs: decodeListMessage(
        json['batchPredictionJobs'],
        BatchPredictionJob.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (batchPredictionJobs != null)
        'batchPredictionJobs': encodeList(batchPredictionJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListBatchPredictionJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.DeleteBatchPredictionJob`.
final class DeleteBatchPredictionJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteBatchPredictionJobRequest';

  /// Required. The name of the BatchPredictionJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  final String name;

  DeleteBatchPredictionJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteBatchPredictionJobRequest.fromJson(Map<String, dynamic> json) {
    return DeleteBatchPredictionJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteBatchPredictionJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CancelBatchPredictionJob`.
final class CancelBatchPredictionJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelBatchPredictionJobRequest';

  /// Required. The name of the BatchPredictionJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/batchPredictionJobs/{batch_prediction_job}`
  final String name;

  CancelBatchPredictionJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory CancelBatchPredictionJobRequest.fromJson(Map<String, dynamic> json) {
    return CancelBatchPredictionJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelBatchPredictionJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.CreateModelDeploymentMonitoringJob`.
final class CreateModelDeploymentMonitoringJobRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateModelDeploymentMonitoringJobRequest';

  /// Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The ModelDeploymentMonitoringJob to create
  final ModelDeploymentMonitoringJob modelDeploymentMonitoringJob;

  CreateModelDeploymentMonitoringJobRequest({
    required this.parent,
    required this.modelDeploymentMonitoringJob,
  }) : super(fullyQualifiedName);

  factory CreateModelDeploymentMonitoringJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateModelDeploymentMonitoringJobRequest(
      parent: json['parent'],
      modelDeploymentMonitoringJob: decode(
        json['modelDeploymentMonitoringJob'],
        ModelDeploymentMonitoringJob.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.SearchModelDeploymentMonitoringStatsAnomalies`.
final class SearchModelDeploymentMonitoringStatsAnomaliesRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelDeploymentMonitoringStatsAnomaliesRequest';

  /// Required. ModelDeploymentMonitoring Job resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String modelDeploymentMonitoringJob;

  /// Required. The DeployedModel ID of the
  /// [ModelDeploymentMonitoringObjectiveConfig.deployed_model_id].
  final String? deployedModelId;

  /// The feature display name. If specified, only return the stats belonging to
  /// this feature. Format:
  /// `ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.feature_display_name`,
  /// example: "user_destination".
  final String? featureDisplayName;

  /// Required. Objectives of the stats to retrieve.
  final List<
    SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective
  >?
  objectives;

  /// The standard list page size.
  final int? pageSize;

  /// A page token received from a previous
  /// `JobService.SearchModelDeploymentMonitoringStatsAnomalies`
  /// call.
  final String? pageToken;

  /// The earliest timestamp of stats being generated.
  /// If not set, indicates fetching stats till the earliest possible one.
  final protobuf.Timestamp? startTime;

  /// The latest timestamp of stats being generated.
  /// If not set, indicates feching stats till the latest possible one.
  final protobuf.Timestamp? endTime;

  SearchModelDeploymentMonitoringStatsAnomaliesRequest({
    required this.modelDeploymentMonitoringJob,
    this.deployedModelId,
    this.featureDisplayName,
    this.objectives,
    this.pageSize,
    this.pageToken,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory SearchModelDeploymentMonitoringStatsAnomaliesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchModelDeploymentMonitoringStatsAnomaliesRequest(
      modelDeploymentMonitoringJob: json['modelDeploymentMonitoringJob'],
      deployedModelId: json['deployedModelId'],
      featureDisplayName: json['featureDisplayName'],
      objectives: decodeListMessage(
        json['objectives'],
        SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective
            .fromJson,
      ),
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob,
      if (deployedModelId != null) 'deployedModelId': deployedModelId,
      if (featureDisplayName != null) 'featureDisplayName': featureDisplayName,
      if (objectives != null) 'objectives': encodeList(objectives),
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'modelDeploymentMonitoringJob=$modelDeploymentMonitoringJob',
      if (deployedModelId != null) 'deployedModelId=$deployedModelId',
      if (featureDisplayName != null) 'featureDisplayName=$featureDisplayName',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'SearchModelDeploymentMonitoringStatsAnomaliesRequest($contents)';
  }
}

/// Stats requested for specific objective.
final class SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelDeploymentMonitoringStatsAnomaliesRequest.StatsAnomaliesObjective';

  final ModelDeploymentMonitoringObjectiveType? type;

  /// If set, all attribution scores between
  /// `SearchModelDeploymentMonitoringStatsAnomaliesRequest.start_time`
  /// and
  /// `SearchModelDeploymentMonitoringStatsAnomaliesRequest.end_time`
  /// are fetched, and page token doesn't take effect in this case. Only used
  /// to retrieve attribution score for the top Features which has the highest
  /// attribution score in the latest monitoring run.
  final int? topFeatureCount;

  SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective({
    this.type,
    this.topFeatureCount,
  }) : super(fullyQualifiedName);

  factory SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchModelDeploymentMonitoringStatsAnomaliesRequest_StatsAnomaliesObjective(
      type: decodeEnum(
        json['type'],
        ModelDeploymentMonitoringObjectiveType.fromJson,
      ),
      topFeatureCount: json['topFeatureCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (type != null) 'type': type!.toJson(),
      if (topFeatureCount != null) 'topFeatureCount': topFeatureCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (type != null) 'type=$type',
      if (topFeatureCount != null) 'topFeatureCount=$topFeatureCount',
    ].join(',');
    return 'StatsAnomaliesObjective($contents)';
  }
}

/// Response message for
/// `JobService.SearchModelDeploymentMonitoringStatsAnomalies`.
final class SearchModelDeploymentMonitoringStatsAnomaliesResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelDeploymentMonitoringStatsAnomaliesResponse';

  /// Stats retrieved for requested objectives.
  /// There are at most 1000
  /// `ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies.prediction_stats`
  /// in the response.
  final List<ModelMonitoringStatsAnomalies>? monitoringStats;

  /// The page token that can be used by the next
  /// `JobService.SearchModelDeploymentMonitoringStatsAnomalies`
  /// call.
  final String? nextPageToken;

  SearchModelDeploymentMonitoringStatsAnomaliesResponse({
    this.monitoringStats,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory SearchModelDeploymentMonitoringStatsAnomaliesResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchModelDeploymentMonitoringStatsAnomaliesResponse(
      monitoringStats: decodeListMessage(
        json['monitoringStats'],
        ModelMonitoringStatsAnomalies.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (monitoringStats != null)
        'monitoringStats': encodeList(monitoringStats),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'SearchModelDeploymentMonitoringStatsAnomaliesResponse($contents)';
  }
}

/// Request message for
/// `JobService.GetModelDeploymentMonitoringJob`.
final class GetModelDeploymentMonitoringJobRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelDeploymentMonitoringJobRequest';

  /// Required. The resource name of the ModelDeploymentMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String name;

  GetModelDeploymentMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetModelDeploymentMonitoringJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return GetModelDeploymentMonitoringJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ListModelDeploymentMonitoringJobs`.
final class ListModelDeploymentMonitoringJobsRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelDeploymentMonitoringJobsRequest';

  /// Required. The parent of the ModelDeploymentMonitoringJob.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="JOB_STATE_SUCCEEDED" AND display_name:"my_job_*"`
  ///   * `state!="JOB_STATE_FAILED" OR display_name="my_job"`
  ///   * `NOT display_name="my_job"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `labels.keyA=valueA`
  ///   * `labels.keyB:*`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  final String? pageToken;

  /// Mask specifying which fields to read
  final protobuf.FieldMask? readMask;

  ListModelDeploymentMonitoringJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelDeploymentMonitoringJobsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListModelDeploymentMonitoringJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListModelDeploymentMonitoringJobsRequest($contents)';
  }
}

/// Response message for
/// `JobService.ListModelDeploymentMonitoringJobs`.
final class ListModelDeploymentMonitoringJobsResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelDeploymentMonitoringJobsResponse';

  /// A list of ModelDeploymentMonitoringJobs that matches the specified filter
  /// in the request.
  final List<ModelDeploymentMonitoringJob>? modelDeploymentMonitoringJobs;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListModelDeploymentMonitoringJobsResponse({
    this.modelDeploymentMonitoringJobs,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListModelDeploymentMonitoringJobsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListModelDeploymentMonitoringJobsResponse(
      modelDeploymentMonitoringJobs: decodeListMessage(
        json['modelDeploymentMonitoringJobs'],
        ModelDeploymentMonitoringJob.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (modelDeploymentMonitoringJobs != null)
        'modelDeploymentMonitoringJobs': encodeList(
          modelDeploymentMonitoringJobs,
        ),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListModelDeploymentMonitoringJobsResponse($contents)';
  }
}

/// Request message for
/// `JobService.UpdateModelDeploymentMonitoringJob`.
final class UpdateModelDeploymentMonitoringJobRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelDeploymentMonitoringJobRequest';

  /// Required. The model monitoring configuration which replaces the resource on
  /// the server.
  final ModelDeploymentMonitoringJob modelDeploymentMonitoringJob;

  /// Required. The update mask is used to specify the fields to be overwritten
  /// in the ModelDeploymentMonitoringJob resource by the update. The fields
  /// specified in the update_mask are relative to the resource, not the full
  /// request. A field will be overwritten if it is in the mask. If the user does
  /// not provide a mask then only the non-empty fields present in the request
  /// will be overwritten. Set the update_mask to `*` to override all fields. For
  /// the objective config, the user can either provide the update mask for
  /// model_deployment_monitoring_objective_configs or any combination of its
  /// nested fields, such as:
  /// model_deployment_monitoring_objective_configs.objective_config.training_dataset.
  ///
  /// Updatable fields:
  ///
  ///   * `display_name`
  ///   * `model_deployment_monitoring_schedule_config`
  ///   * `model_monitoring_alert_config`
  ///   * `logging_sampling_strategy`
  ///   * `labels`
  ///   * `log_ttl`
  ///   * `enable_monitoring_pipeline_logs`
  /// .  and
  ///   * `model_deployment_monitoring_objective_configs`
  /// .  or
  ///   * `model_deployment_monitoring_objective_configs.objective_config.training_dataset`
  ///   * `model_deployment_monitoring_objective_configs.objective_config.training_prediction_skew_detection_config`
  ///   * `model_deployment_monitoring_objective_configs.objective_config.prediction_drift_detection_config`
  final protobuf.FieldMask? updateMask;

  UpdateModelDeploymentMonitoringJobRequest({
    required this.modelDeploymentMonitoringJob,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateModelDeploymentMonitoringJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateModelDeploymentMonitoringJobRequest(
      modelDeploymentMonitoringJob: decode(
        json['modelDeploymentMonitoringJob'],
        ModelDeploymentMonitoringJob.fromJson,
      )!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'modelDeploymentMonitoringJob': modelDeploymentMonitoringJob.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateModelDeploymentMonitoringJobRequest()';
}

/// Request message for
/// `JobService.DeleteModelDeploymentMonitoringJob`.
final class DeleteModelDeploymentMonitoringJobRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelDeploymentMonitoringJobRequest';

  /// Required. The resource name of the model monitoring job to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String name;

  DeleteModelDeploymentMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteModelDeploymentMonitoringJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteModelDeploymentMonitoringJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.PauseModelDeploymentMonitoringJob`.
final class PauseModelDeploymentMonitoringJobRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PauseModelDeploymentMonitoringJobRequest';

  /// Required. The resource name of the ModelDeploymentMonitoringJob to pause.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String name;

  PauseModelDeploymentMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory PauseModelDeploymentMonitoringJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return PauseModelDeploymentMonitoringJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'PauseModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `JobService.ResumeModelDeploymentMonitoringJob`.
final class ResumeModelDeploymentMonitoringJobRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResumeModelDeploymentMonitoringJobRequest';

  /// Required. The resource name of the ModelDeploymentMonitoringJob to resume.
  /// Format:
  /// `projects/{project}/locations/{location}/modelDeploymentMonitoringJobs/{model_deployment_monitoring_job}`
  final String name;

  ResumeModelDeploymentMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory ResumeModelDeploymentMonitoringJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ResumeModelDeploymentMonitoringJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ResumeModelDeploymentMonitoringJobRequest($contents)';
  }
}

/// Runtime operation information for
/// `JobService.UpdateModelDeploymentMonitoringJob`.
final class UpdateModelDeploymentMonitoringJobOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelDeploymentMonitoringJobOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateModelDeploymentMonitoringJobOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateModelDeploymentMonitoringJobOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateModelDeploymentMonitoringJobOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateModelDeploymentMonitoringJobOperationMetadata()';
}

/// A subgraph of the overall lineage graph. Event edges connect Artifact and
/// Execution nodes.
final class LineageSubgraph extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LineageSubgraph';

  /// The Artifact nodes in the subgraph.
  final List<Artifact>? artifacts;

  /// The Execution nodes in the subgraph.
  final List<Execution>? executions;

  /// The Event edges between Artifacts and Executions in the subgraph.
  final List<Event>? events;

  LineageSubgraph({this.artifacts, this.executions, this.events})
    : super(fullyQualifiedName);

  factory LineageSubgraph.fromJson(Map<String, dynamic> json) {
    return LineageSubgraph(
      artifacts: decodeListMessage(json['artifacts'], Artifact.fromJson),
      executions: decodeListMessage(json['executions'], Execution.fromJson),
      events: decodeListMessage(json['events'], Event.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (artifacts != null) 'artifacts': encodeList(artifacts),
      if (executions != null) 'executions': encodeList(executions),
      if (events != null) 'events': encodeList(events),
    };
  }

  @override
  String toString() => 'LineageSubgraph()';
}

/// Request message for ComputeTokens RPC call.
final class ComputeTokensRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ComputeTokensRequest';

  /// Required. The name of the Endpoint requested to get lists of tokens and
  /// token ids.
  final String endpoint;

  /// Optional. The instances that are the input to token computing API call.
  /// Schema is identical to the prediction schema of the text model, even for
  /// the non-text models, like chat models, or Codey models.
  final List<protobuf.Value>? instances;

  /// Optional. The name of the publisher model requested to serve the
  /// prediction. Format:
  /// projects/{project}/locations/{location}/publishers/*/models/*
  final String? model;

  /// Optional. Input content.
  final List<Content>? contents;

  ComputeTokensRequest({
    required this.endpoint,
    this.instances,
    this.model,
    this.contents,
  }) : super(fullyQualifiedName);

  factory ComputeTokensRequest.fromJson(Map<String, dynamic> json) {
    return ComputeTokensRequest(
      endpoint: json['endpoint'],
      instances: decodeListMessageCustom(
        json['instances'],
        protobuf.Value.fromJson,
      ),
      model: json['model'],
      contents: decodeListMessage(json['contents'], Content.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (instances != null) 'instances': encodeList(instances),
      if (model != null) 'model': model,
      if (contents != null) 'contents': encodeList(contents),
    };
  }

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      if (model != null) 'model=$model',
    ].join(',');
    return 'ComputeTokensRequest($contents)';
  }
}

/// Tokens info with a list of tokens and the corresponding list of token ids.
final class TokensInfo extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TokensInfo';

  /// A list of tokens from the input.
  final List<Uint8List>? tokens;

  /// A list of token ids from the input.
  final List<int>? tokenIds;

  /// Optional. Optional fields for the role from the corresponding Content.
  final String? role;

  TokensInfo({this.tokens, this.tokenIds, this.role})
    : super(fullyQualifiedName);

  factory TokensInfo.fromJson(Map<String, dynamic> json) {
    return TokensInfo(
      tokens: decodeListBytes(json['tokens']),
      tokenIds: decodeList(json['tokenIds']),
      role: json['role'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tokens != null) 'tokens': encodeListBytes(tokens),
      if (tokenIds != null) 'tokenIds': tokenIds,
      if (role != null) 'role': role,
    };
  }

  @override
  String toString() {
    final contents = [if (role != null) 'role=$role'].join(',');
    return 'TokensInfo($contents)';
  }
}

/// Response message for ComputeTokens RPC call.
final class ComputeTokensResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ComputeTokensResponse';

  /// Lists of tokens info from the input. A ComputeTokensRequest could have
  /// multiple instances with a prompt in each instance. We also need to return
  /// lists of tokens info for the request with multiple instances.
  final List<TokensInfo>? tokensInfo;

  ComputeTokensResponse({this.tokensInfo}) : super(fullyQualifiedName);

  factory ComputeTokensResponse.fromJson(Map<String, dynamic> json) {
    return ComputeTokensResponse(
      tokensInfo: decodeListMessage(json['tokensInfo'], TokensInfo.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (tokensInfo != null) 'tokensInfo': encodeList(tokensInfo)};
  }

  @override
  String toString() => 'ComputeTokensResponse()';
}

/// Specification of a single machine.
final class MachineSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MachineSpec';

  /// Immutable. The type of the machine.
  ///
  /// See the [list of machine types supported for
  /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/configure-compute#machine-types)
  ///
  /// See the [list of machine types supported for custom
  /// training](https://cloud.google.com/vertex-ai/docs/training/configure-compute#machine-types).
  ///
  /// For `DeployedModel` this
  /// field is optional, and the default value is `n1-standard-2`. For
  /// `BatchPredictionJob` or
  /// as part of `WorkerPoolSpec`
  /// this field is required.
  final String? machineType;

  /// Immutable. The type of accelerator(s) that may be attached to the machine
  /// as per
  /// `accelerator_count`.
  final AcceleratorType? acceleratorType;

  /// The number of accelerators to attach to the machine.
  final int? acceleratorCount;

  /// Optional. Immutable. The Nvidia GPU partition size.
  ///
  /// When specified, the requested accelerators will be partitioned into
  /// smaller GPU partitions. For example, if the request is for 8 units of
  /// NVIDIA A100 GPUs, and gpu_partition_size="1g.10gb", the service will
  /// create 8 * 7 = 56 partitioned MIG instances.
  ///
  /// The partition size must be a value supported by the requested accelerator.
  /// Refer to
  /// [Nvidia GPU
  /// Partitioning](https://cloud.google.com/kubernetes-engine/docs/how-to/gpus-multi#multi-instance_gpu_partitions)
  /// for the available partition sizes.
  ///
  /// If set, the accelerator_count should be set to 1.
  final String? gpuPartitionSize;

  /// Immutable. The topology of the TPUs. Corresponds to the TPU topologies
  /// available from GKE. (Example: tpu_topology: "2x2x1").
  final String? tpuTopology;

  /// Optional. Immutable. The number of nodes per replica for multihost GPU
  /// deployments.
  final int? multihostGpuNodeCount;

  /// Optional. Immutable. Configuration controlling how this resource pool
  /// consumes reservation.
  final ReservationAffinity? reservationAffinity;

  MachineSpec({
    this.machineType,
    this.acceleratorType,
    this.acceleratorCount,
    this.gpuPartitionSize,
    this.tpuTopology,
    this.multihostGpuNodeCount,
    this.reservationAffinity,
  }) : super(fullyQualifiedName);

  factory MachineSpec.fromJson(Map<String, dynamic> json) {
    return MachineSpec(
      machineType: json['machineType'],
      acceleratorType: decodeEnum(
        json['acceleratorType'],
        AcceleratorType.fromJson,
      ),
      acceleratorCount: json['acceleratorCount'],
      gpuPartitionSize: json['gpuPartitionSize'],
      tpuTopology: json['tpuTopology'],
      multihostGpuNodeCount: json['multihostGpuNodeCount'],
      reservationAffinity: decode(
        json['reservationAffinity'],
        ReservationAffinity.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (machineType != null) 'machineType': machineType,
      if (acceleratorType != null) 'acceleratorType': acceleratorType!.toJson(),
      if (acceleratorCount != null) 'acceleratorCount': acceleratorCount,
      if (gpuPartitionSize != null) 'gpuPartitionSize': gpuPartitionSize,
      if (tpuTopology != null) 'tpuTopology': tpuTopology,
      if (multihostGpuNodeCount != null)
        'multihostGpuNodeCount': multihostGpuNodeCount,
      if (reservationAffinity != null)
        'reservationAffinity': reservationAffinity!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (machineType != null) 'machineType=$machineType',
      if (acceleratorType != null) 'acceleratorType=$acceleratorType',
      if (acceleratorCount != null) 'acceleratorCount=$acceleratorCount',
      if (gpuPartitionSize != null) 'gpuPartitionSize=$gpuPartitionSize',
      if (tpuTopology != null) 'tpuTopology=$tpuTopology',
      if (multihostGpuNodeCount != null)
        'multihostGpuNodeCount=$multihostGpuNodeCount',
    ].join(',');
    return 'MachineSpec($contents)';
  }
}

/// A description of resources that are dedicated to a DeployedModel or
/// DeployedIndex, and that need a higher degree of manual configuration.
final class DedicatedResources extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DedicatedResources';

  /// Required. Immutable. The specification of a single machine being used.
  final MachineSpec? machineSpec;

  /// Required. Immutable. The minimum number of machine replicas that will be
  /// always deployed on. This value must be greater than or equal to 1.
  ///
  /// If traffic increases, it may dynamically be deployed onto more replicas,
  /// and as traffic decreases, some of these extra replicas may be freed.
  final int? minReplicaCount;

  /// Immutable. The maximum number of replicas that may be deployed on when the
  /// traffic against it increases. If the requested value is too large, the
  /// deployment will error, but if deployment succeeds then the ability to scale
  /// to that many replicas is guaranteed (barring service outages). If traffic
  /// increases beyond what its replicas at maximum may handle, a portion of the
  /// traffic will be dropped. If this value is not provided, will use
  /// `min_replica_count`
  /// as the default value.
  ///
  /// The value of this field impacts the charge against Vertex CPU and GPU
  /// quotas. Specifically, you will be charged for (max_replica_count *
  /// number of cores in the selected machine type) and (max_replica_count *
  /// number of GPUs per replica in the selected machine type).
  final int? maxReplicaCount;

  /// Optional. Number of required available replicas for the deployment to
  /// succeed. This field is only needed when partial deployment/mutation is
  /// desired. If set, the deploy/mutate operation will succeed once
  /// available_replica_count reaches required_replica_count, and the rest of
  /// the replicas will be retried. If not set, the default
  /// required_replica_count will be min_replica_count.
  final int? requiredReplicaCount;

  /// Immutable. Number of initial replicas being deployed on when scaling the
  /// workload up from zero or when creating the workload in case
  /// `min_replica_count`
  /// = 0. When
  /// `min_replica_count`
  /// > 0 (meaning that the scale-to-zero feature is not enabled),
  /// `initial_replica_count`
  /// should not be set. When
  /// `min_replica_count`
  /// = 0 (meaning that the scale-to-zero feature is enabled),
  /// `initial_replica_count`
  /// should be larger than zero, but no greater than
  /// `max_replica_count`.
  final int? initialReplicaCount;

  /// Immutable. The metric specifications that overrides a resource
  /// utilization metric (CPU utilization, accelerator's duty cycle, and so on)
  /// target value (default to 60 if not set). At most one entry is allowed per
  /// metric.
  ///
  /// If
  /// `machine_spec.accelerator_count`
  /// is above 0, the autoscaling will be based on both CPU utilization and
  /// accelerator's duty cycle metrics and scale up when either metrics exceeds
  /// its target value while scale down if both metrics are under their target
  /// value. The default target value is 60 for both metrics.
  ///
  /// If
  /// `machine_spec.accelerator_count`
  /// is 0, the autoscaling will be based on CPU utilization metric only with
  /// default target value 60 if not explicitly set.
  ///
  /// For example, in the case of Online Prediction, if you want to override
  /// target CPU utilization to 80, you should set
  /// `autoscaling_metric_specs.metric_name`
  /// to `aiplatform.googleapis.com/prediction/online/cpu/utilization` and
  /// `autoscaling_metric_specs.target`
  /// to `80`.
  final List<AutoscalingMetricSpec>? autoscalingMetricSpecs;

  /// Optional. If true, schedule the deployment workload on [spot
  /// VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
  final bool? spot;

  /// Optional. Immutable. If set, use DWS resource to schedule the deployment
  /// workload. reference:
  /// (https://cloud.google.com/blog/products/compute/introducing-dynamic-workload-scheduler)
  final FlexStart? flexStart;

  /// Optional. Specification for scale-to-zero feature.
  final DedicatedResources_ScaleToZeroSpec? scaleToZeroSpec;

  DedicatedResources({
    this.machineSpec,
    this.minReplicaCount,
    this.maxReplicaCount,
    this.requiredReplicaCount,
    this.initialReplicaCount,
    this.autoscalingMetricSpecs,
    this.spot,
    this.flexStart,
    this.scaleToZeroSpec,
  }) : super(fullyQualifiedName);

  factory DedicatedResources.fromJson(Map<String, dynamic> json) {
    return DedicatedResources(
      machineSpec: decode(json['machineSpec'], MachineSpec.fromJson),
      minReplicaCount: json['minReplicaCount'],
      maxReplicaCount: json['maxReplicaCount'],
      requiredReplicaCount: json['requiredReplicaCount'],
      initialReplicaCount: json['initialReplicaCount'],
      autoscalingMetricSpecs: decodeListMessage(
        json['autoscalingMetricSpecs'],
        AutoscalingMetricSpec.fromJson,
      ),
      spot: json['spot'],
      flexStart: decode(json['flexStart'], FlexStart.fromJson),
      scaleToZeroSpec: decode(
        json['scaleToZeroSpec'],
        DedicatedResources_ScaleToZeroSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
      if (minReplicaCount != null) 'minReplicaCount': minReplicaCount,
      if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount,
      if (requiredReplicaCount != null)
        'requiredReplicaCount': requiredReplicaCount,
      if (initialReplicaCount != null)
        'initialReplicaCount': initialReplicaCount,
      if (autoscalingMetricSpecs != null)
        'autoscalingMetricSpecs': encodeList(autoscalingMetricSpecs),
      if (spot != null) 'spot': spot,
      if (flexStart != null) 'flexStart': flexStart!.toJson(),
      if (scaleToZeroSpec != null) 'scaleToZeroSpec': scaleToZeroSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (minReplicaCount != null) 'minReplicaCount=$minReplicaCount',
      if (maxReplicaCount != null) 'maxReplicaCount=$maxReplicaCount',
      if (requiredReplicaCount != null)
        'requiredReplicaCount=$requiredReplicaCount',
      if (initialReplicaCount != null)
        'initialReplicaCount=$initialReplicaCount',
      if (spot != null) 'spot=$spot',
    ].join(',');
    return 'DedicatedResources($contents)';
  }
}

/// Specification for scale-to-zero feature.
final class DedicatedResources_ScaleToZeroSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DedicatedResources.ScaleToZeroSpec';

  /// Optional. Minimum duration that a deployment will be scaled up before
  /// traffic is evaluated for potential scale-down. [MinValue=300] (5 minutes)
  /// [MaxValue=28800] (8 hours)
  final protobuf.Duration? minScaleupPeriod;

  /// Optional. Duration of no traffic before scaling to zero.
  /// [MinValue=3600] (5 minutes)
  /// [MaxValue=28800] (8 hours)
  final protobuf.Duration? idleScaledownPeriod;

  DedicatedResources_ScaleToZeroSpec({
    this.minScaleupPeriod,
    this.idleScaledownPeriod,
  }) : super(fullyQualifiedName);

  factory DedicatedResources_ScaleToZeroSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return DedicatedResources_ScaleToZeroSpec(
      minScaleupPeriod: decodeCustom(
        json['minScaleupPeriod'],
        protobuf.Duration.fromJson,
      ),
      idleScaledownPeriod: decodeCustom(
        json['idleScaledownPeriod'],
        protobuf.Duration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (minScaleupPeriod != null)
        'minScaleupPeriod': minScaleupPeriod!.toJson(),
      if (idleScaledownPeriod != null)
        'idleScaledownPeriod': idleScaledownPeriod!.toJson(),
    };
  }

  @override
  String toString() => 'ScaleToZeroSpec()';
}

/// A description of resources that to large degree are decided by Vertex AI,
/// and require only a modest additional configuration.
/// Each Model supporting these resources documents its specific guidelines.
final class AutomaticResources extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AutomaticResources';

  /// Immutable. The minimum number of replicas that will be always deployed on.
  /// If traffic against it increases, it may dynamically be deployed onto more
  /// replicas up to
  /// `max_replica_count`,
  /// and as traffic decreases, some of these extra replicas may be freed. If the
  /// requested value is too large, the deployment will error.
  final int? minReplicaCount;

  /// Immutable. The maximum number of replicas that may be deployed on when the
  /// traffic against it increases. If the requested value is too large, the
  /// deployment will error, but if deployment succeeds then the ability to scale
  /// to that many replicas is guaranteed (barring service outages). If traffic
  /// increases beyond what its replicas at maximum may handle, a portion of the
  /// traffic will be dropped. If this value is not provided, a no upper bound
  /// for scaling under heavy traffic will be assume, though Vertex AI may be
  /// unable to scale beyond certain replica number.
  final int? maxReplicaCount;

  AutomaticResources({this.minReplicaCount, this.maxReplicaCount})
    : super(fullyQualifiedName);

  factory AutomaticResources.fromJson(Map<String, dynamic> json) {
    return AutomaticResources(
      minReplicaCount: json['minReplicaCount'],
      maxReplicaCount: json['maxReplicaCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (minReplicaCount != null) 'minReplicaCount': minReplicaCount,
      if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (minReplicaCount != null) 'minReplicaCount=$minReplicaCount',
      if (maxReplicaCount != null) 'maxReplicaCount=$maxReplicaCount',
    ].join(',');
    return 'AutomaticResources($contents)';
  }
}

/// A description of resources that are used for performing batch operations, are
/// dedicated to a Model, and need manual configuration.
final class BatchDedicatedResources extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchDedicatedResources';

  /// Required. Immutable. The specification of a single machine.
  final MachineSpec? machineSpec;

  /// Immutable. The number of machine replicas used at the start of the batch
  /// operation. If not set, Vertex AI decides starting number, not greater than
  /// `max_replica_count`
  final int? startingReplicaCount;

  /// Immutable. The maximum number of machine replicas the batch operation may
  /// be scaled to. The default value is 10.
  final int? maxReplicaCount;

  /// Optional. Immutable. If set, use DWS resource to schedule the deployment
  /// workload. reference:
  /// (https://cloud.google.com/blog/products/compute/introducing-dynamic-workload-scheduler)
  final FlexStart? flexStart;

  /// Optional. If true, schedule the deployment workload on [spot
  /// VMs](https://cloud.google.com/kubernetes-engine/docs/concepts/spot-vms).
  final bool? spot;

  BatchDedicatedResources({
    this.machineSpec,
    this.startingReplicaCount,
    this.maxReplicaCount,
    this.flexStart,
    this.spot,
  }) : super(fullyQualifiedName);

  factory BatchDedicatedResources.fromJson(Map<String, dynamic> json) {
    return BatchDedicatedResources(
      machineSpec: decode(json['machineSpec'], MachineSpec.fromJson),
      startingReplicaCount: json['startingReplicaCount'],
      maxReplicaCount: json['maxReplicaCount'],
      flexStart: decode(json['flexStart'], FlexStart.fromJson),
      spot: json['spot'],
    );
  }

  @override
  Object toJson() {
    return {
      if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
      if (startingReplicaCount != null)
        'startingReplicaCount': startingReplicaCount,
      if (maxReplicaCount != null) 'maxReplicaCount': maxReplicaCount,
      if (flexStart != null) 'flexStart': flexStart!.toJson(),
      if (spot != null) 'spot': spot,
    };
  }

  @override
  String toString() {
    final contents = [
      if (startingReplicaCount != null)
        'startingReplicaCount=$startingReplicaCount',
      if (maxReplicaCount != null) 'maxReplicaCount=$maxReplicaCount',
      if (spot != null) 'spot=$spot',
    ].join(',');
    return 'BatchDedicatedResources($contents)';
  }
}

/// Statistics information about resource consumption.
final class ResourcesConsumed extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourcesConsumed';

  /// Output only. The number of replica hours used. Note that many replicas may
  /// run in parallel, and additionally any given work may be queued for some
  /// time. Therefore this value is not strictly related to wall time.
  final double? replicaHours;

  ResourcesConsumed({this.replicaHours}) : super(fullyQualifiedName);

  factory ResourcesConsumed.fromJson(Map<String, dynamic> json) {
    return ResourcesConsumed(replicaHours: decodeDouble(json['replicaHours']));
  }

  @override
  Object toJson() {
    return {
      if (replicaHours != null) 'replicaHours': encodeDouble(replicaHours),
    };
  }

  @override
  String toString() {
    final contents = [
      if (replicaHours != null) 'replicaHours=$replicaHours',
    ].join(',');
    return 'ResourcesConsumed($contents)';
  }
}

/// Represents the spec of disk options.
final class DiskSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DiskSpec';

  /// Type of the boot disk. For non-A3U machines, the default value is
  /// "pd-ssd", for A3U machines, the default value is "hyperdisk-balanced".
  /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive),
  /// "pd-standard" (Persistent Disk Hard Disk Drive) or "hyperdisk-balanced".
  final String? bootDiskType;

  /// Size in GB of the boot disk (default is 100GB).
  final int? bootDiskSizeGb;

  DiskSpec({this.bootDiskType, this.bootDiskSizeGb})
    : super(fullyQualifiedName);

  factory DiskSpec.fromJson(Map<String, dynamic> json) {
    return DiskSpec(
      bootDiskType: json['bootDiskType'],
      bootDiskSizeGb: json['bootDiskSizeGb'],
    );
  }

  @override
  Object toJson() {
    return {
      if (bootDiskType != null) 'bootDiskType': bootDiskType,
      if (bootDiskSizeGb != null) 'bootDiskSizeGb': bootDiskSizeGb,
    };
  }

  @override
  String toString() {
    final contents = [
      if (bootDiskType != null) 'bootDiskType=$bootDiskType',
      if (bootDiskSizeGb != null) 'bootDiskSizeGb=$bootDiskSizeGb',
    ].join(',');
    return 'DiskSpec($contents)';
  }
}

/// Represents the spec of [persistent
/// disk][https://cloud.google.com/compute/docs/disks/persistent-disks] options.
final class PersistentDiskSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PersistentDiskSpec';

  /// Type of the disk (default is "pd-standard").
  /// Valid values: "pd-ssd" (Persistent Disk Solid State Drive)
  /// "pd-standard" (Persistent Disk Hard Disk Drive)
  /// "pd-balanced" (Balanced Persistent Disk)
  /// "pd-extreme" (Extreme Persistent Disk)
  final String? diskType;

  /// Size in GB of the disk (default is 100GB).
  final int? diskSizeGb;

  PersistentDiskSpec({this.diskType, this.diskSizeGb})
    : super(fullyQualifiedName);

  factory PersistentDiskSpec.fromJson(Map<String, dynamic> json) {
    return PersistentDiskSpec(
      diskType: json['diskType'],
      diskSizeGb: decodeInt64(json['diskSizeGb']),
    );
  }

  @override
  Object toJson() {
    return {
      if (diskType != null) 'diskType': diskType,
      if (diskSizeGb != null) 'diskSizeGb': encodeInt64(diskSizeGb),
    };
  }

  @override
  String toString() {
    final contents = [
      if (diskType != null) 'diskType=$diskType',
      if (diskSizeGb != null) 'diskSizeGb=$diskSizeGb',
    ].join(',');
    return 'PersistentDiskSpec($contents)';
  }
}

/// Represents a mount configuration for Network File System (NFS) to mount.
final class NfsMount extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NfsMount';

  /// Required. IP address of the NFS server.
  final String? server;

  /// Required. Source path exported from NFS server.
  /// Has to start with '/', and combined with the ip address, it indicates
  /// the source mount path in the form of `server:path`
  final String? path;

  /// Required. Destination mount path. The NFS will be mounted for the user
  /// under /mnt/nfs/<mount_point>
  final String? mountPoint;

  NfsMount({this.server, this.path, this.mountPoint})
    : super(fullyQualifiedName);

  factory NfsMount.fromJson(Map<String, dynamic> json) {
    return NfsMount(
      server: json['server'],
      path: json['path'],
      mountPoint: json['mountPoint'],
    );
  }

  @override
  Object toJson() {
    return {
      if (server != null) 'server': server,
      if (path != null) 'path': path,
      if (mountPoint != null) 'mountPoint': mountPoint,
    };
  }

  @override
  String toString() {
    final contents = [
      if (server != null) 'server=$server',
      if (path != null) 'path=$path',
      if (mountPoint != null) 'mountPoint=$mountPoint',
    ].join(',');
    return 'NfsMount($contents)';
  }
}

/// The metric specification that defines the target resource utilization
/// (CPU utilization, accelerator's duty cycle, and so on) for calculating the
/// desired replica count.
final class AutoscalingMetricSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AutoscalingMetricSpec';

  /// Required. The resource metric name.
  /// Supported metrics:
  ///
  /// * For Online Prediction:
  /// * `aiplatform.googleapis.com/prediction/online/accelerator/duty_cycle`
  /// * `aiplatform.googleapis.com/prediction/online/cpu/utilization`
  /// * `aiplatform.googleapis.com/prediction/online/request_count`
  final String? metricName;

  /// The target resource utilization in percentage (1% - 100%) for the given
  /// metric; once the real usage deviates from the target by a certain
  /// percentage, the machine replicas change. The default value is 60
  /// (representing 60%) if not provided.
  final int? target;

  /// Optional. The Cloud Monitoring monitored resource labels as key value pairs
  /// used for metrics filtering. See Cloud Monitoring Labels
  /// https://cloud.google.com/monitoring/api/v3/metric-model#generic-label-info
  final Map<String, String>? monitoredResourceLabels;

  AutoscalingMetricSpec({
    this.metricName,
    this.target,
    this.monitoredResourceLabels,
  }) : super(fullyQualifiedName);

  factory AutoscalingMetricSpec.fromJson(Map<String, dynamic> json) {
    return AutoscalingMetricSpec(
      metricName: json['metricName'],
      target: json['target'],
      monitoredResourceLabels: decodeMap(json['monitoredResourceLabels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricName != null) 'metricName': metricName,
      if (target != null) 'target': target,
      if (monitoredResourceLabels != null)
        'monitoredResourceLabels': monitoredResourceLabels,
    };
  }

  @override
  String toString() {
    final contents = [
      if (metricName != null) 'metricName=$metricName',
      if (target != null) 'target=$target',
    ].join(',');
    return 'AutoscalingMetricSpec($contents)';
  }
}

/// A set of Shielded Instance options.
/// See [Images using supported Shielded VM
/// features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
final class ShieldedVmConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ShieldedVmConfig';

  /// Defines whether the instance has [Secure
  /// Boot](https://cloud.google.com/compute/shielded-vm/docs/shielded-vm#secure-boot)
  /// enabled.
  ///
  /// Secure Boot helps ensure that the system only runs authentic software by
  /// verifying the digital signature of all boot components, and halting the
  /// boot process if signature verification fails.
  final bool? enableSecureBoot;

  ShieldedVmConfig({this.enableSecureBoot}) : super(fullyQualifiedName);

  factory ShieldedVmConfig.fromJson(Map<String, dynamic> json) {
    return ShieldedVmConfig(enableSecureBoot: json['enableSecureBoot']);
  }

  @override
  Object toJson() {
    return {if (enableSecureBoot != null) 'enableSecureBoot': enableSecureBoot};
  }

  @override
  String toString() {
    final contents = [
      if (enableSecureBoot != null) 'enableSecureBoot=$enableSecureBoot',
    ].join(',');
    return 'ShieldedVmConfig($contents)';
  }
}

/// FlexStart is used to schedule the deployment workload on DWS resource. It
/// contains the max duration of the deployment.
final class FlexStart extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FlexStart';

  /// The max duration of the deployment is max_runtime_duration. The
  /// deployment will be terminated after the duration. The
  /// max_runtime_duration can be set up to 7 days.
  final protobuf.Duration? maxRuntimeDuration;

  FlexStart({this.maxRuntimeDuration}) : super(fullyQualifiedName);

  factory FlexStart.fromJson(Map<String, dynamic> json) {
    return FlexStart(
      maxRuntimeDuration: decodeCustom(
        json['maxRuntimeDuration'],
        protobuf.Duration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (maxRuntimeDuration != null)
        'maxRuntimeDuration': maxRuntimeDuration!.toJson(),
    };
  }

  @override
  String toString() => 'FlexStart()';
}

/// Manual batch tuning parameters.
final class ManualBatchTuningParameters extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ManualBatchTuningParameters';

  /// Immutable. The number of the records (e.g. instances) of the operation
  /// given in each batch to a machine replica. Machine type, and size of a
  /// single record should be considered when setting this parameter, higher
  /// value speeds up the batch operation's execution, but too high value will
  /// result in a whole batch not fitting in a machine's memory, and the whole
  /// operation will fail.
  /// The default value is 64.
  final int? batchSize;

  ManualBatchTuningParameters({this.batchSize}) : super(fullyQualifiedName);

  factory ManualBatchTuningParameters.fromJson(Map<String, dynamic> json) {
    return ManualBatchTuningParameters(batchSize: json['batchSize']);
  }

  @override
  Object toJson() {
    return {if (batchSize != null) 'batchSize': batchSize};
  }

  @override
  String toString() {
    final contents = [if (batchSize != null) 'batchSize=$batchSize'].join(',');
    return 'ManualBatchTuningParameters($contents)';
  }
}

/// The request message for
/// `MatchService.FindNeighbors`.
final class FindNeighborsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsRequest';

  /// Required. The name of the index endpoint.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// The ID of the DeployedIndex that will serve the request. This request is
  /// sent to a specific IndexEndpoint, as per the IndexEndpoint.network. That
  /// IndexEndpoint also has IndexEndpoint.deployed_indexes, and each such index
  /// has a DeployedIndex.id field.
  /// The value of the field below must equal one of the DeployedIndex.id
  /// fields of the IndexEndpoint that is being called for this request.
  final String? deployedIndexId;

  /// The list of queries.
  final List<FindNeighborsRequest_Query>? queries;

  /// If set to true, the full datapoints (including all vector values and
  /// restricts) of the nearest neighbors are returned.
  /// Note that returning full datapoint will significantly increase the
  /// latency and cost of the query.
  final bool? returnFullDatapoint;

  FindNeighborsRequest({
    required this.indexEndpoint,
    this.deployedIndexId,
    this.queries,
    this.returnFullDatapoint,
  }) : super(fullyQualifiedName);

  factory FindNeighborsRequest.fromJson(Map<String, dynamic> json) {
    return FindNeighborsRequest(
      indexEndpoint: json['indexEndpoint'],
      deployedIndexId: json['deployedIndexId'],
      queries: decodeListMessage(
        json['queries'],
        FindNeighborsRequest_Query.fromJson,
      ),
      returnFullDatapoint: json['returnFullDatapoint'],
    );
  }

  @override
  Object toJson() {
    return {
      'indexEndpoint': indexEndpoint,
      if (deployedIndexId != null) 'deployedIndexId': deployedIndexId,
      if (queries != null) 'queries': encodeList(queries),
      if (returnFullDatapoint != null)
        'returnFullDatapoint': returnFullDatapoint,
    };
  }

  @override
  String toString() {
    final contents = [
      'indexEndpoint=$indexEndpoint',
      if (deployedIndexId != null) 'deployedIndexId=$deployedIndexId',
      if (returnFullDatapoint != null)
        'returnFullDatapoint=$returnFullDatapoint',
    ].join(',');
    return 'FindNeighborsRequest($contents)';
  }
}

/// A query to find a number of the nearest neighbors (most similar vectors)
/// of a vector.
final class FindNeighborsRequest_Query extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsRequest.Query';

  /// Optional. Represents RRF algorithm that combines search results.
  final FindNeighborsRequest_Query_Rrf? rrf;

  /// Required. The datapoint/vector whose nearest neighbors should be searched
  /// for.
  final IndexDatapoint? datapoint;

  /// The number of nearest neighbors to be retrieved from database for each
  /// query. If not set, will use the default from the service configuration
  /// (https://cloud.google.com/vertex-ai/docs/matching-engine/configuring-indexes#nearest-neighbor-search-config).
  final int? neighborCount;

  /// Crowding is a constraint on a neighbor list produced by nearest neighbor
  /// search requiring that no more than some value k' of the k neighbors
  /// returned have the same value of crowding_attribute.
  /// It's used for improving result diversity.
  /// This field is the maximum number of matches with the same crowding tag.
  final int? perCrowdingAttributeNeighborCount;

  /// The number of neighbors to find via approximate search before
  /// exact reordering is performed. If not set, the default value from scam
  /// config is used; if set, this value must be > 0.
  final int? approximateNeighborCount;

  /// The fraction of the number of leaves to search, set at query time allows
  /// user to tune search performance. This value increase result in both
  /// search accuracy and latency increase. The value should be between 0.0
  /// and 1.0. If not set or set to 0.0, query uses the default value specified
  /// in
  /// NearestNeighborSearchConfig.TreeAHConfig.fraction_leaf_nodes_to_search.
  final double? fractionLeafNodesToSearchOverride;

  FindNeighborsRequest_Query({
    this.rrf,
    this.datapoint,
    this.neighborCount,
    this.perCrowdingAttributeNeighborCount,
    this.approximateNeighborCount,
    this.fractionLeafNodesToSearchOverride,
  }) : super(fullyQualifiedName);

  factory FindNeighborsRequest_Query.fromJson(Map<String, dynamic> json) {
    return FindNeighborsRequest_Query(
      rrf: decode(json['rrf'], FindNeighborsRequest_Query_Rrf.fromJson),
      datapoint: decode(json['datapoint'], IndexDatapoint.fromJson),
      neighborCount: json['neighborCount'],
      perCrowdingAttributeNeighborCount:
          json['perCrowdingAttributeNeighborCount'],
      approximateNeighborCount: json['approximateNeighborCount'],
      fractionLeafNodesToSearchOverride: decodeDouble(
        json['fractionLeafNodesToSearchOverride'],
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (rrf != null) 'rrf': rrf!.toJson(),
      if (datapoint != null) 'datapoint': datapoint!.toJson(),
      if (neighborCount != null) 'neighborCount': neighborCount,
      if (perCrowdingAttributeNeighborCount != null)
        'perCrowdingAttributeNeighborCount': perCrowdingAttributeNeighborCount,
      if (approximateNeighborCount != null)
        'approximateNeighborCount': approximateNeighborCount,
      if (fractionLeafNodesToSearchOverride != null)
        'fractionLeafNodesToSearchOverride': encodeDouble(
          fractionLeafNodesToSearchOverride,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (neighborCount != null) 'neighborCount=$neighborCount',
      if (perCrowdingAttributeNeighborCount != null)
        'perCrowdingAttributeNeighborCount=$perCrowdingAttributeNeighborCount',
      if (approximateNeighborCount != null)
        'approximateNeighborCount=$approximateNeighborCount',
      if (fractionLeafNodesToSearchOverride != null)
        'fractionLeafNodesToSearchOverride=$fractionLeafNodesToSearchOverride',
    ].join(',');
    return 'Query($contents)';
  }
}

/// Parameters for RRF algorithm that combines search results.
final class FindNeighborsRequest_Query_Rrf extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsRequest.Query.RRF';

  /// Required. Users can provide an alpha value to give more weight to dense
  /// vs sparse results. For example, if the alpha is 0, we only return
  /// sparse and if the alpha is 1, we only return dense.
  final double? alpha;

  FindNeighborsRequest_Query_Rrf({this.alpha}) : super(fullyQualifiedName);

  factory FindNeighborsRequest_Query_Rrf.fromJson(Map<String, dynamic> json) {
    return FindNeighborsRequest_Query_Rrf(alpha: decodeDouble(json['alpha']));
  }

  @override
  Object toJson() {
    return {if (alpha != null) 'alpha': encodeDouble(alpha)};
  }

  @override
  String toString() {
    final contents = [if (alpha != null) 'alpha=$alpha'].join(',');
    return 'RRF($contents)';
  }
}

/// The response message for
/// `MatchService.FindNeighbors`.
final class FindNeighborsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsResponse';

  /// The nearest neighbors of the query datapoints.
  final List<FindNeighborsResponse_NearestNeighbors>? nearestNeighbors;

  FindNeighborsResponse({this.nearestNeighbors}) : super(fullyQualifiedName);

  factory FindNeighborsResponse.fromJson(Map<String, dynamic> json) {
    return FindNeighborsResponse(
      nearestNeighbors: decodeListMessage(
        json['nearestNeighbors'],
        FindNeighborsResponse_NearestNeighbors.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (nearestNeighbors != null)
        'nearestNeighbors': encodeList(nearestNeighbors),
    };
  }

  @override
  String toString() => 'FindNeighborsResponse()';
}

/// A neighbor of the query vector.
final class FindNeighborsResponse_Neighbor extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsResponse.Neighbor';

  /// The datapoint of the neighbor.
  /// Note that full datapoints are returned only when "return_full_datapoint"
  /// is set to true. Otherwise, only the "datapoint_id" and "crowding_tag"
  /// fields are populated.
  final IndexDatapoint? datapoint;

  /// The distance between the neighbor and the dense embedding query.
  final double? distance;

  /// The distance between the neighbor and the query sparse_embedding.
  final double? sparseDistance;

  FindNeighborsResponse_Neighbor({
    this.datapoint,
    this.distance,
    this.sparseDistance,
  }) : super(fullyQualifiedName);

  factory FindNeighborsResponse_Neighbor.fromJson(Map<String, dynamic> json) {
    return FindNeighborsResponse_Neighbor(
      datapoint: decode(json['datapoint'], IndexDatapoint.fromJson),
      distance: decodeDouble(json['distance']),
      sparseDistance: decodeDouble(json['sparseDistance']),
    );
  }

  @override
  Object toJson() {
    return {
      if (datapoint != null) 'datapoint': datapoint!.toJson(),
      if (distance != null) 'distance': encodeDouble(distance),
      if (sparseDistance != null)
        'sparseDistance': encodeDouble(sparseDistance),
    };
  }

  @override
  String toString() {
    final contents = [
      if (distance != null) 'distance=$distance',
      if (sparseDistance != null) 'sparseDistance=$sparseDistance',
    ].join(',');
    return 'Neighbor($contents)';
  }
}

/// Nearest neighbors for one query.
final class FindNeighborsResponse_NearestNeighbors
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FindNeighborsResponse.NearestNeighbors';

  /// The ID of the query datapoint.
  final String? id;

  /// All its neighbors.
  final List<FindNeighborsResponse_Neighbor>? neighbors;

  FindNeighborsResponse_NearestNeighbors({this.id, this.neighbors})
    : super(fullyQualifiedName);

  factory FindNeighborsResponse_NearestNeighbors.fromJson(
    Map<String, dynamic> json,
  ) {
    return FindNeighborsResponse_NearestNeighbors(
      id: json['id'],
      neighbors: decodeListMessage(
        json['neighbors'],
        FindNeighborsResponse_Neighbor.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (neighbors != null) 'neighbors': encodeList(neighbors),
    };
  }

  @override
  String toString() {
    final contents = [if (id != null) 'id=$id'].join(',');
    return 'NearestNeighbors($contents)';
  }
}

/// The request message for
/// `MatchService.ReadIndexDatapoints`.
final class ReadIndexDatapointsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadIndexDatapointsRequest';

  /// Required. The name of the index endpoint.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String indexEndpoint;

  /// The ID of the DeployedIndex that will serve the request.
  final String? deployedIndexId;

  /// IDs of the datapoints to be searched for.
  final List<String>? ids;

  ReadIndexDatapointsRequest({
    required this.indexEndpoint,
    this.deployedIndexId,
    this.ids,
  }) : super(fullyQualifiedName);

  factory ReadIndexDatapointsRequest.fromJson(Map<String, dynamic> json) {
    return ReadIndexDatapointsRequest(
      indexEndpoint: json['indexEndpoint'],
      deployedIndexId: json['deployedIndexId'],
      ids: decodeList(json['ids']),
    );
  }

  @override
  Object toJson() {
    return {
      'indexEndpoint': indexEndpoint,
      if (deployedIndexId != null) 'deployedIndexId': deployedIndexId,
      if (ids != null) 'ids': ids,
    };
  }

  @override
  String toString() {
    final contents = [
      'indexEndpoint=$indexEndpoint',
      if (deployedIndexId != null) 'deployedIndexId=$deployedIndexId',
    ].join(',');
    return 'ReadIndexDatapointsRequest($contents)';
  }
}

/// The response message for
/// `MatchService.ReadIndexDatapoints`.
final class ReadIndexDatapointsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadIndexDatapointsResponse';

  /// The result list of datapoints.
  final List<IndexDatapoint>? datapoints;

  ReadIndexDatapointsResponse({this.datapoints}) : super(fullyQualifiedName);

  factory ReadIndexDatapointsResponse.fromJson(Map<String, dynamic> json) {
    return ReadIndexDatapointsResponse(
      datapoints: decodeListMessage(
        json['datapoints'],
        IndexDatapoint.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (datapoints != null) 'datapoints': encodeList(datapoints)};
  }

  @override
  String toString() => 'ReadIndexDatapointsResponse()';
}

/// A memory.
final class Memory extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Memory';

  /// Optional. Timestamp of when this resource is considered expired.
  /// This is *always* provided on output, regardless of what `expiration` was
  /// sent on input.
  final protobuf.Timestamp? expireTime;

  /// Optional. Input only. The TTL for this resource. The expiration time is
  /// computed: now + TTL.
  final protobuf.Duration? ttl;

  /// Identifier. The resource name of the Memory.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  final String? name;

  /// Optional. Display name of the Memory.
  final String? displayName;

  /// Optional. Description of the Memory.
  final String? description;

  /// Output only. Timestamp when this Memory was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Memory was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Required. Semantic knowledge extracted from the source content.
  final String? fact;

  /// Required. Immutable. The scope of the Memory. Memories are isolated
  /// within their scope. The scope is defined when creating or generating
  /// memories. Scope values cannot contain the wildcard character '*'.
  final Map<String, String>? scope;

  Memory({
    this.expireTime,
    this.ttl,
    this.name,
    this.displayName,
    this.description,
    this.createTime,
    this.updateTime,
    this.fact,
    this.scope,
  }) : super(fullyQualifiedName);

  factory Memory.fromJson(Map<String, dynamic> json) {
    return Memory(
      expireTime: decodeCustom(json['expireTime'], protobuf.Timestamp.fromJson),
      ttl: decodeCustom(json['ttl'], protobuf.Duration.fromJson),
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      fact: json['fact'],
      scope: decodeMap(json['scope']),
    );
  }

  @override
  Object toJson() {
    return {
      if (expireTime != null) 'expireTime': expireTime!.toJson(),
      if (ttl != null) 'ttl': ttl!.toJson(),
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (fact != null) 'fact': fact,
      if (scope != null) 'scope': scope,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (fact != null) 'fact=$fact',
    ].join(',');
    return 'Memory($contents)';
  }
}

/// Request message for
/// `MemoryBankService.CreateMemory`.
final class CreateMemoryRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMemoryRequest';

  /// Required. The resource name of the ReasoningEngine to create the Memory
  /// under. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Required. The Memory to be created.
  final Memory memory;

  CreateMemoryRequest({required this.parent, required this.memory})
    : super(fullyQualifiedName);

  factory CreateMemoryRequest.fromJson(Map<String, dynamic> json) {
    return CreateMemoryRequest(
      parent: json['parent'],
      memory: decode(json['memory'], Memory.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'memory': memory.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateMemoryRequest($contents)';
  }
}

/// Details of
/// `MemoryBankService.CreateMemory`
/// operation.
final class CreateMemoryOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMemoryOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateMemoryOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateMemoryOperationMetadata.fromJson(Map<String, dynamic> json) {
    return CreateMemoryOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateMemoryOperationMetadata()';
}

/// Request message for
/// `MemoryBankService.GetMemory`.
final class GetMemoryRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetMemoryRequest';

  /// Required. The resource name of the Memory.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  final String name;

  GetMemoryRequest({required this.name}) : super(fullyQualifiedName);

  factory GetMemoryRequest.fromJson(Map<String, dynamic> json) {
    return GetMemoryRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetMemoryRequest($contents)';
  }
}

/// Request message for
/// `MemoryBankService.UpdateMemory`.
final class UpdateMemoryRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateMemoryRequest';

  /// Required. The Memory which replaces the resource on the server.
  final Memory memory;

  /// Optional. Mask specifying which fields to update.
  /// Supported fields:
  ///
  ///    * `display_name`
  ///    * `description`
  ///    * `fact`
  final protobuf.FieldMask? updateMask;

  UpdateMemoryRequest({required this.memory, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateMemoryRequest.fromJson(Map<String, dynamic> json) {
    return UpdateMemoryRequest(
      memory: decode(json['memory'], Memory.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'memory': memory.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateMemoryRequest()';
}

/// Details of
/// `MemoryBankService.UpdateMemory`
/// operation.
final class UpdateMemoryOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateMemoryOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UpdateMemoryOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateMemoryOperationMetadata.fromJson(Map<String, dynamic> json) {
    return UpdateMemoryOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateMemoryOperationMetadata()';
}

/// Request message for
/// `MemoryBankService.ListMemories`.
final class ListMemoriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMemoriesRequest';

  /// Required. The resource name of the ReasoningEngine to list the Memories
  /// under. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Optional. The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  ///
  /// Supported fields (equality match only):
  ///   * `scope` (as a JSON string)
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  final String? pageToken;

  ListMemoriesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListMemoriesRequest.fromJson(Map<String, dynamic> json) {
    return ListMemoriesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListMemoriesRequest($contents)';
  }
}

/// Response message for
/// `MemoryBankService.ListMemories`.
final class ListMemoriesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMemoriesResponse';

  /// List of Memories in the requested page.
  final List<Memory>? memories;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListMemoriesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListMemoriesResponse({this.memories, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListMemoriesResponse.fromJson(Map<String, dynamic> json) {
    return ListMemoriesResponse(
      memories: decodeListMessage(json['memories'], Memory.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (memories != null) 'memories': encodeList(memories),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListMemoriesResponse($contents)';
  }
}

/// Request message for
/// `MemoryBankService.DeleteMemory`.
final class DeleteMemoryRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteMemoryRequest';

  /// Required. The resource name of the Memory to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/memories/{memory}`
  final String name;

  DeleteMemoryRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteMemoryRequest.fromJson(Map<String, dynamic> json) {
    return DeleteMemoryRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteMemoryRequest($contents)';
  }
}

/// Details of
/// `MemoryBankService.DeleteMemory`
/// operation.
final class DeleteMemoryOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteMemoryOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  DeleteMemoryOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory DeleteMemoryOperationMetadata.fromJson(Map<String, dynamic> json) {
    return DeleteMemoryOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'DeleteMemoryOperationMetadata()';
}

/// Request message for
/// `MemoryBankService.GenerateMemories`.
final class GenerateMemoriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest';

  /// Defines a Vertex Session as the source content from which to generate
  /// memories.
  final GenerateMemoriesRequest_VertexSessionSource? vertexSessionSource;

  /// Defines a direct source of content as the source content from which to
  /// generate memories.
  final GenerateMemoriesRequest_DirectContentsSource? directContentsSource;

  /// Defines a direct source of memories that should be uploaded to Memory
  /// Bank. This is similar to `CreateMemory`, but it allows for consolidation
  /// between these new memories and existing memories for the same scope.
  final GenerateMemoriesRequest_DirectMemoriesSource? directMemoriesSource;

  /// Required. The resource name of the ReasoningEngine to generate memories
  /// for. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Optional. If true, generated memories will not be consolidated with
  /// existing memories; all generated memories will be added as new memories
  /// regardless of whether they are duplicates of or contradictory to existing
  /// memories. By default, memory consolidation is enabled.
  final bool? disableConsolidation;

  /// Optional. The scope of the memories that should be generated. Memories will
  /// be consolidated across memories with the same scope. Must be provided
  /// unless the scope is defined in the source content. If `scope` is provided,
  /// it will override the scope defined in the source content. Scope values
  /// cannot contain the wildcard character '*'.
  final Map<String, String>? scope;

  GenerateMemoriesRequest({
    this.vertexSessionSource,
    this.directContentsSource,
    this.directMemoriesSource,
    required this.parent,
    this.disableConsolidation,
    this.scope,
  }) : super(fullyQualifiedName);

  factory GenerateMemoriesRequest.fromJson(Map<String, dynamic> json) {
    return GenerateMemoriesRequest(
      vertexSessionSource: decode(
        json['vertexSessionSource'],
        GenerateMemoriesRequest_VertexSessionSource.fromJson,
      ),
      directContentsSource: decode(
        json['directContentsSource'],
        GenerateMemoriesRequest_DirectContentsSource.fromJson,
      ),
      directMemoriesSource: decode(
        json['directMemoriesSource'],
        GenerateMemoriesRequest_DirectMemoriesSource.fromJson,
      ),
      parent: json['parent'],
      disableConsolidation: json['disableConsolidation'],
      scope: decodeMap(json['scope']),
    );
  }

  @override
  Object toJson() {
    return {
      if (vertexSessionSource != null)
        'vertexSessionSource': vertexSessionSource!.toJson(),
      if (directContentsSource != null)
        'directContentsSource': directContentsSource!.toJson(),
      if (directMemoriesSource != null)
        'directMemoriesSource': directMemoriesSource!.toJson(),
      'parent': parent,
      if (disableConsolidation != null)
        'disableConsolidation': disableConsolidation,
      if (scope != null) 'scope': scope,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (disableConsolidation != null)
        'disableConsolidation=$disableConsolidation',
    ].join(',');
    return 'GenerateMemoriesRequest($contents)';
  }
}

/// Defines an Agent Engine Session from which to generate the memories. If
/// `scope` is not provided, the scope will be extracted from the Session
/// (i.e. {"user_id": sesison.user_id}).
final class GenerateMemoriesRequest_VertexSessionSource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.VertexSessionSource';

  /// Required. The resource name of the Session to generate memories for.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String? session;

  /// Optional. Time range to define which session events should be used to
  /// generate memories. Start time (inclusive) of the time range. If not set,
  /// the start time is unbounded.
  final protobuf.Timestamp? startTime;

  /// Optional. End time (exclusive) of the time range. If not set, the end
  /// time is unbounded.
  final protobuf.Timestamp? endTime;

  GenerateMemoriesRequest_VertexSessionSource({
    this.session,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_VertexSessionSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateMemoriesRequest_VertexSessionSource(
      session: json['session'],
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (session != null) 'session': session,
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (session != null) 'session=$session'].join(',');
    return 'VertexSessionSource($contents)';
  }
}

/// Defines a direct source of content from which to generate the memories.
final class GenerateMemoriesRequest_DirectContentsSource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.DirectContentsSource';

  /// Required. The source content (i.e. chat history) to generate memories
  /// from.
  final List<GenerateMemoriesRequest_DirectContentsSource_Event>? events;

  GenerateMemoriesRequest_DirectContentsSource({this.events})
    : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_DirectContentsSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateMemoriesRequest_DirectContentsSource(
      events: decodeListMessage(
        json['events'],
        GenerateMemoriesRequest_DirectContentsSource_Event.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (events != null) 'events': encodeList(events)};
  }

  @override
  String toString() => 'DirectContentsSource()';
}

/// A single piece of conversation from which to generate memories.
final class GenerateMemoriesRequest_DirectContentsSource_Event
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.DirectContentsSource.Event';

  /// Required. A single piece of content from which to generate memories.
  final Content? content;

  GenerateMemoriesRequest_DirectContentsSource_Event({this.content})
    : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_DirectContentsSource_Event.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateMemoriesRequest_DirectContentsSource_Event(
      content: decode(json['content'], Content.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (content != null) 'content': content!.toJson()};
  }

  @override
  String toString() => 'Event()';
}

/// Defines a direct source of memories that should be uploaded to Memory Bank
/// with consolidation.
final class GenerateMemoriesRequest_DirectMemoriesSource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.DirectMemoriesSource';

  /// Required. The direct memories to upload to Memory Bank. At most 5 direct
  /// memories are allowed per request.
  final List<GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory>?
  directMemories;

  GenerateMemoriesRequest_DirectMemoriesSource({this.directMemories})
    : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_DirectMemoriesSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateMemoriesRequest_DirectMemoriesSource(
      directMemories: decodeListMessage(
        json['directMemories'],
        GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (directMemories != null) 'directMemories': encodeList(directMemories),
    };
  }

  @override
  String toString() => 'DirectMemoriesSource()';
}

/// A direct memory to upload to Memory Bank.
final class GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesRequest.DirectMemoriesSource.DirectMemory';

  /// Required. The fact to consolidate with existing memories.
  final String? fact;

  GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory({this.fact})
    : super(fullyQualifiedName);

  factory GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateMemoriesRequest_DirectMemoriesSource_DirectMemory(
      fact: json['fact'],
    );
  }

  @override
  Object toJson() {
    return {if (fact != null) 'fact': fact};
  }

  @override
  String toString() {
    final contents = [if (fact != null) 'fact=$fact'].join(',');
    return 'DirectMemory($contents)';
  }
}

/// Response message for
/// `MemoryBankService.GenerateMemories`.
final class GenerateMemoriesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesResponse';

  /// The generated memories.
  final List<GenerateMemoriesResponse_GeneratedMemory>? generatedMemories;

  GenerateMemoriesResponse({this.generatedMemories})
    : super(fullyQualifiedName);

  factory GenerateMemoriesResponse.fromJson(Map<String, dynamic> json) {
    return GenerateMemoriesResponse(
      generatedMemories: decodeListMessage(
        json['generatedMemories'],
        GenerateMemoriesResponse_GeneratedMemory.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (generatedMemories != null)
        'generatedMemories': encodeList(generatedMemories),
    };
  }

  @override
  String toString() => 'GenerateMemoriesResponse()';
}

/// A memory generated by the operation.
final class GenerateMemoriesResponse_GeneratedMemory
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesResponse.GeneratedMemory';

  /// The generated Memory.
  final Memory? memory;

  /// The action that was performed on the Memory.
  final GenerateMemoriesResponse_GeneratedMemory_Action? action;

  GenerateMemoriesResponse_GeneratedMemory({this.memory, this.action})
    : super(fullyQualifiedName);

  factory GenerateMemoriesResponse_GeneratedMemory.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateMemoriesResponse_GeneratedMemory(
      memory: decode(json['memory'], Memory.fromJson),
      action: decodeEnum(
        json['action'],
        GenerateMemoriesResponse_GeneratedMemory_Action.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (memory != null) 'memory': memory!.toJson(),
      if (action != null) 'action': action!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (action != null) 'action=$action'].join(',');
    return 'GeneratedMemory($contents)';
  }
}

/// Actions that can be performed on a Memory.
final class GenerateMemoriesResponse_GeneratedMemory_Action
    extends protobuf.ProtoEnum {
  /// Action is unspecified.
  static const actionUnspecified =
      GenerateMemoriesResponse_GeneratedMemory_Action('ACTION_UNSPECIFIED');

  /// The memory was created.
  static const created = GenerateMemoriesResponse_GeneratedMemory_Action(
    'CREATED',
  );

  /// The memory was updated. The `fact` field may not be updated if the
  /// existing fact is still accurate.
  static const updated = GenerateMemoriesResponse_GeneratedMemory_Action(
    'UPDATED',
  );

  /// The memory was deleted.
  static const deleted = GenerateMemoriesResponse_GeneratedMemory_Action(
    'DELETED',
  );

  const GenerateMemoriesResponse_GeneratedMemory_Action(super.value);

  factory GenerateMemoriesResponse_GeneratedMemory_Action.fromJson(
    String json,
  ) => GenerateMemoriesResponse_GeneratedMemory_Action(json);

  @override
  String toString() => 'Action.$value';
}

/// Details of
/// `MemoryBankService.GenerateMemories`
/// operation.
final class GenerateMemoriesOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateMemoriesOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  GenerateMemoriesOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory GenerateMemoriesOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateMemoriesOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'GenerateMemoriesOperationMetadata()';
}

/// Request message for
/// `MemoryBankService.RetrieveMemories`.
final class RetrieveMemoriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesRequest';

  /// Parameters for semantic similarity search based retrieval.
  final RetrieveMemoriesRequest_SimilaritySearchParams? similaritySearchParams;

  /// Parameters for simple (non-similarity search) retrieval.
  final RetrieveMemoriesRequest_SimpleRetrievalParams? simpleRetrievalParams;

  /// Required. The resource name of the ReasoningEngine to retrieve memories
  /// from. Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Required. The scope of the memories to retrieve. A memory must have
  /// exactly the same scope (`Memory.scope`) as the scope provided here to be
  /// retrieved (same keys and values). Order does not matter, but it is
  /// case-sensitive.
  final Map<String, String>? scope;

  RetrieveMemoriesRequest({
    this.similaritySearchParams,
    this.simpleRetrievalParams,
    required this.parent,
    this.scope,
  }) : super(fullyQualifiedName);

  factory RetrieveMemoriesRequest.fromJson(Map<String, dynamic> json) {
    return RetrieveMemoriesRequest(
      similaritySearchParams: decode(
        json['similaritySearchParams'],
        RetrieveMemoriesRequest_SimilaritySearchParams.fromJson,
      ),
      simpleRetrievalParams: decode(
        json['simpleRetrievalParams'],
        RetrieveMemoriesRequest_SimpleRetrievalParams.fromJson,
      ),
      parent: json['parent'],
      scope: decodeMap(json['scope']),
    );
  }

  @override
  Object toJson() {
    return {
      if (similaritySearchParams != null)
        'similaritySearchParams': similaritySearchParams!.toJson(),
      if (simpleRetrievalParams != null)
        'simpleRetrievalParams': simpleRetrievalParams!.toJson(),
      'parent': parent,
      if (scope != null) 'scope': scope,
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'RetrieveMemoriesRequest($contents)';
  }
}

/// Parameters for semantic similarity search based retrieval.
final class RetrieveMemoriesRequest_SimilaritySearchParams
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesRequest.SimilaritySearchParams';

  /// Required. Query to use for similarity search retrieval. If provided, then
  /// the parent ReasoningEngine must have
  /// `ReasoningEngineContextSpec.MemoryBankConfig.SimilaritySearchConfig`
  /// set.
  final String? searchQuery;

  /// Optional. The maximum number of memories to return.
  /// The service may return fewer than this value. If unspecified, at most 3
  /// memories will be returned. The maximum value is 100; values above 100
  /// will be coerced to 100.
  final int? topK;

  RetrieveMemoriesRequest_SimilaritySearchParams({this.searchQuery, this.topK})
    : super(fullyQualifiedName);

  factory RetrieveMemoriesRequest_SimilaritySearchParams.fromJson(
    Map<String, dynamic> json,
  ) {
    return RetrieveMemoriesRequest_SimilaritySearchParams(
      searchQuery: json['searchQuery'],
      topK: json['topK'],
    );
  }

  @override
  Object toJson() {
    return {
      if (searchQuery != null) 'searchQuery': searchQuery,
      if (topK != null) 'topK': topK,
    };
  }

  @override
  String toString() {
    final contents = [
      if (searchQuery != null) 'searchQuery=$searchQuery',
      if (topK != null) 'topK=$topK',
    ].join(',');
    return 'SimilaritySearchParams($contents)';
  }
}

/// Parameters for simple (non-similarity search) retrieval.
final class RetrieveMemoriesRequest_SimpleRetrievalParams
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesRequest.SimpleRetrievalParams';

  /// Optional. The maximum number of memories to return.
  /// The service may return fewer than this value. If unspecified, at most 3
  /// memories will be returned. The maximum value is 100; values above 100
  /// will be coerced to 100.
  final int? pageSize;

  /// Optional. A page token, received from a previous `RetrieveMemories` call.
  /// Provide this to retrieve the subsequent page.
  final String? pageToken;

  RetrieveMemoriesRequest_SimpleRetrievalParams({this.pageSize, this.pageToken})
    : super(fullyQualifiedName);

  factory RetrieveMemoriesRequest_SimpleRetrievalParams.fromJson(
    Map<String, dynamic> json,
  ) {
    return RetrieveMemoriesRequest_SimpleRetrievalParams(
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'SimpleRetrievalParams($contents)';
  }
}

/// Response message for
/// `MemoryBankService.RetrieveMemories`.
final class RetrieveMemoriesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesResponse';

  /// The retrieved memories.
  final List<RetrieveMemoriesResponse_RetrievedMemory>? retrievedMemories;

  /// A token that can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  /// This token is not set if similarity search was used for retrieval.
  final String? nextPageToken;

  RetrieveMemoriesResponse({this.retrievedMemories, this.nextPageToken})
    : super(fullyQualifiedName);

  factory RetrieveMemoriesResponse.fromJson(Map<String, dynamic> json) {
    return RetrieveMemoriesResponse(
      retrievedMemories: decodeListMessage(
        json['retrievedMemories'],
        RetrieveMemoriesResponse_RetrievedMemory.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (retrievedMemories != null)
        'retrievedMemories': encodeList(retrievedMemories),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'RetrieveMemoriesResponse($contents)';
  }
}

/// A retrieved memory.
final class RetrieveMemoriesResponse_RetrievedMemory
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveMemoriesResponse.RetrievedMemory';

  /// The retrieved Memory.
  final Memory? memory;

  /// The distance between the query and the retrieved Memory. Smaller values
  /// indicate more similar memories. This is only set if similarity search was
  /// used for retrieval.
  final double? distance;

  RetrieveMemoriesResponse_RetrievedMemory({this.memory, this.distance})
    : super(fullyQualifiedName);

  factory RetrieveMemoriesResponse_RetrievedMemory.fromJson(
    Map<String, dynamic> json,
  ) {
    return RetrieveMemoriesResponse_RetrievedMemory(
      memory: decode(json['memory'], Memory.fromJson),
      distance: decodeDouble(json['distance']),
    );
  }

  @override
  Object toJson() {
    return {
      if (memory != null) 'memory': memory!.toJson(),
      if (distance != null) 'distance': encodeDouble(distance),
    };
  }

  @override
  String toString() {
    final contents = [if (distance != null) 'distance=$distance'].join(',');
    return 'RetrievedMemory($contents)';
  }
}

/// Instance of a general MetadataSchema.
final class MetadataSchema extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetadataSchema';

  /// Output only. The resource name of the MetadataSchema.
  final String? name;

  /// The version of the MetadataSchema. The version's format must match
  /// the following regular expression: `^[0-9]+[.][0-9]+[.][0-9]+$`, which would
  /// allow to order/compare different versions. Example: 1.0.0, 1.0.1, etc.
  final String? schemaVersion;

  /// Required. The raw YAML string representation of the MetadataSchema. The
  /// combination of [MetadataSchema.version] and the schema name given by
  /// `title` in [MetadataSchema.schema] must be unique within a MetadataStore.
  ///
  /// The schema is defined as an OpenAPI 3.0.2
  /// [MetadataSchema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#schemaObject)
  final String? schema;

  /// The type of the MetadataSchema. This is a property that identifies which
  /// metadata types will use the MetadataSchema.
  final MetadataSchema_MetadataSchemaType? schemaType;

  /// Output only. Timestamp when this MetadataSchema was created.
  final protobuf.Timestamp? createTime;

  /// Description of the Metadata Schema
  final String? description;

  MetadataSchema({
    this.name,
    this.schemaVersion,
    this.schema,
    this.schemaType,
    this.createTime,
    this.description,
  }) : super(fullyQualifiedName);

  factory MetadataSchema.fromJson(Map<String, dynamic> json) {
    return MetadataSchema(
      name: json['name'],
      schemaVersion: json['schemaVersion'],
      schema: json['schema'],
      schemaType: decodeEnum(
        json['schemaType'],
        MetadataSchema_MetadataSchemaType.fromJson,
      ),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (schemaVersion != null) 'schemaVersion': schemaVersion,
      if (schema != null) 'schema': schema,
      if (schemaType != null) 'schemaType': schemaType!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (schemaVersion != null) 'schemaVersion=$schemaVersion',
      if (schema != null) 'schema=$schema',
      if (schemaType != null) 'schemaType=$schemaType',
      if (description != null) 'description=$description',
    ].join(',');
    return 'MetadataSchema($contents)';
  }
}

/// Describes the type of the MetadataSchema.
final class MetadataSchema_MetadataSchemaType extends protobuf.ProtoEnum {
  /// Unspecified type for the MetadataSchema.
  static const metadataSchemaTypeUnspecified =
      MetadataSchema_MetadataSchemaType('METADATA_SCHEMA_TYPE_UNSPECIFIED');

  /// A type indicating that the MetadataSchema will be used by Artifacts.
  static const artifactType = MetadataSchema_MetadataSchemaType(
    'ARTIFACT_TYPE',
  );

  /// A typee indicating that the MetadataSchema will be used by Executions.
  static const executionType = MetadataSchema_MetadataSchemaType(
    'EXECUTION_TYPE',
  );

  /// A state indicating that the MetadataSchema will be used by Contexts.
  static const contextType = MetadataSchema_MetadataSchemaType('CONTEXT_TYPE');

  const MetadataSchema_MetadataSchemaType(super.value);

  factory MetadataSchema_MetadataSchemaType.fromJson(String json) =>
      MetadataSchema_MetadataSchemaType(json);

  @override
  String toString() => 'MetadataSchemaType.$value';
}

/// Request message for
/// `MetadataService.CreateMetadataStore`.
final class CreateMetadataStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMetadataStoreRequest';

  /// Required. The resource name of the Location where the MetadataStore should
  /// be created.
  /// Format: `projects/{project}/locations/{location}/`
  final String parent;

  /// Required. The MetadataStore to create.
  final MetadataStore metadataStore;

  /// The {metadatastore} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all MetadataStores in the parent Location.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting MetadataStore.)
  final String? metadataStoreId;

  CreateMetadataStoreRequest({
    required this.parent,
    required this.metadataStore,
    this.metadataStoreId,
  }) : super(fullyQualifiedName);

  factory CreateMetadataStoreRequest.fromJson(Map<String, dynamic> json) {
    return CreateMetadataStoreRequest(
      parent: json['parent'],
      metadataStore: decode(json['metadataStore'], MetadataStore.fromJson)!,
      metadataStoreId: json['metadataStoreId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'metadataStore': metadataStore.toJson(),
      if (metadataStoreId != null) 'metadataStoreId': metadataStoreId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (metadataStoreId != null) 'metadataStoreId=$metadataStoreId',
    ].join(',');
    return 'CreateMetadataStoreRequest($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.CreateMetadataStore`.
final class CreateMetadataStoreOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMetadataStoreOperationMetadata';

  /// Operation metadata for creating a MetadataStore.
  final GenericOperationMetadata? genericMetadata;

  CreateMetadataStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateMetadataStoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateMetadataStoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateMetadataStoreOperationMetadata()';
}

/// Request message for
/// `MetadataService.GetMetadataStore`.
final class GetMetadataStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetMetadataStoreRequest';

  /// Required. The resource name of the MetadataStore to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String name;

  GetMetadataStoreRequest({required this.name}) : super(fullyQualifiedName);

  factory GetMetadataStoreRequest.fromJson(Map<String, dynamic> json) {
    return GetMetadataStoreRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetMetadataStoreRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListMetadataStores`.
final class ListMetadataStoresRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMetadataStoresRequest';

  /// Required. The Location whose MetadataStores should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// The maximum number of Metadata Stores to return. The service may return
  /// fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListMetadataStores`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  final String? pageToken;

  ListMetadataStoresRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListMetadataStoresRequest.fromJson(Map<String, dynamic> json) {
    return ListMetadataStoresRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListMetadataStoresRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListMetadataStores`.
final class ListMetadataStoresResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMetadataStoresResponse';

  /// The MetadataStores found for the Location.
  final List<MetadataStore>? metadataStores;

  /// A token, which can be sent as
  /// `ListMetadataStoresRequest.page_token`
  /// to retrieve the next page. If this field is not populated, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListMetadataStoresResponse({this.metadataStores, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListMetadataStoresResponse.fromJson(Map<String, dynamic> json) {
    return ListMetadataStoresResponse(
      metadataStores: decodeListMessage(
        json['metadataStores'],
        MetadataStore.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (metadataStores != null) 'metadataStores': encodeList(metadataStores),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListMetadataStoresResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.DeleteMetadataStore`.
final class DeleteMetadataStoreRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteMetadataStoreRequest';

  /// Required. The resource name of the MetadataStore to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String name;

  /// Deprecated: Field is no longer supported.
  final bool? force;

  DeleteMetadataStoreRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteMetadataStoreRequest.fromJson(Map<String, dynamic> json) {
    return DeleteMetadataStoreRequest(name: json['name'], force: json['force']);
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteMetadataStoreRequest($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.DeleteMetadataStore`.
final class DeleteMetadataStoreOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteMetadataStoreOperationMetadata';

  /// Operation metadata for deleting a MetadataStore.
  final GenericOperationMetadata? genericMetadata;

  DeleteMetadataStoreOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory DeleteMetadataStoreOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteMetadataStoreOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'DeleteMetadataStoreOperationMetadata()';
}

/// Request message for
/// `MetadataService.CreateArtifact`.
final class CreateArtifactRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateArtifactRequest';

  /// Required. The resource name of the MetadataStore where the Artifact should
  /// be created.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. The Artifact to create.
  final Artifact artifact;

  /// The {artifact} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  /// If not provided, the Artifact's ID will be a UUID generated by the service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all Artifacts in the parent MetadataStore. (Otherwise
  /// the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the
  /// caller can't view the preexisting Artifact.)
  final String? artifactId;

  CreateArtifactRequest({
    required this.parent,
    required this.artifact,
    this.artifactId,
  }) : super(fullyQualifiedName);

  factory CreateArtifactRequest.fromJson(Map<String, dynamic> json) {
    return CreateArtifactRequest(
      parent: json['parent'],
      artifact: decode(json['artifact'], Artifact.fromJson)!,
      artifactId: json['artifactId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'artifact': artifact.toJson(),
      if (artifactId != null) 'artifactId': artifactId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (artifactId != null) 'artifactId=$artifactId',
    ].join(',');
    return 'CreateArtifactRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.GetArtifact`.
final class GetArtifactRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetArtifactRequest';

  /// Required. The resource name of the Artifact to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  final String name;

  GetArtifactRequest({required this.name}) : super(fullyQualifiedName);

  factory GetArtifactRequest.fromJson(Map<String, dynamic> json) {
    return GetArtifactRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetArtifactRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListArtifacts`.
final class ListArtifactsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListArtifactsRequest';

  /// Required. The MetadataStore whose Artifacts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// The maximum number of Artifacts to return. The service may return fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListArtifacts`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  final String? pageToken;

  /// Filter specifying the boolean condition for the Artifacts to satisfy in
  /// order to be part of the result set.
  /// The syntax to define filter query is based on https://google.aip.dev/160.
  /// The supported set of filters include the following:
  ///
  /// *   **Attribute filtering**:
  ///     For example: `display_name = "test"`.
  ///     Supported fields include: `name`, `display_name`, `uri`, `state`,
  ///     `schema_title`, `create_time`, and `update_time`.
  ///     Time fields, such as `create_time` and `update_time`, require values
  ///     specified in RFC-3339 format.
  ///     For example: `create_time = "2020-11-19T11:30:00-04:00"`
  /// *   **Metadata field**:
  ///     To filter on metadata fields use traversal operation as follows:
  ///     `metadata.<field_name>.<type_value>`.
  ///     For example: `metadata.field_1.number_value = 10.0`
  ///     In case the field name contains special characters (such as colon), one
  ///     can embed it inside double quote.
  ///     For example: `metadata."field:1".number_value = 10.0`
  /// *   **Context based filtering**:
  ///     To filter Artifacts based on the contexts to which they belong, use the
  ///     function operator with the full resource name
  ///     `in_context(<context-name>)`.
  ///     For example:
  ///     `in_context("projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context-id>")`
  ///
  /// Each of the above supported filter types can be combined together using
  /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
  /// is 5.
  ///
  /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
  final String? filter;

  /// How the list of messages is ordered. Specify the values to order by and an
  /// ordering operation. The default sorting order is ascending. To specify
  /// descending order for a field, users append a " desc" suffix; for example:
  /// "foo desc, bar".
  /// Subfields are specified with a `.` character, such as foo.bar.
  /// see https://google.aip.dev/132#ordering for more details.
  final String? orderBy;

  ListArtifactsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListArtifactsRequest.fromJson(Map<String, dynamic> json) {
    return ListArtifactsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListArtifactsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListArtifacts`.
final class ListArtifactsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListArtifactsResponse';

  /// The Artifacts retrieved from the MetadataStore.
  final List<Artifact>? artifacts;

  /// A token, which can be sent as
  /// `ListArtifactsRequest.page_token`
  /// to retrieve the next page.
  /// If this field is not populated, there are no subsequent pages.
  final String? nextPageToken;

  ListArtifactsResponse({this.artifacts, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListArtifactsResponse.fromJson(Map<String, dynamic> json) {
    return ListArtifactsResponse(
      artifacts: decodeListMessage(json['artifacts'], Artifact.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (artifacts != null) 'artifacts': encodeList(artifacts),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListArtifactsResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.UpdateArtifact`.
final class UpdateArtifactRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateArtifactRequest';

  /// Required. The Artifact containing updates.
  /// The Artifact's
  /// `Artifact.name` field is
  /// used to identify the Artifact to be updated. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  final Artifact artifact;

  /// Optional. A FieldMask indicating which fields should be updated.
  final protobuf.FieldMask? updateMask;

  /// If set to true, and the
  /// `Artifact` is not found, a new
  /// `Artifact` is created.
  final bool? allowMissing;

  UpdateArtifactRequest({
    required this.artifact,
    this.updateMask,
    this.allowMissing,
  }) : super(fullyQualifiedName);

  factory UpdateArtifactRequest.fromJson(Map<String, dynamic> json) {
    return UpdateArtifactRequest(
      artifact: decode(json['artifact'], Artifact.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
      allowMissing: json['allowMissing'],
    );
  }

  @override
  Object toJson() {
    return {
      'artifact': artifact.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
      if (allowMissing != null) 'allowMissing': allowMissing,
    };
  }

  @override
  String toString() {
    final contents = [
      if (allowMissing != null) 'allowMissing=$allowMissing',
    ].join(',');
    return 'UpdateArtifactRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.DeleteArtifact`.
final class DeleteArtifactRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteArtifactRequest';

  /// Required. The resource name of the Artifact to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  final String name;

  /// Optional. The etag of the Artifact to delete.
  /// If this is provided, it must match the server's etag. Otherwise, the
  /// request will fail with a FAILED_PRECONDITION.
  final String? etag;

  DeleteArtifactRequest({required this.name, this.etag})
    : super(fullyQualifiedName);

  factory DeleteArtifactRequest.fromJson(Map<String, dynamic> json) {
    return DeleteArtifactRequest(name: json['name'], etag: json['etag']);
  }

  @override
  Object toJson() {
    return {'name': name, if (etag != null) 'etag': etag};
  }

  @override
  String toString() {
    final contents = ['name=$name', if (etag != null) 'etag=$etag'].join(',');
    return 'DeleteArtifactRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.PurgeArtifacts`.
final class PurgeArtifactsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeArtifactsRequest';

  /// Required. The metadata store to purge Artifacts from.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. A required filter matching the Artifacts to be purged.
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  final String? filter;

  /// Optional. Flag to indicate to actually perform the purge.
  /// If `force` is set to false, the method will return a sample of
  /// Artifact names that would be deleted.
  final bool? force;

  PurgeArtifactsRequest({required this.parent, this.filter, this.force})
    : super(fullyQualifiedName);

  factory PurgeArtifactsRequest.fromJson(Map<String, dynamic> json) {
    return PurgeArtifactsRequest(
      parent: json['parent'],
      filter: json['filter'],
      force: json['force'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (force != null) 'force': force,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (force != null) 'force=$force',
    ].join(',');
    return 'PurgeArtifactsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.PurgeArtifacts`.
final class PurgeArtifactsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeArtifactsResponse';

  /// The number of Artifacts that this request deleted (or, if `force` is false,
  /// the number of Artifacts that will be deleted). This can be an estimate.
  final int? purgeCount;

  /// A sample of the Artifact names that will be deleted.
  /// Only populated if `force` is set to false. The maximum number of samples is
  /// 100 (it is possible to return fewer).
  final List<String>? purgeSample;

  PurgeArtifactsResponse({this.purgeCount, this.purgeSample})
    : super(fullyQualifiedName);

  factory PurgeArtifactsResponse.fromJson(Map<String, dynamic> json) {
    return PurgeArtifactsResponse(
      purgeCount: decodeInt64(json['purgeCount']),
      purgeSample: decodeList(json['purgeSample']),
    );
  }

  @override
  Object toJson() {
    return {
      if (purgeCount != null) 'purgeCount': encodeInt64(purgeCount),
      if (purgeSample != null) 'purgeSample': purgeSample,
    };
  }

  @override
  String toString() {
    final contents = [
      if (purgeCount != null) 'purgeCount=$purgeCount',
    ].join(',');
    return 'PurgeArtifactsResponse($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.PurgeArtifacts`.
final class PurgeArtifactsMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeArtifactsMetadata';

  /// Operation metadata for purging Artifacts.
  final GenericOperationMetadata? genericMetadata;

  PurgeArtifactsMetadata({this.genericMetadata}) : super(fullyQualifiedName);

  factory PurgeArtifactsMetadata.fromJson(Map<String, dynamic> json) {
    return PurgeArtifactsMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'PurgeArtifactsMetadata()';
}

/// Request message for
/// `MetadataService.CreateContext`.
final class CreateContextRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateContextRequest';

  /// Required. The resource name of the MetadataStore where the Context should
  /// be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. The Context to create.
  final Context context;

  /// The {context} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`.
  /// If not provided, the Context's ID will be a UUID generated by the service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all Contexts in the parent MetadataStore. (Otherwise
  /// the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED if the
  /// caller can't view the preexisting Context.)
  final String? contextId;

  CreateContextRequest({
    required this.parent,
    required this.context,
    this.contextId,
  }) : super(fullyQualifiedName);

  factory CreateContextRequest.fromJson(Map<String, dynamic> json) {
    return CreateContextRequest(
      parent: json['parent'],
      context: decode(json['context'], Context.fromJson)!,
      contextId: json['contextId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'context': context.toJson(),
      if (contextId != null) 'contextId': contextId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (contextId != null) 'contextId=$contextId',
    ].join(',');
    return 'CreateContextRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.GetContext`.
final class GetContextRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetContextRequest';

  /// Required. The resource name of the Context to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String name;

  GetContextRequest({required this.name}) : super(fullyQualifiedName);

  factory GetContextRequest.fromJson(Map<String, dynamic> json) {
    return GetContextRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetContextRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListContexts`
final class ListContextsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListContextsRequest';

  /// Required. The MetadataStore whose Contexts should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// The maximum number of Contexts to return. The service may return fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListContexts`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  final String? pageToken;

  /// Filter specifying the boolean condition for the Contexts to satisfy in
  /// order to be part of the result set.
  /// The syntax to define filter query is based on https://google.aip.dev/160.
  /// Following are the supported set of filters:
  ///
  /// *  **Attribute filtering**:
  ///    For example: `display_name = "test"`.
  ///    Supported fields include: `name`, `display_name`, `schema_title`,
  ///    `create_time`, and `update_time`.
  ///    Time fields, such as `create_time` and `update_time`, require values
  ///    specified in RFC-3339 format.
  ///    For example: `create_time = "2020-11-19T11:30:00-04:00"`.
  /// *  **Metadata field**:
  ///    To filter on metadata fields use traversal operation as follows:
  ///    `metadata.<field_name>.<type_value>`.
  ///    For example: `metadata.field_1.number_value = 10.0`.
  ///    In case the field name contains special characters (such as colon), one
  ///    can embed it inside double quote.
  ///    For example: `metadata."field:1".number_value = 10.0`
  /// *  **Parent Child filtering**:
  ///    To filter Contexts based on parent-child relationship use the HAS
  ///    operator as follows:
  ///
  ///    ```
  ///    parent_contexts:
  ///    "projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context_id>"
  ///    child_contexts:
  ///    "projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context_id>"
  ///    ```
  ///
  /// Each of the above supported filters can be combined together using
  /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
  /// is 5.
  ///
  /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
  final String? filter;

  /// How the list of messages is ordered. Specify the values to order by and an
  /// ordering operation. The default sorting order is ascending. To specify
  /// descending order for a field, users append a " desc" suffix; for example:
  /// "foo desc, bar".
  /// Subfields are specified with a `.` character, such as foo.bar.
  /// see https://google.aip.dev/132#ordering for more details.
  final String? orderBy;

  ListContextsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListContextsRequest.fromJson(Map<String, dynamic> json) {
    return ListContextsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListContextsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListContexts`.
final class ListContextsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListContextsResponse';

  /// The Contexts retrieved from the MetadataStore.
  final List<Context>? contexts;

  /// A token, which can be sent as
  /// `ListContextsRequest.page_token`
  /// to retrieve the next page.
  /// If this field is not populated, there are no subsequent pages.
  final String? nextPageToken;

  ListContextsResponse({this.contexts, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListContextsResponse.fromJson(Map<String, dynamic> json) {
    return ListContextsResponse(
      contexts: decodeListMessage(json['contexts'], Context.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (contexts != null) 'contexts': encodeList(contexts),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListContextsResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.UpdateContext`.
final class UpdateContextRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateContextRequest';

  /// Required. The Context containing updates.
  /// The Context's `Context.name`
  /// field is used to identify the Context to be updated. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final Context context;

  /// Optional. A FieldMask indicating which fields should be updated.
  final protobuf.FieldMask? updateMask;

  /// If set to true, and the `Context`
  /// is not found, a new `Context` is
  /// created.
  final bool? allowMissing;

  UpdateContextRequest({
    required this.context,
    this.updateMask,
    this.allowMissing,
  }) : super(fullyQualifiedName);

  factory UpdateContextRequest.fromJson(Map<String, dynamic> json) {
    return UpdateContextRequest(
      context: decode(json['context'], Context.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
      allowMissing: json['allowMissing'],
    );
  }

  @override
  Object toJson() {
    return {
      'context': context.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
      if (allowMissing != null) 'allowMissing': allowMissing,
    };
  }

  @override
  String toString() {
    final contents = [
      if (allowMissing != null) 'allowMissing=$allowMissing',
    ].join(',');
    return 'UpdateContextRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.DeleteContext`.
final class DeleteContextRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteContextRequest';

  /// Required. The resource name of the Context to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String name;

  /// The force deletion semantics is still undefined.
  /// Users should not use this field.
  final bool? force;

  /// Optional. The etag of the Context to delete.
  /// If this is provided, it must match the server's etag. Otherwise, the
  /// request will fail with a FAILED_PRECONDITION.
  final String? etag;

  DeleteContextRequest({required this.name, this.force, this.etag})
    : super(fullyQualifiedName);

  factory DeleteContextRequest.fromJson(Map<String, dynamic> json) {
    return DeleteContextRequest(
      name: json['name'],
      force: json['force'],
      etag: json['etag'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (force != null) 'force': force,
      if (etag != null) 'etag': etag,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'DeleteContextRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.PurgeContexts`.
final class PurgeContextsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeContextsRequest';

  /// Required. The metadata store to purge Contexts from.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. A required filter matching the Contexts to be purged.
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  final String? filter;

  /// Optional. Flag to indicate to actually perform the purge.
  /// If `force` is set to false, the method will return a sample of
  /// Context names that would be deleted.
  final bool? force;

  PurgeContextsRequest({required this.parent, this.filter, this.force})
    : super(fullyQualifiedName);

  factory PurgeContextsRequest.fromJson(Map<String, dynamic> json) {
    return PurgeContextsRequest(
      parent: json['parent'],
      filter: json['filter'],
      force: json['force'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (force != null) 'force': force,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (force != null) 'force=$force',
    ].join(',');
    return 'PurgeContextsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.PurgeContexts`.
final class PurgeContextsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeContextsResponse';

  /// The number of Contexts that this request deleted (or, if `force` is false,
  /// the number of Contexts that will be deleted). This can be an estimate.
  final int? purgeCount;

  /// A sample of the Context names that will be deleted.
  /// Only populated if `force` is set to false. The maximum number of samples is
  /// 100 (it is possible to return fewer).
  final List<String>? purgeSample;

  PurgeContextsResponse({this.purgeCount, this.purgeSample})
    : super(fullyQualifiedName);

  factory PurgeContextsResponse.fromJson(Map<String, dynamic> json) {
    return PurgeContextsResponse(
      purgeCount: decodeInt64(json['purgeCount']),
      purgeSample: decodeList(json['purgeSample']),
    );
  }

  @override
  Object toJson() {
    return {
      if (purgeCount != null) 'purgeCount': encodeInt64(purgeCount),
      if (purgeSample != null) 'purgeSample': purgeSample,
    };
  }

  @override
  String toString() {
    final contents = [
      if (purgeCount != null) 'purgeCount=$purgeCount',
    ].join(',');
    return 'PurgeContextsResponse($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.PurgeContexts`.
final class PurgeContextsMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeContextsMetadata';

  /// Operation metadata for purging Contexts.
  final GenericOperationMetadata? genericMetadata;

  PurgeContextsMetadata({this.genericMetadata}) : super(fullyQualifiedName);

  factory PurgeContextsMetadata.fromJson(Map<String, dynamic> json) {
    return PurgeContextsMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'PurgeContextsMetadata()';
}

/// Request message for
/// `MetadataService.AddContextArtifactsAndExecutions`.
final class AddContextArtifactsAndExecutionsRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddContextArtifactsAndExecutionsRequest';

  /// Required. The resource name of the Context that the Artifacts and
  /// Executions belong to. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String context;

  /// The resource names of the Artifacts to attribute to the Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  final List<String>? artifacts;

  /// The resource names of the Executions to associate with the
  /// Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final List<String>? executions;

  AddContextArtifactsAndExecutionsRequest({
    required this.context,
    this.artifacts,
    this.executions,
  }) : super(fullyQualifiedName);

  factory AddContextArtifactsAndExecutionsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return AddContextArtifactsAndExecutionsRequest(
      context: json['context'],
      artifacts: decodeList(json['artifacts']),
      executions: decodeList(json['executions']),
    );
  }

  @override
  Object toJson() {
    return {
      'context': context,
      if (artifacts != null) 'artifacts': artifacts,
      if (executions != null) 'executions': executions,
    };
  }

  @override
  String toString() {
    final contents = ['context=$context'].join(',');
    return 'AddContextArtifactsAndExecutionsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.AddContextArtifactsAndExecutions`.
final class AddContextArtifactsAndExecutionsResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddContextArtifactsAndExecutionsResponse';

  AddContextArtifactsAndExecutionsResponse() : super(fullyQualifiedName);

  factory AddContextArtifactsAndExecutionsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return AddContextArtifactsAndExecutionsResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'AddContextArtifactsAndExecutionsResponse()';
}

/// Request message for
/// `MetadataService.AddContextChildren`.
final class AddContextChildrenRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddContextChildrenRequest';

  /// Required. The resource name of the parent Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String context;

  /// The resource names of the child Contexts.
  final List<String>? childContexts;

  AddContextChildrenRequest({required this.context, this.childContexts})
    : super(fullyQualifiedName);

  factory AddContextChildrenRequest.fromJson(Map<String, dynamic> json) {
    return AddContextChildrenRequest(
      context: json['context'],
      childContexts: decodeList(json['childContexts']),
    );
  }

  @override
  Object toJson() {
    return {
      'context': context,
      if (childContexts != null) 'childContexts': childContexts,
    };
  }

  @override
  String toString() {
    final contents = ['context=$context'].join(',');
    return 'AddContextChildrenRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.AddContextChildren`.
final class AddContextChildrenResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddContextChildrenResponse';

  AddContextChildrenResponse() : super(fullyQualifiedName);

  factory AddContextChildrenResponse.fromJson(Map<String, dynamic> json) {
    return AddContextChildrenResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'AddContextChildrenResponse()';
}

/// Request message for
/// `MetadataService.DeleteContextChildrenRequest`.
final class RemoveContextChildrenRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveContextChildrenRequest';

  /// Required. The resource name of the parent Context.
  ///
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  final String context;

  /// The resource names of the child Contexts.
  final List<String>? childContexts;

  RemoveContextChildrenRequest({required this.context, this.childContexts})
    : super(fullyQualifiedName);

  factory RemoveContextChildrenRequest.fromJson(Map<String, dynamic> json) {
    return RemoveContextChildrenRequest(
      context: json['context'],
      childContexts: decodeList(json['childContexts']),
    );
  }

  @override
  Object toJson() {
    return {
      'context': context,
      if (childContexts != null) 'childContexts': childContexts,
    };
  }

  @override
  String toString() {
    final contents = ['context=$context'].join(',');
    return 'RemoveContextChildrenRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.RemoveContextChildren`.
final class RemoveContextChildrenResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RemoveContextChildrenResponse';

  RemoveContextChildrenResponse() : super(fullyQualifiedName);

  factory RemoveContextChildrenResponse.fromJson(Map<String, dynamic> json) {
    return RemoveContextChildrenResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'RemoveContextChildrenResponse()';
}

/// Request message for
/// `MetadataService.QueryContextLineageSubgraph`.
final class QueryContextLineageSubgraphRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryContextLineageSubgraphRequest';

  /// Required. The resource name of the Context whose Artifacts and Executions
  /// should be retrieved as a LineageSubgraph.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/contexts/{context}`
  ///
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  final String context;

  QueryContextLineageSubgraphRequest({required this.context})
    : super(fullyQualifiedName);

  factory QueryContextLineageSubgraphRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return QueryContextLineageSubgraphRequest(context: json['context']);
  }

  @override
  Object toJson() {
    return {'context': context};
  }

  @override
  String toString() {
    final contents = ['context=$context'].join(',');
    return 'QueryContextLineageSubgraphRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.CreateExecution`.
final class CreateExecutionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateExecutionRequest';

  /// Required. The resource name of the MetadataStore where the Execution should
  /// be created.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. The Execution to create.
  final Execution execution;

  /// The {execution} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  /// If not provided, the Execution's ID will be a UUID generated by the
  /// service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all Executions in the parent MetadataStore.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting Execution.)
  final String? executionId;

  CreateExecutionRequest({
    required this.parent,
    required this.execution,
    this.executionId,
  }) : super(fullyQualifiedName);

  factory CreateExecutionRequest.fromJson(Map<String, dynamic> json) {
    return CreateExecutionRequest(
      parent: json['parent'],
      execution: decode(json['execution'], Execution.fromJson)!,
      executionId: json['executionId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'execution': execution.toJson(),
      if (executionId != null) 'executionId': executionId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (executionId != null) 'executionId=$executionId',
    ].join(',');
    return 'CreateExecutionRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.GetExecution`.
final class GetExecutionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetExecutionRequest';

  /// Required. The resource name of the Execution to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final String name;

  GetExecutionRequest({required this.name}) : super(fullyQualifiedName);

  factory GetExecutionRequest.fromJson(Map<String, dynamic> json) {
    return GetExecutionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetExecutionRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListExecutions`.
final class ListExecutionsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExecutionsRequest';

  /// Required. The MetadataStore whose Executions should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// The maximum number of Executions to return. The service may return fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListExecutions`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with an
  /// INVALID_ARGUMENT error.)
  final String? pageToken;

  /// Filter specifying the boolean condition for the Executions to satisfy in
  /// order to be part of the result set.
  /// The syntax to define filter query is based on https://google.aip.dev/160.
  /// Following are the supported set of filters:
  ///
  /// *  **Attribute filtering**:
  ///    For example: `display_name = "test"`.
  ///    Supported fields include: `name`, `display_name`, `state`,
  ///    `schema_title`, `create_time`, and `update_time`.
  ///    Time fields, such as `create_time` and `update_time`, require values
  ///    specified in RFC-3339 format.
  ///    For example: `create_time = "2020-11-19T11:30:00-04:00"`.
  /// *  **Metadata field**:
  ///    To filter on metadata fields use traversal operation as follows:
  ///    `metadata.<field_name>.<type_value>`
  ///    For example: `metadata.field_1.number_value = 10.0`
  ///    In case the field name contains special characters (such as colon), one
  ///    can embed it inside double quote.
  ///    For example: `metadata."field:1".number_value = 10.0`
  /// *  **Context based filtering**:
  ///    To filter Executions based on the contexts to which they belong use
  ///    the function operator with the full resource name:
  ///    `in_context(<context-name>)`.
  ///    For example:
  ///    `in_context("projects/<project_number>/locations/<location>/metadataStores/<metadatastore_name>/contexts/<context-id>")`
  ///
  /// Each of the above supported filters can be combined together using
  /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
  /// is 5.
  ///
  /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
  final String? filter;

  /// How the list of messages is ordered. Specify the values to order by and an
  /// ordering operation. The default sorting order is ascending. To specify
  /// descending order for a field, users append a " desc" suffix; for example:
  /// "foo desc, bar".
  /// Subfields are specified with a `.` character, such as foo.bar.
  /// see https://google.aip.dev/132#ordering for more details.
  final String? orderBy;

  ListExecutionsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListExecutionsRequest.fromJson(Map<String, dynamic> json) {
    return ListExecutionsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListExecutionsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListExecutions`.
final class ListExecutionsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListExecutionsResponse';

  /// The Executions retrieved from the MetadataStore.
  final List<Execution>? executions;

  /// A token, which can be sent as
  /// `ListExecutionsRequest.page_token`
  /// to retrieve the next page.
  /// If this field is not populated, there are no subsequent pages.
  final String? nextPageToken;

  ListExecutionsResponse({this.executions, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListExecutionsResponse.fromJson(Map<String, dynamic> json) {
    return ListExecutionsResponse(
      executions: decodeListMessage(json['executions'], Execution.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (executions != null) 'executions': encodeList(executions),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListExecutionsResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.UpdateExecution`.
final class UpdateExecutionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExecutionRequest';

  /// Required. The Execution containing updates.
  /// The Execution's
  /// `Execution.name` field is
  /// used to identify the Execution to be updated. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final Execution execution;

  /// Optional. A FieldMask indicating which fields should be updated.
  final protobuf.FieldMask? updateMask;

  /// If set to true, and the
  /// `Execution` is not found, a new
  /// `Execution` is created.
  final bool? allowMissing;

  UpdateExecutionRequest({
    required this.execution,
    this.updateMask,
    this.allowMissing,
  }) : super(fullyQualifiedName);

  factory UpdateExecutionRequest.fromJson(Map<String, dynamic> json) {
    return UpdateExecutionRequest(
      execution: decode(json['execution'], Execution.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
      allowMissing: json['allowMissing'],
    );
  }

  @override
  Object toJson() {
    return {
      'execution': execution.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
      if (allowMissing != null) 'allowMissing': allowMissing,
    };
  }

  @override
  String toString() {
    final contents = [
      if (allowMissing != null) 'allowMissing=$allowMissing',
    ].join(',');
    return 'UpdateExecutionRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.DeleteExecution`.
final class DeleteExecutionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteExecutionRequest';

  /// Required. The resource name of the Execution to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final String name;

  /// Optional. The etag of the Execution to delete.
  /// If this is provided, it must match the server's etag. Otherwise, the
  /// request will fail with a FAILED_PRECONDITION.
  final String? etag;

  DeleteExecutionRequest({required this.name, this.etag})
    : super(fullyQualifiedName);

  factory DeleteExecutionRequest.fromJson(Map<String, dynamic> json) {
    return DeleteExecutionRequest(name: json['name'], etag: json['etag']);
  }

  @override
  Object toJson() {
    return {'name': name, if (etag != null) 'etag': etag};
  }

  @override
  String toString() {
    final contents = ['name=$name', if (etag != null) 'etag=$etag'].join(',');
    return 'DeleteExecutionRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.PurgeExecutions`.
final class PurgeExecutionsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeExecutionsRequest';

  /// Required. The metadata store to purge Executions from.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. A required filter matching the Executions to be purged.
  /// E.g., `update_time <= 2020-11-19T11:30:00-04:00`.
  final String? filter;

  /// Optional. Flag to indicate to actually perform the purge.
  /// If `force` is set to false, the method will return a sample of
  /// Execution names that would be deleted.
  final bool? force;

  PurgeExecutionsRequest({required this.parent, this.filter, this.force})
    : super(fullyQualifiedName);

  factory PurgeExecutionsRequest.fromJson(Map<String, dynamic> json) {
    return PurgeExecutionsRequest(
      parent: json['parent'],
      filter: json['filter'],
      force: json['force'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (force != null) 'force': force,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (force != null) 'force=$force',
    ].join(',');
    return 'PurgeExecutionsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.PurgeExecutions`.
final class PurgeExecutionsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeExecutionsResponse';

  /// The number of Executions that this request deleted (or, if `force` is
  /// false, the number of Executions that will be deleted). This can be an
  /// estimate.
  final int? purgeCount;

  /// A sample of the Execution names that will be deleted.
  /// Only populated if `force` is set to false. The maximum number of samples is
  /// 100 (it is possible to return fewer).
  final List<String>? purgeSample;

  PurgeExecutionsResponse({this.purgeCount, this.purgeSample})
    : super(fullyQualifiedName);

  factory PurgeExecutionsResponse.fromJson(Map<String, dynamic> json) {
    return PurgeExecutionsResponse(
      purgeCount: decodeInt64(json['purgeCount']),
      purgeSample: decodeList(json['purgeSample']),
    );
  }

  @override
  Object toJson() {
    return {
      if (purgeCount != null) 'purgeCount': encodeInt64(purgeCount),
      if (purgeSample != null) 'purgeSample': purgeSample,
    };
  }

  @override
  String toString() {
    final contents = [
      if (purgeCount != null) 'purgeCount=$purgeCount',
    ].join(',');
    return 'PurgeExecutionsResponse($contents)';
  }
}

/// Details of operations that perform
/// `MetadataService.PurgeExecutions`.
final class PurgeExecutionsMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PurgeExecutionsMetadata';

  /// Operation metadata for purging Executions.
  final GenericOperationMetadata? genericMetadata;

  PurgeExecutionsMetadata({this.genericMetadata}) : super(fullyQualifiedName);

  factory PurgeExecutionsMetadata.fromJson(Map<String, dynamic> json) {
    return PurgeExecutionsMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'PurgeExecutionsMetadata()';
}

/// Request message for
/// `MetadataService.AddExecutionEvents`.
final class AddExecutionEventsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddExecutionEventsRequest';

  /// Required. The resource name of the Execution that the Events connect
  /// Artifacts with.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final String execution;

  /// The Events to create and add.
  final List<Event>? events;

  AddExecutionEventsRequest({required this.execution, this.events})
    : super(fullyQualifiedName);

  factory AddExecutionEventsRequest.fromJson(Map<String, dynamic> json) {
    return AddExecutionEventsRequest(
      execution: json['execution'],
      events: decodeListMessage(json['events'], Event.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'execution': execution,
      if (events != null) 'events': encodeList(events),
    };
  }

  @override
  String toString() {
    final contents = ['execution=$execution'].join(',');
    return 'AddExecutionEventsRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.AddExecutionEvents`.
final class AddExecutionEventsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddExecutionEventsResponse';

  AddExecutionEventsResponse() : super(fullyQualifiedName);

  factory AddExecutionEventsResponse.fromJson(Map<String, dynamic> json) {
    return AddExecutionEventsResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'AddExecutionEventsResponse()';
}

/// Request message for
/// `MetadataService.QueryExecutionInputsAndOutputs`.
final class QueryExecutionInputsAndOutputsRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryExecutionInputsAndOutputsRequest';

  /// Required. The resource name of the Execution whose input and output
  /// Artifacts should be retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/executions/{execution}`
  final String execution;

  QueryExecutionInputsAndOutputsRequest({required this.execution})
    : super(fullyQualifiedName);

  factory QueryExecutionInputsAndOutputsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return QueryExecutionInputsAndOutputsRequest(execution: json['execution']);
  }

  @override
  Object toJson() {
    return {'execution': execution};
  }

  @override
  String toString() {
    final contents = ['execution=$execution'].join(',');
    return 'QueryExecutionInputsAndOutputsRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.CreateMetadataSchema`.
final class CreateMetadataSchemaRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateMetadataSchemaRequest';

  /// Required. The resource name of the MetadataStore where the MetadataSchema
  /// should be created. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// Required. The MetadataSchema to create.
  final MetadataSchema metadataSchema;

  /// The {metadata_schema} portion of the resource name with the format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  /// If not provided, the MetadataStore's ID will be a UUID generated by the
  /// service.
  /// Must be 4-128 characters in length. Valid characters are `/[a-z][0-9]-/`.
  /// Must be unique across all MetadataSchemas in the parent Location.
  /// (Otherwise the request will fail with ALREADY_EXISTS, or PERMISSION_DENIED
  /// if the caller can't view the preexisting MetadataSchema.)
  final String? metadataSchemaId;

  CreateMetadataSchemaRequest({
    required this.parent,
    required this.metadataSchema,
    this.metadataSchemaId,
  }) : super(fullyQualifiedName);

  factory CreateMetadataSchemaRequest.fromJson(Map<String, dynamic> json) {
    return CreateMetadataSchemaRequest(
      parent: json['parent'],
      metadataSchema: decode(json['metadataSchema'], MetadataSchema.fromJson)!,
      metadataSchemaId: json['metadataSchemaId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'metadataSchema': metadataSchema.toJson(),
      if (metadataSchemaId != null) 'metadataSchemaId': metadataSchemaId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (metadataSchemaId != null) 'metadataSchemaId=$metadataSchemaId',
    ].join(',');
    return 'CreateMetadataSchemaRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.GetMetadataSchema`.
final class GetMetadataSchemaRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetMetadataSchemaRequest';

  /// Required. The resource name of the MetadataSchema to retrieve.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/metadataSchemas/{metadataschema}`
  final String name;

  GetMetadataSchemaRequest({required this.name}) : super(fullyQualifiedName);

  factory GetMetadataSchemaRequest.fromJson(Map<String, dynamic> json) {
    return GetMetadataSchemaRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetMetadataSchemaRequest($contents)';
  }
}

/// Request message for
/// `MetadataService.ListMetadataSchemas`.
final class ListMetadataSchemasRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMetadataSchemasRequest';

  /// Required. The MetadataStore whose MetadataSchemas should be listed.
  /// Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}`
  final String parent;

  /// The maximum number of MetadataSchemas to return. The service may return
  /// fewer.
  /// Must be in range 1-1000, inclusive. Defaults to 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `MetadataService.ListMetadataSchemas`
  /// call. Provide this to retrieve the next page.
  ///
  /// When paginating, all other provided parameters must match the call that
  /// provided the page token. (Otherwise the request will fail with
  /// INVALID_ARGUMENT error.)
  final String? pageToken;

  /// A query to filter available MetadataSchemas for matching results.
  final String? filter;

  ListMetadataSchemasRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
  }) : super(fullyQualifiedName);

  factory ListMetadataSchemasRequest.fromJson(Map<String, dynamic> json) {
    return ListMetadataSchemasRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'ListMetadataSchemasRequest($contents)';
  }
}

/// Response message for
/// `MetadataService.ListMetadataSchemas`.
final class ListMetadataSchemasResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListMetadataSchemasResponse';

  /// The MetadataSchemas found for the MetadataStore.
  final List<MetadataSchema>? metadataSchemas;

  /// A token, which can be sent as
  /// `ListMetadataSchemasRequest.page_token`
  /// to retrieve the next page. If this field is not populated, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListMetadataSchemasResponse({this.metadataSchemas, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListMetadataSchemasResponse.fromJson(Map<String, dynamic> json) {
    return ListMetadataSchemasResponse(
      metadataSchemas: decodeListMessage(
        json['metadataSchemas'],
        MetadataSchema.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (metadataSchemas != null)
        'metadataSchemas': encodeList(metadataSchemas),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListMetadataSchemasResponse($contents)';
  }
}

/// Request message for
/// `MetadataService.QueryArtifactLineageSubgraph`.
final class QueryArtifactLineageSubgraphRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryArtifactLineageSubgraphRequest';

  /// Required. The resource name of the Artifact whose Lineage needs to be
  /// retrieved as a LineageSubgraph. Format:
  /// `projects/{project}/locations/{location}/metadataStores/{metadatastore}/artifacts/{artifact}`
  ///
  /// The request may error with FAILED_PRECONDITION if the number of Artifacts,
  /// the number of Executions, or the number of Events that would be returned
  /// for the Context exceeds 1000.
  final String artifact;

  /// Specifies the size of the lineage graph in terms of number of hops from the
  /// specified artifact.
  /// Negative Value: INVALID_ARGUMENT error is returned
  /// 0: Only input artifact is returned.
  /// No value: Transitive closure is performed to return the complete graph.
  final int? maxHops;

  /// Filter specifying the boolean condition for the Artifacts to satisfy in
  /// order to be part of the Lineage Subgraph.
  /// The syntax to define filter query is based on https://google.aip.dev/160.
  /// The supported set of filters include the following:
  ///
  /// *  **Attribute filtering**:
  ///    For example: `display_name = "test"`
  ///    Supported fields include: `name`, `display_name`, `uri`, `state`,
  ///    `schema_title`, `create_time`, and `update_time`.
  ///    Time fields, such as `create_time` and `update_time`, require values
  ///    specified in RFC-3339 format.
  ///    For example: `create_time = "2020-11-19T11:30:00-04:00"`
  /// *  **Metadata field**:
  ///    To filter on metadata fields use traversal operation as follows:
  ///    `metadata.<field_name>.<type_value>`.
  ///    For example: `metadata.field_1.number_value = 10.0`
  ///    In case the field name contains special characters (such as colon), one
  ///    can embed it inside double quote.
  ///    For example: `metadata."field:1".number_value = 10.0`
  ///
  /// Each of the above supported filter types can be combined together using
  /// logical operators (`AND` & `OR`). Maximum nested expression depth allowed
  /// is 5.
  ///
  /// For example: `display_name = "test" AND metadata.field1.bool_value = true`.
  final String? filter;

  QueryArtifactLineageSubgraphRequest({
    required this.artifact,
    this.maxHops,
    this.filter,
  }) : super(fullyQualifiedName);

  factory QueryArtifactLineageSubgraphRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return QueryArtifactLineageSubgraphRequest(
      artifact: json['artifact'],
      maxHops: json['maxHops'],
      filter: json['filter'],
    );
  }

  @override
  Object toJson() {
    return {
      'artifact': artifact,
      if (maxHops != null) 'maxHops': maxHops,
      if (filter != null) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      'artifact=$artifact',
      if (maxHops != null) 'maxHops=$maxHops',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'QueryArtifactLineageSubgraphRequest($contents)';
  }
}

/// Instance of a metadata store. Contains a set of metadata that can be
/// queried.
final class MetadataStore extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetadataStore';

  /// Output only. The resource name of the MetadataStore instance.
  final String? name;

  /// Output only. Timestamp when this MetadataStore was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this MetadataStore was last updated.
  final protobuf.Timestamp? updateTime;

  /// Customer-managed encryption key spec for a Metadata Store. If set, this
  /// Metadata Store and all sub-resources of this Metadata Store are secured
  /// using this key.
  final EncryptionSpec? encryptionSpec;

  /// Description of the MetadataStore.
  final String? description;

  /// Output only. State information of the MetadataStore.
  final MetadataStore_MetadataStoreState? state;

  /// Optional. Dataplex integration settings.
  final MetadataStore_DataplexConfig? dataplexConfig;

  MetadataStore({
    this.name,
    this.createTime,
    this.updateTime,
    this.encryptionSpec,
    this.description,
    this.state,
    this.dataplexConfig,
  }) : super(fullyQualifiedName);

  factory MetadataStore.fromJson(Map<String, dynamic> json) {
    return MetadataStore(
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      description: json['description'],
      state: decode(json['state'], MetadataStore_MetadataStoreState.fromJson),
      dataplexConfig: decode(
        json['dataplexConfig'],
        MetadataStore_DataplexConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (description != null) 'description': description,
      if (state != null) 'state': state!.toJson(),
      if (dataplexConfig != null) 'dataplexConfig': dataplexConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
    ].join(',');
    return 'MetadataStore($contents)';
  }
}

/// Represents state information for a MetadataStore.
final class MetadataStore_MetadataStoreState extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetadataStore.MetadataStoreState';

  /// The disk utilization of the MetadataStore in bytes.
  final int? diskUtilizationBytes;

  MetadataStore_MetadataStoreState({this.diskUtilizationBytes})
    : super(fullyQualifiedName);

  factory MetadataStore_MetadataStoreState.fromJson(Map<String, dynamic> json) {
    return MetadataStore_MetadataStoreState(
      diskUtilizationBytes: decodeInt64(json['diskUtilizationBytes']),
    );
  }

  @override
  Object toJson() {
    return {
      if (diskUtilizationBytes != null)
        'diskUtilizationBytes': encodeInt64(diskUtilizationBytes),
    };
  }

  @override
  String toString() {
    final contents = [
      if (diskUtilizationBytes != null)
        'diskUtilizationBytes=$diskUtilizationBytes',
    ].join(',');
    return 'MetadataStoreState($contents)';
  }
}

/// Represents Dataplex integration settings.
final class MetadataStore_DataplexConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MetadataStore.DataplexConfig';

  /// Optional. Whether or not Data Lineage synchronization is enabled for
  /// Vertex Pipelines.
  final bool? enabledPipelinesLineage;

  MetadataStore_DataplexConfig({this.enabledPipelinesLineage})
    : super(fullyQualifiedName);

  factory MetadataStore_DataplexConfig.fromJson(Map<String, dynamic> json) {
    return MetadataStore_DataplexConfig(
      enabledPipelinesLineage: json['enabledPipelinesLineage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (enabledPipelinesLineage != null)
        'enabledPipelinesLineage': enabledPipelinesLineage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (enabledPipelinesLineage != null)
        'enabledPipelinesLineage=$enabledPipelinesLineage',
    ].join(',');
    return 'DataplexConfig($contents)';
  }
}

/// Represents one resource that exists in automl.googleapis.com,
/// datalabeling.googleapis.com or ml.googleapis.com.
final class MigratableResource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource';

  /// Output only. Represents one Version in ml.googleapis.com.
  final MigratableResource_MlEngineModelVersion? mlEngineModelVersion;

  /// Output only. Represents one Model in automl.googleapis.com.
  final MigratableResource_AutomlModel? automlModel;

  /// Output only. Represents one Dataset in automl.googleapis.com.
  final MigratableResource_AutomlDataset? automlDataset;

  /// Output only. Represents one Dataset in datalabeling.googleapis.com.
  final MigratableResource_DataLabelingDataset? dataLabelingDataset;

  /// Output only. Timestamp when the last migration attempt on this
  /// MigratableResource started. Will not be set if there's no migration attempt
  /// on this MigratableResource.
  final protobuf.Timestamp? lastMigrateTime;

  /// Output only. Timestamp when this MigratableResource was last updated.
  final protobuf.Timestamp? lastUpdateTime;

  MigratableResource({
    this.mlEngineModelVersion,
    this.automlModel,
    this.automlDataset,
    this.dataLabelingDataset,
    this.lastMigrateTime,
    this.lastUpdateTime,
  }) : super(fullyQualifiedName);

  factory MigratableResource.fromJson(Map<String, dynamic> json) {
    return MigratableResource(
      mlEngineModelVersion: decode(
        json['mlEngineModelVersion'],
        MigratableResource_MlEngineModelVersion.fromJson,
      ),
      automlModel: decode(
        json['automlModel'],
        MigratableResource_AutomlModel.fromJson,
      ),
      automlDataset: decode(
        json['automlDataset'],
        MigratableResource_AutomlDataset.fromJson,
      ),
      dataLabelingDataset: decode(
        json['dataLabelingDataset'],
        MigratableResource_DataLabelingDataset.fromJson,
      ),
      lastMigrateTime: decodeCustom(
        json['lastMigrateTime'],
        protobuf.Timestamp.fromJson,
      ),
      lastUpdateTime: decodeCustom(
        json['lastUpdateTime'],
        protobuf.Timestamp.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (mlEngineModelVersion != null)
        'mlEngineModelVersion': mlEngineModelVersion!.toJson(),
      if (automlModel != null) 'automlModel': automlModel!.toJson(),
      if (automlDataset != null) 'automlDataset': automlDataset!.toJson(),
      if (dataLabelingDataset != null)
        'dataLabelingDataset': dataLabelingDataset!.toJson(),
      if (lastMigrateTime != null) 'lastMigrateTime': lastMigrateTime!.toJson(),
      if (lastUpdateTime != null) 'lastUpdateTime': lastUpdateTime!.toJson(),
    };
  }

  @override
  String toString() => 'MigratableResource()';
}

/// Represents one model Version in ml.googleapis.com.
final class MigratableResource_MlEngineModelVersion
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.MlEngineModelVersion';

  /// The ml.googleapis.com endpoint that this model Version currently lives
  /// in.
  /// Example values:
  ///
  /// * ml.googleapis.com
  /// * us-centrall-ml.googleapis.com
  /// * europe-west4-ml.googleapis.com
  /// * asia-east1-ml.googleapis.com
  final String? endpoint;

  /// Full resource name of ml engine model Version.
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  final String? version;

  MigratableResource_MlEngineModelVersion({this.endpoint, this.version})
    : super(fullyQualifiedName);

  factory MigratableResource_MlEngineModelVersion.fromJson(
    Map<String, dynamic> json,
  ) {
    return MigratableResource_MlEngineModelVersion(
      endpoint: json['endpoint'],
      version: json['version'],
    );
  }

  @override
  Object toJson() {
    return {
      if (endpoint != null) 'endpoint': endpoint,
      if (version != null) 'version': version,
    };
  }

  @override
  String toString() {
    final contents = [
      if (endpoint != null) 'endpoint=$endpoint',
      if (version != null) 'version=$version',
    ].join(',');
    return 'MlEngineModelVersion($contents)';
  }
}

/// Represents one Model in automl.googleapis.com.
final class MigratableResource_AutomlModel extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.AutomlModel';

  /// Full resource name of automl Model.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}`.
  final String? model;

  /// The Model's display name in automl.googleapis.com.
  final String? modelDisplayName;

  MigratableResource_AutomlModel({this.model, this.modelDisplayName})
    : super(fullyQualifiedName);

  factory MigratableResource_AutomlModel.fromJson(Map<String, dynamic> json) {
    return MigratableResource_AutomlModel(
      model: json['model'],
      modelDisplayName: json['modelDisplayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      if (modelDisplayName != null) 'modelDisplayName': modelDisplayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (modelDisplayName != null) 'modelDisplayName=$modelDisplayName',
    ].join(',');
    return 'AutomlModel($contents)';
  }
}

/// Represents one Dataset in automl.googleapis.com.
final class MigratableResource_AutomlDataset extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.AutomlDataset';

  /// Full resource name of automl Dataset.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`.
  final String? dataset;

  /// The Dataset's display name in automl.googleapis.com.
  final String? datasetDisplayName;

  MigratableResource_AutomlDataset({this.dataset, this.datasetDisplayName})
    : super(fullyQualifiedName);

  factory MigratableResource_AutomlDataset.fromJson(Map<String, dynamic> json) {
    return MigratableResource_AutomlDataset(
      dataset: json['dataset'],
      datasetDisplayName: json['datasetDisplayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dataset != null) 'dataset': dataset,
      if (datasetDisplayName != null) 'datasetDisplayName': datasetDisplayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataset != null) 'dataset=$dataset',
      if (datasetDisplayName != null) 'datasetDisplayName=$datasetDisplayName',
    ].join(',');
    return 'AutomlDataset($contents)';
  }
}

/// Represents one Dataset in datalabeling.googleapis.com.
final class MigratableResource_DataLabelingDataset
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.DataLabelingDataset';

  /// Full resource name of data labeling Dataset.
  /// Format:
  /// `projects/{project}/datasets/{dataset}`.
  final String? dataset;

  /// The Dataset's display name in datalabeling.googleapis.com.
  final String? datasetDisplayName;

  /// The migratable AnnotatedDataset in datalabeling.googleapis.com belongs to
  /// the data labeling Dataset.
  final List<
    MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset
  >?
  dataLabelingAnnotatedDatasets;

  MigratableResource_DataLabelingDataset({
    this.dataset,
    this.datasetDisplayName,
    this.dataLabelingAnnotatedDatasets,
  }) : super(fullyQualifiedName);

  factory MigratableResource_DataLabelingDataset.fromJson(
    Map<String, dynamic> json,
  ) {
    return MigratableResource_DataLabelingDataset(
      dataset: json['dataset'],
      datasetDisplayName: json['datasetDisplayName'],
      dataLabelingAnnotatedDatasets: decodeListMessage(
        json['dataLabelingAnnotatedDatasets'],
        MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataset != null) 'dataset': dataset,
      if (datasetDisplayName != null) 'datasetDisplayName': datasetDisplayName,
      if (dataLabelingAnnotatedDatasets != null)
        'dataLabelingAnnotatedDatasets': encodeList(
          dataLabelingAnnotatedDatasets,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataset != null) 'dataset=$dataset',
      if (datasetDisplayName != null) 'datasetDisplayName=$datasetDisplayName',
    ].join(',');
    return 'DataLabelingDataset($contents)';
  }
}

/// Represents one AnnotatedDataset in datalabeling.googleapis.com.
final class MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigratableResource.DataLabelingDataset.DataLabelingAnnotatedDataset';

  /// Full resource name of data labeling AnnotatedDataset.
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  final String? annotatedDataset;

  /// The AnnotatedDataset's display name in datalabeling.googleapis.com.
  final String? annotatedDatasetDisplayName;

  MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset({
    this.annotatedDataset,
    this.annotatedDatasetDisplayName,
  }) : super(fullyQualifiedName);

  factory MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset.fromJson(
    Map<String, dynamic> json,
  ) {
    return MigratableResource_DataLabelingDataset_DataLabelingAnnotatedDataset(
      annotatedDataset: json['annotatedDataset'],
      annotatedDatasetDisplayName: json['annotatedDatasetDisplayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (annotatedDataset != null) 'annotatedDataset': annotatedDataset,
      if (annotatedDatasetDisplayName != null)
        'annotatedDatasetDisplayName': annotatedDatasetDisplayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (annotatedDataset != null) 'annotatedDataset=$annotatedDataset',
      if (annotatedDatasetDisplayName != null)
        'annotatedDatasetDisplayName=$annotatedDatasetDisplayName',
    ].join(',');
    return 'DataLabelingAnnotatedDataset($contents)';
  }
}

/// Request message for
/// `MigrationService.SearchMigratableResources`.
final class SearchMigratableResourcesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchMigratableResourcesRequest';

  /// Required. The location that the migratable resources should be searched
  /// from. It's the Vertex AI location that the resources can be migrated to,
  /// not the resources' original location. Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// The standard page size.
  /// The default and maximum value is 100.
  final int? pageSize;

  /// The standard page token.
  final String? pageToken;

  /// A filter for your search. You can use the following types of filters:
  ///
  /// *   Resource type filters. The following strings filter for a specific type
  ///     of
  ///     `MigratableResource`:
  ///     *   `ml_engine_model_version:*`
  ///     *   `automl_model:*`
  ///     *   `automl_dataset:*`
  ///     *   `data_labeling_dataset:*`
  /// *   "Migrated or not" filters. The following strings filter for resources
  ///     that either have or have not already been migrated:
  ///     *   `last_migrate_time:*` filters for migrated resources.
  ///     *   `NOT last_migrate_time:*` filters for not yet migrated resources.
  final String? filter;

  SearchMigratableResourcesRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
  }) : super(fullyQualifiedName);

  factory SearchMigratableResourcesRequest.fromJson(Map<String, dynamic> json) {
    return SearchMigratableResourcesRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'SearchMigratableResourcesRequest($contents)';
  }
}

/// Response message for
/// `MigrationService.SearchMigratableResources`.
final class SearchMigratableResourcesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchMigratableResourcesResponse';

  /// All migratable resources that can be migrated to the
  /// location specified in the request.
  final List<MigratableResource>? migratableResources;

  /// The standard next-page token.
  /// The migratable_resources may not fill page_size in
  /// SearchMigratableResourcesRequest even when there are subsequent pages.
  final String? nextPageToken;

  SearchMigratableResourcesResponse({
    this.migratableResources,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory SearchMigratableResourcesResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchMigratableResourcesResponse(
      migratableResources: decodeListMessage(
        json['migratableResources'],
        MigratableResource.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (migratableResources != null)
        'migratableResources': encodeList(migratableResources),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'SearchMigratableResourcesResponse($contents)';
  }
}

/// Request message for
/// `MigrationService.BatchMigrateResources`.
final class BatchMigrateResourcesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchMigrateResourcesRequest';

  /// Required. The location of the migrated resource will live in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The request messages specifying the resources to migrate.
  /// They must be in the same location as the destination.
  /// Up to 50 resources can be migrated in one batch.
  final List<MigrateResourceRequest>? migrateResourceRequests;

  BatchMigrateResourcesRequest({
    required this.parent,
    this.migrateResourceRequests,
  }) : super(fullyQualifiedName);

  factory BatchMigrateResourcesRequest.fromJson(Map<String, dynamic> json) {
    return BatchMigrateResourcesRequest(
      parent: json['parent'],
      migrateResourceRequests: decodeListMessage(
        json['migrateResourceRequests'],
        MigrateResourceRequest.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (migrateResourceRequests != null)
        'migrateResourceRequests': encodeList(migrateResourceRequests),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchMigrateResourcesRequest($contents)';
  }
}

/// Config of migrating one resource from automl.googleapis.com,
/// datalabeling.googleapis.com and ml.googleapis.com to Vertex AI.
final class MigrateResourceRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest';

  /// Config for migrating Version in ml.googleapis.com to Vertex AI's Model.
  final MigrateResourceRequest_MigrateMlEngineModelVersionConfig?
  migrateMlEngineModelVersionConfig;

  /// Config for migrating Model in automl.googleapis.com to Vertex AI's
  /// Model.
  final MigrateResourceRequest_MigrateAutomlModelConfig?
  migrateAutomlModelConfig;

  /// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
  /// Dataset.
  final MigrateResourceRequest_MigrateAutomlDatasetConfig?
  migrateAutomlDatasetConfig;

  /// Config for migrating Dataset in datalabeling.googleapis.com to
  /// Vertex AI's Dataset.
  final MigrateResourceRequest_MigrateDataLabelingDatasetConfig?
  migrateDataLabelingDatasetConfig;

  MigrateResourceRequest({
    this.migrateMlEngineModelVersionConfig,
    this.migrateAutomlModelConfig,
    this.migrateAutomlDatasetConfig,
    this.migrateDataLabelingDatasetConfig,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest.fromJson(Map<String, dynamic> json) {
    return MigrateResourceRequest(
      migrateMlEngineModelVersionConfig: decode(
        json['migrateMlEngineModelVersionConfig'],
        MigrateResourceRequest_MigrateMlEngineModelVersionConfig.fromJson,
      ),
      migrateAutomlModelConfig: decode(
        json['migrateAutomlModelConfig'],
        MigrateResourceRequest_MigrateAutomlModelConfig.fromJson,
      ),
      migrateAutomlDatasetConfig: decode(
        json['migrateAutomlDatasetConfig'],
        MigrateResourceRequest_MigrateAutomlDatasetConfig.fromJson,
      ),
      migrateDataLabelingDatasetConfig: decode(
        json['migrateDataLabelingDatasetConfig'],
        MigrateResourceRequest_MigrateDataLabelingDatasetConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (migrateMlEngineModelVersionConfig != null)
        'migrateMlEngineModelVersionConfig': migrateMlEngineModelVersionConfig!
            .toJson(),
      if (migrateAutomlModelConfig != null)
        'migrateAutomlModelConfig': migrateAutomlModelConfig!.toJson(),
      if (migrateAutomlDatasetConfig != null)
        'migrateAutomlDatasetConfig': migrateAutomlDatasetConfig!.toJson(),
      if (migrateDataLabelingDatasetConfig != null)
        'migrateDataLabelingDatasetConfig': migrateDataLabelingDatasetConfig!
            .toJson(),
    };
  }

  @override
  String toString() => 'MigrateResourceRequest()';
}

/// Config for migrating version in ml.googleapis.com to Vertex AI's Model.
final class MigrateResourceRequest_MigrateMlEngineModelVersionConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateMlEngineModelVersionConfig';

  /// Required. The ml.googleapis.com endpoint that this model version should
  /// be migrated from. Example values:
  ///
  /// * ml.googleapis.com
  ///
  /// * us-centrall-ml.googleapis.com
  ///
  /// * europe-west4-ml.googleapis.com
  ///
  /// * asia-east1-ml.googleapis.com
  final String? endpoint;

  /// Required. Full resource name of ml engine model version.
  /// Format: `projects/{project}/models/{model}/versions/{version}`.
  final String? modelVersion;

  /// Required. Display name of the model in Vertex AI.
  /// System will pick a display name if unspecified.
  final String? modelDisplayName;

  MigrateResourceRequest_MigrateMlEngineModelVersionConfig({
    this.endpoint,
    this.modelVersion,
    this.modelDisplayName,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateMlEngineModelVersionConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return MigrateResourceRequest_MigrateMlEngineModelVersionConfig(
      endpoint: json['endpoint'],
      modelVersion: json['modelVersion'],
      modelDisplayName: json['modelDisplayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (endpoint != null) 'endpoint': endpoint,
      if (modelVersion != null) 'modelVersion': modelVersion,
      if (modelDisplayName != null) 'modelDisplayName': modelDisplayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (endpoint != null) 'endpoint=$endpoint',
      if (modelVersion != null) 'modelVersion=$modelVersion',
      if (modelDisplayName != null) 'modelDisplayName=$modelDisplayName',
    ].join(',');
    return 'MigrateMlEngineModelVersionConfig($contents)';
  }
}

/// Config for migrating Model in automl.googleapis.com to Vertex AI's Model.
final class MigrateResourceRequest_MigrateAutomlModelConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateAutomlModelConfig';

  /// Required. Full resource name of automl Model.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}`.
  final String? model;

  /// Optional. Display name of the model in Vertex AI.
  /// System will pick a display name if unspecified.
  final String? modelDisplayName;

  MigrateResourceRequest_MigrateAutomlModelConfig({
    this.model,
    this.modelDisplayName,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateAutomlModelConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return MigrateResourceRequest_MigrateAutomlModelConfig(
      model: json['model'],
      modelDisplayName: json['modelDisplayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      if (modelDisplayName != null) 'modelDisplayName': modelDisplayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (modelDisplayName != null) 'modelDisplayName=$modelDisplayName',
    ].join(',');
    return 'MigrateAutomlModelConfig($contents)';
  }
}

/// Config for migrating Dataset in automl.googleapis.com to Vertex AI's
/// Dataset.
final class MigrateResourceRequest_MigrateAutomlDatasetConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateAutomlDatasetConfig';

  /// Required. Full resource name of automl Dataset.
  /// Format:
  /// `projects/{project}/locations/{location}/datasets/{dataset}`.
  final String? dataset;

  /// Required. Display name of the Dataset in Vertex AI.
  /// System will pick a display name if unspecified.
  final String? datasetDisplayName;

  MigrateResourceRequest_MigrateAutomlDatasetConfig({
    this.dataset,
    this.datasetDisplayName,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateAutomlDatasetConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return MigrateResourceRequest_MigrateAutomlDatasetConfig(
      dataset: json['dataset'],
      datasetDisplayName: json['datasetDisplayName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dataset != null) 'dataset': dataset,
      if (datasetDisplayName != null) 'datasetDisplayName': datasetDisplayName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataset != null) 'dataset=$dataset',
      if (datasetDisplayName != null) 'datasetDisplayName=$datasetDisplayName',
    ].join(',');
    return 'MigrateAutomlDatasetConfig($contents)';
  }
}

/// Config for migrating Dataset in datalabeling.googleapis.com to Vertex
/// AI's Dataset.
final class MigrateResourceRequest_MigrateDataLabelingDatasetConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig';

  /// Required. Full resource name of data labeling Dataset.
  /// Format:
  /// `projects/{project}/datasets/{dataset}`.
  final String? dataset;

  /// Optional. Display name of the Dataset in Vertex AI.
  /// System will pick a display name if unspecified.
  final String? datasetDisplayName;

  /// Optional. Configs for migrating AnnotatedDataset in
  /// datalabeling.googleapis.com to Vertex AI's SavedQuery. The specified
  /// AnnotatedDatasets have to belong to the datalabeling Dataset.
  final List<
    MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig
  >?
  migrateDataLabelingAnnotatedDatasetConfigs;

  MigrateResourceRequest_MigrateDataLabelingDatasetConfig({
    this.dataset,
    this.datasetDisplayName,
    this.migrateDataLabelingAnnotatedDatasetConfigs,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateDataLabelingDatasetConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return MigrateResourceRequest_MigrateDataLabelingDatasetConfig(
      dataset: json['dataset'],
      datasetDisplayName: json['datasetDisplayName'],
      migrateDataLabelingAnnotatedDatasetConfigs: decodeListMessage(
        json['migrateDataLabelingAnnotatedDatasetConfigs'],
        MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataset != null) 'dataset': dataset,
      if (datasetDisplayName != null) 'datasetDisplayName': datasetDisplayName,
      if (migrateDataLabelingAnnotatedDatasetConfigs != null)
        'migrateDataLabelingAnnotatedDatasetConfigs': encodeList(
          migrateDataLabelingAnnotatedDatasetConfigs,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataset != null) 'dataset=$dataset',
      if (datasetDisplayName != null) 'datasetDisplayName=$datasetDisplayName',
    ].join(',');
    return 'MigrateDataLabelingDatasetConfig($contents)';
  }
}

/// Config for migrating AnnotatedDataset in datalabeling.googleapis.com to
/// Vertex AI's SavedQuery.
final class MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceRequest.MigrateDataLabelingDatasetConfig.MigrateDataLabelingAnnotatedDatasetConfig';

  /// Required. Full resource name of data labeling AnnotatedDataset.
  /// Format:
  /// `projects/{project}/datasets/{dataset}/annotatedDatasets/{annotated_dataset}`.
  final String? annotatedDataset;

  MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig({
    this.annotatedDataset,
  }) : super(fullyQualifiedName);

  factory MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return MigrateResourceRequest_MigrateDataLabelingDatasetConfig_MigrateDataLabelingAnnotatedDatasetConfig(
      annotatedDataset: json['annotatedDataset'],
    );
  }

  @override
  Object toJson() {
    return {if (annotatedDataset != null) 'annotatedDataset': annotatedDataset};
  }

  @override
  String toString() {
    final contents = [
      if (annotatedDataset != null) 'annotatedDataset=$annotatedDataset',
    ].join(',');
    return 'MigrateDataLabelingAnnotatedDatasetConfig($contents)';
  }
}

/// Response message for
/// `MigrationService.BatchMigrateResources`.
final class BatchMigrateResourcesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchMigrateResourcesResponse';

  /// Successfully migrated resources.
  final List<MigrateResourceResponse>? migrateResourceResponses;

  BatchMigrateResourcesResponse({this.migrateResourceResponses})
    : super(fullyQualifiedName);

  factory BatchMigrateResourcesResponse.fromJson(Map<String, dynamic> json) {
    return BatchMigrateResourcesResponse(
      migrateResourceResponses: decodeListMessage(
        json['migrateResourceResponses'],
        MigrateResourceResponse.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (migrateResourceResponses != null)
        'migrateResourceResponses': encodeList(migrateResourceResponses),
    };
  }

  @override
  String toString() => 'BatchMigrateResourcesResponse()';
}

/// Describes a successfully migrated resource.
final class MigrateResourceResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MigrateResourceResponse';

  /// Migrated Dataset's resource name.
  final String? dataset;

  /// Migrated Model's resource name.
  final String? model;

  /// Before migration, the identifier in ml.googleapis.com,
  /// automl.googleapis.com or datalabeling.googleapis.com.
  final MigratableResource? migratableResource;

  MigrateResourceResponse({this.dataset, this.model, this.migratableResource})
    : super(fullyQualifiedName);

  factory MigrateResourceResponse.fromJson(Map<String, dynamic> json) {
    return MigrateResourceResponse(
      dataset: json['dataset'],
      model: json['model'],
      migratableResource: decode(
        json['migratableResource'],
        MigratableResource.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataset != null) 'dataset': dataset,
      if (model != null) 'model': model,
      if (migratableResource != null)
        'migratableResource': migratableResource!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataset != null) 'dataset=$dataset',
      if (model != null) 'model=$model',
    ].join(',');
    return 'MigrateResourceResponse($contents)';
  }
}

/// Runtime operation information for
/// `MigrationService.BatchMigrateResources`.
final class BatchMigrateResourcesOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchMigrateResourcesOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  /// Partial results that reflect the latest migration operation progress.
  final List<BatchMigrateResourcesOperationMetadata_PartialResult>?
  partialResults;

  BatchMigrateResourcesOperationMetadata({
    this.genericMetadata,
    this.partialResults,
  }) : super(fullyQualifiedName);

  factory BatchMigrateResourcesOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchMigrateResourcesOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      partialResults: decodeListMessage(
        json['partialResults'],
        BatchMigrateResourcesOperationMetadata_PartialResult.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (partialResults != null) 'partialResults': encodeList(partialResults),
    };
  }

  @override
  String toString() => 'BatchMigrateResourcesOperationMetadata()';
}

/// Represents a partial result in batch migration operation for one
/// `MigrateResourceRequest`.
final class BatchMigrateResourcesOperationMetadata_PartialResult
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchMigrateResourcesOperationMetadata.PartialResult';

  /// The error result of the migration request in case of failure.
  final Status? error;

  /// Migrated model resource name.
  final String? model;

  /// Migrated dataset resource name.
  final String? dataset;

  /// It's the same as the value in
  /// `MigrateResourceRequest.migrate_resource_requests`.
  final MigrateResourceRequest? request;

  BatchMigrateResourcesOperationMetadata_PartialResult({
    this.error,
    this.model,
    this.dataset,
    this.request,
  }) : super(fullyQualifiedName);

  factory BatchMigrateResourcesOperationMetadata_PartialResult.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchMigrateResourcesOperationMetadata_PartialResult(
      error: decode(json['error'], Status.fromJson),
      model: json['model'],
      dataset: json['dataset'],
      request: decode(json['request'], MigrateResourceRequest.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (error != null) 'error': error!.toJson(),
      if (model != null) 'model': model,
      if (dataset != null) 'dataset': dataset,
      if (request != null) 'request': request!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (dataset != null) 'dataset=$dataset',
    ].join(',');
    return 'PartialResult($contents)';
  }
}

/// A trained machine learning Model.
final class Model extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Model';

  /// The resource name of the Model.
  final String? name;

  /// Output only. Immutable. The version ID of the model.
  /// A new version is committed when a new model version is uploaded or
  /// trained under an existing model id. It is an auto-incrementing decimal
  /// number in string representation.
  final String? versionId;

  /// User provided version aliases so that a model version can be referenced via
  /// alias (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_alias}`
  /// instead of auto-generated version id (i.e.
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id})`.
  /// The format is [a-z][a-zA-Z0-9-]{0,126}[a-z0-9] to distinguish from
  /// version_id. A default version alias will be created for the first version
  /// of the model, and there must be exactly one default version alias for a
  /// model.
  final List<String>? versionAliases;

  /// Output only. Timestamp when this version was created.
  final protobuf.Timestamp? versionCreateTime;

  /// Output only. Timestamp when this version was most recently updated.
  final protobuf.Timestamp? versionUpdateTime;

  /// Required. The display name of the Model.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// The description of the Model.
  final String? description;

  /// The description of this version.
  final String? versionDescription;

  /// The default checkpoint id of a model version.
  final String? defaultCheckpointId;

  /// The schemata that describe formats of the Model's predictions and
  /// explanations as given and returned via
  /// `PredictionService.Predict`
  /// and
  /// `PredictionService.Explain`.
  final PredictSchemata? predictSchemata;

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// additional information about the Model, that is specific to it. Unset if
  /// the Model does not have any additional information. The schema is defined
  /// as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// additional metadata is needed, this field is set to an empty string.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String? metadataSchemaUri;

  /// Immutable. An additional information about the Model; the schema of the
  /// metadata can be found in
  /// `metadata_schema`.
  /// Unset if the Model does not have any additional information.
  final protobuf.Value? metadata;

  /// Output only. The formats in which this Model may be exported. If empty,
  /// this Model is not available for export.
  final List<Model_ExportFormat>? supportedExportFormats;

  /// Output only. The resource name of the TrainingPipeline that uploaded this
  /// Model, if any.
  final String? trainingPipeline;

  /// Input only. The specification of the container that is to be used when
  /// deploying this Model. The specification is ingested upon
  /// `ModelService.UploadModel`,
  /// and all binaries it contains are copied and stored internally by Vertex AI.
  /// Not required for AutoML Models.
  final ModelContainerSpec? containerSpec;

  /// Immutable. The path to the directory containing the Model artifact and any
  /// of its supporting files. Not required for AutoML Models.
  final String? artifactUri;

  /// Output only. When this Model is deployed, its prediction resources are
  /// described by the `prediction_resources` field of the
  /// `Endpoint.deployed_models`
  /// object. Because not all Models support all resource configuration types,
  /// the configuration types this Model supports are listed here. If no
  /// configuration types are listed, the Model cannot be deployed to an
  /// `Endpoint` and does not support
  /// online predictions
  /// (`PredictionService.Predict`
  /// or
  /// `PredictionService.Explain`).
  /// Such a Model can serve predictions by using a
  /// `BatchPredictionJob`,
  /// if it has at least one entry each in
  /// `supported_input_storage_formats`
  /// and
  /// `supported_output_storage_formats`.
  final List<Model_DeploymentResourcesType>? supportedDeploymentResourcesTypes;

  /// Output only. The formats this Model supports in
  /// `BatchPredictionJob.input_config`.
  /// If
  /// `PredictSchemata.instance_schema_uri`
  /// exists, the instances should be given as per that schema.
  ///
  /// The possible formats are:
  ///
  /// * `jsonl`
  /// The JSON Lines format, where each instance is a single line. Uses
  /// `GcsSource`.
  ///
  /// * `csv`
  /// The CSV format, where each instance is a single comma-separated line.
  /// The first line in the file is the header, containing comma-separated field
  /// names. Uses
  /// `GcsSource`.
  ///
  /// * `tf-record`
  /// The TFRecord format, where each instance is a single record in tfrecord
  /// syntax. Uses
  /// `GcsSource`.
  ///
  /// * `tf-record-gzip`
  /// Similar to `tf-record`, but the file is gzipped. Uses
  /// `GcsSource`.
  ///
  /// * `bigquery`
  /// Each instance is a single row in BigQuery. Uses
  /// `BigQuerySource`.
  ///
  /// * `file-list`
  /// Each line of the file is the location of an instance to process, uses
  /// `gcs_source` field of the
  /// `InputConfig`
  /// object.
  ///
  ///
  /// If this Model doesn't support any of these formats it means it cannot be
  /// used with a
  /// `BatchPredictionJob`.
  /// However, if it has
  /// `supported_deployment_resources_types`,
  /// it could serve online predictions by using
  /// `PredictionService.Predict`
  /// or
  /// `PredictionService.Explain`.
  final List<String>? supportedInputStorageFormats;

  /// Output only. The formats this Model supports in
  /// `BatchPredictionJob.output_config`.
  /// If both
  /// `PredictSchemata.instance_schema_uri`
  /// and
  /// `PredictSchemata.prediction_schema_uri`
  /// exist, the predictions are returned together with their instances. In other
  /// words, the prediction has the original instance data first, followed by the
  /// actual prediction content (as per the schema).
  ///
  /// The possible formats are:
  ///
  /// * `jsonl`
  /// The JSON Lines format, where each prediction is a single line. Uses
  /// `GcsDestination`.
  ///
  /// * `csv`
  /// The CSV format, where each prediction is a single comma-separated line.
  /// The first line in the file is the header, containing comma-separated field
  /// names. Uses
  /// `GcsDestination`.
  ///
  /// * `bigquery`
  /// Each prediction is a single row in a BigQuery table, uses
  /// `BigQueryDestination`
  /// .
  ///
  ///
  /// If this Model doesn't support any of these formats it means it cannot be
  /// used with a
  /// `BatchPredictionJob`.
  /// However, if it has
  /// `supported_deployment_resources_types`,
  /// it could serve online predictions by using
  /// `PredictionService.Predict`
  /// or
  /// `PredictionService.Explain`.
  final List<String>? supportedOutputStorageFormats;

  /// Output only. Timestamp when this Model was uploaded into Vertex AI.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Model was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. The pointers to DeployedModels created from this Model. Note
  /// that Model could have been deployed to Endpoints in different Locations.
  final List<DeployedModelRef>? deployedModels;

  /// The default explanation specification for this Model.
  ///
  /// The Model can be used for
  /// [requesting
  /// explanation][google.cloud.aiplatform.v1beta1.PredictionService.Explain]
  /// after being
  /// `deployed` if
  /// it is populated. The Model can be used for [batch
  /// explanation][google.cloud.aiplatform.v1beta1.BatchPredictionJob.generate_explanation]
  /// if it is populated.
  ///
  /// All fields of the explanation_spec can be overridden by
  /// `explanation_spec`
  /// of
  /// `DeployModelRequest.deployed_model`,
  /// or
  /// `explanation_spec`
  /// of
  /// `BatchPredictionJob`.
  ///
  /// If the default explanation specification is not set for this Model, this
  /// Model can still be used for
  /// [requesting
  /// explanation][google.cloud.aiplatform.v1beta1.PredictionService.Explain] by
  /// setting
  /// `explanation_spec`
  /// of
  /// `DeployModelRequest.deployed_model`
  /// and for [batch
  /// explanation][google.cloud.aiplatform.v1beta1.BatchPredictionJob.generate_explanation]
  /// by setting
  /// `explanation_spec`
  /// of
  /// `BatchPredictionJob`.
  final ExplanationSpec? explanationSpec;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize your Models.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Customer-managed encryption key spec for a Model. If set, this
  /// Model and all sub-resources of this Model will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Source of a model. It can either be automl training pipeline,
  /// custom training pipeline, BigQuery ML, or saved and tuned from Genie or
  /// Model Garden.
  final ModelSourceInfo? modelSourceInfo;

  /// Output only. If this Model is a copy of another Model, this contains info
  /// about the original.
  final Model_OriginalModelInfo? originalModelInfo;

  /// Output only. The resource name of the Artifact that was created in
  /// MetadataStore when creating the Model. The Artifact resource name pattern
  /// is
  /// `projects/{project}/locations/{location}/metadataStores/{metadata_store}/artifacts/{artifact}`.
  final String? metadataArtifact;

  /// Optional. User input field to specify the base model source. Currently it
  /// only supports specifing the Model Garden models and Genie models.
  final Model_BaseModelSource? baseModelSource;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  /// Optional. Output only. The checkpoints of the model.
  final List<Checkpoint>? checkpoints;

  Model({
    this.name,
    this.versionId,
    this.versionAliases,
    this.versionCreateTime,
    this.versionUpdateTime,
    this.displayName,
    this.description,
    this.versionDescription,
    this.defaultCheckpointId,
    this.predictSchemata,
    this.metadataSchemaUri,
    this.metadata,
    this.supportedExportFormats,
    this.trainingPipeline,
    this.containerSpec,
    this.artifactUri,
    this.supportedDeploymentResourcesTypes,
    this.supportedInputStorageFormats,
    this.supportedOutputStorageFormats,
    this.createTime,
    this.updateTime,
    this.deployedModels,
    this.explanationSpec,
    this.etag,
    this.labels,
    this.encryptionSpec,
    this.modelSourceInfo,
    this.originalModelInfo,
    this.metadataArtifact,
    this.baseModelSource,
    this.satisfiesPzs,
    this.satisfiesPzi,
    this.checkpoints,
  }) : super(fullyQualifiedName);

  factory Model.fromJson(Map<String, dynamic> json) {
    return Model(
      name: json['name'],
      versionId: json['versionId'],
      versionAliases: decodeList(json['versionAliases']),
      versionCreateTime: decodeCustom(
        json['versionCreateTime'],
        protobuf.Timestamp.fromJson,
      ),
      versionUpdateTime: decodeCustom(
        json['versionUpdateTime'],
        protobuf.Timestamp.fromJson,
      ),
      displayName: json['displayName'],
      description: json['description'],
      versionDescription: json['versionDescription'],
      defaultCheckpointId: json['defaultCheckpointId'],
      predictSchemata: decode(
        json['predictSchemata'],
        PredictSchemata.fromJson,
      ),
      metadataSchemaUri: json['metadataSchemaUri'],
      metadata: decodeCustom(json['metadata'], protobuf.Value.fromJson),
      supportedExportFormats: decodeListMessage(
        json['supportedExportFormats'],
        Model_ExportFormat.fromJson,
      ),
      trainingPipeline: json['trainingPipeline'],
      containerSpec: decode(json['containerSpec'], ModelContainerSpec.fromJson),
      artifactUri: json['artifactUri'],
      supportedDeploymentResourcesTypes: decodeListEnum(
        json['supportedDeploymentResourcesTypes'],
        Model_DeploymentResourcesType.fromJson,
      ),
      supportedInputStorageFormats: decodeList(
        json['supportedInputStorageFormats'],
      ),
      supportedOutputStorageFormats: decodeList(
        json['supportedOutputStorageFormats'],
      ),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      deployedModels: decodeListMessage(
        json['deployedModels'],
        DeployedModelRef.fromJson,
      ),
      explanationSpec: decode(
        json['explanationSpec'],
        ExplanationSpec.fromJson,
      ),
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      modelSourceInfo: decode(
        json['modelSourceInfo'],
        ModelSourceInfo.fromJson,
      ),
      originalModelInfo: decode(
        json['originalModelInfo'],
        Model_OriginalModelInfo.fromJson,
      ),
      metadataArtifact: json['metadataArtifact'],
      baseModelSource: decode(
        json['baseModelSource'],
        Model_BaseModelSource.fromJson,
      ),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
      checkpoints: decodeListMessage(json['checkpoints'], Checkpoint.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (versionId != null) 'versionId': versionId,
      if (versionAliases != null) 'versionAliases': versionAliases,
      if (versionCreateTime != null)
        'versionCreateTime': versionCreateTime!.toJson(),
      if (versionUpdateTime != null)
        'versionUpdateTime': versionUpdateTime!.toJson(),
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (versionDescription != null) 'versionDescription': versionDescription,
      if (defaultCheckpointId != null)
        'defaultCheckpointId': defaultCheckpointId,
      if (predictSchemata != null) 'predictSchemata': predictSchemata!.toJson(),
      if (metadataSchemaUri != null) 'metadataSchemaUri': metadataSchemaUri,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (supportedExportFormats != null)
        'supportedExportFormats': encodeList(supportedExportFormats),
      if (trainingPipeline != null) 'trainingPipeline': trainingPipeline,
      if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
      if (artifactUri != null) 'artifactUri': artifactUri,
      if (supportedDeploymentResourcesTypes != null)
        'supportedDeploymentResourcesTypes': encodeList(
          supportedDeploymentResourcesTypes,
        ),
      if (supportedInputStorageFormats != null)
        'supportedInputStorageFormats': supportedInputStorageFormats,
      if (supportedOutputStorageFormats != null)
        'supportedOutputStorageFormats': supportedOutputStorageFormats,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (deployedModels != null) 'deployedModels': encodeList(deployedModels),
      if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (modelSourceInfo != null) 'modelSourceInfo': modelSourceInfo!.toJson(),
      if (originalModelInfo != null)
        'originalModelInfo': originalModelInfo!.toJson(),
      if (metadataArtifact != null) 'metadataArtifact': metadataArtifact,
      if (baseModelSource != null) 'baseModelSource': baseModelSource!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
      if (checkpoints != null) 'checkpoints': encodeList(checkpoints),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (versionId != null) 'versionId=$versionId',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (versionDescription != null) 'versionDescription=$versionDescription',
      if (defaultCheckpointId != null)
        'defaultCheckpointId=$defaultCheckpointId',
      if (metadataSchemaUri != null) 'metadataSchemaUri=$metadataSchemaUri',
      if (trainingPipeline != null) 'trainingPipeline=$trainingPipeline',
      if (artifactUri != null) 'artifactUri=$artifactUri',
      if (etag != null) 'etag=$etag',
      if (metadataArtifact != null) 'metadataArtifact=$metadataArtifact',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Model($contents)';
  }
}

/// Represents export format supported by the Model.
/// All formats export to Google Cloud Storage.
final class Model_ExportFormat extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Model.ExportFormat';

  /// Output only. The ID of the export format.
  /// The possible format IDs are:
  ///
  /// * `tflite`
  /// Used for Android mobile devices.
  ///
  /// * `edgetpu-tflite`
  /// Used for [Edge TPU](https://cloud.google.com/edge-tpu/) devices.
  ///
  /// * `tf-saved-model`
  /// A tensorflow model in SavedModel format.
  ///
  /// * `tf-js`
  /// A [TensorFlow.js](https://www.tensorflow.org/js) model that can be used
  /// in the browser and in Node.js using JavaScript.
  ///
  /// * `core-ml`
  /// Used for iOS mobile devices.
  ///
  /// * `custom-trained`
  /// A Model that was uploaded or trained by custom code.
  final String? id;

  /// Output only. The content of this Model that may be exported.
  final List<Model_ExportFormat_ExportableContent>? exportableContents;

  Model_ExportFormat({this.id, this.exportableContents})
    : super(fullyQualifiedName);

  factory Model_ExportFormat.fromJson(Map<String, dynamic> json) {
    return Model_ExportFormat(
      id: json['id'],
      exportableContents: decodeListEnum(
        json['exportableContents'],
        Model_ExportFormat_ExportableContent.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (exportableContents != null)
        'exportableContents': encodeList(exportableContents),
    };
  }

  @override
  String toString() {
    final contents = [if (id != null) 'id=$id'].join(',');
    return 'ExportFormat($contents)';
  }
}

/// The Model content that can be exported.
final class Model_ExportFormat_ExportableContent extends protobuf.ProtoEnum {
  /// Should not be used.
  static const exportableContentUnspecified =
      Model_ExportFormat_ExportableContent('EXPORTABLE_CONTENT_UNSPECIFIED');

  /// Model artifact and any of its supported files. Will be exported to the
  /// location specified by the `artifactDestination` field of the
  /// `ExportModelRequest.output_config`
  /// object.
  static const artifact = Model_ExportFormat_ExportableContent('ARTIFACT');

  /// The container image that is to be used when deploying this Model. Will
  /// be exported to the location specified by the `imageDestination` field
  /// of the
  /// `ExportModelRequest.output_config`
  /// object.
  static const image = Model_ExportFormat_ExportableContent('IMAGE');

  const Model_ExportFormat_ExportableContent(super.value);

  factory Model_ExportFormat_ExportableContent.fromJson(String json) =>
      Model_ExportFormat_ExportableContent(json);

  @override
  String toString() => 'ExportableContent.$value';
}

/// Contains information about the original Model if this Model is a copy.
final class Model_OriginalModelInfo extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Model.OriginalModelInfo';

  /// Output only. The resource name of the Model this Model is a copy of,
  /// including the revision. Format:
  /// `projects/{project}/locations/{location}/models/{model_id}@{version_id}`
  final String? model;

  Model_OriginalModelInfo({this.model}) : super(fullyQualifiedName);

  factory Model_OriginalModelInfo.fromJson(Map<String, dynamic> json) {
    return Model_OriginalModelInfo(model: json['model']);
  }

  @override
  Object toJson() {
    return {if (model != null) 'model': model};
  }

  @override
  String toString() {
    final contents = [if (model != null) 'model=$model'].join(',');
    return 'OriginalModelInfo($contents)';
  }
}

/// User input field to specify the base model source. Currently it only
/// supports specifing the Model Garden models and Genie models.
final class Model_BaseModelSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Model.BaseModelSource';

  /// Source information of Model Garden models.
  final ModelGardenSource? modelGardenSource;

  /// Information about the base model of Genie models.
  final GenieSource? genieSource;

  Model_BaseModelSource({this.modelGardenSource, this.genieSource})
    : super(fullyQualifiedName);

  factory Model_BaseModelSource.fromJson(Map<String, dynamic> json) {
    return Model_BaseModelSource(
      modelGardenSource: decode(
        json['modelGardenSource'],
        ModelGardenSource.fromJson,
      ),
      genieSource: decode(json['genieSource'], GenieSource.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (modelGardenSource != null)
        'modelGardenSource': modelGardenSource!.toJson(),
      if (genieSource != null) 'genieSource': genieSource!.toJson(),
    };
  }

  @override
  String toString() => 'BaseModelSource()';
}

/// Identifies a type of Model's prediction resources.
final class Model_DeploymentResourcesType extends protobuf.ProtoEnum {
  /// Should not be used.
  static const deploymentResourcesTypeUnspecified =
      Model_DeploymentResourcesType('DEPLOYMENT_RESOURCES_TYPE_UNSPECIFIED');

  /// Resources that are dedicated to the
  /// `DeployedModel`, and that
  /// need a higher degree of manual configuration.
  static const dedicatedResources = Model_DeploymentResourcesType(
    'DEDICATED_RESOURCES',
  );

  /// Resources that to large degree are decided by Vertex AI, and require
  /// only a modest additional configuration.
  static const automaticResources = Model_DeploymentResourcesType(
    'AUTOMATIC_RESOURCES',
  );

  /// Resources that can be shared by multiple
  /// `DeployedModels`. A
  /// pre-configured
  /// `DeploymentResourcePool`
  /// is required.
  static const sharedResources = Model_DeploymentResourcesType(
    'SHARED_RESOURCES',
  );

  const Model_DeploymentResourcesType(super.value);

  factory Model_DeploymentResourcesType.fromJson(String json) =>
      Model_DeploymentResourcesType(json);

  @override
  String toString() => 'DeploymentResourcesType.$value';
}

/// Contains information about the Large Model.
final class LargeModelReference extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LargeModelReference';

  /// Required. The unique name of the large Foundation or pre-built model. Like
  /// "chat-bison", "text-bison". Or model name with version ID, like
  /// "chat-bison@001", "text-bison@005", etc.
  final String? name;

  LargeModelReference({this.name}) : super(fullyQualifiedName);

  factory LargeModelReference.fromJson(Map<String, dynamic> json) {
    return LargeModelReference(name: json['name']);
  }

  @override
  Object toJson() {
    return {if (name != null) 'name': name};
  }

  @override
  String toString() {
    final contents = [if (name != null) 'name=$name'].join(',');
    return 'LargeModelReference($contents)';
  }
}

/// Contains information about the source of the models generated from Model
/// Garden.
final class ModelGardenSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelGardenSource';

  /// Required. The model garden source model resource name.
  final String? publicModelName;

  /// Optional. The model garden source model version ID.
  final String? versionId;

  /// Optional. Whether to avoid pulling the model from the HF cache.
  final bool? skipHfModelCache;

  ModelGardenSource({
    this.publicModelName,
    this.versionId,
    this.skipHfModelCache,
  }) : super(fullyQualifiedName);

  factory ModelGardenSource.fromJson(Map<String, dynamic> json) {
    return ModelGardenSource(
      publicModelName: json['publicModelName'],
      versionId: json['versionId'],
      skipHfModelCache: json['skipHfModelCache'],
    );
  }

  @override
  Object toJson() {
    return {
      if (publicModelName != null) 'publicModelName': publicModelName,
      if (versionId != null) 'versionId': versionId,
      if (skipHfModelCache != null) 'skipHfModelCache': skipHfModelCache,
    };
  }

  @override
  String toString() {
    final contents = [
      if (publicModelName != null) 'publicModelName=$publicModelName',
      if (versionId != null) 'versionId=$versionId',
      if (skipHfModelCache != null) 'skipHfModelCache=$skipHfModelCache',
    ].join(',');
    return 'ModelGardenSource($contents)';
  }
}

/// Contains information about the source of the models generated from Generative
/// AI Studio.
final class GenieSource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenieSource';

  /// Required. The public base model URI.
  final String? baseModelUri;

  GenieSource({this.baseModelUri}) : super(fullyQualifiedName);

  factory GenieSource.fromJson(Map<String, dynamic> json) {
    return GenieSource(baseModelUri: json['baseModelUri']);
  }

  @override
  Object toJson() {
    return {if (baseModelUri != null) 'baseModelUri': baseModelUri};
  }

  @override
  String toString() {
    final contents = [
      if (baseModelUri != null) 'baseModelUri=$baseModelUri',
    ].join(',');
    return 'GenieSource($contents)';
  }
}

/// Contains the schemata used in Model's predictions and explanations via
/// `PredictionService.Predict`,
/// `PredictionService.Explain`
/// and `BatchPredictionJob`.
final class PredictSchemata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictSchemata';

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the format of a single instance, which are used in
  /// `PredictRequest.instances`,
  /// `ExplainRequest.instances`
  /// and
  /// `BatchPredictionJob.input_config`.
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String? instanceSchemaUri;

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the parameters of prediction and explanation via
  /// `PredictRequest.parameters`,
  /// `ExplainRequest.parameters`
  /// and
  /// `BatchPredictionJob.model_parameters`.
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI, if no
  /// parameters are supported, then it is set to an empty string.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String? parametersSchemaUri;

  /// Immutable. Points to a YAML file stored on Google Cloud Storage describing
  /// the format of a single prediction produced by this Model, which are
  /// returned via
  /// `PredictResponse.predictions`,
  /// `ExplainResponse.explanations`,
  /// and
  /// `BatchPredictionJob.output_config`.
  /// The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// AutoML Models always have this field populated by Vertex AI.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String? predictionSchemaUri;

  PredictSchemata({
    this.instanceSchemaUri,
    this.parametersSchemaUri,
    this.predictionSchemaUri,
  }) : super(fullyQualifiedName);

  factory PredictSchemata.fromJson(Map<String, dynamic> json) {
    return PredictSchemata(
      instanceSchemaUri: json['instanceSchemaUri'],
      parametersSchemaUri: json['parametersSchemaUri'],
      predictionSchemaUri: json['predictionSchemaUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (instanceSchemaUri != null) 'instanceSchemaUri': instanceSchemaUri,
      if (parametersSchemaUri != null)
        'parametersSchemaUri': parametersSchemaUri,
      if (predictionSchemaUri != null)
        'predictionSchemaUri': predictionSchemaUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (instanceSchemaUri != null) 'instanceSchemaUri=$instanceSchemaUri',
      if (parametersSchemaUri != null)
        'parametersSchemaUri=$parametersSchemaUri',
      if (predictionSchemaUri != null)
        'predictionSchemaUri=$predictionSchemaUri',
    ].join(',');
    return 'PredictSchemata($contents)';
  }
}

/// Specification of a container for serving predictions. Some fields in this
/// message correspond to fields in the [Kubernetes Container v1 core
/// specification](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
final class ModelContainerSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelContainerSpec';

  /// Required. Immutable. URI of the Docker image to be used as the custom
  /// container for serving predictions. This URI must identify an image in
  /// Artifact Registry or Container Registry. Learn more about the [container
  /// publishing
  /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#publishing),
  /// including permissions requirements for the Vertex AI Service Agent.
  ///
  /// The container image is ingested upon
  /// `ModelService.UploadModel`,
  /// stored internally, and this original path is afterwards not used.
  ///
  /// To learn about the requirements for the Docker image itself, see
  /// [Custom container
  /// requirements](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#).
  ///
  /// You can use the URI to one of Vertex AI's [pre-built container images for
  /// prediction](https://cloud.google.com/vertex-ai/docs/predictions/pre-built-containers)
  /// in this field.
  final String? imageUri;

  /// Immutable. Specifies the command that runs when the container starts. This
  /// overrides the container's
  /// [ENTRYPOINT](https://docs.docker.com/engine/reference/builder/#entrypoint).
  /// Specify this field as an array of executable and arguments, similar to a
  /// Docker `ENTRYPOINT`'s "exec" form, not its "shell" form.
  ///
  /// If you do not specify this field, then the container's `ENTRYPOINT` runs,
  /// in conjunction with the
  /// `args` field or
  /// the container's
  /// [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd), if either
  /// exists. If this field is not specified and the container does not have an
  /// `ENTRYPOINT`, then refer to the Docker documentation about [how `CMD` and
  /// `ENTRYPOINT`
  /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  ///
  /// If you specify this field, then you can also specify the `args` field to
  /// provide additional arguments for this command. However, if you specify this
  /// field, then the container's `CMD` is ignored. See the
  /// [Kubernetes documentation about how the
  /// `command` and `args` fields interact with a container's `ENTRYPOINT` and
  /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  ///
  /// In this field, you can reference [environment variables set by Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the
  /// `env` field. You
  /// cannot reference environment variables set in the Docker image. In order
  /// for environment variables to be expanded, reference them by using the
  /// following syntax:
  /// <code>$(<var>VARIABLE_NAME</var>)</code>
  /// Note that this differs from Bash variable expansion, which does not use
  /// parentheses. If a variable cannot be resolved, the reference in the input
  /// string is used unchanged. To avoid variable expansion, you can escape this
  /// syntax with `$$`; for example:
  /// <code>$$(<var>VARIABLE_NAME</var>)</code>
  /// This field corresponds to the `command` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  final List<String>? command;

  /// Immutable. Specifies arguments for the command that runs when the container
  /// starts. This overrides the container's
  /// [`CMD`](https://docs.docker.com/engine/reference/builder/#cmd). Specify
  /// this field as an array of executable and arguments, similar to a Docker
  /// `CMD`'s "default parameters" form.
  ///
  /// If you don't specify this field but do specify the
  /// `command`
  /// field, then the command from the `command` field runs without any
  /// additional arguments. See the [Kubernetes documentation about how the
  /// `command` and `args` fields interact with a container's `ENTRYPOINT` and
  /// `CMD`](https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/#notes).
  ///
  /// If you don't specify this field and don't specify the `command` field,
  /// then the container's
  /// [`ENTRYPOINT`](https://docs.docker.com/engine/reference/builder/#cmd) and
  /// `CMD` determine what runs based on their default behavior. See the Docker
  /// documentation about [how `CMD` and `ENTRYPOINT`
  /// interact](https://docs.docker.com/engine/reference/builder/#understand-how-cmd-and-entrypoint-interact).
  ///
  /// In this field, you can reference [environment variables
  /// set by Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables)
  /// and environment variables set in the
  /// `env` field. You
  /// cannot reference environment variables set in the Docker image. In order
  /// for environment variables to be expanded, reference them by using the
  /// following syntax:
  /// <code>$(<var>VARIABLE_NAME</var>)</code>
  /// Note that this differs from Bash variable expansion, which does not use
  /// parentheses. If a variable cannot be resolved, the reference in the input
  /// string is used unchanged. To avoid variable expansion, you can escape this
  /// syntax with `$$`; for example:
  /// <code>$$(<var>VARIABLE_NAME</var>)</code>
  /// This field corresponds to the `args` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  final List<String>? args;

  /// Immutable. List of environment variables to set in the container. After the
  /// container starts running, code running in the container can read these
  /// environment variables.
  ///
  /// Additionally, the
  /// `command` and
  /// `args` fields can
  /// reference these variables. Later entries in this list can also reference
  /// earlier entries. For example, the following example sets the variable
  /// `VAR_2` to have the value `foo bar`:
  ///
  /// ```json
  /// [
  ///   {
  ///     "name": "VAR_1",
  ///     "value": "foo"
  ///   },
  ///   {
  ///     "name": "VAR_2",
  ///     "value": "$(VAR_1) bar"
  ///   }
  /// ]
  /// ```
  ///
  /// If you switch the order of the variables in the example, then the expansion
  /// does not occur.
  ///
  /// This field corresponds to the `env` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  final List<EnvVar>? env;

  /// Immutable. List of ports to expose from the container. Vertex AI sends any
  /// prediction requests that it receives to the first port on this list. Vertex
  /// AI also sends
  /// [liveness and health
  /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#liveness)
  /// to this port.
  ///
  /// If you do not specify this field, it defaults to following value:
  ///
  /// ```json
  /// [
  ///   {
  ///     "containerPort": 8080
  ///   }
  /// ]
  /// ```
  ///
  /// Vertex AI does not use ports other than the first one listed. This field
  /// corresponds to the `ports` field of the Kubernetes Containers
  /// [v1 core
  /// API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#container-v1-core).
  final List<Port>? ports;

  /// Immutable. HTTP path on the container to send prediction requests to.
  /// Vertex AI forwards requests sent using
  /// `projects.locations.endpoints.predict`
  /// to this path on the container's IP address and port. Vertex AI then returns
  /// the container's response in the API response.
  ///
  /// For example, if you set this field to `/foo`, then when Vertex AI
  /// receives a prediction request, it forwards the request body in a POST
  /// request to the `/foo` path on the port of your container specified by the
  /// first value of this `ModelContainerSpec`'s
  /// `ports` field.
  ///
  /// If you don't specify this field, it defaults to the following value when
  /// you [deploy this Model to an
  /// Endpoint][google.cloud.aiplatform.v1beta1.EndpointService.DeployModel]:
  /// <code>/v1/endpoints/<var>ENDPOINT</var>/deployedModels/<var>DEPLOYED_MODEL</var>:predict</code>
  /// The placeholders in this value are replaced as follows:
  ///
  /// * <var>ENDPOINT</var>: The last segment (following `endpoints/`)of the
  ///   Endpoint.name][] field of the Endpoint where this Model has been
  ///   deployed. (Vertex AI makes this value available to your container code
  ///   as the [`AIP_ENDPOINT_ID` environment
  ///  variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// * <var>DEPLOYED_MODEL</var>:
  /// `DeployedModel.id` of the
  /// `DeployedModel`.
  ///   (Vertex AI makes this value available to your container code
  ///   as the [`AIP_DEPLOYED_MODEL_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  final String? predictRoute;

  /// Immutable. HTTP path on the container to send health checks to. Vertex AI
  /// intermittently sends GET requests to this path on the container's IP
  /// address and port to check that the container is healthy. Read more about
  /// [health
  /// checks](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#health).
  ///
  /// For example, if you set this field to `/bar`, then Vertex AI
  /// intermittently sends a GET request to the `/bar` path on the port of your
  /// container specified by the first value of this `ModelContainerSpec`'s
  /// `ports` field.
  ///
  /// If you don't specify this field, it defaults to the following value when
  /// you [deploy this Model to an
  /// Endpoint][google.cloud.aiplatform.v1beta1.EndpointService.DeployModel]:
  /// <code>/v1/endpoints/<var>ENDPOINT</var>/deployedModels/<var>DEPLOYED_MODEL</var>:predict</code>
  /// The placeholders in this value are replaced as follows:
  ///
  /// * <var>ENDPOINT</var>: The last segment (following `endpoints/`)of the
  ///   Endpoint.name][] field of the Endpoint where this Model has been
  ///   deployed. (Vertex AI makes this value available to your container code
  ///   as the [`AIP_ENDPOINT_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  ///
  /// * <var>DEPLOYED_MODEL</var>:
  /// `DeployedModel.id` of the
  /// `DeployedModel`.
  ///   (Vertex AI makes this value available to your container code as the
  ///   [`AIP_DEPLOYED_MODEL_ID` environment
  ///   variable](https://cloud.google.com/vertex-ai/docs/predictions/custom-container-requirements#aip-variables).)
  final String? healthRoute;

  /// Immutable. Invoke route prefix for the custom container. "/*" is the only
  /// supported value right now. By setting this field, any non-root route on
  /// this model will be accessible with [PredictionService.Invoke] eg:
  /// "/invoke/foo/bar".
  ///
  /// Only one of `predict_route` or `invoke_route_prefix` can be set, and we
  /// default to using `predict_route` if this field is not set. If this field
  /// is set, the Model can only be deployed to dedicated endpoint.
  final String? invokeRoutePrefix;

  /// Immutable. List of ports to expose from the container. Vertex AI sends gRPC
  /// prediction requests that it receives to the first port on this list. Vertex
  /// AI also sends liveness and health checks to this port.
  ///
  /// If you do not specify this field, gRPC requests to the container will be
  /// disabled.
  ///
  /// Vertex AI does not use ports other than the first one listed. This field
  /// corresponds to the `ports` field of the Kubernetes Containers v1 core API.
  final List<Port>? grpcPorts;

  /// Immutable. Deployment timeout.
  /// Limit for deployment timeout is 2 hours.
  final protobuf.Duration? deploymentTimeout;

  /// Immutable. The amount of the VM memory to reserve as the shared memory for
  /// the model in megabytes.
  final int? sharedMemorySizeMb;

  /// Immutable. Specification for Kubernetes startup probe.
  final Probe? startupProbe;

  /// Immutable. Specification for Kubernetes readiness probe.
  final Probe? healthProbe;

  /// Immutable. Specification for Kubernetes liveness probe.
  final Probe? livenessProbe;

  ModelContainerSpec({
    this.imageUri,
    this.command,
    this.args,
    this.env,
    this.ports,
    this.predictRoute,
    this.healthRoute,
    this.invokeRoutePrefix,
    this.grpcPorts,
    this.deploymentTimeout,
    this.sharedMemorySizeMb,
    this.startupProbe,
    this.healthProbe,
    this.livenessProbe,
  }) : super(fullyQualifiedName);

  factory ModelContainerSpec.fromJson(Map<String, dynamic> json) {
    return ModelContainerSpec(
      imageUri: json['imageUri'],
      command: decodeList(json['command']),
      args: decodeList(json['args']),
      env: decodeListMessage(json['env'], EnvVar.fromJson),
      ports: decodeListMessage(json['ports'], Port.fromJson),
      predictRoute: json['predictRoute'],
      healthRoute: json['healthRoute'],
      invokeRoutePrefix: json['invokeRoutePrefix'],
      grpcPorts: decodeListMessage(json['grpcPorts'], Port.fromJson),
      deploymentTimeout: decodeCustom(
        json['deploymentTimeout'],
        protobuf.Duration.fromJson,
      ),
      sharedMemorySizeMb: decodeInt64(json['sharedMemorySizeMb']),
      startupProbe: decode(json['startupProbe'], Probe.fromJson),
      healthProbe: decode(json['healthProbe'], Probe.fromJson),
      livenessProbe: decode(json['livenessProbe'], Probe.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (imageUri != null) 'imageUri': imageUri,
      if (command != null) 'command': command,
      if (args != null) 'args': args,
      if (env != null) 'env': encodeList(env),
      if (ports != null) 'ports': encodeList(ports),
      if (predictRoute != null) 'predictRoute': predictRoute,
      if (healthRoute != null) 'healthRoute': healthRoute,
      if (invokeRoutePrefix != null) 'invokeRoutePrefix': invokeRoutePrefix,
      if (grpcPorts != null) 'grpcPorts': encodeList(grpcPorts),
      if (deploymentTimeout != null)
        'deploymentTimeout': deploymentTimeout!.toJson(),
      if (sharedMemorySizeMb != null)
        'sharedMemorySizeMb': encodeInt64(sharedMemorySizeMb),
      if (startupProbe != null) 'startupProbe': startupProbe!.toJson(),
      if (healthProbe != null) 'healthProbe': healthProbe!.toJson(),
      if (livenessProbe != null) 'livenessProbe': livenessProbe!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (imageUri != null) 'imageUri=$imageUri',
      if (predictRoute != null) 'predictRoute=$predictRoute',
      if (healthRoute != null) 'healthRoute=$healthRoute',
      if (invokeRoutePrefix != null) 'invokeRoutePrefix=$invokeRoutePrefix',
      if (sharedMemorySizeMb != null) 'sharedMemorySizeMb=$sharedMemorySizeMb',
    ].join(',');
    return 'ModelContainerSpec($contents)';
  }
}

/// Represents a network port in a container.
final class Port extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Port';

  /// The number of the port to expose on the pod's IP address.
  /// Must be a valid port number, between 1 and 65535 inclusive.
  final int? containerPort;

  Port({this.containerPort}) : super(fullyQualifiedName);

  factory Port.fromJson(Map<String, dynamic> json) {
    return Port(containerPort: json['containerPort']);
  }

  @override
  Object toJson() {
    return {if (containerPort != null) 'containerPort': containerPort};
  }

  @override
  String toString() {
    final contents = [
      if (containerPort != null) 'containerPort=$containerPort',
    ].join(',');
    return 'Port($contents)';
  }
}

/// Detail description of the source information of the model.
final class ModelSourceInfo extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelSourceInfo';

  /// Type of the model source.
  final ModelSourceInfo_ModelSourceType? sourceType;

  /// If this Model is copy of another Model. If true then
  /// `source_type`
  /// pertains to the original.
  final bool? copy;

  ModelSourceInfo({this.sourceType, this.copy}) : super(fullyQualifiedName);

  factory ModelSourceInfo.fromJson(Map<String, dynamic> json) {
    return ModelSourceInfo(
      sourceType: decodeEnum(
        json['sourceType'],
        ModelSourceInfo_ModelSourceType.fromJson,
      ),
      copy: json['copy'],
    );
  }

  @override
  Object toJson() {
    return {
      if (sourceType != null) 'sourceType': sourceType!.toJson(),
      if (copy != null) 'copy': copy,
    };
  }

  @override
  String toString() {
    final contents = [
      if (sourceType != null) 'sourceType=$sourceType',
      if (copy != null) 'copy=$copy',
    ].join(',');
    return 'ModelSourceInfo($contents)';
  }
}

/// Source of the model.
/// Different from `objective` field, this `ModelSourceType` enum
/// indicates the source from which the model was accessed or obtained,
/// whereas the `objective` indicates the overall aim or function of this
/// model.
final class ModelSourceInfo_ModelSourceType extends protobuf.ProtoEnum {
  /// Should not be used.
  static const modelSourceTypeUnspecified = ModelSourceInfo_ModelSourceType(
    'MODEL_SOURCE_TYPE_UNSPECIFIED',
  );

  /// The Model is uploaded by automl training pipeline.
  static const automl = ModelSourceInfo_ModelSourceType('AUTOML');

  /// The Model is uploaded by user or custom training pipeline.
  static const custom = ModelSourceInfo_ModelSourceType('CUSTOM');

  /// The Model is registered and sync'ed from BigQuery ML.
  static const bqml = ModelSourceInfo_ModelSourceType('BQML');

  /// The Model is saved or tuned from Model Garden.
  static const modelGarden = ModelSourceInfo_ModelSourceType('MODEL_GARDEN');

  /// The Model is saved or tuned from Genie.
  static const genie = ModelSourceInfo_ModelSourceType('GENIE');

  /// The Model is uploaded by text embedding finetuning pipeline.
  static const customTextEmbedding = ModelSourceInfo_ModelSourceType(
    'CUSTOM_TEXT_EMBEDDING',
  );

  /// The Model is saved or tuned from Marketplace.
  static const marketplace = ModelSourceInfo_ModelSourceType('MARKETPLACE');

  const ModelSourceInfo_ModelSourceType(super.value);

  factory ModelSourceInfo_ModelSourceType.fromJson(String json) =>
      ModelSourceInfo_ModelSourceType(json);

  @override
  String toString() => 'ModelSourceType.$value';
}

/// Probe describes a health check to be performed against a container to
/// determine whether it is alive or ready to receive traffic.
final class Probe extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe';

  /// ExecAction probes the health of a container by executing a command.
  final Probe_ExecAction? exec;

  /// HttpGetAction probes the health of a container by sending an HTTP GET
  /// request.
  final Probe_HttpGetAction? httpGet;

  /// GrpcAction probes the health of a container by sending a gRPC request.
  final Probe_GrpcAction? grpc;

  /// TcpSocketAction probes the health of a container by opening a TCP socket
  /// connection.
  final Probe_TcpSocketAction? tcpSocket;

  /// How often (in seconds) to perform the probe. Default to 10 seconds.
  /// Minimum value is 1. Must be less than timeout_seconds.
  ///
  /// Maps to Kubernetes probe argument 'periodSeconds'.
  final int? periodSeconds;

  /// Number of seconds after which the probe times out. Defaults to 1 second.
  /// Minimum value is 1. Must be greater or equal to period_seconds.
  ///
  /// Maps to Kubernetes probe argument 'timeoutSeconds'.
  final int? timeoutSeconds;

  /// Number of consecutive failures before the probe is considered failed.
  /// Defaults to 3. Minimum value is 1.
  ///
  /// Maps to Kubernetes probe argument 'failureThreshold'.
  final int? failureThreshold;

  /// Number of consecutive successes before the probe is considered successful.
  /// Defaults to 1. Minimum value is 1.
  ///
  /// Maps to Kubernetes probe argument 'successThreshold'.
  final int? successThreshold;

  /// Number of seconds to wait before starting the probe. Defaults to 0.
  /// Minimum value is 0.
  ///
  /// Maps to Kubernetes probe argument 'initialDelaySeconds'.
  final int? initialDelaySeconds;

  Probe({
    this.exec,
    this.httpGet,
    this.grpc,
    this.tcpSocket,
    this.periodSeconds,
    this.timeoutSeconds,
    this.failureThreshold,
    this.successThreshold,
    this.initialDelaySeconds,
  }) : super(fullyQualifiedName);

  factory Probe.fromJson(Map<String, dynamic> json) {
    return Probe(
      exec: decode(json['exec'], Probe_ExecAction.fromJson),
      httpGet: decode(json['httpGet'], Probe_HttpGetAction.fromJson),
      grpc: decode(json['grpc'], Probe_GrpcAction.fromJson),
      tcpSocket: decode(json['tcpSocket'], Probe_TcpSocketAction.fromJson),
      periodSeconds: json['periodSeconds'],
      timeoutSeconds: json['timeoutSeconds'],
      failureThreshold: json['failureThreshold'],
      successThreshold: json['successThreshold'],
      initialDelaySeconds: json['initialDelaySeconds'],
    );
  }

  @override
  Object toJson() {
    return {
      if (exec != null) 'exec': exec!.toJson(),
      if (httpGet != null) 'httpGet': httpGet!.toJson(),
      if (grpc != null) 'grpc': grpc!.toJson(),
      if (tcpSocket != null) 'tcpSocket': tcpSocket!.toJson(),
      if (periodSeconds != null) 'periodSeconds': periodSeconds,
      if (timeoutSeconds != null) 'timeoutSeconds': timeoutSeconds,
      if (failureThreshold != null) 'failureThreshold': failureThreshold,
      if (successThreshold != null) 'successThreshold': successThreshold,
      if (initialDelaySeconds != null)
        'initialDelaySeconds': initialDelaySeconds,
    };
  }

  @override
  String toString() {
    final contents = [
      if (periodSeconds != null) 'periodSeconds=$periodSeconds',
      if (timeoutSeconds != null) 'timeoutSeconds=$timeoutSeconds',
      if (failureThreshold != null) 'failureThreshold=$failureThreshold',
      if (successThreshold != null) 'successThreshold=$successThreshold',
      if (initialDelaySeconds != null)
        'initialDelaySeconds=$initialDelaySeconds',
    ].join(',');
    return 'Probe($contents)';
  }
}

/// ExecAction specifies a command to execute.
final class Probe_ExecAction extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.ExecAction';

  /// Command is the command line to execute inside the container, the working
  /// directory for the command is root ('/') in the container's filesystem.
  /// The command is simply exec'd, it is not run inside a shell, so
  /// traditional shell instructions ('|', etc) won't work. To use a shell, you
  /// need to explicitly call out to that shell. Exit status of 0 is treated as
  /// live/healthy and non-zero is unhealthy.
  final List<String>? command;

  Probe_ExecAction({this.command}) : super(fullyQualifiedName);

  factory Probe_ExecAction.fromJson(Map<String, dynamic> json) {
    return Probe_ExecAction(command: decodeList(json['command']));
  }

  @override
  Object toJson() {
    return {if (command != null) 'command': command};
  }

  @override
  String toString() => 'ExecAction()';
}

/// HttpGetAction describes an action based on HTTP Get requests.
final class Probe_HttpGetAction extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.HttpGetAction';

  /// Path to access on the HTTP server.
  final String? path;

  /// Number of the port to access on the container.
  /// Number must be in the range 1 to 65535.
  final int? port;

  /// Host name to connect to, defaults to the model serving container's IP.
  /// You probably want to set "Host" in httpHeaders instead.
  final String? host;

  /// Scheme to use for connecting to the host.
  /// Defaults to HTTP. Acceptable values are "HTTP" or "HTTPS".
  final String? scheme;

  /// Custom headers to set in the request. HTTP allows repeated headers.
  final List<Probe_HttpHeader>? httpHeaders;

  Probe_HttpGetAction({
    this.path,
    this.port,
    this.host,
    this.scheme,
    this.httpHeaders,
  }) : super(fullyQualifiedName);

  factory Probe_HttpGetAction.fromJson(Map<String, dynamic> json) {
    return Probe_HttpGetAction(
      path: json['path'],
      port: json['port'],
      host: json['host'],
      scheme: json['scheme'],
      httpHeaders: decodeListMessage(
        json['httpHeaders'],
        Probe_HttpHeader.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (path != null) 'path': path,
      if (port != null) 'port': port,
      if (host != null) 'host': host,
      if (scheme != null) 'scheme': scheme,
      if (httpHeaders != null) 'httpHeaders': encodeList(httpHeaders),
    };
  }

  @override
  String toString() {
    final contents = [
      if (path != null) 'path=$path',
      if (port != null) 'port=$port',
      if (host != null) 'host=$host',
      if (scheme != null) 'scheme=$scheme',
    ].join(',');
    return 'HttpGetAction($contents)';
  }
}

/// GrpcAction checks the health of a container using a gRPC service.
final class Probe_GrpcAction extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.GrpcAction';

  /// Port number of the gRPC service. Number must be in the range 1 to 65535.
  final int? port;

  /// Service is the name of the service to place in the gRPC
  /// HealthCheckRequest (see
  /// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
  ///
  /// If this is not specified, the default behavior is defined by gRPC.
  final String? service;

  Probe_GrpcAction({this.port, this.service}) : super(fullyQualifiedName);

  factory Probe_GrpcAction.fromJson(Map<String, dynamic> json) {
    return Probe_GrpcAction(port: json['port'], service: json['service']);
  }

  @override
  Object toJson() {
    return {
      if (port != null) 'port': port,
      if (service != null) 'service': service,
    };
  }

  @override
  String toString() {
    final contents = [
      if (port != null) 'port=$port',
      if (service != null) 'service=$service',
    ].join(',');
    return 'GrpcAction($contents)';
  }
}

/// TcpSocketAction probes the health of a container by opening a TCP socket
/// connection.
final class Probe_TcpSocketAction extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.TcpSocketAction';

  /// Number of the port to access on the container.
  /// Number must be in the range 1 to 65535.
  final int? port;

  /// Optional: Host name to connect to, defaults to the model serving
  /// container's IP.
  final String? host;

  Probe_TcpSocketAction({this.port, this.host}) : super(fullyQualifiedName);

  factory Probe_TcpSocketAction.fromJson(Map<String, dynamic> json) {
    return Probe_TcpSocketAction(port: json['port'], host: json['host']);
  }

  @override
  Object toJson() {
    return {if (port != null) 'port': port, if (host != null) 'host': host};
  }

  @override
  String toString() {
    final contents = [
      if (port != null) 'port=$port',
      if (host != null) 'host=$host',
    ].join(',');
    return 'TcpSocketAction($contents)';
  }
}

/// HttpHeader describes a custom header to be used in HTTP probes
final class Probe_HttpHeader extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Probe.HttpHeader';

  /// The header field name.
  /// This will be canonicalized upon output, so case-variant names will be
  /// understood as the same header.
  final String? name;

  /// The header field value
  final String? value;

  Probe_HttpHeader({this.name, this.value}) : super(fullyQualifiedName);

  factory Probe_HttpHeader.fromJson(Map<String, dynamic> json) {
    return Probe_HttpHeader(name: json['name'], value: json['value']);
  }

  @override
  Object toJson() {
    return {if (name != null) 'name': name, if (value != null) 'value': value};
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (value != null) 'value=$value',
    ].join(',');
    return 'HttpHeader($contents)';
  }
}

/// Describes the machine learning model version checkpoint.
final class Checkpoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Checkpoint';

  /// The ID of the checkpoint.
  final String? checkpointId;

  /// The epoch of the checkpoint.
  final int? epoch;

  /// The step of the checkpoint.
  final int? step;

  Checkpoint({this.checkpointId, this.epoch, this.step})
    : super(fullyQualifiedName);

  factory Checkpoint.fromJson(Map<String, dynamic> json) {
    return Checkpoint(
      checkpointId: json['checkpointId'],
      epoch: decodeInt64(json['epoch']),
      step: decodeInt64(json['step']),
    );
  }

  @override
  Object toJson() {
    return {
      if (checkpointId != null) 'checkpointId': checkpointId,
      if (epoch != null) 'epoch': encodeInt64(epoch),
      if (step != null) 'step': encodeInt64(step),
    };
  }

  @override
  String toString() {
    final contents = [
      if (checkpointId != null) 'checkpointId=$checkpointId',
      if (epoch != null) 'epoch=$epoch',
      if (step != null) 'step=$step',
    ].join(',');
    return 'Checkpoint($contents)';
  }
}

/// Represents a job that runs periodically to monitor the deployed models in an
/// endpoint. It will analyze the logged training & prediction data to detect any
/// abnormal behaviors.
final class ModelDeploymentMonitoringJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringJob';

  /// Output only. Resource name of a ModelDeploymentMonitoringJob.
  final String? name;

  /// Required. The user-defined name of the ModelDeploymentMonitoringJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  /// Display name of a ModelDeploymentMonitoringJob.
  final String? displayName;

  /// Required. Endpoint resource name.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? endpoint;

  /// Output only. The detailed state of the monitoring job.
  /// When the job is still creating, the state will be 'PENDING'.
  /// Once the job is successfully created, the state will be 'RUNNING'.
  /// Pause the job, the state will be 'PAUSED'.
  /// Resume the job, the state will return to 'RUNNING'.
  final JobState? state;

  /// Output only. Schedule state when the monitoring job is in Running state.
  final ModelDeploymentMonitoringJob_MonitoringScheduleState? scheduleState;

  /// Output only. Latest triggered monitoring pipeline metadata.
  final ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata?
  latestMonitoringPipelineMetadata;

  /// Required. The config for monitoring objectives. This is a per DeployedModel
  /// config. Each DeployedModel needs to be configured separately.
  final List<ModelDeploymentMonitoringObjectiveConfig>?
  modelDeploymentMonitoringObjectiveConfigs;

  /// Required. Schedule config for running the monitoring job.
  final ModelDeploymentMonitoringScheduleConfig?
  modelDeploymentMonitoringScheduleConfig;

  /// Required. Sample Strategy for logging.
  final SamplingStrategy? loggingSamplingStrategy;

  /// Alert config for model monitoring.
  final ModelMonitoringAlertConfig? modelMonitoringAlertConfig;

  /// YAML schema file uri describing the format of a single instance,
  /// which are given to format this Endpoint's prediction (and explanation).
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  final String? predictInstanceSchemaUri;

  /// Sample Predict instance, same format as
  /// `PredictRequest.instances`,
  /// this can be set as a replacement of
  /// `ModelDeploymentMonitoringJob.predict_instance_schema_uri`.
  /// If not set, we will generate predict schema from collected predict
  /// requests.
  final protobuf.Value? samplePredictInstance;

  /// YAML schema file uri describing the format of a single instance that you
  /// want Tensorflow Data Validation (TFDV) to analyze.
  ///
  /// If this field is empty, all the feature data types are inferred from
  /// `predict_instance_schema_uri`,
  /// meaning that TFDV will use the data in the exact format(data type) as
  /// prediction request/response.
  /// If there are any data type differences between predict instance and TFDV
  /// instance, this field can be used to override the schema.
  /// For models trained with Vertex AI, this field must be set as all the
  /// fields in predict instance formatted as string.
  final String? analysisInstanceSchemaUri;

  /// Output only. The created bigquery tables for the job under customer
  /// project. Customer could do their own query & analysis. There could be 4 log
  /// tables in maximum:
  /// 1. Training data logging predict request/response
  /// 2. Serving data logging predict request/response
  final List<ModelDeploymentMonitoringBigQueryTable>? bigqueryTables;

  /// The TTL of BigQuery tables in user projects which stores logs.
  /// A day is the basic unit of the TTL and we take the ceil of TTL/86400(a
  /// day). e.g. { second: 3600} indicates ttl = 1 day.
  final protobuf.Duration? logTtl;

  /// The labels with user-defined metadata to organize your
  /// ModelDeploymentMonitoringJob.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Output only. Timestamp when this ModelDeploymentMonitoringJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ModelDeploymentMonitoringJob was updated
  /// most recently.
  final protobuf.Timestamp? updateTime;

  /// Output only. Timestamp when this monitoring pipeline will be scheduled to
  /// run for the next round.
  final protobuf.Timestamp? nextScheduleTime;

  /// Stats anomalies base folder path.
  final GcsDestination? statsAnomaliesBaseDirectory;

  /// Customer-managed encryption key spec for a ModelDeploymentMonitoringJob. If
  /// set, this ModelDeploymentMonitoringJob and all sub-resources of this
  /// ModelDeploymentMonitoringJob will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// If true, the scheduled monitoring pipeline logs are sent to
  /// Google Cloud Logging, including pipeline status and anomalies detected.
  /// Please note the logs incur cost, which are subject to [Cloud Logging
  /// pricing](https://cloud.google.com/logging#pricing).
  final bool? enableMonitoringPipelineLogs;

  /// Output only. Only populated when the job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  final Status? error;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  ModelDeploymentMonitoringJob({
    this.name,
    this.displayName,
    this.endpoint,
    this.state,
    this.scheduleState,
    this.latestMonitoringPipelineMetadata,
    this.modelDeploymentMonitoringObjectiveConfigs,
    this.modelDeploymentMonitoringScheduleConfig,
    this.loggingSamplingStrategy,
    this.modelMonitoringAlertConfig,
    this.predictInstanceSchemaUri,
    this.samplePredictInstance,
    this.analysisInstanceSchemaUri,
    this.bigqueryTables,
    this.logTtl,
    this.labels,
    this.createTime,
    this.updateTime,
    this.nextScheduleTime,
    this.statsAnomaliesBaseDirectory,
    this.encryptionSpec,
    this.enableMonitoringPipelineLogs,
    this.error,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringJob.fromJson(Map<String, dynamic> json) {
    return ModelDeploymentMonitoringJob(
      name: json['name'],
      displayName: json['displayName'],
      endpoint: json['endpoint'],
      state: decodeEnum(json['state'], JobState.fromJson),
      scheduleState: decodeEnum(
        json['scheduleState'],
        ModelDeploymentMonitoringJob_MonitoringScheduleState.fromJson,
      ),
      latestMonitoringPipelineMetadata: decode(
        json['latestMonitoringPipelineMetadata'],
        ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata.fromJson,
      ),
      modelDeploymentMonitoringObjectiveConfigs: decodeListMessage(
        json['modelDeploymentMonitoringObjectiveConfigs'],
        ModelDeploymentMonitoringObjectiveConfig.fromJson,
      ),
      modelDeploymentMonitoringScheduleConfig: decode(
        json['modelDeploymentMonitoringScheduleConfig'],
        ModelDeploymentMonitoringScheduleConfig.fromJson,
      ),
      loggingSamplingStrategy: decode(
        json['loggingSamplingStrategy'],
        SamplingStrategy.fromJson,
      ),
      modelMonitoringAlertConfig: decode(
        json['modelMonitoringAlertConfig'],
        ModelMonitoringAlertConfig.fromJson,
      ),
      predictInstanceSchemaUri: json['predictInstanceSchemaUri'],
      samplePredictInstance: decodeCustom(
        json['samplePredictInstance'],
        protobuf.Value.fromJson,
      ),
      analysisInstanceSchemaUri: json['analysisInstanceSchemaUri'],
      bigqueryTables: decodeListMessage(
        json['bigqueryTables'],
        ModelDeploymentMonitoringBigQueryTable.fromJson,
      ),
      logTtl: decodeCustom(json['logTtl'], protobuf.Duration.fromJson),
      labels: decodeMap(json['labels']),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      nextScheduleTime: decodeCustom(
        json['nextScheduleTime'],
        protobuf.Timestamp.fromJson,
      ),
      statsAnomaliesBaseDirectory: decode(
        json['statsAnomaliesBaseDirectory'],
        GcsDestination.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      enableMonitoringPipelineLogs: json['enableMonitoringPipelineLogs'],
      error: decode(json['error'], Status.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (endpoint != null) 'endpoint': endpoint,
      if (state != null) 'state': state!.toJson(),
      if (scheduleState != null) 'scheduleState': scheduleState!.toJson(),
      if (latestMonitoringPipelineMetadata != null)
        'latestMonitoringPipelineMetadata': latestMonitoringPipelineMetadata!
            .toJson(),
      if (modelDeploymentMonitoringObjectiveConfigs != null)
        'modelDeploymentMonitoringObjectiveConfigs': encodeList(
          modelDeploymentMonitoringObjectiveConfigs,
        ),
      if (modelDeploymentMonitoringScheduleConfig != null)
        'modelDeploymentMonitoringScheduleConfig':
            modelDeploymentMonitoringScheduleConfig!.toJson(),
      if (loggingSamplingStrategy != null)
        'loggingSamplingStrategy': loggingSamplingStrategy!.toJson(),
      if (modelMonitoringAlertConfig != null)
        'modelMonitoringAlertConfig': modelMonitoringAlertConfig!.toJson(),
      if (predictInstanceSchemaUri != null)
        'predictInstanceSchemaUri': predictInstanceSchemaUri,
      if (samplePredictInstance != null)
        'samplePredictInstance': samplePredictInstance!.toJson(),
      if (analysisInstanceSchemaUri != null)
        'analysisInstanceSchemaUri': analysisInstanceSchemaUri,
      if (bigqueryTables != null) 'bigqueryTables': encodeList(bigqueryTables),
      if (logTtl != null) 'logTtl': logTtl!.toJson(),
      if (labels != null) 'labels': labels,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (nextScheduleTime != null)
        'nextScheduleTime': nextScheduleTime!.toJson(),
      if (statsAnomaliesBaseDirectory != null)
        'statsAnomaliesBaseDirectory': statsAnomaliesBaseDirectory!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (enableMonitoringPipelineLogs != null)
        'enableMonitoringPipelineLogs': enableMonitoringPipelineLogs,
      if (error != null) 'error': error!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (endpoint != null) 'endpoint=$endpoint',
      if (state != null) 'state=$state',
      if (scheduleState != null) 'scheduleState=$scheduleState',
      if (predictInstanceSchemaUri != null)
        'predictInstanceSchemaUri=$predictInstanceSchemaUri',
      if (analysisInstanceSchemaUri != null)
        'analysisInstanceSchemaUri=$analysisInstanceSchemaUri',
      if (enableMonitoringPipelineLogs != null)
        'enableMonitoringPipelineLogs=$enableMonitoringPipelineLogs',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'ModelDeploymentMonitoringJob($contents)';
  }
}

/// All metadata of most recent monitoring pipelines.
final class ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringJob.LatestMonitoringPipelineMetadata';

  /// The time that most recent monitoring pipelines that is related to this
  /// run.
  final protobuf.Timestamp? runTime;

  /// The status of the most recent monitoring pipeline.
  final Status? status;

  ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata({
    this.runTime,
    this.status,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelDeploymentMonitoringJob_LatestMonitoringPipelineMetadata(
      runTime: decodeCustom(json['runTime'], protobuf.Timestamp.fromJson),
      status: decode(json['status'], Status.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (runTime != null) 'runTime': runTime!.toJson(),
      if (status != null) 'status': status!.toJson(),
    };
  }

  @override
  String toString() => 'LatestMonitoringPipelineMetadata()';
}

/// The state to Specify the monitoring pipeline.
final class ModelDeploymentMonitoringJob_MonitoringScheduleState
    extends protobuf.ProtoEnum {
  /// Unspecified state.
  static const monitoringScheduleStateUnspecified =
      ModelDeploymentMonitoringJob_MonitoringScheduleState(
        'MONITORING_SCHEDULE_STATE_UNSPECIFIED',
      );

  /// The pipeline is picked up and wait to run.
  static const pending = ModelDeploymentMonitoringJob_MonitoringScheduleState(
    'PENDING',
  );

  /// The pipeline is offline and will be scheduled for next run.
  static const offline = ModelDeploymentMonitoringJob_MonitoringScheduleState(
    'OFFLINE',
  );

  /// The pipeline is running.
  static const running = ModelDeploymentMonitoringJob_MonitoringScheduleState(
    'RUNNING',
  );

  const ModelDeploymentMonitoringJob_MonitoringScheduleState(super.value);

  factory ModelDeploymentMonitoringJob_MonitoringScheduleState.fromJson(
    String json,
  ) => ModelDeploymentMonitoringJob_MonitoringScheduleState(json);

  @override
  String toString() => 'MonitoringScheduleState.$value';
}

/// ModelDeploymentMonitoringBigQueryTable specifies the BigQuery table name
/// as well as some information of the logs stored in this table.
final class ModelDeploymentMonitoringBigQueryTable
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringBigQueryTable';

  /// The source of log.
  final ModelDeploymentMonitoringBigQueryTable_LogSource? logSource;

  /// The type of log.
  final ModelDeploymentMonitoringBigQueryTable_LogType? logType;

  /// The created BigQuery table to store logs. Customer could do their own query
  /// & analysis. Format:
  /// `bq://<project_id>.model_deployment_monitoring_<endpoint_id>.<tolower(log_source)>_<tolower(log_type)>`
  final String? bigqueryTablePath;

  /// Output only. The schema version of the request/response logging BigQuery
  /// table. Default to v1 if unset.
  final String? requestResponseLoggingSchemaVersion;

  ModelDeploymentMonitoringBigQueryTable({
    this.logSource,
    this.logType,
    this.bigqueryTablePath,
    this.requestResponseLoggingSchemaVersion,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringBigQueryTable.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelDeploymentMonitoringBigQueryTable(
      logSource: decodeEnum(
        json['logSource'],
        ModelDeploymentMonitoringBigQueryTable_LogSource.fromJson,
      ),
      logType: decodeEnum(
        json['logType'],
        ModelDeploymentMonitoringBigQueryTable_LogType.fromJson,
      ),
      bigqueryTablePath: json['bigqueryTablePath'],
      requestResponseLoggingSchemaVersion:
          json['requestResponseLoggingSchemaVersion'],
    );
  }

  @override
  Object toJson() {
    return {
      if (logSource != null) 'logSource': logSource!.toJson(),
      if (logType != null) 'logType': logType!.toJson(),
      if (bigqueryTablePath != null) 'bigqueryTablePath': bigqueryTablePath,
      if (requestResponseLoggingSchemaVersion != null)
        'requestResponseLoggingSchemaVersion':
            requestResponseLoggingSchemaVersion,
    };
  }

  @override
  String toString() {
    final contents = [
      if (logSource != null) 'logSource=$logSource',
      if (logType != null) 'logType=$logType',
      if (bigqueryTablePath != null) 'bigqueryTablePath=$bigqueryTablePath',
      if (requestResponseLoggingSchemaVersion != null)
        'requestResponseLoggingSchemaVersion=$requestResponseLoggingSchemaVersion',
    ].join(',');
    return 'ModelDeploymentMonitoringBigQueryTable($contents)';
  }
}

/// Indicates where does the log come from.
final class ModelDeploymentMonitoringBigQueryTable_LogSource
    extends protobuf.ProtoEnum {
  /// Unspecified source.
  static const logSourceUnspecified =
      ModelDeploymentMonitoringBigQueryTable_LogSource(
        'LOG_SOURCE_UNSPECIFIED',
      );

  /// Logs coming from Training dataset.
  static const training = ModelDeploymentMonitoringBigQueryTable_LogSource(
    'TRAINING',
  );

  /// Logs coming from Serving traffic.
  static const serving = ModelDeploymentMonitoringBigQueryTable_LogSource(
    'SERVING',
  );

  const ModelDeploymentMonitoringBigQueryTable_LogSource(super.value);

  factory ModelDeploymentMonitoringBigQueryTable_LogSource.fromJson(
    String json,
  ) => ModelDeploymentMonitoringBigQueryTable_LogSource(json);

  @override
  String toString() => 'LogSource.$value';
}

/// Indicates what type of traffic does the log belong to.
final class ModelDeploymentMonitoringBigQueryTable_LogType
    extends protobuf.ProtoEnum {
  /// Unspecified type.
  static const logTypeUnspecified =
      ModelDeploymentMonitoringBigQueryTable_LogType('LOG_TYPE_UNSPECIFIED');

  /// Predict logs.
  static const predict = ModelDeploymentMonitoringBigQueryTable_LogType(
    'PREDICT',
  );

  /// Explain logs.
  static const explain = ModelDeploymentMonitoringBigQueryTable_LogType(
    'EXPLAIN',
  );

  const ModelDeploymentMonitoringBigQueryTable_LogType(super.value);

  factory ModelDeploymentMonitoringBigQueryTable_LogType.fromJson(
    String json,
  ) => ModelDeploymentMonitoringBigQueryTable_LogType(json);

  @override
  String toString() => 'LogType.$value';
}

/// ModelDeploymentMonitoringObjectiveConfig contains the pair of
/// deployed_model_id to ModelMonitoringObjectiveConfig.
final class ModelDeploymentMonitoringObjectiveConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringObjectiveConfig';

  /// The DeployedModel ID of the objective config.
  final String? deployedModelId;

  /// The objective config of for the modelmonitoring job of this deployed model.
  final ModelMonitoringObjectiveConfig? objectiveConfig;

  ModelDeploymentMonitoringObjectiveConfig({
    this.deployedModelId,
    this.objectiveConfig,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringObjectiveConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelDeploymentMonitoringObjectiveConfig(
      deployedModelId: json['deployedModelId'],
      objectiveConfig: decode(
        json['objectiveConfig'],
        ModelMonitoringObjectiveConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (deployedModelId != null) 'deployedModelId': deployedModelId,
      if (objectiveConfig != null) 'objectiveConfig': objectiveConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (deployedModelId != null) 'deployedModelId=$deployedModelId',
    ].join(',');
    return 'ModelDeploymentMonitoringObjectiveConfig($contents)';
  }
}

/// The config for scheduling monitoring job.
final class ModelDeploymentMonitoringScheduleConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelDeploymentMonitoringScheduleConfig';

  /// Required. The model monitoring job scheduling interval. It will be rounded
  /// up to next full hour. This defines how often the monitoring jobs are
  /// triggered.
  final protobuf.Duration? monitorInterval;

  /// The time window of the prediction data being included in each prediction
  /// dataset. This window specifies how long the data should be collected from
  /// historical model results for each run. If not set,
  /// `ModelDeploymentMonitoringScheduleConfig.monitor_interval`
  /// will be used. e.g. If currently the cutoff time is 2022-01-08 14:30:00 and
  /// the monitor_window is set to be 3600, then data from 2022-01-08 13:30:00 to
  /// 2022-01-08 14:30:00 will be retrieved and aggregated to calculate the
  /// monitoring statistics.
  final protobuf.Duration? monitorWindow;

  ModelDeploymentMonitoringScheduleConfig({
    this.monitorInterval,
    this.monitorWindow,
  }) : super(fullyQualifiedName);

  factory ModelDeploymentMonitoringScheduleConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelDeploymentMonitoringScheduleConfig(
      monitorInterval: decodeCustom(
        json['monitorInterval'],
        protobuf.Duration.fromJson,
      ),
      monitorWindow: decodeCustom(
        json['monitorWindow'],
        protobuf.Duration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (monitorInterval != null) 'monitorInterval': monitorInterval!.toJson(),
      if (monitorWindow != null) 'monitorWindow': monitorWindow!.toJson(),
    };
  }

  @override
  String toString() => 'ModelDeploymentMonitoringScheduleConfig()';
}

/// Statistics and anomalies generated by Model Monitoring.
final class ModelMonitoringStatsAnomalies extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsAnomalies';

  /// Model Monitoring Objective those stats and anomalies belonging to.
  final ModelDeploymentMonitoringObjectiveType? objective;

  /// Deployed Model ID.
  final String? deployedModelId;

  /// Number of anomalies within all stats.
  final int? anomalyCount;

  /// A list of historical Stats and Anomalies generated for all Features.
  final List<ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies>?
  featureStats;

  ModelMonitoringStatsAnomalies({
    this.objective,
    this.deployedModelId,
    this.anomalyCount,
    this.featureStats,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsAnomalies.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringStatsAnomalies(
      objective: decodeEnum(
        json['objective'],
        ModelDeploymentMonitoringObjectiveType.fromJson,
      ),
      deployedModelId: json['deployedModelId'],
      anomalyCount: json['anomalyCount'],
      featureStats: decodeListMessage(
        json['featureStats'],
        ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (objective != null) 'objective': objective!.toJson(),
      if (deployedModelId != null) 'deployedModelId': deployedModelId,
      if (anomalyCount != null) 'anomalyCount': anomalyCount,
      if (featureStats != null) 'featureStats': encodeList(featureStats),
    };
  }

  @override
  String toString() {
    final contents = [
      if (objective != null) 'objective=$objective',
      if (deployedModelId != null) 'deployedModelId=$deployedModelId',
      if (anomalyCount != null) 'anomalyCount=$anomalyCount',
    ].join(',');
    return 'ModelMonitoringStatsAnomalies($contents)';
  }
}

/// Historical Stats (and Anomalies) for a specific Feature.
final class ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsAnomalies.FeatureHistoricStatsAnomalies';

  /// Display Name of the Feature.
  final String? featureDisplayName;

  /// Threshold for anomaly detection.
  final ThresholdConfig? threshold;

  /// Stats calculated for the Training Dataset.
  final FeatureStatsAnomaly? trainingStats;

  /// A list of historical stats generated by different time window's
  /// Prediction Dataset.
  final List<FeatureStatsAnomaly>? predictionStats;

  ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies({
    this.featureDisplayName,
    this.threshold,
    this.trainingStats,
    this.predictionStats,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringStatsAnomalies_FeatureHistoricStatsAnomalies(
      featureDisplayName: json['featureDisplayName'],
      threshold: decode(json['threshold'], ThresholdConfig.fromJson),
      trainingStats: decode(
        json['trainingStats'],
        FeatureStatsAnomaly.fromJson,
      ),
      predictionStats: decodeListMessage(
        json['predictionStats'],
        FeatureStatsAnomaly.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureDisplayName != null) 'featureDisplayName': featureDisplayName,
      if (threshold != null) 'threshold': threshold!.toJson(),
      if (trainingStats != null) 'trainingStats': trainingStats!.toJson(),
      if (predictionStats != null)
        'predictionStats': encodeList(predictionStats),
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureDisplayName != null) 'featureDisplayName=$featureDisplayName',
    ].join(',');
    return 'FeatureHistoricStatsAnomalies($contents)';
  }
}

/// A collection of metrics calculated by comparing Model's predictions on all of
/// the test data against annotations from the test data.
final class ModelEvaluation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluation';

  /// Output only. The resource name of the ModelEvaluation.
  final String? name;

  /// The display name of the ModelEvaluation.
  final String? displayName;

  /// Points to a YAML file stored on Google Cloud Storage describing the
  /// `metrics` of this
  /// ModelEvaluation. The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  final String? metricsSchemaUri;

  /// Evaluation metrics of the Model. The schema of the metrics is stored in
  /// `metrics_schema_uri`
  final protobuf.Value? metrics;

  /// Output only. Timestamp when this ModelEvaluation was created.
  final protobuf.Timestamp? createTime;

  /// All possible
  /// `dimensions`
  /// of ModelEvaluationSlices. The dimensions can be used as the filter of the
  /// `ModelService.ListModelEvaluationSlices`
  /// request, in the form of `slice.dimension = <dimension>`.
  final List<String>? sliceDimensions;

  /// Aggregated explanation metrics for the Model's prediction output over the
  /// data this ModelEvaluation uses. This field is populated only if the Model
  /// is evaluated with explanations, and only for AutoML tabular Models.
  final ModelExplanation? modelExplanation;

  /// Describes the values of
  /// `ExplanationSpec` that are
  /// used for explaining the predicted values on the evaluated data.
  final List<ModelEvaluation_ModelEvaluationExplanationSpec>? explanationSpecs;

  /// The metadata of the ModelEvaluation.
  /// For the ModelEvaluation uploaded from Managed Pipeline, metadata contains a
  /// structured value with keys of "pipeline_job_id", "evaluation_dataset_type",
  /// "evaluation_dataset_path", "row_based_metrics_path".
  final protobuf.Value? metadata;

  /// Specify the configuration for bias detection.
  final ModelEvaluation_BiasConfig? biasConfigs;

  ModelEvaluation({
    this.name,
    this.displayName,
    this.metricsSchemaUri,
    this.metrics,
    this.createTime,
    this.sliceDimensions,
    this.modelExplanation,
    this.explanationSpecs,
    this.metadata,
    this.biasConfigs,
  }) : super(fullyQualifiedName);

  factory ModelEvaluation.fromJson(Map<String, dynamic> json) {
    return ModelEvaluation(
      name: json['name'],
      displayName: json['displayName'],
      metricsSchemaUri: json['metricsSchemaUri'],
      metrics: decodeCustom(json['metrics'], protobuf.Value.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      sliceDimensions: decodeList(json['sliceDimensions']),
      modelExplanation: decode(
        json['modelExplanation'],
        ModelExplanation.fromJson,
      ),
      explanationSpecs: decodeListMessage(
        json['explanationSpecs'],
        ModelEvaluation_ModelEvaluationExplanationSpec.fromJson,
      ),
      metadata: decodeCustom(json['metadata'], protobuf.Value.fromJson),
      biasConfigs: decode(
        json['biasConfigs'],
        ModelEvaluation_BiasConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (metricsSchemaUri != null) 'metricsSchemaUri': metricsSchemaUri,
      if (metrics != null) 'metrics': metrics!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (sliceDimensions != null) 'sliceDimensions': sliceDimensions,
      if (modelExplanation != null)
        'modelExplanation': modelExplanation!.toJson(),
      if (explanationSpecs != null)
        'explanationSpecs': encodeList(explanationSpecs),
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (biasConfigs != null) 'biasConfigs': biasConfigs!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (metricsSchemaUri != null) 'metricsSchemaUri=$metricsSchemaUri',
    ].join(',');
    return 'ModelEvaluation($contents)';
  }
}

final class ModelEvaluation_ModelEvaluationExplanationSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluation.ModelEvaluationExplanationSpec';

  /// Explanation type.
  ///
  /// For AutoML Image Classification models, possible values are:
  ///
  ///   * `image-integrated-gradients`
  ///   * `image-xrai`
  final String? explanationType;

  /// Explanation spec details.
  final ExplanationSpec? explanationSpec;

  ModelEvaluation_ModelEvaluationExplanationSpec({
    this.explanationType,
    this.explanationSpec,
  }) : super(fullyQualifiedName);

  factory ModelEvaluation_ModelEvaluationExplanationSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelEvaluation_ModelEvaluationExplanationSpec(
      explanationType: json['explanationType'],
      explanationSpec: decode(
        json['explanationSpec'],
        ExplanationSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (explanationType != null) 'explanationType': explanationType,
      if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (explanationType != null) 'explanationType=$explanationType',
    ].join(',');
    return 'ModelEvaluationExplanationSpec($contents)';
  }
}

/// Configuration for bias detection.
final class ModelEvaluation_BiasConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluation.BiasConfig';

  /// Specification for how the data should be sliced for bias. It contains a
  /// list of slices, with limitation of two slices. The first slice of data
  /// will be the slice_a. The second slice in the list (slice_b) will be
  /// compared against the first slice. If only a single slice is provided,
  /// then slice_a will be compared against "not slice_a".
  /// Below are examples with feature "education" with value "low", "medium",
  /// "high" in the dataset:
  ///
  /// Example 1:
  ///
  ///     bias_slices = [{'education': 'low'}]
  ///
  /// A single slice provided. In this case, slice_a is the collection of data
  /// with 'education' equals 'low', and slice_b is the collection of data with
  /// 'education' equals 'medium' or 'high'.
  ///
  /// Example 2:
  ///
  ///     bias_slices = [{'education': 'low'},
  ///                    {'education': 'high'}]
  ///
  /// Two slices provided. In this case, slice_a is the collection of data
  /// with 'education' equals 'low', and slice_b is the collection of data with
  /// 'education' equals 'high'.
  final ModelEvaluationSlice_Slice_SliceSpec? biasSlices;

  /// Positive labels selection on the target field.
  final List<String>? labels;

  ModelEvaluation_BiasConfig({this.biasSlices, this.labels})
    : super(fullyQualifiedName);

  factory ModelEvaluation_BiasConfig.fromJson(Map<String, dynamic> json) {
    return ModelEvaluation_BiasConfig(
      biasSlices: decode(
        json['biasSlices'],
        ModelEvaluationSlice_Slice_SliceSpec.fromJson,
      ),
      labels: decodeList(json['labels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (biasSlices != null) 'biasSlices': biasSlices!.toJson(),
      if (labels != null) 'labels': labels,
    };
  }

  @override
  String toString() => 'BiasConfig()';
}

/// A collection of metrics calculated by comparing Model's predictions on a
/// slice of the test data against ground truth annotations.
final class ModelEvaluationSlice extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice';

  /// Output only. The resource name of the ModelEvaluationSlice.
  final String? name;

  /// Output only. The slice of the test data that is used to evaluate the Model.
  final ModelEvaluationSlice_Slice? slice;

  /// Output only. Points to a YAML file stored on Google Cloud Storage
  /// describing the
  /// `metrics` of
  /// this ModelEvaluationSlice. The schema is defined as an OpenAPI 3.0.2
  /// [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  final String? metricsSchemaUri;

  /// Output only. Sliced evaluation metrics of the Model. The schema of the
  /// metrics is stored in
  /// `metrics_schema_uri`
  final protobuf.Value? metrics;

  /// Output only. Timestamp when this ModelEvaluationSlice was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Aggregated explanation metrics for the Model's prediction
  /// output over the data this ModelEvaluation uses. This field is populated
  /// only if the Model is evaluated with explanations, and only for tabular
  /// Models.
  final ModelExplanation? modelExplanation;

  ModelEvaluationSlice({
    this.name,
    this.slice,
    this.metricsSchemaUri,
    this.metrics,
    this.createTime,
    this.modelExplanation,
  }) : super(fullyQualifiedName);

  factory ModelEvaluationSlice.fromJson(Map<String, dynamic> json) {
    return ModelEvaluationSlice(
      name: json['name'],
      slice: decode(json['slice'], ModelEvaluationSlice_Slice.fromJson),
      metricsSchemaUri: json['metricsSchemaUri'],
      metrics: decodeCustom(json['metrics'], protobuf.Value.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      modelExplanation: decode(
        json['modelExplanation'],
        ModelExplanation.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (slice != null) 'slice': slice!.toJson(),
      if (metricsSchemaUri != null) 'metricsSchemaUri': metricsSchemaUri,
      if (metrics != null) 'metrics': metrics!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (modelExplanation != null)
        'modelExplanation': modelExplanation!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (metricsSchemaUri != null) 'metricsSchemaUri=$metricsSchemaUri',
    ].join(',');
    return 'ModelEvaluationSlice($contents)';
  }
}

/// Definition of a slice.
final class ModelEvaluationSlice_Slice extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice';

  /// Output only. The dimension of the slice.
  /// Well-known dimensions are:
  ///   * `annotationSpec`: This slice is on the test data that has either
  ///     ground truth or prediction with
  ///     `AnnotationSpec.display_name`
  ///     equals to
  ///     `value`.
  ///   * `slice`: This slice is a user customized slice defined by its
  ///     SliceSpec.
  final String? dimension;

  /// Output only. The value of the dimension in this slice.
  final String? value;

  /// Output only. Specification for how the data was sliced.
  final ModelEvaluationSlice_Slice_SliceSpec? sliceSpec;

  ModelEvaluationSlice_Slice({this.dimension, this.value, this.sliceSpec})
    : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice.fromJson(Map<String, dynamic> json) {
    return ModelEvaluationSlice_Slice(
      dimension: json['dimension'],
      value: json['value'],
      sliceSpec: decode(
        json['sliceSpec'],
        ModelEvaluationSlice_Slice_SliceSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dimension != null) 'dimension': dimension,
      if (value != null) 'value': value,
      if (sliceSpec != null) 'sliceSpec': sliceSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (dimension != null) 'dimension=$dimension',
      if (value != null) 'value=$value',
    ].join(',');
    return 'Slice($contents)';
  }
}

/// Specification for how the data should be sliced.
final class ModelEvaluationSlice_Slice_SliceSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice.SliceSpec';

  /// Mapping configuration for this SliceSpec.
  /// The key is the name of the feature.
  /// By default, the key will be prefixed by "instance" as a dictionary
  /// prefix for Vertex Batch Predictions output format.
  final Map<String, ModelEvaluationSlice_Slice_SliceSpec_SliceConfig>? configs;

  ModelEvaluationSlice_Slice_SliceSpec({this.configs})
    : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice_SliceSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelEvaluationSlice_Slice_SliceSpec(
      configs: decodeMapMessage(
        json['configs'],
        ModelEvaluationSlice_Slice_SliceSpec_SliceConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (configs != null) 'configs': encodeMap(configs)};
  }

  @override
  String toString() => 'SliceSpec()';
}

/// Specification message containing the config for this SliceSpec.
/// When `kind` is selected as `value` and/or `range`, only a single slice
/// will be computed.
/// When `all_values` is present, a separate slice will be computed for
/// each possible label/value for the corresponding key in `config`.
/// Examples, with feature zip_code with values 12345, 23334, 88888 and
/// feature country with values "US", "Canada", "Mexico" in the dataset:
///
/// Example 1:
///
///     {
///       "zip_code": { "value": { "float_value": 12345.0 } }
///     }
///
/// A single slice for any data with zip_code 12345 in the dataset.
///
/// Example 2:
///
///     {
///       "zip_code": { "range": { "low": 12345, "high": 20000 } }
///     }
///
/// A single slice containing data where the zip_codes between 12345 and
/// 20000 For this example, data with the zip_code of 12345 will be in this
/// slice.
///
/// Example 3:
///
///     {
///       "zip_code": { "range": { "low": 10000, "high": 20000 } },
///       "country": { "value": { "string_value": "US" } }
///     }
///
/// A single slice containing data where the zip_codes between 10000 and
/// 20000 has the country "US". For this example, data with the zip_code of
/// 12345 and country "US" will be in this slice.
///
/// Example 4:
///
///     { "country": {"all_values": { "value": true } } }
///
/// Three slices are computed, one for each unique country in the dataset.
///
/// Example 5:
///
///     {
///       "country": { "all_values": { "value": true } },
///       "zip_code": { "value": { "float_value": 12345.0 } }
///     }
///
/// Three slices are computed, one for each unique country in the dataset
/// where the zip_code is also 12345. For this example, data with zip_code
/// 12345 and country "US" will be in one slice, zip_code 12345 and country
/// "Canada" in another slice, and zip_code 12345 and country "Mexico" in
/// another slice, totaling 3 slices.
final class ModelEvaluationSlice_Slice_SliceSpec_SliceConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice.SliceSpec.SliceConfig';

  /// A unique specific value for a given feature.
  /// Example: `{ "value": { "string_value": "12345" } }`
  final ModelEvaluationSlice_Slice_SliceSpec_Value? value;

  /// A range of values for a numerical feature.
  /// Example: `{"range":{"low":10000.0,"high":50000.0}}`
  /// will capture 12345 and 23334 in the slice.
  final ModelEvaluationSlice_Slice_SliceSpec_Range? range;

  /// If all_values is set to true, then all possible labels of the keyed
  /// feature will have another slice computed.
  /// Example: `{"all_values":{"value":true}}`
  final protobuf.BoolValue? allValues;

  ModelEvaluationSlice_Slice_SliceSpec_SliceConfig({
    this.value,
    this.range,
    this.allValues,
  }) : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice_SliceSpec_SliceConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelEvaluationSlice_Slice_SliceSpec_SliceConfig(
      value: decode(
        json['value'],
        ModelEvaluationSlice_Slice_SliceSpec_Value.fromJson,
      ),
      range: decode(
        json['range'],
        ModelEvaluationSlice_Slice_SliceSpec_Range.fromJson,
      ),
      allValues: decodeCustom(json['allValues'], protobuf.BoolValue.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (value != null) 'value': value!.toJson(),
      if (range != null) 'range': range!.toJson(),
      if (allValues != null) 'allValues': allValues!.toJson(),
    };
  }

  @override
  String toString() => 'SliceConfig()';
}

/// A range of values for slice(s).
/// `low` is inclusive, `high` is exclusive.
final class ModelEvaluationSlice_Slice_SliceSpec_Range
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice.SliceSpec.Range';

  /// Inclusive low value for the range.
  final double? low;

  /// Exclusive high value for the range.
  final double? high;

  ModelEvaluationSlice_Slice_SliceSpec_Range({this.low, this.high})
    : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice_SliceSpec_Range.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelEvaluationSlice_Slice_SliceSpec_Range(
      low: decodeDouble(json['low']),
      high: decodeDouble(json['high']),
    );
  }

  @override
  Object toJson() {
    return {
      if (low != null) 'low': encodeDouble(low),
      if (high != null) 'high': encodeDouble(high),
    };
  }

  @override
  String toString() {
    final contents = [
      if (low != null) 'low=$low',
      if (high != null) 'high=$high',
    ].join(',');
    return 'Range($contents)';
  }
}

/// Single value that supports strings and floats.
final class ModelEvaluationSlice_Slice_SliceSpec_Value
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelEvaluationSlice.Slice.SliceSpec.Value';

  /// String type.
  final String? stringValue;

  /// Float type.
  final double? floatValue;

  ModelEvaluationSlice_Slice_SliceSpec_Value({
    this.stringValue,
    this.floatValue,
  }) : super(fullyQualifiedName);

  factory ModelEvaluationSlice_Slice_SliceSpec_Value.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelEvaluationSlice_Slice_SliceSpec_Value(
      stringValue: json['stringValue'],
      floatValue: decodeDouble(json['floatValue']),
    );
  }

  @override
  Object toJson() {
    return {
      if (stringValue != null) 'stringValue': stringValue,
      if (floatValue != null) 'floatValue': encodeDouble(floatValue),
    };
  }

  @override
  String toString() {
    final contents = [
      if (stringValue != null) 'stringValue=$stringValue',
      if (floatValue != null) 'floatValue=$floatValue',
    ].join(',');
    return 'Value($contents)';
  }
}

/// Request message for
/// `ModelGardenService.GetPublisherModel`
final class GetPublisherModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetPublisherModelRequest';

  /// Required. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}`
  final String name;

  /// Optional. The IETF BCP-47 language code representing the language in which
  /// the publisher model's text information should be written in.
  final String? languageCode;

  /// Optional. PublisherModel view specifying which fields to read.
  final PublisherModelView? view;

  /// Optional. Boolean indicates whether the requested model is a Hugging Face
  /// model.
  final bool? isHuggingFaceModel;

  /// Optional. Token used to access Hugging Face gated models.
  final String? huggingFaceToken;

  /// Optional. Whether to cnclude the deployment configs from the equivalent
  /// Model Garden model if the requested model is a Hugging Face model.
  final bool? includeEquivalentModelGardenModelDeploymentConfigs;

  GetPublisherModelRequest({
    required this.name,
    this.languageCode,
    this.view,
    this.isHuggingFaceModel,
    this.huggingFaceToken,
    this.includeEquivalentModelGardenModelDeploymentConfigs,
  }) : super(fullyQualifiedName);

  factory GetPublisherModelRequest.fromJson(Map<String, dynamic> json) {
    return GetPublisherModelRequest(
      name: json['name'],
      languageCode: json['languageCode'],
      view: decodeEnum(json['view'], PublisherModelView.fromJson),
      isHuggingFaceModel: json['isHuggingFaceModel'],
      huggingFaceToken: json['huggingFaceToken'],
      includeEquivalentModelGardenModelDeploymentConfigs:
          json['includeEquivalentModelGardenModelDeploymentConfigs'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (languageCode != null) 'languageCode': languageCode,
      if (view != null) 'view': view!.toJson(),
      if (isHuggingFaceModel != null) 'isHuggingFaceModel': isHuggingFaceModel,
      if (huggingFaceToken != null) 'huggingFaceToken': huggingFaceToken,
      if (includeEquivalentModelGardenModelDeploymentConfigs != null)
        'includeEquivalentModelGardenModelDeploymentConfigs':
            includeEquivalentModelGardenModelDeploymentConfigs,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (languageCode != null) 'languageCode=$languageCode',
      if (view != null) 'view=$view',
      if (isHuggingFaceModel != null) 'isHuggingFaceModel=$isHuggingFaceModel',
      if (huggingFaceToken != null) 'huggingFaceToken=$huggingFaceToken',
      if (includeEquivalentModelGardenModelDeploymentConfigs != null)
        'includeEquivalentModelGardenModelDeploymentConfigs=$includeEquivalentModelGardenModelDeploymentConfigs',
    ].join(',');
    return 'GetPublisherModelRequest($contents)';
  }
}

/// Request message for
/// `ModelGardenService.ListPublisherModels`.
final class ListPublisherModelsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPublisherModelsRequest';

  /// Required. The name of the Publisher from which to list the PublisherModels.
  /// Format: `publishers/{publisher}`
  final String parent;

  /// Optional. The standard list filter.
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListPublisherModelsResponse.next_page_token`
  /// of the previous
  /// `ModelGardenService.ListPublisherModels`
  /// call.
  final String? pageToken;

  /// Optional. PublisherModel view specifying which fields to read.
  final PublisherModelView? view;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending.
  final String? orderBy;

  /// Optional. The IETF BCP-47 language code representing the language in which
  /// the publisher models' text information should be written in. If not set, by
  /// default English (en).
  final String? languageCode;

  /// Optional. List all publisher model versions if the flag is set to true.
  final bool? listAllVersions;

  ListPublisherModelsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.view,
    this.orderBy,
    this.languageCode,
    this.listAllVersions,
  }) : super(fullyQualifiedName);

  factory ListPublisherModelsRequest.fromJson(Map<String, dynamic> json) {
    return ListPublisherModelsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      view: decodeEnum(json['view'], PublisherModelView.fromJson),
      orderBy: json['orderBy'],
      languageCode: json['languageCode'],
      listAllVersions: json['listAllVersions'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (view != null) 'view': view!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
      if (languageCode != null) 'languageCode': languageCode,
      if (listAllVersions != null) 'listAllVersions': listAllVersions,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (view != null) 'view=$view',
      if (orderBy != null) 'orderBy=$orderBy',
      if (languageCode != null) 'languageCode=$languageCode',
      if (listAllVersions != null) 'listAllVersions=$listAllVersions',
    ].join(',');
    return 'ListPublisherModelsRequest($contents)';
  }
}

/// Response message for
/// `ModelGardenService.ListPublisherModels`.
final class ListPublisherModelsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPublisherModelsResponse';

  /// List of PublisherModels in the requested page.
  final List<PublisherModel>? publisherModels;

  /// A token to retrieve next page of results.
  /// Pass to `ListPublisherModels.page_token` to obtain that page.
  final String? nextPageToken;

  ListPublisherModelsResponse({this.publisherModels, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListPublisherModelsResponse.fromJson(Map<String, dynamic> json) {
    return ListPublisherModelsResponse(
      publisherModels: decodeListMessage(
        json['publisherModels'],
        PublisherModel.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (publisherModels != null)
        'publisherModels': encodeList(publisherModels),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListPublisherModelsResponse($contents)';
  }
}

/// Request message for
/// `ModelGardenService.Deploy`.
final class DeployRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest';

  /// The Model Garden model to deploy.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`.
  final String? publisherModelName;

  /// The Hugging Face model to deploy.
  /// Format: Hugging Face model ID like `google/gemma-2-2b-it`.
  final String? huggingFaceModelId;

  /// The custom model to deploy from a Google Cloud Storage URI.
  final DeployRequest_CustomModel? customModel;

  /// Required. The resource name of the Location to deploy the model in.
  /// Format: `projects/{project}/locations/{location}`
  final String destination;

  /// Optional. The model config to use for the deployment.
  /// If not specified, the default model config will be used.
  final DeployRequest_ModelConfig? modelConfig;

  /// Optional. The endpoint config to use for the deployment.
  /// If not specified, the default endpoint config will be used.
  final DeployRequest_EndpointConfig? endpointConfig;

  /// Optional. The deploy config to use for the deployment.
  /// If not specified, the default deploy config will be used.
  final DeployRequest_DeployConfig? deployConfig;

  DeployRequest({
    this.publisherModelName,
    this.huggingFaceModelId,
    this.customModel,
    required this.destination,
    this.modelConfig,
    this.endpointConfig,
    this.deployConfig,
  }) : super(fullyQualifiedName);

  factory DeployRequest.fromJson(Map<String, dynamic> json) {
    return DeployRequest(
      publisherModelName: json['publisherModelName'],
      huggingFaceModelId: json['huggingFaceModelId'],
      customModel: decode(
        json['customModel'],
        DeployRequest_CustomModel.fromJson,
      ),
      destination: json['destination'],
      modelConfig: decode(
        json['modelConfig'],
        DeployRequest_ModelConfig.fromJson,
      ),
      endpointConfig: decode(
        json['endpointConfig'],
        DeployRequest_EndpointConfig.fromJson,
      ),
      deployConfig: decode(
        json['deployConfig'],
        DeployRequest_DeployConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (publisherModelName != null) 'publisherModelName': publisherModelName,
      if (huggingFaceModelId != null) 'huggingFaceModelId': huggingFaceModelId,
      if (customModel != null) 'customModel': customModel!.toJson(),
      'destination': destination,
      if (modelConfig != null) 'modelConfig': modelConfig!.toJson(),
      if (endpointConfig != null) 'endpointConfig': endpointConfig!.toJson(),
      if (deployConfig != null) 'deployConfig': deployConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (publisherModelName != null) 'publisherModelName=$publisherModelName',
      if (huggingFaceModelId != null) 'huggingFaceModelId=$huggingFaceModelId',
      'destination=$destination',
    ].join(',');
    return 'DeployRequest($contents)';
  }
}

/// The custom model to deploy from model weights in a Google Cloud Storage URI
/// or Model Registry model.
final class DeployRequest_CustomModel extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest.CustomModel';

  /// Immutable. The Google Cloud Storage URI of the custom model, storing
  /// weights and config files (which can be used to infer the base model).
  final String? gcsUri;

  DeployRequest_CustomModel({this.gcsUri}) : super(fullyQualifiedName);

  factory DeployRequest_CustomModel.fromJson(Map<String, dynamic> json) {
    return DeployRequest_CustomModel(gcsUri: json['gcsUri']);
  }

  @override
  Object toJson() {
    return {if (gcsUri != null) 'gcsUri': gcsUri};
  }

  @override
  String toString() {
    final contents = [if (gcsUri != null) 'gcsUri=$gcsUri'].join(',');
    return 'CustomModel($contents)';
  }
}

/// The model config to use for the deployment.
final class DeployRequest_ModelConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest.ModelConfig';

  /// Optional. Whether the user accepts the End User License Agreement (EULA)
  /// for the model.
  final bool? acceptEula;

  /// Optional. The Hugging Face read access token used to access the model
  /// artifacts of gated models.
  final String? huggingFaceAccessToken;

  /// Optional. If true, the model will deploy with a cached version instead of
  /// directly downloading the model artifacts from Hugging Face. This is
  /// suitable for VPC-SC users with limited internet access.
  final bool? huggingFaceCacheEnabled;

  /// Optional. The user-specified display name of the uploaded model. If not
  /// set, a default name will be used.
  final String? modelDisplayName;

  /// Optional. The specification of the container that is to be used when
  /// deploying. If not set, the default container spec will be used.
  final ModelContainerSpec? containerSpec;

  /// Optional. The ID to use for the uploaded Model, which will become the
  /// final component of the model resource name. When not provided, Vertex AI
  /// will generate a value for this ID. When Model Registry model is provided,
  /// this field will be ignored.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  final String? modelUserId;

  DeployRequest_ModelConfig({
    this.acceptEula,
    this.huggingFaceAccessToken,
    this.huggingFaceCacheEnabled,
    this.modelDisplayName,
    this.containerSpec,
    this.modelUserId,
  }) : super(fullyQualifiedName);

  factory DeployRequest_ModelConfig.fromJson(Map<String, dynamic> json) {
    return DeployRequest_ModelConfig(
      acceptEula: json['acceptEula'],
      huggingFaceAccessToken: json['huggingFaceAccessToken'],
      huggingFaceCacheEnabled: json['huggingFaceCacheEnabled'],
      modelDisplayName: json['modelDisplayName'],
      containerSpec: decode(json['containerSpec'], ModelContainerSpec.fromJson),
      modelUserId: json['modelUserId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (acceptEula != null) 'acceptEula': acceptEula,
      if (huggingFaceAccessToken != null)
        'huggingFaceAccessToken': huggingFaceAccessToken,
      if (huggingFaceCacheEnabled != null)
        'huggingFaceCacheEnabled': huggingFaceCacheEnabled,
      if (modelDisplayName != null) 'modelDisplayName': modelDisplayName,
      if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
      if (modelUserId != null) 'modelUserId': modelUserId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (acceptEula != null) 'acceptEula=$acceptEula',
      if (huggingFaceAccessToken != null)
        'huggingFaceAccessToken=$huggingFaceAccessToken',
      if (huggingFaceCacheEnabled != null)
        'huggingFaceCacheEnabled=$huggingFaceCacheEnabled',
      if (modelDisplayName != null) 'modelDisplayName=$modelDisplayName',
      if (modelUserId != null) 'modelUserId=$modelUserId',
    ].join(',');
    return 'ModelConfig($contents)';
  }
}

/// The endpoint config to use for the deployment.
final class DeployRequest_EndpointConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest.EndpointConfig';

  /// Optional. The user-specified display name of the endpoint. If not set, a
  /// default name will be used.
  final String? endpointDisplayName;

  /// Optional. Deprecated. Use dedicated_endpoint_disabled instead.
  /// If true, the endpoint will be exposed through a
  /// dedicated DNS [Endpoint.dedicated_endpoint_dns]. Your request to the
  /// dedicated DNS will be isolated from other users' traffic and will have
  /// better performance and reliability. Note: Once you enabled dedicated
  /// endpoint, you won't be able to send request to the shared DNS
  /// {region}-aiplatform.googleapis.com. The limitations will be removed soon.
  final bool? dedicatedEndpointEnabled;

  /// Optional. By default, if dedicated endpoint is enabled and private
  /// service connect config is not set, the endpoint will be exposed through a
  /// dedicated DNS [Endpoint.dedicated_endpoint_dns]. If private service
  /// connect config is set, the endpoint will be exposed through private
  /// service connect. Your request to the dedicated DNS will be isolated from
  /// other users' traffic and will have better performance and reliability.
  /// Note: Once you enabled dedicated endpoint, you won't be able to send
  /// request to the shared DNS {region}-aiplatform.googleapis.com. The
  /// limitations will be removed soon.
  ///
  /// If this field is set to true, the dedicated endpoint will be disabled
  /// and the deployed model will be exposed through the shared DNS
  /// {region}-aiplatform.googleapis.com.
  final bool? dedicatedEndpointDisabled;

  /// Optional. Configuration for private service connect. If set, the endpoint
  /// will be exposed through private service connect.
  final PrivateServiceConnectConfig? privateServiceConnectConfig;

  /// Optional. Immutable. The ID to use for endpoint, which will become the
  /// final component of the endpoint resource name. If not provided, Vertex AI
  /// will generate a value for this ID.
  ///
  /// If the first character is a letter, this value may be up to 63
  /// characters, and valid characters are `[a-z0-9-]`. The last character must
  /// be a letter or number.
  ///
  /// If the first character is a number, this value may be up to 9 characters,
  /// and valid characters are `[0-9]` with no leading zeros.
  ///
  /// When using HTTP/JSON, this field is populated
  /// based on a query string argument, such as `?endpoint_id=12345`. This is
  /// the fallback for fields that are not included in either the URI or the
  /// body.
  final String? endpointUserId;

  DeployRequest_EndpointConfig({
    this.endpointDisplayName,
    this.dedicatedEndpointEnabled,
    this.dedicatedEndpointDisabled,
    this.privateServiceConnectConfig,
    this.endpointUserId,
  }) : super(fullyQualifiedName);

  factory DeployRequest_EndpointConfig.fromJson(Map<String, dynamic> json) {
    return DeployRequest_EndpointConfig(
      endpointDisplayName: json['endpointDisplayName'],
      dedicatedEndpointEnabled: json['dedicatedEndpointEnabled'],
      dedicatedEndpointDisabled: json['dedicatedEndpointDisabled'],
      privateServiceConnectConfig: decode(
        json['privateServiceConnectConfig'],
        PrivateServiceConnectConfig.fromJson,
      ),
      endpointUserId: json['endpointUserId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (endpointDisplayName != null)
        'endpointDisplayName': endpointDisplayName,
      if (dedicatedEndpointEnabled != null)
        'dedicatedEndpointEnabled': dedicatedEndpointEnabled,
      if (dedicatedEndpointDisabled != null)
        'dedicatedEndpointDisabled': dedicatedEndpointDisabled,
      if (privateServiceConnectConfig != null)
        'privateServiceConnectConfig': privateServiceConnectConfig!.toJson(),
      if (endpointUserId != null) 'endpointUserId': endpointUserId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (endpointDisplayName != null)
        'endpointDisplayName=$endpointDisplayName',
      if (dedicatedEndpointEnabled != null)
        'dedicatedEndpointEnabled=$dedicatedEndpointEnabled',
      if (dedicatedEndpointDisabled != null)
        'dedicatedEndpointDisabled=$dedicatedEndpointDisabled',
      if (endpointUserId != null) 'endpointUserId=$endpointUserId',
    ].join(',');
    return 'EndpointConfig($contents)';
  }
}

/// The deploy config to use for the deployment.
final class DeployRequest_DeployConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployRequest.DeployConfig';

  /// Optional. The dedicated resources to use for the endpoint. If not set,
  /// the default resources will be used.
  final DedicatedResources? dedicatedResources;

  /// Optional. If true, enable the QMT fast tryout feature for this model if
  /// possible.
  final bool? fastTryoutEnabled;

  /// Optional. System labels for Model Garden deployments.
  /// These labels are managed by Google and for tracking purposes only.
  final Map<String, String>? systemLabels;

  DeployRequest_DeployConfig({
    this.dedicatedResources,
    this.fastTryoutEnabled,
    this.systemLabels,
  }) : super(fullyQualifiedName);

  factory DeployRequest_DeployConfig.fromJson(Map<String, dynamic> json) {
    return DeployRequest_DeployConfig(
      dedicatedResources: decode(
        json['dedicatedResources'],
        DedicatedResources.fromJson,
      ),
      fastTryoutEnabled: json['fastTryoutEnabled'],
      systemLabels: decodeMap(json['systemLabels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (dedicatedResources != null)
        'dedicatedResources': dedicatedResources!.toJson(),
      if (fastTryoutEnabled != null) 'fastTryoutEnabled': fastTryoutEnabled,
      if (systemLabels != null) 'systemLabels': systemLabels,
    };
  }

  @override
  String toString() {
    final contents = [
      if (fastTryoutEnabled != null) 'fastTryoutEnabled=$fastTryoutEnabled',
    ].join(',');
    return 'DeployConfig($contents)';
  }
}

/// Request message for
/// `ModelGardenService.DeployPublisherModel`.
final class DeployPublisherModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployPublisherModelRequest';

  /// Required. The model to deploy.
  /// Format:
  /// 1. `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`.
  /// 2. Hugging Face model ID like `google/gemma-2-2b-it`.
  /// 3. Custom model Google Cloud Storage URI like `gs://bucket`.
  /// 4. Custom model zip file like `https://example.com/a.zip`.
  final String? model;

  /// Required. The resource name of the Location to deploy the model in.
  /// Format: `projects/{project}/locations/{location}`
  final String destination;

  /// Optional. The user-specified display name of the endpoint. If not set, a
  /// default name will be used.
  final String? endpointDisplayName;

  /// Optional. The dedicated resources to use for the endpoint. If not set, the
  /// default resources will be used.
  final DedicatedResources? dedicatedResources;

  /// Optional. The user-specified display name of the uploaded model. If not
  /// set, a default name will be used.
  final String? modelDisplayName;

  /// Optional. The Hugging Face read access token used to access the model
  /// artifacts of gated models.
  final String? huggingFaceAccessToken;

  /// Optional. Whether the user accepts the End User License Agreement (EULA)
  /// for the model.
  final bool? acceptEula;

  DeployPublisherModelRequest({
    this.model,
    required this.destination,
    this.endpointDisplayName,
    this.dedicatedResources,
    this.modelDisplayName,
    this.huggingFaceAccessToken,
    this.acceptEula,
  }) : super(fullyQualifiedName);

  factory DeployPublisherModelRequest.fromJson(Map<String, dynamic> json) {
    return DeployPublisherModelRequest(
      model: json['model'],
      destination: json['destination'],
      endpointDisplayName: json['endpointDisplayName'],
      dedicatedResources: decode(
        json['dedicatedResources'],
        DedicatedResources.fromJson,
      ),
      modelDisplayName: json['modelDisplayName'],
      huggingFaceAccessToken: json['huggingFaceAccessToken'],
      acceptEula: json['acceptEula'],
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      'destination': destination,
      if (endpointDisplayName != null)
        'endpointDisplayName': endpointDisplayName,
      if (dedicatedResources != null)
        'dedicatedResources': dedicatedResources!.toJson(),
      if (modelDisplayName != null) 'modelDisplayName': modelDisplayName,
      if (huggingFaceAccessToken != null)
        'huggingFaceAccessToken': huggingFaceAccessToken,
      if (acceptEula != null) 'acceptEula': acceptEula,
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      'destination=$destination',
      if (endpointDisplayName != null)
        'endpointDisplayName=$endpointDisplayName',
      if (modelDisplayName != null) 'modelDisplayName=$modelDisplayName',
      if (huggingFaceAccessToken != null)
        'huggingFaceAccessToken=$huggingFaceAccessToken',
      if (acceptEula != null) 'acceptEula=$acceptEula',
    ].join(',');
    return 'DeployPublisherModelRequest($contents)';
  }
}

/// Response message for
/// `ModelGardenService.Deploy`.
final class DeployResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployResponse';

  /// Output only. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  final String? publisherModel;

  /// Output only. The name of the Endpoint created.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? endpoint;

  /// Output only. The name of the Model created.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String? model;

  DeployResponse({this.publisherModel, this.endpoint, this.model})
    : super(fullyQualifiedName);

  factory DeployResponse.fromJson(Map<String, dynamic> json) {
    return DeployResponse(
      publisherModel: json['publisherModel'],
      endpoint: json['endpoint'],
      model: json['model'],
    );
  }

  @override
  Object toJson() {
    return {
      if (publisherModel != null) 'publisherModel': publisherModel,
      if (endpoint != null) 'endpoint': endpoint,
      if (model != null) 'model': model,
    };
  }

  @override
  String toString() {
    final contents = [
      if (publisherModel != null) 'publisherModel=$publisherModel',
      if (endpoint != null) 'endpoint=$endpoint',
      if (model != null) 'model=$model',
    ].join(',');
    return 'DeployResponse($contents)';
  }
}

/// Response message for
/// `ModelGardenService.DeployPublisherModel`.
final class DeployPublisherModelResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployPublisherModelResponse';

  /// Output only. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  final String? publisherModel;

  /// Output only. The name of the Endpoint created.
  /// Format: `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? endpoint;

  /// Output only. The name of the Model created.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String? model;

  DeployPublisherModelResponse({this.publisherModel, this.endpoint, this.model})
    : super(fullyQualifiedName);

  factory DeployPublisherModelResponse.fromJson(Map<String, dynamic> json) {
    return DeployPublisherModelResponse(
      publisherModel: json['publisherModel'],
      endpoint: json['endpoint'],
      model: json['model'],
    );
  }

  @override
  Object toJson() {
    return {
      if (publisherModel != null) 'publisherModel': publisherModel,
      if (endpoint != null) 'endpoint': endpoint,
      if (model != null) 'model': model,
    };
  }

  @override
  String toString() {
    final contents = [
      if (publisherModel != null) 'publisherModel=$publisherModel',
      if (endpoint != null) 'endpoint=$endpoint',
      if (model != null) 'model=$model',
    ].join(',');
    return 'DeployPublisherModelResponse($contents)';
  }
}

/// Runtime operation information for
/// `ModelGardenService.Deploy`.
final class DeployOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. The name of the model resource.
  final String? publisherModel;

  /// Output only. The resource name of the Location to deploy the model in.
  /// Format: `projects/{project}/locations/{location}`
  final String? destination;

  /// Output only. The project number where the deploy model request is sent.
  final int? projectNumber;

  /// Output only. The model id to be used at query time.
  final String? modelId;

  DeployOperationMetadata({
    this.genericMetadata,
    this.publisherModel,
    this.destination,
    this.projectNumber,
    this.modelId,
  }) : super(fullyQualifiedName);

  factory DeployOperationMetadata.fromJson(Map<String, dynamic> json) {
    return DeployOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      publisherModel: json['publisherModel'],
      destination: json['destination'],
      projectNumber: decodeInt64(json['projectNumber']),
      modelId: json['modelId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (publisherModel != null) 'publisherModel': publisherModel,
      if (destination != null) 'destination': destination,
      if (projectNumber != null) 'projectNumber': encodeInt64(projectNumber),
      if (modelId != null) 'modelId': modelId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (publisherModel != null) 'publisherModel=$publisherModel',
      if (destination != null) 'destination=$destination',
      if (projectNumber != null) 'projectNumber=$projectNumber',
      if (modelId != null) 'modelId=$modelId',
    ].join(',');
    return 'DeployOperationMetadata($contents)';
  }
}

/// Runtime operation information for
/// `ModelGardenService.DeployPublisherModel`.
final class DeployPublisherModelOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeployPublisherModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  final String? publisherModel;

  /// Output only. The resource name of the Location to deploy the model in.
  /// Format: `projects/{project}/locations/{location}`
  final String? destination;

  /// Output only. The project number where the deploy model request is sent.
  final int? projectNumber;

  DeployPublisherModelOperationMetadata({
    this.genericMetadata,
    this.publisherModel,
    this.destination,
    this.projectNumber,
  }) : super(fullyQualifiedName);

  factory DeployPublisherModelOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeployPublisherModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      publisherModel: json['publisherModel'],
      destination: json['destination'],
      projectNumber: decodeInt64(json['projectNumber']),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (publisherModel != null) 'publisherModel': publisherModel,
      if (destination != null) 'destination': destination,
      if (projectNumber != null) 'projectNumber': encodeInt64(projectNumber),
    };
  }

  @override
  String toString() {
    final contents = [
      if (publisherModel != null) 'publisherModel=$publisherModel',
      if (destination != null) 'destination=$destination',
      if (projectNumber != null) 'projectNumber=$projectNumber',
    ].join(',');
    return 'DeployPublisherModelOperationMetadata($contents)';
  }
}

/// Response message for
/// `ModelGardenService.ExportPublisherModel`.
final class ExportPublisherModelResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportPublisherModelResponse';

  /// The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`
  final String? publisherModel;

  /// The destination uri of the model weights.
  final String? destinationUri;

  ExportPublisherModelResponse({this.publisherModel, this.destinationUri})
    : super(fullyQualifiedName);

  factory ExportPublisherModelResponse.fromJson(Map<String, dynamic> json) {
    return ExportPublisherModelResponse(
      publisherModel: json['publisherModel'],
      destinationUri: json['destinationUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (publisherModel != null) 'publisherModel': publisherModel,
      if (destinationUri != null) 'destinationUri': destinationUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (publisherModel != null) 'publisherModel=$publisherModel',
      if (destinationUri != null) 'destinationUri=$destinationUri',
    ].join(',');
    return 'ExportPublisherModelResponse($contents)';
  }
}

/// Runtime operation information for
/// `ModelGardenService.ExportPublisherModel`.
final class ExportPublisherModelOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportPublisherModelOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  ExportPublisherModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory ExportPublisherModelOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExportPublisherModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'ExportPublisherModelOperationMetadata()';
}

/// Request message for
/// `ModelGardenService.ExportPublisherModel`.
final class ExportPublisherModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportPublisherModelRequest';

  /// Required. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}@{version_id}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}@001`
  final String name;

  /// Required. The target where we are exporting the model weights to
  final GcsDestination? destination;

  /// Required. The Location to export the model weights from
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  ExportPublisherModelRequest({
    required this.name,
    this.destination,
    required this.parent,
  }) : super(fullyQualifiedName);

  factory ExportPublisherModelRequest.fromJson(Map<String, dynamic> json) {
    return ExportPublisherModelRequest(
      name: json['name'],
      destination: decode(json['destination'], GcsDestination.fromJson),
      parent: json['parent'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (destination != null) 'destination': destination!.toJson(),
      'parent': parent,
    };
  }

  @override
  String toString() {
    final contents = ['name=$name', 'parent=$parent'].join(',');
    return 'ExportPublisherModelRequest($contents)';
  }
}

/// Request message for
/// `ModelGardenService.CheckPublisherModelEula`.
final class CheckPublisherModelEulaAcceptanceRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CheckPublisherModelEulaAcceptanceRequest';

  /// Required. The project requesting access for named model. The format is
  /// `projects/{project}`.
  final String parent;

  /// Required. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}`
  final String? publisherModel;

  CheckPublisherModelEulaAcceptanceRequest({
    required this.parent,
    this.publisherModel,
  }) : super(fullyQualifiedName);

  factory CheckPublisherModelEulaAcceptanceRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CheckPublisherModelEulaAcceptanceRequest(
      parent: json['parent'],
      publisherModel: json['publisherModel'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (publisherModel != null) 'publisherModel': publisherModel,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (publisherModel != null) 'publisherModel=$publisherModel',
    ].join(',');
    return 'CheckPublisherModelEulaAcceptanceRequest($contents)';
  }
}

/// Request message for
/// `ModelGardenService.AcceptPublisherModelEula`.
final class AcceptPublisherModelEulaRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AcceptPublisherModelEulaRequest';

  /// Required. The project requesting access for named model. The format is
  /// `projects/{project}`.
  final String parent;

  /// Required. The name of the PublisherModel resource.
  /// Format:
  /// `publishers/{publisher}/models/{publisher_model}`, or
  /// `publishers/hf-{hugging-face-author}/models/{hugging-face-model-name}`
  final String? publisherModel;

  AcceptPublisherModelEulaRequest({required this.parent, this.publisherModel})
    : super(fullyQualifiedName);

  factory AcceptPublisherModelEulaRequest.fromJson(Map<String, dynamic> json) {
    return AcceptPublisherModelEulaRequest(
      parent: json['parent'],
      publisherModel: json['publisherModel'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (publisherModel != null) 'publisherModel': publisherModel,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (publisherModel != null) 'publisherModel=$publisherModel',
    ].join(',');
    return 'AcceptPublisherModelEulaRequest($contents)';
  }
}

/// Response message for
/// `ModelGardenService.UpdatePublisherModelEula`.
final class PublisherModelEulaAcceptance extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModelEulaAcceptance';

  /// The project number requesting access for named model.
  final int? projectNumber;

  /// The publisher model resource name.
  final String? publisherModel;

  /// The EULA content acceptance status.
  final bool? publisherModelEulaAcked;

  PublisherModelEulaAcceptance({
    this.projectNumber,
    this.publisherModel,
    this.publisherModelEulaAcked,
  }) : super(fullyQualifiedName);

  factory PublisherModelEulaAcceptance.fromJson(Map<String, dynamic> json) {
    return PublisherModelEulaAcceptance(
      projectNumber: decodeInt64(json['projectNumber']),
      publisherModel: json['publisherModel'],
      publisherModelEulaAcked: json['publisherModelEulaAcked'],
    );
  }

  @override
  Object toJson() {
    return {
      if (projectNumber != null) 'projectNumber': encodeInt64(projectNumber),
      if (publisherModel != null) 'publisherModel': publisherModel,
      if (publisherModelEulaAcked != null)
        'publisherModelEulaAcked': publisherModelEulaAcked,
    };
  }

  @override
  String toString() {
    final contents = [
      if (projectNumber != null) 'projectNumber=$projectNumber',
      if (publisherModel != null) 'publisherModel=$publisherModel',
      if (publisherModelEulaAcked != null)
        'publisherModelEulaAcked=$publisherModelEulaAcked',
    ].join(',');
    return 'PublisherModelEulaAcceptance($contents)';
  }
}

/// Vertex AI Model Monitoring Service serves as a central hub for the analysis
/// and visualization of data quality and performance related to models.
/// ModelMonitor stands as a top level resource for overseeing your model
/// monitoring tasks.
final class ModelMonitor extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitor';

  /// Optional default tabular model monitoring objective.
  final ModelMonitoringObjectiveSpec_TabularObjective? tabularObjective;

  /// Immutable. Resource name of the ModelMonitor. Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`.
  final String? name;

  /// The display name of the ModelMonitor.
  /// The name can be up to 128 characters long and can consist of any UTF-8.
  final String? displayName;

  /// The entity that is subject to analysis.
  /// Currently only models in Vertex AI Model Registry are supported. If you
  /// want to analyze the model which is outside the Vertex AI, you could
  /// register a model in Vertex AI Model Registry using just a display name.
  final ModelMonitor_ModelMonitoringTarget? modelMonitoringTarget;

  /// Optional training dataset used to train the model.
  /// It can serve as a reference dataset to identify changes in production.
  final ModelMonitoringInput? trainingDataset;

  /// Optional default notification spec, it can be overridden in the
  /// ModelMonitoringJob notification spec.
  final ModelMonitoringNotificationSpec? notificationSpec;

  /// Optional default monitoring metrics/logs export spec, it can be overridden
  /// in the ModelMonitoringJob output spec.
  /// If not specified, a default Google Cloud Storage bucket will be created
  /// under your project.
  final ModelMonitoringOutputSpec? outputSpec;

  /// Optional model explanation spec. It is used for feature attribution
  /// monitoring.
  final ExplanationSpec? explanationSpec;

  /// Monitoring Schema is to specify the model's features, prediction outputs
  /// and ground truth properties. It is used to extract pertinent data from the
  /// dataset and to process features based on their properties.
  /// Make sure that the schema aligns with your dataset, if it does not, we will
  /// be unable to extract data from the dataset.
  /// It is required for most models, but optional for Vertex AI AutoML Tables
  /// unless the schem information is not available.
  final ModelMonitoringSchema? modelMonitoringSchema;

  /// Customer-managed encryption key spec for a ModelMonitor. If
  /// set, this ModelMonitor and all sub-resources of this
  /// ModelMonitor will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Timestamp when this ModelMonitor was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ModelMonitor was updated most recently.
  final protobuf.Timestamp? updateTime;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  ModelMonitor({
    this.tabularObjective,
    this.name,
    this.displayName,
    this.modelMonitoringTarget,
    this.trainingDataset,
    this.notificationSpec,
    this.outputSpec,
    this.explanationSpec,
    this.modelMonitoringSchema,
    this.encryptionSpec,
    this.createTime,
    this.updateTime,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory ModelMonitor.fromJson(Map<String, dynamic> json) {
    return ModelMonitor(
      tabularObjective: decode(
        json['tabularObjective'],
        ModelMonitoringObjectiveSpec_TabularObjective.fromJson,
      ),
      name: json['name'],
      displayName: json['displayName'],
      modelMonitoringTarget: decode(
        json['modelMonitoringTarget'],
        ModelMonitor_ModelMonitoringTarget.fromJson,
      ),
      trainingDataset: decode(
        json['trainingDataset'],
        ModelMonitoringInput.fromJson,
      ),
      notificationSpec: decode(
        json['notificationSpec'],
        ModelMonitoringNotificationSpec.fromJson,
      ),
      outputSpec: decode(
        json['outputSpec'],
        ModelMonitoringOutputSpec.fromJson,
      ),
      explanationSpec: decode(
        json['explanationSpec'],
        ExplanationSpec.fromJson,
      ),
      modelMonitoringSchema: decode(
        json['modelMonitoringSchema'],
        ModelMonitoringSchema.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tabularObjective != null)
        'tabularObjective': tabularObjective!.toJson(),
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (modelMonitoringTarget != null)
        'modelMonitoringTarget': modelMonitoringTarget!.toJson(),
      if (trainingDataset != null) 'trainingDataset': trainingDataset!.toJson(),
      if (notificationSpec != null)
        'notificationSpec': notificationSpec!.toJson(),
      if (outputSpec != null) 'outputSpec': outputSpec!.toJson(),
      if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
      if (modelMonitoringSchema != null)
        'modelMonitoringSchema': modelMonitoringSchema!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'ModelMonitor($contents)';
  }
}

/// The monitoring target refers to the entity that is subject to analysis.
/// e.g. Vertex AI Model version.
final class ModelMonitor_ModelMonitoringTarget extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitor.ModelMonitoringTarget';

  /// Model in Vertex AI Model Registry.
  final ModelMonitor_ModelMonitoringTarget_VertexModelSource? vertexModel;

  ModelMonitor_ModelMonitoringTarget({this.vertexModel})
    : super(fullyQualifiedName);

  factory ModelMonitor_ModelMonitoringTarget.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitor_ModelMonitoringTarget(
      vertexModel: decode(
        json['vertexModel'],
        ModelMonitor_ModelMonitoringTarget_VertexModelSource.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (vertexModel != null) 'vertexModel': vertexModel!.toJson()};
  }

  @override
  String toString() => 'ModelMonitoringTarget()';
}

/// Model in Vertex AI Model Registry.
final class ModelMonitor_ModelMonitoringTarget_VertexModelSource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitor.ModelMonitoringTarget.VertexModelSource';

  /// Model resource name. Format:
  /// projects/{project}/locations/{location}/models/{model}.
  final String? model;

  /// Model version id.
  final String? modelVersionId;

  ModelMonitor_ModelMonitoringTarget_VertexModelSource({
    this.model,
    this.modelVersionId,
  }) : super(fullyQualifiedName);

  factory ModelMonitor_ModelMonitoringTarget_VertexModelSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitor_ModelMonitoringTarget_VertexModelSource(
      model: json['model'],
      modelVersionId: json['modelVersionId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      if (modelVersionId != null) 'modelVersionId': modelVersionId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (modelVersionId != null) 'modelVersionId=$modelVersionId',
    ].join(',');
    return 'VertexModelSource($contents)';
  }
}

/// The Model Monitoring Schema definition.
final class ModelMonitoringSchema extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringSchema';

  /// Feature names of the model. Vertex AI will try to match the features from
  /// your dataset as follows:
  ///  * For 'csv' files, the header names are required, and we will extract the
  ///    corresponding feature values when the header names align with the
  ///    feature names.
  ///  * For 'jsonl' files, we will extract the corresponding feature values if
  ///    the key names match the feature names.
  ///    Note: Nested features are not supported, so please ensure your features
  ///    are flattened. Ensure the feature values are scalar or an array of
  ///    scalars.
  ///  * For 'bigquery' dataset, we will extract the corresponding feature values
  ///    if the column names match the feature names.
  ///    Note: The column type can be a scalar or an array of scalars. STRUCT or
  ///    JSON types are not supported. You may use SQL queries to select or
  ///    aggregate the relevant features from your original table. However,
  ///    ensure that the 'schema' of the query results meets our requirements.
  ///  * For the Vertex AI Endpoint Request Response Logging table or Vertex AI
  ///    Batch Prediction Job results. If the
  ///    `instance_type`
  ///    is an array, ensure that the sequence in
  ///    `feature_fields`
  ///    matches the order of features in the prediction instance. We will match
  ///    the feature with the array in the order specified in [feature_fields].
  final List<ModelMonitoringSchema_FieldSchema>? featureFields;

  /// Prediction output names of the model. The requirements are the same as the
  /// `feature_fields`.
  /// For AutoML Tables, the prediction output name presented in schema will be:
  /// `predicted_{target_column}`, the `target_column` is the one you specified
  /// when you train the model.
  /// For Prediction output drift analysis:
  ///  * AutoML Classification, the distribution of the argmax label will be
  ///    analyzed.
  ///  * AutoML Regression, the distribution of the value will be analyzed.
  final List<ModelMonitoringSchema_FieldSchema>? predictionFields;

  /// Target /ground truth names of the model.
  final List<ModelMonitoringSchema_FieldSchema>? groundTruthFields;

  ModelMonitoringSchema({
    this.featureFields,
    this.predictionFields,
    this.groundTruthFields,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringSchema.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringSchema(
      featureFields: decodeListMessage(
        json['featureFields'],
        ModelMonitoringSchema_FieldSchema.fromJson,
      ),
      predictionFields: decodeListMessage(
        json['predictionFields'],
        ModelMonitoringSchema_FieldSchema.fromJson,
      ),
      groundTruthFields: decodeListMessage(
        json['groundTruthFields'],
        ModelMonitoringSchema_FieldSchema.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureFields != null) 'featureFields': encodeList(featureFields),
      if (predictionFields != null)
        'predictionFields': encodeList(predictionFields),
      if (groundTruthFields != null)
        'groundTruthFields': encodeList(groundTruthFields),
    };
  }

  @override
  String toString() => 'ModelMonitoringSchema()';
}

/// Schema field definition.
final class ModelMonitoringSchema_FieldSchema extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringSchema.FieldSchema';

  /// Field name.
  final String? name;

  /// Supported data types are:
  /// `float`
  /// `integer`
  /// `boolean`
  /// `string`
  /// `categorical`
  final String? dataType;

  /// Describes if the schema field is an array of given data type.
  final bool? repeated;

  ModelMonitoringSchema_FieldSchema({this.name, this.dataType, this.repeated})
    : super(fullyQualifiedName);

  factory ModelMonitoringSchema_FieldSchema.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringSchema_FieldSchema(
      name: json['name'],
      dataType: json['dataType'],
      repeated: json['repeated'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (dataType != null) 'dataType': dataType,
      if (repeated != null) 'repeated': repeated,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (dataType != null) 'dataType=$dataType',
      if (repeated != null) 'repeated=$repeated',
    ].join(',');
    return 'FieldSchema($contents)';
  }
}

/// The model monitoring configuration used for Batch Prediction Job.
final class ModelMonitoringConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringConfig';

  /// Model monitoring objective config.
  final List<ModelMonitoringObjectiveConfig>? objectiveConfigs;

  /// Model monitoring alert config.
  final ModelMonitoringAlertConfig? alertConfig;

  /// YAML schema file uri in Cloud Storage describing the format of a single
  /// instance that you want Tensorflow Data Validation (TFDV) to analyze.
  ///
  /// If there are any data type differences between predict instance and TFDV
  /// instance, this field can be used to override the schema.
  /// For models trained with Vertex AI, this field must be set as all the
  /// fields in predict instance formatted as string.
  final String? analysisInstanceSchemaUri;

  /// A Google Cloud Storage location for batch prediction model monitoring to
  /// dump statistics and anomalies.
  /// If not provided, a folder will be created in customer project to hold
  /// statistics and anomalies.
  final GcsDestination? statsAnomaliesBaseDirectory;

  ModelMonitoringConfig({
    this.objectiveConfigs,
    this.alertConfig,
    this.analysisInstanceSchemaUri,
    this.statsAnomaliesBaseDirectory,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringConfig.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringConfig(
      objectiveConfigs: decodeListMessage(
        json['objectiveConfigs'],
        ModelMonitoringObjectiveConfig.fromJson,
      ),
      alertConfig: decode(
        json['alertConfig'],
        ModelMonitoringAlertConfig.fromJson,
      ),
      analysisInstanceSchemaUri: json['analysisInstanceSchemaUri'],
      statsAnomaliesBaseDirectory: decode(
        json['statsAnomaliesBaseDirectory'],
        GcsDestination.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (objectiveConfigs != null)
        'objectiveConfigs': encodeList(objectiveConfigs),
      if (alertConfig != null) 'alertConfig': alertConfig!.toJson(),
      if (analysisInstanceSchemaUri != null)
        'analysisInstanceSchemaUri': analysisInstanceSchemaUri,
      if (statsAnomaliesBaseDirectory != null)
        'statsAnomaliesBaseDirectory': statsAnomaliesBaseDirectory!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (analysisInstanceSchemaUri != null)
        'analysisInstanceSchemaUri=$analysisInstanceSchemaUri',
    ].join(',');
    return 'ModelMonitoringConfig($contents)';
  }
}

/// The objective configuration for model monitoring, including the information
/// needed to detect anomalies for one particular model.
final class ModelMonitoringObjectiveConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig';

  /// Training dataset for models. This field has to be set only if
  /// TrainingPredictionSkewDetectionConfig is specified.
  final ModelMonitoringObjectiveConfig_TrainingDataset? trainingDataset;

  /// The config for skew between training data and prediction data.
  final ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig?
  trainingPredictionSkewDetectionConfig;

  /// The config for drift of prediction data.
  final ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig?
  predictionDriftDetectionConfig;

  /// The config for integrating with Vertex Explainable AI.
  final ModelMonitoringObjectiveConfig_ExplanationConfig? explanationConfig;

  ModelMonitoringObjectiveConfig({
    this.trainingDataset,
    this.trainingPredictionSkewDetectionConfig,
    this.predictionDriftDetectionConfig,
    this.explanationConfig,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringObjectiveConfig(
      trainingDataset: decode(
        json['trainingDataset'],
        ModelMonitoringObjectiveConfig_TrainingDataset.fromJson,
      ),
      trainingPredictionSkewDetectionConfig: decode(
        json['trainingPredictionSkewDetectionConfig'],
        ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig
            .fromJson,
      ),
      predictionDriftDetectionConfig: decode(
        json['predictionDriftDetectionConfig'],
        ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.fromJson,
      ),
      explanationConfig: decode(
        json['explanationConfig'],
        ModelMonitoringObjectiveConfig_ExplanationConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingDataset != null) 'trainingDataset': trainingDataset!.toJson(),
      if (trainingPredictionSkewDetectionConfig != null)
        'trainingPredictionSkewDetectionConfig':
            trainingPredictionSkewDetectionConfig!.toJson(),
      if (predictionDriftDetectionConfig != null)
        'predictionDriftDetectionConfig': predictionDriftDetectionConfig!
            .toJson(),
      if (explanationConfig != null)
        'explanationConfig': explanationConfig!.toJson(),
    };
  }

  @override
  String toString() => 'ModelMonitoringObjectiveConfig()';
}

/// Training Dataset information.
final class ModelMonitoringObjectiveConfig_TrainingDataset
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.TrainingDataset';

  /// The resource name of the Dataset used to train this Model.
  final String? dataset;

  /// The Google Cloud Storage uri of the unmanaged Dataset used to train
  /// this Model.
  final GcsSource? gcsSource;

  /// The BigQuery table of the unmanaged Dataset used to train this
  /// Model.
  final BigQuerySource? bigquerySource;

  /// Data format of the dataset, only applicable if the input is from
  /// Google Cloud Storage.
  /// The possible formats are:
  ///
  /// "tf-record"
  /// The source file is a TFRecord file.
  ///
  /// "csv"
  /// The source file is a CSV file.
  /// "jsonl"
  /// The source file is a JSONL file.
  final String? dataFormat;

  /// The target field name the model is to predict.
  /// This field will be excluded when doing Predict and (or) Explain for the
  /// training data.
  final String? targetField;

  /// Strategy to sample data from Training Dataset.
  /// If not set, we process the whole dataset.
  final SamplingStrategy? loggingSamplingStrategy;

  ModelMonitoringObjectiveConfig_TrainingDataset({
    this.dataset,
    this.gcsSource,
    this.bigquerySource,
    this.dataFormat,
    this.targetField,
    this.loggingSamplingStrategy,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_TrainingDataset.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringObjectiveConfig_TrainingDataset(
      dataset: json['dataset'],
      gcsSource: decode(json['gcsSource'], GcsSource.fromJson),
      bigquerySource: decode(json['bigquerySource'], BigQuerySource.fromJson),
      dataFormat: json['dataFormat'],
      targetField: json['targetField'],
      loggingSamplingStrategy: decode(
        json['loggingSamplingStrategy'],
        SamplingStrategy.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataset != null) 'dataset': dataset,
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
      if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
      if (dataFormat != null) 'dataFormat': dataFormat,
      if (targetField != null) 'targetField': targetField,
      if (loggingSamplingStrategy != null)
        'loggingSamplingStrategy': loggingSamplingStrategy!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataset != null) 'dataset=$dataset',
      if (dataFormat != null) 'dataFormat=$dataFormat',
      if (targetField != null) 'targetField=$targetField',
    ].join(',');
    return 'TrainingDataset($contents)';
  }
}

/// The config for Training & Prediction data skew detection. It specifies the
/// training dataset sources and the skew detection parameters.
final class ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.TrainingPredictionSkewDetectionConfig';

  /// Key is the feature name and value is the threshold. If a feature needs to
  /// be monitored for skew, a value threshold must be configured for that
  /// feature. The threshold here is against feature distribution distance
  /// between the training and prediction feature.
  final Map<String, ThresholdConfig>? skewThresholds;

  /// Key is the feature name and value is the threshold. The threshold here is
  /// against attribution score distance between the training and prediction
  /// feature.
  final Map<String, ThresholdConfig>? attributionScoreSkewThresholds;

  /// Skew anomaly detection threshold used by all features.
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  final ThresholdConfig? defaultSkewThreshold;

  ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig({
    this.skewThresholds,
    this.attributionScoreSkewThresholds,
    this.defaultSkewThreshold,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringObjectiveConfig_TrainingPredictionSkewDetectionConfig(
      skewThresholds: decodeMapMessage(
        json['skewThresholds'],
        ThresholdConfig.fromJson,
      ),
      attributionScoreSkewThresholds: decodeMapMessage(
        json['attributionScoreSkewThresholds'],
        ThresholdConfig.fromJson,
      ),
      defaultSkewThreshold: decode(
        json['defaultSkewThreshold'],
        ThresholdConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (skewThresholds != null) 'skewThresholds': encodeMap(skewThresholds),
      if (attributionScoreSkewThresholds != null)
        'attributionScoreSkewThresholds': encodeMap(
          attributionScoreSkewThresholds,
        ),
      if (defaultSkewThreshold != null)
        'defaultSkewThreshold': defaultSkewThreshold!.toJson(),
    };
  }

  @override
  String toString() => 'TrainingPredictionSkewDetectionConfig()';
}

/// The config for Prediction data drift detection.
final class ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.PredictionDriftDetectionConfig';

  /// Key is the feature name and value is the threshold. If a feature needs to
  /// be monitored for drift, a value threshold must be configured for that
  /// feature. The threshold here is against feature distribution distance
  /// between different time windws.
  final Map<String, ThresholdConfig>? driftThresholds;

  /// Key is the feature name and value is the threshold. The threshold here is
  /// against attribution score distance between different time windows.
  final Map<String, ThresholdConfig>? attributionScoreDriftThresholds;

  /// Drift anomaly detection threshold used by all features.
  /// When the per-feature thresholds are not set, this field can be used to
  /// specify a threshold for all features.
  final ThresholdConfig? defaultDriftThreshold;

  ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig({
    this.driftThresholds,
    this.attributionScoreDriftThresholds,
    this.defaultDriftThreshold,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringObjectiveConfig_PredictionDriftDetectionConfig(
      driftThresholds: decodeMapMessage(
        json['driftThresholds'],
        ThresholdConfig.fromJson,
      ),
      attributionScoreDriftThresholds: decodeMapMessage(
        json['attributionScoreDriftThresholds'],
        ThresholdConfig.fromJson,
      ),
      defaultDriftThreshold: decode(
        json['defaultDriftThreshold'],
        ThresholdConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (driftThresholds != null)
        'driftThresholds': encodeMap(driftThresholds),
      if (attributionScoreDriftThresholds != null)
        'attributionScoreDriftThresholds': encodeMap(
          attributionScoreDriftThresholds,
        ),
      if (defaultDriftThreshold != null)
        'defaultDriftThreshold': defaultDriftThreshold!.toJson(),
    };
  }

  @override
  String toString() => 'PredictionDriftDetectionConfig()';
}

/// The config for integrating with Vertex Explainable AI. Only applicable if
/// the Model has explanation_spec populated.
final class ModelMonitoringObjectiveConfig_ExplanationConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.ExplanationConfig';

  /// If want to analyze the Vertex Explainable AI feature attribute scores or
  /// not. If set to true, Vertex AI will log the feature attributions from
  /// explain response and do the skew/drift detection for them.
  final bool? enableFeatureAttributes;

  /// Predictions generated by the BatchPredictionJob using baseline dataset.
  final ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline?
  explanationBaseline;

  ModelMonitoringObjectiveConfig_ExplanationConfig({
    this.enableFeatureAttributes,
    this.explanationBaseline,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_ExplanationConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringObjectiveConfig_ExplanationConfig(
      enableFeatureAttributes: json['enableFeatureAttributes'],
      explanationBaseline: decode(
        json['explanationBaseline'],
        ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (enableFeatureAttributes != null)
        'enableFeatureAttributes': enableFeatureAttributes,
      if (explanationBaseline != null)
        'explanationBaseline': explanationBaseline!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (enableFeatureAttributes != null)
        'enableFeatureAttributes=$enableFeatureAttributes',
    ].join(',');
    return 'ExplanationConfig($contents)';
  }
}

/// Output from
/// `BatchPredictionJob`
/// for Model Monitoring baseline dataset, which can be used to generate
/// baseline attribution scores.
final class ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveConfig.ExplanationConfig.ExplanationBaseline';

  /// Cloud Storage location for BatchExplain output.
  final GcsDestination? gcs;

  /// BigQuery location for BatchExplain output.
  final BigQueryDestination? bigquery;

  /// The storage format of the predictions generated BatchPrediction job.
  final ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat?
  predictionFormat;

  ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline({
    this.gcs,
    this.bigquery,
    this.predictionFormat,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline(
      gcs: decode(json['gcs'], GcsDestination.fromJson),
      bigquery: decode(json['bigquery'], BigQueryDestination.fromJson),
      predictionFormat: decodeEnum(
        json['predictionFormat'],
        ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (gcs != null) 'gcs': gcs!.toJson(),
      if (bigquery != null) 'bigquery': bigquery!.toJson(),
      if (predictionFormat != null)
        'predictionFormat': predictionFormat!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (predictionFormat != null) 'predictionFormat=$predictionFormat',
    ].join(',');
    return 'ExplanationBaseline($contents)';
  }
}

/// The storage format of the predictions generated BatchPrediction job.
final class ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat
    extends protobuf.ProtoEnum {
  /// Should not be set.
  static const predictionFormatUnspecified =
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
        'PREDICTION_FORMAT_UNSPECIFIED',
      );

  /// Predictions are in JSONL files.
  static const jsonl =
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
        'JSONL',
      );

  /// Predictions are in BigQuery.
  static const bigquery =
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
        'BIGQUERY',
      );

  const ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
    super.value,
  );

  factory ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat.fromJson(
    String json,
  ) =>
      ModelMonitoringObjectiveConfig_ExplanationConfig_ExplanationBaseline_PredictionFormat(
        json,
      );

  @override
  String toString() => 'PredictionFormat.$value';
}

/// The alert config for model monitoring.
final class ModelMonitoringAlertConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAlertConfig';

  /// Email alert config.
  final ModelMonitoringAlertConfig_EmailAlertConfig? emailAlertConfig;

  /// Dump the anomalies to Cloud Logging. The anomalies will be put to json
  /// payload encoded from proto
  /// `google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry`.
  /// This can be further sinked to Pub/Sub or any other services supported
  /// by Cloud Logging.
  final bool? enableLogging;

  /// Resource names of the NotificationChannels to send alert.
  /// Must be of the format
  /// `projects/<project_id_or_number>/notificationChannels/<channel_id>`
  final List<String>? notificationChannels;

  ModelMonitoringAlertConfig({
    this.emailAlertConfig,
    this.enableLogging,
    this.notificationChannels,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringAlertConfig.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringAlertConfig(
      emailAlertConfig: decode(
        json['emailAlertConfig'],
        ModelMonitoringAlertConfig_EmailAlertConfig.fromJson,
      ),
      enableLogging: json['enableLogging'],
      notificationChannels: decodeList(json['notificationChannels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (emailAlertConfig != null)
        'emailAlertConfig': emailAlertConfig!.toJson(),
      if (enableLogging != null) 'enableLogging': enableLogging,
      if (notificationChannels != null)
        'notificationChannels': notificationChannels,
    };
  }

  @override
  String toString() {
    final contents = [
      if (enableLogging != null) 'enableLogging=$enableLogging',
    ].join(',');
    return 'ModelMonitoringAlertConfig($contents)';
  }
}

/// The config for email alert.
final class ModelMonitoringAlertConfig_EmailAlertConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAlertConfig.EmailAlertConfig';

  /// The email addresses to send the alert.
  final List<String>? userEmails;

  ModelMonitoringAlertConfig_EmailAlertConfig({this.userEmails})
    : super(fullyQualifiedName);

  factory ModelMonitoringAlertConfig_EmailAlertConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringAlertConfig_EmailAlertConfig(
      userEmails: decodeList(json['userEmails']),
    );
  }

  @override
  Object toJson() {
    return {if (userEmails != null) 'userEmails': userEmails};
  }

  @override
  String toString() => 'EmailAlertConfig()';
}

/// The config for feature monitoring threshold.
final class ThresholdConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ThresholdConfig';

  /// Specify a threshold value that can trigger the alert.
  /// If this threshold config is for feature distribution distance:
  ///   1. For categorical feature, the distribution distance is calculated by
  ///      L-inifinity norm.
  ///   2. For numerical feature, the distribution distance is calculated by
  ///      JensenShannon divergence.
  /// Each feature must have a non-zero threshold if they need to be monitored.
  /// Otherwise no alert will be triggered for that feature.
  final double? value;

  ThresholdConfig({this.value}) : super(fullyQualifiedName);

  factory ThresholdConfig.fromJson(Map<String, dynamic> json) {
    return ThresholdConfig(value: decodeDouble(json['value']));
  }

  @override
  Object toJson() {
    return {if (value != null) 'value': encodeDouble(value)};
  }

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'ThresholdConfig($contents)';
  }
}

/// Sampling Strategy for logging, can be for both training and prediction
/// dataset.
final class SamplingStrategy extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SamplingStrategy';

  /// Random sample config. Will support more sampling strategies later.
  final SamplingStrategy_RandomSampleConfig? randomSampleConfig;

  SamplingStrategy({this.randomSampleConfig}) : super(fullyQualifiedName);

  factory SamplingStrategy.fromJson(Map<String, dynamic> json) {
    return SamplingStrategy(
      randomSampleConfig: decode(
        json['randomSampleConfig'],
        SamplingStrategy_RandomSampleConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (randomSampleConfig != null)
        'randomSampleConfig': randomSampleConfig!.toJson(),
    };
  }

  @override
  String toString() => 'SamplingStrategy()';
}

/// Requests are randomly selected.
final class SamplingStrategy_RandomSampleConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SamplingStrategy.RandomSampleConfig';

  /// Sample rate (0, 1]
  final double? sampleRate;

  SamplingStrategy_RandomSampleConfig({this.sampleRate})
    : super(fullyQualifiedName);

  factory SamplingStrategy_RandomSampleConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return SamplingStrategy_RandomSampleConfig(
      sampleRate: decodeDouble(json['sampleRate']),
    );
  }

  @override
  Object toJson() {
    return {if (sampleRate != null) 'sampleRate': encodeDouble(sampleRate)};
  }

  @override
  String toString() {
    final contents = [
      if (sampleRate != null) 'sampleRate=$sampleRate',
    ].join(',');
    return 'RandomSampleConfig($contents)';
  }
}

/// Monitoring alert triggered condition.
final class ModelMonitoringAlertCondition extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAlertCondition';

  /// A condition that compares a stats value against a threshold. Alert will
  /// be triggered if value above the threshold.
  final double? threshold;

  ModelMonitoringAlertCondition({this.threshold}) : super(fullyQualifiedName);

  factory ModelMonitoringAlertCondition.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringAlertCondition(
      threshold: decodeDouble(json['threshold']),
    );
  }

  @override
  Object toJson() {
    return {if (threshold != null) 'threshold': encodeDouble(threshold)};
  }

  @override
  String toString() {
    final contents = [if (threshold != null) 'threshold=$threshold'].join(',');
    return 'ModelMonitoringAlertCondition($contents)';
  }
}

/// Represents a single model monitoring anomaly.
final class ModelMonitoringAnomaly extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAnomaly';

  /// Tabular anomaly.
  final ModelMonitoringAnomaly_TabularAnomaly? tabularAnomaly;

  /// Model monitoring job resource name.
  final String? modelMonitoringJob;

  /// Algorithm used to calculated the metrics, eg: jensen_shannon_divergence,
  /// l_infinity.
  final String? algorithm;

  ModelMonitoringAnomaly({
    this.tabularAnomaly,
    this.modelMonitoringJob,
    this.algorithm,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringAnomaly.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringAnomaly(
      tabularAnomaly: decode(
        json['tabularAnomaly'],
        ModelMonitoringAnomaly_TabularAnomaly.fromJson,
      ),
      modelMonitoringJob: json['modelMonitoringJob'],
      algorithm: json['algorithm'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tabularAnomaly != null) 'tabularAnomaly': tabularAnomaly!.toJson(),
      if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob,
      if (algorithm != null) 'algorithm': algorithm,
    };
  }

  @override
  String toString() {
    final contents = [
      if (modelMonitoringJob != null) 'modelMonitoringJob=$modelMonitoringJob',
      if (algorithm != null) 'algorithm=$algorithm',
    ].join(',');
    return 'ModelMonitoringAnomaly($contents)';
  }
}

/// Tabular anomaly details.
final class ModelMonitoringAnomaly_TabularAnomaly
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAnomaly.TabularAnomaly';

  /// Additional anomaly information. e.g. Google Cloud Storage uri.
  final String? anomalyUri;

  /// Overview of this anomaly.
  final String? summary;

  /// Anomaly body.
  final protobuf.Value? anomaly;

  /// The time the anomaly was triggered.
  final protobuf.Timestamp? triggerTime;

  /// The alert condition associated with this anomaly.
  final ModelMonitoringAlertCondition? condition;

  ModelMonitoringAnomaly_TabularAnomaly({
    this.anomalyUri,
    this.summary,
    this.anomaly,
    this.triggerTime,
    this.condition,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringAnomaly_TabularAnomaly.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringAnomaly_TabularAnomaly(
      anomalyUri: json['anomalyUri'],
      summary: json['summary'],
      anomaly: decodeCustom(json['anomaly'], protobuf.Value.fromJson),
      triggerTime: decodeCustom(
        json['triggerTime'],
        protobuf.Timestamp.fromJson,
      ),
      condition: decode(
        json['condition'],
        ModelMonitoringAlertCondition.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (anomalyUri != null) 'anomalyUri': anomalyUri,
      if (summary != null) 'summary': summary,
      if (anomaly != null) 'anomaly': anomaly!.toJson(),
      if (triggerTime != null) 'triggerTime': triggerTime!.toJson(),
      if (condition != null) 'condition': condition!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (anomalyUri != null) 'anomalyUri=$anomalyUri',
      if (summary != null) 'summary=$summary',
    ].join(',');
    return 'TabularAnomaly($contents)';
  }
}

/// Represents a single monitoring alert. This is currently used in the
/// SearchModelMonitoringAlerts api, thus the alert wrapped in this message
/// belongs to the resource asked in the request.
final class ModelMonitoringAlert extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringAlert';

  /// The stats name.
  final String? statsName;

  /// One of the supported monitoring objectives:
  /// `raw-feature-drift`
  /// `prediction-output-drift`
  /// `feature-attribution`
  final String? objectiveType;

  /// Alert creation time.
  final protobuf.Timestamp? alertTime;

  /// Anomaly details.
  final ModelMonitoringAnomaly? anomaly;

  ModelMonitoringAlert({
    this.statsName,
    this.objectiveType,
    this.alertTime,
    this.anomaly,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringAlert.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringAlert(
      statsName: json['statsName'],
      objectiveType: json['objectiveType'],
      alertTime: decodeCustom(json['alertTime'], protobuf.Timestamp.fromJson),
      anomaly: decode(json['anomaly'], ModelMonitoringAnomaly.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (statsName != null) 'statsName': statsName,
      if (objectiveType != null) 'objectiveType': objectiveType,
      if (alertTime != null) 'alertTime': alertTime!.toJson(),
      if (anomaly != null) 'anomaly': anomaly!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (statsName != null) 'statsName=$statsName',
      if (objectiveType != null) 'objectiveType=$objectiveType',
    ].join(',');
    return 'ModelMonitoringAlert($contents)';
  }
}

/// Represents a model monitoring job that analyze dataset using different
/// monitoring algorithm.
final class ModelMonitoringJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringJob';

  /// Output only. Resource name of a ModelMonitoringJob. Format:
  /// `projects/{project_id}/locations/{location_id}/modelMonitors/{model_monitor_id}/modelMonitoringJobs/{model_monitoring_job_id}`
  final String? name;

  /// The display name of the ModelMonitoringJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8.
  final String? displayName;

  /// Monitoring monitoring job spec. It outlines the specifications for
  /// monitoring objectives, notifications, and result exports. If left blank,
  /// the default monitoring specifications from the top-level resource
  /// 'ModelMonitor' will be applied. If provided, we will use the specification
  /// defined here rather than the default one.
  final ModelMonitoringSpec? modelMonitoringSpec;

  /// Output only. Timestamp when this ModelMonitoringJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ModelMonitoringJob was updated most
  /// recently.
  final protobuf.Timestamp? updateTime;

  /// Output only. The state of the monitoring job.
  ///  * When the job is still creating, the state will be 'JOB_STATE_PENDING'.
  ///  * Once the job is successfully created, the state will be
  ///    'JOB_STATE_RUNNING'.
  ///  * Once the job is finished, the state will be one of
  ///    'JOB_STATE_FAILED', 'JOB_STATE_SUCCEEDED',
  ///    'JOB_STATE_PARTIALLY_SUCCEEDED'.
  final JobState? state;

  /// Output only. Schedule resource name. It will only appear when this job is
  /// triggered by a schedule.
  final String? schedule;

  /// Output only. Execution results for all the monitoring objectives.
  final ModelMonitoringJobExecutionDetail? jobExecutionDetail;

  /// Output only. Timestamp when this ModelMonitoringJob was scheduled. It will
  /// only appear when this job is triggered by a schedule.
  final protobuf.Timestamp? scheduleTime;

  ModelMonitoringJob({
    this.name,
    this.displayName,
    this.modelMonitoringSpec,
    this.createTime,
    this.updateTime,
    this.state,
    this.schedule,
    this.jobExecutionDetail,
    this.scheduleTime,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringJob.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringJob(
      name: json['name'],
      displayName: json['displayName'],
      modelMonitoringSpec: decode(
        json['modelMonitoringSpec'],
        ModelMonitoringSpec.fromJson,
      ),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      state: decodeEnum(json['state'], JobState.fromJson),
      schedule: json['schedule'],
      jobExecutionDetail: decode(
        json['jobExecutionDetail'],
        ModelMonitoringJobExecutionDetail.fromJson,
      ),
      scheduleTime: decodeCustom(
        json['scheduleTime'],
        protobuf.Timestamp.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (modelMonitoringSpec != null)
        'modelMonitoringSpec': modelMonitoringSpec!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (schedule != null) 'schedule': schedule,
      if (jobExecutionDetail != null)
        'jobExecutionDetail': jobExecutionDetail!.toJson(),
      if (scheduleTime != null) 'scheduleTime': scheduleTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (state != null) 'state=$state',
      if (schedule != null) 'schedule=$schedule',
    ].join(',');
    return 'ModelMonitoringJob($contents)';
  }
}

/// Represent the execution details of the job.
final class ModelMonitoringJobExecutionDetail extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringJobExecutionDetail';

  /// Processed baseline datasets.
  final List<ModelMonitoringJobExecutionDetail_ProcessedDataset>?
  baselineDatasets;

  /// Processed target datasets.
  final List<ModelMonitoringJobExecutionDetail_ProcessedDataset>?
  targetDatasets;

  /// Status of data processing for each monitoring objective.
  /// Key is the objective.
  final Map<String, Status>? objectiveStatus;

  /// Additional job error status.
  final Status? error;

  ModelMonitoringJobExecutionDetail({
    this.baselineDatasets,
    this.targetDatasets,
    this.objectiveStatus,
    this.error,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringJobExecutionDetail.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringJobExecutionDetail(
      baselineDatasets: decodeListMessage(
        json['baselineDatasets'],
        ModelMonitoringJobExecutionDetail_ProcessedDataset.fromJson,
      ),
      targetDatasets: decodeListMessage(
        json['targetDatasets'],
        ModelMonitoringJobExecutionDetail_ProcessedDataset.fromJson,
      ),
      objectiveStatus: decodeMapMessage(
        json['objectiveStatus'],
        Status.fromJson,
      ),
      error: decode(json['error'], Status.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (baselineDatasets != null)
        'baselineDatasets': encodeList(baselineDatasets),
      if (targetDatasets != null) 'targetDatasets': encodeList(targetDatasets),
      if (objectiveStatus != null)
        'objectiveStatus': encodeMap(objectiveStatus),
      if (error != null) 'error': error!.toJson(),
    };
  }

  @override
  String toString() => 'ModelMonitoringJobExecutionDetail()';
}

/// Processed dataset information.
final class ModelMonitoringJobExecutionDetail_ProcessedDataset
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringJobExecutionDetail.ProcessedDataset';

  /// Actual data location of the processed dataset.
  final String? location;

  /// Dataset time range information if any.
  final Interval? timeRange;

  ModelMonitoringJobExecutionDetail_ProcessedDataset({
    this.location,
    this.timeRange,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringJobExecutionDetail_ProcessedDataset.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringJobExecutionDetail_ProcessedDataset(
      location: json['location'],
      timeRange: decode(json['timeRange'], Interval.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (location != null) 'location': location,
      if (timeRange != null) 'timeRange': timeRange!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (location != null) 'location=$location'].join(',');
    return 'ProcessedDataset($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.CreateModelMonitor`.
final class CreateModelMonitorRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateModelMonitorRequest';

  /// Required. The resource name of the Location to create the ModelMonitor in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The ModelMonitor to create.
  final ModelMonitor modelMonitor;

  /// Optional. The ID to use for the Model Monitor, which will become the final
  /// component of the model monitor resource name.
  ///
  /// The maximum length is 63 characters, and valid characters are
  /// `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  final String? modelMonitorId;

  CreateModelMonitorRequest({
    required this.parent,
    required this.modelMonitor,
    this.modelMonitorId,
  }) : super(fullyQualifiedName);

  factory CreateModelMonitorRequest.fromJson(Map<String, dynamic> json) {
    return CreateModelMonitorRequest(
      parent: json['parent'],
      modelMonitor: decode(json['modelMonitor'], ModelMonitor.fromJson)!,
      modelMonitorId: json['modelMonitorId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'modelMonitor': modelMonitor.toJson(),
      if (modelMonitorId != null) 'modelMonitorId': modelMonitorId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (modelMonitorId != null) 'modelMonitorId=$modelMonitorId',
    ].join(',');
    return 'CreateModelMonitorRequest($contents)';
  }
}

/// Runtime operation information for
/// `ModelMonitoringService.CreateModelMonitor`.
final class CreateModelMonitorOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateModelMonitorOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateModelMonitorOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateModelMonitorOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateModelMonitorOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateModelMonitorOperationMetadata()';
}

/// Request message for
/// `ModelMonitoringService.UpdateModelMonitor`.
final class UpdateModelMonitorRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelMonitorRequest';

  /// Required. The model monitoring configuration which replaces the resource on
  /// the server.
  final ModelMonitor modelMonitor;

  /// Required. Mask specifying which fields to update.
  final protobuf.FieldMask? updateMask;

  UpdateModelMonitorRequest({required this.modelMonitor, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateModelMonitorRequest.fromJson(Map<String, dynamic> json) {
    return UpdateModelMonitorRequest(
      modelMonitor: decode(json['modelMonitor'], ModelMonitor.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'modelMonitor': modelMonitor.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateModelMonitorRequest()';
}

/// Runtime operation information for
/// `ModelMonitoringService.UpdateModelMonitor`.
final class UpdateModelMonitorOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelMonitorOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateModelMonitorOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateModelMonitorOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateModelMonitorOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateModelMonitorOperationMetadata()';
}

/// Request message for
/// `ModelMonitoringService.GetModelMonitor`.
final class GetModelMonitorRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelMonitorRequest';

  /// Required. The name of the ModelMonitor resource.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  final String name;

  GetModelMonitorRequest({required this.name}) : super(fullyQualifiedName);

  factory GetModelMonitorRequest.fromJson(Map<String, dynamic> json) {
    return GetModelMonitorRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelMonitorRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.ListModelMonitors`.
final class ListModelMonitorsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelMonitorsRequest';

  /// Required. The resource name of the Location to list the ModelMonitors from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListModelMonitorsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelMonitorsRequest.fromJson(Map<String, dynamic> json) {
    return ListModelMonitorsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListModelMonitorsRequest($contents)';
  }
}

/// Response message for
/// `ModelMonitoringService.ListModelMonitors`
final class ListModelMonitorsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelMonitorsResponse';

  /// List of ModelMonitor in the requested page.
  final List<ModelMonitor>? modelMonitors;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListModelMonitorsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListModelMonitorsResponse({this.modelMonitors, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListModelMonitorsResponse.fromJson(Map<String, dynamic> json) {
    return ListModelMonitorsResponse(
      modelMonitors: decodeListMessage(
        json['modelMonitors'],
        ModelMonitor.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (modelMonitors != null) 'modelMonitors': encodeList(modelMonitors),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListModelMonitorsResponse($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.DeleteModelMonitor`.
final class DeleteModelMonitorRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelMonitorRequest';

  /// Required. The name of the ModelMonitor resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitords/{model_monitor}`
  final String name;

  /// Optional. Force delete the model monitor with schedules.
  final bool? force;

  DeleteModelMonitorRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteModelMonitorRequest.fromJson(Map<String, dynamic> json) {
    return DeleteModelMonitorRequest(name: json['name'], force: json['force']);
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteModelMonitorRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.CreateModelMonitoringJob`.
final class CreateModelMonitoringJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateModelMonitoringJobRequest';

  /// Required. The parent of the ModelMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMoniitors/{model_monitor}`
  final String parent;

  /// Required. The ModelMonitoringJob to create
  final ModelMonitoringJob modelMonitoringJob;

  /// Optional. The ID to use for the Model Monitoring Job, which will become the
  /// final component of the model monitoring job resource name.
  ///
  /// The maximum length is 63 characters, and valid characters are
  /// `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  final String? modelMonitoringJobId;

  CreateModelMonitoringJobRequest({
    required this.parent,
    required this.modelMonitoringJob,
    this.modelMonitoringJobId,
  }) : super(fullyQualifiedName);

  factory CreateModelMonitoringJobRequest.fromJson(Map<String, dynamic> json) {
    return CreateModelMonitoringJobRequest(
      parent: json['parent'],
      modelMonitoringJob: decode(
        json['modelMonitoringJob'],
        ModelMonitoringJob.fromJson,
      )!,
      modelMonitoringJobId: json['modelMonitoringJobId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'modelMonitoringJob': modelMonitoringJob.toJson(),
      if (modelMonitoringJobId != null)
        'modelMonitoringJobId': modelMonitoringJobId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (modelMonitoringJobId != null)
        'modelMonitoringJobId=$modelMonitoringJobId',
    ].join(',');
    return 'CreateModelMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.GetModelMonitoringJob`.
final class GetModelMonitoringJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelMonitoringJobRequest';

  /// Required. The resource name of the ModelMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}/modelMonitoringJobs/{model_monitoring_job}`
  final String name;

  GetModelMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetModelMonitoringJobRequest.fromJson(Map<String, dynamic> json) {
    return GetModelMonitoringJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.ListModelMonitoringJobs`.
final class ListModelMonitoringJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelMonitoringJobsRequest';

  /// Required. The parent of the ModelMonitoringJob.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  final String parent;

  /// The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  final String? pageToken;

  /// Mask specifying which fields to read
  final protobuf.FieldMask? readMask;

  ListModelMonitoringJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelMonitoringJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListModelMonitoringJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListModelMonitoringJobsRequest($contents)';
  }
}

/// Response message for
/// `ModelMonitoringService.ListModelMonitoringJobs`.
final class ListModelMonitoringJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelMonitoringJobsResponse';

  /// A list of ModelMonitoringJobs that matches the specified filter
  /// in the request.
  final List<ModelMonitoringJob>? modelMonitoringJobs;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListModelMonitoringJobsResponse({
    this.modelMonitoringJobs,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListModelMonitoringJobsResponse.fromJson(Map<String, dynamic> json) {
    return ListModelMonitoringJobsResponse(
      modelMonitoringJobs: decodeListMessage(
        json['modelMonitoringJobs'],
        ModelMonitoringJob.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (modelMonitoringJobs != null)
        'modelMonitoringJobs': encodeList(modelMonitoringJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListModelMonitoringJobsResponse($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.DeleteModelMonitoringJob`.
final class DeleteModelMonitoringJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelMonitoringJobRequest';

  /// Required. The resource name of the model monitoring job to delete.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}/modelMonitoringJobs/{model_monitoring_job}`
  final String name;

  DeleteModelMonitoringJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteModelMonitoringJobRequest.fromJson(Map<String, dynamic> json) {
    return DeleteModelMonitoringJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteModelMonitoringJobRequest($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.SearchModelMonitoringStats`.
final class SearchModelMonitoringStatsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringStatsRequest';

  /// Required. ModelMonitor resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  final String modelMonitor;

  /// Filter for search different stats.
  final SearchModelMonitoringStatsFilter? statsFilter;

  /// The time interval for which results should be returned.
  final Interval? timeInterval;

  /// The standard list page size.
  final int? pageSize;

  /// A page token received from a previous
  /// `ModelMonitoringService.SearchModelMonitoringStats`
  /// call.
  final String? pageToken;

  SearchModelMonitoringStatsRequest({
    required this.modelMonitor,
    this.statsFilter,
    this.timeInterval,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringStatsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchModelMonitoringStatsRequest(
      modelMonitor: json['modelMonitor'],
      statsFilter: decode(
        json['statsFilter'],
        SearchModelMonitoringStatsFilter.fromJson,
      ),
      timeInterval: decode(json['timeInterval'], Interval.fromJson),
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'modelMonitor': modelMonitor,
      if (statsFilter != null) 'statsFilter': statsFilter!.toJson(),
      if (timeInterval != null) 'timeInterval': timeInterval!.toJson(),
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'modelMonitor=$modelMonitor',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'SearchModelMonitoringStatsRequest($contents)';
  }
}

/// Response message for
/// `ModelMonitoringService.SearchModelMonitoringStats`.
final class SearchModelMonitoringStatsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringStatsResponse';

  /// Stats retrieved for requested objectives.
  final List<ModelMonitoringStats>? monitoringStats;

  /// The page token that can be used by the next
  /// `ModelMonitoringService.SearchModelMonitoringStats`
  /// call.
  final String? nextPageToken;

  SearchModelMonitoringStatsResponse({this.monitoringStats, this.nextPageToken})
    : super(fullyQualifiedName);

  factory SearchModelMonitoringStatsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchModelMonitoringStatsResponse(
      monitoringStats: decodeListMessage(
        json['monitoringStats'],
        ModelMonitoringStats.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (monitoringStats != null)
        'monitoringStats': encodeList(monitoringStats),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'SearchModelMonitoringStatsResponse($contents)';
  }
}

/// Request message for
/// `ModelMonitoringService.SearchModelMonitoringAlerts`.
final class SearchModelMonitoringAlertsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringAlertsRequest';

  /// Required. ModelMonitor resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/modelMonitors/{model_monitor}`
  final String modelMonitor;

  /// If non-empty, returns the alerts of this model monitoring job.
  final String? modelMonitoringJob;

  /// If non-empty, returns the alerts in this time interval.
  final Interval? alertTimeInterval;

  /// If non-empty, returns the alerts of this stats_name.
  final String? statsName;

  /// If non-empty, returns the alerts of this objective type.
  /// Supported monitoring objectives:
  /// `raw-feature-drift`
  /// `prediction-output-drift`
  /// `feature-attribution`
  final String? objectiveType;

  /// The standard list page size.
  final int? pageSize;

  /// A page token received from a previous
  /// `ModelMonitoringService.SearchModelMonitoringAlerts`
  /// call.
  final String? pageToken;

  SearchModelMonitoringAlertsRequest({
    required this.modelMonitor,
    this.modelMonitoringJob,
    this.alertTimeInterval,
    this.statsName,
    this.objectiveType,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringAlertsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchModelMonitoringAlertsRequest(
      modelMonitor: json['modelMonitor'],
      modelMonitoringJob: json['modelMonitoringJob'],
      alertTimeInterval: decode(json['alertTimeInterval'], Interval.fromJson),
      statsName: json['statsName'],
      objectiveType: json['objectiveType'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'modelMonitor': modelMonitor,
      if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob,
      if (alertTimeInterval != null)
        'alertTimeInterval': alertTimeInterval!.toJson(),
      if (statsName != null) 'statsName': statsName,
      if (objectiveType != null) 'objectiveType': objectiveType,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'modelMonitor=$modelMonitor',
      if (modelMonitoringJob != null) 'modelMonitoringJob=$modelMonitoringJob',
      if (statsName != null) 'statsName=$statsName',
      if (objectiveType != null) 'objectiveType=$objectiveType',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'SearchModelMonitoringAlertsRequest($contents)';
  }
}

/// Response message for
/// `ModelMonitoringService.SearchModelMonitoringAlerts`.
final class SearchModelMonitoringAlertsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringAlertsResponse';

  /// Alerts retrieved for the requested objectives. Sorted by alert time
  /// descendingly.
  final List<ModelMonitoringAlert>? modelMonitoringAlerts;

  /// The total number of alerts retrieved by the requested objectives.
  final int? totalNumberAlerts;

  /// The page token that can be used by the next
  /// `ModelMonitoringService.SearchModelMonitoringAlerts`
  /// call.
  final String? nextPageToken;

  SearchModelMonitoringAlertsResponse({
    this.modelMonitoringAlerts,
    this.totalNumberAlerts,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringAlertsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchModelMonitoringAlertsResponse(
      modelMonitoringAlerts: decodeListMessage(
        json['modelMonitoringAlerts'],
        ModelMonitoringAlert.fromJson,
      ),
      totalNumberAlerts: decodeInt64(json['totalNumberAlerts']),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (modelMonitoringAlerts != null)
        'modelMonitoringAlerts': encodeList(modelMonitoringAlerts),
      if (totalNumberAlerts != null)
        'totalNumberAlerts': encodeInt64(totalNumberAlerts),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (totalNumberAlerts != null) 'totalNumberAlerts=$totalNumberAlerts',
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'SearchModelMonitoringAlertsResponse($contents)';
  }
}

/// Monitoring monitoring job spec. It outlines the specifications for monitoring
/// objectives, notifications, and result exports.
final class ModelMonitoringSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringSpec';

  /// The monitoring objective spec.
  final ModelMonitoringObjectiveSpec? objectiveSpec;

  /// The model monitoring notification spec.
  final ModelMonitoringNotificationSpec? notificationSpec;

  /// The Output destination spec for metrics, error logs, etc.
  final ModelMonitoringOutputSpec? outputSpec;

  ModelMonitoringSpec({
    this.objectiveSpec,
    this.notificationSpec,
    this.outputSpec,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringSpec.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringSpec(
      objectiveSpec: decode(
        json['objectiveSpec'],
        ModelMonitoringObjectiveSpec.fromJson,
      ),
      notificationSpec: decode(
        json['notificationSpec'],
        ModelMonitoringNotificationSpec.fromJson,
      ),
      outputSpec: decode(
        json['outputSpec'],
        ModelMonitoringOutputSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (objectiveSpec != null) 'objectiveSpec': objectiveSpec!.toJson(),
      if (notificationSpec != null)
        'notificationSpec': notificationSpec!.toJson(),
      if (outputSpec != null) 'outputSpec': outputSpec!.toJson(),
    };
  }

  @override
  String toString() => 'ModelMonitoringSpec()';
}

/// Monitoring objectives spec.
final class ModelMonitoringObjectiveSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveSpec';

  /// Tabular monitoring objective.
  final ModelMonitoringObjectiveSpec_TabularObjective? tabularObjective;

  /// The explanation spec.
  /// This spec is required when the objectives spec includes feature attribution
  /// objectives.
  final ExplanationSpec? explanationSpec;

  /// Baseline dataset.
  /// It could be the training dataset or production serving dataset from a
  /// previous period.
  final ModelMonitoringInput? baselineDataset;

  /// Target dataset.
  final ModelMonitoringInput? targetDataset;

  ModelMonitoringObjectiveSpec({
    this.tabularObjective,
    this.explanationSpec,
    this.baselineDataset,
    this.targetDataset,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveSpec.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringObjectiveSpec(
      tabularObjective: decode(
        json['tabularObjective'],
        ModelMonitoringObjectiveSpec_TabularObjective.fromJson,
      ),
      explanationSpec: decode(
        json['explanationSpec'],
        ExplanationSpec.fromJson,
      ),
      baselineDataset: decode(
        json['baselineDataset'],
        ModelMonitoringInput.fromJson,
      ),
      targetDataset: decode(
        json['targetDataset'],
        ModelMonitoringInput.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (tabularObjective != null)
        'tabularObjective': tabularObjective!.toJson(),
      if (explanationSpec != null) 'explanationSpec': explanationSpec!.toJson(),
      if (baselineDataset != null) 'baselineDataset': baselineDataset!.toJson(),
      if (targetDataset != null) 'targetDataset': targetDataset!.toJson(),
    };
  }

  @override
  String toString() => 'ModelMonitoringObjectiveSpec()';
}

/// Data drift monitoring spec.
/// Data drift measures the distribution distance between the current dataset
/// and a baseline dataset. A typical use case is to detect data drift between
/// the recent production serving dataset and the training dataset, or to
/// compare the recent production dataset with a dataset from a previous
/// period.
final class ModelMonitoringObjectiveSpec_DataDriftSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveSpec.DataDriftSpec';

  /// Feature names / Prediction output names interested in monitoring.
  /// These should be a subset of the input feature names or prediction output
  /// names specified in the monitoring schema.
  /// If the field is not specified all features / prediction outputs outlied
  /// in the monitoring schema will be used.
  final List<String>? features;

  /// Supported metrics type:
  ///  * l_infinity
  ///  * jensen_shannon_divergence
  final String? categoricalMetricType;

  /// Supported metrics type:
  ///  * jensen_shannon_divergence
  final String? numericMetricType;

  /// Default alert condition for all the categorical features.
  final ModelMonitoringAlertCondition? defaultCategoricalAlertCondition;

  /// Default alert condition for all the numeric features.
  final ModelMonitoringAlertCondition? defaultNumericAlertCondition;

  /// Per feature alert condition will override default alert condition.
  final Map<String, ModelMonitoringAlertCondition>? featureAlertConditions;

  ModelMonitoringObjectiveSpec_DataDriftSpec({
    this.features,
    this.categoricalMetricType,
    this.numericMetricType,
    this.defaultCategoricalAlertCondition,
    this.defaultNumericAlertCondition,
    this.featureAlertConditions,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveSpec_DataDriftSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringObjectiveSpec_DataDriftSpec(
      features: decodeList(json['features']),
      categoricalMetricType: json['categoricalMetricType'],
      numericMetricType: json['numericMetricType'],
      defaultCategoricalAlertCondition: decode(
        json['defaultCategoricalAlertCondition'],
        ModelMonitoringAlertCondition.fromJson,
      ),
      defaultNumericAlertCondition: decode(
        json['defaultNumericAlertCondition'],
        ModelMonitoringAlertCondition.fromJson,
      ),
      featureAlertConditions: decodeMapMessage(
        json['featureAlertConditions'],
        ModelMonitoringAlertCondition.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (features != null) 'features': features,
      if (categoricalMetricType != null)
        'categoricalMetricType': categoricalMetricType,
      if (numericMetricType != null) 'numericMetricType': numericMetricType,
      if (defaultCategoricalAlertCondition != null)
        'defaultCategoricalAlertCondition': defaultCategoricalAlertCondition!
            .toJson(),
      if (defaultNumericAlertCondition != null)
        'defaultNumericAlertCondition': defaultNumericAlertCondition!.toJson(),
      if (featureAlertConditions != null)
        'featureAlertConditions': encodeMap(featureAlertConditions),
    };
  }

  @override
  String toString() {
    final contents = [
      if (categoricalMetricType != null)
        'categoricalMetricType=$categoricalMetricType',
      if (numericMetricType != null) 'numericMetricType=$numericMetricType',
    ].join(',');
    return 'DataDriftSpec($contents)';
  }
}

/// Feature attribution monitoring spec.
final class ModelMonitoringObjectiveSpec_FeatureAttributionSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveSpec.FeatureAttributionSpec';

  /// Feature names interested in monitoring.
  /// These should be a subset of the input feature names specified in the
  /// monitoring schema. If the field is not specified all features outlied in
  /// the monitoring schema will be used.
  final List<String>? features;

  /// Default alert condition for all the features.
  final ModelMonitoringAlertCondition? defaultAlertCondition;

  /// Per feature alert condition will override default alert condition.
  final Map<String, ModelMonitoringAlertCondition>? featureAlertConditions;

  /// The config of resources used by the Model Monitoring during the batch
  /// explanation for non-AutoML models. If not set, `n1-standard-2` machine
  /// type will be used by default.
  final BatchDedicatedResources? batchExplanationDedicatedResources;

  ModelMonitoringObjectiveSpec_FeatureAttributionSpec({
    this.features,
    this.defaultAlertCondition,
    this.featureAlertConditions,
    this.batchExplanationDedicatedResources,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveSpec_FeatureAttributionSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringObjectiveSpec_FeatureAttributionSpec(
      features: decodeList(json['features']),
      defaultAlertCondition: decode(
        json['defaultAlertCondition'],
        ModelMonitoringAlertCondition.fromJson,
      ),
      featureAlertConditions: decodeMapMessage(
        json['featureAlertConditions'],
        ModelMonitoringAlertCondition.fromJson,
      ),
      batchExplanationDedicatedResources: decode(
        json['batchExplanationDedicatedResources'],
        BatchDedicatedResources.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (features != null) 'features': features,
      if (defaultAlertCondition != null)
        'defaultAlertCondition': defaultAlertCondition!.toJson(),
      if (featureAlertConditions != null)
        'featureAlertConditions': encodeMap(featureAlertConditions),
      if (batchExplanationDedicatedResources != null)
        'batchExplanationDedicatedResources':
            batchExplanationDedicatedResources!.toJson(),
    };
  }

  @override
  String toString() => 'FeatureAttributionSpec()';
}

/// Tabular monitoring objective.
final class ModelMonitoringObjectiveSpec_TabularObjective
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringObjectiveSpec.TabularObjective';

  /// Input feature distribution drift monitoring spec.
  final ModelMonitoringObjectiveSpec_DataDriftSpec? featureDriftSpec;

  /// Prediction output distribution drift monitoring spec.
  final ModelMonitoringObjectiveSpec_DataDriftSpec? predictionOutputDriftSpec;

  /// Feature attribution monitoring spec.
  final ModelMonitoringObjectiveSpec_FeatureAttributionSpec?
  featureAttributionSpec;

  ModelMonitoringObjectiveSpec_TabularObjective({
    this.featureDriftSpec,
    this.predictionOutputDriftSpec,
    this.featureAttributionSpec,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringObjectiveSpec_TabularObjective.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringObjectiveSpec_TabularObjective(
      featureDriftSpec: decode(
        json['featureDriftSpec'],
        ModelMonitoringObjectiveSpec_DataDriftSpec.fromJson,
      ),
      predictionOutputDriftSpec: decode(
        json['predictionOutputDriftSpec'],
        ModelMonitoringObjectiveSpec_DataDriftSpec.fromJson,
      ),
      featureAttributionSpec: decode(
        json['featureAttributionSpec'],
        ModelMonitoringObjectiveSpec_FeatureAttributionSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (featureDriftSpec != null)
        'featureDriftSpec': featureDriftSpec!.toJson(),
      if (predictionOutputDriftSpec != null)
        'predictionOutputDriftSpec': predictionOutputDriftSpec!.toJson(),
      if (featureAttributionSpec != null)
        'featureAttributionSpec': featureAttributionSpec!.toJson(),
    };
  }

  @override
  String toString() => 'TabularObjective()';
}

/// Specification for the export destination of monitoring results, including
/// metrics, logs, etc.
final class ModelMonitoringOutputSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringOutputSpec';

  /// Google Cloud Storage base folder path for metrics, error logs, etc.
  final GcsDestination? gcsBaseDirectory;

  ModelMonitoringOutputSpec({this.gcsBaseDirectory})
    : super(fullyQualifiedName);

  factory ModelMonitoringOutputSpec.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringOutputSpec(
      gcsBaseDirectory: decode(
        json['gcsBaseDirectory'],
        GcsDestination.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsBaseDirectory != null)
        'gcsBaseDirectory': gcsBaseDirectory!.toJson(),
    };
  }

  @override
  String toString() => 'ModelMonitoringOutputSpec()';
}

/// Model monitoring data input spec.
final class ModelMonitoringInput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput';

  /// Columnized dataset.
  final ModelMonitoringInput_ModelMonitoringDataset? columnizedDataset;

  /// Vertex AI Batch prediction Job.
  final ModelMonitoringInput_BatchPredictionOutput? batchPredictionOutput;

  /// Vertex AI Endpoint request & response logging.
  final ModelMonitoringInput_VertexEndpointLogs? vertexEndpointLogs;

  /// The time interval (pair of start_time and end_time) for which results
  /// should be returned.
  final Interval? timeInterval;

  /// The time offset setting for which results should be returned.
  final ModelMonitoringInput_TimeOffset? timeOffset;

  ModelMonitoringInput({
    this.columnizedDataset,
    this.batchPredictionOutput,
    this.vertexEndpointLogs,
    this.timeInterval,
    this.timeOffset,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringInput.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringInput(
      columnizedDataset: decode(
        json['columnizedDataset'],
        ModelMonitoringInput_ModelMonitoringDataset.fromJson,
      ),
      batchPredictionOutput: decode(
        json['batchPredictionOutput'],
        ModelMonitoringInput_BatchPredictionOutput.fromJson,
      ),
      vertexEndpointLogs: decode(
        json['vertexEndpointLogs'],
        ModelMonitoringInput_VertexEndpointLogs.fromJson,
      ),
      timeInterval: decode(json['timeInterval'], Interval.fromJson),
      timeOffset: decode(
        json['timeOffset'],
        ModelMonitoringInput_TimeOffset.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (columnizedDataset != null)
        'columnizedDataset': columnizedDataset!.toJson(),
      if (batchPredictionOutput != null)
        'batchPredictionOutput': batchPredictionOutput!.toJson(),
      if (vertexEndpointLogs != null)
        'vertexEndpointLogs': vertexEndpointLogs!.toJson(),
      if (timeInterval != null) 'timeInterval': timeInterval!.toJson(),
      if (timeOffset != null) 'timeOffset': timeOffset!.toJson(),
    };
  }

  @override
  String toString() => 'ModelMonitoringInput()';
}

/// Input dataset spec.
final class ModelMonitoringInput_ModelMonitoringDataset
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.ModelMonitoringDataset';

  /// Resource name of the Vertex AI managed dataset.
  final String? vertexDataset;

  /// Google Cloud Storage data source.
  final ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource?
  gcsSource;

  /// BigQuery data source.
  final ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource?
  bigquerySource;

  /// The timestamp field. Usually for serving data.
  final String? timestampField;

  ModelMonitoringInput_ModelMonitoringDataset({
    this.vertexDataset,
    this.gcsSource,
    this.bigquerySource,
    this.timestampField,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringInput_ModelMonitoringDataset.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringInput_ModelMonitoringDataset(
      vertexDataset: json['vertexDataset'],
      gcsSource: decode(
        json['gcsSource'],
        ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource
            .fromJson,
      ),
      bigquerySource: decode(
        json['bigquerySource'],
        ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource
            .fromJson,
      ),
      timestampField: json['timestampField'],
    );
  }

  @override
  Object toJson() {
    return {
      if (vertexDataset != null) 'vertexDataset': vertexDataset,
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
      if (bigquerySource != null) 'bigquerySource': bigquerySource!.toJson(),
      if (timestampField != null) 'timestampField': timestampField,
    };
  }

  @override
  String toString() {
    final contents = [
      if (vertexDataset != null) 'vertexDataset=$vertexDataset',
      if (timestampField != null) 'timestampField=$timestampField',
    ].join(',');
    return 'ModelMonitoringDataset($contents)';
  }
}

/// Dataset spec for data stored in Google Cloud Storage.
final class ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.ModelMonitoringDataset.ModelMonitoringGcsSource';

  /// Google Cloud Storage URI to the input file(s). May contain
  /// wildcards. For more information on wildcards, see
  /// https://cloud.google.com/storage/docs/wildcards.
  final String? gcsUri;

  /// Data format of the dataset.
  final ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat?
  format;

  ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource({
    this.gcsUri,
    this.format,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource(
      gcsUri: json['gcsUri'],
      format: decodeEnum(
        json['format'],
        ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsUri != null) 'gcsUri': gcsUri,
      if (format != null) 'format': format!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (gcsUri != null) 'gcsUri=$gcsUri',
      if (format != null) 'format=$format',
    ].join(',');
    return 'ModelMonitoringGcsSource($contents)';
  }
}

/// Supported data format.
final class ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat
    extends protobuf.ProtoEnum {
  /// Data format unspecified, used when this field is unset.
  static const dataFormatUnspecified =
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        'DATA_FORMAT_UNSPECIFIED',
      );

  /// CSV files.
  static const csv =
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        'CSV',
      );

  /// TfRecord files
  static const tfRecord =
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        'TF_RECORD',
      );

  /// JsonL files.
  static const jsonl =
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        'JSONL',
      );

  const ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
    super.value,
  );

  factory ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat.fromJson(
    String json,
  ) =>
      ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringGcsSource_DataFormat(
        json,
      );

  @override
  String toString() => 'DataFormat.$value';
}

/// Dataset spec for data sotred in BigQuery.
final class ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.ModelMonitoringDataset.ModelMonitoringBigQuerySource';

  /// BigQuery URI to a table, up to 2000 characters long. All the columns
  /// in the table will be selected. Accepted forms:
  ///
  /// *  BigQuery path. For example:
  /// `bq://projectId.bqDatasetId.bqTableId`.
  final String? tableUri;

  /// Standard SQL to be used instead of the `table_uri`.
  final String? query;

  ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource({
    this.tableUri,
    this.query,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringInput_ModelMonitoringDataset_ModelMonitoringBigQuerySource(
      tableUri: json['tableUri'],
      query: json['query'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tableUri != null) 'tableUri': tableUri,
      if (query != null) 'query': query,
    };
  }

  @override
  String toString() {
    final contents = [
      if (tableUri != null) 'tableUri=$tableUri',
      if (query != null) 'query=$query',
    ].join(',');
    return 'ModelMonitoringBigQuerySource($contents)';
  }
}

/// Data from Vertex AI Batch prediction job output.
final class ModelMonitoringInput_BatchPredictionOutput
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.BatchPredictionOutput';

  /// Vertex AI Batch prediction job resource name. The job must match the
  /// model version specified in [ModelMonitor].[model_monitoring_target].
  final String? batchPredictionJob;

  ModelMonitoringInput_BatchPredictionOutput({this.batchPredictionJob})
    : super(fullyQualifiedName);

  factory ModelMonitoringInput_BatchPredictionOutput.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringInput_BatchPredictionOutput(
      batchPredictionJob: json['batchPredictionJob'],
    );
  }

  @override
  Object toJson() {
    return {
      if (batchPredictionJob != null) 'batchPredictionJob': batchPredictionJob,
    };
  }

  @override
  String toString() {
    final contents = [
      if (batchPredictionJob != null) 'batchPredictionJob=$batchPredictionJob',
    ].join(',');
    return 'BatchPredictionOutput($contents)';
  }
}

/// Data from Vertex AI Endpoint request response logging.
final class ModelMonitoringInput_VertexEndpointLogs
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.VertexEndpointLogs';

  /// List of endpoint resource names. The endpoints must enable the logging
  /// with the [Endpoint].[request_response_logging_config], and must contain
  /// the deployed model corresponding to the model version specified in
  /// [ModelMonitor].[model_monitoring_target].
  final List<String>? endpoints;

  ModelMonitoringInput_VertexEndpointLogs({this.endpoints})
    : super(fullyQualifiedName);

  factory ModelMonitoringInput_VertexEndpointLogs.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringInput_VertexEndpointLogs(
      endpoints: decodeList(json['endpoints']),
    );
  }

  @override
  Object toJson() {
    return {if (endpoints != null) 'endpoints': endpoints};
  }

  @override
  String toString() => 'VertexEndpointLogs()';
}

/// Time offset setting.
final class ModelMonitoringInput_TimeOffset extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringInput.TimeOffset';

  /// [offset] is the time difference from the cut-off time.
  /// For scheduled jobs, the cut-off time is the scheduled time.
  /// For non-scheduled jobs, it's the time when the job was created.
  /// Currently we support the following format:
  /// 'w|W': Week, 'd|D': Day, 'h|H': Hour
  /// E.g. '1h' stands for 1 hour, '2d' stands for 2 days.
  final String? offset;

  /// [window] refers to the scope of data selected for analysis.
  /// It allows you to specify the quantity of data you wish to examine.
  /// Currently we support the following format:
  /// 'w|W': Week, 'd|D': Day, 'h|H': Hour
  /// E.g. '1h' stands for 1 hour, '2d' stands for 2 days.
  final String? window;

  ModelMonitoringInput_TimeOffset({this.offset, this.window})
    : super(fullyQualifiedName);

  factory ModelMonitoringInput_TimeOffset.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringInput_TimeOffset(
      offset: json['offset'],
      window: json['window'],
    );
  }

  @override
  Object toJson() {
    return {
      if (offset != null) 'offset': offset,
      if (window != null) 'window': window,
    };
  }

  @override
  String toString() {
    final contents = [
      if (offset != null) 'offset=$offset',
      if (window != null) 'window=$window',
    ].join(',');
    return 'TimeOffset($contents)';
  }
}

/// Notification spec(email, notification channel) for model monitoring
/// statistics/alerts.
final class ModelMonitoringNotificationSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringNotificationSpec';

  /// Email alert config.
  final ModelMonitoringNotificationSpec_EmailConfig? emailConfig;

  /// Dump the anomalies to Cloud Logging. The anomalies will be put to json
  /// payload encoded from proto
  /// `google.cloud.aiplatform.logging.ModelMonitoringAnomaliesLogEntry`.
  /// This can be further sinked to Pub/Sub or any other services supported
  /// by Cloud Logging.
  final bool? enableCloudLogging;

  /// Notification channel config.
  final List<ModelMonitoringNotificationSpec_NotificationChannelConfig>?
  notificationChannelConfigs;

  ModelMonitoringNotificationSpec({
    this.emailConfig,
    this.enableCloudLogging,
    this.notificationChannelConfigs,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringNotificationSpec.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringNotificationSpec(
      emailConfig: decode(
        json['emailConfig'],
        ModelMonitoringNotificationSpec_EmailConfig.fromJson,
      ),
      enableCloudLogging: json['enableCloudLogging'],
      notificationChannelConfigs: decodeListMessage(
        json['notificationChannelConfigs'],
        ModelMonitoringNotificationSpec_NotificationChannelConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (emailConfig != null) 'emailConfig': emailConfig!.toJson(),
      if (enableCloudLogging != null) 'enableCloudLogging': enableCloudLogging,
      if (notificationChannelConfigs != null)
        'notificationChannelConfigs': encodeList(notificationChannelConfigs),
    };
  }

  @override
  String toString() {
    final contents = [
      if (enableCloudLogging != null) 'enableCloudLogging=$enableCloudLogging',
    ].join(',');
    return 'ModelMonitoringNotificationSpec($contents)';
  }
}

/// The config for email alerts.
final class ModelMonitoringNotificationSpec_EmailConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringNotificationSpec.EmailConfig';

  /// The email addresses to send the alerts.
  final List<String>? userEmails;

  ModelMonitoringNotificationSpec_EmailConfig({this.userEmails})
    : super(fullyQualifiedName);

  factory ModelMonitoringNotificationSpec_EmailConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringNotificationSpec_EmailConfig(
      userEmails: decodeList(json['userEmails']),
    );
  }

  @override
  Object toJson() {
    return {if (userEmails != null) 'userEmails': userEmails};
  }

  @override
  String toString() => 'EmailConfig()';
}

/// Google Cloud Notification Channel config.
final class ModelMonitoringNotificationSpec_NotificationChannelConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringNotificationSpec.NotificationChannelConfig';

  /// Resource names of the NotificationChannels.
  /// Must be of the format
  /// `projects/<project_id_or_number>/notificationChannels/<channel_id>`
  final String? notificationChannel;

  ModelMonitoringNotificationSpec_NotificationChannelConfig({
    this.notificationChannel,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringNotificationSpec_NotificationChannelConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringNotificationSpec_NotificationChannelConfig(
      notificationChannel: json['notificationChannel'],
    );
  }

  @override
  Object toJson() {
    return {
      if (notificationChannel != null)
        'notificationChannel': notificationChannel,
    };
  }

  @override
  String toString() {
    final contents = [
      if (notificationChannel != null)
        'notificationChannel=$notificationChannel',
    ].join(',');
    return 'NotificationChannelConfig($contents)';
  }
}

/// Represents the collection of statistics for a metric.
final class ModelMonitoringStats extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStats';

  /// Generated tabular statistics.
  final ModelMonitoringTabularStats? tabularStats;

  ModelMonitoringStats({this.tabularStats}) : super(fullyQualifiedName);

  factory ModelMonitoringStats.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringStats(
      tabularStats: decode(
        json['tabularStats'],
        ModelMonitoringTabularStats.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (tabularStats != null) 'tabularStats': tabularStats!.toJson()};
  }

  @override
  String toString() => 'ModelMonitoringStats()';
}

/// Represents a single statistics data point.
final class ModelMonitoringStatsDataPoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsDataPoint';

  /// Statistics from current dataset.
  final ModelMonitoringStatsDataPoint_TypedValue? currentStats;

  /// Statistics from baseline dataset.
  final ModelMonitoringStatsDataPoint_TypedValue? baselineStats;

  /// Threshold value.
  final double? thresholdValue;

  /// Indicate if the statistics has anomaly.
  final bool? hasAnomaly;

  /// Model monitoring job resource name.
  final String? modelMonitoringJob;

  /// Schedule resource name.
  final String? schedule;

  /// Statistics create time.
  final protobuf.Timestamp? createTime;

  /// Algorithm used to calculated the metrics, eg: jensen_shannon_divergence,
  /// l_infinity.
  final String? algorithm;

  ModelMonitoringStatsDataPoint({
    this.currentStats,
    this.baselineStats,
    this.thresholdValue,
    this.hasAnomaly,
    this.modelMonitoringJob,
    this.schedule,
    this.createTime,
    this.algorithm,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsDataPoint.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringStatsDataPoint(
      currentStats: decode(
        json['currentStats'],
        ModelMonitoringStatsDataPoint_TypedValue.fromJson,
      ),
      baselineStats: decode(
        json['baselineStats'],
        ModelMonitoringStatsDataPoint_TypedValue.fromJson,
      ),
      thresholdValue: decodeDouble(json['thresholdValue']),
      hasAnomaly: json['hasAnomaly'],
      modelMonitoringJob: json['modelMonitoringJob'],
      schedule: json['schedule'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      algorithm: json['algorithm'],
    );
  }

  @override
  Object toJson() {
    return {
      if (currentStats != null) 'currentStats': currentStats!.toJson(),
      if (baselineStats != null) 'baselineStats': baselineStats!.toJson(),
      if (thresholdValue != null)
        'thresholdValue': encodeDouble(thresholdValue),
      if (hasAnomaly != null) 'hasAnomaly': hasAnomaly,
      if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob,
      if (schedule != null) 'schedule': schedule,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (algorithm != null) 'algorithm': algorithm,
    };
  }

  @override
  String toString() {
    final contents = [
      if (thresholdValue != null) 'thresholdValue=$thresholdValue',
      if (hasAnomaly != null) 'hasAnomaly=$hasAnomaly',
      if (modelMonitoringJob != null) 'modelMonitoringJob=$modelMonitoringJob',
      if (schedule != null) 'schedule=$schedule',
      if (algorithm != null) 'algorithm=$algorithm',
    ].join(',');
    return 'ModelMonitoringStatsDataPoint($contents)';
  }
}

/// Typed value of the statistics.
final class ModelMonitoringStatsDataPoint_TypedValue
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsDataPoint.TypedValue';

  /// Double.
  final double? doubleValue;

  /// Distribution.
  final ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue?
  distributionValue;

  ModelMonitoringStatsDataPoint_TypedValue({
    this.doubleValue,
    this.distributionValue,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsDataPoint_TypedValue.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringStatsDataPoint_TypedValue(
      doubleValue: decodeDouble(json['doubleValue']),
      distributionValue: decode(
        json['distributionValue'],
        ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (doubleValue != null) 'doubleValue': encodeDouble(doubleValue),
      if (distributionValue != null)
        'distributionValue': distributionValue!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (doubleValue != null) 'doubleValue=$doubleValue',
    ].join(',');
    return 'TypedValue($contents)';
  }
}

/// Summary statistics for a population of values.
final class ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringStatsDataPoint.TypedValue.DistributionDataValue';

  /// Predictive monitoring drift distribution in
  /// `tensorflow.metadata.v0.DatasetFeatureStatistics` format.
  final protobuf.Value? distribution;

  /// Distribution distance deviation from the current dataset's statistics
  /// to baseline dataset's statistics.
  ///   * For categorical feature, the distribution distance is calculated
  ///     by L-inifinity norm or JensenShannon divergence.
  ///   * For numerical feature, the distribution distance is calculated by
  ///     JensenShannon divergence.
  final double? distributionDeviation;

  ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue({
    this.distribution,
    this.distributionDeviation,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue.fromJson(
    Map<String, dynamic> json,
  ) {
    return ModelMonitoringStatsDataPoint_TypedValue_DistributionDataValue(
      distribution: decodeCustom(json['distribution'], protobuf.Value.fromJson),
      distributionDeviation: decodeDouble(json['distributionDeviation']),
    );
  }

  @override
  Object toJson() {
    return {
      if (distribution != null) 'distribution': distribution!.toJson(),
      if (distributionDeviation != null)
        'distributionDeviation': encodeDouble(distributionDeviation),
    };
  }

  @override
  String toString() {
    final contents = [
      if (distributionDeviation != null)
        'distributionDeviation=$distributionDeviation',
    ].join(',');
    return 'DistributionDataValue($contents)';
  }
}

/// A collection of data points that describes the time-varying values of a
/// tabular metric.
final class ModelMonitoringTabularStats extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelMonitoringTabularStats';

  /// The stats name.
  final String? statsName;

  /// One of the supported monitoring objectives:
  /// `raw-feature-drift`
  /// `prediction-output-drift`
  /// `feature-attribution`
  final String? objectiveType;

  /// The data points of this time series. When listing time series, points are
  /// returned in reverse time order.
  final List<ModelMonitoringStatsDataPoint>? dataPoints;

  ModelMonitoringTabularStats({
    this.statsName,
    this.objectiveType,
    this.dataPoints,
  }) : super(fullyQualifiedName);

  factory ModelMonitoringTabularStats.fromJson(Map<String, dynamic> json) {
    return ModelMonitoringTabularStats(
      statsName: json['statsName'],
      objectiveType: json['objectiveType'],
      dataPoints: decodeListMessage(
        json['dataPoints'],
        ModelMonitoringStatsDataPoint.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (statsName != null) 'statsName': statsName,
      if (objectiveType != null) 'objectiveType': objectiveType,
      if (dataPoints != null) 'dataPoints': encodeList(dataPoints),
    };
  }

  @override
  String toString() {
    final contents = [
      if (statsName != null) 'statsName=$statsName',
      if (objectiveType != null) 'objectiveType=$objectiveType',
    ].join(',');
    return 'ModelMonitoringTabularStats($contents)';
  }
}

/// Filter for searching ModelMonitoringStats.
final class SearchModelMonitoringStatsFilter extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringStatsFilter';

  /// Tabular statistics filter.
  final SearchModelMonitoringStatsFilter_TabularStatsFilter? tabularStatsFilter;

  SearchModelMonitoringStatsFilter({this.tabularStatsFilter})
    : super(fullyQualifiedName);

  factory SearchModelMonitoringStatsFilter.fromJson(Map<String, dynamic> json) {
    return SearchModelMonitoringStatsFilter(
      tabularStatsFilter: decode(
        json['tabularStatsFilter'],
        SearchModelMonitoringStatsFilter_TabularStatsFilter.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (tabularStatsFilter != null)
        'tabularStatsFilter': tabularStatsFilter!.toJson(),
    };
  }

  @override
  String toString() => 'SearchModelMonitoringStatsFilter()';
}

/// Tabular statistics filter.
final class SearchModelMonitoringStatsFilter_TabularStatsFilter
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SearchModelMonitoringStatsFilter.TabularStatsFilter';

  /// If not specified, will return all the stats_names.
  final String? statsName;

  /// One of the supported monitoring objectives:
  /// `raw-feature-drift`
  /// `prediction-output-drift`
  /// `feature-attribution`
  final String? objectiveType;

  /// From a particular monitoring job.
  final String? modelMonitoringJob;

  /// From a particular monitoring schedule.
  final String? modelMonitoringSchedule;

  /// Specify the algorithm type used for distance calculation, eg:
  /// jensen_shannon_divergence, l_infinity.
  final String? algorithm;

  SearchModelMonitoringStatsFilter_TabularStatsFilter({
    this.statsName,
    this.objectiveType,
    this.modelMonitoringJob,
    this.modelMonitoringSchedule,
    this.algorithm,
  }) : super(fullyQualifiedName);

  factory SearchModelMonitoringStatsFilter_TabularStatsFilter.fromJson(
    Map<String, dynamic> json,
  ) {
    return SearchModelMonitoringStatsFilter_TabularStatsFilter(
      statsName: json['statsName'],
      objectiveType: json['objectiveType'],
      modelMonitoringJob: json['modelMonitoringJob'],
      modelMonitoringSchedule: json['modelMonitoringSchedule'],
      algorithm: json['algorithm'],
    );
  }

  @override
  Object toJson() {
    return {
      if (statsName != null) 'statsName': statsName,
      if (objectiveType != null) 'objectiveType': objectiveType,
      if (modelMonitoringJob != null) 'modelMonitoringJob': modelMonitoringJob,
      if (modelMonitoringSchedule != null)
        'modelMonitoringSchedule': modelMonitoringSchedule,
      if (algorithm != null) 'algorithm': algorithm,
    };
  }

  @override
  String toString() {
    final contents = [
      if (statsName != null) 'statsName=$statsName',
      if (objectiveType != null) 'objectiveType=$objectiveType',
      if (modelMonitoringJob != null) 'modelMonitoringJob=$modelMonitoringJob',
      if (modelMonitoringSchedule != null)
        'modelMonitoringSchedule=$modelMonitoringSchedule',
      if (algorithm != null) 'algorithm=$algorithm',
    ].join(',');
    return 'TabularStatsFilter($contents)';
  }
}

/// Request message for
/// `ModelService.UploadModel`.
final class UploadModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadModelRequest';

  /// Required. The resource name of the Location into which to upload the Model.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The resource name of the model into which to upload the version.
  /// Only specify this field when uploading a new version.
  final String? parentModel;

  /// Optional. The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  final String? modelId;

  /// Required. The Model to create.
  final Model? model;

  /// Optional. The user-provided custom service account to use to do the model
  /// upload. If empty, [Vertex AI Service
  /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents)
  /// will be used to access resources needed to upload the model. This account
  /// must belong to the target project where the model is uploaded to, i.e., the
  /// project specified in the `parent` field of this request and have necessary
  /// read permissions (to Google Cloud Storage, Artifact Registry, etc.).
  final String? serviceAccount;

  UploadModelRequest({
    required this.parent,
    this.parentModel,
    this.modelId,
    this.model,
    this.serviceAccount,
  }) : super(fullyQualifiedName);

  factory UploadModelRequest.fromJson(Map<String, dynamic> json) {
    return UploadModelRequest(
      parent: json['parent'],
      parentModel: json['parentModel'],
      modelId: json['modelId'],
      model: decode(json['model'], Model.fromJson),
      serviceAccount: json['serviceAccount'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (parentModel != null) 'parentModel': parentModel,
      if (modelId != null) 'modelId': modelId,
      if (model != null) 'model': model!.toJson(),
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (parentModel != null) 'parentModel=$parentModel',
      if (modelId != null) 'modelId=$modelId',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
    ].join(',');
    return 'UploadModelRequest($contents)';
  }
}

/// Details of
/// `ModelService.UploadModel`
/// operation.
final class UploadModelOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadModelOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UploadModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UploadModelOperationMetadata.fromJson(Map<String, dynamic> json) {
    return UploadModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UploadModelOperationMetadata()';
}

/// Response message of
/// `ModelService.UploadModel`
/// operation.
final class UploadModelResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadModelResponse';

  /// The name of the uploaded Model resource.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String? model;

  /// Output only. The version ID of the model that is uploaded.
  final String? modelVersionId;

  UploadModelResponse({this.model, this.modelVersionId})
    : super(fullyQualifiedName);

  factory UploadModelResponse.fromJson(Map<String, dynamic> json) {
    return UploadModelResponse(
      model: json['model'],
      modelVersionId: json['modelVersionId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      if (modelVersionId != null) 'modelVersionId': modelVersionId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (modelVersionId != null) 'modelVersionId=$modelVersionId',
    ].join(',');
    return 'UploadModelResponse($contents)';
  }
}

/// Request message for
/// `ModelService.GetModel`.
final class GetModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelRequest';

  /// Required. The name of the Model resource.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  ///
  /// In order to retrieve a specific version of the model, also provide
  /// the version ID or version alias.
  ///   Example: `projects/{project}/locations/{location}/models/{model}@2`
  ///              or
  ///            `projects/{project}/locations/{location}/models/{model}@golden`
  /// If no version ID or alias is specified, the "default" version will be
  /// returned. The "default" version alias is created for the first version of
  /// the model, and can be moved to other versions later on. There will be
  /// exactly one default version.
  final String name;

  GetModelRequest({required this.name}) : super(fullyQualifiedName);

  factory GetModelRequest.fromJson(Map<String, dynamic> json) {
    return GetModelRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelRequest($contents)';
  }
}

/// Request message for
/// `ModelService.ListModels`.
final class ListModelsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelsRequest';

  /// Required. The resource name of the Location to list the Models from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// An expression for filtering the results of the request. For field names
  /// both snake_case and camelCase are supported.
  ///
  ///   * `model` supports = and !=. `model` represents the Model ID,
  ///     i.e. the last segment of the Model's [resource
  ///     name][google.cloud.aiplatform.v1beta1.Model.name].
  ///   * `display_name` supports = and !=
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:* or labels:key - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///   * `base_model_name` only supports =
  ///
  /// Some examples:
  ///
  ///   * `model=1234`
  ///   * `displayName="myDisplayName"`
  ///   * `labels.myKey="myValue"`
  ///   * `baseModelName="text-bison"`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListModelsResponse.next_page_token`
  /// of the previous
  /// `ModelService.ListModels`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListModelsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelsRequest.fromJson(Map<String, dynamic> json) {
    return ListModelsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListModelsRequest($contents)';
  }
}

/// Response message for
/// `ModelService.ListModels`
final class ListModelsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelsResponse';

  /// List of Models in the requested page.
  final List<Model>? models;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListModelsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListModelsResponse({this.models, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListModelsResponse.fromJson(Map<String, dynamic> json) {
    return ListModelsResponse(
      models: decodeListMessage(json['models'], Model.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (models != null) 'models': encodeList(models),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListModelsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.ListModelVersions`.
final class ListModelVersionsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelVersionsRequest';

  /// Required. The name of the model to list versions for.
  final String name;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `next_page_token`
  /// of the previous
  /// `ListModelVersions`
  /// call.
  final String? pageToken;

  /// An expression for filtering the results of the request. For field names
  /// both snake_case and camelCase are supported.
  ///
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:* or labels:key - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///
  /// Some examples:
  ///
  ///   * `labels.myKey="myValue"`
  final String? filter;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// A comma-separated list of fields to order by, sorted in ascending order.
  /// Use "desc" after a field name for descending.
  /// Supported fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `update_time asc, create_time desc`.
  final String? orderBy;

  ListModelVersionsRequest({
    required this.name,
    this.pageSize,
    this.pageToken,
    this.filter,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListModelVersionsRequest.fromJson(Map<String, dynamic> json) {
    return ListModelVersionsRequest(
      name: json['name'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListModelVersionsRequest($contents)';
  }
}

/// Response message for
/// `ModelService.ListModelVersions`
final class ListModelVersionsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelVersionsResponse';

  /// List of Model versions in the requested page.
  /// In the returned Model name field, version ID instead of regvision tag will
  /// be included.
  final List<Model>? models;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListModelVersionsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListModelVersionsResponse({this.models, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListModelVersionsResponse.fromJson(Map<String, dynamic> json) {
    return ListModelVersionsResponse(
      models: decodeListMessage(json['models'], Model.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (models != null) 'models': encodeList(models),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListModelVersionsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.ListModelVersionCheckpoints`.
final class ListModelVersionCheckpointsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelVersionCheckpointsRequest';

  /// Required. The name of the model version to list checkpoints for.
  /// `projects/{project}/locations/{location}/models/{model}@{version}`
  /// Example: `projects/{project}/locations/{location}/models/{model}@2`
  /// or
  /// `projects/{project}/locations/{location}/models/{model}@golden`
  /// If no version ID or alias is specified, the latest version will be
  /// used.
  final String name;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `next_page_token`
  /// of the previous
  /// `ListModelVersionCheckpoints`
  /// call.
  final String? pageToken;

  ListModelVersionCheckpointsRequest({
    required this.name,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListModelVersionCheckpointsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListModelVersionCheckpointsRequest(
      name: json['name'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListModelVersionCheckpointsRequest($contents)';
  }
}

/// A proto representation of a Spanner-stored ModelVersionCheckpoint.
/// The meaning of the fields is equivalent to their in-Spanner counterparts.
final class ModelVersionCheckpoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ModelVersionCheckpoint';

  /// The ID of the checkpoint.
  final String? checkpointId;

  /// The epoch of the checkpoint.
  final int? epoch;

  /// The step of the checkpoint.
  final int? step;

  ModelVersionCheckpoint({this.checkpointId, this.epoch, this.step})
    : super(fullyQualifiedName);

  factory ModelVersionCheckpoint.fromJson(Map<String, dynamic> json) {
    return ModelVersionCheckpoint(
      checkpointId: json['checkpointId'],
      epoch: decodeInt64(json['epoch']),
      step: decodeInt64(json['step']),
    );
  }

  @override
  Object toJson() {
    return {
      if (checkpointId != null) 'checkpointId': checkpointId,
      if (epoch != null) 'epoch': encodeInt64(epoch),
      if (step != null) 'step': encodeInt64(step),
    };
  }

  @override
  String toString() {
    final contents = [
      if (checkpointId != null) 'checkpointId=$checkpointId',
      if (epoch != null) 'epoch=$epoch',
      if (step != null) 'step=$step',
    ].join(',');
    return 'ModelVersionCheckpoint($contents)';
  }
}

/// Response message for
/// `ModelService.ListModelVersionCheckpoints`
final class ListModelVersionCheckpointsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelVersionCheckpointsResponse';

  /// List of Model Version checkpoints.
  final List<ModelVersionCheckpoint>? checkpoints;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListModelVersionCheckpointsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListModelVersionCheckpointsResponse({this.checkpoints, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListModelVersionCheckpointsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListModelVersionCheckpointsResponse(
      checkpoints: decodeListMessage(
        json['checkpoints'],
        ModelVersionCheckpoint.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (checkpoints != null) 'checkpoints': encodeList(checkpoints),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListModelVersionCheckpointsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.UpdateModel`.
final class UpdateModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateModelRequest';

  /// Required. The Model which replaces the resource on the server.
  /// When Model Versioning is enabled, the model.name will be used to determine
  /// whether to update the model or model version.
  /// 1. model.name with the @ value, e.g. models/123@1, refers to a version
  /// specific update.
  /// 2. model.name without the @ value, e.g. models/123, refers to a model
  /// update.
  /// 3. model.name with @-, e.g. models/123@-, refers to a model update.
  /// 4. Supported model fields: display_name, description; supported
  /// version-specific fields: version_description. Labels are supported in both
  /// scenarios. Both the model labels and the version labels are merged when a
  /// model is returned. When updating labels, if the request is for
  /// model-specific update, model label gets updated. Otherwise, version labels
  /// get updated.
  /// 5. A model name or model version name fields update mismatch will cause a
  /// precondition error.
  /// 6. One request cannot update both the model and the version fields. You
  /// must update them separately.
  final Model model;

  /// Required. The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateModelRequest({required this.model, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateModelRequest.fromJson(Map<String, dynamic> json) {
    return UpdateModelRequest(
      model: decode(json['model'], Model.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'model': model.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateModelRequest()';
}

/// Request message for
/// `ModelService.UpdateExplanationDataset`.
final class UpdateExplanationDatasetRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExplanationDatasetRequest';

  /// Required. The resource name of the Model to update.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String model;

  /// The example config containing the location of the dataset.
  final Examples? examples;

  UpdateExplanationDatasetRequest({required this.model, this.examples})
    : super(fullyQualifiedName);

  factory UpdateExplanationDatasetRequest.fromJson(Map<String, dynamic> json) {
    return UpdateExplanationDatasetRequest(
      model: json['model'],
      examples: decode(json['examples'], Examples.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'model': model,
      if (examples != null) 'examples': examples!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['model=$model'].join(',');
    return 'UpdateExplanationDatasetRequest($contents)';
  }
}

/// Runtime operation information for
/// `ModelService.UpdateExplanationDataset`.
final class UpdateExplanationDatasetOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExplanationDatasetOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UpdateExplanationDatasetOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateExplanationDatasetOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateExplanationDatasetOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateExplanationDatasetOperationMetadata()';
}

/// Request message for
/// `ModelService.DeleteModel`.
final class DeleteModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelRequest';

  /// Required. The name of the Model resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String name;

  DeleteModelRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteModelRequest.fromJson(Map<String, dynamic> json) {
    return DeleteModelRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteModelRequest($contents)';
  }
}

/// Request message for
/// `ModelService.DeleteModelVersion`.
final class DeleteModelVersionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteModelVersionRequest';

  /// Required. The name of the model version to be deleted, with a version ID
  /// explicitly included.
  ///
  /// Example: `projects/{project}/locations/{location}/models/{model}@1234`
  final String name;

  DeleteModelVersionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteModelVersionRequest.fromJson(Map<String, dynamic> json) {
    return DeleteModelVersionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteModelVersionRequest($contents)';
  }
}

/// Request message for
/// `ModelService.MergeVersionAliases`.
final class MergeVersionAliasesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.MergeVersionAliasesRequest';

  /// Required. The name of the model version to merge aliases, with a version ID
  /// explicitly included.
  ///
  /// Example: `projects/{project}/locations/{location}/models/{model}@1234`
  final String name;

  /// Required. The set of version aliases to merge.
  /// The alias should be at most 128 characters, and match
  /// `[a-z][a-zA-Z0-9-]{0,126}[a-z-0-9]`.
  /// Add the `-` prefix to an alias means removing that alias from the version.
  /// `-` is NOT counted in the 128 characters. Example: `-golden` means removing
  /// the `golden` alias from the version.
  ///
  /// There is NO ordering in aliases, which means
  /// 1) The aliases returned from GetModel API might not have the exactly same
  /// order from this MergeVersionAliases API. 2) Adding and deleting the same
  /// alias in the request is not recommended, and the 2 operations will be
  /// cancelled out.
  final List<String>? versionAliases;

  MergeVersionAliasesRequest({required this.name, this.versionAliases})
    : super(fullyQualifiedName);

  factory MergeVersionAliasesRequest.fromJson(Map<String, dynamic> json) {
    return MergeVersionAliasesRequest(
      name: json['name'],
      versionAliases: decodeList(json['versionAliases']),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (versionAliases != null) 'versionAliases': versionAliases,
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'MergeVersionAliasesRequest($contents)';
  }
}

/// Request message for
/// `ModelService.ExportModel`.
final class ExportModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelRequest';

  /// Required. The resource name of the Model to export.
  /// The resource name may contain version id or version alias to specify the
  /// version, if no version is specified, the default version will be exported.
  final String name;

  /// Required. The desired output location and configuration.
  final ExportModelRequest_OutputConfig? outputConfig;

  ExportModelRequest({required this.name, this.outputConfig})
    : super(fullyQualifiedName);

  factory ExportModelRequest.fromJson(Map<String, dynamic> json) {
    return ExportModelRequest(
      name: json['name'],
      outputConfig: decode(
        json['outputConfig'],
        ExportModelRequest_OutputConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (outputConfig != null) 'outputConfig': outputConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ExportModelRequest($contents)';
  }
}

/// Output configuration for the Model export.
final class ExportModelRequest_OutputConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelRequest.OutputConfig';

  /// The ID of the format in which the Model must be exported. Each Model
  /// lists the [export formats it
  /// supports][google.cloud.aiplatform.v1beta1.Model.supported_export_formats].
  /// If no value is provided here, then the first from the list of the Model's
  /// supported formats is used by default.
  final String? exportFormatId;

  /// The Cloud Storage location where the Model artifact is to be
  /// written to. Under the directory given as the destination a new one with
  /// name "`model-export-<model-display-name>-<timestamp-of-export-call>`",
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format,
  /// will be created. Inside, the Model and any of its supporting files
  /// will be written.
  /// This field should only be set when the `exportableContent` field of the
  /// [Model.supported_export_formats] object contains `ARTIFACT`.
  final GcsDestination? artifactDestination;

  /// The Google Container Registry or Artifact Registry uri where the
  /// Model container image will be copied to.
  /// This field should only be set when the `exportableContent` field of the
  /// [Model.supported_export_formats] object contains `IMAGE`.
  final ContainerRegistryDestination? imageDestination;

  ExportModelRequest_OutputConfig({
    this.exportFormatId,
    this.artifactDestination,
    this.imageDestination,
  }) : super(fullyQualifiedName);

  factory ExportModelRequest_OutputConfig.fromJson(Map<String, dynamic> json) {
    return ExportModelRequest_OutputConfig(
      exportFormatId: json['exportFormatId'],
      artifactDestination: decode(
        json['artifactDestination'],
        GcsDestination.fromJson,
      ),
      imageDestination: decode(
        json['imageDestination'],
        ContainerRegistryDestination.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (exportFormatId != null) 'exportFormatId': exportFormatId,
      if (artifactDestination != null)
        'artifactDestination': artifactDestination!.toJson(),
      if (imageDestination != null)
        'imageDestination': imageDestination!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (exportFormatId != null) 'exportFormatId=$exportFormatId',
    ].join(',');
    return 'OutputConfig($contents)';
  }
}

/// Details of
/// `ModelService.ExportModel`
/// operation.
final class ExportModelOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  /// Output only. Information further describing the output of this Model
  /// export.
  final ExportModelOperationMetadata_OutputInfo? outputInfo;

  ExportModelOperationMetadata({this.genericMetadata, this.outputInfo})
    : super(fullyQualifiedName);

  factory ExportModelOperationMetadata.fromJson(Map<String, dynamic> json) {
    return ExportModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      outputInfo: decode(
        json['outputInfo'],
        ExportModelOperationMetadata_OutputInfo.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (outputInfo != null) 'outputInfo': outputInfo!.toJson(),
    };
  }

  @override
  String toString() => 'ExportModelOperationMetadata()';
}

/// Further describes the output of the ExportModel. Supplements
/// `ExportModelRequest.OutputConfig`.
final class ExportModelOperationMetadata_OutputInfo
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelOperationMetadata.OutputInfo';

  /// Output only. If the Model artifact is being exported to Google Cloud
  /// Storage this is the full path of the directory created, into which the
  /// Model files are being written to.
  final String? artifactOutputUri;

  /// Output only. If the Model image is being exported to Google Container
  /// Registry or Artifact Registry this is the full path of the image created.
  final String? imageOutputUri;

  ExportModelOperationMetadata_OutputInfo({
    this.artifactOutputUri,
    this.imageOutputUri,
  }) : super(fullyQualifiedName);

  factory ExportModelOperationMetadata_OutputInfo.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExportModelOperationMetadata_OutputInfo(
      artifactOutputUri: json['artifactOutputUri'],
      imageOutputUri: json['imageOutputUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (artifactOutputUri != null) 'artifactOutputUri': artifactOutputUri,
      if (imageOutputUri != null) 'imageOutputUri': imageOutputUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (artifactOutputUri != null) 'artifactOutputUri=$artifactOutputUri',
      if (imageOutputUri != null) 'imageOutputUri=$imageOutputUri',
    ].join(',');
    return 'OutputInfo($contents)';
  }
}

/// Response message of
/// `ModelService.UpdateExplanationDataset`
/// operation.
final class UpdateExplanationDatasetResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateExplanationDatasetResponse';

  UpdateExplanationDatasetResponse() : super(fullyQualifiedName);

  factory UpdateExplanationDatasetResponse.fromJson(Map<String, dynamic> json) {
    return UpdateExplanationDatasetResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'UpdateExplanationDatasetResponse()';
}

/// Response message of
/// `ModelService.ExportModel`
/// operation.
final class ExportModelResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportModelResponse';

  ExportModelResponse() : super(fullyQualifiedName);

  factory ExportModelResponse.fromJson(Map<String, dynamic> json) {
    return ExportModelResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'ExportModelResponse()';
}

/// Request message for
/// `ModelService.CopyModel`.
final class CopyModelRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CopyModelRequest';

  /// Optional. Copy source_model into a new Model with this ID. The ID will
  /// become the final component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  final String? modelId;

  /// Optional. Specify this field to copy source_model into this existing
  /// Model as a new version. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  final String? parentModel;

  /// Required. The resource name of the Location into which to copy the Model.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The resource name of the Model to copy. That Model must be in the
  /// same Project. Format:
  /// `projects/{project}/locations/{location}/models/{model}`
  final String? sourceModel;

  /// Customer-managed encryption key options. If this is set,
  /// then the Model copy will be encrypted with the provided encryption key.
  final EncryptionSpec? encryptionSpec;

  CopyModelRequest({
    this.modelId,
    this.parentModel,
    required this.parent,
    this.sourceModel,
    this.encryptionSpec,
  }) : super(fullyQualifiedName);

  factory CopyModelRequest.fromJson(Map<String, dynamic> json) {
    return CopyModelRequest(
      modelId: json['modelId'],
      parentModel: json['parentModel'],
      parent: json['parent'],
      sourceModel: json['sourceModel'],
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (modelId != null) 'modelId': modelId,
      if (parentModel != null) 'parentModel': parentModel,
      'parent': parent,
      if (sourceModel != null) 'sourceModel': sourceModel,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (modelId != null) 'modelId=$modelId',
      if (parentModel != null) 'parentModel=$parentModel',
      'parent=$parent',
      if (sourceModel != null) 'sourceModel=$sourceModel',
    ].join(',');
    return 'CopyModelRequest($contents)';
  }
}

/// Details of
/// `ModelService.CopyModel`
/// operation.
final class CopyModelOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CopyModelOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CopyModelOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CopyModelOperationMetadata.fromJson(Map<String, dynamic> json) {
    return CopyModelOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CopyModelOperationMetadata()';
}

/// Response message of
/// `ModelService.CopyModel`
/// operation.
final class CopyModelResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CopyModelResponse';

  /// The name of the copied Model resource.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String? model;

  /// Output only. The version ID of the model that is copied.
  final String? modelVersionId;

  CopyModelResponse({this.model, this.modelVersionId})
    : super(fullyQualifiedName);

  factory CopyModelResponse.fromJson(Map<String, dynamic> json) {
    return CopyModelResponse(
      model: json['model'],
      modelVersionId: json['modelVersionId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      if (modelVersionId != null) 'modelVersionId': modelVersionId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (modelVersionId != null) 'modelVersionId=$modelVersionId',
    ].join(',');
    return 'CopyModelResponse($contents)';
  }
}

/// Request message for
/// `ModelService.ImportModelEvaluation`
final class ImportModelEvaluationRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportModelEvaluationRequest';

  /// Required. The name of the parent model resource.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String parent;

  /// Required. Model evaluation resource to be imported.
  final ModelEvaluation? modelEvaluation;

  ImportModelEvaluationRequest({required this.parent, this.modelEvaluation})
    : super(fullyQualifiedName);

  factory ImportModelEvaluationRequest.fromJson(Map<String, dynamic> json) {
    return ImportModelEvaluationRequest(
      parent: json['parent'],
      modelEvaluation: decode(
        json['modelEvaluation'],
        ModelEvaluation.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (modelEvaluation != null) 'modelEvaluation': modelEvaluation!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ImportModelEvaluationRequest($contents)';
  }
}

/// Request message for
/// `ModelService.BatchImportModelEvaluationSlices`
final class BatchImportModelEvaluationSlicesRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchImportModelEvaluationSlicesRequest';

  /// Required. The name of the parent ModelEvaluation resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  final String parent;

  /// Required. Model evaluation slice resource to be imported.
  final List<ModelEvaluationSlice>? modelEvaluationSlices;

  BatchImportModelEvaluationSlicesRequest({
    required this.parent,
    this.modelEvaluationSlices,
  }) : super(fullyQualifiedName);

  factory BatchImportModelEvaluationSlicesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchImportModelEvaluationSlicesRequest(
      parent: json['parent'],
      modelEvaluationSlices: decodeListMessage(
        json['modelEvaluationSlices'],
        ModelEvaluationSlice.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (modelEvaluationSlices != null)
        'modelEvaluationSlices': encodeList(modelEvaluationSlices),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchImportModelEvaluationSlicesRequest($contents)';
  }
}

/// Response message for
/// `ModelService.BatchImportModelEvaluationSlices`
final class BatchImportModelEvaluationSlicesResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchImportModelEvaluationSlicesResponse';

  /// Output only. List of imported
  /// `ModelEvaluationSlice.name`.
  final List<String>? importedModelEvaluationSlices;

  BatchImportModelEvaluationSlicesResponse({this.importedModelEvaluationSlices})
    : super(fullyQualifiedName);

  factory BatchImportModelEvaluationSlicesResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchImportModelEvaluationSlicesResponse(
      importedModelEvaluationSlices: decodeList(
        json['importedModelEvaluationSlices'],
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (importedModelEvaluationSlices != null)
        'importedModelEvaluationSlices': importedModelEvaluationSlices,
    };
  }

  @override
  String toString() => 'BatchImportModelEvaluationSlicesResponse()';
}

/// Request message for
/// `ModelService.BatchImportEvaluatedAnnotations`
final class BatchImportEvaluatedAnnotationsRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchImportEvaluatedAnnotationsRequest';

  /// Required. The name of the parent ModelEvaluationSlice resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  final String parent;

  /// Required. Evaluated annotations resource to be imported.
  final List<EvaluatedAnnotation>? evaluatedAnnotations;

  BatchImportEvaluatedAnnotationsRequest({
    required this.parent,
    this.evaluatedAnnotations,
  }) : super(fullyQualifiedName);

  factory BatchImportEvaluatedAnnotationsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchImportEvaluatedAnnotationsRequest(
      parent: json['parent'],
      evaluatedAnnotations: decodeListMessage(
        json['evaluatedAnnotations'],
        EvaluatedAnnotation.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (evaluatedAnnotations != null)
        'evaluatedAnnotations': encodeList(evaluatedAnnotations),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchImportEvaluatedAnnotationsRequest($contents)';
  }
}

/// Response message for
/// `ModelService.BatchImportEvaluatedAnnotations`
final class BatchImportEvaluatedAnnotationsResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchImportEvaluatedAnnotationsResponse';

  /// Output only. Number of EvaluatedAnnotations imported.
  final int? importedEvaluatedAnnotationsCount;

  BatchImportEvaluatedAnnotationsResponse({
    this.importedEvaluatedAnnotationsCount,
  }) : super(fullyQualifiedName);

  factory BatchImportEvaluatedAnnotationsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchImportEvaluatedAnnotationsResponse(
      importedEvaluatedAnnotationsCount:
          json['importedEvaluatedAnnotationsCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (importedEvaluatedAnnotationsCount != null)
        'importedEvaluatedAnnotationsCount': importedEvaluatedAnnotationsCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (importedEvaluatedAnnotationsCount != null)
        'importedEvaluatedAnnotationsCount=$importedEvaluatedAnnotationsCount',
    ].join(',');
    return 'BatchImportEvaluatedAnnotationsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.GetModelEvaluation`.
final class GetModelEvaluationRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelEvaluationRequest';

  /// Required. The name of the ModelEvaluation resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  final String name;

  GetModelEvaluationRequest({required this.name}) : super(fullyQualifiedName);

  factory GetModelEvaluationRequest.fromJson(Map<String, dynamic> json) {
    return GetModelEvaluationRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelEvaluationRequest($contents)';
  }
}

/// Request message for
/// `ModelService.ListModelEvaluations`.
final class ListModelEvaluationsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelEvaluationsRequest';

  /// Required. The resource name of the Model to list the ModelEvaluations from.
  /// Format: `projects/{project}/locations/{location}/models/{model}`
  final String parent;

  /// The standard list filter.
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListModelEvaluationsResponse.next_page_token`
  /// of the previous
  /// `ModelService.ListModelEvaluations`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListModelEvaluationsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelEvaluationsRequest.fromJson(Map<String, dynamic> json) {
    return ListModelEvaluationsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListModelEvaluationsRequest($contents)';
  }
}

/// Response message for
/// `ModelService.ListModelEvaluations`.
final class ListModelEvaluationsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelEvaluationsResponse';

  /// List of ModelEvaluations in the requested page.
  final List<ModelEvaluation>? modelEvaluations;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListModelEvaluationsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListModelEvaluationsResponse({this.modelEvaluations, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListModelEvaluationsResponse.fromJson(Map<String, dynamic> json) {
    return ListModelEvaluationsResponse(
      modelEvaluations: decodeListMessage(
        json['modelEvaluations'],
        ModelEvaluation.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (modelEvaluations != null)
        'modelEvaluations': encodeList(modelEvaluations),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListModelEvaluationsResponse($contents)';
  }
}

/// Request message for
/// `ModelService.GetModelEvaluationSlice`.
final class GetModelEvaluationSliceRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetModelEvaluationSliceRequest';

  /// Required. The name of the ModelEvaluationSlice resource.
  /// Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}/slices/{slice}`
  final String name;

  GetModelEvaluationSliceRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetModelEvaluationSliceRequest.fromJson(Map<String, dynamic> json) {
    return GetModelEvaluationSliceRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetModelEvaluationSliceRequest($contents)';
  }
}

/// Request message for
/// `ModelService.ListModelEvaluationSlices`.
final class ListModelEvaluationSlicesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelEvaluationSlicesRequest';

  /// Required. The resource name of the ModelEvaluation to list the
  /// ModelEvaluationSlices from. Format:
  /// `projects/{project}/locations/{location}/models/{model}/evaluations/{evaluation}`
  final String parent;

  /// The standard list filter.
  ///
  ///   * `slice.dimension` - for =.
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListModelEvaluationSlicesResponse.next_page_token`
  /// of the previous
  /// `ModelService.ListModelEvaluationSlices`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListModelEvaluationSlicesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListModelEvaluationSlicesRequest.fromJson(Map<String, dynamic> json) {
    return ListModelEvaluationSlicesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListModelEvaluationSlicesRequest($contents)';
  }
}

/// Response message for
/// `ModelService.ListModelEvaluationSlices`.
final class ListModelEvaluationSlicesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListModelEvaluationSlicesResponse';

  /// List of ModelEvaluations in the requested page.
  final List<ModelEvaluationSlice>? modelEvaluationSlices;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListModelEvaluationSlicesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListModelEvaluationSlicesResponse({
    this.modelEvaluationSlices,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListModelEvaluationSlicesResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListModelEvaluationSlicesResponse(
      modelEvaluationSlices: decodeListMessage(
        json['modelEvaluationSlices'],
        ModelEvaluationSlice.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (modelEvaluationSlices != null)
        'modelEvaluationSlices': encodeList(modelEvaluationSlices),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListModelEvaluationSlicesResponse($contents)';
  }
}

/// Request message for
/// `ModelService.RecommendSpec`.
final class RecommendSpecRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RecommendSpecRequest';

  /// Required. The resource name of the Location from which to recommend specs.
  /// The users must have permission to make a call in the project.
  /// Format:
  /// `projects/{project}/locations/{location}`.
  final String parent;

  /// Required. The Google Cloud Storage URI of the custom model, storing weights
  /// and config files (which can be used to infer the base model).
  final String? gcsUri;

  /// Optional. If true, check machine availability for the recommended regions.
  /// Only return the machine spec in regions where the machine is available.
  final bool? checkMachineAvailability;

  /// Optional. If true, check user quota for the recommended regions.
  /// Returns all the machine spec in regions they are available, and also the
  /// user quota state for each machine type in each region.
  final bool? checkUserQuota;

  RecommendSpecRequest({
    required this.parent,
    this.gcsUri,
    this.checkMachineAvailability,
    this.checkUserQuota,
  }) : super(fullyQualifiedName);

  factory RecommendSpecRequest.fromJson(Map<String, dynamic> json) {
    return RecommendSpecRequest(
      parent: json['parent'],
      gcsUri: json['gcsUri'],
      checkMachineAvailability: json['checkMachineAvailability'],
      checkUserQuota: json['checkUserQuota'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (gcsUri != null) 'gcsUri': gcsUri,
      if (checkMachineAvailability != null)
        'checkMachineAvailability': checkMachineAvailability,
      if (checkUserQuota != null) 'checkUserQuota': checkUserQuota,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (gcsUri != null) 'gcsUri=$gcsUri',
      if (checkMachineAvailability != null)
        'checkMachineAvailability=$checkMachineAvailability',
      if (checkUserQuota != null) 'checkUserQuota=$checkUserQuota',
    ].join(',');
    return 'RecommendSpecRequest($contents)';
  }
}

/// Response message for
/// `ModelService.RecommendSpec`.
final class RecommendSpecResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RecommendSpecResponse';

  /// Output only. The base model used to finetune the custom model.
  final String? baseModel;

  /// Output only. Recommendations of deployment options for the given custom
  /// weights model.
  final List<RecommendSpecResponse_Recommendation>? recommendations;

  /// Output only. The machine and model container specs.
  final List<RecommendSpecResponse_MachineAndModelContainerSpec>? specs;

  RecommendSpecResponse({this.baseModel, this.recommendations, this.specs})
    : super(fullyQualifiedName);

  factory RecommendSpecResponse.fromJson(Map<String, dynamic> json) {
    return RecommendSpecResponse(
      baseModel: json['baseModel'],
      recommendations: decodeListMessage(
        json['recommendations'],
        RecommendSpecResponse_Recommendation.fromJson,
      ),
      specs: decodeListMessage(
        json['specs'],
        RecommendSpecResponse_MachineAndModelContainerSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (baseModel != null) 'baseModel': baseModel,
      if (recommendations != null)
        'recommendations': encodeList(recommendations),
      if (specs != null) 'specs': encodeList(specs),
    };
  }

  @override
  String toString() {
    final contents = [if (baseModel != null) 'baseModel=$baseModel'].join(',');
    return 'RecommendSpecResponse($contents)';
  }
}

/// A machine and model container spec.
final class RecommendSpecResponse_MachineAndModelContainerSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RecommendSpecResponse.MachineAndModelContainerSpec';

  /// Output only. The machine spec.
  final MachineSpec? machineSpec;

  /// Output only. The model container spec.
  final ModelContainerSpec? containerSpec;

  RecommendSpecResponse_MachineAndModelContainerSpec({
    this.machineSpec,
    this.containerSpec,
  }) : super(fullyQualifiedName);

  factory RecommendSpecResponse_MachineAndModelContainerSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return RecommendSpecResponse_MachineAndModelContainerSpec(
      machineSpec: decode(json['machineSpec'], MachineSpec.fromJson),
      containerSpec: decode(json['containerSpec'], ModelContainerSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
      if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
    };
  }

  @override
  String toString() => 'MachineAndModelContainerSpec()';
}

/// Recommendation of one deployment option for the given custom weights model
/// in one region.
/// Contains the machine and container spec, and user accelerator quota state.
final class RecommendSpecResponse_Recommendation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RecommendSpecResponse.Recommendation';

  /// The region for the deployment spec (machine).
  final String? region;

  /// Output only. The machine and model container specs.
  final RecommendSpecResponse_MachineAndModelContainerSpec? spec;

  /// Output only. The user accelerator quota state.
  final RecommendSpecResponse_Recommendation_QuotaState? userQuotaState;

  RecommendSpecResponse_Recommendation({
    this.region,
    this.spec,
    this.userQuotaState,
  }) : super(fullyQualifiedName);

  factory RecommendSpecResponse_Recommendation.fromJson(
    Map<String, dynamic> json,
  ) {
    return RecommendSpecResponse_Recommendation(
      region: json['region'],
      spec: decode(
        json['spec'],
        RecommendSpecResponse_MachineAndModelContainerSpec.fromJson,
      ),
      userQuotaState: decodeEnum(
        json['userQuotaState'],
        RecommendSpecResponse_Recommendation_QuotaState.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (region != null) 'region': region,
      if (spec != null) 'spec': spec!.toJson(),
      if (userQuotaState != null) 'userQuotaState': userQuotaState!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (region != null) 'region=$region',
      if (userQuotaState != null) 'userQuotaState=$userQuotaState',
    ].join(',');
    return 'Recommendation($contents)';
  }
}

/// The user accelerator quota state.
final class RecommendSpecResponse_Recommendation_QuotaState
    extends protobuf.ProtoEnum {
  /// Unspecified quota state. Quota information not available.
  static const quotaStateUnspecified =
      RecommendSpecResponse_Recommendation_QuotaState(
        'QUOTA_STATE_UNSPECIFIED',
      );

  /// User has enough accelerator quota for the machine type.
  static const quotaStateUserHasQuota =
      RecommendSpecResponse_Recommendation_QuotaState(
        'QUOTA_STATE_USER_HAS_QUOTA',
      );

  /// User does not have enough accelerator quota for the machine type.
  static const quotaStateNoUserQuota =
      RecommendSpecResponse_Recommendation_QuotaState(
        'QUOTA_STATE_NO_USER_QUOTA',
      );

  const RecommendSpecResponse_Recommendation_QuotaState(super.value);

  factory RecommendSpecResponse_Recommendation_QuotaState.fromJson(
    String json,
  ) => RecommendSpecResponse_Recommendation_QuotaState(json);

  @override
  String toString() => 'QuotaState.$value';
}

/// Represents a Neural Architecture Search (NAS) job.
final class NasJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJob';

  /// Output only. Resource name of the NasJob.
  final String? name;

  /// Required. The display name of the NasJob.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Required. The specification of a NasJob.
  final NasJobSpec? nasJobSpec;

  /// Output only. Output of the NasJob.
  final NasJobOutput? nasJobOutput;

  /// Output only. The detailed state of the job.
  final JobState? state;

  /// Output only. Time when the NasJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the NasJob for the first time entered the
  /// `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the NasJob entered any of the following states:
  /// `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the NasJob was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Only populated when job's state is JOB_STATE_FAILED or
  /// JOB_STATE_CANCELLED.
  final Status? error;

  /// The labels with user-defined metadata to organize NasJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Customer-managed encryption key options for a NasJob.
  /// If this is set, then all resources created by the NasJob
  /// will be encrypted with the provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// Optional. Enable a separation of Custom model training
  /// and restricted image training for tenant project.
  final bool? enableRestrictedImageTraining;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  NasJob({
    this.name,
    this.displayName,
    this.nasJobSpec,
    this.nasJobOutput,
    this.state,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.error,
    this.labels,
    this.encryptionSpec,
    this.enableRestrictedImageTraining,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory NasJob.fromJson(Map<String, dynamic> json) {
    return NasJob(
      name: json['name'],
      displayName: json['displayName'],
      nasJobSpec: decode(json['nasJobSpec'], NasJobSpec.fromJson),
      nasJobOutput: decode(json['nasJobOutput'], NasJobOutput.fromJson),
      state: decodeEnum(json['state'], JobState.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      error: decode(json['error'], Status.fromJson),
      labels: decodeMap(json['labels']),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      enableRestrictedImageTraining: json['enableRestrictedImageTraining'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (nasJobSpec != null) 'nasJobSpec': nasJobSpec!.toJson(),
      if (nasJobOutput != null) 'nasJobOutput': nasJobOutput!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (labels != null) 'labels': labels,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (enableRestrictedImageTraining != null)
        'enableRestrictedImageTraining': enableRestrictedImageTraining,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (state != null) 'state=$state',
      if (enableRestrictedImageTraining != null)
        'enableRestrictedImageTraining=$enableRestrictedImageTraining',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'NasJob($contents)';
  }
}

/// Represents a NasTrial details along with its parameters. If there is a
/// corresponding train NasTrial, the train NasTrial is also returned.
final class NasTrialDetail extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasTrialDetail';

  /// Output only. Resource name of the NasTrialDetail.
  final String? name;

  /// The parameters for the NasJob NasTrial.
  final String? parameters;

  /// The requested search NasTrial.
  final NasTrial? searchTrial;

  /// The train NasTrial corresponding to
  /// `search_trial`.
  /// Only populated if
  /// `search_trial`
  /// is used for training.
  final NasTrial? trainTrial;

  NasTrialDetail({
    this.name,
    this.parameters,
    this.searchTrial,
    this.trainTrial,
  }) : super(fullyQualifiedName);

  factory NasTrialDetail.fromJson(Map<String, dynamic> json) {
    return NasTrialDetail(
      name: json['name'],
      parameters: json['parameters'],
      searchTrial: decode(json['searchTrial'], NasTrial.fromJson),
      trainTrial: decode(json['trainTrial'], NasTrial.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (parameters != null) 'parameters': parameters,
      if (searchTrial != null) 'searchTrial': searchTrial!.toJson(),
      if (trainTrial != null) 'trainTrial': trainTrial!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (parameters != null) 'parameters=$parameters',
    ].join(',');
    return 'NasTrialDetail($contents)';
  }
}

/// Represents the spec of a NasJob.
final class NasJobSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec';

  /// The spec of multi-trial algorithms.
  final NasJobSpec_MultiTrialAlgorithmSpec? multiTrialAlgorithmSpec;

  /// The ID of the existing NasJob in the same Project and Location
  /// which will be used to resume search. search_space_spec and
  /// nas_algorithm_spec are obtained from previous NasJob hence should not
  /// provide them again for this NasJob.
  final String? resumeNasJobId;

  /// It defines the search space for Neural Architecture Search (NAS).
  final String? searchSpaceSpec;

  NasJobSpec({
    this.multiTrialAlgorithmSpec,
    this.resumeNasJobId,
    this.searchSpaceSpec,
  }) : super(fullyQualifiedName);

  factory NasJobSpec.fromJson(Map<String, dynamic> json) {
    return NasJobSpec(
      multiTrialAlgorithmSpec: decode(
        json['multiTrialAlgorithmSpec'],
        NasJobSpec_MultiTrialAlgorithmSpec.fromJson,
      ),
      resumeNasJobId: json['resumeNasJobId'],
      searchSpaceSpec: json['searchSpaceSpec'],
    );
  }

  @override
  Object toJson() {
    return {
      if (multiTrialAlgorithmSpec != null)
        'multiTrialAlgorithmSpec': multiTrialAlgorithmSpec!.toJson(),
      if (resumeNasJobId != null) 'resumeNasJobId': resumeNasJobId,
      if (searchSpaceSpec != null) 'searchSpaceSpec': searchSpaceSpec,
    };
  }

  @override
  String toString() {
    final contents = [
      if (resumeNasJobId != null) 'resumeNasJobId=$resumeNasJobId',
      if (searchSpaceSpec != null) 'searchSpaceSpec=$searchSpaceSpec',
    ].join(',');
    return 'NasJobSpec($contents)';
  }
}

/// The spec of multi-trial Neural Architecture Search (NAS).
final class NasJobSpec_MultiTrialAlgorithmSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec.MultiTrialAlgorithmSpec';

  /// The multi-trial Neural Architecture Search (NAS) algorithm
  /// type. Defaults to `REINFORCEMENT_LEARNING`.
  final NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm?
  multiTrialAlgorithm;

  /// Metric specs for the NAS job.
  /// Validation for this field is done at `multi_trial_algorithm_spec` field.
  final NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec? metric;

  /// Required. Spec for search trials.
  final NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec? searchTrialSpec;

  /// Spec for train trials. Top N [TrainTrialSpec.max_parallel_trial_count]
  /// search trials will be trained for every M
  /// [TrainTrialSpec.frequency] trials searched.
  final NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec? trainTrialSpec;

  NasJobSpec_MultiTrialAlgorithmSpec({
    this.multiTrialAlgorithm,
    this.metric,
    this.searchTrialSpec,
    this.trainTrialSpec,
  }) : super(fullyQualifiedName);

  factory NasJobSpec_MultiTrialAlgorithmSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return NasJobSpec_MultiTrialAlgorithmSpec(
      multiTrialAlgorithm: decodeEnum(
        json['multiTrialAlgorithm'],
        NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.fromJson,
      ),
      metric: decode(
        json['metric'],
        NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.fromJson,
      ),
      searchTrialSpec: decode(
        json['searchTrialSpec'],
        NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.fromJson,
      ),
      trainTrialSpec: decode(
        json['trainTrialSpec'],
        NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (multiTrialAlgorithm != null)
        'multiTrialAlgorithm': multiTrialAlgorithm!.toJson(),
      if (metric != null) 'metric': metric!.toJson(),
      if (searchTrialSpec != null) 'searchTrialSpec': searchTrialSpec!.toJson(),
      if (trainTrialSpec != null) 'trainTrialSpec': trainTrialSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (multiTrialAlgorithm != null)
        'multiTrialAlgorithm=$multiTrialAlgorithm',
    ].join(',');
    return 'MultiTrialAlgorithmSpec($contents)';
  }
}

/// Represents a metric to optimize.
final class NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec.MultiTrialAlgorithmSpec.MetricSpec';

  /// Required. The ID of the metric. Must not contain whitespaces.
  final String? metricId;

  /// Required. The optimization goal of the metric.
  final NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType? goal;

  NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec({this.metricId, this.goal})
    : super(fullyQualifiedName);

  factory NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec(
      metricId: json['metricId'],
      goal: decodeEnum(
        json['goal'],
        NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricId != null) 'metricId': metricId,
      if (goal != null) 'goal': goal!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (metricId != null) 'metricId=$metricId',
      if (goal != null) 'goal=$goal',
    ].join(',');
    return 'MetricSpec($contents)';
  }
}

/// The available types of optimization goals.
final class NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType
    extends protobuf.ProtoEnum {
  /// Goal Type will default to maximize.
  static const goalTypeUnspecified =
      NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType(
        'GOAL_TYPE_UNSPECIFIED',
      );

  /// Maximize the goal metric.
  static const maximize =
      NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType('MAXIMIZE');

  /// Minimize the goal metric.
  static const minimize =
      NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType('MINIMIZE');

  const NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType(super.value);

  factory NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType.fromJson(
    String json,
  ) => NasJobSpec_MultiTrialAlgorithmSpec_MetricSpec_GoalType(json);

  @override
  String toString() => 'GoalType.$value';
}

/// Represent spec for search trials.
final class NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec.MultiTrialAlgorithmSpec.SearchTrialSpec';

  /// Required. The spec of a search trial job. The same spec applies to
  /// all search trials.
  final CustomJobSpec? searchTrialJobSpec;

  /// Required. The maximum number of Neural Architecture Search (NAS) trials
  /// to run.
  final int? maxTrialCount;

  /// Required. The maximum number of trials to run in parallel.
  final int? maxParallelTrialCount;

  /// The number of failed trials that need to be seen before failing
  /// the NasJob.
  ///
  /// If set to 0, Vertex AI decides how many trials must fail
  /// before the whole job fails.
  final int? maxFailedTrialCount;

  NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec({
    this.searchTrialJobSpec,
    this.maxTrialCount,
    this.maxParallelTrialCount,
    this.maxFailedTrialCount,
  }) : super(fullyQualifiedName);

  factory NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return NasJobSpec_MultiTrialAlgorithmSpec_SearchTrialSpec(
      searchTrialJobSpec: decode(
        json['searchTrialJobSpec'],
        CustomJobSpec.fromJson,
      ),
      maxTrialCount: json['maxTrialCount'],
      maxParallelTrialCount: json['maxParallelTrialCount'],
      maxFailedTrialCount: json['maxFailedTrialCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (searchTrialJobSpec != null)
        'searchTrialJobSpec': searchTrialJobSpec!.toJson(),
      if (maxTrialCount != null) 'maxTrialCount': maxTrialCount,
      if (maxParallelTrialCount != null)
        'maxParallelTrialCount': maxParallelTrialCount,
      if (maxFailedTrialCount != null)
        'maxFailedTrialCount': maxFailedTrialCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxTrialCount != null) 'maxTrialCount=$maxTrialCount',
      if (maxParallelTrialCount != null)
        'maxParallelTrialCount=$maxParallelTrialCount',
      if (maxFailedTrialCount != null)
        'maxFailedTrialCount=$maxFailedTrialCount',
    ].join(',');
    return 'SearchTrialSpec($contents)';
  }
}

/// Represent spec for train trials.
final class NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobSpec.MultiTrialAlgorithmSpec.TrainTrialSpec';

  /// Required. The spec of a train trial job. The same spec applies to
  /// all train trials.
  final CustomJobSpec? trainTrialJobSpec;

  /// Required. The maximum number of trials to run in parallel.
  final int? maxParallelTrialCount;

  /// Required. Frequency of search trials to start train stage. Top N
  /// [TrainTrialSpec.max_parallel_trial_count]
  /// search trials will be trained for every M
  /// [TrainTrialSpec.frequency] trials searched.
  final int? frequency;

  NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec({
    this.trainTrialJobSpec,
    this.maxParallelTrialCount,
    this.frequency,
  }) : super(fullyQualifiedName);

  factory NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return NasJobSpec_MultiTrialAlgorithmSpec_TrainTrialSpec(
      trainTrialJobSpec: decode(
        json['trainTrialJobSpec'],
        CustomJobSpec.fromJson,
      ),
      maxParallelTrialCount: json['maxParallelTrialCount'],
      frequency: json['frequency'],
    );
  }

  @override
  Object toJson() {
    return {
      if (trainTrialJobSpec != null)
        'trainTrialJobSpec': trainTrialJobSpec!.toJson(),
      if (maxParallelTrialCount != null)
        'maxParallelTrialCount': maxParallelTrialCount,
      if (frequency != null) 'frequency': frequency,
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxParallelTrialCount != null)
        'maxParallelTrialCount=$maxParallelTrialCount',
      if (frequency != null) 'frequency=$frequency',
    ].join(',');
    return 'TrainTrialSpec($contents)';
  }
}

/// The available types of multi-trial algorithms.
final class NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm
    extends protobuf.ProtoEnum {
  /// Defaults to `REINFORCEMENT_LEARNING`.
  static const multiTrialAlgorithmUnspecified =
      NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm(
        'MULTI_TRIAL_ALGORITHM_UNSPECIFIED',
      );

  /// The Reinforcement Learning Algorithm for Multi-trial Neural
  /// Architecture Search (NAS).
  static const reinforcementLearning =
      NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm(
        'REINFORCEMENT_LEARNING',
      );

  /// The Grid Search Algorithm for Multi-trial Neural
  /// Architecture Search (NAS).
  static const gridSearch =
      NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm('GRID_SEARCH');

  const NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm(super.value);

  factory NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm.fromJson(
    String json,
  ) => NasJobSpec_MultiTrialAlgorithmSpec_MultiTrialAlgorithm(json);

  @override
  String toString() => 'MultiTrialAlgorithm.$value';
}

/// Represents a uCAIP NasJob output.
final class NasJobOutput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobOutput';

  /// Output only. The output of this multi-trial Neural Architecture Search
  /// (NAS) job.
  final NasJobOutput_MultiTrialJobOutput? multiTrialJobOutput;

  NasJobOutput({this.multiTrialJobOutput}) : super(fullyQualifiedName);

  factory NasJobOutput.fromJson(Map<String, dynamic> json) {
    return NasJobOutput(
      multiTrialJobOutput: decode(
        json['multiTrialJobOutput'],
        NasJobOutput_MultiTrialJobOutput.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (multiTrialJobOutput != null)
        'multiTrialJobOutput': multiTrialJobOutput!.toJson(),
    };
  }

  @override
  String toString() => 'NasJobOutput()';
}

/// The output of a multi-trial Neural Architecture Search (NAS) jobs.
final class NasJobOutput_MultiTrialJobOutput extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasJobOutput.MultiTrialJobOutput';

  /// Output only. List of NasTrials that were started as part of search stage.
  final List<NasTrial>? searchTrials;

  /// Output only. List of NasTrials that were started as part of train stage.
  final List<NasTrial>? trainTrials;

  NasJobOutput_MultiTrialJobOutput({this.searchTrials, this.trainTrials})
    : super(fullyQualifiedName);

  factory NasJobOutput_MultiTrialJobOutput.fromJson(Map<String, dynamic> json) {
    return NasJobOutput_MultiTrialJobOutput(
      searchTrials: decodeListMessage(json['searchTrials'], NasTrial.fromJson),
      trainTrials: decodeListMessage(json['trainTrials'], NasTrial.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (searchTrials != null) 'searchTrials': encodeList(searchTrials),
      if (trainTrials != null) 'trainTrials': encodeList(trainTrials),
    };
  }

  @override
  String toString() => 'MultiTrialJobOutput()';
}

/// Represents a uCAIP NasJob trial.
final class NasTrial extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NasTrial';

  /// Output only. The identifier of the NasTrial assigned by the service.
  final String? id;

  /// Output only. The detailed state of the NasTrial.
  final NasTrial_State? state;

  /// Output only. The final measurement containing the objective value.
  final Measurement? finalMeasurement;

  /// Output only. Time when the NasTrial was started.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the NasTrial's status changed to `SUCCEEDED` or
  /// `INFEASIBLE`.
  final protobuf.Timestamp? endTime;

  NasTrial({
    this.id,
    this.state,
    this.finalMeasurement,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory NasTrial.fromJson(Map<String, dynamic> json) {
    return NasTrial(
      id: json['id'],
      state: decodeEnum(json['state'], NasTrial_State.fromJson),
      finalMeasurement: decode(json['finalMeasurement'], Measurement.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (state != null) 'state': state!.toJson(),
      if (finalMeasurement != null)
        'finalMeasurement': finalMeasurement!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      if (state != null) 'state=$state',
    ].join(',');
    return 'NasTrial($contents)';
  }
}

/// Describes a NasTrial state.
final class NasTrial_State extends protobuf.ProtoEnum {
  /// The NasTrial state is unspecified.
  static const stateUnspecified = NasTrial_State('STATE_UNSPECIFIED');

  /// Indicates that a specific NasTrial has been requested, but it has not yet
  /// been suggested by the service.
  static const requested = NasTrial_State('REQUESTED');

  /// Indicates that the NasTrial has been suggested.
  static const active = NasTrial_State('ACTIVE');

  /// Indicates that the NasTrial should stop according to the service.
  static const stopping = NasTrial_State('STOPPING');

  /// Indicates that the NasTrial is completed successfully.
  static const succeeded = NasTrial_State('SUCCEEDED');

  /// Indicates that the NasTrial should not be attempted again.
  /// The service will set a NasTrial to INFEASIBLE when it's done but missing
  /// the final_measurement.
  static const infeasible = NasTrial_State('INFEASIBLE');

  const NasTrial_State(super.value);

  factory NasTrial_State.fromJson(String json) => NasTrial_State(json);

  @override
  String toString() => 'State.$value';
}

/// Network spec.
final class NetworkSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NetworkSpec';

  /// Whether to enable public internet access. Default false.
  final bool? enableInternetAccess;

  /// The full name of the Google Compute Engine
  /// [network](https://cloud.google.com//compute/docs/networks-and-firewalls#networks)
  final String? network;

  /// The name of the subnet that this instance is in.
  /// Format:
  /// `projects/{project_id_or_number}/regions/{region}/subnetworks/{subnetwork_id}`
  final String? subnetwork;

  NetworkSpec({this.enableInternetAccess, this.network, this.subnetwork})
    : super(fullyQualifiedName);

  factory NetworkSpec.fromJson(Map<String, dynamic> json) {
    return NetworkSpec(
      enableInternetAccess: json['enableInternetAccess'],
      network: json['network'],
      subnetwork: json['subnetwork'],
    );
  }

  @override
  Object toJson() {
    return {
      if (enableInternetAccess != null)
        'enableInternetAccess': enableInternetAccess,
      if (network != null) 'network': network,
      if (subnetwork != null) 'subnetwork': subnetwork,
    };
  }

  @override
  String toString() {
    final contents = [
      if (enableInternetAccess != null)
        'enableInternetAccess=$enableInternetAccess',
      if (network != null) 'network=$network',
      if (subnetwork != null) 'subnetwork=$subnetwork',
    ].join(',');
    return 'NetworkSpec($contents)';
  }
}

/// The euc configuration of NotebookRuntimeTemplate.
final class NotebookEucConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookEucConfig';

  /// Input only. Whether EUC is disabled in this NotebookRuntimeTemplate.
  /// In proto3, the default value of a boolean is false. In this way, by default
  /// EUC will be enabled for NotebookRuntimeTemplate.
  final bool? eucDisabled;

  /// Output only. Whether ActAs check is bypassed for service account attached
  /// to the VM. If false, we need ActAs check for the default Compute Engine
  /// Service account. When a Runtime is created, a VM is allocated using Default
  /// Compute Engine Service Account. Any user requesting to use this Runtime
  /// requires Service Account User (ActAs) permission over this SA. If true,
  /// Runtime owner is using EUC and does not require the above permission as VM
  /// no longer use default Compute Engine SA, but a P4SA.
  final bool? bypassActasCheck;

  NotebookEucConfig({this.eucDisabled, this.bypassActasCheck})
    : super(fullyQualifiedName);

  factory NotebookEucConfig.fromJson(Map<String, dynamic> json) {
    return NotebookEucConfig(
      eucDisabled: json['eucDisabled'],
      bypassActasCheck: json['bypassActasCheck'],
    );
  }

  @override
  Object toJson() {
    return {
      if (eucDisabled != null) 'eucDisabled': eucDisabled,
      if (bypassActasCheck != null) 'bypassActasCheck': bypassActasCheck,
    };
  }

  @override
  String toString() {
    final contents = [
      if (eucDisabled != null) 'eucDisabled=$eucDisabled',
      if (bypassActasCheck != null) 'bypassActasCheck=$bypassActasCheck',
    ].join(',');
    return 'NotebookEucConfig($contents)';
  }
}

/// NotebookExecutionJob represents an instance of a notebook execution.
final class NotebookExecutionJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob';

  /// The Dataform Repository pointing to a single file notebook repository.
  final NotebookExecutionJob_DataformRepositorySource? dataformRepositorySource;

  /// The Cloud Storage url pointing to the ipynb file. Format:
  /// `gs://bucket/notebook_file.ipynb`
  final NotebookExecutionJob_GcsNotebookSource? gcsNotebookSource;

  /// The contents of an input notebook file.
  final NotebookExecutionJob_DirectNotebookSource? directNotebookSource;

  /// The NotebookRuntimeTemplate to source compute configuration from.
  final String? notebookRuntimeTemplateResourceName;

  /// The custom compute configuration for an execution job.
  final NotebookExecutionJob_CustomEnvironmentSpec? customEnvironmentSpec;

  /// The Cloud Storage location to upload the result to. Format:
  /// `gs://bucket-name`
  final String? gcsOutputUri;

  /// The user email to run the execution as. Only supported by Colab runtimes.
  final String? executionUser;

  /// The service account to run the execution as.
  final String? serviceAccount;

  /// The Workbench runtime configuration to use for the notebook execution.
  final NotebookExecutionJob_WorkbenchRuntime? workbenchRuntime;

  /// Output only. The resource name of this NotebookExecutionJob. Format:
  /// `projects/{project_id}/locations/{location}/notebookExecutionJobs/{job_id}`
  final String? name;

  /// The display name of the NotebookExecutionJob. The name can be up to 128
  /// characters long and can consist of any UTF-8 characters.
  final String? displayName;

  /// Max running time of the execution job in seconds (default 86400s / 24 hrs).
  final protobuf.Duration? executionTimeout;

  /// The Schedule resource name if this job is triggered by one. Format:
  /// `projects/{project_id}/locations/{location}/schedules/{schedule_id}`
  final String? scheduleResourceName;

  /// Output only. The state of the NotebookExecutionJob.
  final JobState? jobState;

  /// Output only. Populated when the NotebookExecutionJob is completed. When
  /// there is an error during notebook execution, the error details are
  /// populated.
  final Status? status;

  /// Output only. Timestamp when this NotebookExecutionJob was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this NotebookExecutionJob was most recently
  /// updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize NotebookExecutionJobs.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? labels;

  /// The name of the kernel to use during notebook execution. If unset, the
  /// default kernel is used.
  final String? kernelName;

  /// Customer-managed encryption key spec for the notebook execution job.
  /// This field is auto-populated if the
  /// `NotebookRuntimeTemplate`
  /// has an encryption spec.
  final EncryptionSpec? encryptionSpec;

  NotebookExecutionJob({
    this.dataformRepositorySource,
    this.gcsNotebookSource,
    this.directNotebookSource,
    this.notebookRuntimeTemplateResourceName,
    this.customEnvironmentSpec,
    this.gcsOutputUri,
    this.executionUser,
    this.serviceAccount,
    this.workbenchRuntime,
    this.name,
    this.displayName,
    this.executionTimeout,
    this.scheduleResourceName,
    this.jobState,
    this.status,
    this.createTime,
    this.updateTime,
    this.labels,
    this.kernelName,
    this.encryptionSpec,
  }) : super(fullyQualifiedName);

  factory NotebookExecutionJob.fromJson(Map<String, dynamic> json) {
    return NotebookExecutionJob(
      dataformRepositorySource: decode(
        json['dataformRepositorySource'],
        NotebookExecutionJob_DataformRepositorySource.fromJson,
      ),
      gcsNotebookSource: decode(
        json['gcsNotebookSource'],
        NotebookExecutionJob_GcsNotebookSource.fromJson,
      ),
      directNotebookSource: decode(
        json['directNotebookSource'],
        NotebookExecutionJob_DirectNotebookSource.fromJson,
      ),
      notebookRuntimeTemplateResourceName:
          json['notebookRuntimeTemplateResourceName'],
      customEnvironmentSpec: decode(
        json['customEnvironmentSpec'],
        NotebookExecutionJob_CustomEnvironmentSpec.fromJson,
      ),
      gcsOutputUri: json['gcsOutputUri'],
      executionUser: json['executionUser'],
      serviceAccount: json['serviceAccount'],
      workbenchRuntime: decode(
        json['workbenchRuntime'],
        NotebookExecutionJob_WorkbenchRuntime.fromJson,
      ),
      name: json['name'],
      displayName: json['displayName'],
      executionTimeout: decodeCustom(
        json['executionTimeout'],
        protobuf.Duration.fromJson,
      ),
      scheduleResourceName: json['scheduleResourceName'],
      jobState: decodeEnum(json['jobState'], JobState.fromJson),
      status: decode(json['status'], Status.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      kernelName: json['kernelName'],
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (dataformRepositorySource != null)
        'dataformRepositorySource': dataformRepositorySource!.toJson(),
      if (gcsNotebookSource != null)
        'gcsNotebookSource': gcsNotebookSource!.toJson(),
      if (directNotebookSource != null)
        'directNotebookSource': directNotebookSource!.toJson(),
      if (notebookRuntimeTemplateResourceName != null)
        'notebookRuntimeTemplateResourceName':
            notebookRuntimeTemplateResourceName,
      if (customEnvironmentSpec != null)
        'customEnvironmentSpec': customEnvironmentSpec!.toJson(),
      if (gcsOutputUri != null) 'gcsOutputUri': gcsOutputUri,
      if (executionUser != null) 'executionUser': executionUser,
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (workbenchRuntime != null)
        'workbenchRuntime': workbenchRuntime!.toJson(),
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (executionTimeout != null)
        'executionTimeout': executionTimeout!.toJson(),
      if (scheduleResourceName != null)
        'scheduleResourceName': scheduleResourceName,
      if (jobState != null) 'jobState': jobState!.toJson(),
      if (status != null) 'status': status!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (kernelName != null) 'kernelName': kernelName,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (notebookRuntimeTemplateResourceName != null)
        'notebookRuntimeTemplateResourceName=$notebookRuntimeTemplateResourceName',
      if (gcsOutputUri != null) 'gcsOutputUri=$gcsOutputUri',
      if (executionUser != null) 'executionUser=$executionUser',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (scheduleResourceName != null)
        'scheduleResourceName=$scheduleResourceName',
      if (jobState != null) 'jobState=$jobState',
      if (kernelName != null) 'kernelName=$kernelName',
    ].join(',');
    return 'NotebookExecutionJob($contents)';
  }
}

/// The Dataform Repository containing the input notebook.
final class NotebookExecutionJob_DataformRepositorySource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.DataformRepositorySource';

  /// The resource name of the Dataform Repository. Format:
  /// `projects/{project_id}/locations/{location}/repositories/{repository_id}`
  final String? dataformRepositoryResourceName;

  /// The commit SHA to read repository with. If unset, the file will be read
  /// at HEAD.
  final String? commitSha;

  NotebookExecutionJob_DataformRepositorySource({
    this.dataformRepositoryResourceName,
    this.commitSha,
  }) : super(fullyQualifiedName);

  factory NotebookExecutionJob_DataformRepositorySource.fromJson(
    Map<String, dynamic> json,
  ) {
    return NotebookExecutionJob_DataformRepositorySource(
      dataformRepositoryResourceName: json['dataformRepositoryResourceName'],
      commitSha: json['commitSha'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dataformRepositoryResourceName != null)
        'dataformRepositoryResourceName': dataformRepositoryResourceName,
      if (commitSha != null) 'commitSha': commitSha,
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataformRepositoryResourceName != null)
        'dataformRepositoryResourceName=$dataformRepositoryResourceName',
      if (commitSha != null) 'commitSha=$commitSha',
    ].join(',');
    return 'DataformRepositorySource($contents)';
  }
}

/// The Cloud Storage uri for the input notebook.
final class NotebookExecutionJob_GcsNotebookSource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.GcsNotebookSource';

  /// The Cloud Storage uri pointing to the ipynb file. Format:
  /// `gs://bucket/notebook_file.ipynb`
  final String? uri;

  /// The version of the Cloud Storage object to read. If unset, the current
  /// version of the object is read. See
  /// https://cloud.google.com/storage/docs/metadata#generation-number.
  final String? generation;

  NotebookExecutionJob_GcsNotebookSource({this.uri, this.generation})
    : super(fullyQualifiedName);

  factory NotebookExecutionJob_GcsNotebookSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return NotebookExecutionJob_GcsNotebookSource(
      uri: json['uri'],
      generation: json['generation'],
    );
  }

  @override
  Object toJson() {
    return {
      if (uri != null) 'uri': uri,
      if (generation != null) 'generation': generation,
    };
  }

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (generation != null) 'generation=$generation',
    ].join(',');
    return 'GcsNotebookSource($contents)';
  }
}

/// The content of the input notebook in ipynb format.
final class NotebookExecutionJob_DirectNotebookSource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.DirectNotebookSource';

  /// The base64-encoded contents of the input notebook file.
  final Uint8List? content;

  NotebookExecutionJob_DirectNotebookSource({this.content})
    : super(fullyQualifiedName);

  factory NotebookExecutionJob_DirectNotebookSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return NotebookExecutionJob_DirectNotebookSource(
      content: decodeBytes(json['content']),
    );
  }

  @override
  Object toJson() {
    return {if (content != null) 'content': encodeBytes(content)};
  }

  @override
  String toString() {
    final contents = [if (content != null) 'content=$content'].join(',');
    return 'DirectNotebookSource($contents)';
  }
}

/// Compute configuration to use for an execution job.
final class NotebookExecutionJob_CustomEnvironmentSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.CustomEnvironmentSpec';

  /// The specification of a single machine for the execution job.
  final MachineSpec? machineSpec;

  /// The specification of a persistent disk to attach for the execution job.
  final PersistentDiskSpec? persistentDiskSpec;

  /// The network configuration to use for the execution job.
  final NetworkSpec? networkSpec;

  NotebookExecutionJob_CustomEnvironmentSpec({
    this.machineSpec,
    this.persistentDiskSpec,
    this.networkSpec,
  }) : super(fullyQualifiedName);

  factory NotebookExecutionJob_CustomEnvironmentSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return NotebookExecutionJob_CustomEnvironmentSpec(
      machineSpec: decode(json['machineSpec'], MachineSpec.fromJson),
      persistentDiskSpec: decode(
        json['persistentDiskSpec'],
        PersistentDiskSpec.fromJson,
      ),
      networkSpec: decode(json['networkSpec'], NetworkSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
      if (persistentDiskSpec != null)
        'persistentDiskSpec': persistentDiskSpec!.toJson(),
      if (networkSpec != null) 'networkSpec': networkSpec!.toJson(),
    };
  }

  @override
  String toString() => 'CustomEnvironmentSpec()';
}

/// Configuration for a Workbench Instances-based environment.
final class NotebookExecutionJob_WorkbenchRuntime
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookExecutionJob.WorkbenchRuntime';

  NotebookExecutionJob_WorkbenchRuntime() : super(fullyQualifiedName);

  factory NotebookExecutionJob_WorkbenchRuntime.fromJson(
    Map<String, dynamic> json,
  ) {
    return NotebookExecutionJob_WorkbenchRuntime();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'WorkbenchRuntime()';
}

/// The idle shutdown configuration of NotebookRuntimeTemplate, which contains
/// the idle_timeout as required field.
final class NotebookIdleShutdownConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookIdleShutdownConfig';

  /// Required. Duration is accurate to the second. In Notebook, Idle Timeout is
  /// accurate to minute so the range of idle_timeout (second) is: 10 * 60 ~ 1440
  /// * 60.
  final protobuf.Duration? idleTimeout;

  /// Whether Idle Shutdown is disabled in this NotebookRuntimeTemplate.
  final bool? idleShutdownDisabled;

  NotebookIdleShutdownConfig({this.idleTimeout, this.idleShutdownDisabled})
    : super(fullyQualifiedName);

  factory NotebookIdleShutdownConfig.fromJson(Map<String, dynamic> json) {
    return NotebookIdleShutdownConfig(
      idleTimeout: decodeCustom(
        json['idleTimeout'],
        protobuf.Duration.fromJson,
      ),
      idleShutdownDisabled: json['idleShutdownDisabled'],
    );
  }

  @override
  Object toJson() {
    return {
      if (idleTimeout != null) 'idleTimeout': idleTimeout!.toJson(),
      if (idleShutdownDisabled != null)
        'idleShutdownDisabled': idleShutdownDisabled,
    };
  }

  @override
  String toString() {
    final contents = [
      if (idleShutdownDisabled != null)
        'idleShutdownDisabled=$idleShutdownDisabled',
    ].join(',');
    return 'NotebookIdleShutdownConfig($contents)';
  }
}

/// A template that specifies runtime configurations such as machine type,
/// runtime version, network configurations, etc.
/// Multiple runtimes can be created from a runtime template.
final class NotebookRuntimeTemplate extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookRuntimeTemplate';

  /// The resource name of the NotebookRuntimeTemplate.
  final String? name;

  /// Required. The display name of the NotebookRuntimeTemplate.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// The description of the NotebookRuntimeTemplate.
  final String? description;

  /// Output only. Deprecated: This field has no behavior. Use
  /// notebook_runtime_type = 'ONE_CLICK' instead.
  ///
  /// The default template to use if not specified.
  final bool? isDefault;

  /// Optional. Immutable. The specification of a single machine for the
  /// template.
  final MachineSpec? machineSpec;

  /// Optional. The specification of [persistent
  /// disk][https://cloud.google.com/compute/docs/disks/persistent-disks]
  /// attached to the runtime as data disk storage.
  final PersistentDiskSpec? dataPersistentDiskSpec;

  /// Optional. Network spec.
  final NetworkSpec? networkSpec;

  /// Deprecated: This field is ignored and the "Vertex AI Notebook Service
  /// Account"
  /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
  /// used for the runtime workload identity.
  /// See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account
  /// for more details.
  /// For NotebookExecutionJob, use NotebookExecutionJob.service_account instead.
  ///
  /// The service account that the runtime workload runs as.
  /// You can use any service account within the same project, but you
  /// must have the service account user permission to use the instance.
  ///
  /// If not specified, the [Compute Engine default service
  /// account](https://cloud.google.com/compute/docs/access/service-accounts#default_service_account)
  /// is used.
  final String? serviceAccount;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// The labels with user-defined metadata to organize the
  /// NotebookRuntimeTemplates.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// The idle shutdown configuration of NotebookRuntimeTemplate. This config
  /// will only be set when idle shutdown is enabled.
  final NotebookIdleShutdownConfig? idleShutdownConfig;

  /// EUC configuration of the NotebookRuntimeTemplate.
  final NotebookEucConfig? eucConfig;

  /// Output only. Timestamp when this NotebookRuntimeTemplate was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this NotebookRuntimeTemplate was most recently
  /// updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Immutable. The type of the notebook runtime template.
  final NotebookRuntimeType? notebookRuntimeType;

  /// Optional. Immutable. Runtime Shielded VM spec.
  final ShieldedVmConfig? shieldedVmConfig;

  /// Optional. The Compute Engine tags to add to runtime (see [Tagging
  /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
  final List<String>? networkTags;

  /// Customer-managed encryption key spec for the notebook runtime.
  final EncryptionSpec? encryptionSpec;

  /// Optional. The notebook software configuration of the notebook runtime.
  final NotebookSoftwareConfig? softwareConfig;

  NotebookRuntimeTemplate({
    this.name,
    this.displayName,
    this.description,
    this.isDefault,
    this.machineSpec,
    this.dataPersistentDiskSpec,
    this.networkSpec,
    this.serviceAccount,
    this.etag,
    this.labels,
    this.idleShutdownConfig,
    this.eucConfig,
    this.createTime,
    this.updateTime,
    this.notebookRuntimeType,
    this.shieldedVmConfig,
    this.networkTags,
    this.encryptionSpec,
    this.softwareConfig,
  }) : super(fullyQualifiedName);

  factory NotebookRuntimeTemplate.fromJson(Map<String, dynamic> json) {
    return NotebookRuntimeTemplate(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      isDefault: json['isDefault'],
      machineSpec: decode(json['machineSpec'], MachineSpec.fromJson),
      dataPersistentDiskSpec: decode(
        json['dataPersistentDiskSpec'],
        PersistentDiskSpec.fromJson,
      ),
      networkSpec: decode(json['networkSpec'], NetworkSpec.fromJson),
      serviceAccount: json['serviceAccount'],
      etag: json['etag'],
      labels: decodeMap(json['labels']),
      idleShutdownConfig: decode(
        json['idleShutdownConfig'],
        NotebookIdleShutdownConfig.fromJson,
      ),
      eucConfig: decode(json['eucConfig'], NotebookEucConfig.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      notebookRuntimeType: decodeEnum(
        json['notebookRuntimeType'],
        NotebookRuntimeType.fromJson,
      ),
      shieldedVmConfig: decode(
        json['shieldedVmConfig'],
        ShieldedVmConfig.fromJson,
      ),
      networkTags: decodeList(json['networkTags']),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      softwareConfig: decode(
        json['softwareConfig'],
        NotebookSoftwareConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (isDefault != null) 'isDefault': isDefault,
      if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
      if (dataPersistentDiskSpec != null)
        'dataPersistentDiskSpec': dataPersistentDiskSpec!.toJson(),
      if (networkSpec != null) 'networkSpec': networkSpec!.toJson(),
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (etag != null) 'etag': etag,
      if (labels != null) 'labels': labels,
      if (idleShutdownConfig != null)
        'idleShutdownConfig': idleShutdownConfig!.toJson(),
      if (eucConfig != null) 'eucConfig': eucConfig!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (notebookRuntimeType != null)
        'notebookRuntimeType': notebookRuntimeType!.toJson(),
      if (shieldedVmConfig != null)
        'shieldedVmConfig': shieldedVmConfig!.toJson(),
      if (networkTags != null) 'networkTags': networkTags,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (softwareConfig != null) 'softwareConfig': softwareConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (isDefault != null) 'isDefault=$isDefault',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (etag != null) 'etag=$etag',
      if (notebookRuntimeType != null)
        'notebookRuntimeType=$notebookRuntimeType',
    ].join(',');
    return 'NotebookRuntimeTemplate($contents)';
  }
}

/// A runtime is a virtual machine allocated to a particular user for a
/// particular Notebook file on temporary basis with lifetime. Default runtimes
/// have a lifetime of 18 hours, while custom runtimes last for 6 months from
/// their creation or last upgrade.
final class NotebookRuntime extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookRuntime';

  /// Output only. The resource name of the NotebookRuntime.
  final String? name;

  /// Required. The user email of the NotebookRuntime.
  final String? runtimeUser;

  /// Output only. The pointer to NotebookRuntimeTemplate this NotebookRuntime is
  /// created from.
  final NotebookRuntimeTemplateRef? notebookRuntimeTemplateRef;

  /// Output only. The proxy endpoint used to access the NotebookRuntime.
  final String? proxyUri;

  /// Output only. Timestamp when this NotebookRuntime was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this NotebookRuntime was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. The health state of the NotebookRuntime.
  final NotebookRuntime_HealthState? healthState;

  /// Required. The display name of the NotebookRuntime.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// The description of the NotebookRuntime.
  final String? description;

  /// Output only. Deprecated: This field is no longer used and the "Vertex AI
  /// Notebook Service Account"
  /// (service-PROJECT_NUMBER@gcp-sa-aiplatform-vm.iam.gserviceaccount.com) is
  /// used for the runtime workload identity.
  /// See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-notebook-service-account
  /// for more details.
  ///
  /// The service account that the NotebookRuntime workload runs as.
  final String? serviceAccount;

  /// Output only. The runtime (instance) state of the NotebookRuntime.
  final NotebookRuntime_RuntimeState? runtimeState;

  /// Output only. Whether NotebookRuntime is upgradable.
  final bool? isUpgradable;

  /// The labels with user-defined metadata to organize your
  /// NotebookRuntime.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one NotebookRuntime
  /// (System labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable. Following system labels exist for NotebookRuntime:
  ///
  /// * "aiplatform.googleapis.com/notebook_runtime_gce_instance_id": output
  /// only, its value is the Compute Engine instance id.
  /// * "aiplatform.googleapis.com/colab_enterprise_entry_service": its value is
  /// either "bigquery" or "vertex"; if absent, it should be "vertex". This is to
  /// describe the entry service, either BigQuery or Vertex.
  final Map<String, String>? labels;

  /// Output only. Timestamp when this NotebookRuntime will be expired:
  /// 1. System Predefined NotebookRuntime: 24 hours after creation. After
  /// expiration, system predifined runtime will be deleted.
  /// 2. User created NotebookRuntime: 6 months after last upgrade. After
  /// expiration, user created runtime will be stopped and allowed for upgrade.
  final protobuf.Timestamp? expirationTime;

  /// Output only. The VM os image version of NotebookRuntime.
  final String? version;

  /// Output only. The type of the notebook runtime.
  final NotebookRuntimeType? notebookRuntimeType;

  /// Output only. The specification of a single machine used by the notebook
  /// runtime.
  final MachineSpec? machineSpec;

  /// Output only. The specification of [persistent
  /// disk][https://cloud.google.com/compute/docs/disks/persistent-disks]
  /// attached to the notebook runtime as data disk storage.
  final PersistentDiskSpec? dataPersistentDiskSpec;

  /// Output only. Network spec of the notebook runtime.
  final NetworkSpec? networkSpec;

  /// Output only. The idle shutdown configuration of the notebook runtime.
  final NotebookIdleShutdownConfig? idleShutdownConfig;

  /// Output only. EUC configuration of the notebook runtime.
  final NotebookEucConfig? eucConfig;

  /// Output only. Runtime Shielded VM spec.
  final ShieldedVmConfig? shieldedVmConfig;

  /// Optional. The Compute Engine tags to add to runtime (see [Tagging
  /// instances](https://cloud.google.com/vpc/docs/add-remove-network-tags)).
  final List<String>? networkTags;

  /// Output only. Software config of the notebook runtime.
  final NotebookSoftwareConfig? softwareConfig;

  /// Output only. Customer-managed encryption key spec for the notebook runtime.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  NotebookRuntime({
    this.name,
    this.runtimeUser,
    this.notebookRuntimeTemplateRef,
    this.proxyUri,
    this.createTime,
    this.updateTime,
    this.healthState,
    this.displayName,
    this.description,
    this.serviceAccount,
    this.runtimeState,
    this.isUpgradable,
    this.labels,
    this.expirationTime,
    this.version,
    this.notebookRuntimeType,
    this.machineSpec,
    this.dataPersistentDiskSpec,
    this.networkSpec,
    this.idleShutdownConfig,
    this.eucConfig,
    this.shieldedVmConfig,
    this.networkTags,
    this.softwareConfig,
    this.encryptionSpec,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory NotebookRuntime.fromJson(Map<String, dynamic> json) {
    return NotebookRuntime(
      name: json['name'],
      runtimeUser: json['runtimeUser'],
      notebookRuntimeTemplateRef: decode(
        json['notebookRuntimeTemplateRef'],
        NotebookRuntimeTemplateRef.fromJson,
      ),
      proxyUri: json['proxyUri'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      healthState: decodeEnum(
        json['healthState'],
        NotebookRuntime_HealthState.fromJson,
      ),
      displayName: json['displayName'],
      description: json['description'],
      serviceAccount: json['serviceAccount'],
      runtimeState: decodeEnum(
        json['runtimeState'],
        NotebookRuntime_RuntimeState.fromJson,
      ),
      isUpgradable: json['isUpgradable'],
      labels: decodeMap(json['labels']),
      expirationTime: decodeCustom(
        json['expirationTime'],
        protobuf.Timestamp.fromJson,
      ),
      version: json['version'],
      notebookRuntimeType: decodeEnum(
        json['notebookRuntimeType'],
        NotebookRuntimeType.fromJson,
      ),
      machineSpec: decode(json['machineSpec'], MachineSpec.fromJson),
      dataPersistentDiskSpec: decode(
        json['dataPersistentDiskSpec'],
        PersistentDiskSpec.fromJson,
      ),
      networkSpec: decode(json['networkSpec'], NetworkSpec.fromJson),
      idleShutdownConfig: decode(
        json['idleShutdownConfig'],
        NotebookIdleShutdownConfig.fromJson,
      ),
      eucConfig: decode(json['eucConfig'], NotebookEucConfig.fromJson),
      shieldedVmConfig: decode(
        json['shieldedVmConfig'],
        ShieldedVmConfig.fromJson,
      ),
      networkTags: decodeList(json['networkTags']),
      softwareConfig: decode(
        json['softwareConfig'],
        NotebookSoftwareConfig.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (runtimeUser != null) 'runtimeUser': runtimeUser,
      if (notebookRuntimeTemplateRef != null)
        'notebookRuntimeTemplateRef': notebookRuntimeTemplateRef!.toJson(),
      if (proxyUri != null) 'proxyUri': proxyUri,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (healthState != null) 'healthState': healthState!.toJson(),
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (runtimeState != null) 'runtimeState': runtimeState!.toJson(),
      if (isUpgradable != null) 'isUpgradable': isUpgradable,
      if (labels != null) 'labels': labels,
      if (expirationTime != null) 'expirationTime': expirationTime!.toJson(),
      if (version != null) 'version': version,
      if (notebookRuntimeType != null)
        'notebookRuntimeType': notebookRuntimeType!.toJson(),
      if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
      if (dataPersistentDiskSpec != null)
        'dataPersistentDiskSpec': dataPersistentDiskSpec!.toJson(),
      if (networkSpec != null) 'networkSpec': networkSpec!.toJson(),
      if (idleShutdownConfig != null)
        'idleShutdownConfig': idleShutdownConfig!.toJson(),
      if (eucConfig != null) 'eucConfig': eucConfig!.toJson(),
      if (shieldedVmConfig != null)
        'shieldedVmConfig': shieldedVmConfig!.toJson(),
      if (networkTags != null) 'networkTags': networkTags,
      if (softwareConfig != null) 'softwareConfig': softwareConfig!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (runtimeUser != null) 'runtimeUser=$runtimeUser',
      if (proxyUri != null) 'proxyUri=$proxyUri',
      if (healthState != null) 'healthState=$healthState',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (runtimeState != null) 'runtimeState=$runtimeState',
      if (isUpgradable != null) 'isUpgradable=$isUpgradable',
      if (version != null) 'version=$version',
      if (notebookRuntimeType != null)
        'notebookRuntimeType=$notebookRuntimeType',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'NotebookRuntime($contents)';
  }
}

/// The substate of the NotebookRuntime to display health information.
final class NotebookRuntime_HealthState extends protobuf.ProtoEnum {
  /// Unspecified health state.
  static const healthStateUnspecified = NotebookRuntime_HealthState(
    'HEALTH_STATE_UNSPECIFIED',
  );

  /// NotebookRuntime is in healthy state. Applies to ACTIVE state.
  static const healthy = NotebookRuntime_HealthState('HEALTHY');

  /// NotebookRuntime is in unhealthy state. Applies to ACTIVE state.
  static const unhealthy = NotebookRuntime_HealthState('UNHEALTHY');

  const NotebookRuntime_HealthState(super.value);

  factory NotebookRuntime_HealthState.fromJson(String json) =>
      NotebookRuntime_HealthState(json);

  @override
  String toString() => 'HealthState.$value';
}

/// The substate of the NotebookRuntime to display state of runtime.
/// The resource of NotebookRuntime is in ACTIVE state for these sub state.
final class NotebookRuntime_RuntimeState extends protobuf.ProtoEnum {
  /// Unspecified runtime state.
  static const runtimeStateUnspecified = NotebookRuntime_RuntimeState(
    'RUNTIME_STATE_UNSPECIFIED',
  );

  /// NotebookRuntime is in running state.
  static const running = NotebookRuntime_RuntimeState('RUNNING');

  /// NotebookRuntime is in starting state. This is when the runtime is being
  /// started from a stopped state.
  static const beingStarted = NotebookRuntime_RuntimeState('BEING_STARTED');

  /// NotebookRuntime is in stopping state.
  static const beingStopped = NotebookRuntime_RuntimeState('BEING_STOPPED');

  /// NotebookRuntime is in stopped state.
  static const stopped = NotebookRuntime_RuntimeState('STOPPED');

  /// NotebookRuntime is in upgrading state. It is in the middle of upgrading
  /// process.
  static const beingUpgraded = NotebookRuntime_RuntimeState('BEING_UPGRADED');

  /// NotebookRuntime was unable to start/stop properly.
  static const error = NotebookRuntime_RuntimeState('ERROR');

  /// NotebookRuntime is in invalid state. Cannot be recovered.
  static const invalid = NotebookRuntime_RuntimeState('INVALID');

  const NotebookRuntime_RuntimeState(super.value);

  factory NotebookRuntime_RuntimeState.fromJson(String json) =>
      NotebookRuntime_RuntimeState(json);

  @override
  String toString() => 'RuntimeState.$value';
}

/// Points to a NotebookRuntimeTemplateRef.
final class NotebookRuntimeTemplateRef extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookRuntimeTemplateRef';

  /// Immutable. A resource name of the NotebookRuntimeTemplate.
  final String? notebookRuntimeTemplate;

  NotebookRuntimeTemplateRef({this.notebookRuntimeTemplate})
    : super(fullyQualifiedName);

  factory NotebookRuntimeTemplateRef.fromJson(Map<String, dynamic> json) {
    return NotebookRuntimeTemplateRef(
      notebookRuntimeTemplate: json['notebookRuntimeTemplate'],
    );
  }

  @override
  Object toJson() {
    return {
      if (notebookRuntimeTemplate != null)
        'notebookRuntimeTemplate': notebookRuntimeTemplate,
    };
  }

  @override
  String toString() {
    final contents = [
      if (notebookRuntimeTemplate != null)
        'notebookRuntimeTemplate=$notebookRuntimeTemplate',
    ].join(',');
    return 'NotebookRuntimeTemplateRef($contents)';
  }
}

/// Request message for
/// `NotebookService.CreateNotebookRuntimeTemplate`.
final class CreateNotebookRuntimeTemplateRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNotebookRuntimeTemplateRequest';

  /// Required. The resource name of the Location to create the
  /// NotebookRuntimeTemplate. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The NotebookRuntimeTemplate to create.
  final NotebookRuntimeTemplate notebookRuntimeTemplate;

  /// Optional. User specified ID for the notebook runtime template.
  final String? notebookRuntimeTemplateId;

  CreateNotebookRuntimeTemplateRequest({
    required this.parent,
    required this.notebookRuntimeTemplate,
    this.notebookRuntimeTemplateId,
  }) : super(fullyQualifiedName);

  factory CreateNotebookRuntimeTemplateRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateNotebookRuntimeTemplateRequest(
      parent: json['parent'],
      notebookRuntimeTemplate: decode(
        json['notebookRuntimeTemplate'],
        NotebookRuntimeTemplate.fromJson,
      )!,
      notebookRuntimeTemplateId: json['notebookRuntimeTemplateId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'notebookRuntimeTemplate': notebookRuntimeTemplate.toJson(),
      if (notebookRuntimeTemplateId != null)
        'notebookRuntimeTemplateId': notebookRuntimeTemplateId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (notebookRuntimeTemplateId != null)
        'notebookRuntimeTemplateId=$notebookRuntimeTemplateId',
    ].join(',');
    return 'CreateNotebookRuntimeTemplateRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.CreateNotebookRuntimeTemplate`.
final class CreateNotebookRuntimeTemplateOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNotebookRuntimeTemplateOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateNotebookRuntimeTemplateOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateNotebookRuntimeTemplateOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateNotebookRuntimeTemplateOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateNotebookRuntimeTemplateOperationMetadata()';
}

/// Request message for
/// `NotebookService.GetNotebookRuntimeTemplate`
final class GetNotebookRuntimeTemplateRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNotebookRuntimeTemplateRequest';

  /// Required. The name of the NotebookRuntimeTemplate resource.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  final String name;

  GetNotebookRuntimeTemplateRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetNotebookRuntimeTemplateRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return GetNotebookRuntimeTemplateRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetNotebookRuntimeTemplateRequest($contents)';
  }
}

/// Request message for
/// `NotebookService.ListNotebookRuntimeTemplates`.
final class ListNotebookRuntimeTemplatesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookRuntimeTemplatesRequest';

  /// Required. The resource name of the Location from which to list the
  /// NotebookRuntimeTemplates.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
  ///     represents the NotebookRuntimeTemplate ID,
  ///     i.e. the last segment of the NotebookRuntimeTemplate's [resource name]
  ///     [google.cloud.aiplatform.v1beta1.NotebookRuntimeTemplate.name].
  ///   * `display_name` supports = and !=
  ///   * `labels` supports general map functions that is:
  ///     * `labels.key=value` - key:value equality
  ///     * `labels.key:* or labels:key - key existence
  ///     * A key including a space must be quoted. `labels."a key"`.
  ///   * `notebookRuntimeType` supports = and !=. notebookRuntimeType enum:
  ///   [USER_DEFINED, ONE_CLICK].
  ///   * `machineType` supports = and !=.
  ///   * `acceleratorType` supports = and !=.
  ///
  /// Some examples:
  ///
  ///   * `notebookRuntimeTemplate=notebookRuntimeTemplate123`
  ///   * `displayName="myDisplayName"`
  ///   * `labels.myKey="myValue"`
  ///   * `notebookRuntimeType=USER_DEFINED`
  ///   * `machineType=e2-standard-4`
  ///   * `acceleratorType=NVIDIA_TESLA_T4`
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListNotebookRuntimeTemplatesResponse.next_page_token`
  /// of the previous
  /// `NotebookService.ListNotebookRuntimeTemplates`
  /// call.
  final String? pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `display_name, create_time desc`.
  final String? orderBy;

  ListNotebookRuntimeTemplatesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListNotebookRuntimeTemplatesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListNotebookRuntimeTemplatesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListNotebookRuntimeTemplatesRequest($contents)';
  }
}

/// Response message for
/// `NotebookService.ListNotebookRuntimeTemplates`.
final class ListNotebookRuntimeTemplatesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookRuntimeTemplatesResponse';

  /// List of NotebookRuntimeTemplates in the requested page.
  final List<NotebookRuntimeTemplate>? notebookRuntimeTemplates;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListNotebookRuntimeTemplatesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListNotebookRuntimeTemplatesResponse({
    this.notebookRuntimeTemplates,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListNotebookRuntimeTemplatesResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListNotebookRuntimeTemplatesResponse(
      notebookRuntimeTemplates: decodeListMessage(
        json['notebookRuntimeTemplates'],
        NotebookRuntimeTemplate.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (notebookRuntimeTemplates != null)
        'notebookRuntimeTemplates': encodeList(notebookRuntimeTemplates),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListNotebookRuntimeTemplatesResponse($contents)';
  }
}

/// Request message for
/// `NotebookService.DeleteNotebookRuntimeTemplate`.
final class DeleteNotebookRuntimeTemplateRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteNotebookRuntimeTemplateRequest';

  /// Required. The name of the NotebookRuntimeTemplate resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/notebookRuntimeTemplates/{notebook_runtime_template}`
  final String name;

  DeleteNotebookRuntimeTemplateRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteNotebookRuntimeTemplateRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteNotebookRuntimeTemplateRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteNotebookRuntimeTemplateRequest($contents)';
  }
}

/// Request message for
/// `NotebookService.UpdateNotebookRuntimeTemplate`.
final class UpdateNotebookRuntimeTemplateRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateNotebookRuntimeTemplateRequest';

  /// Required. The NotebookRuntimeTemplate to update.
  final NotebookRuntimeTemplate notebookRuntimeTemplate;

  /// Required. The update mask applies to the resource.
  /// For the `FieldMask` definition, see
  /// `google.protobuf.FieldMask`. Input format:
  /// `{paths: "${updated_filed}"}` Updatable fields:
  ///
  ///   * `encryption_spec.kms_key_name`
  final protobuf.FieldMask? updateMask;

  UpdateNotebookRuntimeTemplateRequest({
    required this.notebookRuntimeTemplate,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdateNotebookRuntimeTemplateRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateNotebookRuntimeTemplateRequest(
      notebookRuntimeTemplate: decode(
        json['notebookRuntimeTemplate'],
        NotebookRuntimeTemplate.fromJson,
      )!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'notebookRuntimeTemplate': notebookRuntimeTemplate.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateNotebookRuntimeTemplateRequest()';
}

/// Request message for
/// `NotebookService.AssignNotebookRuntime`.
final class AssignNotebookRuntimeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssignNotebookRuntimeRequest';

  /// Required. The resource name of the Location to get the NotebookRuntime
  /// assignment. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The resource name of the NotebookRuntimeTemplate based on which a
  /// NotebookRuntime will be assigned (reuse or create a new one).
  final String? notebookRuntimeTemplate;

  /// Required. Provide runtime specific information (e.g. runtime owner,
  /// notebook id) used for NotebookRuntime assignment.
  final NotebookRuntime? notebookRuntime;

  /// Optional. User specified ID for the notebook runtime.
  final String? notebookRuntimeId;

  AssignNotebookRuntimeRequest({
    required this.parent,
    this.notebookRuntimeTemplate,
    this.notebookRuntime,
    this.notebookRuntimeId,
  }) : super(fullyQualifiedName);

  factory AssignNotebookRuntimeRequest.fromJson(Map<String, dynamic> json) {
    return AssignNotebookRuntimeRequest(
      parent: json['parent'],
      notebookRuntimeTemplate: json['notebookRuntimeTemplate'],
      notebookRuntime: decode(
        json['notebookRuntime'],
        NotebookRuntime.fromJson,
      ),
      notebookRuntimeId: json['notebookRuntimeId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (notebookRuntimeTemplate != null)
        'notebookRuntimeTemplate': notebookRuntimeTemplate,
      if (notebookRuntime != null) 'notebookRuntime': notebookRuntime!.toJson(),
      if (notebookRuntimeId != null) 'notebookRuntimeId': notebookRuntimeId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (notebookRuntimeTemplate != null)
        'notebookRuntimeTemplate=$notebookRuntimeTemplate',
      if (notebookRuntimeId != null) 'notebookRuntimeId=$notebookRuntimeId',
    ].join(',');
    return 'AssignNotebookRuntimeRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.AssignNotebookRuntime`.
final class AssignNotebookRuntimeOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AssignNotebookRuntimeOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// A human-readable message that shows the intermediate progress details of
  /// NotebookRuntime.
  final String? progressMessage;

  AssignNotebookRuntimeOperationMetadata({
    this.genericMetadata,
    this.progressMessage,
  }) : super(fullyQualifiedName);

  factory AssignNotebookRuntimeOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return AssignNotebookRuntimeOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      progressMessage: json['progressMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (progressMessage != null) 'progressMessage': progressMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (progressMessage != null) 'progressMessage=$progressMessage',
    ].join(',');
    return 'AssignNotebookRuntimeOperationMetadata($contents)';
  }
}

/// Request message for
/// `NotebookService.GetNotebookRuntime`
final class GetNotebookRuntimeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  GetNotebookRuntimeRequest({required this.name}) : super(fullyQualifiedName);

  factory GetNotebookRuntimeRequest.fromJson(Map<String, dynamic> json) {
    return GetNotebookRuntimeRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetNotebookRuntimeRequest($contents)';
  }
}

/// Request message for
/// `NotebookService.ListNotebookRuntimes`.
final class ListNotebookRuntimesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookRuntimesRequest';

  /// Required. The resource name of the Location from which to list the
  /// NotebookRuntimes.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `notebookRuntime` supports = and !=. `notebookRuntime` represents the
  ///     NotebookRuntime ID,
  ///     i.e. the last segment of the NotebookRuntime's [resource name]
  ///     [google.cloud.aiplatform.v1beta1.NotebookRuntime.name].
  ///   * `displayName` supports = and != and regex.
  ///   * `notebookRuntimeTemplate` supports = and !=. `notebookRuntimeTemplate`
  ///     represents the NotebookRuntimeTemplate ID,
  ///     i.e. the last segment of the NotebookRuntimeTemplate's [resource name]
  ///     [google.cloud.aiplatform.v1beta1.NotebookRuntimeTemplate.name].
  ///   * `healthState` supports = and !=. healthState enum: [HEALTHY, UNHEALTHY,
  ///   HEALTH_STATE_UNSPECIFIED].
  ///   * `runtimeState` supports = and !=. runtimeState enum:
  ///   [RUNTIME_STATE_UNSPECIFIED, RUNNING, BEING_STARTED, BEING_STOPPED,
  ///   STOPPED, BEING_UPGRADED, ERROR, INVALID].
  ///   * `runtimeUser` supports = and !=.
  ///   * API version is UI only: `uiState` supports = and !=. uiState enum:
  ///   [UI_RESOURCE_STATE_UNSPECIFIED, UI_RESOURCE_STATE_BEING_CREATED,
  ///   UI_RESOURCE_STATE_ACTIVE, UI_RESOURCE_STATE_BEING_DELETED,
  ///   UI_RESOURCE_STATE_CREATION_FAILED].
  ///   * `notebookRuntimeType` supports = and !=. notebookRuntimeType enum:
  ///   [USER_DEFINED, ONE_CLICK].
  ///   * `machineType` supports = and !=.
  ///   * `acceleratorType` supports = and !=.
  ///
  /// Some examples:
  ///
  ///   * `notebookRuntime="notebookRuntime123"`
  ///   * `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
  ///   * `notebookRuntimeTemplate="notebookRuntimeTemplate321"`
  ///   * `healthState=HEALTHY`
  ///   * `runtimeState=RUNNING`
  ///   * `runtimeUser="test@google.com"`
  ///   * `uiState=UI_RESOURCE_STATE_BEING_DELETED`
  ///   * `notebookRuntimeType=USER_DEFINED`
  ///   * `machineType=e2-standard-4`
  ///   * `acceleratorType=NVIDIA_TESLA_T4`
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListNotebookRuntimesResponse.next_page_token`
  /// of the previous
  /// `NotebookService.ListNotebookRuntimes`
  /// call.
  final String? pageToken;

  /// Optional. Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `display_name, create_time desc`.
  final String? orderBy;

  ListNotebookRuntimesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListNotebookRuntimesRequest.fromJson(Map<String, dynamic> json) {
    return ListNotebookRuntimesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListNotebookRuntimesRequest($contents)';
  }
}

/// Response message for
/// `NotebookService.ListNotebookRuntimes`.
final class ListNotebookRuntimesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookRuntimesResponse';

  /// List of NotebookRuntimes in the requested page.
  final List<NotebookRuntime>? notebookRuntimes;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListNotebookRuntimesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListNotebookRuntimesResponse({this.notebookRuntimes, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListNotebookRuntimesResponse.fromJson(Map<String, dynamic> json) {
    return ListNotebookRuntimesResponse(
      notebookRuntimes: decodeListMessage(
        json['notebookRuntimes'],
        NotebookRuntime.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (notebookRuntimes != null)
        'notebookRuntimes': encodeList(notebookRuntimes),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListNotebookRuntimesResponse($contents)';
  }
}

/// Request message for
/// `NotebookService.DeleteNotebookRuntime`.
final class DeleteNotebookRuntimeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource to be deleted.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  DeleteNotebookRuntimeRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteNotebookRuntimeRequest.fromJson(Map<String, dynamic> json) {
    return DeleteNotebookRuntimeRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteNotebookRuntimeRequest($contents)';
  }
}

/// Request message for
/// `NotebookService.UpgradeNotebookRuntime`.
final class UpgradeNotebookRuntimeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpgradeNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource to be upgrade.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  UpgradeNotebookRuntimeRequest({required this.name})
    : super(fullyQualifiedName);

  factory UpgradeNotebookRuntimeRequest.fromJson(Map<String, dynamic> json) {
    return UpgradeNotebookRuntimeRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'UpgradeNotebookRuntimeRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.UpgradeNotebookRuntime`.
final class UpgradeNotebookRuntimeOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpgradeNotebookRuntimeOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// A human-readable message that shows the intermediate progress details of
  /// NotebookRuntime.
  final String? progressMessage;

  UpgradeNotebookRuntimeOperationMetadata({
    this.genericMetadata,
    this.progressMessage,
  }) : super(fullyQualifiedName);

  factory UpgradeNotebookRuntimeOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpgradeNotebookRuntimeOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      progressMessage: json['progressMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (progressMessage != null) 'progressMessage': progressMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (progressMessage != null) 'progressMessage=$progressMessage',
    ].join(',');
    return 'UpgradeNotebookRuntimeOperationMetadata($contents)';
  }
}

/// Response message for
/// `NotebookService.UpgradeNotebookRuntime`.
final class UpgradeNotebookRuntimeResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpgradeNotebookRuntimeResponse';

  UpgradeNotebookRuntimeResponse() : super(fullyQualifiedName);

  factory UpgradeNotebookRuntimeResponse.fromJson(Map<String, dynamic> json) {
    return UpgradeNotebookRuntimeResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'UpgradeNotebookRuntimeResponse()';
}

/// Request message for
/// `NotebookService.StartNotebookRuntime`.
final class StartNotebookRuntimeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StartNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource to be started.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  StartNotebookRuntimeRequest({required this.name}) : super(fullyQualifiedName);

  factory StartNotebookRuntimeRequest.fromJson(Map<String, dynamic> json) {
    return StartNotebookRuntimeRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StartNotebookRuntimeRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.StartNotebookRuntime`.
final class StartNotebookRuntimeOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StartNotebookRuntimeOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// A human-readable message that shows the intermediate progress details of
  /// NotebookRuntime.
  final String? progressMessage;

  StartNotebookRuntimeOperationMetadata({
    this.genericMetadata,
    this.progressMessage,
  }) : super(fullyQualifiedName);

  factory StartNotebookRuntimeOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return StartNotebookRuntimeOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      progressMessage: json['progressMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (progressMessage != null) 'progressMessage': progressMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (progressMessage != null) 'progressMessage=$progressMessage',
    ].join(',');
    return 'StartNotebookRuntimeOperationMetadata($contents)';
  }
}

/// Response message for
/// `NotebookService.StartNotebookRuntime`.
final class StartNotebookRuntimeResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StartNotebookRuntimeResponse';

  StartNotebookRuntimeResponse() : super(fullyQualifiedName);

  factory StartNotebookRuntimeResponse.fromJson(Map<String, dynamic> json) {
    return StartNotebookRuntimeResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'StartNotebookRuntimeResponse()';
}

/// Request message for
/// `NotebookService.StopNotebookRuntime`.
final class StopNotebookRuntimeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StopNotebookRuntimeRequest';

  /// Required. The name of the NotebookRuntime resource to be stopped.
  /// Instead of checking whether the name is in valid NotebookRuntime resource
  /// name format, directly throw NotFound exception if there is no such
  /// NotebookRuntime in spanner.
  final String name;

  StopNotebookRuntimeRequest({required this.name}) : super(fullyQualifiedName);

  factory StopNotebookRuntimeRequest.fromJson(Map<String, dynamic> json) {
    return StopNotebookRuntimeRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StopNotebookRuntimeRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.StopNotebookRuntime`.
final class StopNotebookRuntimeOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StopNotebookRuntimeOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  StopNotebookRuntimeOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory StopNotebookRuntimeOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return StopNotebookRuntimeOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'StopNotebookRuntimeOperationMetadata()';
}

/// Response message for
/// `NotebookService.StopNotebookRuntime`.
final class StopNotebookRuntimeResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StopNotebookRuntimeResponse';

  StopNotebookRuntimeResponse() : super(fullyQualifiedName);

  factory StopNotebookRuntimeResponse.fromJson(Map<String, dynamic> json) {
    return StopNotebookRuntimeResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'StopNotebookRuntimeResponse()';
}

/// Request message for [NotebookService.CreateNotebookExecutionJob]
final class CreateNotebookExecutionJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNotebookExecutionJobRequest';

  /// Required. The resource name of the Location to create the
  /// NotebookExecutionJob. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The NotebookExecutionJob to create.
  final NotebookExecutionJob notebookExecutionJob;

  /// Optional. User specified ID for the NotebookExecutionJob.
  final String? notebookExecutionJobId;

  CreateNotebookExecutionJobRequest({
    required this.parent,
    required this.notebookExecutionJob,
    this.notebookExecutionJobId,
  }) : super(fullyQualifiedName);

  factory CreateNotebookExecutionJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateNotebookExecutionJobRequest(
      parent: json['parent'],
      notebookExecutionJob: decode(
        json['notebookExecutionJob'],
        NotebookExecutionJob.fromJson,
      )!,
      notebookExecutionJobId: json['notebookExecutionJobId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'notebookExecutionJob': notebookExecutionJob.toJson(),
      if (notebookExecutionJobId != null)
        'notebookExecutionJobId': notebookExecutionJobId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (notebookExecutionJobId != null)
        'notebookExecutionJobId=$notebookExecutionJobId',
    ].join(',');
    return 'CreateNotebookExecutionJobRequest($contents)';
  }
}

/// Metadata information for
/// `NotebookService.CreateNotebookExecutionJob`.
final class CreateNotebookExecutionJobOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateNotebookExecutionJobOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// A human-readable message that shows the intermediate progress details of
  /// NotebookRuntime.
  final String? progressMessage;

  CreateNotebookExecutionJobOperationMetadata({
    this.genericMetadata,
    this.progressMessage,
  }) : super(fullyQualifiedName);

  factory CreateNotebookExecutionJobOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateNotebookExecutionJobOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      progressMessage: json['progressMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (progressMessage != null) 'progressMessage': progressMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (progressMessage != null) 'progressMessage=$progressMessage',
    ].join(',');
    return 'CreateNotebookExecutionJobOperationMetadata($contents)';
  }
}

/// Request message for [NotebookService.GetNotebookExecutionJob]
final class GetNotebookExecutionJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetNotebookExecutionJobRequest';

  /// Required. The name of the NotebookExecutionJob resource.
  final String name;

  /// Optional. The NotebookExecutionJob view. Defaults to BASIC.
  final NotebookExecutionJobView? view;

  GetNotebookExecutionJobRequest({required this.name, this.view})
    : super(fullyQualifiedName);

  factory GetNotebookExecutionJobRequest.fromJson(Map<String, dynamic> json) {
    return GetNotebookExecutionJobRequest(
      name: json['name'],
      view: decodeEnum(json['view'], NotebookExecutionJobView.fromJson),
    );
  }

  @override
  Object toJson() {
    return {'name': name, if (view != null) 'view': view!.toJson()};
  }

  @override
  String toString() {
    final contents = ['name=$name', if (view != null) 'view=$view'].join(',');
    return 'GetNotebookExecutionJobRequest($contents)';
  }
}

/// Request message for [NotebookService.ListNotebookExecutionJobs]
final class ListNotebookExecutionJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookExecutionJobsRequest';

  /// Required. The resource name of the Location from which to list the
  /// NotebookExecutionJobs.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. An expression for filtering the results of the request. For field
  /// names both snake_case and camelCase are supported.
  ///
  ///   * `notebookExecutionJob` supports = and !=. `notebookExecutionJob`
  ///   represents the NotebookExecutionJob ID.
  ///   * `displayName` supports = and != and regex.
  ///   * `schedule` supports = and != and regex.
  ///
  /// Some examples:
  ///   * `notebookExecutionJob="123"`
  ///   * `notebookExecutionJob="my-execution-job"`
  ///   * `displayName="myDisplayName"` and `displayName=~"myDisplayNameRegex"`
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListNotebookExecutionJobsResponse.next_page_token`
  /// of the previous
  /// `NotebookService.ListNotebookExecutionJobs`
  /// call.
  final String? pageToken;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///
  ///   * `display_name`
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `display_name, create_time desc`.
  final String? orderBy;

  /// Optional. The NotebookExecutionJob view. Defaults to BASIC.
  final NotebookExecutionJobView? view;

  ListNotebookExecutionJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.view,
  }) : super(fullyQualifiedName);

  factory ListNotebookExecutionJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListNotebookExecutionJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      view: decodeEnum(json['view'], NotebookExecutionJobView.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (view != null) 'view': view!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
      if (view != null) 'view=$view',
    ].join(',');
    return 'ListNotebookExecutionJobsRequest($contents)';
  }
}

/// Response message for [NotebookService.CreateNotebookExecutionJob]
final class ListNotebookExecutionJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListNotebookExecutionJobsResponse';

  /// List of NotebookExecutionJobs in the requested page.
  final List<NotebookExecutionJob>? notebookExecutionJobs;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListNotebookExecutionJobsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListNotebookExecutionJobsResponse({
    this.notebookExecutionJobs,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListNotebookExecutionJobsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListNotebookExecutionJobsResponse(
      notebookExecutionJobs: decodeListMessage(
        json['notebookExecutionJobs'],
        NotebookExecutionJob.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (notebookExecutionJobs != null)
        'notebookExecutionJobs': encodeList(notebookExecutionJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListNotebookExecutionJobsResponse($contents)';
  }
}

/// Request message for [NotebookService.DeleteNotebookExecutionJob]
final class DeleteNotebookExecutionJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteNotebookExecutionJobRequest';

  /// Required. The name of the NotebookExecutionJob resource to be deleted.
  final String name;

  DeleteNotebookExecutionJobRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteNotebookExecutionJobRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteNotebookExecutionJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteNotebookExecutionJobRequest($contents)';
  }
}

final class PostStartupScriptConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PostStartupScriptConfig';

  final String? postStartupScript;

  final String? postStartupScriptUrl;

  final PostStartupScriptConfig_PostStartupScriptBehavior?
  postStartupScriptBehavior;

  PostStartupScriptConfig({
    this.postStartupScript,
    this.postStartupScriptUrl,
    this.postStartupScriptBehavior,
  }) : super(fullyQualifiedName);

  factory PostStartupScriptConfig.fromJson(Map<String, dynamic> json) {
    return PostStartupScriptConfig(
      postStartupScript: json['postStartupScript'],
      postStartupScriptUrl: json['postStartupScriptUrl'],
      postStartupScriptBehavior: decodeEnum(
        json['postStartupScriptBehavior'],
        PostStartupScriptConfig_PostStartupScriptBehavior.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (postStartupScript != null) 'postStartupScript': postStartupScript,
      if (postStartupScriptUrl != null)
        'postStartupScriptUrl': postStartupScriptUrl,
      if (postStartupScriptBehavior != null)
        'postStartupScriptBehavior': postStartupScriptBehavior!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (postStartupScript != null) 'postStartupScript=$postStartupScript',
      if (postStartupScriptUrl != null)
        'postStartupScriptUrl=$postStartupScriptUrl',
      if (postStartupScriptBehavior != null)
        'postStartupScriptBehavior=$postStartupScriptBehavior',
    ].join(',');
    return 'PostStartupScriptConfig($contents)';
  }
}

final class PostStartupScriptConfig_PostStartupScriptBehavior
    extends protobuf.ProtoEnum {
  static const postStartupScriptBehaviorUnspecified =
      PostStartupScriptConfig_PostStartupScriptBehavior(
        'POST_STARTUP_SCRIPT_BEHAVIOR_UNSPECIFIED',
      );

  static const runOnce = PostStartupScriptConfig_PostStartupScriptBehavior(
    'RUN_ONCE',
  );

  static const runEveryStart =
      PostStartupScriptConfig_PostStartupScriptBehavior('RUN_EVERY_START');

  static const downloadAndRunEveryStart =
      PostStartupScriptConfig_PostStartupScriptBehavior(
        'DOWNLOAD_AND_RUN_EVERY_START',
      );

  const PostStartupScriptConfig_PostStartupScriptBehavior(super.value);

  factory PostStartupScriptConfig_PostStartupScriptBehavior.fromJson(
    String json,
  ) => PostStartupScriptConfig_PostStartupScriptBehavior(json);

  @override
  String toString() => 'PostStartupScriptBehavior.$value';
}

/// Colab image of the runtime.
final class ColabImage extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ColabImage';

  /// Optional. The release name of the NotebookRuntime Colab image, e.g.
  /// "py310". If not specified, detault to the latest release.
  final String? releaseName;

  /// Output only. A human-readable description of the specified colab image
  /// release, populated by the system. Example: "Python 3.10", "Latest - current
  /// Python 3.11"
  final String? description;

  ColabImage({this.releaseName, this.description}) : super(fullyQualifiedName);

  factory ColabImage.fromJson(Map<String, dynamic> json) {
    return ColabImage(
      releaseName: json['releaseName'],
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (releaseName != null) 'releaseName': releaseName,
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (releaseName != null) 'releaseName=$releaseName',
      if (description != null) 'description=$description',
    ].join(',');
    return 'ColabImage($contents)';
  }
}

/// Notebook Software Config. This is passed to the backend when user
/// makes software configurations in UI.
final class NotebookSoftwareConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.NotebookSoftwareConfig';

  /// Optional. Google-managed NotebookRuntime colab image.
  final ColabImage? colabImage;

  /// Optional. Environment variables to be passed to the container.
  /// Maximum limit is 100.
  final List<EnvVar>? env;

  final PostStartupScriptConfig? postStartupScriptConfig;

  NotebookSoftwareConfig({
    this.colabImage,
    this.env,
    this.postStartupScriptConfig,
  }) : super(fullyQualifiedName);

  factory NotebookSoftwareConfig.fromJson(Map<String, dynamic> json) {
    return NotebookSoftwareConfig(
      colabImage: decode(json['colabImage'], ColabImage.fromJson),
      env: decodeListMessage(json['env'], EnvVar.fromJson),
      postStartupScriptConfig: decode(
        json['postStartupScriptConfig'],
        PostStartupScriptConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (colabImage != null) 'colabImage': colabImage!.toJson(),
      if (env != null) 'env': encodeList(env),
      if (postStartupScriptConfig != null)
        'postStartupScriptConfig': postStartupScriptConfig!.toJson(),
    };
  }

  @override
  String toString() => 'NotebookSoftwareConfig()';
}

/// Schema is used to define the format of input/output data. Represents a select
/// subset of an [OpenAPI 3.0 schema
/// object](https://spec.openapis.org/oas/v3.0.3#schema-object). More fields may
/// be added in the future as needed.
final class Schema extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Schema';

  /// Optional. The type of the data.
  final Type? type;

  /// Optional. The format of the data.
  /// Supported formats:
  ///  for NUMBER type: "float", "double"
  ///  for INTEGER type: "int32", "int64"
  ///  for STRING type: "email", "byte", etc
  final String? format;

  /// Optional. The title of the Schema.
  final String? title;

  /// Optional. The description of the data.
  final String? description;

  /// Optional. Indicates if the value may be null.
  final bool? nullable;

  /// Optional. Default value of the data.
  final protobuf.Value? default$;

  /// Optional. SCHEMA FIELDS FOR TYPE ARRAY
  /// Schema of the elements of Type.ARRAY.
  final Schema? items;

  /// Optional. Minimum number of the elements for Type.ARRAY.
  final int? minItems;

  /// Optional. Maximum number of the elements for Type.ARRAY.
  final int? maxItems;

  /// Optional. Possible values of the element of Type.STRING with enum format.
  /// For example we can define an Enum Direction as :
  /// {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
  final List<String>? enum$;

  /// Optional. SCHEMA FIELDS FOR TYPE OBJECT
  /// Properties of Type.OBJECT.
  final Map<String, Schema>? properties;

  /// Optional. The order of the properties.
  /// Not a standard field in open api spec. Only used to support the order of
  /// the properties.
  final List<String>? propertyOrdering;

  /// Optional. Required properties of Type.OBJECT.
  final List<String>? required;

  /// Optional. Minimum number of the properties for Type.OBJECT.
  final int? minProperties;

  /// Optional. Maximum number of the properties for Type.OBJECT.
  final int? maxProperties;

  /// Optional. SCHEMA FIELDS FOR TYPE INTEGER and NUMBER
  /// Minimum value of the Type.INTEGER and Type.NUMBER
  final double? minimum;

  /// Optional. Maximum value of the Type.INTEGER and Type.NUMBER
  final double? maximum;

  /// Optional. SCHEMA FIELDS FOR TYPE STRING
  /// Minimum length of the Type.STRING
  final int? minLength;

  /// Optional. Maximum length of the Type.STRING
  final int? maxLength;

  /// Optional. Pattern of the Type.STRING to restrict a string to a regular
  /// expression.
  final String? pattern;

  /// Optional. Example of the object. Will only populated when the object is the
  /// root.
  final protobuf.Value? example;

  /// Optional. The value should be validated against any (one or more) of the
  /// subschemas in the list.
  final List<Schema>? anyOf;

  /// Optional. Can either be a boolean or an object; controls the presence of
  /// additional properties.
  final protobuf.Value? additionalProperties;

  /// Optional. Allows indirect references between schema nodes. The value should
  /// be a valid reference to a child of the root `defs`.
  ///
  /// For example, the following schema defines a reference to a schema node
  /// named "Pet":
  ///
  /// type: object
  /// properties:
  ///   pet:
  ///     ref: #/defs/Pet
  /// defs:
  ///   Pet:
  ///     type: object
  ///     properties:
  ///       name:
  ///         type: string
  ///
  /// The value of the "pet" property is a reference to the schema node
  /// named "Pet".
  /// See details in
  /// https://json-schema.org/understanding-json-schema/structuring
  final String? ref;

  /// Optional. A map of definitions for use by `ref`
  /// Only allowed at the root of the schema.
  final Map<String, Schema>? defs;

  Schema({
    this.type,
    this.format,
    this.title,
    this.description,
    this.nullable,
    this.default$,
    this.items,
    this.minItems,
    this.maxItems,
    this.enum$,
    this.properties,
    this.propertyOrdering,
    this.required,
    this.minProperties,
    this.maxProperties,
    this.minimum,
    this.maximum,
    this.minLength,
    this.maxLength,
    this.pattern,
    this.example,
    this.anyOf,
    this.additionalProperties,
    this.ref,
    this.defs,
  }) : super(fullyQualifiedName);

  factory Schema.fromJson(Map<String, dynamic> json) {
    return Schema(
      type: decodeEnum(json['type'], Type.fromJson),
      format: json['format'],
      title: json['title'],
      description: json['description'],
      nullable: json['nullable'],
      default$: decodeCustom(json['default'], protobuf.Value.fromJson),
      items: decode(json['items'], Schema.fromJson),
      minItems: decodeInt64(json['minItems']),
      maxItems: decodeInt64(json['maxItems']),
      enum$: decodeList(json['enum']),
      properties: decodeMapMessage(json['properties'], Schema.fromJson),
      propertyOrdering: decodeList(json['propertyOrdering']),
      required: decodeList(json['required']),
      minProperties: decodeInt64(json['minProperties']),
      maxProperties: decodeInt64(json['maxProperties']),
      minimum: decodeDouble(json['minimum']),
      maximum: decodeDouble(json['maximum']),
      minLength: decodeInt64(json['minLength']),
      maxLength: decodeInt64(json['maxLength']),
      pattern: json['pattern'],
      example: decodeCustom(json['example'], protobuf.Value.fromJson),
      anyOf: decodeListMessage(json['anyOf'], Schema.fromJson),
      additionalProperties: decodeCustom(
        json['additionalProperties'],
        protobuf.Value.fromJson,
      ),
      ref: json['ref'],
      defs: decodeMapMessage(json['defs'], Schema.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (type != null) 'type': type!.toJson(),
      if (format != null) 'format': format,
      if (title != null) 'title': title,
      if (description != null) 'description': description,
      if (nullable != null) 'nullable': nullable,
      if (default$ != null) 'default': default$!.toJson(),
      if (items != null) 'items': items!.toJson(),
      if (minItems != null) 'minItems': encodeInt64(minItems),
      if (maxItems != null) 'maxItems': encodeInt64(maxItems),
      if (enum$ != null) 'enum': enum$,
      if (properties != null) 'properties': encodeMap(properties),
      if (propertyOrdering != null) 'propertyOrdering': propertyOrdering,
      if (required != null) 'required': required,
      if (minProperties != null) 'minProperties': encodeInt64(minProperties),
      if (maxProperties != null) 'maxProperties': encodeInt64(maxProperties),
      if (minimum != null) 'minimum': encodeDouble(minimum),
      if (maximum != null) 'maximum': encodeDouble(maximum),
      if (minLength != null) 'minLength': encodeInt64(minLength),
      if (maxLength != null) 'maxLength': encodeInt64(maxLength),
      if (pattern != null) 'pattern': pattern,
      if (example != null) 'example': example!.toJson(),
      if (anyOf != null) 'anyOf': encodeList(anyOf),
      if (additionalProperties != null)
        'additionalProperties': additionalProperties!.toJson(),
      if (ref != null) 'ref': ref,
      if (defs != null) 'defs': encodeMap(defs),
    };
  }

  @override
  String toString() {
    final contents = [
      if (type != null) 'type=$type',
      if (format != null) 'format=$format',
      if (title != null) 'title=$title',
      if (description != null) 'description=$description',
      if (nullable != null) 'nullable=$nullable',
      if (minItems != null) 'minItems=$minItems',
      if (maxItems != null) 'maxItems=$maxItems',
      if (minProperties != null) 'minProperties=$minProperties',
      if (maxProperties != null) 'maxProperties=$maxProperties',
      if (minimum != null) 'minimum=$minimum',
      if (maximum != null) 'maximum=$maximum',
      if (minLength != null) 'minLength=$minLength',
      if (maxLength != null) 'maxLength=$maxLength',
      if (pattern != null) 'pattern=$pattern',
      if (ref != null) 'ref=$ref',
    ].join(',');
    return 'Schema($contents)';
  }
}

/// Generic Metadata shared by all operations.
final class GenericOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenericOperationMetadata';

  /// Output only. Partial failures encountered.
  /// E.g. single files that couldn't be read.
  /// This field should never exceed 20 entries.
  /// Status details field will contain standard Google Cloud error details.
  final List<Status>? partialFailures;

  /// Output only. Time when the operation was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the operation was updated for the last time.
  /// If the operation has finished (successfully or not), this is the finish
  /// time.
  final protobuf.Timestamp? updateTime;

  GenericOperationMetadata({
    this.partialFailures,
    this.createTime,
    this.updateTime,
  }) : super(fullyQualifiedName);

  factory GenericOperationMetadata.fromJson(Map<String, dynamic> json) {
    return GenericOperationMetadata(
      partialFailures: decodeListMessage(
        json['partialFailures'],
        Status.fromJson,
      ),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (partialFailures != null)
        'partialFailures': encodeList(partialFailures),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
    };
  }

  @override
  String toString() => 'GenericOperationMetadata()';
}

/// Details of operations that perform deletes of any entities.
final class DeleteOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  DeleteOperationMetadata({this.genericMetadata}) : super(fullyQualifiedName);

  factory DeleteOperationMetadata.fromJson(Map<String, dynamic> json) {
    return DeleteOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'DeleteOperationMetadata()';
}

/// Represents long-lasting resources that are dedicated to users to runs custom
/// workloads.
/// A PersistentResource can have multiple node pools and each node
/// pool can have its own machine spec.
final class PersistentResource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PersistentResource';

  /// Immutable. Resource name of a PersistentResource.
  final String? name;

  /// Optional. The display name of the PersistentResource.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Required. The spec of the pools of different resources.
  final List<ResourcePool>? resourcePools;

  /// Output only. The detailed state of a Study.
  final PersistentResource_State? state;

  /// Output only. Only populated when persistent resource's state is `STOPPING`
  /// or `ERROR`.
  final Status? error;

  /// Output only. Time when the PersistentResource was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the PersistentResource for the first time entered
  /// the `RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the PersistentResource was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The labels with user-defined metadata to organize
  /// PersistentResource.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Optional. The full name of the Compute Engine
  /// [network](/compute/docs/networks-and-firewalls#networks) to peered with
  /// Vertex AI to host the persistent resources.
  /// For example, `projects/12345/global/networks/myVPC`.
  /// [Format](/compute/docs/reference/rest/v1/networks/insert)
  /// is of the form `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in `12345`, and {network} is a
  /// network name.
  ///
  /// To specify this field, you must have already [configured VPC Network
  /// Peering for Vertex
  /// AI](https://cloud.google.com/vertex-ai/docs/general/vpc-peering).
  ///
  /// If this field is left unspecified, the resources aren't peered with any
  /// network.
  final String? network;

  /// Optional. Configuration for PSC-I for PersistentResource.
  final PscInterfaceConfig? pscInterfaceConfig;

  /// Optional. Customer-managed encryption key spec for a PersistentResource.
  /// If set, this PersistentResource and all sub-resources of this
  /// PersistentResource will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Optional. Persistent Resource runtime spec.
  /// For example, used for Ray cluster configuration.
  final ResourceRuntimeSpec? resourceRuntimeSpec;

  /// Output only. Runtime information of the Persistent Resource.
  final ResourceRuntime? resourceRuntime;

  /// Optional. A list of names for the reserved IP ranges under the VPC network
  /// that can be used for this persistent resource.
  ///
  /// If set, we will deploy the persistent resource within the provided IP
  /// ranges. Otherwise, the persistent resource is deployed to any IP
  /// ranges under the provided VPC network.
  ///
  /// Example: ['vertex-ai-ip-range'].
  final List<String>? reservedIpRanges;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  PersistentResource({
    this.name,
    this.displayName,
    this.resourcePools,
    this.state,
    this.error,
    this.createTime,
    this.startTime,
    this.updateTime,
    this.labels,
    this.network,
    this.pscInterfaceConfig,
    this.encryptionSpec,
    this.resourceRuntimeSpec,
    this.resourceRuntime,
    this.reservedIpRanges,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory PersistentResource.fromJson(Map<String, dynamic> json) {
    return PersistentResource(
      name: json['name'],
      displayName: json['displayName'],
      resourcePools: decodeListMessage(
        json['resourcePools'],
        ResourcePool.fromJson,
      ),
      state: decodeEnum(json['state'], PersistentResource_State.fromJson),
      error: decode(json['error'], Status.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      network: json['network'],
      pscInterfaceConfig: decode(
        json['pscInterfaceConfig'],
        PscInterfaceConfig.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      resourceRuntimeSpec: decode(
        json['resourceRuntimeSpec'],
        ResourceRuntimeSpec.fromJson,
      ),
      resourceRuntime: decode(
        json['resourceRuntime'],
        ResourceRuntime.fromJson,
      ),
      reservedIpRanges: decodeList(json['reservedIpRanges']),
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (resourcePools != null) 'resourcePools': encodeList(resourcePools),
      if (state != null) 'state': state!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (network != null) 'network': network,
      if (pscInterfaceConfig != null)
        'pscInterfaceConfig': pscInterfaceConfig!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (resourceRuntimeSpec != null)
        'resourceRuntimeSpec': resourceRuntimeSpec!.toJson(),
      if (resourceRuntime != null) 'resourceRuntime': resourceRuntime!.toJson(),
      if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (state != null) 'state=$state',
      if (network != null) 'network=$network',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'PersistentResource($contents)';
  }
}

/// Describes the PersistentResource state.
final class PersistentResource_State extends protobuf.ProtoEnum {
  /// Not set.
  static const stateUnspecified = PersistentResource_State('STATE_UNSPECIFIED');

  /// The PROVISIONING state indicates the persistent resources is being
  /// created.
  static const provisioning = PersistentResource_State('PROVISIONING');

  /// The RUNNING state indicates the persistent resource is healthy and fully
  /// usable.
  static const running = PersistentResource_State('RUNNING');

  /// The STOPPING state indicates the persistent resource is being deleted.
  static const stopping = PersistentResource_State('STOPPING');

  /// The ERROR state indicates the persistent resource may be unusable.
  /// Details can be found in the `error` field.
  static const error = PersistentResource_State('ERROR');

  /// The REBOOTING state indicates the persistent resource is being rebooted
  /// (PR is not available right now but is expected to be ready again later).
  static const rebooting = PersistentResource_State('REBOOTING');

  /// The UPDATING state indicates the persistent resource is being updated.
  static const updating = PersistentResource_State('UPDATING');

  const PersistentResource_State(super.value);

  factory PersistentResource_State.fromJson(String json) =>
      PersistentResource_State(json);

  @override
  String toString() => 'State.$value';
}

/// Represents the spec of a group of resources of the same type,
/// for example machine type, disk, and accelerators, in a PersistentResource.
final class ResourcePool extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourcePool';

  /// Immutable. The unique ID in a PersistentResource for referring to this
  /// resource pool. User can specify it if necessary. Otherwise, it's generated
  /// automatically.
  final String? id;

  /// Required. Immutable. The specification of a single machine.
  final MachineSpec? machineSpec;

  /// Optional. The total number of machines to use for this resource pool.
  final int? replicaCount;

  /// Optional. Disk spec for the machine in this node pool.
  final DiskSpec? diskSpec;

  /// Output only. The number of machines currently in use by training jobs for
  /// this resource pool. Will replace idle_replica_count.
  final int? usedReplicaCount;

  /// Optional. Optional spec to configure GKE or Ray-on-Vertex autoscaling
  final ResourcePool_AutoscalingSpec? autoscalingSpec;

  ResourcePool({
    this.id,
    this.machineSpec,
    this.replicaCount,
    this.diskSpec,
    this.usedReplicaCount,
    this.autoscalingSpec,
  }) : super(fullyQualifiedName);

  factory ResourcePool.fromJson(Map<String, dynamic> json) {
    return ResourcePool(
      id: json['id'],
      machineSpec: decode(json['machineSpec'], MachineSpec.fromJson),
      replicaCount: decodeInt64(json['replicaCount']),
      diskSpec: decode(json['diskSpec'], DiskSpec.fromJson),
      usedReplicaCount: decodeInt64(json['usedReplicaCount']),
      autoscalingSpec: decode(
        json['autoscalingSpec'],
        ResourcePool_AutoscalingSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (machineSpec != null) 'machineSpec': machineSpec!.toJson(),
      if (replicaCount != null) 'replicaCount': encodeInt64(replicaCount),
      if (diskSpec != null) 'diskSpec': diskSpec!.toJson(),
      if (usedReplicaCount != null)
        'usedReplicaCount': encodeInt64(usedReplicaCount),
      if (autoscalingSpec != null) 'autoscalingSpec': autoscalingSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      if (replicaCount != null) 'replicaCount=$replicaCount',
      if (usedReplicaCount != null) 'usedReplicaCount=$usedReplicaCount',
    ].join(',');
    return 'ResourcePool($contents)';
  }
}

/// The min/max number of replicas allowed if enabling autoscaling
final class ResourcePool_AutoscalingSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourcePool.AutoscalingSpec';

  /// Optional. min replicas in the node pool,
  /// must be  replica_count and < max_replica_count or will throw error.
  /// For autoscaling enabled Ray-on-Vertex, we allow min_replica_count of a
  /// resource_pool to be 0 to match the OSS Ray
  /// behavior(https://docs.ray.io/en/latest/cluster/vms/user-guides/configuring-autoscaling.html#cluster-config-parameters).
  /// As for Persistent Resource, the min_replica_count must be > 0, we added
  /// a corresponding validation inside
  /// CreatePersistentResourceRequestValidator.java.
  final int? minReplicaCount;

  /// Optional. max replicas in the node pool,
  /// must be  replica_count and > min_replica_count or will throw error
  final int? maxReplicaCount;

  ResourcePool_AutoscalingSpec({this.minReplicaCount, this.maxReplicaCount})
    : super(fullyQualifiedName);

  factory ResourcePool_AutoscalingSpec.fromJson(Map<String, dynamic> json) {
    return ResourcePool_AutoscalingSpec(
      minReplicaCount: decodeInt64(json['minReplicaCount']),
      maxReplicaCount: decodeInt64(json['maxReplicaCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (minReplicaCount != null)
        'minReplicaCount': encodeInt64(minReplicaCount),
      if (maxReplicaCount != null)
        'maxReplicaCount': encodeInt64(maxReplicaCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (minReplicaCount != null) 'minReplicaCount=$minReplicaCount',
      if (maxReplicaCount != null) 'maxReplicaCount=$maxReplicaCount',
    ].join(',');
    return 'AutoscalingSpec($contents)';
  }
}

/// Configuration for the runtime on a PersistentResource instance, including
/// but not limited to:
///
/// * Service accounts used to run the workloads.
/// * Whether to make it a dedicated Ray Cluster.
final class ResourceRuntimeSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourceRuntimeSpec';

  /// Optional. Configure the use of workload identity on the PersistentResource
  final ServiceAccountSpec? serviceAccountSpec;

  /// Optional. Ray cluster configuration.
  /// Required when creating a dedicated RayCluster on the PersistentResource.
  final RaySpec? raySpec;

  ResourceRuntimeSpec({this.serviceAccountSpec, this.raySpec})
    : super(fullyQualifiedName);

  factory ResourceRuntimeSpec.fromJson(Map<String, dynamic> json) {
    return ResourceRuntimeSpec(
      serviceAccountSpec: decode(
        json['serviceAccountSpec'],
        ServiceAccountSpec.fromJson,
      ),
      raySpec: decode(json['raySpec'], RaySpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (serviceAccountSpec != null)
        'serviceAccountSpec': serviceAccountSpec!.toJson(),
      if (raySpec != null) 'raySpec': raySpec!.toJson(),
    };
  }

  @override
  String toString() => 'ResourceRuntimeSpec()';
}

/// Configuration information for the Ray cluster.
/// For experimental launch, Ray cluster creation and Persistent
/// cluster creation are 1:1 mapping: We will provision all the nodes within the
/// Persistent cluster as Ray nodes.
final class RaySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RaySpec';

  /// Optional. Default image for user to choose a preferred ML framework
  /// (for example, TensorFlow or Pytorch) by choosing from [Vertex prebuilt
  /// images](https://cloud.google.com/vertex-ai/docs/training/pre-built-containers).
  /// Either this or the resource_pool_images is required. Use this field if
  /// you need all the resource pools to have the same Ray image. Otherwise, use
  /// the {@code resource_pool_images} field.
  final String? imageUri;

  /// Optional. Use if you want to mount to any NFS storages.
  final List<NfsMount>? nfsMounts;

  /// Optional. Required if image_uri isn't set. A map of resource_pool_id to
  /// prebuild Ray image if user need to use different images for different
  /// head/worker pools. This map needs to cover all the resource pool ids.
  /// Example:
  /// {
  ///   "ray_head_node_pool": "head image"
  ///   "ray_worker_node_pool1": "worker image"
  ///   "ray_worker_node_pool2": "another worker image"
  /// }
  final Map<String, String>? resourcePoolImages;

  /// Optional. This will be used to indicate which resource pool will serve as
  /// the Ray head node(the first node within that pool). Will use the machine
  /// from the first workerpool as the head node by default if this field isn't
  /// set.
  final String? headNodeResourcePoolId;

  /// Optional. Ray metrics configurations.
  final RayMetricSpec? rayMetricSpec;

  /// Optional. OSS Ray logging configurations.
  final RayLogsSpec? rayLogsSpec;

  RaySpec({
    this.imageUri,
    this.nfsMounts,
    this.resourcePoolImages,
    this.headNodeResourcePoolId,
    this.rayMetricSpec,
    this.rayLogsSpec,
  }) : super(fullyQualifiedName);

  factory RaySpec.fromJson(Map<String, dynamic> json) {
    return RaySpec(
      imageUri: json['imageUri'],
      nfsMounts: decodeListMessage(json['nfsMounts'], NfsMount.fromJson),
      resourcePoolImages: decodeMap(json['resourcePoolImages']),
      headNodeResourcePoolId: json['headNodeResourcePoolId'],
      rayMetricSpec: decode(json['rayMetricSpec'], RayMetricSpec.fromJson),
      rayLogsSpec: decode(json['rayLogsSpec'], RayLogsSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (imageUri != null) 'imageUri': imageUri,
      if (nfsMounts != null) 'nfsMounts': encodeList(nfsMounts),
      if (resourcePoolImages != null) 'resourcePoolImages': resourcePoolImages,
      if (headNodeResourcePoolId != null)
        'headNodeResourcePoolId': headNodeResourcePoolId,
      if (rayMetricSpec != null) 'rayMetricSpec': rayMetricSpec!.toJson(),
      if (rayLogsSpec != null) 'rayLogsSpec': rayLogsSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (imageUri != null) 'imageUri=$imageUri',
      if (headNodeResourcePoolId != null)
        'headNodeResourcePoolId=$headNodeResourcePoolId',
    ].join(',');
    return 'RaySpec($contents)';
  }
}

/// Persistent Cluster runtime information as output
final class ResourceRuntime extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResourceRuntime';

  /// Output only. URIs for user to connect to the Cluster.
  /// Example:
  /// {
  ///   "RAY_HEAD_NODE_INTERNAL_IP": "head-node-IP:10001"
  ///   "RAY_DASHBOARD_URI": "ray-dashboard-address:8888"
  /// }
  final Map<String, String>? accessUris;

  /// Output only. The resource name of NotebookRuntimeTemplate for the RoV
  /// Persistent Cluster The NotebokRuntimeTemplate is created in the same VPC
  /// (if set), and with the same Ray and Python version as the Persistent
  /// Cluster. Example:
  ///   "projects/1000/locations/us-central1/notebookRuntimeTemplates/abc123"
  final String? notebookRuntimeTemplate;

  ResourceRuntime({this.accessUris, this.notebookRuntimeTemplate})
    : super(fullyQualifiedName);

  factory ResourceRuntime.fromJson(Map<String, dynamic> json) {
    return ResourceRuntime(
      accessUris: decodeMap(json['accessUris']),
      notebookRuntimeTemplate: json['notebookRuntimeTemplate'],
    );
  }

  @override
  Object toJson() {
    return {
      if (accessUris != null) 'accessUris': accessUris,
      if (notebookRuntimeTemplate != null)
        'notebookRuntimeTemplate': notebookRuntimeTemplate,
    };
  }

  @override
  String toString() {
    final contents = [
      if (notebookRuntimeTemplate != null)
        'notebookRuntimeTemplate=$notebookRuntimeTemplate',
    ].join(',');
    return 'ResourceRuntime($contents)';
  }
}

/// Configuration for the use of custom service account to run the workloads.
final class ServiceAccountSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ServiceAccountSpec';

  /// Required. If true, custom user-managed service account is enforced to run
  /// any workloads (for example, Vertex Jobs) on the resource. Otherwise, uses
  /// the [Vertex AI Custom Code Service
  /// Agent](https://cloud.google.com/vertex-ai/docs/general/access-control#service-agents).
  final bool? enableCustomServiceAccount;

  /// Optional. Required when all below conditions are met
  ///  * `enable_custom_service_account` is true;
  ///  * any runtime is specified via `ResourceRuntimeSpec` on creation time,
  ///    for example, Ray
  ///
  /// The users must have `iam.serviceAccounts.actAs` permission on this service
  /// account and then the specified runtime containers will run as it.
  ///
  /// Do not set this field if you want to submit jobs using custom service
  /// account to this PersistentResource after creation, but only specify the
  /// `service_account` inside the job.
  final String? serviceAccount;

  ServiceAccountSpec({this.enableCustomServiceAccount, this.serviceAccount})
    : super(fullyQualifiedName);

  factory ServiceAccountSpec.fromJson(Map<String, dynamic> json) {
    return ServiceAccountSpec(
      enableCustomServiceAccount: json['enableCustomServiceAccount'],
      serviceAccount: json['serviceAccount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (enableCustomServiceAccount != null)
        'enableCustomServiceAccount': enableCustomServiceAccount,
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (enableCustomServiceAccount != null)
        'enableCustomServiceAccount=$enableCustomServiceAccount',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
    ].join(',');
    return 'ServiceAccountSpec($contents)';
  }
}

/// Configuration for the Ray metrics.
final class RayMetricSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RayMetricSpec';

  /// Optional. Flag to disable the Ray metrics collection.
  final bool? disabled;

  RayMetricSpec({this.disabled}) : super(fullyQualifiedName);

  factory RayMetricSpec.fromJson(Map<String, dynamic> json) {
    return RayMetricSpec(disabled: json['disabled']);
  }

  @override
  Object toJson() {
    return {if (disabled != null) 'disabled': disabled};
  }

  @override
  String toString() {
    final contents = [if (disabled != null) 'disabled=$disabled'].join(',');
    return 'RayMetricSpec($contents)';
  }
}

/// Configuration for the Ray OSS Logs.
final class RayLogsSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RayLogsSpec';

  /// Optional. Flag to disable the export of Ray OSS logs to Cloud Logging.
  final bool? disabled;

  RayLogsSpec({this.disabled}) : super(fullyQualifiedName);

  factory RayLogsSpec.fromJson(Map<String, dynamic> json) {
    return RayLogsSpec(disabled: json['disabled']);
  }

  @override
  Object toJson() {
    return {if (disabled != null) 'disabled': disabled};
  }

  @override
  String toString() {
    final contents = [if (disabled != null) 'disabled=$disabled'].join(',');
    return 'RayLogsSpec($contents)';
  }
}

/// Request message for
/// `PersistentResourceService.CreatePersistentResource`.
final class CreatePersistentResourceRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreatePersistentResourceRequest';

  /// Required. The resource name of the Location to create the
  /// PersistentResource in. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The PersistentResource to create.
  final PersistentResource persistentResource;

  /// Required. The ID to use for the PersistentResource, which become the final
  /// component of the PersistentResource's resource name.
  ///
  /// The maximum length is 63 characters, and valid characters
  /// are `/^[a-z]([a-z0-9-]{0,61}[a-z0-9])?$/`.
  final String? persistentResourceId;

  CreatePersistentResourceRequest({
    required this.parent,
    required this.persistentResource,
    this.persistentResourceId,
  }) : super(fullyQualifiedName);

  factory CreatePersistentResourceRequest.fromJson(Map<String, dynamic> json) {
    return CreatePersistentResourceRequest(
      parent: json['parent'],
      persistentResource: decode(
        json['persistentResource'],
        PersistentResource.fromJson,
      )!,
      persistentResourceId: json['persistentResourceId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'persistentResource': persistentResource.toJson(),
      if (persistentResourceId != null)
        'persistentResourceId': persistentResourceId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (persistentResourceId != null)
        'persistentResourceId=$persistentResourceId',
    ].join(',');
    return 'CreatePersistentResourceRequest($contents)';
  }
}

/// Details of operations that perform create PersistentResource.
final class CreatePersistentResourceOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreatePersistentResourceOperationMetadata';

  /// Operation metadata for PersistentResource.
  final GenericOperationMetadata? genericMetadata;

  /// Progress Message for Create LRO
  final String? progressMessage;

  CreatePersistentResourceOperationMetadata({
    this.genericMetadata,
    this.progressMessage,
  }) : super(fullyQualifiedName);

  factory CreatePersistentResourceOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreatePersistentResourceOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      progressMessage: json['progressMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (progressMessage != null) 'progressMessage': progressMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (progressMessage != null) 'progressMessage=$progressMessage',
    ].join(',');
    return 'CreatePersistentResourceOperationMetadata($contents)';
  }
}

/// Details of operations that perform update PersistentResource.
final class UpdatePersistentResourceOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdatePersistentResourceOperationMetadata';

  /// Operation metadata for PersistentResource.
  final GenericOperationMetadata? genericMetadata;

  /// Progress Message for Update LRO
  final String? progressMessage;

  UpdatePersistentResourceOperationMetadata({
    this.genericMetadata,
    this.progressMessage,
  }) : super(fullyQualifiedName);

  factory UpdatePersistentResourceOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdatePersistentResourceOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      progressMessage: json['progressMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (progressMessage != null) 'progressMessage': progressMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (progressMessage != null) 'progressMessage=$progressMessage',
    ].join(',');
    return 'UpdatePersistentResourceOperationMetadata($contents)';
  }
}

/// Details of operations that perform reboot PersistentResource.
final class RebootPersistentResourceOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RebootPersistentResourceOperationMetadata';

  /// Operation metadata for PersistentResource.
  final GenericOperationMetadata? genericMetadata;

  /// Progress Message for Reboot LRO
  final String? progressMessage;

  RebootPersistentResourceOperationMetadata({
    this.genericMetadata,
    this.progressMessage,
  }) : super(fullyQualifiedName);

  factory RebootPersistentResourceOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return RebootPersistentResourceOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      progressMessage: json['progressMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (progressMessage != null) 'progressMessage': progressMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (progressMessage != null) 'progressMessage=$progressMessage',
    ].join(',');
    return 'RebootPersistentResourceOperationMetadata($contents)';
  }
}

/// Request message for
/// `PersistentResourceService.GetPersistentResource`.
final class GetPersistentResourceRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetPersistentResourceRequest';

  /// Required. The name of the PersistentResource resource.
  /// Format:
  /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
  final String name;

  GetPersistentResourceRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetPersistentResourceRequest.fromJson(Map<String, dynamic> json) {
    return GetPersistentResourceRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetPersistentResourceRequest($contents)';
  }
}

/// Request message for `PersistentResourceService.ListPersistentResource`.
final class ListPersistentResourcesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPersistentResourcesRequest';

  /// Required. The resource name of the Location to list the PersistentResources
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListPersistentResourceResponse.next_page_token` of the previous
  /// `PersistentResourceService.ListPersistentResource` call.
  final String? pageToken;

  ListPersistentResourcesRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListPersistentResourcesRequest.fromJson(Map<String, dynamic> json) {
    return ListPersistentResourcesRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListPersistentResourcesRequest($contents)';
  }
}

/// Response message for
/// `PersistentResourceService.ListPersistentResources`
final class ListPersistentResourcesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPersistentResourcesResponse';

  final List<PersistentResource>? persistentResources;

  /// A token to retrieve next page of results.
  /// Pass to
  /// `ListPersistentResourcesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListPersistentResourcesResponse({
    this.persistentResources,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListPersistentResourcesResponse.fromJson(Map<String, dynamic> json) {
    return ListPersistentResourcesResponse(
      persistentResources: decodeListMessage(
        json['persistentResources'],
        PersistentResource.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (persistentResources != null)
        'persistentResources': encodeList(persistentResources),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListPersistentResourcesResponse($contents)';
  }
}

/// Request message for
/// `PersistentResourceService.DeletePersistentResource`.
final class DeletePersistentResourceRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeletePersistentResourceRequest';

  /// Required. The name of the PersistentResource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  final String name;

  DeletePersistentResourceRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeletePersistentResourceRequest.fromJson(Map<String, dynamic> json) {
    return DeletePersistentResourceRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeletePersistentResourceRequest($contents)';
  }
}

/// Request message for UpdatePersistentResource method.
final class UpdatePersistentResourceRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdatePersistentResourceRequest';

  /// Required. The PersistentResource to update.
  ///
  /// The PersistentResource's `name` field is used to identify the
  /// PersistentResource to update. Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  final PersistentResource persistentResource;

  /// Required. Specify the fields to be overwritten in the PersistentResource by
  /// the update method.
  final protobuf.FieldMask? updateMask;

  UpdatePersistentResourceRequest({
    required this.persistentResource,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory UpdatePersistentResourceRequest.fromJson(Map<String, dynamic> json) {
    return UpdatePersistentResourceRequest(
      persistentResource: decode(
        json['persistentResource'],
        PersistentResource.fromJson,
      )!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'persistentResource': persistentResource.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdatePersistentResourceRequest()';
}

/// Request message for
/// `PersistentResourceService.RebootPersistentResource`.
final class RebootPersistentResourceRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RebootPersistentResourceRequest';

  /// Required. The name of the PersistentResource resource.
  /// Format:
  /// `projects/{project_id_or_number}/locations/{location_id}/persistentResources/{persistent_resource_id}`
  final String name;

  RebootPersistentResourceRequest({required this.name})
    : super(fullyQualifiedName);

  factory RebootPersistentResourceRequest.fromJson(Map<String, dynamic> json) {
    return RebootPersistentResourceRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'RebootPersistentResourceRequest($contents)';
  }
}

/// An instance of a machine learning PipelineJob.
final class PipelineJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob';

  /// Output only. The resource name of the PipelineJob.
  final String? name;

  /// The display name of the Pipeline.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Output only. Pipeline creation time.
  final protobuf.Timestamp? createTime;

  /// Output only. Pipeline start time.
  final protobuf.Timestamp? startTime;

  /// Output only. Pipeline end time.
  final protobuf.Timestamp? endTime;

  /// Output only. Timestamp when this PipelineJob was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// The spec of the pipeline.
  final protobuf.Struct? pipelineSpec;

  /// Output only. The detailed state of the job.
  final PipelineState? state;

  /// Output only. The details of pipeline run. Not available in the list view.
  final PipelineJobDetail? jobDetail;

  /// Output only. The error that occurred during pipeline execution.
  /// Only populated when the pipeline's state is FAILED or CANCELLED.
  final Status? error;

  /// The labels with user-defined metadata to organize PipelineJob.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  ///
  /// Note there is some reserved label key for Vertex AI Pipelines.
  /// - `vertex-ai-pipelines-run-billing-id`, user set value will get overrided.
  final Map<String, String>? labels;

  /// Runtime config of the pipeline.
  final PipelineJob_RuntimeConfig? runtimeConfig;

  /// Customer-managed encryption key spec for a pipelineJob. If set, this
  /// PipelineJob and all of its sub-resources will be secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// The service account that the pipeline workload runs as.
  /// If not specified, the Compute Engine default service account in the project
  /// will be used.
  /// See
  /// https://cloud.google.com/compute/docs/access/service-accounts#default_service_account
  ///
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  final String? serviceAccount;

  /// The full name of the Compute Engine
  /// [network](/compute/docs/networks-and-firewalls#networks) to which the
  /// Pipeline Job's workload should be peered. For example,
  /// `projects/12345/global/networks/myVPC`.
  /// [Format](/compute/docs/reference/rest/v1/networks/insert)
  /// is of the form `projects/{project}/global/networks/{network}`.
  /// Where {project} is a project number, as in `12345`, and {network} is a
  /// network name.
  ///
  /// Private services access must already be configured for the network.
  /// Pipeline job will apply the network configuration to the Google Cloud
  /// resources being launched, if applied, such as Vertex AI
  /// Training or Dataflow job. If left unspecified, the workload is not peered
  /// with any network.
  final String? network;

  /// A list of names for the reserved ip ranges under the VPC network
  /// that can be used for this Pipeline Job's workload.
  ///
  /// If set, we will deploy the Pipeline Job's workload within the provided ip
  /// ranges. Otherwise, the job will be deployed to any ip ranges under the
  /// provided VPC network.
  ///
  /// Example: ['vertex-ai-ip-range'].
  final List<String>? reservedIpRanges;

  /// Optional. Configuration for PSC-I for PipelineJob.
  final PscInterfaceConfig? pscInterfaceConfig;

  /// A template uri from where the
  /// `PipelineJob.pipeline_spec`,
  /// if empty, will be downloaded. Currently, only uri from Vertex Template
  /// Registry & Gallery is supported. Reference to
  /// https://cloud.google.com/vertex-ai/docs/pipelines/create-pipeline-template.
  final String? templateUri;

  /// Output only. Pipeline template metadata. Will fill up fields if
  /// `PipelineJob.template_uri`
  /// is from supported template registry.
  final PipelineTemplateMetadata? templateMetadata;

  /// Output only. The schedule resource name.
  /// Only returned if the Pipeline is created by Schedule API.
  final String? scheduleName;

  /// Optional. Whether to do component level validations before job creation.
  final bool? preflightValidations;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  /// Optional. The original pipeline job id if this pipeline job is a rerun of a
  /// previous pipeline job.
  final int? originalPipelineJobId;

  /// Optional. The rerun configs for each task in the pipeline job.
  /// By default, the rerun will:
  /// 1. Use the same input artifacts as the original run.
  /// 2. Use the same input parameters as the original run.
  /// 3. Skip all the tasks that are already succeeded in the original run.
  /// 4. Rerun all the tasks that are not succeeded in the original run.
  /// By providing this field, users can override the default behavior and
  /// specify the rerun config for each task.
  final List<PipelineTaskRerunConfig>? pipelineTaskRerunConfigs;

  PipelineJob({
    this.name,
    this.displayName,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.pipelineSpec,
    this.state,
    this.jobDetail,
    this.error,
    this.labels,
    this.runtimeConfig,
    this.encryptionSpec,
    this.serviceAccount,
    this.network,
    this.reservedIpRanges,
    this.pscInterfaceConfig,
    this.templateUri,
    this.templateMetadata,
    this.scheduleName,
    this.preflightValidations,
    this.satisfiesPzs,
    this.satisfiesPzi,
    this.originalPipelineJobId,
    this.pipelineTaskRerunConfigs,
  }) : super(fullyQualifiedName);

  factory PipelineJob.fromJson(Map<String, dynamic> json) {
    return PipelineJob(
      name: json['name'],
      displayName: json['displayName'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      pipelineSpec: decodeCustom(
        json['pipelineSpec'],
        protobuf.Struct.fromJson,
      ),
      state: decodeEnum(json['state'], PipelineState.fromJson),
      jobDetail: decode(json['jobDetail'], PipelineJobDetail.fromJson),
      error: decode(json['error'], Status.fromJson),
      labels: decodeMap(json['labels']),
      runtimeConfig: decode(
        json['runtimeConfig'],
        PipelineJob_RuntimeConfig.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      serviceAccount: json['serviceAccount'],
      network: json['network'],
      reservedIpRanges: decodeList(json['reservedIpRanges']),
      pscInterfaceConfig: decode(
        json['pscInterfaceConfig'],
        PscInterfaceConfig.fromJson,
      ),
      templateUri: json['templateUri'],
      templateMetadata: decode(
        json['templateMetadata'],
        PipelineTemplateMetadata.fromJson,
      ),
      scheduleName: json['scheduleName'],
      preflightValidations: json['preflightValidations'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
      originalPipelineJobId: decodeInt64(json['originalPipelineJobId']),
      pipelineTaskRerunConfigs: decodeListMessage(
        json['pipelineTaskRerunConfigs'],
        PipelineTaskRerunConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (pipelineSpec != null) 'pipelineSpec': pipelineSpec!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (jobDetail != null) 'jobDetail': jobDetail!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (labels != null) 'labels': labels,
      if (runtimeConfig != null) 'runtimeConfig': runtimeConfig!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (network != null) 'network': network,
      if (reservedIpRanges != null) 'reservedIpRanges': reservedIpRanges,
      if (pscInterfaceConfig != null)
        'pscInterfaceConfig': pscInterfaceConfig!.toJson(),
      if (templateUri != null) 'templateUri': templateUri,
      if (templateMetadata != null)
        'templateMetadata': templateMetadata!.toJson(),
      if (scheduleName != null) 'scheduleName': scheduleName,
      if (preflightValidations != null)
        'preflightValidations': preflightValidations,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
      if (originalPipelineJobId != null)
        'originalPipelineJobId': encodeInt64(originalPipelineJobId),
      if (pipelineTaskRerunConfigs != null)
        'pipelineTaskRerunConfigs': encodeList(pipelineTaskRerunConfigs),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (state != null) 'state=$state',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (network != null) 'network=$network',
      if (templateUri != null) 'templateUri=$templateUri',
      if (scheduleName != null) 'scheduleName=$scheduleName',
      if (preflightValidations != null)
        'preflightValidations=$preflightValidations',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
      if (originalPipelineJobId != null)
        'originalPipelineJobId=$originalPipelineJobId',
    ].join(',');
    return 'PipelineJob($contents)';
  }
}

/// The runtime config of a PipelineJob.
final class PipelineJob_RuntimeConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob.RuntimeConfig';

  /// Deprecated. Use
  /// `RuntimeConfig.parameter_values`
  /// instead. The runtime parameters of the PipelineJob. The parameters will
  /// be passed into
  /// `PipelineJob.pipeline_spec`
  /// to replace the placeholders at runtime. This field is used by pipelines
  /// built using `PipelineJob.pipeline_spec.schema_version` 2.0.0 or lower,
  /// such as pipelines built using Kubeflow Pipelines SDK 1.8 or lower.
  final Map<String, Value>? parameters;

  /// Required. A path in a Cloud Storage bucket, which will be treated as the
  /// root output directory of the pipeline. It is used by the system to
  /// generate the paths of output artifacts. The artifact paths are generated
  /// with a sub-path pattern `{job_id}/{task_id}/{output_key}` under the
  /// specified output directory. The service account specified in this
  /// pipeline must have the `storage.objects.get` and `storage.objects.create`
  /// permissions for this bucket.
  final String? gcsOutputDirectory;

  /// The runtime parameters of the PipelineJob. The parameters will be
  /// passed into
  /// `PipelineJob.pipeline_spec`
  /// to replace the placeholders at runtime. This field is used by pipelines
  /// built using `PipelineJob.pipeline_spec.schema_version` 2.1.0, such as
  /// pipelines built using Kubeflow Pipelines SDK 1.9 or higher and the v2
  /// DSL.
  final Map<String, protobuf.Value>? parameterValues;

  /// Represents the failure policy of a pipeline. Currently, the default of a
  /// pipeline is that the pipeline will continue to run until no more tasks
  /// can be executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW.
  /// However, if a pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it
  /// will stop scheduling any new tasks when a task has failed. Any scheduled
  /// tasks will continue to completion.
  final PipelineFailurePolicy? failurePolicy;

  /// The runtime artifacts of the PipelineJob. The key will be the input
  /// artifact name and the value would be one of the InputArtifact.
  final Map<String, PipelineJob_RuntimeConfig_InputArtifact>? inputArtifacts;

  /// Optional. The default runtime for the PipelineJob. If not provided,
  /// Vertex Custom Job(on demand) is used as the runtime. For Vertex Custom
  /// Job, please refer to
  /// https://cloud.google.com/vertex-ai/docs/training/overview.
  final PipelineJob_RuntimeConfig_DefaultRuntime? defaultRuntime;

  PipelineJob_RuntimeConfig({
    this.parameters,
    this.gcsOutputDirectory,
    this.parameterValues,
    this.failurePolicy,
    this.inputArtifacts,
    this.defaultRuntime,
  }) : super(fullyQualifiedName);

  factory PipelineJob_RuntimeConfig.fromJson(Map<String, dynamic> json) {
    return PipelineJob_RuntimeConfig(
      parameters: decodeMapMessage(json['parameters'], Value.fromJson),
      gcsOutputDirectory: json['gcsOutputDirectory'],
      parameterValues: decodeMapMessageCustom(
        json['parameterValues'],
        protobuf.Value.fromJson,
      ),
      failurePolicy: decodeEnum(
        json['failurePolicy'],
        PipelineFailurePolicy.fromJson,
      ),
      inputArtifacts: decodeMapMessage(
        json['inputArtifacts'],
        PipelineJob_RuntimeConfig_InputArtifact.fromJson,
      ),
      defaultRuntime: decode(
        json['defaultRuntime'],
        PipelineJob_RuntimeConfig_DefaultRuntime.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (parameters != null) 'parameters': encodeMap(parameters),
      if (gcsOutputDirectory != null) 'gcsOutputDirectory': gcsOutputDirectory,
      if (parameterValues != null)
        'parameterValues': encodeMap(parameterValues),
      if (failurePolicy != null) 'failurePolicy': failurePolicy!.toJson(),
      if (inputArtifacts != null) 'inputArtifacts': encodeMap(inputArtifacts),
      if (defaultRuntime != null) 'defaultRuntime': defaultRuntime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (gcsOutputDirectory != null) 'gcsOutputDirectory=$gcsOutputDirectory',
      if (failurePolicy != null) 'failurePolicy=$failurePolicy',
    ].join(',');
    return 'RuntimeConfig($contents)';
  }
}

/// The type of an input artifact.
final class PipelineJob_RuntimeConfig_InputArtifact
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob.RuntimeConfig.InputArtifact';

  /// Artifact resource id from MLMD. Which is the last portion of an
  /// artifact resource name:
  /// `projects/{project}/locations/{location}/metadataStores/default/artifacts/{artifact_id}`.
  /// The artifact must stay within the same project, location and default
  /// metadatastore as the pipeline.
  final String? artifactId;

  PipelineJob_RuntimeConfig_InputArtifact({this.artifactId})
    : super(fullyQualifiedName);

  factory PipelineJob_RuntimeConfig_InputArtifact.fromJson(
    Map<String, dynamic> json,
  ) {
    return PipelineJob_RuntimeConfig_InputArtifact(
      artifactId: json['artifactId'],
    );
  }

  @override
  Object toJson() {
    return {if (artifactId != null) 'artifactId': artifactId};
  }

  @override
  String toString() {
    final contents = [
      if (artifactId != null) 'artifactId=$artifactId',
    ].join(',');
    return 'InputArtifact($contents)';
  }
}

/// Persistent resource based runtime detail. For more information, refer to
/// https://cloud.google.com/vertex-ai/docs/training/persistent-resource-overview
final class PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob.RuntimeConfig.PersistentResourceRuntimeDetail';

  /// Persistent resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/persistentResources/{persistent_resource}`
  final String? persistentResourceName;

  /// The max time a pipeline task waits for the required CPU, memory, or
  /// accelerator resource to become available from the specified persistent
  /// resource. Default wait time is 0.
  final int? taskResourceUnavailableWaitTimeMs;

  /// Specifies the behavior to take if the timeout is reached.
  final PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior?
  taskResourceUnavailableTimeoutBehavior;

  PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail({
    this.persistentResourceName,
    this.taskResourceUnavailableWaitTimeMs,
    this.taskResourceUnavailableTimeoutBehavior,
  }) : super(fullyQualifiedName);

  factory PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail.fromJson(
    Map<String, dynamic> json,
  ) {
    return PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail(
      persistentResourceName: json['persistentResourceName'],
      taskResourceUnavailableWaitTimeMs: decodeInt64(
        json['taskResourceUnavailableWaitTimeMs'],
      ),
      taskResourceUnavailableTimeoutBehavior: decodeEnum(
        json['taskResourceUnavailableTimeoutBehavior'],
        PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (persistentResourceName != null)
        'persistentResourceName': persistentResourceName,
      if (taskResourceUnavailableWaitTimeMs != null)
        'taskResourceUnavailableWaitTimeMs': encodeInt64(
          taskResourceUnavailableWaitTimeMs,
        ),
      if (taskResourceUnavailableTimeoutBehavior != null)
        'taskResourceUnavailableTimeoutBehavior':
            taskResourceUnavailableTimeoutBehavior!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (persistentResourceName != null)
        'persistentResourceName=$persistentResourceName',
      if (taskResourceUnavailableWaitTimeMs != null)
        'taskResourceUnavailableWaitTimeMs=$taskResourceUnavailableWaitTimeMs',
      if (taskResourceUnavailableTimeoutBehavior != null)
        'taskResourceUnavailableTimeoutBehavior=$taskResourceUnavailableTimeoutBehavior',
    ].join(',');
    return 'PersistentResourceRuntimeDetail($contents)';
  }
}

/// An enum that specifies the behavior to take if the timeout is reached.
final class PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior
    extends protobuf.ProtoEnum {
  /// Unspecified. Behavior is same as `FAIL`.
  static const taskResourceUnavailableTimeoutBehaviorUnspecified =
      PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
        'TASK_RESOURCE_UNAVAILABLE_TIMEOUT_BEHAVIOR_UNSPECIFIED',
      );

  /// Fail the task if the timeout is reached.
  static const fail =
      PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
        'FAIL',
      );

  /// Fall back to on-demand execution if the timeout is reached.
  static const fallBackToOnDemand =
      PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
        'FALL_BACK_TO_ON_DEMAND',
      );

  const PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
    super.value,
  );

  factory PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior.fromJson(
    String json,
  ) =>
      PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail_TaskResourceUnavailableTimeoutBehavior(
        json,
      );

  @override
  String toString() => 'TaskResourceUnavailableTimeoutBehavior.$value';
}

/// The default runtime for the PipelineJob.
final class PipelineJob_RuntimeConfig_DefaultRuntime
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJob.RuntimeConfig.DefaultRuntime';

  /// Persistent resource based runtime detail.
  final PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail?
  persistentResourceRuntimeDetail;

  PipelineJob_RuntimeConfig_DefaultRuntime({
    this.persistentResourceRuntimeDetail,
  }) : super(fullyQualifiedName);

  factory PipelineJob_RuntimeConfig_DefaultRuntime.fromJson(
    Map<String, dynamic> json,
  ) {
    return PipelineJob_RuntimeConfig_DefaultRuntime(
      persistentResourceRuntimeDetail: decode(
        json['persistentResourceRuntimeDetail'],
        PipelineJob_RuntimeConfig_PersistentResourceRuntimeDetail.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (persistentResourceRuntimeDetail != null)
        'persistentResourceRuntimeDetail': persistentResourceRuntimeDetail!
            .toJson(),
    };
  }

  @override
  String toString() => 'DefaultRuntime()';
}

/// Pipeline template metadata if
/// `PipelineJob.template_uri`
/// is from supported template registry. Currently, the only supported registry
/// is Artifact Registry.
final class PipelineTemplateMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTemplateMetadata';

  /// The version_name in artifact registry.
  ///
  /// Will always be presented in output if the
  /// `PipelineJob.template_uri`
  /// is from supported template registry.
  ///
  /// Format is "sha256:abcdef123456...".
  final String? version;

  PipelineTemplateMetadata({this.version}) : super(fullyQualifiedName);

  factory PipelineTemplateMetadata.fromJson(Map<String, dynamic> json) {
    return PipelineTemplateMetadata(version: json['version']);
  }

  @override
  Object toJson() {
    return {if (version != null) 'version': version};
  }

  @override
  String toString() {
    final contents = [if (version != null) 'version=$version'].join(',');
    return 'PipelineTemplateMetadata($contents)';
  }
}

/// The runtime detail of PipelineJob.
final class PipelineJobDetail extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineJobDetail';

  /// Output only. The context of the pipeline.
  final Context? pipelineContext;

  /// Output only. The context of the current pipeline run.
  final Context? pipelineRunContext;

  /// Output only. The runtime details of the tasks under the pipeline.
  final List<PipelineTaskDetail>? taskDetails;

  PipelineJobDetail({
    this.pipelineContext,
    this.pipelineRunContext,
    this.taskDetails,
  }) : super(fullyQualifiedName);

  factory PipelineJobDetail.fromJson(Map<String, dynamic> json) {
    return PipelineJobDetail(
      pipelineContext: decode(json['pipelineContext'], Context.fromJson),
      pipelineRunContext: decode(json['pipelineRunContext'], Context.fromJson),
      taskDetails: decodeListMessage(
        json['taskDetails'],
        PipelineTaskDetail.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (pipelineContext != null) 'pipelineContext': pipelineContext!.toJson(),
      if (pipelineRunContext != null)
        'pipelineRunContext': pipelineRunContext!.toJson(),
      if (taskDetails != null) 'taskDetails': encodeList(taskDetails),
    };
  }

  @override
  String toString() => 'PipelineJobDetail()';
}

/// The runtime detail of a task execution.
final class PipelineTaskDetail extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskDetail';

  /// Output only. The system generated ID of the task.
  final int? taskId;

  /// Output only. The id of the parent task if the task is within a component
  /// scope. Empty if the task is at the root level.
  final int? parentTaskId;

  /// Output only. The user specified name of the task that is defined in
  /// `pipeline_spec`.
  final String? taskName;

  /// Output only. Task create time.
  final protobuf.Timestamp? createTime;

  /// Output only. Task start time.
  final protobuf.Timestamp? startTime;

  /// Output only. Task end time.
  final protobuf.Timestamp? endTime;

  /// Output only. The detailed execution info.
  final PipelineTaskExecutorDetail? executorDetail;

  /// Output only. State of the task.
  final PipelineTaskDetail_State? state;

  /// Output only. The execution metadata of the task.
  final Execution? execution;

  /// Output only. The error that occurred during task execution.
  /// Only populated when the task's state is FAILED or CANCELLED.
  final Status? error;

  /// Output only. A list of task status. This field keeps a record of task
  /// status evolving over time.
  final List<PipelineTaskDetail_PipelineTaskStatus>? pipelineTaskStatus;

  /// Output only. The runtime input artifacts of the task.
  final Map<String, PipelineTaskDetail_ArtifactList>? inputs;

  /// Output only. The runtime output artifacts of the task.
  final Map<String, PipelineTaskDetail_ArtifactList>? outputs;

  /// Output only. The unique name of a task.
  /// This field is used by pipeline job reruns.
  /// Console UI and Vertex AI SDK will support triggering pipeline job reruns.
  /// The name is constructed by concatenating all the parent tasks' names with
  /// the task name. For example, if a task named "child_task" has a parent task
  /// named "parent_task_1" and parent task 1 has a parent task named
  /// "parent_task_2", the task unique name will be
  /// "parent_task_2.parent_task_1.child_task".
  final String? taskUniqueName;

  PipelineTaskDetail({
    this.taskId,
    this.parentTaskId,
    this.taskName,
    this.createTime,
    this.startTime,
    this.endTime,
    this.executorDetail,
    this.state,
    this.execution,
    this.error,
    this.pipelineTaskStatus,
    this.inputs,
    this.outputs,
    this.taskUniqueName,
  }) : super(fullyQualifiedName);

  factory PipelineTaskDetail.fromJson(Map<String, dynamic> json) {
    return PipelineTaskDetail(
      taskId: decodeInt64(json['taskId']),
      parentTaskId: decodeInt64(json['parentTaskId']),
      taskName: json['taskName'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      executorDetail: decode(
        json['executorDetail'],
        PipelineTaskExecutorDetail.fromJson,
      ),
      state: decodeEnum(json['state'], PipelineTaskDetail_State.fromJson),
      execution: decode(json['execution'], Execution.fromJson),
      error: decode(json['error'], Status.fromJson),
      pipelineTaskStatus: decodeListMessage(
        json['pipelineTaskStatus'],
        PipelineTaskDetail_PipelineTaskStatus.fromJson,
      ),
      inputs: decodeMapMessage(
        json['inputs'],
        PipelineTaskDetail_ArtifactList.fromJson,
      ),
      outputs: decodeMapMessage(
        json['outputs'],
        PipelineTaskDetail_ArtifactList.fromJson,
      ),
      taskUniqueName: json['taskUniqueName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (taskId != null) 'taskId': encodeInt64(taskId),
      if (parentTaskId != null) 'parentTaskId': encodeInt64(parentTaskId),
      if (taskName != null) 'taskName': taskName,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (executorDetail != null) 'executorDetail': executorDetail!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (execution != null) 'execution': execution!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (pipelineTaskStatus != null)
        'pipelineTaskStatus': encodeList(pipelineTaskStatus),
      if (inputs != null) 'inputs': encodeMap(inputs),
      if (outputs != null) 'outputs': encodeMap(outputs),
      if (taskUniqueName != null) 'taskUniqueName': taskUniqueName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (taskId != null) 'taskId=$taskId',
      if (parentTaskId != null) 'parentTaskId=$parentTaskId',
      if (taskName != null) 'taskName=$taskName',
      if (state != null) 'state=$state',
      if (taskUniqueName != null) 'taskUniqueName=$taskUniqueName',
    ].join(',');
    return 'PipelineTaskDetail($contents)';
  }
}

/// A single record of the task status.
final class PipelineTaskDetail_PipelineTaskStatus
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskDetail.PipelineTaskStatus';

  /// Output only. Update time of this status.
  final protobuf.Timestamp? updateTime;

  /// Output only. The state of the task.
  final PipelineTaskDetail_State? state;

  /// Output only. The error that occurred during the state. May be set when
  /// the state is any of the non-final state (PENDING/RUNNING/CANCELLING) or
  /// FAILED state. If the state is FAILED, the error here is final and not
  /// going to be retried. If the state is a non-final state, the error
  /// indicates a system-error being retried.
  final Status? error;

  PipelineTaskDetail_PipelineTaskStatus({
    this.updateTime,
    this.state,
    this.error,
  }) : super(fullyQualifiedName);

  factory PipelineTaskDetail_PipelineTaskStatus.fromJson(
    Map<String, dynamic> json,
  ) {
    return PipelineTaskDetail_PipelineTaskStatus(
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      state: decodeEnum(json['state'], PipelineTaskDetail_State.fromJson),
      error: decode(json['error'], Status.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (error != null) 'error': error!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (state != null) 'state=$state'].join(',');
    return 'PipelineTaskStatus($contents)';
  }
}

/// A list of artifact metadata.
final class PipelineTaskDetail_ArtifactList extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskDetail.ArtifactList';

  /// Output only. A list of artifact metadata.
  final List<Artifact>? artifacts;

  PipelineTaskDetail_ArtifactList({this.artifacts}) : super(fullyQualifiedName);

  factory PipelineTaskDetail_ArtifactList.fromJson(Map<String, dynamic> json) {
    return PipelineTaskDetail_ArtifactList(
      artifacts: decodeListMessage(json['artifacts'], Artifact.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (artifacts != null) 'artifacts': encodeList(artifacts)};
  }

  @override
  String toString() => 'ArtifactList()';
}

/// Specifies state of TaskExecution
final class PipelineTaskDetail_State extends protobuf.ProtoEnum {
  /// Unspecified.
  static const stateUnspecified = PipelineTaskDetail_State('STATE_UNSPECIFIED');

  /// Specifies pending state for the task.
  static const pending = PipelineTaskDetail_State('PENDING');

  /// Specifies task is being executed.
  static const running = PipelineTaskDetail_State('RUNNING');

  /// Specifies task completed successfully.
  static const succeeded = PipelineTaskDetail_State('SUCCEEDED');

  /// Specifies Task cancel is in pending state.
  static const cancelPending = PipelineTaskDetail_State('CANCEL_PENDING');

  /// Specifies task is being cancelled.
  static const cancelling = PipelineTaskDetail_State('CANCELLING');

  /// Specifies task was cancelled.
  static const cancelled = PipelineTaskDetail_State('CANCELLED');

  /// Specifies task failed.
  static const failed = PipelineTaskDetail_State('FAILED');

  /// Specifies task was skipped due to cache hit.
  static const skipped = PipelineTaskDetail_State('SKIPPED');

  /// Specifies that the task was not triggered because the task's trigger
  /// policy is not satisfied. The trigger policy is specified in the
  /// `condition` field of
  /// `PipelineJob.pipeline_spec`.
  static const notTriggered = PipelineTaskDetail_State('NOT_TRIGGERED');

  const PipelineTaskDetail_State(super.value);

  factory PipelineTaskDetail_State.fromJson(String json) =>
      PipelineTaskDetail_State(json);

  @override
  String toString() => 'State.$value';
}

/// The runtime detail of a pipeline executor.
final class PipelineTaskExecutorDetail extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskExecutorDetail';

  /// Output only. The detailed info for a container executor.
  final PipelineTaskExecutorDetail_ContainerDetail? containerDetail;

  /// Output only. The detailed info for a custom job executor.
  final PipelineTaskExecutorDetail_CustomJobDetail? customJobDetail;

  PipelineTaskExecutorDetail({this.containerDetail, this.customJobDetail})
    : super(fullyQualifiedName);

  factory PipelineTaskExecutorDetail.fromJson(Map<String, dynamic> json) {
    return PipelineTaskExecutorDetail(
      containerDetail: decode(
        json['containerDetail'],
        PipelineTaskExecutorDetail_ContainerDetail.fromJson,
      ),
      customJobDetail: decode(
        json['customJobDetail'],
        PipelineTaskExecutorDetail_CustomJobDetail.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (containerDetail != null) 'containerDetail': containerDetail!.toJson(),
      if (customJobDetail != null) 'customJobDetail': customJobDetail!.toJson(),
    };
  }

  @override
  String toString() => 'PipelineTaskExecutorDetail()';
}

/// The detail of a container execution. It contains the job names of the
/// lifecycle of a container execution.
final class PipelineTaskExecutorDetail_ContainerDetail
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskExecutorDetail.ContainerDetail';

  /// Output only. The name of the
  /// `CustomJob` for the main
  /// container execution.
  final String? mainJob;

  /// Output only. The name of the
  /// `CustomJob` for the
  /// pre-caching-check container execution. This job will be available if the
  /// `PipelineJob.pipeline_spec`
  /// specifies the `pre_caching_check` hook in the lifecycle events.
  final String? preCachingCheckJob;

  /// Output only. The names of the previously failed
  /// `CustomJob` for the main
  /// container executions. The list includes the all attempts in chronological
  /// order.
  final List<String>? failedMainJobs;

  /// Output only. The names of the previously failed
  /// `CustomJob` for the
  /// pre-caching-check container executions. This job will be available if the
  /// `PipelineJob.pipeline_spec`
  /// specifies the `pre_caching_check` hook in the lifecycle events. The list
  /// includes the all attempts in chronological order.
  final List<String>? failedPreCachingCheckJobs;

  PipelineTaskExecutorDetail_ContainerDetail({
    this.mainJob,
    this.preCachingCheckJob,
    this.failedMainJobs,
    this.failedPreCachingCheckJobs,
  }) : super(fullyQualifiedName);

  factory PipelineTaskExecutorDetail_ContainerDetail.fromJson(
    Map<String, dynamic> json,
  ) {
    return PipelineTaskExecutorDetail_ContainerDetail(
      mainJob: json['mainJob'],
      preCachingCheckJob: json['preCachingCheckJob'],
      failedMainJobs: decodeList(json['failedMainJobs']),
      failedPreCachingCheckJobs: decodeList(json['failedPreCachingCheckJobs']),
    );
  }

  @override
  Object toJson() {
    return {
      if (mainJob != null) 'mainJob': mainJob,
      if (preCachingCheckJob != null) 'preCachingCheckJob': preCachingCheckJob,
      if (failedMainJobs != null) 'failedMainJobs': failedMainJobs,
      if (failedPreCachingCheckJobs != null)
        'failedPreCachingCheckJobs': failedPreCachingCheckJobs,
    };
  }

  @override
  String toString() {
    final contents = [
      if (mainJob != null) 'mainJob=$mainJob',
      if (preCachingCheckJob != null) 'preCachingCheckJob=$preCachingCheckJob',
    ].join(',');
    return 'ContainerDetail($contents)';
  }
}

/// The detailed info for a custom job executor.
final class PipelineTaskExecutorDetail_CustomJobDetail
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskExecutorDetail.CustomJobDetail';

  /// Output only. The name of the
  /// `CustomJob`.
  final String? job;

  /// Output only. The names of the previously failed
  /// `CustomJob`. The list includes
  /// the all attempts in chronological order.
  final List<String>? failedJobs;

  PipelineTaskExecutorDetail_CustomJobDetail({this.job, this.failedJobs})
    : super(fullyQualifiedName);

  factory PipelineTaskExecutorDetail_CustomJobDetail.fromJson(
    Map<String, dynamic> json,
  ) {
    return PipelineTaskExecutorDetail_CustomJobDetail(
      job: json['job'],
      failedJobs: decodeList(json['failedJobs']),
    );
  }

  @override
  Object toJson() {
    return {
      if (job != null) 'job': job,
      if (failedJobs != null) 'failedJobs': failedJobs,
    };
  }

  @override
  String toString() {
    final contents = [if (job != null) 'job=$job'].join(',');
    return 'CustomJobDetail($contents)';
  }
}

/// User provided rerun config to submit a rerun pipelinejob. This includes
/// 1. Which task to rerun
/// 2. User override input parameters and artifacts.
final class PipelineTaskRerunConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskRerunConfig';

  /// Optional. The system generated ID of the task. Retrieved from original run.
  final int? taskId;

  /// Optional. The name of the task.
  final String? taskName;

  /// Optional. The runtime input of the task overridden by the user.
  final PipelineTaskRerunConfig_Inputs? inputs;

  /// Optional. Whether to skip this task. Default value is False.
  final bool? skipTask;

  /// Optional. Whether to skip downstream tasks. Default value is False.
  final bool? skipDownstreamTasks;

  PipelineTaskRerunConfig({
    this.taskId,
    this.taskName,
    this.inputs,
    this.skipTask,
    this.skipDownstreamTasks,
  }) : super(fullyQualifiedName);

  factory PipelineTaskRerunConfig.fromJson(Map<String, dynamic> json) {
    return PipelineTaskRerunConfig(
      taskId: decodeInt64(json['taskId']),
      taskName: json['taskName'],
      inputs: decode(json['inputs'], PipelineTaskRerunConfig_Inputs.fromJson),
      skipTask: json['skipTask'],
      skipDownstreamTasks: json['skipDownstreamTasks'],
    );
  }

  @override
  Object toJson() {
    return {
      if (taskId != null) 'taskId': encodeInt64(taskId),
      if (taskName != null) 'taskName': taskName,
      if (inputs != null) 'inputs': inputs!.toJson(),
      if (skipTask != null) 'skipTask': skipTask,
      if (skipDownstreamTasks != null)
        'skipDownstreamTasks': skipDownstreamTasks,
    };
  }

  @override
  String toString() {
    final contents = [
      if (taskId != null) 'taskId=$taskId',
      if (taskName != null) 'taskName=$taskName',
      if (skipTask != null) 'skipTask=$skipTask',
      if (skipDownstreamTasks != null)
        'skipDownstreamTasks=$skipDownstreamTasks',
    ].join(',');
    return 'PipelineTaskRerunConfig($contents)';
  }
}

/// A list of artifact metadata.
final class PipelineTaskRerunConfig_ArtifactList extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskRerunConfig.ArtifactList';

  /// Optional. A list of artifact metadata.
  final List<RuntimeArtifact>? artifacts;

  PipelineTaskRerunConfig_ArtifactList({this.artifacts})
    : super(fullyQualifiedName);

  factory PipelineTaskRerunConfig_ArtifactList.fromJson(
    Map<String, dynamic> json,
  ) {
    return PipelineTaskRerunConfig_ArtifactList(
      artifacts: decodeListMessage(json['artifacts'], RuntimeArtifact.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (artifacts != null) 'artifacts': encodeList(artifacts)};
  }

  @override
  String toString() => 'ArtifactList()';
}

/// Runtime inputs data of the task.
final class PipelineTaskRerunConfig_Inputs extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PipelineTaskRerunConfig.Inputs';

  /// Optional. Input artifacts.
  final Map<String, PipelineTaskRerunConfig_ArtifactList>? artifacts;

  /// Optional. Input parameters.
  final Map<String, protobuf.Value>? parameterValues;

  PipelineTaskRerunConfig_Inputs({this.artifacts, this.parameterValues})
    : super(fullyQualifiedName);

  factory PipelineTaskRerunConfig_Inputs.fromJson(Map<String, dynamic> json) {
    return PipelineTaskRerunConfig_Inputs(
      artifacts: decodeMapMessage(
        json['artifacts'],
        PipelineTaskRerunConfig_ArtifactList.fromJson,
      ),
      parameterValues: decodeMapMessageCustom(
        json['parameterValues'],
        protobuf.Value.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (artifacts != null) 'artifacts': encodeMap(artifacts),
      if (parameterValues != null)
        'parameterValues': encodeMap(parameterValues),
    };
  }

  @override
  String toString() => 'Inputs()';
}

/// Runtime operation information for
/// `PipelineService.BatchCancelPipelineJobs`.
final class BatchCancelPipelineJobsOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCancelPipelineJobsOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  BatchCancelPipelineJobsOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory BatchCancelPipelineJobsOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchCancelPipelineJobsOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'BatchCancelPipelineJobsOperationMetadata()';
}

/// Request message for
/// `PipelineService.CreateTrainingPipeline`.
final class CreateTrainingPipelineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTrainingPipelineRequest';

  /// Required. The resource name of the Location to create the TrainingPipeline
  /// in. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The TrainingPipeline to create.
  final TrainingPipeline trainingPipeline;

  CreateTrainingPipelineRequest({
    required this.parent,
    required this.trainingPipeline,
  }) : super(fullyQualifiedName);

  factory CreateTrainingPipelineRequest.fromJson(Map<String, dynamic> json) {
    return CreateTrainingPipelineRequest(
      parent: json['parent'],
      trainingPipeline: decode(
        json['trainingPipeline'],
        TrainingPipeline.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'trainingPipeline': trainingPipeline.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateTrainingPipelineRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.GetTrainingPipeline`.
final class GetTrainingPipelineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTrainingPipelineRequest';

  /// Required. The name of the TrainingPipeline resource.
  /// Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  final String name;

  GetTrainingPipelineRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTrainingPipelineRequest.fromJson(Map<String, dynamic> json) {
    return GetTrainingPipelineRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTrainingPipelineRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.ListTrainingPipelines`.
final class ListTrainingPipelinesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTrainingPipelinesRequest';

  /// Required. The resource name of the Location to list the TrainingPipelines
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list filter.
  ///
  /// Supported fields:
  ///
  ///   * `display_name` supports `=`, `!=` comparisons, and `:` wildcard.
  ///   * `state` supports `=`, `!=` comparisons.
  ///   * `training_task_definition` `=`, `!=` comparisons, and `:` wildcard.
  ///   * `create_time` supports `=`, `!=`,`<`, `<=`,`>`, `>=` comparisons.
  ///     `create_time` must be in RFC 3339 format.
  ///   * `labels` supports general map functions that is:
  ///     `labels.key=value` - key:value equality
  ///     `labels.key:* - key existence
  ///
  /// Some examples of using the filter are:
  ///
  ///   * `state="PIPELINE_STATE_SUCCEEDED" AND display_name:"my_pipeline_*"`
  ///   * `state!="PIPELINE_STATE_FAILED" OR display_name="my_pipeline"`
  ///   * `NOT display_name="my_pipeline"`
  ///   * `create_time>"2021-05-18T00:00:00Z"`
  ///   * `training_task_definition:"*automl_text_classification*"`
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListTrainingPipelinesResponse.next_page_token`
  /// of the previous
  /// `PipelineService.ListTrainingPipelines`
  /// call.
  final String? pageToken;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTrainingPipelinesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTrainingPipelinesRequest.fromJson(Map<String, dynamic> json) {
    return ListTrainingPipelinesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListTrainingPipelinesRequest($contents)';
  }
}

/// Response message for
/// `PipelineService.ListTrainingPipelines`
final class ListTrainingPipelinesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTrainingPipelinesResponse';

  /// List of TrainingPipelines in the requested page.
  final List<TrainingPipeline>? trainingPipelines;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListTrainingPipelinesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListTrainingPipelinesResponse({this.trainingPipelines, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListTrainingPipelinesResponse.fromJson(Map<String, dynamic> json) {
    return ListTrainingPipelinesResponse(
      trainingPipelines: decodeListMessage(
        json['trainingPipelines'],
        TrainingPipeline.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingPipelines != null)
        'trainingPipelines': encodeList(trainingPipelines),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListTrainingPipelinesResponse($contents)';
  }
}

/// Request message for
/// `PipelineService.DeleteTrainingPipeline`.
final class DeleteTrainingPipelineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTrainingPipelineRequest';

  /// Required. The name of the TrainingPipeline resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  final String name;

  DeleteTrainingPipelineRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteTrainingPipelineRequest.fromJson(Map<String, dynamic> json) {
    return DeleteTrainingPipelineRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTrainingPipelineRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.CancelTrainingPipeline`.
final class CancelTrainingPipelineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelTrainingPipelineRequest';

  /// Required. The name of the TrainingPipeline to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/trainingPipelines/{training_pipeline}`
  final String name;

  CancelTrainingPipelineRequest({required this.name})
    : super(fullyQualifiedName);

  factory CancelTrainingPipelineRequest.fromJson(Map<String, dynamic> json) {
    return CancelTrainingPipelineRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelTrainingPipelineRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.CreatePipelineJob`.
final class CreatePipelineJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreatePipelineJobRequest';

  /// Required. The resource name of the Location to create the PipelineJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The PipelineJob to create.
  final PipelineJob pipelineJob;

  /// The ID to use for the PipelineJob, which will become the final component of
  /// the PipelineJob name. If not provided, an ID will be automatically
  /// generated.
  ///
  /// This value should be less than 128 characters, and valid characters
  /// are `/[a-z][0-9]-/`.
  final String? pipelineJobId;

  CreatePipelineJobRequest({
    required this.parent,
    required this.pipelineJob,
    this.pipelineJobId,
  }) : super(fullyQualifiedName);

  factory CreatePipelineJobRequest.fromJson(Map<String, dynamic> json) {
    return CreatePipelineJobRequest(
      parent: json['parent'],
      pipelineJob: decode(json['pipelineJob'], PipelineJob.fromJson)!,
      pipelineJobId: json['pipelineJobId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'pipelineJob': pipelineJob.toJson(),
      if (pipelineJobId != null) 'pipelineJobId': pipelineJobId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pipelineJobId != null) 'pipelineJobId=$pipelineJobId',
    ].join(',');
    return 'CreatePipelineJobRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.GetPipelineJob`.
final class GetPipelineJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetPipelineJobRequest';

  /// Required. The name of the PipelineJob resource.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  final String name;

  GetPipelineJobRequest({required this.name}) : super(fullyQualifiedName);

  factory GetPipelineJobRequest.fromJson(Map<String, dynamic> json) {
    return GetPipelineJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetPipelineJobRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.ListPipelineJobs`.
final class ListPipelineJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPipelineJobsRequest';

  /// Required. The resource name of the Location to list the PipelineJobs from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the PipelineJobs that match the filter expression. The following
  /// fields are supported:
  ///
  /// * `pipeline_name`: Supports `=` and `!=` comparisons.
  /// * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard.
  /// * `pipeline_job_user_id`: Supports `=`, `!=` comparisons, and `:` wildcard.
  ///   for example, can check if pipeline's display_name contains *step* by
  ///   doing display_name:\"*step*\"
  /// * `state`: Supports `=` and `!=` comparisons.
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///   Values must be in RFC 3339 format.
  /// * `update_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///   Values must be in RFC 3339 format.
  /// * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///   Values must be in RFC 3339 format.
  /// * `labels`: Supports key-value equality and key presence.
  /// * `template_uri`: Supports `=`, `!=` comparisons, and `:` wildcard.
  /// * `template_metadata.version`: Supports `=`, `!=` comparisons, and `:`
  ///   wildcard.
  ///
  /// Filter expressions can be combined together using logical operators
  /// (`AND` & `OR`).
  /// For example: `pipeline_name="test" AND create_time>"2020-05-18T13:30:00Z"`.
  ///
  /// The syntax to define filter expression is based on
  /// https://google.aip.dev/160.
  ///
  /// Examples:
  ///
  /// * `create_time>"2021-05-18T00:00:00Z" OR
  ///   update_time>"2020-05-18T00:00:00Z"` PipelineJobs created or updated
  ///   after 2020-05-18 00:00:00 UTC.
  /// * `labels.env = "prod"`
  ///   PipelineJobs with label "env" set to "prod".
  final String? filter;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListPipelineJobsResponse.next_page_token`
  /// of the previous
  /// `PipelineService.ListPipelineJobs`
  /// call.
  final String? pageToken;

  /// A comma-separated list of fields to order by. The default sort order is in
  /// ascending order. Use "desc" after a field name for descending. You can have
  /// multiple order_by fields provided e.g. "create_time desc, end_time",
  /// "end_time, start_time, update_time" For example, using "create_time desc,
  /// end_time" will order results by create time in descending order, and if
  /// there are multiple jobs having the same create time, order them by the end
  /// time in ascending order. if order_by is not specified, it will order by
  /// default order is create time in descending order. Supported fields:
  ///
  ///   * `create_time`
  ///   * `update_time`
  ///   * `end_time`
  ///   * `start_time`
  final String? orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListPipelineJobsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListPipelineJobsRequest.fromJson(Map<String, dynamic> json) {
    return ListPipelineJobsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListPipelineJobsRequest($contents)';
  }
}

/// Response message for
/// `PipelineService.ListPipelineJobs`
final class ListPipelineJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListPipelineJobsResponse';

  /// List of PipelineJobs in the requested page.
  final List<PipelineJob>? pipelineJobs;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListPipelineJobsRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListPipelineJobsResponse({this.pipelineJobs, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListPipelineJobsResponse.fromJson(Map<String, dynamic> json) {
    return ListPipelineJobsResponse(
      pipelineJobs: decodeListMessage(
        json['pipelineJobs'],
        PipelineJob.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (pipelineJobs != null) 'pipelineJobs': encodeList(pipelineJobs),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListPipelineJobsResponse($contents)';
  }
}

/// Request message for
/// `PipelineService.DeletePipelineJob`.
final class DeletePipelineJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeletePipelineJobRequest';

  /// Required. The name of the PipelineJob resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  final String name;

  DeletePipelineJobRequest({required this.name}) : super(fullyQualifiedName);

  factory DeletePipelineJobRequest.fromJson(Map<String, dynamic> json) {
    return DeletePipelineJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeletePipelineJobRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.BatchDeletePipelineJobs`.
final class BatchDeletePipelineJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchDeletePipelineJobsRequest';

  /// Required. The name of the PipelineJobs' parent resource.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The names of the PipelineJobs to delete.
  /// A maximum of 32 PipelineJobs can be deleted in a batch.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
  final List<String>? names;

  BatchDeletePipelineJobsRequest({required this.parent, this.names})
    : super(fullyQualifiedName);

  factory BatchDeletePipelineJobsRequest.fromJson(Map<String, dynamic> json) {
    return BatchDeletePipelineJobsRequest(
      parent: json['parent'],
      names: decodeList(json['names']),
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, if (names != null) 'names': names};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchDeletePipelineJobsRequest($contents)';
  }
}

/// Response message for
/// `PipelineService.BatchDeletePipelineJobs`.
final class BatchDeletePipelineJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchDeletePipelineJobsResponse';

  /// PipelineJobs deleted.
  final List<PipelineJob>? pipelineJobs;

  BatchDeletePipelineJobsResponse({this.pipelineJobs})
    : super(fullyQualifiedName);

  factory BatchDeletePipelineJobsResponse.fromJson(Map<String, dynamic> json) {
    return BatchDeletePipelineJobsResponse(
      pipelineJobs: decodeListMessage(
        json['pipelineJobs'],
        PipelineJob.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (pipelineJobs != null) 'pipelineJobs': encodeList(pipelineJobs)};
  }

  @override
  String toString() => 'BatchDeletePipelineJobsResponse()';
}

/// Request message for
/// `PipelineService.CancelPipelineJob`.
final class CancelPipelineJobRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CancelPipelineJobRequest';

  /// Required. The name of the PipelineJob to cancel.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`
  final String name;

  CancelPipelineJobRequest({required this.name}) : super(fullyQualifiedName);

  factory CancelPipelineJobRequest.fromJson(Map<String, dynamic> json) {
    return CancelPipelineJobRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelPipelineJobRequest($contents)';
  }
}

/// Request message for
/// `PipelineService.BatchCancelPipelineJobs`.
final class BatchCancelPipelineJobsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCancelPipelineJobsRequest';

  /// Required. The name of the PipelineJobs' parent resource.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The names of the PipelineJobs to cancel.
  /// A maximum of 32 PipelineJobs can be cancelled in a batch.
  /// Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipelineJob}`
  final List<String>? names;

  BatchCancelPipelineJobsRequest({required this.parent, this.names})
    : super(fullyQualifiedName);

  factory BatchCancelPipelineJobsRequest.fromJson(Map<String, dynamic> json) {
    return BatchCancelPipelineJobsRequest(
      parent: json['parent'],
      names: decodeList(json['names']),
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, if (names != null) 'names': names};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchCancelPipelineJobsRequest($contents)';
  }
}

/// Response message for
/// `PipelineService.BatchCancelPipelineJobs`.
final class BatchCancelPipelineJobsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCancelPipelineJobsResponse';

  /// PipelineJobs cancelled.
  final List<PipelineJob>? pipelineJobs;

  BatchCancelPipelineJobsResponse({this.pipelineJobs})
    : super(fullyQualifiedName);

  factory BatchCancelPipelineJobsResponse.fromJson(Map<String, dynamic> json) {
    return BatchCancelPipelineJobsResponse(
      pipelineJobs: decodeListMessage(
        json['pipelineJobs'],
        PipelineJob.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (pipelineJobs != null) 'pipelineJobs': encodeList(pipelineJobs)};
  }

  @override
  String toString() => 'BatchCancelPipelineJobsResponse()';
}

/// Request message for
/// `PredictionService.Predict`.
final class PredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The instances that are the input to the prediction call.
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the prediction call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model.
  /// The schema of any single instance may be specified via Endpoint's
  /// DeployedModels'
  /// [Model's][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`.
  final List<protobuf.Value>? instances;

  /// The parameters that govern the prediction. The schema of the parameters may
  /// be specified via Endpoint's DeployedModels' [Model's
  /// ][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `parameters_schema_uri`.
  final protobuf.Value? parameters;

  /// Optional. The user labels for Imagen billing usage only. Only Imagen
  /// supports labels. For other use cases, it will be ignored.
  final Map<String, String>? labels;

  PredictRequest({
    required this.endpoint,
    this.instances,
    this.parameters,
    this.labels,
  }) : super(fullyQualifiedName);

  factory PredictRequest.fromJson(Map<String, dynamic> json) {
    return PredictRequest(
      endpoint: json['endpoint'],
      instances: decodeListMessageCustom(
        json['instances'],
        protobuf.Value.fromJson,
      ),
      parameters: decodeCustom(json['parameters'], protobuf.Value.fromJson),
      labels: decodeMap(json['labels']),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (instances != null) 'instances': encodeList(instances),
      if (parameters != null) 'parameters': parameters!.toJson(),
      if (labels != null) 'labels': labels,
    };
  }

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'PredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.Predict`.
final class PredictResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictResponse';

  /// The predictions that are the output of the predictions call.
  /// The schema of any single prediction may be specified via Endpoint's
  /// DeployedModels' [Model's
  /// ][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `prediction_schema_uri`.
  final List<protobuf.Value>? predictions;

  /// ID of the Endpoint's DeployedModel that served this prediction.
  final String? deployedModelId;

  /// Output only. The resource name of the Model which is deployed as the
  /// DeployedModel that this prediction hits.
  final String? model;

  /// Output only. The version ID of the Model which is deployed as the
  /// DeployedModel that this prediction hits.
  final String? modelVersionId;

  /// Output only. The [display
  /// name][google.cloud.aiplatform.v1beta1.Model.display_name] of the Model
  /// which is deployed as the DeployedModel that this prediction hits.
  final String? modelDisplayName;

  /// Output only. Request-level metadata returned by the model. The metadata
  /// type will be dependent upon the model implementation.
  final protobuf.Value? metadata;

  PredictResponse({
    this.predictions,
    this.deployedModelId,
    this.model,
    this.modelVersionId,
    this.modelDisplayName,
    this.metadata,
  }) : super(fullyQualifiedName);

  factory PredictResponse.fromJson(Map<String, dynamic> json) {
    return PredictResponse(
      predictions: decodeListMessageCustom(
        json['predictions'],
        protobuf.Value.fromJson,
      ),
      deployedModelId: json['deployedModelId'],
      model: json['model'],
      modelVersionId: json['modelVersionId'],
      modelDisplayName: json['modelDisplayName'],
      metadata: decodeCustom(json['metadata'], protobuf.Value.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (predictions != null) 'predictions': encodeList(predictions),
      if (deployedModelId != null) 'deployedModelId': deployedModelId,
      if (model != null) 'model': model,
      if (modelVersionId != null) 'modelVersionId': modelVersionId,
      if (modelDisplayName != null) 'modelDisplayName': modelDisplayName,
      if (metadata != null) 'metadata': metadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (deployedModelId != null) 'deployedModelId=$deployedModelId',
      if (model != null) 'model=$model',
      if (modelVersionId != null) 'modelVersionId=$modelVersionId',
      if (modelDisplayName != null) 'modelDisplayName=$modelDisplayName',
    ].join(',');
    return 'PredictResponse($contents)';
  }
}

/// Request message for
/// `PredictionService.RawPredict`.
final class RawPredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// The prediction input. Supports HTTP headers and arbitrary data payload.
  ///
  /// A `DeployedModel` may have
  /// an upper limit on the number of instances it supports per request. When
  /// this limit it is exceeded for an AutoML model, the
  /// `RawPredict`
  /// method returns an error. When this limit is exceeded for a custom-trained
  /// model, the behavior varies depending on the model.
  ///
  /// You can specify the schema for each instance in the
  /// `predict_schemata.instance_schema_uri`
  /// field when you create a `Model`.
  /// This schema applies when you deploy the `Model` as a `DeployedModel` to an
  /// `Endpoint` and use the
  /// `RawPredict` method.
  final HttpBody? httpBody;

  RawPredictRequest({required this.endpoint, this.httpBody})
    : super(fullyQualifiedName);

  factory RawPredictRequest.fromJson(Map<String, dynamic> json) {
    return RawPredictRequest(
      endpoint: json['endpoint'],
      httpBody: decode(json['httpBody'], HttpBody.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (httpBody != null) 'httpBody': httpBody!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'RawPredictRequest($contents)';
  }
}

/// Request message for
/// `PredictionService.StreamRawPredict`.
final class StreamRawPredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamRawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// The prediction input. Supports HTTP headers and arbitrary data payload.
  final HttpBody? httpBody;

  StreamRawPredictRequest({required this.endpoint, this.httpBody})
    : super(fullyQualifiedName);

  factory StreamRawPredictRequest.fromJson(Map<String, dynamic> json) {
    return StreamRawPredictRequest(
      endpoint: json['endpoint'],
      httpBody: decode(json['httpBody'], HttpBody.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (httpBody != null) 'httpBody': httpBody!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'StreamRawPredictRequest($contents)';
  }
}

/// Request message for
/// `PredictionService.DirectPredict`.
final class DirectPredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// The prediction input.
  final List<Tensor>? inputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  DirectPredictRequest({required this.endpoint, this.inputs, this.parameters})
    : super(fullyQualifiedName);

  factory DirectPredictRequest.fromJson(Map<String, dynamic> json) {
    return DirectPredictRequest(
      endpoint: json['endpoint'],
      inputs: decodeListMessage(json['inputs'], Tensor.fromJson),
      parameters: decode(json['parameters'], Tensor.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (inputs != null) 'inputs': encodeList(inputs),
      if (parameters != null) 'parameters': parameters!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'DirectPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.DirectPredict`.
final class DirectPredictResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectPredictResponse';

  /// The prediction output.
  final List<Tensor>? outputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  DirectPredictResponse({this.outputs, this.parameters})
    : super(fullyQualifiedName);

  factory DirectPredictResponse.fromJson(Map<String, dynamic> json) {
    return DirectPredictResponse(
      outputs: decodeListMessage(json['outputs'], Tensor.fromJson),
      parameters: decode(json['parameters'], Tensor.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (outputs != null) 'outputs': encodeList(outputs),
      if (parameters != null) 'parameters': parameters!.toJson(),
    };
  }

  @override
  String toString() => 'DirectPredictResponse()';
}

/// Request message for
/// `PredictionService.DirectRawPredict`.
final class DirectRawPredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectRawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Fully qualified name of the API method being invoked to perform
  /// predictions.
  ///
  /// Format:
  /// `/namespace.Service/Method/`
  /// Example:
  /// `/tensorflow.serving.PredictionService/Predict`
  final String? methodName;

  /// The prediction input.
  final Uint8List? input;

  DirectRawPredictRequest({required this.endpoint, this.methodName, this.input})
    : super(fullyQualifiedName);

  factory DirectRawPredictRequest.fromJson(Map<String, dynamic> json) {
    return DirectRawPredictRequest(
      endpoint: json['endpoint'],
      methodName: json['methodName'],
      input: decodeBytes(json['input']),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (methodName != null) 'methodName': methodName,
      if (input != null) 'input': encodeBytes(input),
    };
  }

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      if (methodName != null) 'methodName=$methodName',
      if (input != null) 'input=$input',
    ].join(',');
    return 'DirectRawPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.DirectRawPredict`.
final class DirectRawPredictResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DirectRawPredictResponse';

  /// The prediction output.
  final Uint8List? output;

  DirectRawPredictResponse({this.output}) : super(fullyQualifiedName);

  factory DirectRawPredictResponse.fromJson(Map<String, dynamic> json) {
    return DirectRawPredictResponse(output: decodeBytes(json['output']));
  }

  @override
  Object toJson() {
    return {if (output != null) 'output': encodeBytes(output)};
  }

  @override
  String toString() {
    final contents = [if (output != null) 'output=$output'].join(',');
    return 'DirectRawPredictResponse($contents)';
  }
}

/// Request message for
/// `PredictionService.StreamDirectPredict`.
///
/// The first message must contain
/// `endpoint`
/// field and optionally `input`. The subsequent messages must contain
/// `input`.
final class StreamDirectPredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamDirectPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? endpoint;

  /// Optional. The prediction input.
  final List<Tensor>? inputs;

  /// Optional. The parameters that govern the prediction.
  final Tensor? parameters;

  StreamDirectPredictRequest({this.endpoint, this.inputs, this.parameters})
    : super(fullyQualifiedName);

  factory StreamDirectPredictRequest.fromJson(Map<String, dynamic> json) {
    return StreamDirectPredictRequest(
      endpoint: json['endpoint'],
      inputs: decodeListMessage(json['inputs'], Tensor.fromJson),
      parameters: decode(json['parameters'], Tensor.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (endpoint != null) 'endpoint': endpoint,
      if (inputs != null) 'inputs': encodeList(inputs),
      if (parameters != null) 'parameters': parameters!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (endpoint != null) 'endpoint=$endpoint'].join(',');
    return 'StreamDirectPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.StreamDirectPredict`.
final class StreamDirectPredictResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamDirectPredictResponse';

  /// The prediction output.
  final List<Tensor>? outputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  StreamDirectPredictResponse({this.outputs, this.parameters})
    : super(fullyQualifiedName);

  factory StreamDirectPredictResponse.fromJson(Map<String, dynamic> json) {
    return StreamDirectPredictResponse(
      outputs: decodeListMessage(json['outputs'], Tensor.fromJson),
      parameters: decode(json['parameters'], Tensor.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (outputs != null) 'outputs': encodeList(outputs),
      if (parameters != null) 'parameters': parameters!.toJson(),
    };
  }

  @override
  String toString() => 'StreamDirectPredictResponse()';
}

/// Request message for
/// `PredictionService.StreamDirectRawPredict`.
///
/// The first message must contain
/// `endpoint`
/// and
/// `method_name`
/// fields and optionally
/// `input`.
/// The subsequent messages must contain
/// `input`.
/// `method_name`
/// in the subsequent messages have no effect.
final class StreamDirectRawPredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamDirectRawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? endpoint;

  /// Optional. Fully qualified name of the API method being invoked to perform
  /// predictions.
  ///
  /// Format:
  /// `/namespace.Service/Method/`
  /// Example:
  /// `/tensorflow.serving.PredictionService/Predict`
  final String? methodName;

  /// Optional. The prediction input.
  final Uint8List? input;

  StreamDirectRawPredictRequest({this.endpoint, this.methodName, this.input})
    : super(fullyQualifiedName);

  factory StreamDirectRawPredictRequest.fromJson(Map<String, dynamic> json) {
    return StreamDirectRawPredictRequest(
      endpoint: json['endpoint'],
      methodName: json['methodName'],
      input: decodeBytes(json['input']),
    );
  }

  @override
  Object toJson() {
    return {
      if (endpoint != null) 'endpoint': endpoint,
      if (methodName != null) 'methodName': methodName,
      if (input != null) 'input': encodeBytes(input),
    };
  }

  @override
  String toString() {
    final contents = [
      if (endpoint != null) 'endpoint=$endpoint',
      if (methodName != null) 'methodName=$methodName',
      if (input != null) 'input=$input',
    ].join(',');
    return 'StreamDirectRawPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.StreamDirectRawPredict`.
final class StreamDirectRawPredictResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamDirectRawPredictResponse';

  /// The prediction output.
  final Uint8List? output;

  StreamDirectRawPredictResponse({this.output}) : super(fullyQualifiedName);

  factory StreamDirectRawPredictResponse.fromJson(Map<String, dynamic> json) {
    return StreamDirectRawPredictResponse(output: decodeBytes(json['output']));
  }

  @override
  Object toJson() {
    return {if (output != null) 'output': encodeBytes(output)};
  }

  @override
  String toString() {
    final contents = [if (output != null) 'output=$output'].join(',');
    return 'StreamDirectRawPredictResponse($contents)';
  }
}

/// Request message for
/// `PredictionService.StreamingPredict`.
///
/// The first message must contain
/// `endpoint`
/// field and optionally `input`. The subsequent messages must contain
/// `input`.
final class StreamingPredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// The prediction input.
  final List<Tensor>? inputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  StreamingPredictRequest({
    required this.endpoint,
    this.inputs,
    this.parameters,
  }) : super(fullyQualifiedName);

  factory StreamingPredictRequest.fromJson(Map<String, dynamic> json) {
    return StreamingPredictRequest(
      endpoint: json['endpoint'],
      inputs: decodeListMessage(json['inputs'], Tensor.fromJson),
      parameters: decode(json['parameters'], Tensor.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (inputs != null) 'inputs': encodeList(inputs),
      if (parameters != null) 'parameters': parameters!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'StreamingPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.StreamingPredict`.
final class StreamingPredictResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingPredictResponse';

  /// The prediction output.
  final List<Tensor>? outputs;

  /// The parameters that govern the prediction.
  final Tensor? parameters;

  StreamingPredictResponse({this.outputs, this.parameters})
    : super(fullyQualifiedName);

  factory StreamingPredictResponse.fromJson(Map<String, dynamic> json) {
    return StreamingPredictResponse(
      outputs: decodeListMessage(json['outputs'], Tensor.fromJson),
      parameters: decode(json['parameters'], Tensor.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (outputs != null) 'outputs': encodeList(outputs),
      if (parameters != null) 'parameters': parameters!.toJson(),
    };
  }

  @override
  String toString() => 'StreamingPredictResponse()';
}

/// Request message for
/// `PredictionService.StreamingRawPredict`.
///
/// The first message must contain
/// `endpoint`
/// and
/// `method_name`
/// fields and optionally
/// `input`.
/// The subsequent messages must contain
/// `input`.
/// `method_name`
/// in the subsequent messages have no effect.
final class StreamingRawPredictRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingRawPredictRequest';

  /// Required. The name of the Endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? endpoint;

  /// Fully qualified name of the API method being invoked to perform
  /// predictions.
  ///
  /// Format:
  /// `/namespace.Service/Method/`
  /// Example:
  /// `/tensorflow.serving.PredictionService/Predict`
  final String? methodName;

  /// The prediction input.
  final Uint8List? input;

  StreamingRawPredictRequest({this.endpoint, this.methodName, this.input})
    : super(fullyQualifiedName);

  factory StreamingRawPredictRequest.fromJson(Map<String, dynamic> json) {
    return StreamingRawPredictRequest(
      endpoint: json['endpoint'],
      methodName: json['methodName'],
      input: decodeBytes(json['input']),
    );
  }

  @override
  Object toJson() {
    return {
      if (endpoint != null) 'endpoint': endpoint,
      if (methodName != null) 'methodName': methodName,
      if (input != null) 'input': encodeBytes(input),
    };
  }

  @override
  String toString() {
    final contents = [
      if (endpoint != null) 'endpoint=$endpoint',
      if (methodName != null) 'methodName=$methodName',
      if (input != null) 'input=$input',
    ].join(',');
    return 'StreamingRawPredictRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.StreamingRawPredict`.
final class StreamingRawPredictResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamingRawPredictResponse';

  /// The prediction output.
  final Uint8List? output;

  StreamingRawPredictResponse({this.output}) : super(fullyQualifiedName);

  factory StreamingRawPredictResponse.fromJson(Map<String, dynamic> json) {
    return StreamingRawPredictResponse(output: decodeBytes(json['output']));
  }

  @override
  Object toJson() {
    return {if (output != null) 'output': encodeBytes(output)};
  }

  @override
  String toString() {
    final contents = [if (output != null) 'output=$output'].join(',');
    return 'StreamingRawPredictResponse($contents)';
  }
}

/// Request message for
/// `PredictionService.Explain`.
final class ExplainRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplainRequest';

  /// Required. The name of the Endpoint requested to serve the explanation.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Required. The instances that are the input to the explanation call.
  /// A DeployedModel may have an upper limit on the number of instances it
  /// supports per request, and when it is exceeded the explanation call errors
  /// in case of AutoML Models, or, in case of customer created Models, the
  /// behaviour is as documented by that Model.
  /// The schema of any single instance may be specified via Endpoint's
  /// DeployedModels'
  /// [Model's][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `instance_schema_uri`.
  final List<protobuf.Value>? instances;

  /// The parameters that govern the prediction. The schema of the parameters may
  /// be specified via Endpoint's DeployedModels' [Model's
  /// ][google.cloud.aiplatform.v1beta1.DeployedModel.model]
  /// [PredictSchemata's][google.cloud.aiplatform.v1beta1.Model.predict_schemata]
  /// `parameters_schema_uri`.
  final protobuf.Value? parameters;

  /// If specified, overrides the
  /// `explanation_spec`
  /// of the DeployedModel. Can be used for explaining prediction results with
  /// different configurations, such as:
  ///  - Explaining top-5 predictions results as opposed to top-1;
  ///  - Increasing path count or step count of the attribution methods to reduce
  ///    approximate errors;
  ///  - Using different baselines for explaining the prediction results.
  final ExplanationSpecOverride? explanationSpecOverride;

  /// Optional. This field is the same as the one above, but supports multiple
  /// explanations to occur in parallel. The key can be any string. Each override
  /// will be run against the model, then its explanations will be grouped
  /// together.
  ///
  /// Note - these explanations are run **In Addition** to the default
  /// Explanation in the deployed model.
  final Map<String, ExplanationSpecOverride>? concurrentExplanationSpecOverride;

  /// If specified, this ExplainRequest will be served by the chosen
  /// DeployedModel, overriding
  /// `Endpoint.traffic_split`.
  final String? deployedModelId;

  ExplainRequest({
    required this.endpoint,
    this.instances,
    this.parameters,
    this.explanationSpecOverride,
    this.concurrentExplanationSpecOverride,
    this.deployedModelId,
  }) : super(fullyQualifiedName);

  factory ExplainRequest.fromJson(Map<String, dynamic> json) {
    return ExplainRequest(
      endpoint: json['endpoint'],
      instances: decodeListMessageCustom(
        json['instances'],
        protobuf.Value.fromJson,
      ),
      parameters: decodeCustom(json['parameters'], protobuf.Value.fromJson),
      explanationSpecOverride: decode(
        json['explanationSpecOverride'],
        ExplanationSpecOverride.fromJson,
      ),
      concurrentExplanationSpecOverride: decodeMapMessage(
        json['concurrentExplanationSpecOverride'],
        ExplanationSpecOverride.fromJson,
      ),
      deployedModelId: json['deployedModelId'],
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (instances != null) 'instances': encodeList(instances),
      if (parameters != null) 'parameters': parameters!.toJson(),
      if (explanationSpecOverride != null)
        'explanationSpecOverride': explanationSpecOverride!.toJson(),
      if (concurrentExplanationSpecOverride != null)
        'concurrentExplanationSpecOverride': encodeMap(
          concurrentExplanationSpecOverride,
        ),
      if (deployedModelId != null) 'deployedModelId': deployedModelId,
    };
  }

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      if (deployedModelId != null) 'deployedModelId=$deployedModelId',
    ].join(',');
    return 'ExplainRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.Explain`.
final class ExplainResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplainResponse';

  /// The explanations of the Model's
  /// `PredictResponse.predictions`.
  ///
  /// It has the same number of elements as
  /// `instances` to be
  /// explained.
  final List<Explanation>? explanations;

  /// This field stores the results of the explanations run in parallel with
  /// The default explanation strategy/method.
  final Map<String, ExplainResponse_ConcurrentExplanation>?
  concurrentExplanations;

  /// ID of the Endpoint's DeployedModel that served this explanation.
  final String? deployedModelId;

  /// The predictions that are the output of the predictions call.
  /// Same as
  /// `PredictResponse.predictions`.
  final List<protobuf.Value>? predictions;

  ExplainResponse({
    this.explanations,
    this.concurrentExplanations,
    this.deployedModelId,
    this.predictions,
  }) : super(fullyQualifiedName);

  factory ExplainResponse.fromJson(Map<String, dynamic> json) {
    return ExplainResponse(
      explanations: decodeListMessage(
        json['explanations'],
        Explanation.fromJson,
      ),
      concurrentExplanations: decodeMapMessage(
        json['concurrentExplanations'],
        ExplainResponse_ConcurrentExplanation.fromJson,
      ),
      deployedModelId: json['deployedModelId'],
      predictions: decodeListMessageCustom(
        json['predictions'],
        protobuf.Value.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (explanations != null) 'explanations': encodeList(explanations),
      if (concurrentExplanations != null)
        'concurrentExplanations': encodeMap(concurrentExplanations),
      if (deployedModelId != null) 'deployedModelId': deployedModelId,
      if (predictions != null) 'predictions': encodeList(predictions),
    };
  }

  @override
  String toString() {
    final contents = [
      if (deployedModelId != null) 'deployedModelId=$deployedModelId',
    ].join(',');
    return 'ExplainResponse($contents)';
  }
}

/// This message is a wrapper grouping Concurrent Explanations.
final class ExplainResponse_ConcurrentExplanation
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExplainResponse.ConcurrentExplanation';

  /// The explanations of the Model's
  /// `PredictResponse.predictions`.
  ///
  /// It has the same number of elements as
  /// `instances` to
  /// be explained.
  final List<Explanation>? explanations;

  ExplainResponse_ConcurrentExplanation({this.explanations})
    : super(fullyQualifiedName);

  factory ExplainResponse_ConcurrentExplanation.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExplainResponse_ConcurrentExplanation(
      explanations: decodeListMessage(
        json['explanations'],
        Explanation.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (explanations != null) 'explanations': encodeList(explanations)};
  }

  @override
  String toString() => 'ConcurrentExplanation()';
}

/// Request message for
/// `PredictionService.CountTokens`.
final class CountTokensRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CountTokensRequest';

  /// Required. The name of the Endpoint requested to perform token counting.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Optional. The name of the publisher model requested to serve the
  /// prediction. Format:
  /// `projects/{project}/locations/{location}/publishers/*/models/*`
  final String? model;

  /// Optional. The instances that are the input to token counting call.
  /// Schema is identical to the prediction schema of the underlying model.
  final List<protobuf.Value>? instances;

  /// Optional. Input content.
  final List<Content>? contents;

  /// Optional. The user provided system instructions for the model.
  /// Note: only text should be used in parts and content in each part will be in
  /// a separate paragraph.
  final Content? systemInstruction;

  /// Optional. A list of `Tools` the model may use to generate the next
  /// response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  final List<Tool>? tools;

  /// Optional. Generation config that the model will use to generate the
  /// response.
  final GenerationConfig? generationConfig;

  CountTokensRequest({
    required this.endpoint,
    this.model,
    this.instances,
    this.contents,
    this.systemInstruction,
    this.tools,
    this.generationConfig,
  }) : super(fullyQualifiedName);

  factory CountTokensRequest.fromJson(Map<String, dynamic> json) {
    return CountTokensRequest(
      endpoint: json['endpoint'],
      model: json['model'],
      instances: decodeListMessageCustom(
        json['instances'],
        protobuf.Value.fromJson,
      ),
      contents: decodeListMessage(json['contents'], Content.fromJson),
      systemInstruction: decode(json['systemInstruction'], Content.fromJson),
      tools: decodeListMessage(json['tools'], Tool.fromJson),
      generationConfig: decode(
        json['generationConfig'],
        GenerationConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'endpoint': endpoint,
      if (model != null) 'model': model,
      if (instances != null) 'instances': encodeList(instances),
      if (contents != null) 'contents': encodeList(contents),
      if (systemInstruction != null)
        'systemInstruction': systemInstruction!.toJson(),
      if (tools != null) 'tools': encodeList(tools),
      if (generationConfig != null)
        'generationConfig': generationConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'endpoint=$endpoint',
      if (model != null) 'model=$model',
    ].join(',');
    return 'CountTokensRequest($contents)';
  }
}

/// Response message for
/// `PredictionService.CountTokens`.
final class CountTokensResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CountTokensResponse';

  /// The total number of tokens counted across all instances from the request.
  final int? totalTokens;

  /// The total number of billable characters counted across all instances from
  /// the request.
  final int? totalBillableCharacters;

  /// Output only. List of modalities that were processed in the request input.
  final List<ModalityTokenCount>? promptTokensDetails;

  CountTokensResponse({
    this.totalTokens,
    this.totalBillableCharacters,
    this.promptTokensDetails,
  }) : super(fullyQualifiedName);

  factory CountTokensResponse.fromJson(Map<String, dynamic> json) {
    return CountTokensResponse(
      totalTokens: json['totalTokens'],
      totalBillableCharacters: json['totalBillableCharacters'],
      promptTokensDetails: decodeListMessage(
        json['promptTokensDetails'],
        ModalityTokenCount.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (totalTokens != null) 'totalTokens': totalTokens,
      if (totalBillableCharacters != null)
        'totalBillableCharacters': totalBillableCharacters,
      if (promptTokensDetails != null)
        'promptTokensDetails': encodeList(promptTokensDetails),
    };
  }

  @override
  String toString() {
    final contents = [
      if (totalTokens != null) 'totalTokens=$totalTokens',
      if (totalBillableCharacters != null)
        'totalBillableCharacters=$totalBillableCharacters',
    ].join(',');
    return 'CountTokensResponse($contents)';
  }
}

/// Request message for [PredictionService.GenerateContent].
final class GenerateContentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateContentRequest';

  /// Required. The fully qualified name of the publisher model or tuned model
  /// endpoint to use.
  ///
  /// Publisher model format:
  /// `projects/{project}/locations/{location}/publishers/*/models/*`
  ///
  /// Tuned model endpoint format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String model;

  /// Required. The content of the current conversation with the model.
  ///
  /// For single-turn queries, this is a single instance. For multi-turn queries,
  /// this is a repeated field that contains conversation history + latest
  /// request.
  final List<Content>? contents;

  /// Optional. The user provided system instructions for the model.
  /// Note: only text should be used in parts and content in each part will be in
  /// a separate paragraph.
  final Content? systemInstruction;

  /// Optional. The name of the cached content used as context to serve the
  /// prediction. Note: only used in explicit caching, where users can have
  /// control over caching (e.g. what content to cache) and enjoy guaranteed cost
  /// savings. Format:
  /// `projects/{project}/locations/{location}/cachedContents/{cachedContent}`
  final String? cachedContent;

  /// Optional. A list of `Tools` the model may use to generate the next
  /// response.
  ///
  /// A `Tool` is a piece of code that enables the system to interact with
  /// external systems to perform an action, or set of actions, outside of
  /// knowledge and scope of the model.
  final List<Tool>? tools;

  /// Optional. Tool config. This config is shared for all tools provided in the
  /// request.
  final ToolConfig? toolConfig;

  /// Optional. The labels with user-defined metadata for the request. It is used
  /// for billing and reporting only.
  ///
  /// Label keys and values can be no longer than 63 characters
  /// (Unicode codepoints) and can only contain lowercase letters, numeric
  /// characters, underscores, and dashes. International characters are allowed.
  /// Label values are optional. Label keys must start with a letter.
  final Map<String, String>? labels;

  /// Optional. Per request settings for blocking unsafe content.
  /// Enforced on GenerateContentResponse.candidates.
  final List<SafetySetting>? safetySettings;

  /// Optional. Settings for prompt and response sanitization using the Model
  /// Armor service. If supplied, safety_settings must not be supplied.
  final ModelArmorConfig? modelArmorConfig;

  /// Optional. Generation config.
  final GenerationConfig? generationConfig;

  GenerateContentRequest({
    required this.model,
    this.contents,
    this.systemInstruction,
    this.cachedContent,
    this.tools,
    this.toolConfig,
    this.labels,
    this.safetySettings,
    this.modelArmorConfig,
    this.generationConfig,
  }) : super(fullyQualifiedName);

  factory GenerateContentRequest.fromJson(Map<String, dynamic> json) {
    return GenerateContentRequest(
      model: json['model'],
      contents: decodeListMessage(json['contents'], Content.fromJson),
      systemInstruction: decode(json['systemInstruction'], Content.fromJson),
      cachedContent: json['cachedContent'],
      tools: decodeListMessage(json['tools'], Tool.fromJson),
      toolConfig: decode(json['toolConfig'], ToolConfig.fromJson),
      labels: decodeMap(json['labels']),
      safetySettings: decodeListMessage(
        json['safetySettings'],
        SafetySetting.fromJson,
      ),
      modelArmorConfig: decode(
        json['modelArmorConfig'],
        ModelArmorConfig.fromJson,
      ),
      generationConfig: decode(
        json['generationConfig'],
        GenerationConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'model': model,
      if (contents != null) 'contents': encodeList(contents),
      if (systemInstruction != null)
        'systemInstruction': systemInstruction!.toJson(),
      if (cachedContent != null) 'cachedContent': cachedContent,
      if (tools != null) 'tools': encodeList(tools),
      if (toolConfig != null) 'toolConfig': toolConfig!.toJson(),
      if (labels != null) 'labels': labels,
      if (safetySettings != null) 'safetySettings': encodeList(safetySettings),
      if (modelArmorConfig != null)
        'modelArmorConfig': modelArmorConfig!.toJson(),
      if (generationConfig != null)
        'generationConfig': generationConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'model=$model',
      if (cachedContent != null) 'cachedContent=$cachedContent',
    ].join(',');
    return 'GenerateContentRequest($contents)';
  }
}

/// Response message for [PredictionService.GenerateContent].
final class GenerateContentResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateContentResponse';

  /// Output only. Generated candidates.
  final List<Candidate>? candidates;

  /// Output only. The model version used to generate the response.
  final String? modelVersion;

  /// Output only. Timestamp when the request is made to the server.
  final protobuf.Timestamp? createTime;

  /// Output only. response_id is used to identify each response. It is the
  /// encoding of the event_id.
  final String? responseId;

  /// Output only. Content filter results for a prompt sent in the request.
  /// Note: Sent only in the first stream chunk.
  /// Only happens when no candidates were generated due to content violations.
  final GenerateContentResponse_PromptFeedback? promptFeedback;

  /// Usage metadata about the response(s).
  final GenerateContentResponse_UsageMetadata? usageMetadata;

  GenerateContentResponse({
    this.candidates,
    this.modelVersion,
    this.createTime,
    this.responseId,
    this.promptFeedback,
    this.usageMetadata,
  }) : super(fullyQualifiedName);

  factory GenerateContentResponse.fromJson(Map<String, dynamic> json) {
    return GenerateContentResponse(
      candidates: decodeListMessage(json['candidates'], Candidate.fromJson),
      modelVersion: json['modelVersion'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      responseId: json['responseId'],
      promptFeedback: decode(
        json['promptFeedback'],
        GenerateContentResponse_PromptFeedback.fromJson,
      ),
      usageMetadata: decode(
        json['usageMetadata'],
        GenerateContentResponse_UsageMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (candidates != null) 'candidates': encodeList(candidates),
      if (modelVersion != null) 'modelVersion': modelVersion,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (responseId != null) 'responseId': responseId,
      if (promptFeedback != null) 'promptFeedback': promptFeedback!.toJson(),
      if (usageMetadata != null) 'usageMetadata': usageMetadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (modelVersion != null) 'modelVersion=$modelVersion',
      if (responseId != null) 'responseId=$responseId',
    ].join(',');
    return 'GenerateContentResponse($contents)';
  }
}

/// Content filter results for a prompt sent in the request.
final class GenerateContentResponse_PromptFeedback
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateContentResponse.PromptFeedback';

  /// Output only. Blocked reason.
  final GenerateContentResponse_PromptFeedback_BlockedReason? blockReason;

  /// Output only. Safety ratings.
  final List<SafetyRating>? safetyRatings;

  /// Output only. A readable block reason message.
  final String? blockReasonMessage;

  GenerateContentResponse_PromptFeedback({
    this.blockReason,
    this.safetyRatings,
    this.blockReasonMessage,
  }) : super(fullyQualifiedName);

  factory GenerateContentResponse_PromptFeedback.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateContentResponse_PromptFeedback(
      blockReason: decodeEnum(
        json['blockReason'],
        GenerateContentResponse_PromptFeedback_BlockedReason.fromJson,
      ),
      safetyRatings: decodeListMessage(
        json['safetyRatings'],
        SafetyRating.fromJson,
      ),
      blockReasonMessage: json['blockReasonMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (blockReason != null) 'blockReason': blockReason!.toJson(),
      if (safetyRatings != null) 'safetyRatings': encodeList(safetyRatings),
      if (blockReasonMessage != null) 'blockReasonMessage': blockReasonMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (blockReason != null) 'blockReason=$blockReason',
      if (blockReasonMessage != null) 'blockReasonMessage=$blockReasonMessage',
    ].join(',');
    return 'PromptFeedback($contents)';
  }
}

/// Blocked reason enumeration.
final class GenerateContentResponse_PromptFeedback_BlockedReason
    extends protobuf.ProtoEnum {
  /// Unspecified blocked reason.
  static const blockedReasonUnspecified =
      GenerateContentResponse_PromptFeedback_BlockedReason(
        'BLOCKED_REASON_UNSPECIFIED',
      );

  /// Candidates blocked due to safety.
  static const safety = GenerateContentResponse_PromptFeedback_BlockedReason(
    'SAFETY',
  );

  /// Candidates blocked due to other reason.
  static const other = GenerateContentResponse_PromptFeedback_BlockedReason(
    'OTHER',
  );

  /// Candidates blocked due to the terms which are included from the
  /// terminology blocklist.
  static const blocklist = GenerateContentResponse_PromptFeedback_BlockedReason(
    'BLOCKLIST',
  );

  /// Candidates blocked due to prohibited content.
  static const prohibitedContent =
      GenerateContentResponse_PromptFeedback_BlockedReason(
        'PROHIBITED_CONTENT',
      );

  /// The user prompt was blocked by Model Armor.
  static const modelArmor =
      GenerateContentResponse_PromptFeedback_BlockedReason('MODEL_ARMOR');

  const GenerateContentResponse_PromptFeedback_BlockedReason(super.value);

  factory GenerateContentResponse_PromptFeedback_BlockedReason.fromJson(
    String json,
  ) => GenerateContentResponse_PromptFeedback_BlockedReason(json);

  @override
  String toString() => 'BlockedReason.$value';
}

/// Usage metadata about response(s).
final class GenerateContentResponse_UsageMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateContentResponse.UsageMetadata';

  /// Number of tokens in the request. When `cached_content` is set, this is
  /// still the total effective prompt size meaning this includes the number of
  /// tokens in the cached content.
  final int? promptTokenCount;

  /// Number of tokens in the response(s).
  final int? candidatesTokenCount;

  /// Output only. Number of tokens present in thoughts output.
  final int? thoughtsTokenCount;

  /// Total token count for prompt and response candidates.
  final int? totalTokenCount;

  /// Output only. Number of tokens in the cached part in the input (the cached
  /// content).
  final int? cachedContentTokenCount;

  /// Output only. List of modalities that were processed in the request input.
  final List<ModalityTokenCount>? promptTokensDetails;

  /// Output only. List of modalities of the cached content in the request
  /// input.
  final List<ModalityTokenCount>? cacheTokensDetails;

  /// Output only. List of modalities that were returned in the response.
  final List<ModalityTokenCount>? candidatesTokensDetails;

  GenerateContentResponse_UsageMetadata({
    this.promptTokenCount,
    this.candidatesTokenCount,
    this.thoughtsTokenCount,
    this.totalTokenCount,
    this.cachedContentTokenCount,
    this.promptTokensDetails,
    this.cacheTokensDetails,
    this.candidatesTokensDetails,
  }) : super(fullyQualifiedName);

  factory GenerateContentResponse_UsageMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return GenerateContentResponse_UsageMetadata(
      promptTokenCount: json['promptTokenCount'],
      candidatesTokenCount: json['candidatesTokenCount'],
      thoughtsTokenCount: json['thoughtsTokenCount'],
      totalTokenCount: json['totalTokenCount'],
      cachedContentTokenCount: json['cachedContentTokenCount'],
      promptTokensDetails: decodeListMessage(
        json['promptTokensDetails'],
        ModalityTokenCount.fromJson,
      ),
      cacheTokensDetails: decodeListMessage(
        json['cacheTokensDetails'],
        ModalityTokenCount.fromJson,
      ),
      candidatesTokensDetails: decodeListMessage(
        json['candidatesTokensDetails'],
        ModalityTokenCount.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (promptTokenCount != null) 'promptTokenCount': promptTokenCount,
      if (candidatesTokenCount != null)
        'candidatesTokenCount': candidatesTokenCount,
      if (thoughtsTokenCount != null) 'thoughtsTokenCount': thoughtsTokenCount,
      if (totalTokenCount != null) 'totalTokenCount': totalTokenCount,
      if (cachedContentTokenCount != null)
        'cachedContentTokenCount': cachedContentTokenCount,
      if (promptTokensDetails != null)
        'promptTokensDetails': encodeList(promptTokensDetails),
      if (cacheTokensDetails != null)
        'cacheTokensDetails': encodeList(cacheTokensDetails),
      if (candidatesTokensDetails != null)
        'candidatesTokensDetails': encodeList(candidatesTokensDetails),
    };
  }

  @override
  String toString() {
    final contents = [
      if (promptTokenCount != null) 'promptTokenCount=$promptTokenCount',
      if (candidatesTokenCount != null)
        'candidatesTokenCount=$candidatesTokenCount',
      if (thoughtsTokenCount != null) 'thoughtsTokenCount=$thoughtsTokenCount',
      if (totalTokenCount != null) 'totalTokenCount=$totalTokenCount',
      if (cachedContentTokenCount != null)
        'cachedContentTokenCount=$cachedContentTokenCount',
    ].join(',');
    return 'UsageMetadata($contents)';
  }
}

/// Request message for [PredictionService.ChatCompletions]
final class ChatCompletionsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ChatCompletionsRequest';

  /// Required. The name of the endpoint requested to serve the prediction.
  /// Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String endpoint;

  /// Optional. The prediction input. Supports HTTP headers and arbitrary data
  /// payload.
  final HttpBody httpBody;

  ChatCompletionsRequest({required this.endpoint, required this.httpBody})
    : super(fullyQualifiedName);

  factory ChatCompletionsRequest.fromJson(Map<String, dynamic> json) {
    return ChatCompletionsRequest(
      endpoint: json['endpoint'],
      httpBody: decode(json['httpBody'], HttpBody.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'endpoint': endpoint, 'httpBody': httpBody.toJson()};
  }

  @override
  String toString() {
    final contents = ['endpoint=$endpoint'].join(',');
    return 'ChatCompletionsRequest($contents)';
  }
}

/// Response message for [PredictionService.PredictLongRunning]
final class PredictLongRunningResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictLongRunningResponse';

  /// The response of the video generation prediction.
  final GenerateVideoResponse? generateVideoResponse;

  PredictLongRunningResponse({this.generateVideoResponse})
    : super(fullyQualifiedName);

  factory PredictLongRunningResponse.fromJson(Map<String, dynamic> json) {
    return PredictLongRunningResponse(
      generateVideoResponse: decode(
        json['generateVideoResponse'],
        GenerateVideoResponse.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (generateVideoResponse != null)
        'generateVideoResponse': generateVideoResponse!.toJson(),
    };
  }

  @override
  String toString() => 'PredictLongRunningResponse()';
}

/// Metadata for PredictLongRunning long running operations.
final class PredictLongRunningMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredictLongRunningMetadata';

  PredictLongRunningMetadata() : super(fullyQualifiedName);

  factory PredictLongRunningMetadata.fromJson(Map<String, dynamic> json) {
    return PredictLongRunningMetadata();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'PredictLongRunningMetadata()';
}

/// Generate video response.
final class GenerateVideoResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GenerateVideoResponse';

  /// The cloud storage uris of the generated videos.
  final List<String>? generatedSamples;

  /// Returns if any videos were filtered due to RAI policies.
  final int? raiMediaFilteredCount;

  /// Returns rai failure reasons if any.
  final List<String>? raiMediaFilteredReasons;

  GenerateVideoResponse({
    this.generatedSamples,
    this.raiMediaFilteredCount,
    this.raiMediaFilteredReasons,
  }) : super(fullyQualifiedName);

  factory GenerateVideoResponse.fromJson(Map<String, dynamic> json) {
    return GenerateVideoResponse(
      generatedSamples: decodeList(json['generatedSamples']),
      raiMediaFilteredCount: json['raiMediaFilteredCount'],
      raiMediaFilteredReasons: decodeList(json['raiMediaFilteredReasons']),
    );
  }

  @override
  Object toJson() {
    return {
      if (generatedSamples != null) 'generatedSamples': generatedSamples,
      if (raiMediaFilteredCount != null)
        'raiMediaFilteredCount': raiMediaFilteredCount,
      if (raiMediaFilteredReasons != null)
        'raiMediaFilteredReasons': raiMediaFilteredReasons,
    };
  }

  @override
  String toString() {
    final contents = [
      if (raiMediaFilteredCount != null)
        'raiMediaFilteredCount=$raiMediaFilteredCount',
    ].join(',');
    return 'GenerateVideoResponse($contents)';
  }
}

/// A Model Garden Publisher Model.
final class PublisherModel extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel';

  /// Output only. The resource name of the PublisherModel.
  final String? name;

  /// Output only. Immutable. The version ID of the PublisherModel.
  /// A new version is committed when a new model version is uploaded under an
  /// existing model id. It is an auto-incrementing decimal number in string
  /// representation.
  final String? versionId;

  /// Required. Indicates the open source category of the publisher model.
  final PublisherModel_OpenSourceCategory? openSourceCategory;

  /// Optional. The parent that this model was customized from. E.g., Vision API,
  /// Natural Language API, LaMDA, T5, etc. Foundation models don't have parents.
  final PublisherModel_Parent? parent;

  /// Optional. Supported call-to-action options.
  final PublisherModel_CallToAction? supportedActions;

  /// Optional. Additional information about the model's Frameworks.
  final List<String>? frameworks;

  /// Optional. Indicates the launch stage of the model.
  final PublisherModel_LaunchStage? launchStage;

  /// Optional. Indicates the state of the model version.
  final PublisherModel_VersionState? versionState;

  /// Optional. Output only. Immutable. Used to indicate this model has a
  /// publisher model and provide the template of the publisher model resource
  /// name.
  final String? publisherModelTemplate;

  /// Optional. The schemata that describes formats of the PublisherModel's
  /// predictions and explanations as given and returned via
  /// `PredictionService.Predict`.
  final PredictSchemata? predictSchemata;

  PublisherModel({
    this.name,
    this.versionId,
    this.openSourceCategory,
    this.parent,
    this.supportedActions,
    this.frameworks,
    this.launchStage,
    this.versionState,
    this.publisherModelTemplate,
    this.predictSchemata,
  }) : super(fullyQualifiedName);

  factory PublisherModel.fromJson(Map<String, dynamic> json) {
    return PublisherModel(
      name: json['name'],
      versionId: json['versionId'],
      openSourceCategory: decodeEnum(
        json['openSourceCategory'],
        PublisherModel_OpenSourceCategory.fromJson,
      ),
      parent: decode(json['parent'], PublisherModel_Parent.fromJson),
      supportedActions: decode(
        json['supportedActions'],
        PublisherModel_CallToAction.fromJson,
      ),
      frameworks: decodeList(json['frameworks']),
      launchStage: decodeEnum(
        json['launchStage'],
        PublisherModel_LaunchStage.fromJson,
      ),
      versionState: decodeEnum(
        json['versionState'],
        PublisherModel_VersionState.fromJson,
      ),
      publisherModelTemplate: json['publisherModelTemplate'],
      predictSchemata: decode(
        json['predictSchemata'],
        PredictSchemata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (versionId != null) 'versionId': versionId,
      if (openSourceCategory != null)
        'openSourceCategory': openSourceCategory!.toJson(),
      if (parent != null) 'parent': parent!.toJson(),
      if (supportedActions != null)
        'supportedActions': supportedActions!.toJson(),
      if (frameworks != null) 'frameworks': frameworks,
      if (launchStage != null) 'launchStage': launchStage!.toJson(),
      if (versionState != null) 'versionState': versionState!.toJson(),
      if (publisherModelTemplate != null)
        'publisherModelTemplate': publisherModelTemplate,
      if (predictSchemata != null) 'predictSchemata': predictSchemata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (versionId != null) 'versionId=$versionId',
      if (openSourceCategory != null) 'openSourceCategory=$openSourceCategory',
      if (launchStage != null) 'launchStage=$launchStage',
      if (versionState != null) 'versionState=$versionState',
      if (publisherModelTemplate != null)
        'publisherModelTemplate=$publisherModelTemplate',
    ].join(',');
    return 'PublisherModel($contents)';
  }
}

/// Reference to a resource.
final class PublisherModel_ResourceReference extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.ResourceReference';

  /// The URI of the resource.
  final String? uri;

  /// The resource name of the Google Cloud resource.
  final String? resourceName;

  /// Use case (CUJ) of the resource.
  final String? useCase;

  /// Description of the resource.
  final String? description;

  PublisherModel_ResourceReference({
    this.uri,
    this.resourceName,
    this.useCase,
    this.description,
  }) : super(fullyQualifiedName);

  factory PublisherModel_ResourceReference.fromJson(Map<String, dynamic> json) {
    return PublisherModel_ResourceReference(
      uri: json['uri'],
      resourceName: json['resourceName'],
      useCase: json['useCase'],
      description: json['description'],
    );
  }

  @override
  Object toJson() {
    return {
      if (uri != null) 'uri': uri,
      if (resourceName != null) 'resourceName': resourceName,
      if (useCase != null) 'useCase': useCase,
      if (description != null) 'description': description,
    };
  }

  @override
  String toString() {
    final contents = [
      if (uri != null) 'uri=$uri',
      if (resourceName != null) 'resourceName=$resourceName',
      if (useCase != null) 'useCase=$useCase',
      if (description != null) 'description=$description',
    ].join(',');
    return 'ResourceReference($contents)';
  }
}

/// The information about the parent of a model.
final class PublisherModel_Parent extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.Parent';

  /// Required. The display name of the parent. E.g., LaMDA, T5, Vision API,
  /// Natural Language API.
  final String? displayName;

  /// Optional. The Google Cloud resource name or the URI reference.
  final PublisherModel_ResourceReference? reference;

  PublisherModel_Parent({this.displayName, this.reference})
    : super(fullyQualifiedName);

  factory PublisherModel_Parent.fromJson(Map<String, dynamic> json) {
    return PublisherModel_Parent(
      displayName: json['displayName'],
      reference: decode(
        json['reference'],
        PublisherModel_ResourceReference.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (displayName != null) 'displayName': displayName,
      if (reference != null) 'reference': reference!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (displayName != null) 'displayName=$displayName',
    ].join(',');
    return 'Parent($contents)';
  }
}

/// A named piece of documentation.
final class PublisherModel_Documentation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.Documentation';

  /// Required. E.g., OVERVIEW, USE CASES, DOCUMENTATION, SDK & SAMPLES, JAVA,
  /// NODE.JS, etc..
  final String? title;

  /// Required. Content of this piece of document (in Markdown format).
  final String? content;

  PublisherModel_Documentation({this.title, this.content})
    : super(fullyQualifiedName);

  factory PublisherModel_Documentation.fromJson(Map<String, dynamic> json) {
    return PublisherModel_Documentation(
      title: json['title'],
      content: json['content'],
    );
  }

  @override
  Object toJson() {
    return {
      if (title != null) 'title': title,
      if (content != null) 'content': content,
    };
  }

  @override
  String toString() {
    final contents = [
      if (title != null) 'title=$title',
      if (content != null) 'content=$content',
    ].join(',');
    return 'Documentation($contents)';
  }
}

/// Actions could take on this Publisher Model.
final class PublisherModel_CallToAction extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction';

  /// Optional. To view Rest API docs.
  final PublisherModel_CallToAction_ViewRestApi? viewRestApi;

  /// Optional. Open notebook of the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences? openNotebook;

  /// Optional. Open notebooks of the PublisherModel.
  final PublisherModel_CallToAction_OpenNotebooks? openNotebooks;

  /// Optional. Create application using the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  createApplication;

  /// Optional. Open fine-tuning pipeline of the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  openFineTuningPipeline;

  /// Optional. Open fine-tuning pipelines of the PublisherModel.
  final PublisherModel_CallToAction_OpenFineTuningPipelines?
  openFineTuningPipelines;

  /// Optional. Open prompt-tuning pipeline of the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  openPromptTuningPipeline;

  /// Optional. Open Genie / Playground.
  final PublisherModel_CallToAction_RegionalResourceReferences? openGenie;

  /// Optional. Deploy the PublisherModel to Vertex Endpoint.
  final PublisherModel_CallToAction_Deploy? deploy;

  /// Optional. Multiple setups to deploy the PublisherModel to Vertex
  /// Endpoint.
  final PublisherModel_CallToAction_DeployVertex? multiDeployVertex;

  /// Optional. Deploy PublisherModel to Google Kubernetes Engine.
  final PublisherModel_CallToAction_DeployGke? deployGke;

  /// Optional. Open in Generation AI Studio.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  openGenerationAiStudio;

  /// Optional. Request for access.
  final PublisherModel_CallToAction_RegionalResourceReferences? requestAccess;

  /// Optional. Open evaluation pipeline of the PublisherModel.
  final PublisherModel_CallToAction_RegionalResourceReferences?
  openEvaluationPipeline;

  PublisherModel_CallToAction({
    this.viewRestApi,
    this.openNotebook,
    this.openNotebooks,
    this.createApplication,
    this.openFineTuningPipeline,
    this.openFineTuningPipelines,
    this.openPromptTuningPipeline,
    this.openGenie,
    this.deploy,
    this.multiDeployVertex,
    this.deployGke,
    this.openGenerationAiStudio,
    this.requestAccess,
    this.openEvaluationPipeline,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction.fromJson(Map<String, dynamic> json) {
    return PublisherModel_CallToAction(
      viewRestApi: decode(
        json['viewRestApi'],
        PublisherModel_CallToAction_ViewRestApi.fromJson,
      ),
      openNotebook: decode(
        json['openNotebook'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
      openNotebooks: decode(
        json['openNotebooks'],
        PublisherModel_CallToAction_OpenNotebooks.fromJson,
      ),
      createApplication: decode(
        json['createApplication'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
      openFineTuningPipeline: decode(
        json['openFineTuningPipeline'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
      openFineTuningPipelines: decode(
        json['openFineTuningPipelines'],
        PublisherModel_CallToAction_OpenFineTuningPipelines.fromJson,
      ),
      openPromptTuningPipeline: decode(
        json['openPromptTuningPipeline'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
      openGenie: decode(
        json['openGenie'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
      deploy: decode(
        json['deploy'],
        PublisherModel_CallToAction_Deploy.fromJson,
      ),
      multiDeployVertex: decode(
        json['multiDeployVertex'],
        PublisherModel_CallToAction_DeployVertex.fromJson,
      ),
      deployGke: decode(
        json['deployGke'],
        PublisherModel_CallToAction_DeployGke.fromJson,
      ),
      openGenerationAiStudio: decode(
        json['openGenerationAiStudio'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
      requestAccess: decode(
        json['requestAccess'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
      openEvaluationPipeline: decode(
        json['openEvaluationPipeline'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (viewRestApi != null) 'viewRestApi': viewRestApi!.toJson(),
      if (openNotebook != null) 'openNotebook': openNotebook!.toJson(),
      if (openNotebooks != null) 'openNotebooks': openNotebooks!.toJson(),
      if (createApplication != null)
        'createApplication': createApplication!.toJson(),
      if (openFineTuningPipeline != null)
        'openFineTuningPipeline': openFineTuningPipeline!.toJson(),
      if (openFineTuningPipelines != null)
        'openFineTuningPipelines': openFineTuningPipelines!.toJson(),
      if (openPromptTuningPipeline != null)
        'openPromptTuningPipeline': openPromptTuningPipeline!.toJson(),
      if (openGenie != null) 'openGenie': openGenie!.toJson(),
      if (deploy != null) 'deploy': deploy!.toJson(),
      if (multiDeployVertex != null)
        'multiDeployVertex': multiDeployVertex!.toJson(),
      if (deployGke != null) 'deployGke': deployGke!.toJson(),
      if (openGenerationAiStudio != null)
        'openGenerationAiStudio': openGenerationAiStudio!.toJson(),
      if (requestAccess != null) 'requestAccess': requestAccess!.toJson(),
      if (openEvaluationPipeline != null)
        'openEvaluationPipeline': openEvaluationPipeline!.toJson(),
    };
  }

  @override
  String toString() => 'CallToAction()';
}

/// The regional resource name or the URI. Key is region, e.g.,
/// us-central1, europe-west2, global, etc..
final class PublisherModel_CallToAction_RegionalResourceReferences
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.RegionalResourceReferences';

  /// Required.
  final Map<String, PublisherModel_ResourceReference>? references;

  /// Required.
  final String? title;

  /// Optional. Title of the resource.
  final String? resourceTitle;

  /// Optional. Use case (CUJ) of the resource.
  final String? resourceUseCase;

  /// Optional. Description of the resource.
  final String? resourceDescription;

  PublisherModel_CallToAction_RegionalResourceReferences({
    this.references,
    this.title,
    this.resourceTitle,
    this.resourceUseCase,
    this.resourceDescription,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_RegionalResourceReferences.fromJson(
    Map<String, dynamic> json,
  ) {
    return PublisherModel_CallToAction_RegionalResourceReferences(
      references: decodeMapMessage(
        json['references'],
        PublisherModel_ResourceReference.fromJson,
      ),
      title: json['title'],
      resourceTitle: json['resourceTitle'],
      resourceUseCase: json['resourceUseCase'],
      resourceDescription: json['resourceDescription'],
    );
  }

  @override
  Object toJson() {
    return {
      if (references != null) 'references': encodeMap(references),
      if (title != null) 'title': title,
      if (resourceTitle != null) 'resourceTitle': resourceTitle,
      if (resourceUseCase != null) 'resourceUseCase': resourceUseCase,
      if (resourceDescription != null)
        'resourceDescription': resourceDescription,
    };
  }

  @override
  String toString() {
    final contents = [
      if (title != null) 'title=$title',
      if (resourceTitle != null) 'resourceTitle=$resourceTitle',
      if (resourceUseCase != null) 'resourceUseCase=$resourceUseCase',
      if (resourceDescription != null)
        'resourceDescription=$resourceDescription',
    ].join(',');
    return 'RegionalResourceReferences($contents)';
  }
}

/// Rest API docs.
final class PublisherModel_CallToAction_ViewRestApi
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.ViewRestApi';

  /// Required.
  final List<PublisherModel_Documentation>? documentations;

  /// Required. The title of the view rest API.
  final String? title;

  PublisherModel_CallToAction_ViewRestApi({this.documentations, this.title})
    : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_ViewRestApi.fromJson(
    Map<String, dynamic> json,
  ) {
    return PublisherModel_CallToAction_ViewRestApi(
      documentations: decodeListMessage(
        json['documentations'],
        PublisherModel_Documentation.fromJson,
      ),
      title: json['title'],
    );
  }

  @override
  Object toJson() {
    return {
      if (documentations != null) 'documentations': encodeList(documentations),
      if (title != null) 'title': title,
    };
  }

  @override
  String toString() {
    final contents = [if (title != null) 'title=$title'].join(',');
    return 'ViewRestApi($contents)';
  }
}

/// Open notebooks.
final class PublisherModel_CallToAction_OpenNotebooks
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.OpenNotebooks';

  /// Required. Regional resource references to notebooks.
  final List<PublisherModel_CallToAction_RegionalResourceReferences>? notebooks;

  PublisherModel_CallToAction_OpenNotebooks({this.notebooks})
    : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_OpenNotebooks.fromJson(
    Map<String, dynamic> json,
  ) {
    return PublisherModel_CallToAction_OpenNotebooks(
      notebooks: decodeListMessage(
        json['notebooks'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (notebooks != null) 'notebooks': encodeList(notebooks)};
  }

  @override
  String toString() => 'OpenNotebooks()';
}

/// Open fine tuning pipelines.
final class PublisherModel_CallToAction_OpenFineTuningPipelines
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.OpenFineTuningPipelines';

  /// Required. Regional resource references to fine tuning pipelines.
  final List<PublisherModel_CallToAction_RegionalResourceReferences>?
  fineTuningPipelines;

  PublisherModel_CallToAction_OpenFineTuningPipelines({
    this.fineTuningPipelines,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_OpenFineTuningPipelines.fromJson(
    Map<String, dynamic> json,
  ) {
    return PublisherModel_CallToAction_OpenFineTuningPipelines(
      fineTuningPipelines: decodeListMessage(
        json['fineTuningPipelines'],
        PublisherModel_CallToAction_RegionalResourceReferences.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (fineTuningPipelines != null)
        'fineTuningPipelines': encodeList(fineTuningPipelines),
    };
  }

  @override
  String toString() => 'OpenFineTuningPipelines()';
}

/// Multiple setups to deploy the PublisherModel.
final class PublisherModel_CallToAction_DeployVertex
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.DeployVertex';

  /// Optional. One click deployment configurations.
  final List<PublisherModel_CallToAction_Deploy>? multiDeployVertex;

  PublisherModel_CallToAction_DeployVertex({this.multiDeployVertex})
    : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_DeployVertex.fromJson(
    Map<String, dynamic> json,
  ) {
    return PublisherModel_CallToAction_DeployVertex(
      multiDeployVertex: decodeListMessage(
        json['multiDeployVertex'],
        PublisherModel_CallToAction_Deploy.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (multiDeployVertex != null)
        'multiDeployVertex': encodeList(multiDeployVertex),
    };
  }

  @override
  String toString() => 'DeployVertex()';
}

/// Model metadata that is needed for UploadModel or
/// DeployModel/CreateEndpoint requests.
final class PublisherModel_CallToAction_Deploy extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.Deploy';

  /// A description of resources that are dedicated to the DeployedModel,
  /// and that need a higher degree of manual configuration.
  final DedicatedResources? dedicatedResources;

  /// A description of resources that to large degree are decided by Vertex
  /// AI, and require only a modest additional configuration.
  final AutomaticResources? automaticResources;

  /// The resource name of the shared DeploymentResourcePool to deploy on.
  /// Format:
  /// `projects/{project}/locations/{location}/deploymentResourcePools/{deployment_resource_pool}`
  final String? sharedResources;

  /// Optional. Default model display name.
  final String? modelDisplayName;

  /// Optional. Large model reference. When this is set, model_artifact_spec
  /// is not needed.
  final LargeModelReference? largeModelReference;

  /// Optional. The specification of the container that is to be used when
  /// deploying this Model in Vertex AI. Not present for Large Models.
  final ModelContainerSpec? containerSpec;

  /// Optional. The path to the directory containing the Model artifact and
  /// any of its supporting files.
  final String? artifactUri;

  /// Optional. The name of the deploy task (e.g., "text to image
  /// generation").
  final String? deployTaskName;

  /// Optional. Metadata information about this deployment config.
  final PublisherModel_CallToAction_Deploy_DeployMetadata? deployMetadata;

  /// Required. The title of the regional resource reference.
  final String? title;

  /// Optional. The signed URI for ephemeral Cloud Storage access to model
  /// artifact.
  final String? publicArtifactUri;

  PublisherModel_CallToAction_Deploy({
    this.dedicatedResources,
    this.automaticResources,
    this.sharedResources,
    this.modelDisplayName,
    this.largeModelReference,
    this.containerSpec,
    this.artifactUri,
    this.deployTaskName,
    this.deployMetadata,
    this.title,
    this.publicArtifactUri,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_Deploy.fromJson(
    Map<String, dynamic> json,
  ) {
    return PublisherModel_CallToAction_Deploy(
      dedicatedResources: decode(
        json['dedicatedResources'],
        DedicatedResources.fromJson,
      ),
      automaticResources: decode(
        json['automaticResources'],
        AutomaticResources.fromJson,
      ),
      sharedResources: json['sharedResources'],
      modelDisplayName: json['modelDisplayName'],
      largeModelReference: decode(
        json['largeModelReference'],
        LargeModelReference.fromJson,
      ),
      containerSpec: decode(json['containerSpec'], ModelContainerSpec.fromJson),
      artifactUri: json['artifactUri'],
      deployTaskName: json['deployTaskName'],
      deployMetadata: decode(
        json['deployMetadata'],
        PublisherModel_CallToAction_Deploy_DeployMetadata.fromJson,
      ),
      title: json['title'],
      publicArtifactUri: json['publicArtifactUri'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dedicatedResources != null)
        'dedicatedResources': dedicatedResources!.toJson(),
      if (automaticResources != null)
        'automaticResources': automaticResources!.toJson(),
      if (sharedResources != null) 'sharedResources': sharedResources,
      if (modelDisplayName != null) 'modelDisplayName': modelDisplayName,
      if (largeModelReference != null)
        'largeModelReference': largeModelReference!.toJson(),
      if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
      if (artifactUri != null) 'artifactUri': artifactUri,
      if (deployTaskName != null) 'deployTaskName': deployTaskName,
      if (deployMetadata != null) 'deployMetadata': deployMetadata!.toJson(),
      if (title != null) 'title': title,
      if (publicArtifactUri != null) 'publicArtifactUri': publicArtifactUri,
    };
  }

  @override
  String toString() {
    final contents = [
      if (sharedResources != null) 'sharedResources=$sharedResources',
      if (modelDisplayName != null) 'modelDisplayName=$modelDisplayName',
      if (artifactUri != null) 'artifactUri=$artifactUri',
      if (deployTaskName != null) 'deployTaskName=$deployTaskName',
      if (title != null) 'title=$title',
      if (publicArtifactUri != null) 'publicArtifactUri=$publicArtifactUri',
    ].join(',');
    return 'Deploy($contents)';
  }
}

/// Metadata information about the deployment for managing deployment
/// config.
final class PublisherModel_CallToAction_Deploy_DeployMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.Deploy.DeployMetadata';

  /// Optional. Labels for the deployment config. For managing deployment
  /// config like verifying, source of deployment config, etc.
  final Map<String, String>? labels;

  /// Optional. Sample request for deployed endpoint.
  final String? sampleRequest;

  PublisherModel_CallToAction_Deploy_DeployMetadata({
    this.labels,
    this.sampleRequest,
  }) : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_Deploy_DeployMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return PublisherModel_CallToAction_Deploy_DeployMetadata(
      labels: decodeMap(json['labels']),
      sampleRequest: json['sampleRequest'],
    );
  }

  @override
  Object toJson() {
    return {
      if (labels != null) 'labels': labels,
      if (sampleRequest != null) 'sampleRequest': sampleRequest,
    };
  }

  @override
  String toString() {
    final contents = [
      if (sampleRequest != null) 'sampleRequest=$sampleRequest',
    ].join(',');
    return 'DeployMetadata($contents)';
  }
}

/// Configurations for PublisherModel GKE deployment
final class PublisherModel_CallToAction_DeployGke
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PublisherModel.CallToAction.DeployGke';

  /// Optional. GKE deployment configuration in yaml format.
  final List<String>? gkeYamlConfigs;

  PublisherModel_CallToAction_DeployGke({this.gkeYamlConfigs})
    : super(fullyQualifiedName);

  factory PublisherModel_CallToAction_DeployGke.fromJson(
    Map<String, dynamic> json,
  ) {
    return PublisherModel_CallToAction_DeployGke(
      gkeYamlConfigs: decodeList(json['gkeYamlConfigs']),
    );
  }

  @override
  Object toJson() {
    return {if (gkeYamlConfigs != null) 'gkeYamlConfigs': gkeYamlConfigs};
  }

  @override
  String toString() => 'DeployGke()';
}

/// An enum representing the open source category of a PublisherModel.
final class PublisherModel_OpenSourceCategory extends protobuf.ProtoEnum {
  /// The open source category is unspecified, which should not be used.
  static const openSourceCategoryUnspecified =
      PublisherModel_OpenSourceCategory('OPEN_SOURCE_CATEGORY_UNSPECIFIED');

  /// Used to indicate the PublisherModel is not open sourced.
  static const proprietary = PublisherModel_OpenSourceCategory('PROPRIETARY');

  /// Used to indicate the PublisherModel is a Google-owned open source model
  /// w/ Google checkpoint.
  static const googleOwnedOssWithGoogleCheckpoint =
      PublisherModel_OpenSourceCategory(
        'GOOGLE_OWNED_OSS_WITH_GOOGLE_CHECKPOINT',
      );

  /// Used to indicate the PublisherModel is a 3p-owned open source model w/
  /// Google checkpoint.
  static const thirdPartyOwnedOssWithGoogleCheckpoint =
      PublisherModel_OpenSourceCategory(
        'THIRD_PARTY_OWNED_OSS_WITH_GOOGLE_CHECKPOINT',
      );

  /// Used to indicate the PublisherModel is a Google-owned pure open source
  /// model.
  static const googleOwnedOss = PublisherModel_OpenSourceCategory(
    'GOOGLE_OWNED_OSS',
  );

  /// Used to indicate the PublisherModel is a 3p-owned pure open source model.
  static const thirdPartyOwnedOss = PublisherModel_OpenSourceCategory(
    'THIRD_PARTY_OWNED_OSS',
  );

  const PublisherModel_OpenSourceCategory(super.value);

  factory PublisherModel_OpenSourceCategory.fromJson(String json) =>
      PublisherModel_OpenSourceCategory(json);

  @override
  String toString() => 'OpenSourceCategory.$value';
}

/// An enum representing the launch stage of a PublisherModel.
final class PublisherModel_LaunchStage extends protobuf.ProtoEnum {
  /// The model launch stage is unspecified.
  static const launchStageUnspecified = PublisherModel_LaunchStage(
    'LAUNCH_STAGE_UNSPECIFIED',
  );

  /// Used to indicate the PublisherModel is at Experimental launch stage,
  /// available to a small set of customers.
  static const experimental = PublisherModel_LaunchStage('EXPERIMENTAL');

  /// Used to indicate the PublisherModel is at Private Preview launch stage,
  /// only available to a small set of customers, although a larger set of
  /// customers than an Experimental launch. Previews are the first launch
  /// stage used to get feedback from customers.
  static const privatePreview = PublisherModel_LaunchStage('PRIVATE_PREVIEW');

  /// Used to indicate the PublisherModel is at Public Preview launch stage,
  /// available to all customers, although not supported for production
  /// workloads.
  static const publicPreview = PublisherModel_LaunchStage('PUBLIC_PREVIEW');

  /// Used to indicate the PublisherModel is at GA launch stage, available to
  /// all customers and ready for production workload.
  static const ga = PublisherModel_LaunchStage('GA');

  const PublisherModel_LaunchStage(super.value);

  factory PublisherModel_LaunchStage.fromJson(String json) =>
      PublisherModel_LaunchStage(json);

  @override
  String toString() => 'LaunchStage.$value';
}

/// An enum representing the state of the PublicModelVersion.
final class PublisherModel_VersionState extends protobuf.ProtoEnum {
  /// The version state is unspecified.
  static const versionStateUnspecified = PublisherModel_VersionState(
    'VERSION_STATE_UNSPECIFIED',
  );

  /// Used to indicate the version is stable.
  static const versionStateStable = PublisherModel_VersionState(
    'VERSION_STATE_STABLE',
  );

  /// Used to indicate the version is unstable.
  static const versionStateUnstable = PublisherModel_VersionState(
    'VERSION_STATE_UNSTABLE',
  );

  const PublisherModel_VersionState(super.value);

  factory PublisherModel_VersionState.fromJson(String json) =>
      PublisherModel_VersionState(json);

  @override
  String toString() => 'VersionState.$value';
}

/// ReasoningEngine configurations
final class ReasoningEngineSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec';

  /// Deploy from source code files with a defined entrypoint.
  final ReasoningEngineSpec_SourceCodeSpec? sourceCodeSpec;

  /// Optional. The service account that the Reasoning Engine artifact runs as.
  /// It should have "roles/storage.objectViewer" for reading the user project's
  /// Cloud Storage and "roles/aiplatform.user" for using Vertex extensions. If
  /// not specified, the Vertex AI Reasoning Engine Service Agent in the project
  /// will be used.
  final String? serviceAccount;

  /// Optional. User provided package spec of the ReasoningEngine.
  /// Ignored when users directly specify a deployment image through
  /// `deployment_spec.first_party_image_override`, but keeping the
  /// field_behavior to avoid introducing breaking changes.
  /// The `deployment_source` field should not be set if `package_spec` is
  /// specified.
  final ReasoningEngineSpec_PackageSpec? packageSpec;

  /// Optional. The specification of a Reasoning Engine deployment.
  final ReasoningEngineSpec_DeploymentSpec? deploymentSpec;

  /// Optional. Declarations for object class methods in OpenAPI specification
  /// format.
  final List<protobuf.Struct>? classMethods;

  /// Optional. The OSS agent framework used to develop the agent.
  /// Currently supported values: "google-adk", "langchain", "langgraph", "ag2",
  /// "llama-index", "custom".
  final String? agentFramework;

  ReasoningEngineSpec({
    this.sourceCodeSpec,
    this.serviceAccount,
    this.packageSpec,
    this.deploymentSpec,
    this.classMethods,
    this.agentFramework,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineSpec.fromJson(Map<String, dynamic> json) {
    return ReasoningEngineSpec(
      sourceCodeSpec: decode(
        json['sourceCodeSpec'],
        ReasoningEngineSpec_SourceCodeSpec.fromJson,
      ),
      serviceAccount: json['serviceAccount'],
      packageSpec: decode(
        json['packageSpec'],
        ReasoningEngineSpec_PackageSpec.fromJson,
      ),
      deploymentSpec: decode(
        json['deploymentSpec'],
        ReasoningEngineSpec_DeploymentSpec.fromJson,
      ),
      classMethods: decodeListMessageCustom(
        json['classMethods'],
        protobuf.Struct.fromJson,
      ),
      agentFramework: json['agentFramework'],
    );
  }

  @override
  Object toJson() {
    return {
      if (sourceCodeSpec != null) 'sourceCodeSpec': sourceCodeSpec!.toJson(),
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (packageSpec != null) 'packageSpec': packageSpec!.toJson(),
      if (deploymentSpec != null) 'deploymentSpec': deploymentSpec!.toJson(),
      if (classMethods != null) 'classMethods': encodeList(classMethods),
      if (agentFramework != null) 'agentFramework': agentFramework,
    };
  }

  @override
  String toString() {
    final contents = [
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (agentFramework != null) 'agentFramework=$agentFramework',
    ].join(',');
    return 'ReasoningEngineSpec($contents)';
  }
}

/// User-provided package specification, containing pickled object and package
/// requirements.
final class ReasoningEngineSpec_PackageSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.PackageSpec';

  /// Optional. The Cloud Storage URI of the pickled python object.
  final String? pickleObjectGcsUri;

  /// Optional. The Cloud Storage URI of the dependency files in tar.gz format.
  final String? dependencyFilesGcsUri;

  /// Optional. The Cloud Storage URI of the `requirements.txt` file
  final String? requirementsGcsUri;

  /// Optional. The Python version. Currently support 3.8, 3.9, 3.10, 3.11.
  /// If not specified, default value is 3.10.
  final String? pythonVersion;

  ReasoningEngineSpec_PackageSpec({
    this.pickleObjectGcsUri,
    this.dependencyFilesGcsUri,
    this.requirementsGcsUri,
    this.pythonVersion,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineSpec_PackageSpec.fromJson(Map<String, dynamic> json) {
    return ReasoningEngineSpec_PackageSpec(
      pickleObjectGcsUri: json['pickleObjectGcsUri'],
      dependencyFilesGcsUri: json['dependencyFilesGcsUri'],
      requirementsGcsUri: json['requirementsGcsUri'],
      pythonVersion: json['pythonVersion'],
    );
  }

  @override
  Object toJson() {
    return {
      if (pickleObjectGcsUri != null) 'pickleObjectGcsUri': pickleObjectGcsUri,
      if (dependencyFilesGcsUri != null)
        'dependencyFilesGcsUri': dependencyFilesGcsUri,
      if (requirementsGcsUri != null) 'requirementsGcsUri': requirementsGcsUri,
      if (pythonVersion != null) 'pythonVersion': pythonVersion,
    };
  }

  @override
  String toString() {
    final contents = [
      if (pickleObjectGcsUri != null) 'pickleObjectGcsUri=$pickleObjectGcsUri',
      if (dependencyFilesGcsUri != null)
        'dependencyFilesGcsUri=$dependencyFilesGcsUri',
      if (requirementsGcsUri != null) 'requirementsGcsUri=$requirementsGcsUri',
      if (pythonVersion != null) 'pythonVersion=$pythonVersion',
    ].join(',');
    return 'PackageSpec($contents)';
  }
}

/// The specification of a Reasoning Engine deployment.
final class ReasoningEngineSpec_DeploymentSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.DeploymentSpec';

  /// Optional. Environment variables to be set with the Reasoning Engine
  /// deployment. The environment variables can be updated through the
  /// UpdateReasoningEngine API.
  final List<EnvVar>? env;

  /// Optional. Environment variables where the value is a secret in Cloud
  /// Secret Manager.
  /// To use this feature, add 'Secret Manager Secret Accessor' role
  /// (roles/secretmanager.secretAccessor) to AI Platform Reasoning Engine
  /// Service Agent.
  final List<SecretEnvVar>? secretEnv;

  /// Optional. Configuration for PSC-I.
  final PscInterfaceConfig? pscInterfaceConfig;

  /// Optional. The minimum number of application instances that will be kept
  /// running at all times. Defaults to 1. Range: [0, 10].
  final int? minInstances;

  /// Optional. The maximum number of application instances that can be
  /// launched to handle increased traffic. Defaults to 100. Range: [1, 1000].
  ///
  /// If VPC-SC or PSC-I is enabled, the acceptable range is [1, 100].
  final int? maxInstances;

  /// Optional. Resource limits for each container. Only 'cpu' and 'memory'
  /// keys are supported. Defaults to {"cpu": "4", "memory": "4Gi"}.
  ///
  ///   * The only supported values for CPU are '1', '2', '4', '6' and '8'. For
  ///   more information, go to
  ///   https://cloud.google.com/run/docs/configuring/cpu.
  ///   * The only supported values for memory are '1Gi', '2Gi', ... '32 Gi'.
  ///   * For required cpu on different memory values, go to
  ///   https://cloud.google.com/run/docs/configuring/memory-limits
  final Map<String, String>? resourceLimits;

  /// Optional. Concurrency for each container and agent server. Recommended
  /// value: 2 * cpu + 1. Defaults to 9.
  final int? containerConcurrency;

  ReasoningEngineSpec_DeploymentSpec({
    this.env,
    this.secretEnv,
    this.pscInterfaceConfig,
    this.minInstances,
    this.maxInstances,
    this.resourceLimits,
    this.containerConcurrency,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineSpec_DeploymentSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineSpec_DeploymentSpec(
      env: decodeListMessage(json['env'], EnvVar.fromJson),
      secretEnv: decodeListMessage(json['secretEnv'], SecretEnvVar.fromJson),
      pscInterfaceConfig: decode(
        json['pscInterfaceConfig'],
        PscInterfaceConfig.fromJson,
      ),
      minInstances: json['minInstances'],
      maxInstances: json['maxInstances'],
      resourceLimits: decodeMap(json['resourceLimits']),
      containerConcurrency: json['containerConcurrency'],
    );
  }

  @override
  Object toJson() {
    return {
      if (env != null) 'env': encodeList(env),
      if (secretEnv != null) 'secretEnv': encodeList(secretEnv),
      if (pscInterfaceConfig != null)
        'pscInterfaceConfig': pscInterfaceConfig!.toJson(),
      if (minInstances != null) 'minInstances': minInstances,
      if (maxInstances != null) 'maxInstances': maxInstances,
      if (resourceLimits != null) 'resourceLimits': resourceLimits,
      if (containerConcurrency != null)
        'containerConcurrency': containerConcurrency,
    };
  }

  @override
  String toString() {
    final contents = [
      if (minInstances != null) 'minInstances=$minInstances',
      if (maxInstances != null) 'maxInstances=$maxInstances',
      if (containerConcurrency != null)
        'containerConcurrency=$containerConcurrency',
    ].join(',');
    return 'DeploymentSpec($contents)';
  }
}

/// Specification for deploying from source code.
final class ReasoningEngineSpec_SourceCodeSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.SourceCodeSpec';

  /// Source code is provided directly in the request.
  final ReasoningEngineSpec_SourceCodeSpec_InlineSource? inlineSource;

  /// Configuration for a Python application.
  final ReasoningEngineSpec_SourceCodeSpec_PythonSpec? pythonSpec;

  ReasoningEngineSpec_SourceCodeSpec({this.inlineSource, this.pythonSpec})
    : super(fullyQualifiedName);

  factory ReasoningEngineSpec_SourceCodeSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineSpec_SourceCodeSpec(
      inlineSource: decode(
        json['inlineSource'],
        ReasoningEngineSpec_SourceCodeSpec_InlineSource.fromJson,
      ),
      pythonSpec: decode(
        json['pythonSpec'],
        ReasoningEngineSpec_SourceCodeSpec_PythonSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (inlineSource != null) 'inlineSource': inlineSource!.toJson(),
      if (pythonSpec != null) 'pythonSpec': pythonSpec!.toJson(),
    };
  }

  @override
  String toString() => 'SourceCodeSpec()';
}

/// Specifies source code provided as a byte stream.
final class ReasoningEngineSpec_SourceCodeSpec_InlineSource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.SourceCodeSpec.InlineSource';

  /// Required. Input only. The application source code archive, provided as
  /// a compressed tarball
  /// (.tar.gz) file.
  final Uint8List? sourceArchive;

  ReasoningEngineSpec_SourceCodeSpec_InlineSource({this.sourceArchive})
    : super(fullyQualifiedName);

  factory ReasoningEngineSpec_SourceCodeSpec_InlineSource.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineSpec_SourceCodeSpec_InlineSource(
      sourceArchive: decodeBytes(json['sourceArchive']),
    );
  }

  @override
  Object toJson() {
    return {
      if (sourceArchive != null) 'sourceArchive': encodeBytes(sourceArchive),
    };
  }

  @override
  String toString() {
    final contents = [
      if (sourceArchive != null) 'sourceArchive=$sourceArchive',
    ].join(',');
    return 'InlineSource($contents)';
  }
}

/// Specification for running a Python application from source.
final class ReasoningEngineSpec_SourceCodeSpec_PythonSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineSpec.SourceCodeSpec.PythonSpec';

  /// Optional. The version of Python to use. Support version
  /// includes 3.9, 3.10, 3.11, 3.12, 3.13.
  /// If not specified, default value is 3.10.
  final String? version;

  /// Optional. The Python module to load as the entrypoint, specified as a
  /// fully qualified module name. For example: path.to.agent.
  /// If not specified, defaults to "agent".
  ///
  /// The project root will be added to Python sys.path, allowing imports
  /// to be specified relative to the root.
  final String? entrypointModule;

  /// Optional. The name of the callable object within the
  /// `entrypoint_module` to use as the application If not specified,
  /// defaults to "root_agent".
  final String? entrypointObject;

  /// Optional. The path to the requirements file, relative to the source
  /// root. If not specified, defaults to "requirements.txt".
  final String? requirementsFile;

  ReasoningEngineSpec_SourceCodeSpec_PythonSpec({
    this.version,
    this.entrypointModule,
    this.entrypointObject,
    this.requirementsFile,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineSpec_SourceCodeSpec_PythonSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineSpec_SourceCodeSpec_PythonSpec(
      version: json['version'],
      entrypointModule: json['entrypointModule'],
      entrypointObject: json['entrypointObject'],
      requirementsFile: json['requirementsFile'],
    );
  }

  @override
  Object toJson() {
    return {
      if (version != null) 'version': version,
      if (entrypointModule != null) 'entrypointModule': entrypointModule,
      if (entrypointObject != null) 'entrypointObject': entrypointObject,
      if (requirementsFile != null) 'requirementsFile': requirementsFile,
    };
  }

  @override
  String toString() {
    final contents = [
      if (version != null) 'version=$version',
      if (entrypointModule != null) 'entrypointModule=$entrypointModule',
      if (entrypointObject != null) 'entrypointObject=$entrypointObject',
      if (requirementsFile != null) 'requirementsFile=$requirementsFile',
    ].join(',');
    return 'PythonSpec($contents)';
  }
}

/// ReasoningEngine provides a customizable runtime for models to determine
/// which actions to take and in which order.
final class ReasoningEngine extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngine';

  /// Identifier. The resource name of the ReasoningEngine.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String? name;

  /// Required. The display name of the ReasoningEngine.
  final String? displayName;

  /// Optional. The description of the ReasoningEngine.
  final String? description;

  /// Optional. Configurations of the ReasoningEngine
  final ReasoningEngineSpec? spec;

  /// Output only. Timestamp when this ReasoningEngine was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this ReasoningEngine was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. Used to perform consistent read-modify-write updates. If not set,
  /// a blind "overwrite" update happens.
  final String? etag;

  /// Optional. Configuration for how Agent Engine sub-resources should manage
  /// context.
  final ReasoningEngineContextSpec? contextSpec;

  /// Customer-managed encryption key spec for a ReasoningEngine. If set, this
  /// ReasoningEngine and all sub-resources of this ReasoningEngine will be
  /// secured by this key.
  final EncryptionSpec? encryptionSpec;

  /// Labels for the ReasoningEngine.
  final Map<String, String>? labels;

  ReasoningEngine({
    this.name,
    this.displayName,
    this.description,
    this.spec,
    this.createTime,
    this.updateTime,
    this.etag,
    this.contextSpec,
    this.encryptionSpec,
    this.labels,
  }) : super(fullyQualifiedName);

  factory ReasoningEngine.fromJson(Map<String, dynamic> json) {
    return ReasoningEngine(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      spec: decode(json['spec'], ReasoningEngineSpec.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      contextSpec: decode(
        json['contextSpec'],
        ReasoningEngineContextSpec.fromJson,
      ),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      labels: decodeMap(json['labels']),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (spec != null) 'spec': spec!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (contextSpec != null) 'contextSpec': contextSpec!.toJson(),
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (labels != null) 'labels': labels,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'ReasoningEngine($contents)';
  }
}

/// Configuration for how Agent Engine sub-resources should manage context.
final class ReasoningEngineContextSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec';

  /// Optional. Specification for a Memory Bank, which manages memories for the
  /// Agent Engine.
  final ReasoningEngineContextSpec_MemoryBankConfig? memoryBankConfig;

  ReasoningEngineContextSpec({this.memoryBankConfig})
    : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec.fromJson(Map<String, dynamic> json) {
    return ReasoningEngineContextSpec(
      memoryBankConfig: decode(
        json['memoryBankConfig'],
        ReasoningEngineContextSpec_MemoryBankConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (memoryBankConfig != null)
        'memoryBankConfig': memoryBankConfig!.toJson(),
    };
  }

  @override
  String toString() => 'ReasoningEngineContextSpec()';
}

/// Specification for a Memory Bank.
final class ReasoningEngineContextSpec_MemoryBankConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig';

  /// Optional. Configuration for how to generate memories for the Memory Bank.
  final ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig?
  generationConfig;

  /// Optional. Configuration for how to perform similarity search on memories.
  /// If not set, the Memory Bank will use the default embedding model
  /// `text-embedding-005`.
  final ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig?
  similaritySearchConfig;

  /// Optional. Configuration for automatic TTL ("time-to-live") of the
  /// memories in the Memory Bank. If not set, TTL will not be applied
  /// automatically. The TTL can be explicitly set by modifying the
  /// `expire_time` of each Memory resource.
  final ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig? ttlConfig;

  ReasoningEngineContextSpec_MemoryBankConfig({
    this.generationConfig,
    this.similaritySearchConfig,
    this.ttlConfig,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineContextSpec_MemoryBankConfig(
      generationConfig: decode(
        json['generationConfig'],
        ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig.fromJson,
      ),
      similaritySearchConfig: decode(
        json['similaritySearchConfig'],
        ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig
            .fromJson,
      ),
      ttlConfig: decode(
        json['ttlConfig'],
        ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (generationConfig != null)
        'generationConfig': generationConfig!.toJson(),
      if (similaritySearchConfig != null)
        'similaritySearchConfig': similaritySearchConfig!.toJson(),
      if (ttlConfig != null) 'ttlConfig': ttlConfig!.toJson(),
    };
  }

  @override
  String toString() => 'MemoryBankConfig()';
}

/// Configuration for automatically setting the TTL ("time-to-live") of the
/// memories in the Memory Bank.
final class ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig.TtlConfig';

  /// Optional. The default TTL duration of the memories in the Memory
  /// Bank. This applies to all operations that create or update a memory.
  final protobuf.Duration? defaultTtl;

  /// Optional. The granular TTL configuration of the memories in the
  /// Memory Bank.
  final ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig?
  granularTtlConfig;

  ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig({
    this.defaultTtl,
    this.granularTtlConfig,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig(
      defaultTtl: decodeCustom(json['defaultTtl'], protobuf.Duration.fromJson),
      granularTtlConfig: decode(
        json['granularTtlConfig'],
        ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig
            .fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (defaultTtl != null) 'defaultTtl': defaultTtl!.toJson(),
      if (granularTtlConfig != null)
        'granularTtlConfig': granularTtlConfig!.toJson(),
    };
  }

  @override
  String toString() => 'TtlConfig()';
}

/// Configuration for TTL of the memories in the Memory Bank based on the
/// action that created or updated the memory.
final class ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig.TtlConfig.GranularTtlConfig';

  /// Optional. The TTL duration for memories uploaded via CreateMemory.
  final protobuf.Duration? createTtl;

  /// Optional. The TTL duration for memories newly generated via
  /// GenerateMemories
  /// (`GenerateMemoriesResponse.GeneratedMemory.Action.CREATED`).
  final protobuf.Duration? generateCreatedTtl;

  /// Optional. The TTL duration for memories updated via GenerateMemories
  /// (`GenerateMemoriesResponse.GeneratedMemory.Action.CREATED`).
  /// In the case of an UPDATE action, the `expire_time` of the existing
  /// memory will be updated to the new value (now + TTL).
  final protobuf.Duration? generateUpdatedTtl;

  ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig({
    this.createTtl,
    this.generateCreatedTtl,
    this.generateUpdatedTtl,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineContextSpec_MemoryBankConfig_TtlConfig_GranularTtlConfig(
      createTtl: decodeCustom(json['createTtl'], protobuf.Duration.fromJson),
      generateCreatedTtl: decodeCustom(
        json['generateCreatedTtl'],
        protobuf.Duration.fromJson,
      ),
      generateUpdatedTtl: decodeCustom(
        json['generateUpdatedTtl'],
        protobuf.Duration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (createTtl != null) 'createTtl': createTtl!.toJson(),
      if (generateCreatedTtl != null)
        'generateCreatedTtl': generateCreatedTtl!.toJson(),
      if (generateUpdatedTtl != null)
        'generateUpdatedTtl': generateUpdatedTtl!.toJson(),
    };
  }

  @override
  String toString() => 'GranularTtlConfig()';
}

/// Configuration for how to generate memories.
final class ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig.GenerationConfig';

  /// Required. The model used to generate memories.
  /// Format:
  /// `projects/{project}/locations/{location}/publishers/google/models/{model}`.
  final String? model;

  ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig({this.model})
    : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineContextSpec_MemoryBankConfig_GenerationConfig(
      model: json['model'],
    );
  }

  @override
  Object toJson() {
    return {if (model != null) 'model': model};
  }

  @override
  String toString() {
    final contents = [if (model != null) 'model=$model'].join(',');
    return 'GenerationConfig($contents)';
  }
}

/// Configuration for how to perform similarity search on memories.
final class ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReasoningEngineContextSpec.MemoryBankConfig.SimilaritySearchConfig';

  /// Required. The model used to generate embeddings to lookup similar
  /// memories. Format:
  /// `projects/{project}/locations/{location}/publishers/google/models/{model}`.
  final String? embeddingModel;

  ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig({
    this.embeddingModel,
  }) : super(fullyQualifiedName);

  factory ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReasoningEngineContextSpec_MemoryBankConfig_SimilaritySearchConfig(
      embeddingModel: json['embeddingModel'],
    );
  }

  @override
  Object toJson() {
    return {if (embeddingModel != null) 'embeddingModel': embeddingModel};
  }

  @override
  String toString() {
    final contents = [
      if (embeddingModel != null) 'embeddingModel=$embeddingModel',
    ].join(',');
    return 'SimilaritySearchConfig($contents)';
  }
}

/// Request message for `ReasoningEngineExecutionService.Query`.
final class QueryReasoningEngineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryReasoningEngineRequest';

  /// Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  /// Optional. Input content provided by users in JSON object format. Examples
  /// include text query, function calling parameters, media bytes, etc.
  final protobuf.Struct? input;

  /// Optional. Class method to be used for the query.
  /// It is optional and defaults to "query" if unspecified.
  final String? classMethod;

  QueryReasoningEngineRequest({
    required this.name,
    this.input,
    this.classMethod,
  }) : super(fullyQualifiedName);

  factory QueryReasoningEngineRequest.fromJson(Map<String, dynamic> json) {
    return QueryReasoningEngineRequest(
      name: json['name'],
      input: decodeCustom(json['input'], protobuf.Struct.fromJson),
      classMethod: json['classMethod'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (input != null) 'input': input!.toJson(),
      if (classMethod != null) 'classMethod': classMethod,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (classMethod != null) 'classMethod=$classMethod',
    ].join(',');
    return 'QueryReasoningEngineRequest($contents)';
  }
}

/// Response message for `ReasoningEngineExecutionService.Query`
final class QueryReasoningEngineResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.QueryReasoningEngineResponse';

  /// Response provided by users in JSON object format.
  final protobuf.Value? output;

  QueryReasoningEngineResponse({this.output}) : super(fullyQualifiedName);

  factory QueryReasoningEngineResponse.fromJson(Map<String, dynamic> json) {
    return QueryReasoningEngineResponse(
      output: decodeCustom(json['output'], protobuf.Value.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (output != null) 'output': output!.toJson()};
  }

  @override
  String toString() => 'QueryReasoningEngineResponse()';
}

/// Request message for `ReasoningEngineExecutionService.StreamQuery`.
final class StreamQueryReasoningEngineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StreamQueryReasoningEngineRequest';

  /// Required. The name of the ReasoningEngine resource to use.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  /// Optional. Input content provided by users in JSON object format. Examples
  /// include text query, function calling parameters, media bytes, etc.
  final protobuf.Struct? input;

  /// Optional. Class method to be used for the stream query.
  /// It is optional and defaults to "stream_query" if unspecified.
  final String? classMethod;

  StreamQueryReasoningEngineRequest({
    required this.name,
    this.input,
    this.classMethod,
  }) : super(fullyQualifiedName);

  factory StreamQueryReasoningEngineRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return StreamQueryReasoningEngineRequest(
      name: json['name'],
      input: decodeCustom(json['input'], protobuf.Struct.fromJson),
      classMethod: json['classMethod'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (input != null) 'input': input!.toJson(),
      if (classMethod != null) 'classMethod': classMethod,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (classMethod != null) 'classMethod=$classMethod',
    ].join(',');
    return 'StreamQueryReasoningEngineRequest($contents)';
  }
}

/// Request message for
/// `ReasoningEngineService.CreateReasoningEngine`.
final class CreateReasoningEngineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateReasoningEngineRequest';

  /// Required. The resource name of the Location to create the ReasoningEngine
  /// in. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The ReasoningEngine to create.
  final ReasoningEngine reasoningEngine;

  CreateReasoningEngineRequest({
    required this.parent,
    required this.reasoningEngine,
  }) : super(fullyQualifiedName);

  factory CreateReasoningEngineRequest.fromJson(Map<String, dynamic> json) {
    return CreateReasoningEngineRequest(
      parent: json['parent'],
      reasoningEngine: decode(
        json['reasoningEngine'],
        ReasoningEngine.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'reasoningEngine': reasoningEngine.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateReasoningEngineRequest($contents)';
  }
}

/// Details of
/// `ReasoningEngineService.CreateReasoningEngine`
/// operation.
final class CreateReasoningEngineOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateReasoningEngineOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateReasoningEngineOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateReasoningEngineOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateReasoningEngineOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateReasoningEngineOperationMetadata()';
}

/// Request message for
/// `ReasoningEngineService.GetReasoningEngine`.
final class GetReasoningEngineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetReasoningEngineRequest';

  /// Required. The name of the ReasoningEngine resource.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  GetReasoningEngineRequest({required this.name}) : super(fullyQualifiedName);

  factory GetReasoningEngineRequest.fromJson(Map<String, dynamic> json) {
    return GetReasoningEngineRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetReasoningEngineRequest($contents)';
  }
}

/// Request message for
/// `ReasoningEngineService.UpdateReasoningEngine`.
final class UpdateReasoningEngineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateReasoningEngineRequest';

  /// Required. The ReasoningEngine which replaces the resource on the server.
  final ReasoningEngine reasoningEngine;

  /// Optional. Mask specifying which fields to update.
  final protobuf.FieldMask? updateMask;

  UpdateReasoningEngineRequest({required this.reasoningEngine, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateReasoningEngineRequest.fromJson(Map<String, dynamic> json) {
    return UpdateReasoningEngineRequest(
      reasoningEngine: decode(
        json['reasoningEngine'],
        ReasoningEngine.fromJson,
      )!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'reasoningEngine': reasoningEngine.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateReasoningEngineRequest()';
}

/// Details of
/// `ReasoningEngineService.UpdateReasoningEngine`
/// operation.
final class UpdateReasoningEngineOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateReasoningEngineOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  UpdateReasoningEngineOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateReasoningEngineOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateReasoningEngineOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateReasoningEngineOperationMetadata()';
}

/// Request message for
/// `ReasoningEngineService.ListReasoningEngines`.
final class ListReasoningEnginesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListReasoningEnginesRequest';

  /// Required. The resource name of the Location to list the ReasoningEngines
  /// from. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list filter.
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String? filter;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  final String? pageToken;

  ListReasoningEnginesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
  }) : super(fullyQualifiedName);

  factory ListReasoningEnginesRequest.fromJson(Map<String, dynamic> json) {
    return ListReasoningEnginesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListReasoningEnginesRequest($contents)';
  }
}

/// Response message for
/// `ReasoningEngineService.ListReasoningEngines`
final class ListReasoningEnginesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListReasoningEnginesResponse';

  /// List of ReasoningEngines in the requested page.
  final List<ReasoningEngine>? reasoningEngines;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListReasoningEnginesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListReasoningEnginesResponse({this.reasoningEngines, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListReasoningEnginesResponse.fromJson(Map<String, dynamic> json) {
    return ListReasoningEnginesResponse(
      reasoningEngines: decodeListMessage(
        json['reasoningEngines'],
        ReasoningEngine.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (reasoningEngines != null)
        'reasoningEngines': encodeList(reasoningEngines),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListReasoningEnginesResponse($contents)';
  }
}

/// Request message for
/// `ReasoningEngineService.DeleteReasoningEngine`.
final class DeleteReasoningEngineRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteReasoningEngineRequest';

  /// Required. The name of the ReasoningEngine resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String name;

  /// Optional. If set to true, child resources of this reasoning engine will
  /// also be deleted. Otherwise, the request will fail with FAILED_PRECONDITION
  /// error when the reasoning engine has undeleted child resources.
  final bool? force;

  DeleteReasoningEngineRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteReasoningEngineRequest.fromJson(Map<String, dynamic> json) {
    return DeleteReasoningEngineRequest(
      name: json['name'],
      force: json['force'],
    );
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteReasoningEngineRequest($contents)';
  }
}

/// A ReservationAffinity can be used to configure a Vertex AI resource (e.g., a
/// DeployedModel) to draw its Compute Engine resources from a Shared
/// Reservation, or exclusively from on-demand capacity.
final class ReservationAffinity extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReservationAffinity';

  /// Required. Specifies the reservation affinity type.
  final ReservationAffinity_Type? reservationAffinityType;

  /// Optional. Corresponds to the label key of a reservation resource. To target
  /// a SPECIFIC_RESERVATION by name, use
  /// `compute.googleapis.com/reservation-name` as the key and specify the name
  /// of your reservation as its value.
  final String? key;

  /// Optional. Corresponds to the label values of a reservation resource. This
  /// must be the full resource name of the reservation.
  final List<String>? values;

  ReservationAffinity({this.reservationAffinityType, this.key, this.values})
    : super(fullyQualifiedName);

  factory ReservationAffinity.fromJson(Map<String, dynamic> json) {
    return ReservationAffinity(
      reservationAffinityType: decodeEnum(
        json['reservationAffinityType'],
        ReservationAffinity_Type.fromJson,
      ),
      key: json['key'],
      values: decodeList(json['values']),
    );
  }

  @override
  Object toJson() {
    return {
      if (reservationAffinityType != null)
        'reservationAffinityType': reservationAffinityType!.toJson(),
      if (key != null) 'key': key,
      if (values != null) 'values': values,
    };
  }

  @override
  String toString() {
    final contents = [
      if (reservationAffinityType != null)
        'reservationAffinityType=$reservationAffinityType',
      if (key != null) 'key=$key',
    ].join(',');
    return 'ReservationAffinity($contents)';
  }
}

/// Identifies a type of reservation affinity.
final class ReservationAffinity_Type extends protobuf.ProtoEnum {
  /// Default value. This should not be used.
  static const typeUnspecified = ReservationAffinity_Type('TYPE_UNSPECIFIED');

  /// Do not consume from any reserved capacity, only use on-demand.
  static const noReservation = ReservationAffinity_Type('NO_RESERVATION');

  /// Consume any reservation available, falling back to on-demand.
  static const anyReservation = ReservationAffinity_Type('ANY_RESERVATION');

  /// Consume from a specific reservation. When chosen, the reservation
  /// must be identified via the `key` and `values` fields.
  static const specificReservation = ReservationAffinity_Type(
    'SPECIFIC_RESERVATION',
  );

  const ReservationAffinity_Type(super.value);

  factory ReservationAffinity_Type.fromJson(String json) =>
      ReservationAffinity_Type(json);

  @override
  String toString() => 'Type.$value';
}

/// A SavedQuery is a view of the dataset. It references a subset of annotations
/// by problem type and filters.
final class SavedQuery extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SavedQuery';

  /// Output only. Resource name of the SavedQuery.
  final String? name;

  /// Required. The user-defined name of the SavedQuery.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Some additional information about the SavedQuery.
  final protobuf.Value? metadata;

  /// Output only. Timestamp when this SavedQuery was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when SavedQuery was last updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Filters on the Annotations in the dataset.
  final String? annotationFilter;

  /// Required. Problem type of the SavedQuery.
  /// Allowed values:
  ///
  /// * IMAGE_CLASSIFICATION_SINGLE_LABEL
  /// * IMAGE_CLASSIFICATION_MULTI_LABEL
  /// * IMAGE_BOUNDING_POLY
  /// * IMAGE_BOUNDING_BOX
  /// * TEXT_CLASSIFICATION_SINGLE_LABEL
  /// * TEXT_CLASSIFICATION_MULTI_LABEL
  /// * TEXT_EXTRACTION
  /// * TEXT_SENTIMENT
  /// * VIDEO_CLASSIFICATION
  /// * VIDEO_OBJECT_TRACKING
  final String? problemType;

  /// Output only. Number of AnnotationSpecs in the context of the SavedQuery.
  final int? annotationSpecCount;

  /// Used to perform a consistent read-modify-write update. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// Output only. If the Annotations belonging to the SavedQuery can be used for
  /// AutoML training.
  final bool? supportAutomlTraining;

  SavedQuery({
    this.name,
    this.displayName,
    this.metadata,
    this.createTime,
    this.updateTime,
    this.annotationFilter,
    this.problemType,
    this.annotationSpecCount,
    this.etag,
    this.supportAutomlTraining,
  }) : super(fullyQualifiedName);

  factory SavedQuery.fromJson(Map<String, dynamic> json) {
    return SavedQuery(
      name: json['name'],
      displayName: json['displayName'],
      metadata: decodeCustom(json['metadata'], protobuf.Value.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      annotationFilter: json['annotationFilter'],
      problemType: json['problemType'],
      annotationSpecCount: json['annotationSpecCount'],
      etag: json['etag'],
      supportAutomlTraining: json['supportAutomlTraining'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (metadata != null) 'metadata': metadata!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (annotationFilter != null) 'annotationFilter': annotationFilter,
      if (problemType != null) 'problemType': problemType,
      if (annotationSpecCount != null)
        'annotationSpecCount': annotationSpecCount,
      if (etag != null) 'etag': etag,
      if (supportAutomlTraining != null)
        'supportAutomlTraining': supportAutomlTraining,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (annotationFilter != null) 'annotationFilter=$annotationFilter',
      if (problemType != null) 'problemType=$problemType',
      if (annotationSpecCount != null)
        'annotationSpecCount=$annotationSpecCount',
      if (etag != null) 'etag=$etag',
      if (supportAutomlTraining != null)
        'supportAutomlTraining=$supportAutomlTraining',
    ].join(',');
    return 'SavedQuery($contents)';
  }
}

/// An instance of a Schedule periodically schedules runs to make API calls based
/// on user specified time specification and API request type.
final class Schedule extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Schedule';

  /// Cron schedule (https://en.wikipedia.org/wiki/Cron) to launch scheduled
  /// runs. To explicitly set a timezone to the cron tab, apply a prefix in the
  /// cron tab: "CRON_TZ=${IANA_TIME_ZONE}" or "TZ=${IANA_TIME_ZONE}".
  /// The ${IANA_TIME_ZONE} may only be a valid string from IANA time zone
  /// database. For example, "CRON_TZ=America/New_York 1 * * * *", or
  /// "TZ=America/New_York 1 * * * *".
  final String? cron;

  /// Request for
  /// `PipelineService.CreatePipelineJob`.
  /// CreatePipelineJobRequest.parent field is required (format:
  /// projects/{project}/locations/{location}).
  final CreatePipelineJobRequest? createPipelineJobRequest;

  /// Request for
  /// `ModelMonitoringService.CreateModelMonitoringJob`.
  final CreateModelMonitoringJobRequest? createModelMonitoringJobRequest;

  /// Request for
  /// `NotebookService.CreateNotebookExecutionJob`.
  final CreateNotebookExecutionJobRequest? createNotebookExecutionJobRequest;

  /// Immutable. The resource name of the Schedule.
  final String? name;

  /// Required. User provided name of the Schedule.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Optional. Timestamp after which the first run can be scheduled.
  /// Default to Schedule create time if not specified.
  final protobuf.Timestamp? startTime;

  /// Optional. Timestamp after which no new runs can be scheduled.
  /// If specified, The schedule will be completed when either
  /// end_time is reached or when scheduled_run_count >= max_run_count.
  /// If not specified, new runs will keep getting scheduled until this Schedule
  /// is paused or deleted. Already scheduled runs will be allowed to complete.
  /// Unset if not specified.
  final protobuf.Timestamp? endTime;

  /// Optional. Maximum run count of the schedule.
  /// If specified, The schedule will be completed when either
  /// started_run_count >= max_run_count or when end_time is reached.
  /// If not specified, new runs will keep getting scheduled until this Schedule
  /// is paused or deleted. Already scheduled runs will be allowed to complete.
  /// Unset if not specified.
  final int? maxRunCount;

  /// Output only. The number of runs started by this schedule.
  final int? startedRunCount;

  /// Output only. The state of this Schedule.
  final Schedule_State? state;

  /// Output only. Timestamp when this Schedule was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Schedule was updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Timestamp when this Schedule should schedule the next run.
  /// Having a next_run_time in the past means the runs are being started
  /// behind schedule.
  final protobuf.Timestamp? nextRunTime;

  /// Output only. Timestamp when this Schedule was last paused.
  /// Unset if never paused.
  final protobuf.Timestamp? lastPauseTime;

  /// Output only. Timestamp when this Schedule was last resumed.
  /// Unset if never resumed from pause.
  final protobuf.Timestamp? lastResumeTime;

  /// Required. Maximum number of runs that can be started concurrently for this
  /// Schedule. This is the limit for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  final int? maxConcurrentRunCount;

  /// Optional. Whether new scheduled runs can be queued when max_concurrent_runs
  /// limit is reached. If set to true, new runs will be queued instead of
  /// skipped. Default to false.
  final bool? allowQueueing;

  /// Output only. Whether to backfill missed runs when the schedule is resumed
  /// from PAUSED state. If set to true, all missed runs will be scheduled. New
  /// runs will be scheduled after the backfill is complete. Default to false.
  final bool? catchUp;

  /// Output only. Response of the last scheduled run.
  /// This is the response for starting the scheduled requests and not the
  /// execution of the operations/jobs created by the requests (if applicable).
  /// Unset if no run has been scheduled yet.
  final Schedule_RunResponse? lastScheduledRunResponse;

  Schedule({
    this.cron,
    this.createPipelineJobRequest,
    this.createModelMonitoringJobRequest,
    this.createNotebookExecutionJobRequest,
    this.name,
    this.displayName,
    this.startTime,
    this.endTime,
    this.maxRunCount,
    this.startedRunCount,
    this.state,
    this.createTime,
    this.updateTime,
    this.nextRunTime,
    this.lastPauseTime,
    this.lastResumeTime,
    this.maxConcurrentRunCount,
    this.allowQueueing,
    this.catchUp,
    this.lastScheduledRunResponse,
  }) : super(fullyQualifiedName);

  factory Schedule.fromJson(Map<String, dynamic> json) {
    return Schedule(
      cron: json['cron'],
      createPipelineJobRequest: decode(
        json['createPipelineJobRequest'],
        CreatePipelineJobRequest.fromJson,
      ),
      createModelMonitoringJobRequest: decode(
        json['createModelMonitoringJobRequest'],
        CreateModelMonitoringJobRequest.fromJson,
      ),
      createNotebookExecutionJobRequest: decode(
        json['createNotebookExecutionJobRequest'],
        CreateNotebookExecutionJobRequest.fromJson,
      ),
      name: json['name'],
      displayName: json['displayName'],
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      maxRunCount: decodeInt64(json['maxRunCount']),
      startedRunCount: decodeInt64(json['startedRunCount']),
      state: decodeEnum(json['state'], Schedule_State.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      nextRunTime: decodeCustom(
        json['nextRunTime'],
        protobuf.Timestamp.fromJson,
      ),
      lastPauseTime: decodeCustom(
        json['lastPauseTime'],
        protobuf.Timestamp.fromJson,
      ),
      lastResumeTime: decodeCustom(
        json['lastResumeTime'],
        protobuf.Timestamp.fromJson,
      ),
      maxConcurrentRunCount: decodeInt64(json['maxConcurrentRunCount']),
      allowQueueing: json['allowQueueing'],
      catchUp: json['catchUp'],
      lastScheduledRunResponse: decode(
        json['lastScheduledRunResponse'],
        Schedule_RunResponse.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (cron != null) 'cron': cron,
      if (createPipelineJobRequest != null)
        'createPipelineJobRequest': createPipelineJobRequest!.toJson(),
      if (createModelMonitoringJobRequest != null)
        'createModelMonitoringJobRequest': createModelMonitoringJobRequest!
            .toJson(),
      if (createNotebookExecutionJobRequest != null)
        'createNotebookExecutionJobRequest': createNotebookExecutionJobRequest!
            .toJson(),
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (maxRunCount != null) 'maxRunCount': encodeInt64(maxRunCount),
      if (startedRunCount != null)
        'startedRunCount': encodeInt64(startedRunCount),
      if (state != null) 'state': state!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (nextRunTime != null) 'nextRunTime': nextRunTime!.toJson(),
      if (lastPauseTime != null) 'lastPauseTime': lastPauseTime!.toJson(),
      if (lastResumeTime != null) 'lastResumeTime': lastResumeTime!.toJson(),
      if (maxConcurrentRunCount != null)
        'maxConcurrentRunCount': encodeInt64(maxConcurrentRunCount),
      if (allowQueueing != null) 'allowQueueing': allowQueueing,
      if (catchUp != null) 'catchUp': catchUp,
      if (lastScheduledRunResponse != null)
        'lastScheduledRunResponse': lastScheduledRunResponse!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (cron != null) 'cron=$cron',
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (maxRunCount != null) 'maxRunCount=$maxRunCount',
      if (startedRunCount != null) 'startedRunCount=$startedRunCount',
      if (state != null) 'state=$state',
      if (maxConcurrentRunCount != null)
        'maxConcurrentRunCount=$maxConcurrentRunCount',
      if (allowQueueing != null) 'allowQueueing=$allowQueueing',
      if (catchUp != null) 'catchUp=$catchUp',
    ].join(',');
    return 'Schedule($contents)';
  }
}

/// Status of a scheduled run.
final class Schedule_RunResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Schedule.RunResponse';

  /// The scheduled run time based on the user-specified schedule.
  final protobuf.Timestamp? scheduledRunTime;

  /// The response of the scheduled run.
  final String? runResponse;

  Schedule_RunResponse({this.scheduledRunTime, this.runResponse})
    : super(fullyQualifiedName);

  factory Schedule_RunResponse.fromJson(Map<String, dynamic> json) {
    return Schedule_RunResponse(
      scheduledRunTime: decodeCustom(
        json['scheduledRunTime'],
        protobuf.Timestamp.fromJson,
      ),
      runResponse: json['runResponse'],
    );
  }

  @override
  Object toJson() {
    return {
      if (scheduledRunTime != null)
        'scheduledRunTime': scheduledRunTime!.toJson(),
      if (runResponse != null) 'runResponse': runResponse,
    };
  }

  @override
  String toString() {
    final contents = [
      if (runResponse != null) 'runResponse=$runResponse',
    ].join(',');
    return 'RunResponse($contents)';
  }
}

/// Possible state of the schedule.
final class Schedule_State extends protobuf.ProtoEnum {
  /// Unspecified.
  static const stateUnspecified = Schedule_State('STATE_UNSPECIFIED');

  /// The Schedule is active. Runs are being scheduled on the user-specified
  /// timespec.
  static const active = Schedule_State('ACTIVE');

  /// The schedule is paused. No new runs will be created until the schedule
  /// is resumed. Already started runs will be allowed to complete.
  static const paused = Schedule_State('PAUSED');

  /// The Schedule is completed. No new runs will be scheduled. Already started
  /// runs will be allowed to complete. Schedules in completed state cannot be
  /// paused or resumed.
  static const completed = Schedule_State('COMPLETED');

  const Schedule_State(super.value);

  factory Schedule_State.fromJson(String json) => Schedule_State(json);

  @override
  String toString() => 'State.$value';
}

/// Request message for
/// `ScheduleService.CreateSchedule`.
final class CreateScheduleRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateScheduleRequest';

  /// Required. The resource name of the Location to create the Schedule in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Schedule to create.
  final Schedule schedule;

  CreateScheduleRequest({required this.parent, required this.schedule})
    : super(fullyQualifiedName);

  factory CreateScheduleRequest.fromJson(Map<String, dynamic> json) {
    return CreateScheduleRequest(
      parent: json['parent'],
      schedule: decode(json['schedule'], Schedule.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'schedule': schedule.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.GetSchedule`.
final class GetScheduleRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetScheduleRequest';

  /// Required. The name of the Schedule resource.
  /// Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  final String name;

  GetScheduleRequest({required this.name}) : super(fullyQualifiedName);

  factory GetScheduleRequest.fromJson(Map<String, dynamic> json) {
    return GetScheduleRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.ListSchedules`.
final class ListSchedulesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSchedulesRequest';

  /// Required. The resource name of the Location to list the Schedules from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the Schedules that match the filter expression. The following
  /// fields are supported:
  ///
  /// * `display_name`: Supports `=`, `!=` comparisons, and `:` wildcard.
  /// * `state`: Supports `=` and `!=` comparisons.
  /// * `request`: Supports existence of the <request_type> check.
  ///       (e.g. `create_pipeline_job_request:*` --> Schedule has
  ///       create_pipeline_job_request).
  /// * `create_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///       Values must be in RFC 3339 format.
  /// * `start_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=` comparisons.
  ///       Values must be in RFC 3339 format.
  /// * `end_time`: Supports `=`, `!=`, `<`, `>`, `<=`, `>=` comparisons and `:*`
  ///       existence check. Values must be in RFC 3339 format.
  /// * `next_run_time`: Supports `=`, `!=`, `<`, `>`, `<=`, and `>=`
  ///       comparisons. Values must be in RFC 3339 format.
  ///
  ///
  /// Filter expressions can be combined together using logical operators
  /// (`NOT`, `AND` & `OR`).
  /// The syntax to define filter expression is based on
  /// https://google.aip.dev/160.
  ///
  /// Examples:
  ///
  /// * `state="ACTIVE" AND display_name:"my_schedule_*"`
  /// * `NOT display_name="my_schedule"`
  /// * `create_time>"2021-05-18T00:00:00Z"`
  /// * `end_time>"2021-05-18T00:00:00Z" OR NOT end_time:*`
  /// * `create_pipeline_job_request:*`
  final String? filter;

  /// The standard list page size.
  /// Default to 100 if not specified.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained via
  /// `ListSchedulesResponse.next_page_token`
  /// of the previous
  /// `ScheduleService.ListSchedules`
  /// call.
  final String? pageToken;

  /// A comma-separated list of fields to order by. The default sort order is in
  /// ascending order. Use "desc" after a field name for descending. You can have
  /// multiple order_by fields provided.
  ///
  /// For example, using "create_time desc, end_time" will order results by
  /// create time in descending order, and if there are multiple schedules having
  /// the same create time, order them by the end time in ascending order.
  ///
  /// If order_by is not specified, it will order by default with create_time in
  /// descending order.
  ///
  /// Supported fields:
  ///
  ///   * `create_time`
  ///   * `start_time`
  ///   * `end_time`
  ///   * `next_run_time`
  final String? orderBy;

  ListSchedulesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListSchedulesRequest.fromJson(Map<String, dynamic> json) {
    return ListSchedulesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListSchedulesRequest($contents)';
  }
}

/// Response message for
/// `ScheduleService.ListSchedules`
final class ListSchedulesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSchedulesResponse';

  /// List of Schedules in the requested page.
  final List<Schedule>? schedules;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListSchedulesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListSchedulesResponse({this.schedules, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListSchedulesResponse.fromJson(Map<String, dynamic> json) {
    return ListSchedulesResponse(
      schedules: decodeListMessage(json['schedules'], Schedule.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (schedules != null) 'schedules': encodeList(schedules),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListSchedulesResponse($contents)';
  }
}

/// Request message for
/// `ScheduleService.DeleteSchedule`.
final class DeleteScheduleRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteScheduleRequest';

  /// Required. The name of the Schedule resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  final String name;

  DeleteScheduleRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteScheduleRequest.fromJson(Map<String, dynamic> json) {
    return DeleteScheduleRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.PauseSchedule`.
final class PauseScheduleRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PauseScheduleRequest';

  /// Required. The name of the Schedule resource to be paused.
  /// Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  final String name;

  PauseScheduleRequest({required this.name}) : super(fullyQualifiedName);

  factory PauseScheduleRequest.fromJson(Map<String, dynamic> json) {
    return PauseScheduleRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'PauseScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.ResumeSchedule`.
final class ResumeScheduleRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ResumeScheduleRequest';

  /// Required. The name of the Schedule resource to be resumed.
  /// Format:
  /// `projects/{project}/locations/{location}/schedules/{schedule}`
  final String name;

  /// Optional. Whether to backfill missed runs when the schedule is resumed from
  /// PAUSED state. If set to true, all missed runs will be scheduled. New runs
  /// will be scheduled after the backfill is complete. This will also update
  /// `Schedule.catch_up`
  /// field. Default to false.
  final bool? catchUp;

  ResumeScheduleRequest({required this.name, this.catchUp})
    : super(fullyQualifiedName);

  factory ResumeScheduleRequest.fromJson(Map<String, dynamic> json) {
    return ResumeScheduleRequest(name: json['name'], catchUp: json['catchUp']);
  }

  @override
  Object toJson() {
    return {'name': name, if (catchUp != null) 'catchUp': catchUp};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (catchUp != null) 'catchUp=$catchUp',
    ].join(',');
    return 'ResumeScheduleRequest($contents)';
  }
}

/// Request message for
/// `ScheduleService.UpdateSchedule`.
final class UpdateScheduleRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateScheduleRequest';

  /// Required. The Schedule which replaces the resource on the server.
  /// The following restrictions will be applied:
  ///
  ///   * The scheduled request type cannot be changed.
  ///   * The non-empty fields cannot be unset.
  ///   * The output_only fields will be ignored if specified.
  final Schedule schedule;

  /// Required. The update mask applies to the resource. See
  /// `google.protobuf.FieldMask`.
  final protobuf.FieldMask? updateMask;

  UpdateScheduleRequest({required this.schedule, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateScheduleRequest.fromJson(Map<String, dynamic> json) {
    return UpdateScheduleRequest(
      schedule: decode(json['schedule'], Schedule.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'schedule': schedule.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateScheduleRequest()';
}

/// PSC config that is used to automatically create PSC endpoints in the user
/// projects.
final class PscautomationConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PSCAutomationConfig';

  /// Required. Project id used to create forwarding rule.
  final String? projectId;

  /// Required. The full name of the Google Compute Engine
  /// [network](https://cloud.google.com/compute/docs/networks-and-firewalls#networks).
  /// [Format](https://cloud.google.com/compute/docs/reference/rest/v1/networks/get):
  /// `projects/{project}/global/networks/{network}`.
  final String? network;

  /// Output only. IP address rule created by the PSC service automation.
  final String? ipAddress;

  /// Output only. Forwarding rule created by the PSC service automation.
  final String? forwardingRule;

  /// Output only. The state of the PSC service automation.
  final PscautomationState? state;

  /// Output only. Error message if the PSC service automation failed.
  final String? errorMessage;

  PscautomationConfig({
    this.projectId,
    this.network,
    this.ipAddress,
    this.forwardingRule,
    this.state,
    this.errorMessage,
  }) : super(fullyQualifiedName);

  factory PscautomationConfig.fromJson(Map<String, dynamic> json) {
    return PscautomationConfig(
      projectId: json['projectId'],
      network: json['network'],
      ipAddress: json['ipAddress'],
      forwardingRule: json['forwardingRule'],
      state: decodeEnum(json['state'], PscautomationState.fromJson),
      errorMessage: json['errorMessage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (projectId != null) 'projectId': projectId,
      if (network != null) 'network': network,
      if (ipAddress != null) 'ipAddress': ipAddress,
      if (forwardingRule != null) 'forwardingRule': forwardingRule,
      if (state != null) 'state': state!.toJson(),
      if (errorMessage != null) 'errorMessage': errorMessage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (projectId != null) 'projectId=$projectId',
      if (network != null) 'network=$network',
      if (ipAddress != null) 'ipAddress=$ipAddress',
      if (forwardingRule != null) 'forwardingRule=$forwardingRule',
      if (state != null) 'state=$state',
      if (errorMessage != null) 'errorMessage=$errorMessage',
    ].join(',');
    return 'PSCAutomationConfig($contents)';
  }
}

/// Represents configuration for private service connect.
final class PrivateServiceConnectConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PrivateServiceConnectConfig';

  /// Required. If true, expose the IndexEndpoint via private service connect.
  final bool? enablePrivateServiceConnect;

  /// A list of Projects from which the forwarding rule will target the service
  /// attachment.
  final List<String>? projectAllowlist;

  /// Optional. List of projects and networks where the PSC endpoints will be
  /// created. This field is used by Online Inference(Prediction) only.
  final List<PscautomationConfig>? pscAutomationConfigs;

  /// Optional. If set to true, enable secure private service connect with IAM
  /// authorization. Otherwise, private service connect will be done without
  /// authorization. Note latency will be slightly increased if authorization is
  /// enabled.
  final bool? enableSecurePrivateServiceConnect;

  /// Output only. The name of the generated service attachment resource.
  /// This is only populated if the endpoint is deployed with
  /// PrivateServiceConnect.
  final String? serviceAttachment;

  PrivateServiceConnectConfig({
    this.enablePrivateServiceConnect,
    this.projectAllowlist,
    this.pscAutomationConfigs,
    this.enableSecurePrivateServiceConnect,
    this.serviceAttachment,
  }) : super(fullyQualifiedName);

  factory PrivateServiceConnectConfig.fromJson(Map<String, dynamic> json) {
    return PrivateServiceConnectConfig(
      enablePrivateServiceConnect: json['enablePrivateServiceConnect'],
      projectAllowlist: decodeList(json['projectAllowlist']),
      pscAutomationConfigs: decodeListMessage(
        json['pscAutomationConfigs'],
        PscautomationConfig.fromJson,
      ),
      enableSecurePrivateServiceConnect:
          json['enableSecurePrivateServiceConnect'],
      serviceAttachment: json['serviceAttachment'],
    );
  }

  @override
  Object toJson() {
    return {
      if (enablePrivateServiceConnect != null)
        'enablePrivateServiceConnect': enablePrivateServiceConnect,
      if (projectAllowlist != null) 'projectAllowlist': projectAllowlist,
      if (pscAutomationConfigs != null)
        'pscAutomationConfigs': encodeList(pscAutomationConfigs),
      if (enableSecurePrivateServiceConnect != null)
        'enableSecurePrivateServiceConnect': enableSecurePrivateServiceConnect,
      if (serviceAttachment != null) 'serviceAttachment': serviceAttachment,
    };
  }

  @override
  String toString() {
    final contents = [
      if (enablePrivateServiceConnect != null)
        'enablePrivateServiceConnect=$enablePrivateServiceConnect',
      if (enableSecurePrivateServiceConnect != null)
        'enableSecurePrivateServiceConnect=$enableSecurePrivateServiceConnect',
      if (serviceAttachment != null) 'serviceAttachment=$serviceAttachment',
    ].join(',');
    return 'PrivateServiceConnectConfig($contents)';
  }
}

/// PscAutomatedEndpoints defines the output of the forwarding rule
/// automatically created by each PscAutomationConfig.
final class PscAutomatedEndpoints extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PscAutomatedEndpoints';

  /// Corresponding project_id in pscAutomationConfigs
  final String? projectId;

  /// Corresponding network in pscAutomationConfigs.
  final String? network;

  /// Ip Address created by the automated forwarding rule.
  final String? matchAddress;

  PscAutomatedEndpoints({this.projectId, this.network, this.matchAddress})
    : super(fullyQualifiedName);

  factory PscAutomatedEndpoints.fromJson(Map<String, dynamic> json) {
    return PscAutomatedEndpoints(
      projectId: json['projectId'],
      network: json['network'],
      matchAddress: json['matchAddress'],
    );
  }

  @override
  Object toJson() {
    return {
      if (projectId != null) 'projectId': projectId,
      if (network != null) 'network': network,
      if (matchAddress != null) 'matchAddress': matchAddress,
    };
  }

  @override
  String toString() {
    final contents = [
      if (projectId != null) 'projectId=$projectId',
      if (network != null) 'network=$network',
      if (matchAddress != null) 'matchAddress=$matchAddress',
    ].join(',');
    return 'PscAutomatedEndpoints($contents)';
  }
}

/// Configuration for PSC-I.
final class PscInterfaceConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PscInterfaceConfig';

  /// Optional. The name of the Compute Engine
  /// [network
  /// attachment](https://cloud.google.com/vpc/docs/about-network-attachments) to
  /// attach to the resource within the region and user project.
  /// To specify this field, you must have already [created a network attachment]
  /// (https://cloud.google.com/vpc/docs/create-manage-network-attachments#create-network-attachments).
  /// This field is only used for resources using PSC-I.
  final String? networkAttachment;

  /// Optional. DNS peering configurations. When specified, Vertex AI will
  /// attempt to configure DNS peering zones in the tenant project VPC
  /// to resolve the specified domains using the target network's Cloud DNS.
  /// The user must grant the dns.peer role to the Vertex AI Service Agent
  /// on the target project.
  final List<DnsPeeringConfig>? dnsPeeringConfigs;

  PscInterfaceConfig({this.networkAttachment, this.dnsPeeringConfigs})
    : super(fullyQualifiedName);

  factory PscInterfaceConfig.fromJson(Map<String, dynamic> json) {
    return PscInterfaceConfig(
      networkAttachment: json['networkAttachment'],
      dnsPeeringConfigs: decodeListMessage(
        json['dnsPeeringConfigs'],
        DnsPeeringConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (networkAttachment != null) 'networkAttachment': networkAttachment,
      if (dnsPeeringConfigs != null)
        'dnsPeeringConfigs': encodeList(dnsPeeringConfigs),
    };
  }

  @override
  String toString() {
    final contents = [
      if (networkAttachment != null) 'networkAttachment=$networkAttachment',
    ].join(',');
    return 'PscInterfaceConfig($contents)';
  }
}

/// DNS peering configuration. These configurations are used to create
/// DNS peering zones in the Vertex tenant project VPC, enabling resolution
/// of records within the specified domain hosted in the target network's
/// Cloud DNS.
final class DnsPeeringConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DnsPeeringConfig';

  /// Required. The DNS name suffix of the zone being peered to, e.g.,
  /// "my-internal-domain.corp.". Must end with a dot.
  final String? domain;

  /// Required. The project ID hosting the Cloud DNS managed zone that
  /// contains the 'domain'. The Vertex AI Service Agent requires the
  /// dns.peer role on this project.
  final String? targetProject;

  /// Required. The VPC network name
  /// in the target_project where the DNS zone specified by 'domain' is
  /// visible.
  final String? targetNetwork;

  DnsPeeringConfig({this.domain, this.targetProject, this.targetNetwork})
    : super(fullyQualifiedName);

  factory DnsPeeringConfig.fromJson(Map<String, dynamic> json) {
    return DnsPeeringConfig(
      domain: json['domain'],
      targetProject: json['targetProject'],
      targetNetwork: json['targetNetwork'],
    );
  }

  @override
  Object toJson() {
    return {
      if (domain != null) 'domain': domain,
      if (targetProject != null) 'targetProject': targetProject,
      if (targetNetwork != null) 'targetNetwork': targetNetwork,
    };
  }

  @override
  String toString() {
    final contents = [
      if (domain != null) 'domain=$domain',
      if (targetProject != null) 'targetProject=$targetProject',
      if (targetNetwork != null) 'targetNetwork=$targetNetwork',
    ].join(',');
    return 'DnsPeeringConfig($contents)';
  }
}

/// A session contains a set of actions between users and Vertex agents.
final class Session extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Session';

  /// Optional. Timestamp of when this session is considered expired.
  /// This is *always* provided on output, regardless of what was sent
  /// on input.
  final protobuf.Timestamp? expireTime;

  /// Optional. Input only. The TTL for this session.
  final protobuf.Duration? ttl;

  /// Identifier. The resource name of the session.
  /// Format:
  /// 'projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}'.
  final String? name;

  /// Output only. Timestamp when the session was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when the session was updated.
  final protobuf.Timestamp? updateTime;

  /// Optional. The display name of the session.
  final String? displayName;

  /// Optional. Session specific memory which stores key conversation points.
  final protobuf.Struct? sessionState;

  /// Required. Immutable. String id provided by the user
  final String? userId;

  Session({
    this.expireTime,
    this.ttl,
    this.name,
    this.createTime,
    this.updateTime,
    this.displayName,
    this.sessionState,
    this.userId,
  }) : super(fullyQualifiedName);

  factory Session.fromJson(Map<String, dynamic> json) {
    return Session(
      expireTime: decodeCustom(json['expireTime'], protobuf.Timestamp.fromJson),
      ttl: decodeCustom(json['ttl'], protobuf.Duration.fromJson),
      name: json['name'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      displayName: json['displayName'],
      sessionState: decodeCustom(
        json['sessionState'],
        protobuf.Struct.fromJson,
      ),
      userId: json['userId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (expireTime != null) 'expireTime': expireTime!.toJson(),
      if (ttl != null) 'ttl': ttl!.toJson(),
      if (name != null) 'name': name,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (displayName != null) 'displayName': displayName,
      if (sessionState != null) 'sessionState': sessionState!.toJson(),
      if (userId != null) 'userId': userId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (userId != null) 'userId=$userId',
    ].join(',');
    return 'Session($contents)';
  }
}

/// An event represents a message from either the user or agent.
final class SessionEvent extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SessionEvent';

  /// Identifier. The resource name of the event.
  /// Format:`projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}/events/{event}`.
  final String? name;

  /// Required. The name of the agent that sent the event, or user.
  final String? author;

  /// Optional. Content of the event provided by the author.
  final Content? content;

  /// Required. The invocation id of the event, multiple events can have the same
  /// invocation id.
  final String? invocationId;

  /// Optional. Actions executed by the agent.
  final EventActions? actions;

  /// Required. Timestamp when the event was created on client side.
  final protobuf.Timestamp? timestamp;

  /// Optional. Error code if the response is an error. Code varies by model.
  final String? errorCode;

  /// Optional. Error message if the response is an error.
  final String? errorMessage;

  /// Optional. Metadata relating to this event.
  final EventMetadata? eventMetadata;

  SessionEvent({
    this.name,
    this.author,
    this.content,
    this.invocationId,
    this.actions,
    this.timestamp,
    this.errorCode,
    this.errorMessage,
    this.eventMetadata,
  }) : super(fullyQualifiedName);

  factory SessionEvent.fromJson(Map<String, dynamic> json) {
    return SessionEvent(
      name: json['name'],
      author: json['author'],
      content: decode(json['content'], Content.fromJson),
      invocationId: json['invocationId'],
      actions: decode(json['actions'], EventActions.fromJson),
      timestamp: decodeCustom(json['timestamp'], protobuf.Timestamp.fromJson),
      errorCode: json['errorCode'],
      errorMessage: json['errorMessage'],
      eventMetadata: decode(json['eventMetadata'], EventMetadata.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (author != null) 'author': author,
      if (content != null) 'content': content!.toJson(),
      if (invocationId != null) 'invocationId': invocationId,
      if (actions != null) 'actions': actions!.toJson(),
      if (timestamp != null) 'timestamp': timestamp!.toJson(),
      if (errorCode != null) 'errorCode': errorCode,
      if (errorMessage != null) 'errorMessage': errorMessage,
      if (eventMetadata != null) 'eventMetadata': eventMetadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (author != null) 'author=$author',
      if (invocationId != null) 'invocationId=$invocationId',
      if (errorCode != null) 'errorCode=$errorCode',
      if (errorMessage != null) 'errorMessage=$errorMessage',
    ].join(',');
    return 'SessionEvent($contents)';
  }
}

/// Metadata relating to a LLM response event.
final class EventMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EventMetadata';

  /// Optional. Metadata returned to client when grounding is enabled.
  final GroundingMetadata? groundingMetadata;

  /// Optional. Indicates whether the text content is part of a unfinished text
  /// stream. Only used for streaming mode and when the content is plain text.
  final bool? partial;

  /// Optional. Indicates whether the response from the model is complete.
  /// Only used for streaming mode.
  final bool? turnComplete;

  /// Optional. Flag indicating that LLM was interrupted when generating the
  /// content. Usually it's due to user interruption during a bidi streaming.
  final bool? interrupted;

  /// Optional. Set of ids of the long running function calls.
  /// Agent client will know from this field about which function call is long
  /// running. Only valid for function call event.
  final List<String>? longRunningToolIds;

  /// Optional. The branch of the event.
  /// The format is like agent_1.agent_2.agent_3, where agent_1 is the parent of
  /// agent_2, and agent_2 is the parent of agent_3.
  /// Branch is used when multiple child agents shouldn't see their siblings'
  /// conversation history.
  final String? branch;

  /// The custom metadata of the LlmResponse.
  final protobuf.Struct? customMetadata;

  EventMetadata({
    this.groundingMetadata,
    this.partial,
    this.turnComplete,
    this.interrupted,
    this.longRunningToolIds,
    this.branch,
    this.customMetadata,
  }) : super(fullyQualifiedName);

  factory EventMetadata.fromJson(Map<String, dynamic> json) {
    return EventMetadata(
      groundingMetadata: decode(
        json['groundingMetadata'],
        GroundingMetadata.fromJson,
      ),
      partial: json['partial'],
      turnComplete: json['turnComplete'],
      interrupted: json['interrupted'],
      longRunningToolIds: decodeList(json['longRunningToolIds']),
      branch: json['branch'],
      customMetadata: decodeCustom(
        json['customMetadata'],
        protobuf.Struct.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (groundingMetadata != null)
        'groundingMetadata': groundingMetadata!.toJson(),
      if (partial != null) 'partial': partial,
      if (turnComplete != null) 'turnComplete': turnComplete,
      if (interrupted != null) 'interrupted': interrupted,
      if (longRunningToolIds != null) 'longRunningToolIds': longRunningToolIds,
      if (branch != null) 'branch': branch,
      if (customMetadata != null) 'customMetadata': customMetadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (partial != null) 'partial=$partial',
      if (turnComplete != null) 'turnComplete=$turnComplete',
      if (interrupted != null) 'interrupted=$interrupted',
      if (branch != null) 'branch=$branch',
    ].join(',');
    return 'EventMetadata($contents)';
  }
}

/// Actions are parts of events that are executed by the agent.
final class EventActions extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EventActions';

  /// Optional. If true, it won't call model to summarize function response.
  /// Only used for function_response event.
  final bool? skipSummarization;

  /// Optional. Indicates that the event is updating the state with the given
  /// delta.
  final protobuf.Struct? stateDelta;

  /// Optional. Indicates that the event is updating an artifact. key is the
  /// filename, value is the version.
  final Map<String, int>? artifactDelta;

  /// Deprecated. If set, the event transfers to the specified agent.
  final bool? transferToAgent;

  /// Optional. The agent is escalating to a higher level agent.
  final bool? escalate;

  /// Optional. Will only be set by a tool response indicating tool request euc.
  /// Struct key is the function call id since one function call response (from
  /// model) could correspond to multiple function calls. Struct value is the
  /// required auth config, which can be another struct.
  final protobuf.Struct? requestedAuthConfigs;

  /// Optional. If set, the event transfers to the specified agent.
  final String? transferAgent;

  EventActions({
    this.skipSummarization,
    this.stateDelta,
    this.artifactDelta,
    this.transferToAgent,
    this.escalate,
    this.requestedAuthConfigs,
    this.transferAgent,
  }) : super(fullyQualifiedName);

  factory EventActions.fromJson(Map<String, dynamic> json) {
    return EventActions(
      skipSummarization: json['skipSummarization'],
      stateDelta: decodeCustom(json['stateDelta'], protobuf.Struct.fromJson),
      artifactDelta: decodeMap(json['artifactDelta']),
      transferToAgent: json['transferToAgent'],
      escalate: json['escalate'],
      requestedAuthConfigs: decodeCustom(
        json['requestedAuthConfigs'],
        protobuf.Struct.fromJson,
      ),
      transferAgent: json['transferAgent'],
    );
  }

  @override
  Object toJson() {
    return {
      if (skipSummarization != null) 'skipSummarization': skipSummarization,
      if (stateDelta != null) 'stateDelta': stateDelta!.toJson(),
      if (artifactDelta != null) 'artifactDelta': artifactDelta,
      if (transferToAgent != null) 'transferToAgent': transferToAgent,
      if (escalate != null) 'escalate': escalate,
      if (requestedAuthConfigs != null)
        'requestedAuthConfigs': requestedAuthConfigs!.toJson(),
      if (transferAgent != null) 'transferAgent': transferAgent,
    };
  }

  @override
  String toString() {
    final contents = [
      if (skipSummarization != null) 'skipSummarization=$skipSummarization',
      if (transferToAgent != null) 'transferToAgent=$transferToAgent',
      if (escalate != null) 'escalate=$escalate',
      if (transferAgent != null) 'transferAgent=$transferAgent',
    ].join(',');
    return 'EventActions($contents)';
  }
}

/// Request message for
/// `SessionService.CreateSession`.
final class CreateSessionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateSessionRequest';

  /// Required. The resource name of the location to create the session in.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Required. The session to create.
  final Session session;

  CreateSessionRequest({required this.parent, required this.session})
    : super(fullyQualifiedName);

  factory CreateSessionRequest.fromJson(Map<String, dynamic> json) {
    return CreateSessionRequest(
      parent: json['parent'],
      session: decode(json['session'], Session.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'session': session.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateSessionRequest($contents)';
  }
}

/// Metadata associated with the
/// `SessionService.CreateSession`
/// operation.
final class CreateSessionOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateSessionOperationMetadata';

  /// The common part of the operation metadata.
  final GenericOperationMetadata? genericMetadata;

  CreateSessionOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateSessionOperationMetadata.fromJson(Map<String, dynamic> json) {
    return CreateSessionOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateSessionOperationMetadata()';
}

/// Request message for
/// `SessionService.GetSession`.
final class GetSessionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetSessionRequest';

  /// Required. The resource name of the session.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String name;

  GetSessionRequest({required this.name}) : super(fullyQualifiedName);

  factory GetSessionRequest.fromJson(Map<String, dynamic> json) {
    return GetSessionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetSessionRequest($contents)';
  }
}

/// Request message for
/// `SessionService.ListSessions`.
final class ListSessionsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSessionsRequest';

  /// Required. The resource name of the location to list sessions from.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}`
  final String parent;

  /// Optional. The maximum number of sessions to return. The service may return
  /// fewer than this value. If unspecified, at most 100 sessions will be
  /// returned.
  final int? pageSize;

  /// Optional. The
  /// `next_page_token`
  /// value returned from a previous list
  /// `SessionService.ListSessions`
  /// call.
  final String? pageToken;

  /// Optional. The standard list filter.
  /// Supported fields:
  ///    * `display_name`
  ///
  /// Example: `display_name=abc`.
  final String? filter;

  /// Optional. A comma-separated list of fields to order by, sorted in ascending
  /// order. Use "desc" after a field name for descending. Supported fields:
  ///   * `create_time`
  ///   * `update_time`
  ///
  /// Example: `create_time desc`.
  final String? orderBy;

  ListSessionsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ListSessionsRequest.fromJson(Map<String, dynamic> json) {
    return ListSessionsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListSessionsRequest($contents)';
  }
}

/// Response message for
/// `SessionService.ListSessions`.
final class ListSessionsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSessionsResponse';

  /// A list of sessions matching the request.
  final List<Session>? sessions;

  /// A token, which can be sent as
  /// `ListSessionsRequest.page_token`
  /// to retrieve the next page. Absence of this field indicates there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListSessionsResponse({this.sessions, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListSessionsResponse.fromJson(Map<String, dynamic> json) {
    return ListSessionsResponse(
      sessions: decodeListMessage(json['sessions'], Session.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (sessions != null) 'sessions': encodeList(sessions),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListSessionsResponse($contents)';
  }
}

/// Request message for
/// `SessionService.UpdateSession`.
final class UpdateSessionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateSessionRequest';

  /// Required. The session to update.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final Session session;

  /// Optional. Field mask is used to control which fields get updated. If the
  /// mask is not present, all fields will be updated.
  final protobuf.FieldMask? updateMask;

  UpdateSessionRequest({required this.session, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateSessionRequest.fromJson(Map<String, dynamic> json) {
    return UpdateSessionRequest(
      session: decode(json['session'], Session.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'session': session.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateSessionRequest()';
}

/// Request message for
/// `SessionService.DeleteSession`.
final class DeleteSessionRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteSessionRequest';

  /// Required. The resource name of the session.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String name;

  DeleteSessionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteSessionRequest.fromJson(Map<String, dynamic> json) {
    return DeleteSessionRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteSessionRequest($contents)';
  }
}

/// Request message for
/// `SessionService.ListEvents`.
final class ListEventsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEventsRequest';

  /// Required. The resource name of the session to list events from.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String parent;

  /// Optional. The maximum number of events to return. The service may return
  /// fewer than this value. If unspecified, at most 100 events will be returned.
  /// These events are ordered by timestamp in ascending order.
  final int? pageSize;

  /// Optional. The
  /// `next_page_token`
  /// value returned from a previous list
  /// `SessionService.ListEvents`
  /// call.
  final String? pageToken;

  /// Optional. The standard list filter.
  /// Supported fields:
  ///    * `timestamp` range (i.e. `timestamp>="2025-01-31T11:30:00-04:00"` where
  ///    the timestamp is in RFC 3339 format)
  ///
  /// More detail in [AIP-160](https://google.aip.dev/160).
  final String? filter;

  ListEventsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.filter,
  }) : super(fullyQualifiedName);

  factory ListEventsRequest.fromJson(Map<String, dynamic> json) {
    return ListEventsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      filter: json['filter'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (filter != null) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'ListEventsRequest($contents)';
  }
}

/// Response message for
/// `SessionService.ListEvents`.
final class ListEventsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListEventsResponse';

  /// A list of events matching the request. Ordered by timestamp in ascending
  /// order.
  final List<SessionEvent>? sessionEvents;

  /// A token, which can be sent as
  /// `ListEventsRequest.page_token`
  /// to retrieve the next page. Absence of this field indicates there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListEventsResponse({this.sessionEvents, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListEventsResponse.fromJson(Map<String, dynamic> json) {
    return ListEventsResponse(
      sessionEvents: decodeListMessage(
        json['sessionEvents'],
        SessionEvent.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (sessionEvents != null) 'sessionEvents': encodeList(sessionEvents),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListEventsResponse($contents)';
  }
}

/// Request message for
/// `SessionService.AppendEvent`.
final class AppendEventRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AppendEventRequest';

  /// Required. The resource name of the session to append event to.
  /// Format:
  /// `projects/{project}/locations/{location}/reasoningEngines/{reasoning_engine}/sessions/{session}`
  final String name;

  /// Required. The event to append to the session.
  final SessionEvent event;

  AppendEventRequest({required this.name, required this.event})
    : super(fullyQualifiedName);

  factory AppendEventRequest.fromJson(Map<String, dynamic> json) {
    return AppendEventRequest(
      name: json['name'],
      event: decode(json['event'], SessionEvent.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'name': name, 'event': event.toJson()};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AppendEventRequest($contents)';
  }
}

/// Response message for
/// `SessionService.AppendEvent`.
final class AppendEventResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AppendEventResponse';

  AppendEventResponse() : super(fullyQualifiedName);

  factory AppendEventResponse.fromJson(Map<String, dynamic> json) {
    return AppendEventResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'AppendEventResponse()';
}

/// SpecialistPool represents customers' own workforce to work on their data
/// labeling jobs. It includes a group of specialist managers and workers.
/// Managers are responsible for managing the workers in this pool as well as
/// customers' data labeling jobs associated with this pool. Customers create
/// specialist pool as well as start data labeling jobs on Cloud, managers and
/// workers handle the jobs using CrowdCompute console.
final class SpecialistPool extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SpecialistPool';

  /// Required. The resource name of the SpecialistPool.
  final String? name;

  /// Required. The user-defined name of the SpecialistPool.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  /// This field should be unique on project-level.
  final String? displayName;

  /// Output only. The number of managers in this SpecialistPool.
  final int? specialistManagersCount;

  /// The email addresses of the managers in the SpecialistPool.
  final List<String>? specialistManagerEmails;

  /// Output only. The resource name of the pending data labeling jobs.
  final List<String>? pendingDataLabelingJobs;

  /// The email addresses of workers in the SpecialistPool.
  final List<String>? specialistWorkerEmails;

  SpecialistPool({
    this.name,
    this.displayName,
    this.specialistManagersCount,
    this.specialistManagerEmails,
    this.pendingDataLabelingJobs,
    this.specialistWorkerEmails,
  }) : super(fullyQualifiedName);

  factory SpecialistPool.fromJson(Map<String, dynamic> json) {
    return SpecialistPool(
      name: json['name'],
      displayName: json['displayName'],
      specialistManagersCount: json['specialistManagersCount'],
      specialistManagerEmails: decodeList(json['specialistManagerEmails']),
      pendingDataLabelingJobs: decodeList(json['pendingDataLabelingJobs']),
      specialistWorkerEmails: decodeList(json['specialistWorkerEmails']),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (specialistManagersCount != null)
        'specialistManagersCount': specialistManagersCount,
      if (specialistManagerEmails != null)
        'specialistManagerEmails': specialistManagerEmails,
      if (pendingDataLabelingJobs != null)
        'pendingDataLabelingJobs': pendingDataLabelingJobs,
      if (specialistWorkerEmails != null)
        'specialistWorkerEmails': specialistWorkerEmails,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (specialistManagersCount != null)
        'specialistManagersCount=$specialistManagersCount',
    ].join(',');
    return 'SpecialistPool($contents)';
  }
}

/// Request message for
/// `SpecialistPoolService.CreateSpecialistPool`.
final class CreateSpecialistPoolRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateSpecialistPoolRequest';

  /// Required. The parent Project name for the new SpecialistPool.
  /// The form is `projects/{project}/locations/{location}`.
  final String parent;

  /// Required. The SpecialistPool to create.
  final SpecialistPool specialistPool;

  CreateSpecialistPoolRequest({
    required this.parent,
    required this.specialistPool,
  }) : super(fullyQualifiedName);

  factory CreateSpecialistPoolRequest.fromJson(Map<String, dynamic> json) {
    return CreateSpecialistPoolRequest(
      parent: json['parent'],
      specialistPool: decode(json['specialistPool'], SpecialistPool.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'specialistPool': specialistPool.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateSpecialistPoolRequest($contents)';
  }
}

/// Runtime operation information for
/// `SpecialistPoolService.CreateSpecialistPool`.
final class CreateSpecialistPoolOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateSpecialistPoolOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateSpecialistPoolOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateSpecialistPoolOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateSpecialistPoolOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateSpecialistPoolOperationMetadata()';
}

/// Request message for
/// `SpecialistPoolService.GetSpecialistPool`.
final class GetSpecialistPoolRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetSpecialistPoolRequest';

  /// Required. The name of the SpecialistPool resource.
  /// The form is
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`.
  final String name;

  GetSpecialistPoolRequest({required this.name}) : super(fullyQualifiedName);

  factory GetSpecialistPoolRequest.fromJson(Map<String, dynamic> json) {
    return GetSpecialistPoolRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetSpecialistPoolRequest($contents)';
  }
}

/// Request message for
/// `SpecialistPoolService.ListSpecialistPools`.
final class ListSpecialistPoolsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSpecialistPoolsRequest';

  /// Required. The name of the SpecialistPool's parent resource.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// The standard list page size.
  final int? pageSize;

  /// The standard list page token.
  /// Typically obtained by
  /// `ListSpecialistPoolsResponse.next_page_token`
  /// of the previous
  /// `SpecialistPoolService.ListSpecialistPools`
  /// call. Return first page if empty.
  final String? pageToken;

  /// Mask specifying which fields to read. FieldMask represents a set of
  final protobuf.FieldMask? readMask;

  ListSpecialistPoolsRequest({
    required this.parent,
    this.pageSize,
    this.pageToken,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListSpecialistPoolsRequest.fromJson(Map<String, dynamic> json) {
    return ListSpecialistPoolsRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListSpecialistPoolsRequest($contents)';
  }
}

/// Response message for
/// `SpecialistPoolService.ListSpecialistPools`.
final class ListSpecialistPoolsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListSpecialistPoolsResponse';

  /// A list of SpecialistPools that matches the specified filter in the request.
  final List<SpecialistPool>? specialistPools;

  /// The standard List next-page token.
  final String? nextPageToken;

  ListSpecialistPoolsResponse({this.specialistPools, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListSpecialistPoolsResponse.fromJson(Map<String, dynamic> json) {
    return ListSpecialistPoolsResponse(
      specialistPools: decodeListMessage(
        json['specialistPools'],
        SpecialistPool.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (specialistPools != null)
        'specialistPools': encodeList(specialistPools),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListSpecialistPoolsResponse($contents)';
  }
}

/// Request message for
/// `SpecialistPoolService.DeleteSpecialistPool`.
final class DeleteSpecialistPoolRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteSpecialistPoolRequest';

  /// Required. The resource name of the SpecialistPool to delete. Format:
  /// `projects/{project}/locations/{location}/specialistPools/{specialist_pool}`
  final String name;

  /// If set to true, any specialist managers in this SpecialistPool will also be
  /// deleted. (Otherwise, the request will only work if the SpecialistPool has
  /// no specialist managers.)
  final bool? force;

  DeleteSpecialistPoolRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteSpecialistPoolRequest.fromJson(Map<String, dynamic> json) {
    return DeleteSpecialistPoolRequest(
      name: json['name'],
      force: json['force'],
    );
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteSpecialistPoolRequest($contents)';
  }
}

/// Request message for
/// `SpecialistPoolService.UpdateSpecialistPool`.
final class UpdateSpecialistPoolRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateSpecialistPoolRequest';

  /// Required. The SpecialistPool which replaces the resource on the server.
  final SpecialistPool specialistPool;

  /// Required. The update mask applies to the resource.
  final protobuf.FieldMask? updateMask;

  UpdateSpecialistPoolRequest({required this.specialistPool, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateSpecialistPoolRequest.fromJson(Map<String, dynamic> json) {
    return UpdateSpecialistPoolRequest(
      specialistPool: decode(json['specialistPool'], SpecialistPool.fromJson)!,
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'specialistPool': specialistPool.toJson(),
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateSpecialistPoolRequest()';
}

/// Runtime operation metadata for
/// `SpecialistPoolService.UpdateSpecialistPool`.
final class UpdateSpecialistPoolOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateSpecialistPoolOperationMetadata';

  /// Output only. The name of the SpecialistPool to which the specialists are
  /// being added. Format:
  /// `projects/{project_id}/locations/{location_id}/specialistPools/{specialist_pool}`
  final String? specialistPool;

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateSpecialistPoolOperationMetadata({
    this.specialistPool,
    this.genericMetadata,
  }) : super(fullyQualifiedName);

  factory UpdateSpecialistPoolOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateSpecialistPoolOperationMetadata(
      specialistPool: json['specialistPool'],
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (specialistPool != null) 'specialistPool': specialistPool,
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (specialistPool != null) 'specialistPool=$specialistPool',
    ].join(',');
    return 'UpdateSpecialistPoolOperationMetadata($contents)';
  }
}

/// A message representing a Study.
final class Study extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Study';

  /// Output only. The name of a study. The study's globally unique identifier.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String? name;

  /// Required. Describes the Study, default value is empty string.
  final String? displayName;

  /// Required. Configuration of the Study.
  final StudySpec? studySpec;

  /// Output only. The detailed state of a Study.
  final Study_State? state;

  /// Output only. Time at which the study was created.
  final protobuf.Timestamp? createTime;

  /// Output only. A human readable reason why the Study is inactive.
  /// This should be empty if a study is ACTIVE or COMPLETED.
  final String? inactiveReason;

  Study({
    this.name,
    this.displayName,
    this.studySpec,
    this.state,
    this.createTime,
    this.inactiveReason,
  }) : super(fullyQualifiedName);

  factory Study.fromJson(Map<String, dynamic> json) {
    return Study(
      name: json['name'],
      displayName: json['displayName'],
      studySpec: decode(json['studySpec'], StudySpec.fromJson),
      state: decodeEnum(json['state'], Study_State.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      inactiveReason: json['inactiveReason'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (studySpec != null) 'studySpec': studySpec!.toJson(),
      if (state != null) 'state': state!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (inactiveReason != null) 'inactiveReason': inactiveReason,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (state != null) 'state=$state',
      if (inactiveReason != null) 'inactiveReason=$inactiveReason',
    ].join(',');
    return 'Study($contents)';
  }
}

/// Describes the Study state.
final class Study_State extends protobuf.ProtoEnum {
  /// The study state is unspecified.
  static const stateUnspecified = Study_State('STATE_UNSPECIFIED');

  /// The study is active.
  static const active = Study_State('ACTIVE');

  /// The study is stopped due to an internal error.
  static const inactive = Study_State('INACTIVE');

  /// The study is done when the service exhausts the parameter search space
  /// or max_trial_count is reached.
  static const completed = Study_State('COMPLETED');

  const Study_State(super.value);

  factory Study_State.fromJson(String json) => Study_State(json);

  @override
  String toString() => 'State.$value';
}

/// A message representing a Trial. A Trial contains a unique set of Parameters
/// that has been or will be evaluated, along with the objective metrics got by
/// running the Trial.
final class Trial extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Trial';

  /// Output only. Resource name of the Trial assigned by the service.
  final String? name;

  /// Output only. The identifier of the Trial assigned by the service.
  final String? id;

  /// Output only. The detailed state of the Trial.
  final Trial_State? state;

  /// Output only. The parameters of the Trial.
  final List<Trial_Parameter>? parameters;

  /// Output only. The final measurement containing the objective value.
  final Measurement? finalMeasurement;

  /// Output only. A list of measurements that are strictly lexicographically
  /// ordered by their induced tuples (steps, elapsed_duration).
  /// These are used for early stopping computations.
  final List<Measurement>? measurements;

  /// Output only. Time when the Trial was started.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the Trial's status changed to `SUCCEEDED` or
  /// `INFEASIBLE`.
  final protobuf.Timestamp? endTime;

  /// Output only. The identifier of the client that originally requested this
  /// Trial. Each client is identified by a unique client_id. When a client asks
  /// for a suggestion, Vertex AI Vizier will assign it a Trial. The client
  /// should evaluate the Trial, complete it, and report back to Vertex AI
  /// Vizier. If suggestion is asked again by same client_id before the Trial is
  /// completed, the same Trial will be returned. Multiple clients with
  /// different client_ids can ask for suggestions simultaneously, each of them
  /// will get their own Trial.
  final String? clientId;

  /// Output only. A human readable string describing why the Trial is
  /// infeasible. This is set only if Trial state is `INFEASIBLE`.
  final String? infeasibleReason;

  /// Output only. The CustomJob name linked to the Trial.
  /// It's set for a HyperparameterTuningJob's Trial.
  final String? customJob;

  /// Output only. URIs for accessing [interactive
  /// shells](https://cloud.google.com/vertex-ai/docs/training/monitor-debug-interactive-shell)
  /// (one URI for each training node). Only available if this trial is part of
  /// a
  /// `HyperparameterTuningJob`
  /// and the job's
  /// `trial_job_spec.enable_web_access`
  /// field is `true`.
  ///
  /// The keys are names of each node used for the trial; for example,
  /// `workerpool0-0` for the primary node, `workerpool1-0` for the first node in
  /// the second worker pool, and `workerpool1-1` for the second node in the
  /// second worker pool.
  ///
  /// The values are the URIs for each node's interactive shell.
  final Map<String, String>? webAccessUris;

  Trial({
    this.name,
    this.id,
    this.state,
    this.parameters,
    this.finalMeasurement,
    this.measurements,
    this.startTime,
    this.endTime,
    this.clientId,
    this.infeasibleReason,
    this.customJob,
    this.webAccessUris,
  }) : super(fullyQualifiedName);

  factory Trial.fromJson(Map<String, dynamic> json) {
    return Trial(
      name: json['name'],
      id: json['id'],
      state: decodeEnum(json['state'], Trial_State.fromJson),
      parameters: decodeListMessage(
        json['parameters'],
        Trial_Parameter.fromJson,
      ),
      finalMeasurement: decode(json['finalMeasurement'], Measurement.fromJson),
      measurements: decodeListMessage(
        json['measurements'],
        Measurement.fromJson,
      ),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      clientId: json['clientId'],
      infeasibleReason: json['infeasibleReason'],
      customJob: json['customJob'],
      webAccessUris: decodeMap(json['webAccessUris']),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (id != null) 'id': id,
      if (state != null) 'state': state!.toJson(),
      if (parameters != null) 'parameters': encodeList(parameters),
      if (finalMeasurement != null)
        'finalMeasurement': finalMeasurement!.toJson(),
      if (measurements != null) 'measurements': encodeList(measurements),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (clientId != null) 'clientId': clientId,
      if (infeasibleReason != null) 'infeasibleReason': infeasibleReason,
      if (customJob != null) 'customJob': customJob,
      if (webAccessUris != null) 'webAccessUris': webAccessUris,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (id != null) 'id=$id',
      if (state != null) 'state=$state',
      if (clientId != null) 'clientId=$clientId',
      if (infeasibleReason != null) 'infeasibleReason=$infeasibleReason',
      if (customJob != null) 'customJob=$customJob',
    ].join(',');
    return 'Trial($contents)';
  }
}

/// A message representing a parameter to be tuned.
final class Trial_Parameter extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Trial.Parameter';

  /// Output only. The ID of the parameter. The parameter should be defined in
  /// [StudySpec's
  /// Parameters][google.cloud.aiplatform.v1beta1.StudySpec.parameters].
  final String? parameterId;

  /// Output only. The value of the parameter.
  /// `number_value` will be set if a parameter defined in StudySpec is
  /// in type 'INTEGER', 'DOUBLE' or 'DISCRETE'.
  /// `string_value` will be set if a parameter defined in StudySpec is
  /// in type 'CATEGORICAL'.
  final protobuf.Value? value;

  Trial_Parameter({this.parameterId, this.value}) : super(fullyQualifiedName);

  factory Trial_Parameter.fromJson(Map<String, dynamic> json) {
    return Trial_Parameter(
      parameterId: json['parameterId'],
      value: decodeCustom(json['value'], protobuf.Value.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (parameterId != null) 'parameterId': parameterId,
      if (value != null) 'value': value!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (parameterId != null) 'parameterId=$parameterId',
    ].join(',');
    return 'Parameter($contents)';
  }
}

/// Describes a Trial state.
final class Trial_State extends protobuf.ProtoEnum {
  /// The Trial state is unspecified.
  static const stateUnspecified = Trial_State('STATE_UNSPECIFIED');

  /// Indicates that a specific Trial has been requested, but it has not yet
  /// been suggested by the service.
  static const requested = Trial_State('REQUESTED');

  /// Indicates that the Trial has been suggested.
  static const active = Trial_State('ACTIVE');

  /// Indicates that the Trial should stop according to the service.
  static const stopping = Trial_State('STOPPING');

  /// Indicates that the Trial is completed successfully.
  static const succeeded = Trial_State('SUCCEEDED');

  /// Indicates that the Trial should not be attempted again.
  /// The service will set a Trial to INFEASIBLE when it's done but missing
  /// the final_measurement.
  static const infeasible = Trial_State('INFEASIBLE');

  const Trial_State(super.value);

  factory Trial_State.fromJson(String json) => Trial_State(json);

  @override
  String toString() => 'State.$value';
}

final class TrialContext extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrialContext';

  /// A human-readable field which can store a description of this context.
  /// This will become part of the resulting Trial's description field.
  final String? description;

  /// If/when a Trial is generated or selected from this Context,
  /// its Parameters will match any parameters specified here.
  /// (I.e. if this context specifies parameter name:'a' int_value:3,
  /// then a resulting Trial will have int_value:3 for its parameter named
  /// 'a'.) Note that we first attempt to match existing REQUESTED Trials with
  /// contexts, and if there are no matches, we generate suggestions in the
  /// subspace defined by the parameters specified here.
  /// NOTE: a Context without any Parameters matches the entire feasible search
  ///   space.
  final List<Trial_Parameter>? parameters;

  TrialContext({this.description, this.parameters}) : super(fullyQualifiedName);

  factory TrialContext.fromJson(Map<String, dynamic> json) {
    return TrialContext(
      description: json['description'],
      parameters: decodeListMessage(
        json['parameters'],
        Trial_Parameter.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (description != null) 'description': description,
      if (parameters != null) 'parameters': encodeList(parameters),
    };
  }

  @override
  String toString() {
    final contents = [
      if (description != null) 'description=$description',
    ].join(',');
    return 'TrialContext($contents)';
  }
}

/// Time-based Constraint for Study
final class StudyTimeConstraint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudyTimeConstraint';

  /// Counts the wallclock time passed since the creation of this Study.
  final protobuf.Duration? maxDuration;

  /// Compares the wallclock time to this time. Must use UTC timezone.
  final protobuf.Timestamp? endTime;

  StudyTimeConstraint({this.maxDuration, this.endTime})
    : super(fullyQualifiedName);

  factory StudyTimeConstraint.fromJson(Map<String, dynamic> json) {
    return StudyTimeConstraint(
      maxDuration: decodeCustom(
        json['maxDuration'],
        protobuf.Duration.fromJson,
      ),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (maxDuration != null) 'maxDuration': maxDuration!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
    };
  }

  @override
  String toString() => 'StudyTimeConstraint()';
}

/// Represents specification of a Study.
final class StudySpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec';

  /// The automated early stopping spec using decay curve rule.
  final StudySpec_DecayCurveAutomatedStoppingSpec? decayCurveStoppingSpec;

  /// The automated early stopping spec using median rule.
  final StudySpec_MedianAutomatedStoppingSpec? medianAutomatedStoppingSpec;

  /// Deprecated.
  /// The automated early stopping using convex stopping rule.
  final StudySpec_ConvexStopConfig? convexStopConfig;

  /// The automated early stopping spec using convex stopping rule.
  final StudySpec_ConvexAutomatedStoppingSpec? convexAutomatedStoppingSpec;

  /// Required. Metric specs for the Study.
  final List<StudySpec_MetricSpec>? metrics;

  /// Required. The set of parameters to tune.
  final List<StudySpec_ParameterSpec>? parameters;

  /// The search algorithm specified for the Study.
  final StudySpec_Algorithm? algorithm;

  /// The observation noise level of the study.
  /// Currently only supported by the Vertex AI Vizier service. Not supported by
  /// HyperparameterTuningJob or TrainingPipeline.
  final StudySpec_ObservationNoise? observationNoise;

  /// Describe which measurement selection type will be used
  final StudySpec_MeasurementSelectionType? measurementSelectionType;

  /// The configuration info/options for transfer learning. Currently supported
  /// for Vertex AI Vizier service, not HyperParameterTuningJob
  final StudySpec_TransferLearningConfig? transferLearningConfig;

  /// Conditions for automated stopping of a Study. Enable automated stopping by
  /// configuring at least one condition.
  final StudySpec_StudyStoppingConfig? studyStoppingConfig;

  StudySpec({
    this.decayCurveStoppingSpec,
    this.medianAutomatedStoppingSpec,
    this.convexStopConfig,
    this.convexAutomatedStoppingSpec,
    this.metrics,
    this.parameters,
    this.algorithm,
    this.observationNoise,
    this.measurementSelectionType,
    this.transferLearningConfig,
    this.studyStoppingConfig,
  }) : super(fullyQualifiedName);

  factory StudySpec.fromJson(Map<String, dynamic> json) {
    return StudySpec(
      decayCurveStoppingSpec: decode(
        json['decayCurveStoppingSpec'],
        StudySpec_DecayCurveAutomatedStoppingSpec.fromJson,
      ),
      medianAutomatedStoppingSpec: decode(
        json['medianAutomatedStoppingSpec'],
        StudySpec_MedianAutomatedStoppingSpec.fromJson,
      ),
      convexStopConfig: decode(
        json['convexStopConfig'],
        StudySpec_ConvexStopConfig.fromJson,
      ),
      convexAutomatedStoppingSpec: decode(
        json['convexAutomatedStoppingSpec'],
        StudySpec_ConvexAutomatedStoppingSpec.fromJson,
      ),
      metrics: decodeListMessage(
        json['metrics'],
        StudySpec_MetricSpec.fromJson,
      ),
      parameters: decodeListMessage(
        json['parameters'],
        StudySpec_ParameterSpec.fromJson,
      ),
      algorithm: decodeEnum(json['algorithm'], StudySpec_Algorithm.fromJson),
      observationNoise: decodeEnum(
        json['observationNoise'],
        StudySpec_ObservationNoise.fromJson,
      ),
      measurementSelectionType: decodeEnum(
        json['measurementSelectionType'],
        StudySpec_MeasurementSelectionType.fromJson,
      ),
      transferLearningConfig: decode(
        json['transferLearningConfig'],
        StudySpec_TransferLearningConfig.fromJson,
      ),
      studyStoppingConfig: decode(
        json['studyStoppingConfig'],
        StudySpec_StudyStoppingConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (decayCurveStoppingSpec != null)
        'decayCurveStoppingSpec': decayCurveStoppingSpec!.toJson(),
      if (medianAutomatedStoppingSpec != null)
        'medianAutomatedStoppingSpec': medianAutomatedStoppingSpec!.toJson(),
      if (convexStopConfig != null)
        'convexStopConfig': convexStopConfig!.toJson(),
      if (convexAutomatedStoppingSpec != null)
        'convexAutomatedStoppingSpec': convexAutomatedStoppingSpec!.toJson(),
      if (metrics != null) 'metrics': encodeList(metrics),
      if (parameters != null) 'parameters': encodeList(parameters),
      if (algorithm != null) 'algorithm': algorithm!.toJson(),
      if (observationNoise != null)
        'observationNoise': observationNoise!.toJson(),
      if (measurementSelectionType != null)
        'measurementSelectionType': measurementSelectionType!.toJson(),
      if (transferLearningConfig != null)
        'transferLearningConfig': transferLearningConfig!.toJson(),
      if (studyStoppingConfig != null)
        'studyStoppingConfig': studyStoppingConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (algorithm != null) 'algorithm=$algorithm',
      if (observationNoise != null) 'observationNoise=$observationNoise',
      if (measurementSelectionType != null)
        'measurementSelectionType=$measurementSelectionType',
    ].join(',');
    return 'StudySpec($contents)';
  }
}

/// Represents a metric to optimize.
final class StudySpec_MetricSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.MetricSpec';

  /// Required. The ID of the metric. Must not contain whitespaces and must be
  /// unique amongst all MetricSpecs.
  final String? metricId;

  /// Required. The optimization goal of the metric.
  final StudySpec_MetricSpec_GoalType? goal;

  /// Used for safe search. In the case, the metric will be a safety
  /// metric. You must provide a separate metric for objective metric.
  final StudySpec_MetricSpec_SafetyMetricConfig? safetyConfig;

  StudySpec_MetricSpec({this.metricId, this.goal, this.safetyConfig})
    : super(fullyQualifiedName);

  factory StudySpec_MetricSpec.fromJson(Map<String, dynamic> json) {
    return StudySpec_MetricSpec(
      metricId: json['metricId'],
      goal: decodeEnum(json['goal'], StudySpec_MetricSpec_GoalType.fromJson),
      safetyConfig: decode(
        json['safetyConfig'],
        StudySpec_MetricSpec_SafetyMetricConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricId != null) 'metricId': metricId,
      if (goal != null) 'goal': goal!.toJson(),
      if (safetyConfig != null) 'safetyConfig': safetyConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (metricId != null) 'metricId=$metricId',
      if (goal != null) 'goal=$goal',
    ].join(',');
    return 'MetricSpec($contents)';
  }
}

/// Used in safe optimization to specify threshold levels and risk tolerance.
final class StudySpec_MetricSpec_SafetyMetricConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.MetricSpec.SafetyMetricConfig';

  /// Safety threshold (boundary value between safe and unsafe). NOTE that if
  /// you leave SafetyMetricConfig unset, a default value of 0 will be used.
  final double? safetyThreshold;

  /// Desired minimum fraction of safe trials (over total number of trials)
  /// that should be targeted by the algorithm at any time during the
  /// study (best effort). This should be between 0.0 and 1.0 and a value of
  /// 0.0 means that there is no minimum and an algorithm proceeds without
  /// targeting any specific fraction. A value of 1.0 means that the
  /// algorithm attempts to only Suggest safe Trials.
  final double? desiredMinSafeTrialsFraction;

  StudySpec_MetricSpec_SafetyMetricConfig({
    this.safetyThreshold,
    this.desiredMinSafeTrialsFraction,
  }) : super(fullyQualifiedName);

  factory StudySpec_MetricSpec_SafetyMetricConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_MetricSpec_SafetyMetricConfig(
      safetyThreshold: decodeDouble(json['safetyThreshold']),
      desiredMinSafeTrialsFraction: decodeDouble(
        json['desiredMinSafeTrialsFraction'],
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (safetyThreshold != null)
        'safetyThreshold': encodeDouble(safetyThreshold),
      if (desiredMinSafeTrialsFraction != null)
        'desiredMinSafeTrialsFraction': encodeDouble(
          desiredMinSafeTrialsFraction,
        ),
    };
  }

  @override
  String toString() {
    final contents = [
      if (safetyThreshold != null) 'safetyThreshold=$safetyThreshold',
      if (desiredMinSafeTrialsFraction != null)
        'desiredMinSafeTrialsFraction=$desiredMinSafeTrialsFraction',
    ].join(',');
    return 'SafetyMetricConfig($contents)';
  }
}

/// The available types of optimization goals.
final class StudySpec_MetricSpec_GoalType extends protobuf.ProtoEnum {
  /// Goal Type will default to maximize.
  static const goalTypeUnspecified = StudySpec_MetricSpec_GoalType(
    'GOAL_TYPE_UNSPECIFIED',
  );

  /// Maximize the goal metric.
  static const maximize = StudySpec_MetricSpec_GoalType('MAXIMIZE');

  /// Minimize the goal metric.
  static const minimize = StudySpec_MetricSpec_GoalType('MINIMIZE');

  const StudySpec_MetricSpec_GoalType(super.value);

  factory StudySpec_MetricSpec_GoalType.fromJson(String json) =>
      StudySpec_MetricSpec_GoalType(json);

  @override
  String toString() => 'GoalType.$value';
}

/// Represents a single parameter to optimize.
final class StudySpec_ParameterSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec';

  /// The value spec for a 'DOUBLE' parameter.
  final StudySpec_ParameterSpec_DoubleValueSpec? doubleValueSpec;

  /// The value spec for an 'INTEGER' parameter.
  final StudySpec_ParameterSpec_IntegerValueSpec? integerValueSpec;

  /// The value spec for a 'CATEGORICAL' parameter.
  final StudySpec_ParameterSpec_CategoricalValueSpec? categoricalValueSpec;

  /// The value spec for a 'DISCRETE' parameter.
  final StudySpec_ParameterSpec_DiscreteValueSpec? discreteValueSpec;

  /// Required. The ID of the parameter. Must not contain whitespaces and must
  /// be unique amongst all ParameterSpecs.
  final String? parameterId;

  /// How the parameter should be scaled.
  /// Leave unset for `CATEGORICAL` parameters.
  final StudySpec_ParameterSpec_ScaleType? scaleType;

  /// A conditional parameter node is active if the parameter's value matches
  /// the conditional node's parent_value_condition.
  ///
  /// If two items in conditional_parameter_specs have the same name, they
  /// must have disjoint parent_value_condition.
  final List<StudySpec_ParameterSpec_ConditionalParameterSpec>?
  conditionalParameterSpecs;

  StudySpec_ParameterSpec({
    this.doubleValueSpec,
    this.integerValueSpec,
    this.categoricalValueSpec,
    this.discreteValueSpec,
    this.parameterId,
    this.scaleType,
    this.conditionalParameterSpecs,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec.fromJson(Map<String, dynamic> json) {
    return StudySpec_ParameterSpec(
      doubleValueSpec: decode(
        json['doubleValueSpec'],
        StudySpec_ParameterSpec_DoubleValueSpec.fromJson,
      ),
      integerValueSpec: decode(
        json['integerValueSpec'],
        StudySpec_ParameterSpec_IntegerValueSpec.fromJson,
      ),
      categoricalValueSpec: decode(
        json['categoricalValueSpec'],
        StudySpec_ParameterSpec_CategoricalValueSpec.fromJson,
      ),
      discreteValueSpec: decode(
        json['discreteValueSpec'],
        StudySpec_ParameterSpec_DiscreteValueSpec.fromJson,
      ),
      parameterId: json['parameterId'],
      scaleType: decodeEnum(
        json['scaleType'],
        StudySpec_ParameterSpec_ScaleType.fromJson,
      ),
      conditionalParameterSpecs: decodeListMessage(
        json['conditionalParameterSpecs'],
        StudySpec_ParameterSpec_ConditionalParameterSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (doubleValueSpec != null) 'doubleValueSpec': doubleValueSpec!.toJson(),
      if (integerValueSpec != null)
        'integerValueSpec': integerValueSpec!.toJson(),
      if (categoricalValueSpec != null)
        'categoricalValueSpec': categoricalValueSpec!.toJson(),
      if (discreteValueSpec != null)
        'discreteValueSpec': discreteValueSpec!.toJson(),
      if (parameterId != null) 'parameterId': parameterId,
      if (scaleType != null) 'scaleType': scaleType!.toJson(),
      if (conditionalParameterSpecs != null)
        'conditionalParameterSpecs': encodeList(conditionalParameterSpecs),
    };
  }

  @override
  String toString() {
    final contents = [
      if (parameterId != null) 'parameterId=$parameterId',
      if (scaleType != null) 'scaleType=$scaleType',
    ].join(',');
    return 'ParameterSpec($contents)';
  }
}

/// Value specification for a parameter in `DOUBLE` type.
final class StudySpec_ParameterSpec_DoubleValueSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.DoubleValueSpec';

  /// Required. Inclusive minimum value of the parameter.
  final double? minValue;

  /// Required. Inclusive maximum value of the parameter.
  final double? maxValue;

  /// A default value for a `DOUBLE` parameter that is assumed to be a
  /// relatively good starting point.  Unset value signals that there is no
  /// offered starting point.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported
  /// by HyperparameterTuningJob or TrainingPipeline.
  final double? defaultValue;

  StudySpec_ParameterSpec_DoubleValueSpec({
    this.minValue,
    this.maxValue,
    this.defaultValue,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_DoubleValueSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ParameterSpec_DoubleValueSpec(
      minValue: decodeDouble(json['minValue']),
      maxValue: decodeDouble(json['maxValue']),
      defaultValue: decodeDouble(json['defaultValue']),
    );
  }

  @override
  Object toJson() {
    return {
      if (minValue != null) 'minValue': encodeDouble(minValue),
      if (maxValue != null) 'maxValue': encodeDouble(maxValue),
      if (defaultValue != null) 'defaultValue': encodeDouble(defaultValue),
    };
  }

  @override
  String toString() {
    final contents = [
      if (minValue != null) 'minValue=$minValue',
      if (maxValue != null) 'maxValue=$maxValue',
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'DoubleValueSpec($contents)';
  }
}

/// Value specification for a parameter in `INTEGER` type.
final class StudySpec_ParameterSpec_IntegerValueSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.IntegerValueSpec';

  /// Required. Inclusive minimum value of the parameter.
  final int? minValue;

  /// Required. Inclusive maximum value of the parameter.
  final int? maxValue;

  /// A default value for an `INTEGER` parameter that is assumed to be a
  /// relatively good starting point.  Unset value signals that there is no
  /// offered starting point.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported
  /// by HyperparameterTuningJob or TrainingPipeline.
  final int? defaultValue;

  StudySpec_ParameterSpec_IntegerValueSpec({
    this.minValue,
    this.maxValue,
    this.defaultValue,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_IntegerValueSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ParameterSpec_IntegerValueSpec(
      minValue: decodeInt64(json['minValue']),
      maxValue: decodeInt64(json['maxValue']),
      defaultValue: decodeInt64(json['defaultValue']),
    );
  }

  @override
  Object toJson() {
    return {
      if (minValue != null) 'minValue': encodeInt64(minValue),
      if (maxValue != null) 'maxValue': encodeInt64(maxValue),
      if (defaultValue != null) 'defaultValue': encodeInt64(defaultValue),
    };
  }

  @override
  String toString() {
    final contents = [
      if (minValue != null) 'minValue=$minValue',
      if (maxValue != null) 'maxValue=$maxValue',
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'IntegerValueSpec($contents)';
  }
}

/// Value specification for a parameter in `CATEGORICAL` type.
final class StudySpec_ParameterSpec_CategoricalValueSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.CategoricalValueSpec';

  /// Required. The list of possible categories.
  final List<String>? values;

  /// A default value for a `CATEGORICAL` parameter that is assumed to be a
  /// relatively good starting point.  Unset value signals that there is no
  /// offered starting point.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported
  /// by HyperparameterTuningJob or TrainingPipeline.
  final String? defaultValue;

  StudySpec_ParameterSpec_CategoricalValueSpec({this.values, this.defaultValue})
    : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_CategoricalValueSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ParameterSpec_CategoricalValueSpec(
      values: decodeList(json['values']),
      defaultValue: json['defaultValue'],
    );
  }

  @override
  Object toJson() {
    return {
      if (values != null) 'values': values,
      if (defaultValue != null) 'defaultValue': defaultValue,
    };
  }

  @override
  String toString() {
    final contents = [
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'CategoricalValueSpec($contents)';
  }
}

/// Value specification for a parameter in `DISCRETE` type.
final class StudySpec_ParameterSpec_DiscreteValueSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.DiscreteValueSpec';

  /// Required. A list of possible values.
  /// The list should be in increasing order and at least 1e-10 apart.
  /// For instance, this parameter might have possible settings of 1.5, 2.5,
  /// and 4.0. This list should not contain more than 1,000 values.
  final List<double>? values;

  /// A default value for a `DISCRETE` parameter that is assumed to be a
  /// relatively good starting point.  Unset value signals that there is no
  /// offered starting point.  It automatically rounds to the
  /// nearest feasible discrete point.
  ///
  /// Currently only supported by the Vertex AI Vizier service. Not supported
  /// by HyperparameterTuningJob or TrainingPipeline.
  final double? defaultValue;

  StudySpec_ParameterSpec_DiscreteValueSpec({this.values, this.defaultValue})
    : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_DiscreteValueSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ParameterSpec_DiscreteValueSpec(
      values: decodeList(json['values']),
      defaultValue: decodeDouble(json['defaultValue']),
    );
  }

  @override
  Object toJson() {
    return {
      if (values != null) 'values': values,
      if (defaultValue != null) 'defaultValue': encodeDouble(defaultValue),
    };
  }

  @override
  String toString() {
    final contents = [
      if (defaultValue != null) 'defaultValue=$defaultValue',
    ].join(',');
    return 'DiscreteValueSpec($contents)';
  }
}

/// Represents a parameter spec with condition from its parent parameter.
final class StudySpec_ParameterSpec_ConditionalParameterSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.ConditionalParameterSpec';

  /// The spec for matching values from a parent parameter of
  /// `DISCRETE` type.
  final StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition?
  parentDiscreteValues;

  /// The spec for matching values from a parent parameter of `INTEGER`
  /// type.
  final StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition?
  parentIntValues;

  /// The spec for matching values from a parent parameter of
  /// `CATEGORICAL` type.
  final StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition?
  parentCategoricalValues;

  /// Required. The spec for a conditional parameter.
  final StudySpec_ParameterSpec? parameterSpec;

  StudySpec_ParameterSpec_ConditionalParameterSpec({
    this.parentDiscreteValues,
    this.parentIntValues,
    this.parentCategoricalValues,
    this.parameterSpec,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_ConditionalParameterSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ParameterSpec_ConditionalParameterSpec(
      parentDiscreteValues: decode(
        json['parentDiscreteValues'],
        StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition
            .fromJson,
      ),
      parentIntValues: decode(
        json['parentIntValues'],
        StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition
            .fromJson,
      ),
      parentCategoricalValues: decode(
        json['parentCategoricalValues'],
        StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition
            .fromJson,
      ),
      parameterSpec: decode(
        json['parameterSpec'],
        StudySpec_ParameterSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (parentDiscreteValues != null)
        'parentDiscreteValues': parentDiscreteValues!.toJson(),
      if (parentIntValues != null) 'parentIntValues': parentIntValues!.toJson(),
      if (parentCategoricalValues != null)
        'parentCategoricalValues': parentCategoricalValues!.toJson(),
      if (parameterSpec != null) 'parameterSpec': parameterSpec!.toJson(),
    };
  }

  @override
  String toString() => 'ConditionalParameterSpec()';
}

/// Represents the spec to match discrete values from parent parameter.
final class StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.ConditionalParameterSpec.DiscreteValueCondition';

  /// Required. Matches values of the parent parameter of 'DISCRETE' type.
  /// All values must exist in `discrete_value_spec` of parent parameter.
  ///
  /// The Epsilon of the value matching is 1e-10.
  final List<double>? values;

  StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition({
    this.values,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ParameterSpec_ConditionalParameterSpec_DiscreteValueCondition(
      values: decodeList(json['values']),
    );
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': values};
  }

  @override
  String toString() => 'DiscreteValueCondition()';
}

/// Represents the spec to match integer values from parent parameter.
final class StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.ConditionalParameterSpec.IntValueCondition';

  /// Required. Matches values of the parent parameter of 'INTEGER' type.
  /// All values must lie in `integer_value_spec` of parent parameter.
  final List<int>? values;

  StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition({
    this.values,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ParameterSpec_ConditionalParameterSpec_IntValueCondition(
      values: decodeList(json['values']),
    );
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': values};
  }

  @override
  String toString() => 'IntValueCondition()';
}

/// Represents the spec to match categorical values from parent parameter.
final class StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ParameterSpec.ConditionalParameterSpec.CategoricalValueCondition';

  /// Required. Matches values of the parent parameter of 'CATEGORICAL'
  /// type. All values must exist in `categorical_value_spec` of parent
  /// parameter.
  final List<String>? values;

  StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition({
    this.values,
  }) : super(fullyQualifiedName);

  factory StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ParameterSpec_ConditionalParameterSpec_CategoricalValueCondition(
      values: decodeList(json['values']),
    );
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': values};
  }

  @override
  String toString() => 'CategoricalValueCondition()';
}

/// The type of scaling that should be applied to this parameter.
final class StudySpec_ParameterSpec_ScaleType extends protobuf.ProtoEnum {
  /// By default, no scaling is applied.
  static const scaleTypeUnspecified = StudySpec_ParameterSpec_ScaleType(
    'SCALE_TYPE_UNSPECIFIED',
  );

  /// Scales the feasible space to (0, 1) linearly.
  static const unitLinearScale = StudySpec_ParameterSpec_ScaleType(
    'UNIT_LINEAR_SCALE',
  );

  /// Scales the feasible space logarithmically to (0, 1). The entire
  /// feasible space must be strictly positive.
  static const unitLogScale = StudySpec_ParameterSpec_ScaleType(
    'UNIT_LOG_SCALE',
  );

  /// Scales the feasible space "reverse" logarithmically to (0, 1). The
  /// result is that values close to the top of the feasible space are spread
  /// out more than points near the bottom. The entire feasible space must be
  /// strictly positive.
  static const unitReverseLogScale = StudySpec_ParameterSpec_ScaleType(
    'UNIT_REVERSE_LOG_SCALE',
  );

  const StudySpec_ParameterSpec_ScaleType(super.value);

  factory StudySpec_ParameterSpec_ScaleType.fromJson(String json) =>
      StudySpec_ParameterSpec_ScaleType(json);

  @override
  String toString() => 'ScaleType.$value';
}

/// The decay curve automated stopping rule builds a Gaussian Process
/// Regressor to predict the final objective value of a Trial based on the
/// already completed Trials and the intermediate measurements of the current
/// Trial. Early stopping is requested for the current Trial if there is very
/// low probability to exceed the optimal value found so far.
final class StudySpec_DecayCurveAutomatedStoppingSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.DecayCurveAutomatedStoppingSpec';

  /// True if
  /// `Measurement.elapsed_duration`
  /// is used as the x-axis of each Trials Decay Curve. Otherwise,
  /// `Measurement.step_count`
  /// will be used as the x-axis.
  final bool? useElapsedDuration;

  StudySpec_DecayCurveAutomatedStoppingSpec({this.useElapsedDuration})
    : super(fullyQualifiedName);

  factory StudySpec_DecayCurveAutomatedStoppingSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_DecayCurveAutomatedStoppingSpec(
      useElapsedDuration: json['useElapsedDuration'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useElapsedDuration != null) 'useElapsedDuration': useElapsedDuration,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useElapsedDuration != null) 'useElapsedDuration=$useElapsedDuration',
    ].join(',');
    return 'DecayCurveAutomatedStoppingSpec($contents)';
  }
}

/// The median automated stopping rule stops a pending Trial if the Trial's
/// best objective_value is strictly below the median 'performance' of all
/// completed Trials reported up to the Trial's last measurement.
/// Currently, 'performance' refers to the running average of the objective
/// values reported by the Trial in each measurement.
final class StudySpec_MedianAutomatedStoppingSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.MedianAutomatedStoppingSpec';

  /// True if median automated stopping rule applies on
  /// `Measurement.elapsed_duration`.
  /// It means that elapsed_duration field of latest measurement of current
  /// Trial is used to compute median objective value for each completed
  /// Trials.
  final bool? useElapsedDuration;

  StudySpec_MedianAutomatedStoppingSpec({this.useElapsedDuration})
    : super(fullyQualifiedName);

  factory StudySpec_MedianAutomatedStoppingSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_MedianAutomatedStoppingSpec(
      useElapsedDuration: json['useElapsedDuration'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useElapsedDuration != null) 'useElapsedDuration': useElapsedDuration,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useElapsedDuration != null) 'useElapsedDuration=$useElapsedDuration',
    ].join(',');
    return 'MedianAutomatedStoppingSpec($contents)';
  }
}

/// Configuration for ConvexAutomatedStoppingSpec.
/// When there are enough completed trials (configured by
/// min_measurement_count), for pending trials with enough measurements and
/// steps, the policy first computes an overestimate of the objective value at
/// max_num_steps according to the slope of the incomplete objective value
/// curve. No prediction can be made if the curve is completely flat. If the
/// overestimation is worse than the best objective value of the completed
/// trials, this pending trial will be early-stopped, but a last measurement
/// will be added to the pending trial with max_num_steps and predicted
/// objective value from the autoregression model.
final class StudySpec_ConvexAutomatedStoppingSpec
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ConvexAutomatedStoppingSpec';

  /// Steps used in predicting the final objective for early stopped trials. In
  /// general, it's set to be the same as the defined steps in training /
  /// tuning. If not defined, it will learn it from the completed trials. When
  /// use_steps is false, this field is set to the maximum elapsed seconds.
  final int? maxStepCount;

  /// Minimum number of steps for a trial to complete. Trials which do not have
  /// a measurement with step_count > min_step_count won't be considered for
  /// early stopping. It's ok to set it to 0, and a trial can be early stopped
  /// at any stage. By default, min_step_count is set to be one-tenth of the
  /// max_step_count.
  /// When use_elapsed_duration is true, this field is set to the minimum
  /// elapsed seconds.
  final int? minStepCount;

  /// The minimal number of measurements in a Trial.  Early-stopping checks
  /// will not trigger if less than min_measurement_count+1 completed trials or
  /// pending trials with less than min_measurement_count measurements. If not
  /// defined, the default value is 5.
  final int? minMeasurementCount;

  /// The hyper-parameter name used in the tuning job that stands for learning
  /// rate. Leave it blank if learning rate is not in a parameter in tuning.
  /// The learning_rate is used to estimate the objective value of the ongoing
  /// trial.
  final String? learningRateParameterName;

  /// This bool determines whether or not the rule is applied based on
  /// elapsed_secs or steps. If use_elapsed_duration==false, the early stopping
  /// decision is made according to the predicted objective values according to
  /// the target steps. If use_elapsed_duration==true, elapsed_secs is used
  /// instead of steps. Also, in this case, the parameters max_num_steps and
  /// min_num_steps are overloaded to contain max_elapsed_seconds and
  /// min_elapsed_seconds.
  final bool? useElapsedDuration;

  /// ConvexAutomatedStoppingSpec by default only updates the trials that needs
  /// to be early stopped using a newly trained auto-regressive model. When
  /// this flag is set to True, all stopped trials from the beginning are
  /// potentially updated in terms of their `final_measurement`. Also, note
  /// that the training logic of autoregressive models is different in this
  /// case. Enabling this option has shown better results and this may be the
  /// default option in the future.
  final bool? updateAllStoppedTrials;

  StudySpec_ConvexAutomatedStoppingSpec({
    this.maxStepCount,
    this.minStepCount,
    this.minMeasurementCount,
    this.learningRateParameterName,
    this.useElapsedDuration,
    this.updateAllStoppedTrials,
  }) : super(fullyQualifiedName);

  factory StudySpec_ConvexAutomatedStoppingSpec.fromJson(
    Map<String, dynamic> json,
  ) {
    return StudySpec_ConvexAutomatedStoppingSpec(
      maxStepCount: decodeInt64(json['maxStepCount']),
      minStepCount: decodeInt64(json['minStepCount']),
      minMeasurementCount: decodeInt64(json['minMeasurementCount']),
      learningRateParameterName: json['learningRateParameterName'],
      useElapsedDuration: json['useElapsedDuration'],
      updateAllStoppedTrials: json['updateAllStoppedTrials'],
    );
  }

  @override
  Object toJson() {
    return {
      if (maxStepCount != null) 'maxStepCount': encodeInt64(maxStepCount),
      if (minStepCount != null) 'minStepCount': encodeInt64(minStepCount),
      if (minMeasurementCount != null)
        'minMeasurementCount': encodeInt64(minMeasurementCount),
      if (learningRateParameterName != null)
        'learningRateParameterName': learningRateParameterName,
      if (useElapsedDuration != null) 'useElapsedDuration': useElapsedDuration,
      if (updateAllStoppedTrials != null)
        'updateAllStoppedTrials': updateAllStoppedTrials,
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxStepCount != null) 'maxStepCount=$maxStepCount',
      if (minStepCount != null) 'minStepCount=$minStepCount',
      if (minMeasurementCount != null)
        'minMeasurementCount=$minMeasurementCount',
      if (learningRateParameterName != null)
        'learningRateParameterName=$learningRateParameterName',
      if (useElapsedDuration != null) 'useElapsedDuration=$useElapsedDuration',
      if (updateAllStoppedTrials != null)
        'updateAllStoppedTrials=$updateAllStoppedTrials',
    ].join(',');
    return 'ConvexAutomatedStoppingSpec($contents)';
  }
}

/// Configuration for ConvexStopPolicy.
final class StudySpec_ConvexStopConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.ConvexStopConfig';

  /// Steps used in predicting the final objective for early stopped trials. In
  /// general, it's set to be the same as the defined steps in training /
  /// tuning. When use_steps is false, this field is set to the maximum elapsed
  /// seconds.
  final int? maxNumSteps;

  /// Minimum number of steps for a trial to complete. Trials which do not have
  /// a measurement with num_steps > min_num_steps won't be considered for
  /// early stopping. It's ok to set it to 0, and a trial can be early stopped
  /// at any stage. By default, min_num_steps is set to be one-tenth of the
  /// max_num_steps.
  /// When use_steps is false, this field is set to the minimum elapsed
  /// seconds.
  final int? minNumSteps;

  /// The number of Trial measurements used in autoregressive model for
  /// value prediction. A trial won't be considered early stopping if has fewer
  /// measurement points.
  final int? autoregressiveOrder;

  /// The hyper-parameter name used in the tuning job that stands for learning
  /// rate. Leave it blank if learning rate is not in a parameter in tuning.
  /// The learning_rate is used to estimate the objective value of the ongoing
  /// trial.
  final String? learningRateParameterName;

  /// This bool determines whether or not the rule is applied based on
  /// elapsed_secs or steps. If use_seconds==false, the early stopping decision
  /// is made according to the predicted objective values according to the
  /// target steps. If use_seconds==true, elapsed_secs is used instead of
  /// steps. Also, in this case, the parameters max_num_steps and min_num_steps
  /// are overloaded to contain max_elapsed_seconds and min_elapsed_seconds.
  final bool? useSeconds;

  StudySpec_ConvexStopConfig({
    this.maxNumSteps,
    this.minNumSteps,
    this.autoregressiveOrder,
    this.learningRateParameterName,
    this.useSeconds,
  }) : super(fullyQualifiedName);

  factory StudySpec_ConvexStopConfig.fromJson(Map<String, dynamic> json) {
    return StudySpec_ConvexStopConfig(
      maxNumSteps: decodeInt64(json['maxNumSteps']),
      minNumSteps: decodeInt64(json['minNumSteps']),
      autoregressiveOrder: decodeInt64(json['autoregressiveOrder']),
      learningRateParameterName: json['learningRateParameterName'],
      useSeconds: json['useSeconds'],
    );
  }

  @override
  Object toJson() {
    return {
      if (maxNumSteps != null) 'maxNumSteps': encodeInt64(maxNumSteps),
      if (minNumSteps != null) 'minNumSteps': encodeInt64(minNumSteps),
      if (autoregressiveOrder != null)
        'autoregressiveOrder': encodeInt64(autoregressiveOrder),
      if (learningRateParameterName != null)
        'learningRateParameterName': learningRateParameterName,
      if (useSeconds != null) 'useSeconds': useSeconds,
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxNumSteps != null) 'maxNumSteps=$maxNumSteps',
      if (minNumSteps != null) 'minNumSteps=$minNumSteps',
      if (autoregressiveOrder != null)
        'autoregressiveOrder=$autoregressiveOrder',
      if (learningRateParameterName != null)
        'learningRateParameterName=$learningRateParameterName',
      if (useSeconds != null) 'useSeconds=$useSeconds',
    ].join(',');
    return 'ConvexStopConfig($contents)';
  }
}

/// This contains flag for manually disabling transfer learning for a study.
/// The names of prior studies being used for transfer learning (if any)
/// are also listed here.
final class StudySpec_TransferLearningConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.TransferLearningConfig';

  /// Flag to to manually prevent vizier from using transfer learning on a
  /// new study. Otherwise, vizier will automatically determine whether or not
  /// to use transfer learning.
  final bool? disableTransferLearning;

  /// Output only. Names of previously completed studies
  final List<String>? priorStudyNames;

  StudySpec_TransferLearningConfig({
    this.disableTransferLearning,
    this.priorStudyNames,
  }) : super(fullyQualifiedName);

  factory StudySpec_TransferLearningConfig.fromJson(Map<String, dynamic> json) {
    return StudySpec_TransferLearningConfig(
      disableTransferLearning: json['disableTransferLearning'],
      priorStudyNames: decodeList(json['priorStudyNames']),
    );
  }

  @override
  Object toJson() {
    return {
      if (disableTransferLearning != null)
        'disableTransferLearning': disableTransferLearning,
      if (priorStudyNames != null) 'priorStudyNames': priorStudyNames,
    };
  }

  @override
  String toString() {
    final contents = [
      if (disableTransferLearning != null)
        'disableTransferLearning=$disableTransferLearning',
    ].join(',');
    return 'TransferLearningConfig($contents)';
  }
}

/// The configuration (stopping conditions) for automated stopping of a Study.
/// Conditions include trial budgets, time budgets, and convergence detection.
final class StudySpec_StudyStoppingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StudySpec.StudyStoppingConfig';

  /// If true, a Study enters STOPPING_ASAP whenever it would normally enters
  /// STOPPING state.
  ///
  /// The bottom line is: set to true if you want to interrupt on-going
  /// evaluations of Trials as soon as the study stopping condition is met.
  /// (Please see Study.State documentation for the source of truth).
  final protobuf.BoolValue? shouldStopAsap;

  /// Each "stopping rule" in this proto specifies an "if" condition. Before
  /// Vizier would generate a new suggestion, it first checks each specified
  /// stopping rule, from top to bottom in this list.
  /// Note that the first few rules (e.g. minimum_runtime_constraint,
  /// min_num_trials) will prevent other stopping rules from being evaluated
  /// until they are met. For example, setting `min_num_trials=5` and
  /// `always_stop_after= 1 hour` means that the Study will ONLY stop after it
  /// has 5 COMPLETED trials, even if more than an hour has passed since its
  /// creation. It follows the first applicable rule (whose "if" condition is
  /// satisfied) to make a stopping decision. If none of the specified rules
  /// are applicable, then Vizier decides that the study should not stop.
  /// If Vizier decides that the study should stop, the study enters
  /// STOPPING state (or STOPPING_ASAP if should_stop_asap = true).
  /// IMPORTANT: The automatic study state transition happens precisely as
  /// described above; that is, deleting trials or updating StudyConfig NEVER
  /// automatically moves the study state back to ACTIVE. If you want to
  /// _resume_ a Study that was stopped, 1) change the stopping conditions if
  /// necessary, 2) activate the study, and then 3) ask for suggestions.
  /// If the specified time or duration has not passed, do not stop the
  /// study.
  final StudyTimeConstraint? minimumRuntimeConstraint;

  /// If the specified time or duration has passed, stop the study.
  final StudyTimeConstraint? maximumRuntimeConstraint;

  /// If there are fewer than this many COMPLETED trials, do not stop the
  /// study.
  final protobuf.Int32Value? minNumTrials;

  /// If there are more than this many trials, stop the study.
  final protobuf.Int32Value? maxNumTrials;

  /// If the objective value has not improved for this many consecutive
  /// trials, stop the study.
  ///
  /// WARNING: Effective only for single-objective studies.
  final protobuf.Int32Value? maxNumTrialsNoProgress;

  /// If the objective value has not improved for this much time, stop the
  /// study.
  ///
  /// WARNING: Effective only for single-objective studies.
  final protobuf.Duration? maxDurationNoProgress;

  StudySpec_StudyStoppingConfig({
    this.shouldStopAsap,
    this.minimumRuntimeConstraint,
    this.maximumRuntimeConstraint,
    this.minNumTrials,
    this.maxNumTrials,
    this.maxNumTrialsNoProgress,
    this.maxDurationNoProgress,
  }) : super(fullyQualifiedName);

  factory StudySpec_StudyStoppingConfig.fromJson(Map<String, dynamic> json) {
    return StudySpec_StudyStoppingConfig(
      shouldStopAsap: decodeCustom(
        json['shouldStopAsap'],
        protobuf.BoolValue.fromJson,
      ),
      minimumRuntimeConstraint: decode(
        json['minimumRuntimeConstraint'],
        StudyTimeConstraint.fromJson,
      ),
      maximumRuntimeConstraint: decode(
        json['maximumRuntimeConstraint'],
        StudyTimeConstraint.fromJson,
      ),
      minNumTrials: decodeCustom(
        json['minNumTrials'],
        protobuf.Int32Value.fromJson,
      ),
      maxNumTrials: decodeCustom(
        json['maxNumTrials'],
        protobuf.Int32Value.fromJson,
      ),
      maxNumTrialsNoProgress: decodeCustom(
        json['maxNumTrialsNoProgress'],
        protobuf.Int32Value.fromJson,
      ),
      maxDurationNoProgress: decodeCustom(
        json['maxDurationNoProgress'],
        protobuf.Duration.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (shouldStopAsap != null) 'shouldStopAsap': shouldStopAsap!.toJson(),
      if (minimumRuntimeConstraint != null)
        'minimumRuntimeConstraint': minimumRuntimeConstraint!.toJson(),
      if (maximumRuntimeConstraint != null)
        'maximumRuntimeConstraint': maximumRuntimeConstraint!.toJson(),
      if (minNumTrials != null) 'minNumTrials': minNumTrials!.toJson(),
      if (maxNumTrials != null) 'maxNumTrials': maxNumTrials!.toJson(),
      if (maxNumTrialsNoProgress != null)
        'maxNumTrialsNoProgress': maxNumTrialsNoProgress!.toJson(),
      if (maxDurationNoProgress != null)
        'maxDurationNoProgress': maxDurationNoProgress!.toJson(),
    };
  }

  @override
  String toString() => 'StudyStoppingConfig()';
}

/// The available search algorithms for the Study.
final class StudySpec_Algorithm extends protobuf.ProtoEnum {
  /// The default algorithm used by Vertex AI for [hyperparameter
  /// tuning](https://cloud.google.com/vertex-ai/docs/training/hyperparameter-tuning-overview)
  /// and [Vertex AI Vizier](https://cloud.google.com/vertex-ai/docs/vizier).
  static const algorithmUnspecified = StudySpec_Algorithm(
    'ALGORITHM_UNSPECIFIED',
  );

  /// Simple grid search within the feasible space. To use grid search,
  /// all parameters must be `INTEGER`, `CATEGORICAL`, or `DISCRETE`.
  static const gridSearch = StudySpec_Algorithm('GRID_SEARCH');

  /// Simple random search within the feasible space.
  static const randomSearch = StudySpec_Algorithm('RANDOM_SEARCH');

  const StudySpec_Algorithm(super.value);

  factory StudySpec_Algorithm.fromJson(String json) =>
      StudySpec_Algorithm(json);

  @override
  String toString() => 'Algorithm.$value';
}

/// Describes the noise level of the repeated observations.
///
/// "Noisy" means that the repeated observations with the same Trial parameters
/// may lead to different metric evaluations.
final class StudySpec_ObservationNoise extends protobuf.ProtoEnum {
  /// The default noise level chosen by Vertex AI.
  static const observationNoiseUnspecified = StudySpec_ObservationNoise(
    'OBSERVATION_NOISE_UNSPECIFIED',
  );

  /// Vertex AI assumes that the objective function is (nearly)
  /// perfectly reproducible, and will never repeat the same Trial
  /// parameters.
  static const low = StudySpec_ObservationNoise('LOW');

  /// Vertex AI will estimate the amount of noise in metric
  /// evaluations, it may repeat the same Trial parameters more than once.
  static const high = StudySpec_ObservationNoise('HIGH');

  const StudySpec_ObservationNoise(super.value);

  factory StudySpec_ObservationNoise.fromJson(String json) =>
      StudySpec_ObservationNoise(json);

  @override
  String toString() => 'ObservationNoise.$value';
}

/// This indicates which measurement to use if/when the service automatically
/// selects the final measurement from previously reported intermediate
/// measurements. Choose this based on two considerations:
///  A) Do you expect your measurements to monotonically improve?
///     If so, choose LAST_MEASUREMENT. On the other hand, if you're in a
///     situation where your system can "over-train" and you expect the
///     performance to get better for a while but then start declining,
///     choose BEST_MEASUREMENT.
///  B) Are your measurements significantly noisy and/or irreproducible?
///     If so, BEST_MEASUREMENT will tend to be over-optimistic, and it
///     may be better to choose LAST_MEASUREMENT.
///  If both or neither of (A) and (B) apply, it doesn't matter which
///  selection type is chosen.
final class StudySpec_MeasurementSelectionType extends protobuf.ProtoEnum {
  /// Will be treated as LAST_MEASUREMENT.
  static const measurementSelectionTypeUnspecified =
      StudySpec_MeasurementSelectionType(
        'MEASUREMENT_SELECTION_TYPE_UNSPECIFIED',
      );

  /// Use the last measurement reported.
  static const lastMeasurement = StudySpec_MeasurementSelectionType(
    'LAST_MEASUREMENT',
  );

  /// Use the best measurement reported.
  static const bestMeasurement = StudySpec_MeasurementSelectionType(
    'BEST_MEASUREMENT',
  );

  const StudySpec_MeasurementSelectionType(super.value);

  factory StudySpec_MeasurementSelectionType.fromJson(String json) =>
      StudySpec_MeasurementSelectionType(json);

  @override
  String toString() => 'MeasurementSelectionType.$value';
}

/// A message representing a Measurement of a Trial. A Measurement contains
/// the Metrics got by executing a Trial using suggested hyperparameter
/// values.
final class Measurement extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Measurement';

  /// Output only. Time that the Trial has been running at the point of this
  /// Measurement.
  final protobuf.Duration? elapsedDuration;

  /// Output only. The number of steps the machine learning model has been
  /// trained for. Must be non-negative.
  final int? stepCount;

  /// Output only. A list of metrics got by evaluating the objective functions
  /// using suggested Parameter values.
  final List<Measurement_Metric>? metrics;

  Measurement({this.elapsedDuration, this.stepCount, this.metrics})
    : super(fullyQualifiedName);

  factory Measurement.fromJson(Map<String, dynamic> json) {
    return Measurement(
      elapsedDuration: decodeCustom(
        json['elapsedDuration'],
        protobuf.Duration.fromJson,
      ),
      stepCount: decodeInt64(json['stepCount']),
      metrics: decodeListMessage(json['metrics'], Measurement_Metric.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (elapsedDuration != null) 'elapsedDuration': elapsedDuration!.toJson(),
      if (stepCount != null) 'stepCount': encodeInt64(stepCount),
      if (metrics != null) 'metrics': encodeList(metrics),
    };
  }

  @override
  String toString() {
    final contents = [if (stepCount != null) 'stepCount=$stepCount'].join(',');
    return 'Measurement($contents)';
  }
}

/// A message representing a metric in the measurement.
final class Measurement_Metric extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Measurement.Metric';

  /// Output only. The ID of the Metric. The Metric should be defined in
  /// [StudySpec's Metrics][google.cloud.aiplatform.v1beta1.StudySpec.metrics].
  final String? metricId;

  /// Output only. The value for this metric.
  final double? value;

  Measurement_Metric({this.metricId, this.value}) : super(fullyQualifiedName);

  factory Measurement_Metric.fromJson(Map<String, dynamic> json) {
    return Measurement_Metric(
      metricId: json['metricId'],
      value: decodeDouble(json['value']),
    );
  }

  @override
  Object toJson() {
    return {
      if (metricId != null) 'metricId': metricId,
      if (value != null) 'value': encodeDouble(value),
    };
  }

  @override
  String toString() {
    final contents = [
      if (metricId != null) 'metricId=$metricId',
      if (value != null) 'value=$value',
    ].join(',');
    return 'Metric($contents)';
  }
}

/// Tensorboard is a physical database that stores users' training metrics.
/// A default Tensorboard is provided in each region of a Google Cloud project.
/// If needed users can also create extra Tensorboards in their projects.
final class Tensorboard extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tensorboard';

  /// Output only. Name of the Tensorboard.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String? name;

  /// Required. User provided name of this Tensorboard.
  final String? displayName;

  /// Description of this Tensorboard.
  final String? description;

  /// Customer-managed encryption key spec for a Tensorboard. If set, this
  /// Tensorboard and all sub-resources of this Tensorboard will be secured by
  /// this key.
  final EncryptionSpec? encryptionSpec;

  /// Output only. Consumer project Cloud Storage path prefix used to store blob
  /// data, which can either be a bucket or directory. Does not end with a '/'.
  final String? blobStoragePathPrefix;

  /// Output only. The number of Runs stored in this Tensorboard.
  final int? runCount;

  /// Output only. Timestamp when this Tensorboard was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this Tensorboard was last updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize your Tensorboards.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Tensorboard
  /// (System labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? labels;

  /// Used to perform a consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// Used to indicate if the TensorBoard instance is the default one.
  /// Each project & region can have at most one default TensorBoard instance.
  /// Creation of a default TensorBoard instance and updating an existing
  /// TensorBoard instance to be default will mark all other TensorBoard
  /// instances (if any) as non default.
  final bool? isDefault;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzs;

  /// Output only. Reserved for future use.
  final bool? satisfiesPzi;

  Tensorboard({
    this.name,
    this.displayName,
    this.description,
    this.encryptionSpec,
    this.blobStoragePathPrefix,
    this.runCount,
    this.createTime,
    this.updateTime,
    this.labels,
    this.etag,
    this.isDefault,
    this.satisfiesPzs,
    this.satisfiesPzi,
  }) : super(fullyQualifiedName);

  factory Tensorboard.fromJson(Map<String, dynamic> json) {
    return Tensorboard(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      blobStoragePathPrefix: json['blobStoragePathPrefix'],
      runCount: json['runCount'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      etag: json['etag'],
      isDefault: json['isDefault'],
      satisfiesPzs: json['satisfiesPzs'],
      satisfiesPzi: json['satisfiesPzi'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (blobStoragePathPrefix != null)
        'blobStoragePathPrefix': blobStoragePathPrefix,
      if (runCount != null) 'runCount': runCount,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (etag != null) 'etag': etag,
      if (isDefault != null) 'isDefault': isDefault,
      if (satisfiesPzs != null) 'satisfiesPzs': satisfiesPzs,
      if (satisfiesPzi != null) 'satisfiesPzi': satisfiesPzi,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (blobStoragePathPrefix != null)
        'blobStoragePathPrefix=$blobStoragePathPrefix',
      if (runCount != null) 'runCount=$runCount',
      if (etag != null) 'etag=$etag',
      if (isDefault != null) 'isDefault=$isDefault',
      if (satisfiesPzs != null) 'satisfiesPzs=$satisfiesPzs',
      if (satisfiesPzi != null) 'satisfiesPzi=$satisfiesPzi',
    ].join(',');
    return 'Tensorboard($contents)';
  }
}

/// All the data stored in a TensorboardTimeSeries.
final class TimeSeriesData extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TimeSeriesData';

  /// Required. The ID of the TensorboardTimeSeries, which will become the final
  /// component of the TensorboardTimeSeries' resource name
  final String? tensorboardTimeSeriesId;

  /// Required. Immutable. The value type of this time series. All the values in
  /// this time series data must match this value type.
  final TensorboardTimeSeries_ValueType? valueType;

  /// Required. Data points in this time series.
  final List<TimeSeriesDataPoint>? values;

  TimeSeriesData({this.tensorboardTimeSeriesId, this.valueType, this.values})
    : super(fullyQualifiedName);

  factory TimeSeriesData.fromJson(Map<String, dynamic> json) {
    return TimeSeriesData(
      tensorboardTimeSeriesId: json['tensorboardTimeSeriesId'],
      valueType: decodeEnum(
        json['valueType'],
        TensorboardTimeSeries_ValueType.fromJson,
      ),
      values: decodeListMessage(json['values'], TimeSeriesDataPoint.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (tensorboardTimeSeriesId != null)
        'tensorboardTimeSeriesId': tensorboardTimeSeriesId,
      if (valueType != null) 'valueType': valueType!.toJson(),
      if (values != null) 'values': encodeList(values),
    };
  }

  @override
  String toString() {
    final contents = [
      if (tensorboardTimeSeriesId != null)
        'tensorboardTimeSeriesId=$tensorboardTimeSeriesId',
      if (valueType != null) 'valueType=$valueType',
    ].join(',');
    return 'TimeSeriesData($contents)';
  }
}

/// A TensorboardTimeSeries data point.
final class TimeSeriesDataPoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TimeSeriesDataPoint';

  /// A scalar value.
  final Scalar? scalar;

  /// A tensor value.
  final TensorboardTensor? tensor;

  /// A blob sequence value.
  final TensorboardBlobSequence? blobs;

  /// Wall clock timestamp when this data point is generated by the end user.
  final protobuf.Timestamp? wallTime;

  /// Step index of this data point within the run.
  final int? step;

  TimeSeriesDataPoint({
    this.scalar,
    this.tensor,
    this.blobs,
    this.wallTime,
    this.step,
  }) : super(fullyQualifiedName);

  factory TimeSeriesDataPoint.fromJson(Map<String, dynamic> json) {
    return TimeSeriesDataPoint(
      scalar: decode(json['scalar'], Scalar.fromJson),
      tensor: decode(json['tensor'], TensorboardTensor.fromJson),
      blobs: decode(json['blobs'], TensorboardBlobSequence.fromJson),
      wallTime: decodeCustom(json['wallTime'], protobuf.Timestamp.fromJson),
      step: decodeInt64(json['step']),
    );
  }

  @override
  Object toJson() {
    return {
      if (scalar != null) 'scalar': scalar!.toJson(),
      if (tensor != null) 'tensor': tensor!.toJson(),
      if (blobs != null) 'blobs': blobs!.toJson(),
      if (wallTime != null) 'wallTime': wallTime!.toJson(),
      if (step != null) 'step': encodeInt64(step),
    };
  }

  @override
  String toString() {
    final contents = [if (step != null) 'step=$step'].join(',');
    return 'TimeSeriesDataPoint($contents)';
  }
}

/// One point viewable on a scalar metric plot.
final class Scalar extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Scalar';

  /// Value of the point at this step / timestamp.
  final double? value;

  Scalar({this.value}) : super(fullyQualifiedName);

  factory Scalar.fromJson(Map<String, dynamic> json) {
    return Scalar(value: decodeDouble(json['value']));
  }

  @override
  Object toJson() {
    return {if (value != null) 'value': encodeDouble(value)};
  }

  @override
  String toString() {
    final contents = [if (value != null) 'value=$value'].join(',');
    return 'Scalar($contents)';
  }
}

/// One point viewable on a tensor metric plot.
final class TensorboardTensor extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardTensor';

  /// Required. Serialized form of
  /// https://github.com/tensorflow/tensorflow/blob/master/tensorflow/core/framework/tensor.proto
  final Uint8List? value;

  /// Optional. Version number of TensorProto used to serialize
  /// `value`.
  final int? versionNumber;

  TensorboardTensor({this.value, this.versionNumber})
    : super(fullyQualifiedName);

  factory TensorboardTensor.fromJson(Map<String, dynamic> json) {
    return TensorboardTensor(
      value: decodeBytes(json['value']),
      versionNumber: json['versionNumber'],
    );
  }

  @override
  Object toJson() {
    return {
      if (value != null) 'value': encodeBytes(value),
      if (versionNumber != null) 'versionNumber': versionNumber,
    };
  }

  @override
  String toString() {
    final contents = [
      if (value != null) 'value=$value',
      if (versionNumber != null) 'versionNumber=$versionNumber',
    ].join(',');
    return 'TensorboardTensor($contents)';
  }
}

/// One point viewable on a blob metric plot, but mostly just a wrapper message
/// to work around repeated fields can't be used directly within `oneof` fields.
final class TensorboardBlobSequence extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardBlobSequence';

  /// List of blobs contained within the sequence.
  final List<TensorboardBlob>? values;

  TensorboardBlobSequence({this.values}) : super(fullyQualifiedName);

  factory TensorboardBlobSequence.fromJson(Map<String, dynamic> json) {
    return TensorboardBlobSequence(
      values: decodeListMessage(json['values'], TensorboardBlob.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': encodeList(values)};
  }

  @override
  String toString() => 'TensorboardBlobSequence()';
}

/// One blob (e.g, image, graph) viewable on a blob metric plot.
final class TensorboardBlob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardBlob';

  /// Output only. A URI safe key uniquely identifying a blob. Can be used to
  /// locate the blob stored in the Cloud Storage bucket of the consumer project.
  final String? id;

  /// Optional. The bytes of the blob is not present unless it's returned by the
  /// ReadTensorboardBlobData endpoint.
  final Uint8List? data;

  TensorboardBlob({this.id, this.data}) : super(fullyQualifiedName);

  factory TensorboardBlob.fromJson(Map<String, dynamic> json) {
    return TensorboardBlob(id: json['id'], data: decodeBytes(json['data']));
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (data != null) 'data': encodeBytes(data),
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      if (data != null) 'data=$data',
    ].join(',');
    return 'TensorboardBlob($contents)';
  }
}

/// A TensorboardExperiment is a group of TensorboardRuns, that are typically the
/// results of a training job run, in a Tensorboard.
final class TensorboardExperiment extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardExperiment';

  /// Output only. Name of the TensorboardExperiment.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String? name;

  /// User provided name of this TensorboardExperiment.
  final String? displayName;

  /// Description of this TensorboardExperiment.
  final String? description;

  /// Output only. Timestamp when this TensorboardExperiment was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this TensorboardExperiment was last updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize your
  /// TensorboardExperiment.
  ///
  /// Label keys and values cannot be longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one Dataset (System
  /// labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with `aiplatform.googleapis.com/`
  /// and are immutable. The following system labels exist for each Dataset:
  ///
  /// * `aiplatform.googleapis.com/dataset_metadata_schema`: output only. Its
  ///    value is the
  ///    [metadata_schema's][google.cloud.aiplatform.v1beta1.Dataset.metadata_schema_uri]
  ///    title.
  final Map<String, String>? labels;

  /// Used to perform consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// Immutable. Source of the TensorboardExperiment. Example: a custom training
  /// job.
  final String? source;

  TensorboardExperiment({
    this.name,
    this.displayName,
    this.description,
    this.createTime,
    this.updateTime,
    this.labels,
    this.etag,
    this.source,
  }) : super(fullyQualifiedName);

  factory TensorboardExperiment.fromJson(Map<String, dynamic> json) {
    return TensorboardExperiment(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      etag: json['etag'],
      source: json['source'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (etag != null) 'etag': etag,
      if (source != null) 'source': source,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (etag != null) 'etag=$etag',
      if (source != null) 'source=$source',
    ].join(',');
    return 'TensorboardExperiment($contents)';
  }
}

/// TensorboardRun maps to a specific execution of a training job with a given
/// set of hyperparameter values, model definition, dataset, etc
final class TensorboardRun extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardRun';

  /// Output only. Name of the TensorboardRun.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String? name;

  /// Required. User provided name of this TensorboardRun.
  /// This value must be unique among all TensorboardRuns
  /// belonging to the same parent TensorboardExperiment.
  final String? displayName;

  /// Description of this TensorboardRun.
  final String? description;

  /// Output only. Timestamp when this TensorboardRun was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this TensorboardRun was last updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize your TensorboardRuns.
  ///
  /// This field will be used to filter and visualize Runs in the Tensorboard UI.
  /// For example, a Vertex AI training job can set a label
  /// aiplatform.googleapis.com/training_job_id=xxxxx to all the runs created
  /// within that job. An end user can set a label experiment_id=xxxxx for all
  /// the runs produced in a Jupyter notebook. These runs can be grouped by a
  /// label value and visualized together in the Tensorboard UI.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  /// No more than 64 user labels can be associated with one TensorboardRun
  /// (System labels are excluded).
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  /// System reserved label keys are prefixed with "aiplatform.googleapis.com/"
  /// and are immutable.
  final Map<String, String>? labels;

  /// Used to perform a consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  TensorboardRun({
    this.name,
    this.displayName,
    this.description,
    this.createTime,
    this.updateTime,
    this.labels,
    this.etag,
  }) : super(fullyQualifiedName);

  factory TensorboardRun.fromJson(Map<String, dynamic> json) {
    return TensorboardRun(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      etag: json['etag'],
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (etag != null) 'etag': etag,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (etag != null) 'etag=$etag',
    ].join(',');
    return 'TensorboardRun($contents)';
  }
}

/// Request message for
/// `TensorboardService.CreateTensorboard`.
final class CreateTensorboardRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardRequest';

  /// Required. The resource name of the Location to create the Tensorboard in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Tensorboard to create.
  final Tensorboard tensorboard;

  CreateTensorboardRequest({required this.parent, required this.tensorboard})
    : super(fullyQualifiedName);

  factory CreateTensorboardRequest.fromJson(Map<String, dynamic> json) {
    return CreateTensorboardRequest(
      parent: json['parent'],
      tensorboard: decode(json['tensorboard'], Tensorboard.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'tensorboard': tensorboard.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateTensorboardRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.GetTensorboard`.
final class GetTensorboardRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTensorboardRequest';

  /// Required. The name of the Tensorboard resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String name;

  GetTensorboardRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTensorboardRequest.fromJson(Map<String, dynamic> json) {
    return GetTensorboardRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTensorboardRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ListTensorboards`.
final class ListTensorboardsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardsRequest';

  /// Required. The resource name of the Location to list Tensorboards.
  /// Format:
  /// `projects/{project}/locations/{location}`
  final String parent;

  /// Lists the Tensorboards that match the filter expression.
  final String? filter;

  /// The maximum number of Tensorboards to return. The service may return
  /// fewer than this value. If unspecified, at most 100 Tensorboards are
  /// returned. The maximum value is 100; values above 100 are coerced to
  /// 100.
  final int? pageSize;

  /// A page token, received from a previous
  /// `TensorboardService.ListTensorboards`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `TensorboardService.ListTensorboards`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// Field to use to sort the list.
  final String? orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTensorboardsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTensorboardsRequest.fromJson(Map<String, dynamic> json) {
    return ListTensorboardsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListTensorboardsRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ListTensorboards`.
final class ListTensorboardsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardsResponse';

  /// The Tensorboards mathching the request.
  final List<Tensorboard>? tensorboards;

  /// A token, which can be sent as
  /// `ListTensorboardsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListTensorboardsResponse({this.tensorboards, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListTensorboardsResponse.fromJson(Map<String, dynamic> json) {
    return ListTensorboardsResponse(
      tensorboards: decodeListMessage(
        json['tensorboards'],
        Tensorboard.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tensorboards != null) 'tensorboards': encodeList(tensorboards),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListTensorboardsResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.UpdateTensorboard`.
final class UpdateTensorboardRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardRequest';

  /// Required. Field mask is used to specify the fields to be overwritten in the
  /// Tensorboard resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field is overwritten if it's in the mask. If the
  /// user does not provide a mask then all fields are overwritten if new
  /// values are specified.
  final protobuf.FieldMask? updateMask;

  /// Required. The Tensorboard's `name` field is used to identify the
  /// Tensorboard to be updated. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final Tensorboard tensorboard;

  UpdateTensorboardRequest({this.updateMask, required this.tensorboard})
    : super(fullyQualifiedName);

  factory UpdateTensorboardRequest.fromJson(Map<String, dynamic> json) {
    return UpdateTensorboardRequest(
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
      tensorboard: decode(json['tensorboard'], Tensorboard.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
      'tensorboard': tensorboard.toJson(),
    };
  }

  @override
  String toString() => 'UpdateTensorboardRequest()';
}

/// Request message for
/// `TensorboardService.DeleteTensorboard`.
final class DeleteTensorboardRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTensorboardRequest';

  /// Required. The name of the Tensorboard to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String name;

  DeleteTensorboardRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteTensorboardRequest.fromJson(Map<String, dynamic> json) {
    return DeleteTensorboardRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTensorboardRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ReadTensorboardUsage`.
final class ReadTensorboardUsageRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardUsageRequest';

  /// Required. The name of the Tensorboard resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String tensorboard;

  ReadTensorboardUsageRequest({required this.tensorboard})
    : super(fullyQualifiedName);

  factory ReadTensorboardUsageRequest.fromJson(Map<String, dynamic> json) {
    return ReadTensorboardUsageRequest(tensorboard: json['tensorboard']);
  }

  @override
  Object toJson() {
    return {'tensorboard': tensorboard};
  }

  @override
  String toString() {
    final contents = ['tensorboard=$tensorboard'].join(',');
    return 'ReadTensorboardUsageRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ReadTensorboardUsage`.
final class ReadTensorboardUsageResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardUsageResponse';

  /// Maps year-month (YYYYMM) string to per month usage data.
  final Map<String, ReadTensorboardUsageResponse_PerMonthUsageData>?
  monthlyUsageData;

  ReadTensorboardUsageResponse({this.monthlyUsageData})
    : super(fullyQualifiedName);

  factory ReadTensorboardUsageResponse.fromJson(Map<String, dynamic> json) {
    return ReadTensorboardUsageResponse(
      monthlyUsageData: decodeMapMessage(
        json['monthlyUsageData'],
        ReadTensorboardUsageResponse_PerMonthUsageData.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (monthlyUsageData != null)
        'monthlyUsageData': encodeMap(monthlyUsageData),
    };
  }

  @override
  String toString() => 'ReadTensorboardUsageResponse()';
}

/// Per user usage data.
final class ReadTensorboardUsageResponse_PerUserUsageData
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardUsageResponse.PerUserUsageData';

  /// User's username
  final String? username;

  /// Number of times the user has read data within the Tensorboard.
  final int? viewCount;

  ReadTensorboardUsageResponse_PerUserUsageData({this.username, this.viewCount})
    : super(fullyQualifiedName);

  factory ReadTensorboardUsageResponse_PerUserUsageData.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReadTensorboardUsageResponse_PerUserUsageData(
      username: json['username'],
      viewCount: decodeInt64(json['viewCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (username != null) 'username': username,
      if (viewCount != null) 'viewCount': encodeInt64(viewCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (username != null) 'username=$username',
      if (viewCount != null) 'viewCount=$viewCount',
    ].join(',');
    return 'PerUserUsageData($contents)';
  }
}

/// Per month usage data
final class ReadTensorboardUsageResponse_PerMonthUsageData
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardUsageResponse.PerMonthUsageData';

  /// Usage data for each user in the given month.
  final List<ReadTensorboardUsageResponse_PerUserUsageData>? userUsageData;

  ReadTensorboardUsageResponse_PerMonthUsageData({this.userUsageData})
    : super(fullyQualifiedName);

  factory ReadTensorboardUsageResponse_PerMonthUsageData.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReadTensorboardUsageResponse_PerMonthUsageData(
      userUsageData: decodeListMessage(
        json['userUsageData'],
        ReadTensorboardUsageResponse_PerUserUsageData.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (userUsageData != null) 'userUsageData': encodeList(userUsageData),
    };
  }

  @override
  String toString() => 'PerMonthUsageData()';
}

/// Request message for
/// `TensorboardService.ReadTensorboardSize`.
final class ReadTensorboardSizeRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardSizeRequest';

  /// Required. The name of the Tensorboard resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String tensorboard;

  ReadTensorboardSizeRequest({required this.tensorboard})
    : super(fullyQualifiedName);

  factory ReadTensorboardSizeRequest.fromJson(Map<String, dynamic> json) {
    return ReadTensorboardSizeRequest(tensorboard: json['tensorboard']);
  }

  @override
  Object toJson() {
    return {'tensorboard': tensorboard};
  }

  @override
  String toString() {
    final contents = ['tensorboard=$tensorboard'].join(',');
    return 'ReadTensorboardSizeRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ReadTensorboardSize`.
final class ReadTensorboardSizeResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardSizeResponse';

  /// Payload storage size for the TensorBoard
  final int? storageSizeByte;

  ReadTensorboardSizeResponse({this.storageSizeByte})
    : super(fullyQualifiedName);

  factory ReadTensorboardSizeResponse.fromJson(Map<String, dynamic> json) {
    return ReadTensorboardSizeResponse(
      storageSizeByte: decodeInt64(json['storageSizeByte']),
    );
  }

  @override
  Object toJson() {
    return {
      if (storageSizeByte != null)
        'storageSizeByte': encodeInt64(storageSizeByte),
    };
  }

  @override
  String toString() {
    final contents = [
      if (storageSizeByte != null) 'storageSizeByte=$storageSizeByte',
    ].join(',');
    return 'ReadTensorboardSizeResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.CreateTensorboardExperiment`.
final class CreateTensorboardExperimentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardExperimentRequest';

  /// Required. The resource name of the Tensorboard to create the
  /// TensorboardExperiment in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String parent;

  /// The TensorboardExperiment to create.
  final TensorboardExperiment tensorboardExperiment;

  /// Required. The ID to use for the Tensorboard experiment, which becomes the
  /// final component of the Tensorboard experiment's resource name.
  ///
  /// This value should be 1-128 characters, and valid characters
  /// are `/[a-z][0-9]-/`.
  final String? tensorboardExperimentId;

  CreateTensorboardExperimentRequest({
    required this.parent,
    required this.tensorboardExperiment,
    this.tensorboardExperimentId,
  }) : super(fullyQualifiedName);

  factory CreateTensorboardExperimentRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateTensorboardExperimentRequest(
      parent: json['parent'],
      tensorboardExperiment: decode(
        json['tensorboardExperiment'],
        TensorboardExperiment.fromJson,
      )!,
      tensorboardExperimentId: json['tensorboardExperimentId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'tensorboardExperiment': tensorboardExperiment.toJson(),
      if (tensorboardExperimentId != null)
        'tensorboardExperimentId': tensorboardExperimentId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (tensorboardExperimentId != null)
        'tensorboardExperimentId=$tensorboardExperimentId',
    ].join(',');
    return 'CreateTensorboardExperimentRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.GetTensorboardExperiment`.
final class GetTensorboardExperimentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTensorboardExperimentRequest';

  /// Required. The name of the TensorboardExperiment resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String name;

  GetTensorboardExperimentRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetTensorboardExperimentRequest.fromJson(Map<String, dynamic> json) {
    return GetTensorboardExperimentRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTensorboardExperimentRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ListTensorboardExperiments`.
final class ListTensorboardExperimentsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardExperimentsRequest';

  /// Required. The resource name of the Tensorboard to list
  /// TensorboardExperiments. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`
  final String parent;

  /// Lists the TensorboardExperiments that match the filter expression.
  final String? filter;

  /// The maximum number of TensorboardExperiments to return. The service may
  /// return fewer than this value. If unspecified, at most 50
  /// TensorboardExperiments are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  final int? pageSize;

  /// A page token, received from a previous
  /// `TensorboardService.ListTensorboardExperiments`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `TensorboardService.ListTensorboardExperiments`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// Field to use to sort the list.
  final String? orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTensorboardExperimentsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTensorboardExperimentsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListTensorboardExperimentsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListTensorboardExperimentsRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ListTensorboardExperiments`.
final class ListTensorboardExperimentsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardExperimentsResponse';

  /// The TensorboardExperiments mathching the request.
  final List<TensorboardExperiment>? tensorboardExperiments;

  /// A token, which can be sent as
  /// `ListTensorboardExperimentsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListTensorboardExperimentsResponse({
    this.tensorboardExperiments,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListTensorboardExperimentsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListTensorboardExperimentsResponse(
      tensorboardExperiments: decodeListMessage(
        json['tensorboardExperiments'],
        TensorboardExperiment.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tensorboardExperiments != null)
        'tensorboardExperiments': encodeList(tensorboardExperiments),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListTensorboardExperimentsResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.UpdateTensorboardExperiment`.
final class UpdateTensorboardExperimentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardExperimentRequest';

  /// Required. Field mask is used to specify the fields to be overwritten in the
  /// TensorboardExperiment resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field is overwritten if it's in the mask. If the
  /// user does not provide a mask then all fields are overwritten if new
  /// values are specified.
  final protobuf.FieldMask? updateMask;

  /// Required. The TensorboardExperiment's `name` field is used to identify the
  /// TensorboardExperiment to be updated. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final TensorboardExperiment tensorboardExperiment;

  UpdateTensorboardExperimentRequest({
    this.updateMask,
    required this.tensorboardExperiment,
  }) : super(fullyQualifiedName);

  factory UpdateTensorboardExperimentRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateTensorboardExperimentRequest(
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
      tensorboardExperiment: decode(
        json['tensorboardExperiment'],
        TensorboardExperiment.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
      'tensorboardExperiment': tensorboardExperiment.toJson(),
    };
  }

  @override
  String toString() => 'UpdateTensorboardExperimentRequest()';
}

/// Request message for
/// `TensorboardService.DeleteTensorboardExperiment`.
final class DeleteTensorboardExperimentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTensorboardExperimentRequest';

  /// Required. The name of the TensorboardExperiment to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String name;

  DeleteTensorboardExperimentRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteTensorboardExperimentRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteTensorboardExperimentRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTensorboardExperimentRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.BatchCreateTensorboardRuns`.
final class BatchCreateTensorboardRunsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateTensorboardRunsRequest';

  /// Required. The resource name of the TensorboardExperiment to create the
  /// TensorboardRuns in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The parent field in the CreateTensorboardRunRequest messages must match
  /// this field.
  final String parent;

  /// Required. The request message specifying the TensorboardRuns to create.
  /// A maximum of 1000 TensorboardRuns can be created in a batch.
  final List<CreateTensorboardRunRequest>? requests;

  BatchCreateTensorboardRunsRequest({required this.parent, this.requests})
    : super(fullyQualifiedName);

  factory BatchCreateTensorboardRunsRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchCreateTensorboardRunsRequest(
      parent: json['parent'],
      requests: decodeListMessage(
        json['requests'],
        CreateTensorboardRunRequest.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (requests != null) 'requests': encodeList(requests),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchCreateTensorboardRunsRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.BatchCreateTensorboardRuns`.
final class BatchCreateTensorboardRunsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateTensorboardRunsResponse';

  /// The created TensorboardRuns.
  final List<TensorboardRun>? tensorboardRuns;

  BatchCreateTensorboardRunsResponse({this.tensorboardRuns})
    : super(fullyQualifiedName);

  factory BatchCreateTensorboardRunsResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchCreateTensorboardRunsResponse(
      tensorboardRuns: decodeListMessage(
        json['tensorboardRuns'],
        TensorboardRun.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (tensorboardRuns != null)
        'tensorboardRuns': encodeList(tensorboardRuns),
    };
  }

  @override
  String toString() => 'BatchCreateTensorboardRunsResponse()';
}

/// Request message for
/// `TensorboardService.CreateTensorboardRun`.
final class CreateTensorboardRunRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardRunRequest';

  /// Required. The resource name of the TensorboardExperiment to create the
  /// TensorboardRun in. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String parent;

  /// Required. The TensorboardRun to create.
  final TensorboardRun tensorboardRun;

  /// Required. The ID to use for the Tensorboard run, which becomes the final
  /// component of the Tensorboard run's resource name.
  ///
  /// This value should be 1-128 characters, and valid characters
  /// are `/[a-z][0-9]-/`.
  final String? tensorboardRunId;

  CreateTensorboardRunRequest({
    required this.parent,
    required this.tensorboardRun,
    this.tensorboardRunId,
  }) : super(fullyQualifiedName);

  factory CreateTensorboardRunRequest.fromJson(Map<String, dynamic> json) {
    return CreateTensorboardRunRequest(
      parent: json['parent'],
      tensorboardRun: decode(json['tensorboardRun'], TensorboardRun.fromJson)!,
      tensorboardRunId: json['tensorboardRunId'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      'tensorboardRun': tensorboardRun.toJson(),
      if (tensorboardRunId != null) 'tensorboardRunId': tensorboardRunId,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (tensorboardRunId != null) 'tensorboardRunId=$tensorboardRunId',
    ].join(',');
    return 'CreateTensorboardRunRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.GetTensorboardRun`.
final class GetTensorboardRunRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTensorboardRunRequest';

  /// Required. The name of the TensorboardRun resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String name;

  GetTensorboardRunRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTensorboardRunRequest.fromJson(Map<String, dynamic> json) {
    return GetTensorboardRunRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTensorboardRunRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ReadTensorboardBlobData`.
final class ReadTensorboardBlobDataRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardBlobDataRequest';

  /// Required. The resource name of the TensorboardTimeSeries to list Blobs.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String timeSeries;

  /// IDs of the blobs to read.
  final List<String>? blobIds;

  ReadTensorboardBlobDataRequest({required this.timeSeries, this.blobIds})
    : super(fullyQualifiedName);

  factory ReadTensorboardBlobDataRequest.fromJson(Map<String, dynamic> json) {
    return ReadTensorboardBlobDataRequest(
      timeSeries: json['timeSeries'],
      blobIds: decodeList(json['blobIds']),
    );
  }

  @override
  Object toJson() {
    return {'timeSeries': timeSeries, if (blobIds != null) 'blobIds': blobIds};
  }

  @override
  String toString() {
    final contents = ['timeSeries=$timeSeries'].join(',');
    return 'ReadTensorboardBlobDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ReadTensorboardBlobData`.
final class ReadTensorboardBlobDataResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardBlobDataResponse';

  /// Blob messages containing blob bytes.
  final List<TensorboardBlob>? blobs;

  ReadTensorboardBlobDataResponse({this.blobs}) : super(fullyQualifiedName);

  factory ReadTensorboardBlobDataResponse.fromJson(Map<String, dynamic> json) {
    return ReadTensorboardBlobDataResponse(
      blobs: decodeListMessage(json['blobs'], TensorboardBlob.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (blobs != null) 'blobs': encodeList(blobs)};
  }

  @override
  String toString() => 'ReadTensorboardBlobDataResponse()';
}

/// Request message for
/// `TensorboardService.ListTensorboardRuns`.
final class ListTensorboardRunsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardRunsRequest';

  /// Required. The resource name of the TensorboardExperiment to list
  /// TensorboardRuns. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String parent;

  /// Lists the TensorboardRuns that match the filter expression.
  final String? filter;

  /// The maximum number of TensorboardRuns to return. The service may return
  /// fewer than this value. If unspecified, at most 50 TensorboardRuns are
  /// returned. The maximum value is 1000; values above 1000 are coerced to
  /// 1000.
  final int? pageSize;

  /// A page token, received from a previous
  /// `TensorboardService.ListTensorboardRuns`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `TensorboardService.ListTensorboardRuns`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// Field to use to sort the list.
  final String? orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTensorboardRunsRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTensorboardRunsRequest.fromJson(Map<String, dynamic> json) {
    return ListTensorboardRunsRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListTensorboardRunsRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ListTensorboardRuns`.
final class ListTensorboardRunsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardRunsResponse';

  /// The TensorboardRuns mathching the request.
  final List<TensorboardRun>? tensorboardRuns;

  /// A token, which can be sent as
  /// `ListTensorboardRunsRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListTensorboardRunsResponse({this.tensorboardRuns, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListTensorboardRunsResponse.fromJson(Map<String, dynamic> json) {
    return ListTensorboardRunsResponse(
      tensorboardRuns: decodeListMessage(
        json['tensorboardRuns'],
        TensorboardRun.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tensorboardRuns != null)
        'tensorboardRuns': encodeList(tensorboardRuns),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListTensorboardRunsResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.UpdateTensorboardRun`.
final class UpdateTensorboardRunRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardRunRequest';

  /// Required. Field mask is used to specify the fields to be overwritten in the
  /// TensorboardRun resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field is overwritten if it's in the mask. If the
  /// user does not provide a mask then all fields are overwritten if new
  /// values are specified.
  final protobuf.FieldMask? updateMask;

  /// Required. The TensorboardRun's `name` field is used to identify the
  /// TensorboardRun to be updated. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final TensorboardRun tensorboardRun;

  UpdateTensorboardRunRequest({this.updateMask, required this.tensorboardRun})
    : super(fullyQualifiedName);

  factory UpdateTensorboardRunRequest.fromJson(Map<String, dynamic> json) {
    return UpdateTensorboardRunRequest(
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
      tensorboardRun: decode(json['tensorboardRun'], TensorboardRun.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
      'tensorboardRun': tensorboardRun.toJson(),
    };
  }

  @override
  String toString() => 'UpdateTensorboardRunRequest()';
}

/// Request message for
/// `TensorboardService.DeleteTensorboardRun`.
final class DeleteTensorboardRunRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTensorboardRunRequest';

  /// Required. The name of the TensorboardRun to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String name;

  DeleteTensorboardRunRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteTensorboardRunRequest.fromJson(Map<String, dynamic> json) {
    return DeleteTensorboardRunRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTensorboardRunRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.BatchCreateTensorboardTimeSeries`.
final class BatchCreateTensorboardTimeSeriesRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateTensorboardTimeSeriesRequest';

  /// Required. The resource name of the TensorboardExperiment to create the
  /// TensorboardTimeSeries in.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  /// The TensorboardRuns referenced by the parent fields in the
  /// CreateTensorboardTimeSeriesRequest messages must be sub resources of this
  /// TensorboardExperiment.
  final String parent;

  /// Required. The request message specifying the TensorboardTimeSeries to
  /// create. A maximum of 1000 TensorboardTimeSeries can be created in a batch.
  final List<CreateTensorboardTimeSeriesRequest>? requests;

  BatchCreateTensorboardTimeSeriesRequest({required this.parent, this.requests})
    : super(fullyQualifiedName);

  factory BatchCreateTensorboardTimeSeriesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchCreateTensorboardTimeSeriesRequest(
      parent: json['parent'],
      requests: decodeListMessage(
        json['requests'],
        CreateTensorboardTimeSeriesRequest.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (requests != null) 'requests': encodeList(requests),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'BatchCreateTensorboardTimeSeriesRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.BatchCreateTensorboardTimeSeries`.
final class BatchCreateTensorboardTimeSeriesResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchCreateTensorboardTimeSeriesResponse';

  /// The created TensorboardTimeSeries.
  final List<TensorboardTimeSeries>? tensorboardTimeSeries;

  BatchCreateTensorboardTimeSeriesResponse({this.tensorboardTimeSeries})
    : super(fullyQualifiedName);

  factory BatchCreateTensorboardTimeSeriesResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchCreateTensorboardTimeSeriesResponse(
      tensorboardTimeSeries: decodeListMessage(
        json['tensorboardTimeSeries'],
        TensorboardTimeSeries.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (tensorboardTimeSeries != null)
        'tensorboardTimeSeries': encodeList(tensorboardTimeSeries),
    };
  }

  @override
  String toString() => 'BatchCreateTensorboardTimeSeriesResponse()';
}

/// Request message for
/// `TensorboardService.CreateTensorboardTimeSeries`.
final class CreateTensorboardTimeSeriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardTimeSeriesRequest';

  /// Required. The resource name of the TensorboardRun to create the
  /// TensorboardTimeSeries in.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String parent;

  /// Optional. The user specified unique ID to use for the
  /// TensorboardTimeSeries, which becomes the final component of the
  /// TensorboardTimeSeries's resource name. This value should match
  /// "[a-z0-9][a-z0-9-]{0, 127}"
  final String? tensorboardTimeSeriesId;

  /// Required. The TensorboardTimeSeries to create.
  final TensorboardTimeSeries tensorboardTimeSeries;

  CreateTensorboardTimeSeriesRequest({
    required this.parent,
    this.tensorboardTimeSeriesId,
    required this.tensorboardTimeSeries,
  }) : super(fullyQualifiedName);

  factory CreateTensorboardTimeSeriesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateTensorboardTimeSeriesRequest(
      parent: json['parent'],
      tensorboardTimeSeriesId: json['tensorboardTimeSeriesId'],
      tensorboardTimeSeries: decode(
        json['tensorboardTimeSeries'],
        TensorboardTimeSeries.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (tensorboardTimeSeriesId != null)
        'tensorboardTimeSeriesId': tensorboardTimeSeriesId,
      'tensorboardTimeSeries': tensorboardTimeSeries.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (tensorboardTimeSeriesId != null)
        'tensorboardTimeSeriesId=$tensorboardTimeSeriesId',
    ].join(',');
    return 'CreateTensorboardTimeSeriesRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.GetTensorboardTimeSeries`.
final class GetTensorboardTimeSeriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTensorboardTimeSeriesRequest';

  /// Required. The name of the TensorboardTimeSeries resource.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String name;

  GetTensorboardTimeSeriesRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetTensorboardTimeSeriesRequest.fromJson(Map<String, dynamic> json) {
    return GetTensorboardTimeSeriesRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTensorboardTimeSeriesRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.ListTensorboardTimeSeries`.
final class ListTensorboardTimeSeriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardTimeSeriesRequest';

  /// Required. The resource name of the TensorboardRun to list
  /// TensorboardTimeSeries. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String parent;

  /// Lists the TensorboardTimeSeries that match the filter expression.
  final String? filter;

  /// The maximum number of TensorboardTimeSeries to return. The service may
  /// return fewer than this value. If unspecified, at most 50
  /// TensorboardTimeSeries are returned. The maximum value is 1000; values
  /// above 1000 are coerced to 1000.
  final int? pageSize;

  /// A page token, received from a previous
  /// `TensorboardService.ListTensorboardTimeSeries`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `TensorboardService.ListTensorboardTimeSeries`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// Field to use to sort the list.
  final String? orderBy;

  /// Mask specifying which fields to read.
  final protobuf.FieldMask? readMask;

  ListTensorboardTimeSeriesRequest({
    required this.parent,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
    this.readMask,
  }) : super(fullyQualifiedName);

  factory ListTensorboardTimeSeriesRequest.fromJson(Map<String, dynamic> json) {
    return ListTensorboardTimeSeriesRequest(
      parent: json['parent'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
      readMask: decodeCustom(json['readMask'], protobuf.FieldMask.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
      if (readMask != null) 'readMask': readMask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ListTensorboardTimeSeriesRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ListTensorboardTimeSeries`.
final class ListTensorboardTimeSeriesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTensorboardTimeSeriesResponse';

  /// The TensorboardTimeSeries mathching the request.
  final List<TensorboardTimeSeries>? tensorboardTimeSeries;

  /// A token, which can be sent as
  /// `ListTensorboardTimeSeriesRequest.page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ListTensorboardTimeSeriesResponse({
    this.tensorboardTimeSeries,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ListTensorboardTimeSeriesResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ListTensorboardTimeSeriesResponse(
      tensorboardTimeSeries: decodeListMessage(
        json['tensorboardTimeSeries'],
        TensorboardTimeSeries.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tensorboardTimeSeries != null)
        'tensorboardTimeSeries': encodeList(tensorboardTimeSeries),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListTensorboardTimeSeriesResponse($contents)';
  }
}

/// Request message for
/// `TensorboardService.UpdateTensorboardTimeSeries`.
final class UpdateTensorboardTimeSeriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardTimeSeriesRequest';

  /// Required. Field mask is used to specify the fields to be overwritten in the
  /// TensorboardTimeSeries resource by the update.
  /// The fields specified in the update_mask are relative to the resource, not
  /// the full request. A field is overwritten if it's in the mask. If the
  /// user does not provide a mask then all fields are overwritten if new
  /// values are specified.
  final protobuf.FieldMask? updateMask;

  /// Required. The TensorboardTimeSeries' `name` field is used to identify the
  /// TensorboardTimeSeries to be updated.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final TensorboardTimeSeries tensorboardTimeSeries;

  UpdateTensorboardTimeSeriesRequest({
    this.updateMask,
    required this.tensorboardTimeSeries,
  }) : super(fullyQualifiedName);

  factory UpdateTensorboardTimeSeriesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateTensorboardTimeSeriesRequest(
      updateMask: decodeCustom(json['updateMask'], protobuf.FieldMask.fromJson),
      tensorboardTimeSeries: decode(
        json['tensorboardTimeSeries'],
        TensorboardTimeSeries.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {
      if (updateMask != null) 'updateMask': updateMask!.toJson(),
      'tensorboardTimeSeries': tensorboardTimeSeries.toJson(),
    };
  }

  @override
  String toString() => 'UpdateTensorboardTimeSeriesRequest()';
}

/// Request message for
/// `TensorboardService.DeleteTensorboardTimeSeries`.
final class DeleteTensorboardTimeSeriesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTensorboardTimeSeriesRequest';

  /// Required. The name of the TensorboardTimeSeries to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String name;

  DeleteTensorboardTimeSeriesRequest({required this.name})
    : super(fullyQualifiedName);

  factory DeleteTensorboardTimeSeriesRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return DeleteTensorboardTimeSeriesRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTensorboardTimeSeriesRequest($contents)';
  }
}

/// Request message for
/// `TensorboardService.BatchReadTensorboardTimeSeriesData`.
final class BatchReadTensorboardTimeSeriesDataRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadTensorboardTimeSeriesDataRequest';

  /// Required. The resource name of the Tensorboard containing
  /// TensorboardTimeSeries to read data from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}`.
  /// The TensorboardTimeSeries referenced by
  /// `time_series`
  /// must be sub resources of this Tensorboard.
  final String tensorboard;

  /// Required. The resource names of the TensorboardTimeSeries to read data
  /// from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final List<String>? timeSeries;

  BatchReadTensorboardTimeSeriesDataRequest({
    required this.tensorboard,
    this.timeSeries,
  }) : super(fullyQualifiedName);

  factory BatchReadTensorboardTimeSeriesDataRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchReadTensorboardTimeSeriesDataRequest(
      tensorboard: json['tensorboard'],
      timeSeries: decodeList(json['timeSeries']),
    );
  }

  @override
  Object toJson() {
    return {
      'tensorboard': tensorboard,
      if (timeSeries != null) 'timeSeries': timeSeries,
    };
  }

  @override
  String toString() {
    final contents = ['tensorboard=$tensorboard'].join(',');
    return 'BatchReadTensorboardTimeSeriesDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.BatchReadTensorboardTimeSeriesData`.
final class BatchReadTensorboardTimeSeriesDataResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BatchReadTensorboardTimeSeriesDataResponse';

  /// The returned time series data.
  final List<TimeSeriesData>? timeSeriesData;

  BatchReadTensorboardTimeSeriesDataResponse({this.timeSeriesData})
    : super(fullyQualifiedName);

  factory BatchReadTensorboardTimeSeriesDataResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return BatchReadTensorboardTimeSeriesDataResponse(
      timeSeriesData: decodeListMessage(
        json['timeSeriesData'],
        TimeSeriesData.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (timeSeriesData != null) 'timeSeriesData': encodeList(timeSeriesData),
    };
  }

  @override
  String toString() => 'BatchReadTensorboardTimeSeriesDataResponse()';
}

/// Request message for
/// `TensorboardService.ReadTensorboardTimeSeriesData`.
final class ReadTensorboardTimeSeriesDataRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardTimeSeriesDataRequest';

  /// Required. The resource name of the TensorboardTimeSeries to read data from.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String tensorboardTimeSeries;

  /// The maximum number of TensorboardTimeSeries' data to return.
  ///
  /// This value should be a positive integer.
  /// This value can be set to -1 to return all data.
  final int? maxDataPoints;

  /// Reads the TensorboardTimeSeries' data that match the filter expression.
  final String? filter;

  ReadTensorboardTimeSeriesDataRequest({
    required this.tensorboardTimeSeries,
    this.maxDataPoints,
    this.filter,
  }) : super(fullyQualifiedName);

  factory ReadTensorboardTimeSeriesDataRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReadTensorboardTimeSeriesDataRequest(
      tensorboardTimeSeries: json['tensorboardTimeSeries'],
      maxDataPoints: json['maxDataPoints'],
      filter: json['filter'],
    );
  }

  @override
  Object toJson() {
    return {
      'tensorboardTimeSeries': tensorboardTimeSeries,
      if (maxDataPoints != null) 'maxDataPoints': maxDataPoints,
      if (filter != null) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      'tensorboardTimeSeries=$tensorboardTimeSeries',
      if (maxDataPoints != null) 'maxDataPoints=$maxDataPoints',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'ReadTensorboardTimeSeriesDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ReadTensorboardTimeSeriesData`.
final class ReadTensorboardTimeSeriesDataResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ReadTensorboardTimeSeriesDataResponse';

  /// The returned time series data.
  final TimeSeriesData? timeSeriesData;

  ReadTensorboardTimeSeriesDataResponse({this.timeSeriesData})
    : super(fullyQualifiedName);

  factory ReadTensorboardTimeSeriesDataResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ReadTensorboardTimeSeriesDataResponse(
      timeSeriesData: decode(json['timeSeriesData'], TimeSeriesData.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (timeSeriesData != null) 'timeSeriesData': timeSeriesData!.toJson(),
    };
  }

  @override
  String toString() => 'ReadTensorboardTimeSeriesDataResponse()';
}

/// Request message for
/// `TensorboardService.WriteTensorboardExperimentData`.
final class WriteTensorboardExperimentDataRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteTensorboardExperimentDataRequest';

  /// Required. The resource name of the TensorboardExperiment to write data to.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}`
  final String tensorboardExperiment;

  /// Required. Requests containing per-run TensorboardTimeSeries data to write.
  final List<WriteTensorboardRunDataRequest>? writeRunDataRequests;

  WriteTensorboardExperimentDataRequest({
    required this.tensorboardExperiment,
    this.writeRunDataRequests,
  }) : super(fullyQualifiedName);

  factory WriteTensorboardExperimentDataRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return WriteTensorboardExperimentDataRequest(
      tensorboardExperiment: json['tensorboardExperiment'],
      writeRunDataRequests: decodeListMessage(
        json['writeRunDataRequests'],
        WriteTensorboardRunDataRequest.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'tensorboardExperiment': tensorboardExperiment,
      if (writeRunDataRequests != null)
        'writeRunDataRequests': encodeList(writeRunDataRequests),
    };
  }

  @override
  String toString() {
    final contents = ['tensorboardExperiment=$tensorboardExperiment'].join(',');
    return 'WriteTensorboardExperimentDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.WriteTensorboardExperimentData`.
final class WriteTensorboardExperimentDataResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteTensorboardExperimentDataResponse';

  WriteTensorboardExperimentDataResponse() : super(fullyQualifiedName);

  factory WriteTensorboardExperimentDataResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return WriteTensorboardExperimentDataResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'WriteTensorboardExperimentDataResponse()';
}

/// Request message for
/// `TensorboardService.WriteTensorboardRunData`.
final class WriteTensorboardRunDataRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteTensorboardRunDataRequest';

  /// Required. The resource name of the TensorboardRun to write data to.
  /// Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}`
  final String tensorboardRun;

  /// Required. The TensorboardTimeSeries data to write.
  /// Values with in a time series are indexed by their step value.
  /// Repeated writes to the same step will overwrite the existing value for that
  /// step.
  /// The upper limit of data points per write request is 5000.
  final List<TimeSeriesData>? timeSeriesData;

  WriteTensorboardRunDataRequest({
    required this.tensorboardRun,
    this.timeSeriesData,
  }) : super(fullyQualifiedName);

  factory WriteTensorboardRunDataRequest.fromJson(Map<String, dynamic> json) {
    return WriteTensorboardRunDataRequest(
      tensorboardRun: json['tensorboardRun'],
      timeSeriesData: decodeListMessage(
        json['timeSeriesData'],
        TimeSeriesData.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'tensorboardRun': tensorboardRun,
      if (timeSeriesData != null) 'timeSeriesData': encodeList(timeSeriesData),
    };
  }

  @override
  String toString() {
    final contents = ['tensorboardRun=$tensorboardRun'].join(',');
    return 'WriteTensorboardRunDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.WriteTensorboardRunData`.
final class WriteTensorboardRunDataResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.WriteTensorboardRunDataResponse';

  WriteTensorboardRunDataResponse() : super(fullyQualifiedName);

  factory WriteTensorboardRunDataResponse.fromJson(Map<String, dynamic> json) {
    return WriteTensorboardRunDataResponse();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'WriteTensorboardRunDataResponse()';
}

/// Request message for
/// `TensorboardService.ExportTensorboardTimeSeriesData`.
final class ExportTensorboardTimeSeriesDataRequest
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportTensorboardTimeSeriesDataRequest';

  /// Required. The resource name of the TensorboardTimeSeries to export data
  /// from. Format:
  /// `projects/{project}/locations/{location}/tensorboards/{tensorboard}/experiments/{experiment}/runs/{run}/timeSeries/{time_series}`
  final String tensorboardTimeSeries;

  /// Exports the TensorboardTimeSeries' data that match the filter expression.
  final String? filter;

  /// The maximum number of data points to return per page.
  /// The default page_size is 1000. Values must be between 1 and 10000.
  /// Values above 10000 are coerced to 10000.
  final int? pageSize;

  /// A page token, received from a previous
  /// `ExportTensorboardTimeSeriesData`
  /// call. Provide this to retrieve the subsequent page.
  ///
  /// When paginating, all other parameters provided to
  /// `ExportTensorboardTimeSeriesData`
  /// must match the call that provided the page token.
  final String? pageToken;

  /// Field to use to sort the TensorboardTimeSeries' data.
  /// By default, TensorboardTimeSeries' data is returned in a pseudo random
  /// order.
  final String? orderBy;

  ExportTensorboardTimeSeriesDataRequest({
    required this.tensorboardTimeSeries,
    this.filter,
    this.pageSize,
    this.pageToken,
    this.orderBy,
  }) : super(fullyQualifiedName);

  factory ExportTensorboardTimeSeriesDataRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExportTensorboardTimeSeriesDataRequest(
      tensorboardTimeSeries: json['tensorboardTimeSeries'],
      filter: json['filter'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
      orderBy: json['orderBy'],
    );
  }

  @override
  Object toJson() {
    return {
      'tensorboardTimeSeries': tensorboardTimeSeries,
      if (filter != null) 'filter': filter,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
      if (orderBy != null) 'orderBy': orderBy,
    };
  }

  @override
  String toString() {
    final contents = [
      'tensorboardTimeSeries=$tensorboardTimeSeries',
      if (filter != null) 'filter=$filter',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
      if (orderBy != null) 'orderBy=$orderBy',
    ].join(',');
    return 'ExportTensorboardTimeSeriesDataRequest($contents)';
  }
}

/// Response message for
/// `TensorboardService.ExportTensorboardTimeSeriesData`.
final class ExportTensorboardTimeSeriesDataResponse
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExportTensorboardTimeSeriesDataResponse';

  /// The returned time series data points.
  final List<TimeSeriesDataPoint>? timeSeriesDataPoints;

  /// A token, which can be sent as
  /// `page_token`
  /// to retrieve the next page. If this field is omitted, there are no
  /// subsequent pages.
  final String? nextPageToken;

  ExportTensorboardTimeSeriesDataResponse({
    this.timeSeriesDataPoints,
    this.nextPageToken,
  }) : super(fullyQualifiedName);

  factory ExportTensorboardTimeSeriesDataResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return ExportTensorboardTimeSeriesDataResponse(
      timeSeriesDataPoints: decodeListMessage(
        json['timeSeriesDataPoints'],
        TimeSeriesDataPoint.fromJson,
      ),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (timeSeriesDataPoints != null)
        'timeSeriesDataPoints': encodeList(timeSeriesDataPoints),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ExportTensorboardTimeSeriesDataResponse($contents)';
  }
}

/// Details of operations that perform create Tensorboard.
final class CreateTensorboardOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTensorboardOperationMetadata';

  /// Operation metadata for Tensorboard.
  final GenericOperationMetadata? genericMetadata;

  CreateTensorboardOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateTensorboardOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CreateTensorboardOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateTensorboardOperationMetadata()';
}

/// Details of operations that perform update Tensorboard.
final class UpdateTensorboardOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateTensorboardOperationMetadata';

  /// Operation metadata for Tensorboard.
  final GenericOperationMetadata? genericMetadata;

  UpdateTensorboardOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateTensorboardOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateTensorboardOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateTensorboardOperationMetadata()';
}

/// TensorboardTimeSeries maps to times series produced in training runs
final class TensorboardTimeSeries extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardTimeSeries';

  /// Output only. Name of the TensorboardTimeSeries.
  final String? name;

  /// Required. User provided name of this TensorboardTimeSeries.
  /// This value should be unique among all TensorboardTimeSeries resources
  /// belonging to the same TensorboardRun resource (parent resource).
  final String? displayName;

  /// Description of this TensorboardTimeSeries.
  final String? description;

  /// Required. Immutable. Type of TensorboardTimeSeries value.
  final TensorboardTimeSeries_ValueType? valueType;

  /// Output only. Timestamp when this TensorboardTimeSeries was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this TensorboardTimeSeries was last updated.
  final protobuf.Timestamp? updateTime;

  /// Used to perform a consistent read-modify-write updates. If not set, a blind
  /// "overwrite" update happens.
  final String? etag;

  /// Immutable. Name of the plugin this time series pertain to. Such as Scalar,
  /// Tensor, Blob
  final String? pluginName;

  /// Data of the current plugin, with the size limited to 65KB.
  final Uint8List? pluginData;

  /// Output only. Scalar, Tensor, or Blob metadata for this
  /// TensorboardTimeSeries.
  final TensorboardTimeSeries_Metadata? metadata;

  TensorboardTimeSeries({
    this.name,
    this.displayName,
    this.description,
    this.valueType,
    this.createTime,
    this.updateTime,
    this.etag,
    this.pluginName,
    this.pluginData,
    this.metadata,
  }) : super(fullyQualifiedName);

  factory TensorboardTimeSeries.fromJson(Map<String, dynamic> json) {
    return TensorboardTimeSeries(
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      valueType: decodeEnum(
        json['valueType'],
        TensorboardTimeSeries_ValueType.fromJson,
      ),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      etag: json['etag'],
      pluginName: json['pluginName'],
      pluginData: decodeBytes(json['pluginData']),
      metadata: decode(
        json['metadata'],
        TensorboardTimeSeries_Metadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (valueType != null) 'valueType': valueType!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (etag != null) 'etag': etag,
      if (pluginName != null) 'pluginName': pluginName,
      if (pluginData != null) 'pluginData': encodeBytes(pluginData),
      if (metadata != null) 'metadata': metadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (valueType != null) 'valueType=$valueType',
      if (etag != null) 'etag=$etag',
      if (pluginName != null) 'pluginName=$pluginName',
      if (pluginData != null) 'pluginData=$pluginData',
    ].join(',');
    return 'TensorboardTimeSeries($contents)';
  }
}

/// Describes metadata for a TensorboardTimeSeries.
final class TensorboardTimeSeries_Metadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TensorboardTimeSeries.Metadata';

  /// Output only. Max step index of all data points within a
  /// TensorboardTimeSeries.
  final int? maxStep;

  /// Output only. Max wall clock timestamp of all data points within a
  /// TensorboardTimeSeries.
  final protobuf.Timestamp? maxWallTime;

  /// Output only. The largest blob sequence length (number of blobs) of all
  /// data points in this time series, if its ValueType is BLOB_SEQUENCE.
  final int? maxBlobSequenceLength;

  TensorboardTimeSeries_Metadata({
    this.maxStep,
    this.maxWallTime,
    this.maxBlobSequenceLength,
  }) : super(fullyQualifiedName);

  factory TensorboardTimeSeries_Metadata.fromJson(Map<String, dynamic> json) {
    return TensorboardTimeSeries_Metadata(
      maxStep: decodeInt64(json['maxStep']),
      maxWallTime: decodeCustom(
        json['maxWallTime'],
        protobuf.Timestamp.fromJson,
      ),
      maxBlobSequenceLength: decodeInt64(json['maxBlobSequenceLength']),
    );
  }

  @override
  Object toJson() {
    return {
      if (maxStep != null) 'maxStep': encodeInt64(maxStep),
      if (maxWallTime != null) 'maxWallTime': maxWallTime!.toJson(),
      if (maxBlobSequenceLength != null)
        'maxBlobSequenceLength': encodeInt64(maxBlobSequenceLength),
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxStep != null) 'maxStep=$maxStep',
      if (maxBlobSequenceLength != null)
        'maxBlobSequenceLength=$maxBlobSequenceLength',
    ].join(',');
    return 'Metadata($contents)';
  }
}

/// An enum representing the value type of a TensorboardTimeSeries.
final class TensorboardTimeSeries_ValueType extends protobuf.ProtoEnum {
  /// The value type is unspecified.
  static const valueTypeUnspecified = TensorboardTimeSeries_ValueType(
    'VALUE_TYPE_UNSPECIFIED',
  );

  /// Used for TensorboardTimeSeries that is a list of scalars.
  /// E.g. accuracy of a model over epochs/time.
  static const scalar = TensorboardTimeSeries_ValueType('SCALAR');

  /// Used for TensorboardTimeSeries that is a list of tensors.
  /// E.g. histograms of weights of layer in a model over epoch/time.
  static const tensor = TensorboardTimeSeries_ValueType('TENSOR');

  /// Used for TensorboardTimeSeries that is a list of blob sequences.
  /// E.g. set of sample images with labels over epochs/time.
  static const blobSequence = TensorboardTimeSeries_ValueType('BLOB_SEQUENCE');

  const TensorboardTimeSeries_ValueType(super.value);

  factory TensorboardTimeSeries_ValueType.fromJson(String json) =>
      TensorboardTimeSeries_ValueType(json);

  @override
  String toString() => 'ValueType.$value';
}

/// Tool details that the model may use to generate response.
///
/// A `Tool` is a piece of code that enables the system to interact with
/// external systems to perform an action, or set of actions, outside of
/// knowledge and scope of the model. A Tool object should contain exactly
/// one type of Tool (e.g FunctionDeclaration, Retrieval or
/// GoogleSearchRetrieval).
final class Tool extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tool';

  /// Optional. Function tool type.
  /// One or more function declarations to be passed to the model along with the
  /// current user query. Model may decide to call a subset of these functions
  /// by populating
  /// `FunctionCall` in the
  /// response. User should provide a
  /// `FunctionResponse`
  /// for each function call in the next turn. Based on the function responses,
  /// Model will generate the final response back to the user.
  /// Maximum 128 function declarations can be provided.
  final List<FunctionDeclaration>? functionDeclarations;

  /// Optional. Retrieval tool type.
  /// System will always execute the provided retrieval tool(s) to get external
  /// knowledge to answer the prompt. Retrieval results are presented to the
  /// model for generation.
  final Retrieval? retrieval;

  /// Optional. GoogleSearch tool type.
  /// Tool to support Google Search in Model. Powered by Google.
  final Tool_GoogleSearch? googleSearch;

  /// Optional. GoogleSearchRetrieval tool type.
  /// Specialized retrieval tool that is powered by Google search.
  final GoogleSearchRetrieval? googleSearchRetrieval;

  /// Optional. GoogleMaps tool type.
  /// Tool to support Google Maps in Model.
  final GoogleMaps? googleMaps;

  /// Optional. Tool to support searching public web data, powered by Vertex AI
  /// Search and Sec4 compliance.
  final EnterpriseWebSearch? enterpriseWebSearch;

  /// Optional. CodeExecution tool type.
  /// Enables the model to execute code as part of generation.
  final Tool_CodeExecution? codeExecution;

  /// Optional. Tool to support URL context retrieval.
  final UrlContext? urlContext;

  /// Optional. Tool to support the model interacting directly with the computer.
  /// If enabled, it automatically populates computer-use specific Function
  /// Declarations.
  final Tool_ComputerUse? computerUse;

  Tool({
    this.functionDeclarations,
    this.retrieval,
    this.googleSearch,
    this.googleSearchRetrieval,
    this.googleMaps,
    this.enterpriseWebSearch,
    this.codeExecution,
    this.urlContext,
    this.computerUse,
  }) : super(fullyQualifiedName);

  factory Tool.fromJson(Map<String, dynamic> json) {
    return Tool(
      functionDeclarations: decodeListMessage(
        json['functionDeclarations'],
        FunctionDeclaration.fromJson,
      ),
      retrieval: decode(json['retrieval'], Retrieval.fromJson),
      googleSearch: decode(json['googleSearch'], Tool_GoogleSearch.fromJson),
      googleSearchRetrieval: decode(
        json['googleSearchRetrieval'],
        GoogleSearchRetrieval.fromJson,
      ),
      googleMaps: decode(json['googleMaps'], GoogleMaps.fromJson),
      enterpriseWebSearch: decode(
        json['enterpriseWebSearch'],
        EnterpriseWebSearch.fromJson,
      ),
      codeExecution: decode(json['codeExecution'], Tool_CodeExecution.fromJson),
      urlContext: decode(json['urlContext'], UrlContext.fromJson),
      computerUse: decode(json['computerUse'], Tool_ComputerUse.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (functionDeclarations != null)
        'functionDeclarations': encodeList(functionDeclarations),
      if (retrieval != null) 'retrieval': retrieval!.toJson(),
      if (googleSearch != null) 'googleSearch': googleSearch!.toJson(),
      if (googleSearchRetrieval != null)
        'googleSearchRetrieval': googleSearchRetrieval!.toJson(),
      if (googleMaps != null) 'googleMaps': googleMaps!.toJson(),
      if (enterpriseWebSearch != null)
        'enterpriseWebSearch': enterpriseWebSearch!.toJson(),
      if (codeExecution != null) 'codeExecution': codeExecution!.toJson(),
      if (urlContext != null) 'urlContext': urlContext!.toJson(),
      if (computerUse != null) 'computerUse': computerUse!.toJson(),
    };
  }

  @override
  String toString() => 'Tool()';
}

/// GoogleSearch tool type.
/// Tool to support Google Search in Model. Powered by Google.
final class Tool_GoogleSearch extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tool.GoogleSearch';

  /// Optional. List of domains to be excluded from the search results.
  /// The default limit is 2000 domains.
  /// Example: ["amazon.com", "facebook.com"].
  final List<String>? excludeDomains;

  /// Optional. Sites with confidence level chosen & above this value will be
  /// blocked from the search results.
  final Tool_PhishBlockThreshold? blockingConfidence;

  Tool_GoogleSearch({this.excludeDomains, this.blockingConfidence})
    : super(fullyQualifiedName);

  factory Tool_GoogleSearch.fromJson(Map<String, dynamic> json) {
    return Tool_GoogleSearch(
      excludeDomains: decodeList(json['excludeDomains']),
      blockingConfidence: decodeEnum(
        json['blockingConfidence'],
        Tool_PhishBlockThreshold.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (excludeDomains != null) 'excludeDomains': excludeDomains,
      if (blockingConfidence != null)
        'blockingConfidence': blockingConfidence!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (blockingConfidence != null) 'blockingConfidence=$blockingConfidence',
    ].join(',');
    return 'GoogleSearch($contents)';
  }
}

/// Tool that executes code generated by the model, and automatically returns
/// the result to the model.
///
/// See also [ExecutableCode]and [CodeExecutionResult] which are input and
/// output to this tool.
final class Tool_CodeExecution extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tool.CodeExecution';

  Tool_CodeExecution() : super(fullyQualifiedName);

  factory Tool_CodeExecution.fromJson(Map<String, dynamic> json) {
    return Tool_CodeExecution();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'CodeExecution()';
}

/// Tool to support computer use.
final class Tool_ComputerUse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tool.ComputerUse';

  /// Required. The environment being operated.
  final Tool_ComputerUse_Environment? environment;

  Tool_ComputerUse({this.environment}) : super(fullyQualifiedName);

  factory Tool_ComputerUse.fromJson(Map<String, dynamic> json) {
    return Tool_ComputerUse(
      environment: decodeEnum(
        json['environment'],
        Tool_ComputerUse_Environment.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (environment != null) 'environment': environment!.toJson()};
  }

  @override
  String toString() {
    final contents = [
      if (environment != null) 'environment=$environment',
    ].join(',');
    return 'ComputerUse($contents)';
  }
}

/// Represents the environment being operated, such as a web browser.
final class Tool_ComputerUse_Environment extends protobuf.ProtoEnum {
  /// Defaults to browser.
  static const environmentUnspecified = Tool_ComputerUse_Environment(
    'ENVIRONMENT_UNSPECIFIED',
  );

  /// Operates in a web browser.
  static const environmentBrowser = Tool_ComputerUse_Environment(
    'ENVIRONMENT_BROWSER',
  );

  const Tool_ComputerUse_Environment(super.value);

  factory Tool_ComputerUse_Environment.fromJson(String json) =>
      Tool_ComputerUse_Environment(json);

  @override
  String toString() => 'Environment.$value';
}

/// These are available confidence level user can set to block malicious urls
/// with chosen confidence and above. For understanding different confidence of
/// webrisk, please refer to
/// https://cloud.google.com/web-risk/docs/reference/rpc/google.cloud.webrisk.v1eap1#confidencelevel
final class Tool_PhishBlockThreshold extends protobuf.ProtoEnum {
  /// Defaults to unspecified.
  static const phishBlockThresholdUnspecified = Tool_PhishBlockThreshold(
    'PHISH_BLOCK_THRESHOLD_UNSPECIFIED',
  );

  /// Blocks Low and above confidence URL that is risky.
  static const blockLowAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_LOW_AND_ABOVE',
  );

  /// Blocks Medium and above confidence URL that is risky.
  static const blockMediumAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_MEDIUM_AND_ABOVE',
  );

  /// Blocks High and above confidence URL that is risky.
  static const blockHighAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_HIGH_AND_ABOVE',
  );

  /// Blocks Higher and above confidence URL that is risky.
  static const blockHigherAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_HIGHER_AND_ABOVE',
  );

  /// Blocks Very high and above confidence URL that is risky.
  static const blockVeryHighAndAbove = Tool_PhishBlockThreshold(
    'BLOCK_VERY_HIGH_AND_ABOVE',
  );

  /// Blocks Extremely high confidence URL that is risky.
  static const blockOnlyExtremelyHigh = Tool_PhishBlockThreshold(
    'BLOCK_ONLY_EXTREMELY_HIGH',
  );

  const Tool_PhishBlockThreshold(super.value);

  factory Tool_PhishBlockThreshold.fromJson(String json) =>
      Tool_PhishBlockThreshold(json);

  @override
  String toString() => 'PhishBlockThreshold.$value';
}

/// Tool to support URL context.
final class UrlContext extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UrlContext';

  UrlContext() : super(fullyQualifiedName);

  factory UrlContext.fromJson(Map<String, dynamic> json) {
    return UrlContext();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'UrlContext()';
}

/// A single example of the tool usage.
final class ToolUseExample extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolUseExample';

  /// Extension operation to call.
  final ToolUseExample_ExtensionOperation? extensionOperation;

  /// Function name to call.
  final String? functionName;

  /// Required. The display name for example.
  final String? displayName;

  /// Required. Query that should be routed to this tool.
  final String? query;

  /// Request parameters used for executing this tool.
  final protobuf.Struct? requestParams;

  /// Response parameters generated by this tool.
  final protobuf.Struct? responseParams;

  /// Summary of the tool response to the user query.
  final String? responseSummary;

  ToolUseExample({
    this.extensionOperation,
    this.functionName,
    this.displayName,
    this.query,
    this.requestParams,
    this.responseParams,
    this.responseSummary,
  }) : super(fullyQualifiedName);

  factory ToolUseExample.fromJson(Map<String, dynamic> json) {
    return ToolUseExample(
      extensionOperation: decode(
        json['extensionOperation'],
        ToolUseExample_ExtensionOperation.fromJson,
      ),
      functionName: json['functionName'],
      displayName: json['displayName'],
      query: json['query'],
      requestParams: decodeCustom(
        json['requestParams'],
        protobuf.Struct.fromJson,
      ),
      responseParams: decodeCustom(
        json['responseParams'],
        protobuf.Struct.fromJson,
      ),
      responseSummary: json['responseSummary'],
    );
  }

  @override
  Object toJson() {
    return {
      if (extensionOperation != null)
        'extensionOperation': extensionOperation!.toJson(),
      if (functionName != null) 'functionName': functionName,
      if (displayName != null) 'displayName': displayName,
      if (query != null) 'query': query,
      if (requestParams != null) 'requestParams': requestParams!.toJson(),
      if (responseParams != null) 'responseParams': responseParams!.toJson(),
      if (responseSummary != null) 'responseSummary': responseSummary,
    };
  }

  @override
  String toString() {
    final contents = [
      if (functionName != null) 'functionName=$functionName',
      if (displayName != null) 'displayName=$displayName',
      if (query != null) 'query=$query',
      if (responseSummary != null) 'responseSummary=$responseSummary',
    ].join(',');
    return 'ToolUseExample($contents)';
  }
}

/// Identifies one operation of the extension.
final class ToolUseExample_ExtensionOperation extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolUseExample.ExtensionOperation';

  /// Resource name of the extension.
  final String? extension;

  /// Required. Operation ID of the extension.
  final String? operationId;

  ToolUseExample_ExtensionOperation({this.extension, this.operationId})
    : super(fullyQualifiedName);

  factory ToolUseExample_ExtensionOperation.fromJson(
    Map<String, dynamic> json,
  ) {
    return ToolUseExample_ExtensionOperation(
      extension: json['extension'],
      operationId: json['operationId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (extension != null) 'extension': extension,
      if (operationId != null) 'operationId': operationId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (extension != null) 'extension=$extension',
      if (operationId != null) 'operationId=$operationId',
    ].join(',');
    return 'ExtensionOperation($contents)';
  }
}

/// Structured representation of a function declaration as defined by the
/// [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included
/// in this declaration are the function name, description, parameters and
/// response type. This FunctionDeclaration is a representation of a block of
/// code that can be used as a `Tool` by the model and executed by the client.
final class FunctionDeclaration extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FunctionDeclaration';

  /// Required. The name of the function to call.
  /// Must start with a letter or an underscore.
  /// Must be a-z, A-Z, 0-9, or contain underscores, dots and dashes, with a
  /// maximum length of 64.
  final String? name;

  /// Optional. Description and purpose of the function.
  /// Model uses it to decide how and whether to call the function.
  final String? description;

  /// Optional. Describes the parameters to this function in JSON Schema Object
  /// format. Reflects the Open API 3.03 Parameter Object. string Key: the name
  /// of the parameter. Parameter names are case sensitive. Schema Value: the
  /// Schema defining the type used for the parameter. For function with no
  /// parameters, this can be left unset. Parameter names must start with a
  /// letter or an underscore and must only contain chars a-z, A-Z, 0-9, or
  /// underscores with a maximum length of 64. Example with 1 required and 1
  /// optional parameter: type: OBJECT properties:
  ///  param1:
  ///    type: STRING
  ///  param2:
  ///    type: INTEGER
  /// required:
  ///  - param1
  final Schema? parameters;

  /// Optional. Describes the parameters to the function in JSON Schema format.
  /// The schema must describe an object where the properties are the parameters
  /// to the function. For example:
  ///
  /// ```
  /// {
  ///   "type": "object",
  ///   "properties": {
  ///     "name": { "type": "string" },
  ///     "age": { "type": "integer" }
  ///   },
  ///   "additionalProperties": false,
  ///   "required": ["name", "age"],
  ///   "propertyOrdering": ["name", "age"]
  /// }
  /// ```
  ///
  /// This field is mutually exclusive with `parameters`.
  final protobuf.Value? parametersJsonSchema;

  /// Optional. Describes the output from this function in JSON Schema format.
  /// Reflects the Open API 3.03 Response Object. The Schema defines the type
  /// used for the response value of the function.
  final Schema? response;

  /// Optional. Describes the output from this function in JSON Schema format.
  /// The value specified by the schema is the response value of the function.
  ///
  /// This field is mutually exclusive with `response`.
  final protobuf.Value? responseJsonSchema;

  FunctionDeclaration({
    this.name,
    this.description,
    this.parameters,
    this.parametersJsonSchema,
    this.response,
    this.responseJsonSchema,
  }) : super(fullyQualifiedName);

  factory FunctionDeclaration.fromJson(Map<String, dynamic> json) {
    return FunctionDeclaration(
      name: json['name'],
      description: json['description'],
      parameters: decode(json['parameters'], Schema.fromJson),
      parametersJsonSchema: decodeCustom(
        json['parametersJsonSchema'],
        protobuf.Value.fromJson,
      ),
      response: decode(json['response'], Schema.fromJson),
      responseJsonSchema: decodeCustom(
        json['responseJsonSchema'],
        protobuf.Value.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (description != null) 'description': description,
      if (parameters != null) 'parameters': parameters!.toJson(),
      if (parametersJsonSchema != null)
        'parametersJsonSchema': parametersJsonSchema!.toJson(),
      if (response != null) 'response': response!.toJson(),
      if (responseJsonSchema != null)
        'responseJsonSchema': responseJsonSchema!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (description != null) 'description=$description',
    ].join(',');
    return 'FunctionDeclaration($contents)';
  }
}

/// A predicted [FunctionCall] returned from the model that contains a string
/// representing the [FunctionDeclaration.name] and a structured JSON object
/// containing the parameters and their values.
final class FunctionCall extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FunctionCall';

  /// Optional. The unique id of the function call. If populated, the client to
  /// execute the `function_call` and return the response with the matching `id`.
  final String? id;

  /// Required. The name of the function to call.
  /// Matches [FunctionDeclaration.name].
  final String? name;

  /// Optional. Required. The function parameters and values in JSON object
  /// format. See [FunctionDeclaration.parameters] for parameter details.
  final protobuf.Struct? args;

  FunctionCall({this.id, this.name, this.args}) : super(fullyQualifiedName);

  factory FunctionCall.fromJson(Map<String, dynamic> json) {
    return FunctionCall(
      id: json['id'],
      name: json['name'],
      args: decodeCustom(json['args'], protobuf.Struct.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (args != null) 'args': args!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      if (name != null) 'name=$name',
    ].join(',');
    return 'FunctionCall($contents)';
  }
}

/// The result output from a [FunctionCall] that contains a string representing
/// the [FunctionDeclaration.name] and a structured JSON object containing any
/// output from the function is used as context to the model. This should contain
/// the result of a [FunctionCall] made based on model prediction.
final class FunctionResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FunctionResponse';

  /// Optional. The id of the function call this response is for. Populated by
  /// the client to match the corresponding function call `id`.
  final String? id;

  /// Required. The name of the function to call.
  /// Matches [FunctionDeclaration.name] and [FunctionCall.name].
  final String? name;

  /// Required. The function response in JSON object format.
  /// Use "output" key to specify function output and "error" key to specify
  /// error details (if any). If "output" and "error" keys are not specified,
  /// then whole "response" is treated as function output.
  final protobuf.Struct? response;

  FunctionResponse({this.id, this.name, this.response})
    : super(fullyQualifiedName);

  factory FunctionResponse.fromJson(Map<String, dynamic> json) {
    return FunctionResponse(
      id: json['id'],
      name: json['name'],
      response: decodeCustom(json['response'], protobuf.Struct.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (response != null) 'response': response!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (id != null) 'id=$id',
      if (name != null) 'name=$name',
    ].join(',');
    return 'FunctionResponse($contents)';
  }
}

/// Code generated by the model that is meant to be executed, and the result
/// returned to the model.
///
/// Generated when using the [FunctionDeclaration] tool and
/// [FunctionCallingConfig] mode is set to [Mode.CODE].
final class ExecutableCode extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ExecutableCode';

  /// Required. Programming language of the `code`.
  final ExecutableCode_Language? language;

  /// Required. The code to be executed.
  final String? code;

  ExecutableCode({this.language, this.code}) : super(fullyQualifiedName);

  factory ExecutableCode.fromJson(Map<String, dynamic> json) {
    return ExecutableCode(
      language: decodeEnum(json['language'], ExecutableCode_Language.fromJson),
      code: json['code'],
    );
  }

  @override
  Object toJson() {
    return {
      if (language != null) 'language': language!.toJson(),
      if (code != null) 'code': code,
    };
  }

  @override
  String toString() {
    final contents = [
      if (language != null) 'language=$language',
      if (code != null) 'code=$code',
    ].join(',');
    return 'ExecutableCode($contents)';
  }
}

/// Supported programming languages for the generated code.
final class ExecutableCode_Language extends protobuf.ProtoEnum {
  /// Unspecified language. This value should not be used.
  static const languageUnspecified = ExecutableCode_Language(
    'LANGUAGE_UNSPECIFIED',
  );

  /// Python >= 3.10, with numpy and simpy available.
  static const python = ExecutableCode_Language('PYTHON');

  const ExecutableCode_Language(super.value);

  factory ExecutableCode_Language.fromJson(String json) =>
      ExecutableCode_Language(json);

  @override
  String toString() => 'Language.$value';
}

/// Result of executing the [ExecutableCode].
///
/// Always follows a `part` containing the [ExecutableCode].
final class CodeExecutionResult extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CodeExecutionResult';

  /// Required. Outcome of the code execution.
  final CodeExecutionResult_Outcome? outcome;

  /// Optional. Contains stdout when code execution is successful, stderr or
  /// other description otherwise.
  final String? output;

  CodeExecutionResult({this.outcome, this.output}) : super(fullyQualifiedName);

  factory CodeExecutionResult.fromJson(Map<String, dynamic> json) {
    return CodeExecutionResult(
      outcome: decodeEnum(
        json['outcome'],
        CodeExecutionResult_Outcome.fromJson,
      ),
      output: json['output'],
    );
  }

  @override
  Object toJson() {
    return {
      if (outcome != null) 'outcome': outcome!.toJson(),
      if (output != null) 'output': output,
    };
  }

  @override
  String toString() {
    final contents = [
      if (outcome != null) 'outcome=$outcome',
      if (output != null) 'output=$output',
    ].join(',');
    return 'CodeExecutionResult($contents)';
  }
}

/// Enumeration of possible outcomes of the code execution.
final class CodeExecutionResult_Outcome extends protobuf.ProtoEnum {
  /// Unspecified status. This value should not be used.
  static const outcomeUnspecified = CodeExecutionResult_Outcome(
    'OUTCOME_UNSPECIFIED',
  );

  /// Code execution completed successfully.
  static const outcomeOk = CodeExecutionResult_Outcome('OUTCOME_OK');

  /// Code execution finished but with a failure. `stderr` should contain the
  /// reason.
  static const outcomeFailed = CodeExecutionResult_Outcome('OUTCOME_FAILED');

  /// Code execution ran for too long, and was cancelled. There may or may not
  /// be a partial output present.
  static const outcomeDeadlineExceeded = CodeExecutionResult_Outcome(
    'OUTCOME_DEADLINE_EXCEEDED',
  );

  const CodeExecutionResult_Outcome(super.value);

  factory CodeExecutionResult_Outcome.fromJson(String json) =>
      CodeExecutionResult_Outcome(json);

  @override
  String toString() => 'Outcome.$value';
}

/// Defines a retrieval tool that model can call to access external knowledge.
final class Retrieval extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Retrieval';

  /// Set to use data source powered by Vertex AI Search.
  final VertexAisearch? vertexAiSearch;

  /// Set to use data source powered by Vertex RAG store.
  /// User data is uploaded via the VertexRagDataService.
  final VertexRagStore? vertexRagStore;

  /// Optional. Deprecated. This option is no longer supported.
  final bool? disableAttribution;

  Retrieval({this.vertexAiSearch, this.vertexRagStore, this.disableAttribution})
    : super(fullyQualifiedName);

  factory Retrieval.fromJson(Map<String, dynamic> json) {
    return Retrieval(
      vertexAiSearch: decode(json['vertexAiSearch'], VertexAisearch.fromJson),
      vertexRagStore: decode(json['vertexRagStore'], VertexRagStore.fromJson),
      disableAttribution: json['disableAttribution'],
    );
  }

  @override
  Object toJson() {
    return {
      if (vertexAiSearch != null) 'vertexAiSearch': vertexAiSearch!.toJson(),
      if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!.toJson(),
      if (disableAttribution != null) 'disableAttribution': disableAttribution,
    };
  }

  @override
  String toString() {
    final contents = [
      if (disableAttribution != null) 'disableAttribution=$disableAttribution',
    ].join(',');
    return 'Retrieval($contents)';
  }
}

/// Retrieve from Vertex RAG Store for grounding.
final class VertexRagStore extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexRagStore';

  /// Optional. Deprecated. Please use rag_resources instead.
  final List<String>? ragCorpora;

  /// Optional. The representation of the rag source. It can be used to specify
  /// corpus only or ragfiles. Currently only support one corpus or multiple
  /// files from one corpus. In the future we may open up multiple corpora
  /// support.
  final List<VertexRagStore_RagResource>? ragResources;

  /// Optional. Number of top k results to return from the selected corpora.
  final int? similarityTopK;

  /// Optional. Only return results with vector distance smaller than the
  /// threshold.
  final double? vectorDistanceThreshold;

  /// Optional. The retrieval config for the Rag query.
  final RagRetrievalConfig? ragRetrievalConfig;

  /// Optional. Currently only supported for Gemini Multimodal Live API.
  ///
  /// In Gemini Multimodal Live API, if `store_context` bool is
  /// true, Gemini will leverage it to automatically memorize the
  /// interactions between the client and Gemini, and retrieve context when
  /// needed to augment the response generation for users' ongoing and future
  /// interactions.
  final bool? storeContext;

  VertexRagStore({
    this.ragCorpora,
    this.ragResources,
    this.similarityTopK,
    this.vectorDistanceThreshold,
    this.ragRetrievalConfig,
    this.storeContext,
  }) : super(fullyQualifiedName);

  factory VertexRagStore.fromJson(Map<String, dynamic> json) {
    return VertexRagStore(
      ragCorpora: decodeList(json['ragCorpora']),
      ragResources: decodeListMessage(
        json['ragResources'],
        VertexRagStore_RagResource.fromJson,
      ),
      similarityTopK: json['similarityTopK'],
      vectorDistanceThreshold: decodeDouble(json['vectorDistanceThreshold']),
      ragRetrievalConfig: decode(
        json['ragRetrievalConfig'],
        RagRetrievalConfig.fromJson,
      ),
      storeContext: json['storeContext'],
    );
  }

  @override
  Object toJson() {
    return {
      if (ragCorpora != null) 'ragCorpora': ragCorpora,
      if (ragResources != null) 'ragResources': encodeList(ragResources),
      if (similarityTopK != null) 'similarityTopK': similarityTopK,
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold': encodeDouble(vectorDistanceThreshold),
      if (ragRetrievalConfig != null)
        'ragRetrievalConfig': ragRetrievalConfig!.toJson(),
      if (storeContext != null) 'storeContext': storeContext,
    };
  }

  @override
  String toString() {
    final contents = [
      if (similarityTopK != null) 'similarityTopK=$similarityTopK',
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold=$vectorDistanceThreshold',
      if (storeContext != null) 'storeContext=$storeContext',
    ].join(',');
    return 'VertexRagStore($contents)';
  }
}

/// The definition of the Rag resource.
final class VertexRagStore_RagResource extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexRagStore.RagResource';

  /// Optional. RagCorpora resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String? ragCorpus;

  /// Optional. rag_file_id. The files should be in the same rag_corpus set in
  /// rag_corpus field.
  final List<String>? ragFileIds;

  VertexRagStore_RagResource({this.ragCorpus, this.ragFileIds})
    : super(fullyQualifiedName);

  factory VertexRagStore_RagResource.fromJson(Map<String, dynamic> json) {
    return VertexRagStore_RagResource(
      ragCorpus: json['ragCorpus'],
      ragFileIds: decodeList(json['ragFileIds']),
    );
  }

  @override
  Object toJson() {
    return {
      if (ragCorpus != null) 'ragCorpus': ragCorpus,
      if (ragFileIds != null) 'ragFileIds': ragFileIds,
    };
  }

  @override
  String toString() {
    final contents = [if (ragCorpus != null) 'ragCorpus=$ragCorpus'].join(',');
    return 'RagResource($contents)';
  }
}

/// Retrieve from Vertex AI Search datastore or engine for grounding.
/// datastore and engine are mutually exclusive.
/// See https://cloud.google.com/products/agent-builder
final class VertexAisearch extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexAISearch';

  /// Optional. Fully-qualified Vertex AI Search data store resource ID.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
  final String? datastore;

  /// Optional. Fully-qualified Vertex AI Search engine resource ID.
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
  final String? engine;

  /// Optional. Number of search results to return per query.
  /// The default value is 10.
  /// The maximumm allowed value is 10.
  final int? maxResults;

  /// Optional. Filter strings to be passed to the search API.
  final String? filter;

  /// Specifications that define the specific DataStores to be searched, along
  /// with configurations for those data stores. This is only considered for
  /// Engines with multiple data stores.
  /// It should only be set if engine is used.
  final List<VertexAisearch_DataStoreSpec>? dataStoreSpecs;

  VertexAisearch({
    this.datastore,
    this.engine,
    this.maxResults,
    this.filter,
    this.dataStoreSpecs,
  }) : super(fullyQualifiedName);

  factory VertexAisearch.fromJson(Map<String, dynamic> json) {
    return VertexAisearch(
      datastore: json['datastore'],
      engine: json['engine'],
      maxResults: json['maxResults'],
      filter: json['filter'],
      dataStoreSpecs: decodeListMessage(
        json['dataStoreSpecs'],
        VertexAisearch_DataStoreSpec.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (datastore != null) 'datastore': datastore,
      if (engine != null) 'engine': engine,
      if (maxResults != null) 'maxResults': maxResults,
      if (filter != null) 'filter': filter,
      if (dataStoreSpecs != null) 'dataStoreSpecs': encodeList(dataStoreSpecs),
    };
  }

  @override
  String toString() {
    final contents = [
      if (datastore != null) 'datastore=$datastore',
      if (engine != null) 'engine=$engine',
      if (maxResults != null) 'maxResults=$maxResults',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'VertexAISearch($contents)';
  }
}

/// Define data stores within engine to filter on in a search call and
/// configurations for those data stores. For more information, see
/// https://cloud.google.com/generative-ai-app-builder/docs/reference/rpc/google.cloud.discoveryengine.v1#datastorespec
final class VertexAisearch_DataStoreSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexAISearch.DataStoreSpec';

  /// Full resource name of DataStore, such as
  /// Format:
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
  final String? dataStore;

  /// Optional. Filter specification to filter documents in the data store
  /// specified by data_store field. For more information on filtering, see
  /// [Filtering](https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata)
  final String? filter;

  VertexAisearch_DataStoreSpec({this.dataStore, this.filter})
    : super(fullyQualifiedName);

  factory VertexAisearch_DataStoreSpec.fromJson(Map<String, dynamic> json) {
    return VertexAisearch_DataStoreSpec(
      dataStore: json['dataStore'],
      filter: json['filter'],
    );
  }

  @override
  Object toJson() {
    return {
      if (dataStore != null) 'dataStore': dataStore,
      if (filter != null) 'filter': filter,
    };
  }

  @override
  String toString() {
    final contents = [
      if (dataStore != null) 'dataStore=$dataStore',
      if (filter != null) 'filter=$filter',
    ].join(',');
    return 'DataStoreSpec($contents)';
  }
}

/// Tool to retrieve public web data for grounding, powered by Google.
final class GoogleSearchRetrieval extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GoogleSearchRetrieval';

  /// Specifies the dynamic retrieval configuration for the given source.
  final DynamicRetrievalConfig? dynamicRetrievalConfig;

  GoogleSearchRetrieval({this.dynamicRetrievalConfig})
    : super(fullyQualifiedName);

  factory GoogleSearchRetrieval.fromJson(Map<String, dynamic> json) {
    return GoogleSearchRetrieval(
      dynamicRetrievalConfig: decode(
        json['dynamicRetrievalConfig'],
        DynamicRetrievalConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (dynamicRetrievalConfig != null)
        'dynamicRetrievalConfig': dynamicRetrievalConfig!.toJson(),
    };
  }

  @override
  String toString() => 'GoogleSearchRetrieval()';
}

/// Tool to retrieve public maps data for grounding, powered by Google.
final class GoogleMaps extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GoogleMaps';

  /// If true, include the widget context token in the response.
  final bool? enableWidget;

  GoogleMaps({this.enableWidget}) : super(fullyQualifiedName);

  factory GoogleMaps.fromJson(Map<String, dynamic> json) {
    return GoogleMaps(enableWidget: json['enableWidget']);
  }

  @override
  Object toJson() {
    return {if (enableWidget != null) 'enableWidget': enableWidget};
  }

  @override
  String toString() {
    final contents = [
      if (enableWidget != null) 'enableWidget=$enableWidget',
    ].join(',');
    return 'GoogleMaps($contents)';
  }
}

/// Tool to search public web data, powered by Vertex AI Search and Sec4
/// compliance.
final class EnterpriseWebSearch extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EnterpriseWebSearch';

  /// Optional. List of domains to be excluded from the search results.
  /// The default limit is 2000 domains.
  final List<String>? excludeDomains;

  /// Optional. Sites with confidence level chosen & above this value will be
  /// blocked from the search results.
  final Tool_PhishBlockThreshold? blockingConfidence;

  EnterpriseWebSearch({this.excludeDomains, this.blockingConfidence})
    : super(fullyQualifiedName);

  factory EnterpriseWebSearch.fromJson(Map<String, dynamic> json) {
    return EnterpriseWebSearch(
      excludeDomains: decodeList(json['excludeDomains']),
      blockingConfidence: decodeEnum(
        json['blockingConfidence'],
        Tool_PhishBlockThreshold.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (excludeDomains != null) 'excludeDomains': excludeDomains,
      if (blockingConfidence != null)
        'blockingConfidence': blockingConfidence!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (blockingConfidence != null) 'blockingConfidence=$blockingConfidence',
    ].join(',');
    return 'EnterpriseWebSearch($contents)';
  }
}

/// Describes the options to customize dynamic retrieval.
final class DynamicRetrievalConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DynamicRetrievalConfig';

  /// The mode of the predictor to be used in dynamic retrieval.
  final DynamicRetrievalConfig_Mode? mode;

  /// Optional. The threshold to be used in dynamic retrieval.
  /// If not set, a system default value is used.
  final double? dynamicThreshold;

  DynamicRetrievalConfig({this.mode, this.dynamicThreshold})
    : super(fullyQualifiedName);

  factory DynamicRetrievalConfig.fromJson(Map<String, dynamic> json) {
    return DynamicRetrievalConfig(
      mode: decodeEnum(json['mode'], DynamicRetrievalConfig_Mode.fromJson),
      dynamicThreshold: decodeDouble(json['dynamicThreshold']),
    );
  }

  @override
  Object toJson() {
    return {
      if (mode != null) 'mode': mode!.toJson(),
      if (dynamicThreshold != null)
        'dynamicThreshold': encodeDouble(dynamicThreshold),
    };
  }

  @override
  String toString() {
    final contents = [
      if (mode != null) 'mode=$mode',
      if (dynamicThreshold != null) 'dynamicThreshold=$dynamicThreshold',
    ].join(',');
    return 'DynamicRetrievalConfig($contents)';
  }
}

/// The mode of the predictor to be used in dynamic retrieval.
final class DynamicRetrievalConfig_Mode extends protobuf.ProtoEnum {
  /// Always trigger retrieval.
  static const modeUnspecified = DynamicRetrievalConfig_Mode(
    'MODE_UNSPECIFIED',
  );

  /// Run retrieval only when system decides it is necessary.
  static const modeDynamic = DynamicRetrievalConfig_Mode('MODE_DYNAMIC');

  const DynamicRetrievalConfig_Mode(super.value);

  factory DynamicRetrievalConfig_Mode.fromJson(String json) =>
      DynamicRetrievalConfig_Mode(json);

  @override
  String toString() => 'Mode.$value';
}

/// Tool config. This config is shared for all tools provided in the request.
final class ToolConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ToolConfig';

  /// Optional. Function calling config.
  final FunctionCallingConfig? functionCallingConfig;

  /// Optional. Retrieval config.
  final RetrievalConfig? retrievalConfig;

  ToolConfig({this.functionCallingConfig, this.retrievalConfig})
    : super(fullyQualifiedName);

  factory ToolConfig.fromJson(Map<String, dynamic> json) {
    return ToolConfig(
      functionCallingConfig: decode(
        json['functionCallingConfig'],
        FunctionCallingConfig.fromJson,
      ),
      retrievalConfig: decode(
        json['retrievalConfig'],
        RetrievalConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (functionCallingConfig != null)
        'functionCallingConfig': functionCallingConfig!.toJson(),
      if (retrievalConfig != null) 'retrievalConfig': retrievalConfig!.toJson(),
    };
  }

  @override
  String toString() => 'ToolConfig()';
}

/// Function calling config.
final class FunctionCallingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FunctionCallingConfig';

  /// Optional. Function calling mode.
  final FunctionCallingConfig_Mode? mode;

  /// Optional. Function names to call. Only set when the Mode is ANY. Function
  /// names should match [FunctionDeclaration.name]. With mode set to ANY, model
  /// will predict a function call from the set of function names provided.
  final List<String>? allowedFunctionNames;

  FunctionCallingConfig({this.mode, this.allowedFunctionNames})
    : super(fullyQualifiedName);

  factory FunctionCallingConfig.fromJson(Map<String, dynamic> json) {
    return FunctionCallingConfig(
      mode: decodeEnum(json['mode'], FunctionCallingConfig_Mode.fromJson),
      allowedFunctionNames: decodeList(json['allowedFunctionNames']),
    );
  }

  @override
  Object toJson() {
    return {
      if (mode != null) 'mode': mode!.toJson(),
      if (allowedFunctionNames != null)
        'allowedFunctionNames': allowedFunctionNames,
    };
  }

  @override
  String toString() {
    final contents = [if (mode != null) 'mode=$mode'].join(',');
    return 'FunctionCallingConfig($contents)';
  }
}

/// Function calling mode.
final class FunctionCallingConfig_Mode extends protobuf.ProtoEnum {
  /// Unspecified function calling mode. This value should not be used.
  static const modeUnspecified = FunctionCallingConfig_Mode('MODE_UNSPECIFIED');

  /// Default model behavior, model decides to predict either function calls
  /// or natural language response.
  static const auto = FunctionCallingConfig_Mode('AUTO');

  /// Model is constrained to always predicting function calls only.
  /// If `allowed_function_names`
  /// are set, the predicted function calls will be limited to any one of
  /// `allowed_function_names`, else the predicted function calls will be any
  /// one of the provided [FunctionDeclaration].
  static const any = FunctionCallingConfig_Mode('ANY');

  /// Model will not predict any function calls. Model behavior is same as when
  /// not passing any function declarations.
  static const none = FunctionCallingConfig_Mode('NONE');

  /// Model is constrained to predict either function calls or natural language
  /// response.
  /// If `allowed_function_names`
  /// are set, the predicted function calls will be limited to any one of
  /// `allowed_function_names`, else the predicted function calls will be any
  /// one of the provided [FunctionDeclaration].
  static const validated = FunctionCallingConfig_Mode('VALIDATED');

  const FunctionCallingConfig_Mode(super.value);

  factory FunctionCallingConfig_Mode.fromJson(String json) =>
      FunctionCallingConfig_Mode(json);

  @override
  String toString() => 'Mode.$value';
}

/// Retrieval config.
final class RetrievalConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrievalConfig';

  /// The location of the user.
  final LatLng? latLng;

  /// The language code of the user.
  final String? languageCode;

  RetrievalConfig({this.latLng, this.languageCode}) : super(fullyQualifiedName);

  factory RetrievalConfig.fromJson(Map<String, dynamic> json) {
    return RetrievalConfig(
      latLng: decode(json['latLng'], LatLng.fromJson),
      languageCode: json['languageCode'],
    );
  }

  @override
  Object toJson() {
    return {
      if (latLng != null) 'latLng': latLng!.toJson(),
      if (languageCode != null) 'languageCode': languageCode,
    };
  }

  @override
  String toString() {
    final contents = [
      if (languageCode != null) 'languageCode=$languageCode',
    ].join(',');
    return 'RetrievalConfig($contents)';
  }
}

/// Specifies the context retrieval config.
final class RagRetrievalConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig';

  /// Optional. The number of contexts to retrieve.
  final int? topK;

  /// Optional. Config for Hybrid Search.
  final RagRetrievalConfig_HybridSearch? hybridSearch;

  /// Optional. Config for filters.
  final RagRetrievalConfig_Filter? filter;

  /// Optional. Config for ranking and reranking.
  final RagRetrievalConfig_Ranking? ranking;

  RagRetrievalConfig({this.topK, this.hybridSearch, this.filter, this.ranking})
    : super(fullyQualifiedName);

  factory RagRetrievalConfig.fromJson(Map<String, dynamic> json) {
    return RagRetrievalConfig(
      topK: json['topK'],
      hybridSearch: decode(
        json['hybridSearch'],
        RagRetrievalConfig_HybridSearch.fromJson,
      ),
      filter: decode(json['filter'], RagRetrievalConfig_Filter.fromJson),
      ranking: decode(json['ranking'], RagRetrievalConfig_Ranking.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (topK != null) 'topK': topK,
      if (hybridSearch != null) 'hybridSearch': hybridSearch!.toJson(),
      if (filter != null) 'filter': filter!.toJson(),
      if (ranking != null) 'ranking': ranking!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (topK != null) 'topK=$topK'].join(',');
    return 'RagRetrievalConfig($contents)';
  }
}

/// Config for Hybrid Search.
final class RagRetrievalConfig_HybridSearch extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.HybridSearch';

  /// Optional. Alpha value controls the weight between dense and sparse vector
  /// search results. The range is [0, 1], while 0 means sparse vector search
  /// only and 1 means dense vector search only. The default value is 0.5 which
  /// balances sparse and dense vector search equally.
  final double? alpha;

  RagRetrievalConfig_HybridSearch({this.alpha}) : super(fullyQualifiedName);

  factory RagRetrievalConfig_HybridSearch.fromJson(Map<String, dynamic> json) {
    return RagRetrievalConfig_HybridSearch(alpha: decodeDouble(json['alpha']));
  }

  @override
  Object toJson() {
    return {if (alpha != null) 'alpha': encodeDouble(alpha)};
  }

  @override
  String toString() {
    final contents = [if (alpha != null) 'alpha=$alpha'].join(',');
    return 'HybridSearch($contents)';
  }
}

/// Config for filters.
final class RagRetrievalConfig_Filter extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.Filter';

  /// Optional. Only returns contexts with vector distance smaller than the
  /// threshold.
  final double? vectorDistanceThreshold;

  /// Optional. Only returns contexts with vector similarity larger than the
  /// threshold.
  final double? vectorSimilarityThreshold;

  /// Optional. String for metadata filtering.
  final String? metadataFilter;

  RagRetrievalConfig_Filter({
    this.vectorDistanceThreshold,
    this.vectorSimilarityThreshold,
    this.metadataFilter,
  }) : super(fullyQualifiedName);

  factory RagRetrievalConfig_Filter.fromJson(Map<String, dynamic> json) {
    return RagRetrievalConfig_Filter(
      vectorDistanceThreshold: decodeDouble(json['vectorDistanceThreshold']),
      vectorSimilarityThreshold: decodeDouble(
        json['vectorSimilarityThreshold'],
      ),
      metadataFilter: json['metadataFilter'],
    );
  }

  @override
  Object toJson() {
    return {
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold': encodeDouble(vectorDistanceThreshold),
      if (vectorSimilarityThreshold != null)
        'vectorSimilarityThreshold': encodeDouble(vectorSimilarityThreshold),
      if (metadataFilter != null) 'metadataFilter': metadataFilter,
    };
  }

  @override
  String toString() {
    final contents = [
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold=$vectorDistanceThreshold',
      if (vectorSimilarityThreshold != null)
        'vectorSimilarityThreshold=$vectorSimilarityThreshold',
      if (metadataFilter != null) 'metadataFilter=$metadataFilter',
    ].join(',');
    return 'Filter($contents)';
  }
}

/// Config for ranking and reranking.
final class RagRetrievalConfig_Ranking extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.Ranking';

  /// Optional. Config for Rank Service.
  final RagRetrievalConfig_Ranking_RankService? rankService;

  /// Optional. Config for LlmRanker.
  final RagRetrievalConfig_Ranking_LlmRanker? llmRanker;

  RagRetrievalConfig_Ranking({this.rankService, this.llmRanker})
    : super(fullyQualifiedName);

  factory RagRetrievalConfig_Ranking.fromJson(Map<String, dynamic> json) {
    return RagRetrievalConfig_Ranking(
      rankService: decode(
        json['rankService'],
        RagRetrievalConfig_Ranking_RankService.fromJson,
      ),
      llmRanker: decode(
        json['llmRanker'],
        RagRetrievalConfig_Ranking_LlmRanker.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (rankService != null) 'rankService': rankService!.toJson(),
      if (llmRanker != null) 'llmRanker': llmRanker!.toJson(),
    };
  }

  @override
  String toString() => 'Ranking()';
}

/// Config for Rank Service.
final class RagRetrievalConfig_Ranking_RankService
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.Ranking.RankService';

  /// Optional. The model name of the rank service.
  /// Format: `semantic-ranker-512@latest`
  final String? modelName;

  RagRetrievalConfig_Ranking_RankService({this.modelName})
    : super(fullyQualifiedName);

  factory RagRetrievalConfig_Ranking_RankService.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagRetrievalConfig_Ranking_RankService(modelName: json['modelName']);
  }

  @override
  Object toJson() {
    return {if (modelName != null) 'modelName': modelName};
  }

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'RankService($contents)';
  }
}

/// Config for LlmRanker.
final class RagRetrievalConfig_Ranking_LlmRanker extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagRetrievalConfig.Ranking.LlmRanker';

  /// Optional. The model name used for ranking.
  /// Format: `gemini-1.5-pro`
  final String? modelName;

  RagRetrievalConfig_Ranking_LlmRanker({this.modelName})
    : super(fullyQualifiedName);

  factory RagRetrievalConfig_Ranking_LlmRanker.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagRetrievalConfig_Ranking_LlmRanker(modelName: json['modelName']);
  }

  @override
  Object toJson() {
    return {if (modelName != null) 'modelName': modelName};
  }

  @override
  String toString() {
    final contents = [if (modelName != null) 'modelName=$modelName'].join(',');
    return 'LlmRanker($contents)';
  }
}

/// The TrainingPipeline orchestrates tasks associated with training a Model. It
/// always executes the training task, and optionally may also
/// export data from Vertex AI's Dataset which becomes the training input,
/// `upload` the Model
/// to Vertex AI, and evaluate the Model.
final class TrainingPipeline extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TrainingPipeline';

  /// Output only. Resource name of the TrainingPipeline.
  final String? name;

  /// Required. The user-defined name of this TrainingPipeline.
  final String? displayName;

  /// Specifies Vertex AI owned input data that may be used for training the
  /// Model. The TrainingPipeline's
  /// `training_task_definition`
  /// should make clear whether this config is used and if there are any special
  /// requirements on how it should be filled. If nothing about this config is
  /// mentioned in the
  /// `training_task_definition`,
  /// then it should be assumed that the TrainingPipeline does not depend on this
  /// configuration.
  final InputDataConfig? inputDataConfig;

  /// Required. A Google Cloud Storage path to the YAML file that defines the
  /// training task which is responsible for producing the model artifact, and
  /// may also include additional auxiliary work. The definition files that can
  /// be used here are found in
  /// gs://google-cloud-aiplatform/schema/trainingjob/definition/.
  /// Note: The URI given on output will be immutable and probably different,
  /// including the URI scheme, than the one given on input. The output URI will
  /// point to a location where the user only has a read access.
  final String? trainingTaskDefinition;

  /// Required. The training task's parameter(s), as specified in the
  /// `training_task_definition`'s
  /// `inputs`.
  final protobuf.Value? trainingTaskInputs;

  /// Output only. The metadata information as specified in the
  /// `training_task_definition`'s
  /// `metadata`. This metadata is an auxiliary runtime and final information
  /// about the training task. While the pipeline is running this information is
  /// populated only at a best effort basis. Only present if the
  /// pipeline's
  /// `training_task_definition`
  /// contains `metadata` object.
  final protobuf.Value? trainingTaskMetadata;

  /// Describes the Model that may be uploaded (via
  /// `ModelService.UploadModel`)
  /// by this TrainingPipeline. The TrainingPipeline's
  /// `training_task_definition`
  /// should make clear whether this Model description should be populated, and
  /// if there are any special requirements regarding how it should be filled. If
  /// nothing is mentioned in the
  /// `training_task_definition`,
  /// then it should be assumed that this field should not be filled and the
  /// training task either uploads the Model without a need of this information,
  /// or that training task does not support uploading a Model as part of the
  /// pipeline. When the Pipeline's state becomes `PIPELINE_STATE_SUCCEEDED` and
  /// the trained Model had been uploaded into Vertex AI, then the
  /// model_to_upload's resource
  /// `name` is populated. The Model
  /// is always uploaded into the Project and Location in which this pipeline
  /// is.
  final Model? modelToUpload;

  /// Optional. The ID to use for the uploaded Model, which will become the final
  /// component of the model resource name.
  ///
  /// This value may be up to 63 characters, and valid characters are
  /// `[a-z0-9_-]`. The first character cannot be a number or hyphen.
  final String? modelId;

  /// Optional. When specify this field, the `model_to_upload` will not be
  /// uploaded as a new model, instead, it will become a new version of this
  /// `parent_model`.
  final String? parentModel;

  /// Output only. The detailed state of the pipeline.
  final PipelineState? state;

  /// Output only. Only populated when the pipeline's state is
  /// `PIPELINE_STATE_FAILED` or `PIPELINE_STATE_CANCELLED`.
  final Status? error;

  /// Output only. Time when the TrainingPipeline was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the TrainingPipeline for the first time entered the
  /// `PIPELINE_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the TrainingPipeline entered any of the following
  /// states: `PIPELINE_STATE_SUCCEEDED`, `PIPELINE_STATE_FAILED`,
  /// `PIPELINE_STATE_CANCELLED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the TrainingPipeline was most recently updated.
  final protobuf.Timestamp? updateTime;

  /// The labels with user-defined metadata to organize TrainingPipelines.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Customer-managed encryption key spec for a TrainingPipeline. If set, this
  /// TrainingPipeline will be secured by this key.
  ///
  /// Note: Model trained by this TrainingPipeline is also secured by this key if
  /// `model_to_upload`
  /// is not set separately.
  final EncryptionSpec? encryptionSpec;

  TrainingPipeline({
    this.name,
    this.displayName,
    this.inputDataConfig,
    this.trainingTaskDefinition,
    this.trainingTaskInputs,
    this.trainingTaskMetadata,
    this.modelToUpload,
    this.modelId,
    this.parentModel,
    this.state,
    this.error,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.labels,
    this.encryptionSpec,
  }) : super(fullyQualifiedName);

  factory TrainingPipeline.fromJson(Map<String, dynamic> json) {
    return TrainingPipeline(
      name: json['name'],
      displayName: json['displayName'],
      inputDataConfig: decode(
        json['inputDataConfig'],
        InputDataConfig.fromJson,
      ),
      trainingTaskDefinition: json['trainingTaskDefinition'],
      trainingTaskInputs: decodeCustom(
        json['trainingTaskInputs'],
        protobuf.Value.fromJson,
      ),
      trainingTaskMetadata: decodeCustom(
        json['trainingTaskMetadata'],
        protobuf.Value.fromJson,
      ),
      modelToUpload: decode(json['modelToUpload'], Model.fromJson),
      modelId: json['modelId'],
      parentModel: json['parentModel'],
      state: decodeEnum(json['state'], PipelineState.fromJson),
      error: decode(json['error'], Status.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      labels: decodeMap(json['labels']),
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (inputDataConfig != null) 'inputDataConfig': inputDataConfig!.toJson(),
      if (trainingTaskDefinition != null)
        'trainingTaskDefinition': trainingTaskDefinition,
      if (trainingTaskInputs != null)
        'trainingTaskInputs': trainingTaskInputs!.toJson(),
      if (trainingTaskMetadata != null)
        'trainingTaskMetadata': trainingTaskMetadata!.toJson(),
      if (modelToUpload != null) 'modelToUpload': modelToUpload!.toJson(),
      if (modelId != null) 'modelId': modelId,
      if (parentModel != null) 'parentModel': parentModel,
      if (state != null) 'state': state!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (labels != null) 'labels': labels,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (trainingTaskDefinition != null)
        'trainingTaskDefinition=$trainingTaskDefinition',
      if (modelId != null) 'modelId=$modelId',
      if (parentModel != null) 'parentModel=$parentModel',
      if (state != null) 'state=$state',
    ].join(',');
    return 'TrainingPipeline($contents)';
  }
}

/// Specifies Vertex AI owned input data to be used for training, and
/// possibly evaluating, the Model.
final class InputDataConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.InputDataConfig';

  /// Split based on fractions defining the size of each set.
  final FractionSplit? fractionSplit;

  /// Split based on the provided filters for each set.
  final FilterSplit? filterSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on a predefined key.
  final PredefinedSplit? predefinedSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the timestamp of the input data pieces.
  final TimestampSplit? timestampSplit;

  /// Supported only for tabular Datasets.
  ///
  /// Split based on the distribution of the specified column.
  final StratifiedSplit? stratifiedSplit;

  /// The Cloud Storage location where the training data is to be
  /// written to. In the given directory a new directory is created with
  /// name:
  /// `dataset-<dataset-id>-<annotation-type>-<timestamp-of-training-call>`
  /// where timestamp is in YYYY-MM-DDThh:mm:ss.sssZ ISO-8601 format.
  /// All training input data is written into that directory.
  ///
  /// The Vertex AI environment variables representing Cloud Storage
  /// data URIs are represented in the Cloud Storage wildcard
  /// format to support sharded data. e.g.: "gs://.../training-*.jsonl"
  ///
  /// * AIP_DATA_FORMAT = "jsonl" for non-tabular data, "csv" for tabular data
  /// * AIP_TRAINING_DATA_URI =
  /// "gcs_destination/dataset-<dataset-id>-<annotation-type>-<time>/training-*.${AIP_DATA_FORMAT}"
  ///
  /// * AIP_VALIDATION_DATA_URI =
  /// "gcs_destination/dataset-<dataset-id>-<annotation-type>-<time>/validation-*.${AIP_DATA_FORMAT}"
  ///
  /// * AIP_TEST_DATA_URI =
  /// "gcs_destination/dataset-<dataset-id>-<annotation-type>-<time>/test-*.${AIP_DATA_FORMAT}"
  final GcsDestination? gcsDestination;

  /// Only applicable to custom training with tabular Dataset with BigQuery
  /// source.
  ///
  /// The BigQuery project location where the training data is to be written
  /// to. In the given project a new dataset is created with name
  /// `dataset_<dataset-id>_<annotation-type>_<timestamp-of-training-call>`
  /// where timestamp is in YYYY_MM_DDThh_mm_ss_sssZ format. All training
  /// input data is written into that dataset. In the dataset three
  /// tables are created, `training`, `validation` and `test`.
  ///
  /// * AIP_DATA_FORMAT = "bigquery".
  /// * AIP_TRAINING_DATA_URI  =
  /// "bigquery_destination.dataset_<dataset-id>_<annotation-type>_<time>.training"
  ///
  /// * AIP_VALIDATION_DATA_URI =
  /// "bigquery_destination.dataset_<dataset-id>_<annotation-type>_<time>.validation"
  ///
  /// * AIP_TEST_DATA_URI =
  /// "bigquery_destination.dataset_<dataset-id>_<annotation-type>_<time>.test"
  final BigQueryDestination? bigqueryDestination;

  /// Required. The ID of the Dataset in the same Project and Location which data
  /// will be used to train the Model. The Dataset must use schema compatible
  /// with Model being trained, and what is compatible should be described in the
  /// used TrainingPipeline's [training_task_definition]
  /// [google.cloud.aiplatform.v1beta1.TrainingPipeline.training_task_definition].
  /// For tabular Datasets, all their data is exported to training, to pick
  /// and choose from.
  final String? datasetId;

  /// Applicable only to Datasets that have DataItems and Annotations.
  ///
  /// A filter on Annotations of the Dataset. Only Annotations that both
  /// match this filter and belong to DataItems not ignored by the split method
  /// are used in respectively training, validation or test role, depending on
  /// the role of the DataItem they are on (for the auto-assigned that role is
  /// decided by Vertex AI). A filter with same syntax as the one used in
  /// `ListAnnotations`
  /// may be used, but note here it filters across all Annotations of the
  /// Dataset, and not just within a single DataItem.
  final String? annotationsFilter;

  /// Applicable only to custom training with Datasets that have DataItems and
  /// Annotations.
  ///
  /// Cloud Storage URI that points to a YAML file describing the annotation
  /// schema. The schema is defined as an OpenAPI 3.0.2 [Schema
  /// Object](https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.2.md#schemaObject).
  /// The schema files that can be used here are found in
  /// gs://google-cloud-aiplatform/schema/dataset/annotation/ , note that the
  /// chosen schema must be consistent with
  /// `metadata` of
  /// the Dataset specified by
  /// `dataset_id`.
  ///
  /// Only Annotations that both match this schema and belong to DataItems not
  /// ignored by the split method are used in respectively training, validation
  /// or test role, depending on the role of the DataItem they are on.
  ///
  /// When used in conjunction with
  /// `annotations_filter`,
  /// the Annotations used for training are filtered by both
  /// `annotations_filter`
  /// and
  /// `annotation_schema_uri`.
  final String? annotationSchemaUri;

  /// Only applicable to Datasets that have SavedQueries.
  ///
  /// The ID of a SavedQuery (annotation set) under the Dataset specified by
  /// `dataset_id`
  /// used for filtering Annotations for training.
  ///
  /// Only Annotations that are associated with this SavedQuery are used in
  /// respectively training. When used in conjunction with
  /// `annotations_filter`,
  /// the Annotations used for training are filtered by both
  /// `saved_query_id`
  /// and
  /// `annotations_filter`.
  ///
  /// Only one of
  /// `saved_query_id`
  /// and
  /// `annotation_schema_uri`
  /// should be specified as both of them represent the same thing: problem type.
  final String? savedQueryId;

  /// Whether to persist the ML use assignment to data item system labels.
  final bool? persistMlUseAssignment;

  InputDataConfig({
    this.fractionSplit,
    this.filterSplit,
    this.predefinedSplit,
    this.timestampSplit,
    this.stratifiedSplit,
    this.gcsDestination,
    this.bigqueryDestination,
    this.datasetId,
    this.annotationsFilter,
    this.annotationSchemaUri,
    this.savedQueryId,
    this.persistMlUseAssignment,
  }) : super(fullyQualifiedName);

  factory InputDataConfig.fromJson(Map<String, dynamic> json) {
    return InputDataConfig(
      fractionSplit: decode(json['fractionSplit'], FractionSplit.fromJson),
      filterSplit: decode(json['filterSplit'], FilterSplit.fromJson),
      predefinedSplit: decode(
        json['predefinedSplit'],
        PredefinedSplit.fromJson,
      ),
      timestampSplit: decode(json['timestampSplit'], TimestampSplit.fromJson),
      stratifiedSplit: decode(
        json['stratifiedSplit'],
        StratifiedSplit.fromJson,
      ),
      gcsDestination: decode(json['gcsDestination'], GcsDestination.fromJson),
      bigqueryDestination: decode(
        json['bigqueryDestination'],
        BigQueryDestination.fromJson,
      ),
      datasetId: json['datasetId'],
      annotationsFilter: json['annotationsFilter'],
      annotationSchemaUri: json['annotationSchemaUri'],
      savedQueryId: json['savedQueryId'],
      persistMlUseAssignment: json['persistMlUseAssignment'],
    );
  }

  @override
  Object toJson() {
    return {
      if (fractionSplit != null) 'fractionSplit': fractionSplit!.toJson(),
      if (filterSplit != null) 'filterSplit': filterSplit!.toJson(),
      if (predefinedSplit != null) 'predefinedSplit': predefinedSplit!.toJson(),
      if (timestampSplit != null) 'timestampSplit': timestampSplit!.toJson(),
      if (stratifiedSplit != null) 'stratifiedSplit': stratifiedSplit!.toJson(),
      if (gcsDestination != null) 'gcsDestination': gcsDestination!.toJson(),
      if (bigqueryDestination != null)
        'bigqueryDestination': bigqueryDestination!.toJson(),
      if (datasetId != null) 'datasetId': datasetId,
      if (annotationsFilter != null) 'annotationsFilter': annotationsFilter,
      if (annotationSchemaUri != null)
        'annotationSchemaUri': annotationSchemaUri,
      if (savedQueryId != null) 'savedQueryId': savedQueryId,
      if (persistMlUseAssignment != null)
        'persistMlUseAssignment': persistMlUseAssignment,
    };
  }

  @override
  String toString() {
    final contents = [
      if (datasetId != null) 'datasetId=$datasetId',
      if (annotationsFilter != null) 'annotationsFilter=$annotationsFilter',
      if (annotationSchemaUri != null)
        'annotationSchemaUri=$annotationSchemaUri',
      if (savedQueryId != null) 'savedQueryId=$savedQueryId',
      if (persistMlUseAssignment != null)
        'persistMlUseAssignment=$persistMlUseAssignment',
    ].join(',');
    return 'InputDataConfig($contents)';
  }
}

/// Assigns the input data to training, validation, and test sets as per the
/// given fractions. Any of `training_fraction`, `validation_fraction` and
/// `test_fraction` may optionally be provided, they must sum to up to 1. If the
/// provided ones sum to less than 1, the remainder is assigned to sets as
/// decided by Vertex AI. If none of the fractions are set, by default roughly
/// 80% of data is used for training, 10% for validation, and 10% for test.
final class FractionSplit extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FractionSplit';

  /// The fraction of the input data that is to be used to train the Model.
  final double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  final double? validationFraction;

  /// The fraction of the input data that is to be used to evaluate the Model.
  final double? testFraction;

  FractionSplit({
    this.trainingFraction,
    this.validationFraction,
    this.testFraction,
  }) : super(fullyQualifiedName);

  factory FractionSplit.fromJson(Map<String, dynamic> json) {
    return FractionSplit(
      trainingFraction: decodeDouble(json['trainingFraction']),
      validationFraction: decodeDouble(json['validationFraction']),
      testFraction: decodeDouble(json['testFraction']),
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingFraction != null)
        'trainingFraction': encodeDouble(trainingFraction),
      if (validationFraction != null)
        'validationFraction': encodeDouble(validationFraction),
      if (testFraction != null) 'testFraction': encodeDouble(testFraction),
    };
  }

  @override
  String toString() {
    final contents = [
      if (trainingFraction != null) 'trainingFraction=$trainingFraction',
      if (validationFraction != null) 'validationFraction=$validationFraction',
      if (testFraction != null) 'testFraction=$testFraction',
    ].join(',');
    return 'FractionSplit($contents)';
  }
}

/// Assigns input data to training, validation, and test sets based on the given
/// filters, data pieces not matched by any filter are ignored. Currently only
/// supported for Datasets containing DataItems.
/// If any of the filters in this message are to match nothing, then they can be
/// set as '-' (the minus sign).
///
/// Supported only for unstructured Datasets.
final class FilterSplit extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FilterSplit';

  /// Required. A filter on DataItems of the Dataset. DataItems that match
  /// this filter are used to train the Model. A filter with same syntax
  /// as the one used in
  /// `DatasetService.ListDataItems`
  /// may be used. If a single DataItem is matched by more than one of the
  /// FilterSplit filters, then it is assigned to the first set that applies to
  /// it in the training, validation, test order.
  final String? trainingFilter;

  /// Required. A filter on DataItems of the Dataset. DataItems that match
  /// this filter are used to validate the Model. A filter with same syntax
  /// as the one used in
  /// `DatasetService.ListDataItems`
  /// may be used. If a single DataItem is matched by more than one of the
  /// FilterSplit filters, then it is assigned to the first set that applies to
  /// it in the training, validation, test order.
  final String? validationFilter;

  /// Required. A filter on DataItems of the Dataset. DataItems that match
  /// this filter are used to test the Model. A filter with same syntax
  /// as the one used in
  /// `DatasetService.ListDataItems`
  /// may be used. If a single DataItem is matched by more than one of the
  /// FilterSplit filters, then it is assigned to the first set that applies to
  /// it in the training, validation, test order.
  final String? testFilter;

  FilterSplit({this.trainingFilter, this.validationFilter, this.testFilter})
    : super(fullyQualifiedName);

  factory FilterSplit.fromJson(Map<String, dynamic> json) {
    return FilterSplit(
      trainingFilter: json['trainingFilter'],
      validationFilter: json['validationFilter'],
      testFilter: json['testFilter'],
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingFilter != null) 'trainingFilter': trainingFilter,
      if (validationFilter != null) 'validationFilter': validationFilter,
      if (testFilter != null) 'testFilter': testFilter,
    };
  }

  @override
  String toString() {
    final contents = [
      if (trainingFilter != null) 'trainingFilter=$trainingFilter',
      if (validationFilter != null) 'validationFilter=$validationFilter',
      if (testFilter != null) 'testFilter=$testFilter',
    ].join(',');
    return 'FilterSplit($contents)';
  }
}

/// Assigns input data to training, validation, and test sets based on the
/// value of a provided key.
///
/// Supported only for tabular Datasets.
final class PredefinedSplit extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PredefinedSplit';

  /// Required. The key is a name of one of the Dataset's data columns.
  /// The value of the key (either the label's value or value in the column)
  /// must be one of {`training`, `validation`, `test`}, and it defines to which
  /// set the given piece of data is assigned. If for a piece of data the key
  /// is not present or has an invalid value, that piece is ignored by the
  /// pipeline.
  final String? key;

  PredefinedSplit({this.key}) : super(fullyQualifiedName);

  factory PredefinedSplit.fromJson(Map<String, dynamic> json) {
    return PredefinedSplit(key: json['key']);
  }

  @override
  Object toJson() {
    return {if (key != null) 'key': key};
  }

  @override
  String toString() {
    final contents = [if (key != null) 'key=$key'].join(',');
    return 'PredefinedSplit($contents)';
  }
}

/// Assigns input data to training, validation, and test sets based on a
/// provided timestamps. The youngest data pieces are assigned to training set,
/// next to validation set, and the oldest to the test set.
///
/// Supported only for tabular Datasets.
final class TimestampSplit extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TimestampSplit';

  /// The fraction of the input data that is to be used to train the Model.
  final double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  final double? validationFraction;

  /// The fraction of the input data that is to be used to evaluate the Model.
  final double? testFraction;

  /// Required. The key is a name of one of the Dataset's data columns.
  /// The values of the key (the values in the column) must be in RFC 3339
  /// `date-time` format, where `time-offset` = `"Z"`
  /// (e.g. 1985-04-12T23:20:50.52Z). If for a piece of data the key is not
  /// present or has an invalid value, that piece is ignored by the pipeline.
  final String? key;

  TimestampSplit({
    this.trainingFraction,
    this.validationFraction,
    this.testFraction,
    this.key,
  }) : super(fullyQualifiedName);

  factory TimestampSplit.fromJson(Map<String, dynamic> json) {
    return TimestampSplit(
      trainingFraction: decodeDouble(json['trainingFraction']),
      validationFraction: decodeDouble(json['validationFraction']),
      testFraction: decodeDouble(json['testFraction']),
      key: json['key'],
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingFraction != null)
        'trainingFraction': encodeDouble(trainingFraction),
      if (validationFraction != null)
        'validationFraction': encodeDouble(validationFraction),
      if (testFraction != null) 'testFraction': encodeDouble(testFraction),
      if (key != null) 'key': key,
    };
  }

  @override
  String toString() {
    final contents = [
      if (trainingFraction != null) 'trainingFraction=$trainingFraction',
      if (validationFraction != null) 'validationFraction=$validationFraction',
      if (testFraction != null) 'testFraction=$testFraction',
      if (key != null) 'key=$key',
    ].join(',');
    return 'TimestampSplit($contents)';
  }
}

/// Assigns input data to the training, validation, and test sets so that the
/// distribution of values found in the categorical column (as specified by the
/// `key` field) is mirrored within each split. The fraction values determine
/// the relative sizes of the splits.
///
/// For example, if the specified column has three values, with 50% of the rows
/// having value "A", 25% value "B", and 25% value "C", and the split fractions
/// are specified as 80/10/10, then the training set will constitute 80% of the
/// training data, with about 50% of the training set rows having the value "A"
/// for the specified column, about 25% having the value "B", and about 25%
/// having the value "C".
///
/// Only the top 500 occurring values are used; any values not in the top
/// 500 values are randomly assigned to a split. If less than three rows contain
/// a specific value, those rows are randomly assigned.
///
/// Supported only for tabular Datasets.
final class StratifiedSplit extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StratifiedSplit';

  /// The fraction of the input data that is to be used to train the Model.
  final double? trainingFraction;

  /// The fraction of the input data that is to be used to validate the Model.
  final double? validationFraction;

  /// The fraction of the input data that is to be used to evaluate the Model.
  final double? testFraction;

  /// Required. The key is a name of one of the Dataset's data columns.
  /// The key provided must be for a categorical column.
  final String? key;

  StratifiedSplit({
    this.trainingFraction,
    this.validationFraction,
    this.testFraction,
    this.key,
  }) : super(fullyQualifiedName);

  factory StratifiedSplit.fromJson(Map<String, dynamic> json) {
    return StratifiedSplit(
      trainingFraction: decodeDouble(json['trainingFraction']),
      validationFraction: decodeDouble(json['validationFraction']),
      testFraction: decodeDouble(json['testFraction']),
      key: json['key'],
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingFraction != null)
        'trainingFraction': encodeDouble(trainingFraction),
      if (validationFraction != null)
        'validationFraction': encodeDouble(validationFraction),
      if (testFraction != null) 'testFraction': encodeDouble(testFraction),
      if (key != null) 'key': key,
    };
  }

  @override
  String toString() {
    final contents = [
      if (trainingFraction != null) 'trainingFraction=$trainingFraction',
      if (validationFraction != null) 'validationFraction=$validationFraction',
      if (testFraction != null) 'testFraction=$testFraction',
      if (key != null) 'key=$key',
    ].join(',');
    return 'StratifiedSplit($contents)';
  }
}

/// Represents a TuningJob that runs with Google owned models.
final class TuningJob extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TuningJob';

  /// The base model that is being tuned. See [Supported
  /// models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/tuning#supported_models).
  final String? baseModel;

  /// The pre-tuned model for continuous tuning.
  final PreTunedModel? preTunedModel;

  /// Tuning Spec for Supervised Fine Tuning.
  final SupervisedTuningSpec? supervisedTuningSpec;

  /// Tuning Spec for Distillation.
  final DistillationSpec? distillationSpec;

  /// Tuning Spec for open sourced and third party Partner models.
  final PartnerModelTuningSpec? partnerModelTuningSpec;

  /// Tuning Spec for Veo Tuning.
  final VeoTuningSpec? veoTuningSpec;

  /// Output only. Identifier. Resource name of a TuningJob. Format:
  /// `projects/{project}/locations/{location}/tuningJobs/{tuning_job}`
  final String? name;

  /// Optional. The display name of the
  /// `TunedModel`. The name can be up to 128
  /// characters long and can consist of any UTF-8 characters.
  final String? tunedModelDisplayName;

  /// Optional. The description of the
  /// `TuningJob`.
  final String? description;

  /// Optional. The user-provided path to custom model weights. Set this field
  /// to tune a custom model. The path must be a Cloud Storage directory that
  /// contains the model weights in .safetensors format along with associated
  /// model metadata files. If this field is set, the base_model field must still
  /// be set to indicate which base model the custom model is derived from. This
  /// feature is only available for open source models.
  final String? customBaseModel;

  /// Output only. The detailed state of the job.
  final JobState? state;

  /// Output only. Time when the
  /// `TuningJob` was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Time when the
  /// `TuningJob` for the first time
  /// entered the `JOB_STATE_RUNNING` state.
  final protobuf.Timestamp? startTime;

  /// Output only. Time when the TuningJob entered any of the following
  /// `JobStates`: `JOB_STATE_SUCCEEDED`,
  /// `JOB_STATE_FAILED`, `JOB_STATE_CANCELLED`, `JOB_STATE_EXPIRED`.
  final protobuf.Timestamp? endTime;

  /// Output only. Time when the
  /// `TuningJob` was most recently
  /// updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. Only populated when job's state is `JOB_STATE_FAILED` or
  /// `JOB_STATE_CANCELLED`.
  final Status? error;

  /// Optional. The labels with user-defined metadata to organize
  /// `TuningJob` and generated resources
  /// such as `Model` and
  /// `Endpoint`.
  ///
  /// Label keys and values can be no longer than 64 characters
  /// (Unicode codepoints), can only contain lowercase letters, numeric
  /// characters, underscores and dashes. International characters are allowed.
  ///
  /// See https://goo.gl/xmQnxf for more information and examples of labels.
  final Map<String, String>? labels;

  /// Output only. The Experiment associated with this
  /// `TuningJob`.
  final String? experiment;

  /// Output only. The tuned model resources associated with this
  /// `TuningJob`.
  final TunedModel? tunedModel;

  /// Output only. The tuning data statistics associated with this
  /// `TuningJob`.
  final TuningDataStats? tuningDataStats;

  /// Output only. The resource name of the PipelineJob associated with the
  /// `TuningJob`. Format:
  /// `projects/{project}/locations/{location}/pipelineJobs/{pipeline_job}`.
  final String? pipelineJob;

  /// Customer-managed encryption key options for a TuningJob. If this is set,
  /// then all resources created by the TuningJob will be encrypted with the
  /// provided encryption key.
  final EncryptionSpec? encryptionSpec;

  /// The service account that the tuningJob workload runs as.
  /// If not specified, the Vertex AI Secure Fine-Tuned Service Agent in the
  /// project will be used. See
  /// https://cloud.google.com/iam/docs/service-agents#vertex-ai-secure-fine-tuning-service-agent
  ///
  /// Users starting the pipeline must have the `iam.serviceAccounts.actAs`
  /// permission on this service account.
  final String? serviceAccount;

  /// Optional. Cloud Storage path to the directory where tuning job outputs are
  /// written to. This field is only available and required for open source
  /// models.
  final String? outputUri;

  /// Output only. Evaluation runs for the Tuning Job.
  final List<EvaluateDatasetRun>? evaluateDatasetRuns;

  TuningJob({
    this.baseModel,
    this.preTunedModel,
    this.supervisedTuningSpec,
    this.distillationSpec,
    this.partnerModelTuningSpec,
    this.veoTuningSpec,
    this.name,
    this.tunedModelDisplayName,
    this.description,
    this.customBaseModel,
    this.state,
    this.createTime,
    this.startTime,
    this.endTime,
    this.updateTime,
    this.error,
    this.labels,
    this.experiment,
    this.tunedModel,
    this.tuningDataStats,
    this.pipelineJob,
    this.encryptionSpec,
    this.serviceAccount,
    this.outputUri,
    this.evaluateDatasetRuns,
  }) : super(fullyQualifiedName);

  factory TuningJob.fromJson(Map<String, dynamic> json) {
    return TuningJob(
      baseModel: json['baseModel'],
      preTunedModel: decode(json['preTunedModel'], PreTunedModel.fromJson),
      supervisedTuningSpec: decode(
        json['supervisedTuningSpec'],
        SupervisedTuningSpec.fromJson,
      ),
      distillationSpec: decode(
        json['distillationSpec'],
        DistillationSpec.fromJson,
      ),
      partnerModelTuningSpec: decode(
        json['partnerModelTuningSpec'],
        PartnerModelTuningSpec.fromJson,
      ),
      veoTuningSpec: decode(json['veoTuningSpec'], VeoTuningSpec.fromJson),
      name: json['name'],
      tunedModelDisplayName: json['tunedModelDisplayName'],
      description: json['description'],
      customBaseModel: json['customBaseModel'],
      state: decodeEnum(json['state'], JobState.fromJson),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      error: decode(json['error'], Status.fromJson),
      labels: decodeMap(json['labels']),
      experiment: json['experiment'],
      tunedModel: decode(json['tunedModel'], TunedModel.fromJson),
      tuningDataStats: decode(
        json['tuningDataStats'],
        TuningDataStats.fromJson,
      ),
      pipelineJob: json['pipelineJob'],
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      serviceAccount: json['serviceAccount'],
      outputUri: json['outputUri'],
      evaluateDatasetRuns: decodeListMessage(
        json['evaluateDatasetRuns'],
        EvaluateDatasetRun.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (baseModel != null) 'baseModel': baseModel,
      if (preTunedModel != null) 'preTunedModel': preTunedModel!.toJson(),
      if (supervisedTuningSpec != null)
        'supervisedTuningSpec': supervisedTuningSpec!.toJson(),
      if (distillationSpec != null)
        'distillationSpec': distillationSpec!.toJson(),
      if (partnerModelTuningSpec != null)
        'partnerModelTuningSpec': partnerModelTuningSpec!.toJson(),
      if (veoTuningSpec != null) 'veoTuningSpec': veoTuningSpec!.toJson(),
      if (name != null) 'name': name,
      if (tunedModelDisplayName != null)
        'tunedModelDisplayName': tunedModelDisplayName,
      if (description != null) 'description': description,
      if (customBaseModel != null) 'customBaseModel': customBaseModel,
      if (state != null) 'state': state!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (error != null) 'error': error!.toJson(),
      if (labels != null) 'labels': labels,
      if (experiment != null) 'experiment': experiment,
      if (tunedModel != null) 'tunedModel': tunedModel!.toJson(),
      if (tuningDataStats != null) 'tuningDataStats': tuningDataStats!.toJson(),
      if (pipelineJob != null) 'pipelineJob': pipelineJob,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (serviceAccount != null) 'serviceAccount': serviceAccount,
      if (outputUri != null) 'outputUri': outputUri,
      if (evaluateDatasetRuns != null)
        'evaluateDatasetRuns': encodeList(evaluateDatasetRuns),
    };
  }

  @override
  String toString() {
    final contents = [
      if (baseModel != null) 'baseModel=$baseModel',
      if (name != null) 'name=$name',
      if (tunedModelDisplayName != null)
        'tunedModelDisplayName=$tunedModelDisplayName',
      if (description != null) 'description=$description',
      if (customBaseModel != null) 'customBaseModel=$customBaseModel',
      if (state != null) 'state=$state',
      if (experiment != null) 'experiment=$experiment',
      if (pipelineJob != null) 'pipelineJob=$pipelineJob',
      if (serviceAccount != null) 'serviceAccount=$serviceAccount',
      if (outputUri != null) 'outputUri=$outputUri',
    ].join(',');
    return 'TuningJob($contents)';
  }
}

/// The Model Registry Model and Online Prediction Endpoint associated with
/// this `TuningJob`.
final class TunedModel extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TunedModel';

  /// Output only. The resource name of the TunedModel. Format:
  ///
  /// `projects/{project}/locations/{location}/models/{model}@{version_id}`
  ///
  /// When tuning from a base model, the version_id will be 1.
  ///
  /// For continuous tuning, the version id will be incremented by 1 from the
  /// last version id in the parent model. E.g.,
  /// `projects/{project}/locations/{location}/models/{model}@{last_version_id +
  /// 1}`
  final String? model;

  /// Output only. A resource name of an Endpoint. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`.
  final String? endpoint;

  /// Output only. The checkpoints associated with this TunedModel.
  /// This field is only populated for tuning jobs that enable intermediate
  /// checkpoints.
  final List<TunedModelCheckpoint>? checkpoints;

  TunedModel({this.model, this.endpoint, this.checkpoints})
    : super(fullyQualifiedName);

  factory TunedModel.fromJson(Map<String, dynamic> json) {
    return TunedModel(
      model: json['model'],
      endpoint: json['endpoint'],
      checkpoints: decodeListMessage(
        json['checkpoints'],
        TunedModelCheckpoint.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      if (endpoint != null) 'endpoint': endpoint,
      if (checkpoints != null) 'checkpoints': encodeList(checkpoints),
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (endpoint != null) 'endpoint=$endpoint',
    ].join(',');
    return 'TunedModel($contents)';
  }
}

/// Dataset distribution for Supervised Tuning.
final class SupervisedTuningDatasetDistribution extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedTuningDatasetDistribution';

  /// Output only. Sum of a given population of values.
  final int? sum;

  /// Output only. Sum of a given population of values that are billable.
  final int? billableSum;

  /// Output only. The minimum of the population values.
  final double? min;

  /// Output only. The maximum of the population values.
  final double? max;

  /// Output only. The arithmetic mean of the values in the population.
  final double? mean;

  /// Output only. The median of the values in the population.
  final double? median;

  /// Output only. The 5th percentile of the values in the population.
  final double? p5;

  /// Output only. The 95th percentile of the values in the population.
  final double? p95;

  /// Output only. Defines the histogram bucket.
  final List<SupervisedTuningDatasetDistribution_DatasetBucket>? buckets;

  SupervisedTuningDatasetDistribution({
    this.sum,
    this.billableSum,
    this.min,
    this.max,
    this.mean,
    this.median,
    this.p5,
    this.p95,
    this.buckets,
  }) : super(fullyQualifiedName);

  factory SupervisedTuningDatasetDistribution.fromJson(
    Map<String, dynamic> json,
  ) {
    return SupervisedTuningDatasetDistribution(
      sum: decodeInt64(json['sum']),
      billableSum: decodeInt64(json['billableSum']),
      min: decodeDouble(json['min']),
      max: decodeDouble(json['max']),
      mean: decodeDouble(json['mean']),
      median: decodeDouble(json['median']),
      p5: decodeDouble(json['p5']),
      p95: decodeDouble(json['p95']),
      buckets: decodeListMessage(
        json['buckets'],
        SupervisedTuningDatasetDistribution_DatasetBucket.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (sum != null) 'sum': encodeInt64(sum),
      if (billableSum != null) 'billableSum': encodeInt64(billableSum),
      if (min != null) 'min': encodeDouble(min),
      if (max != null) 'max': encodeDouble(max),
      if (mean != null) 'mean': encodeDouble(mean),
      if (median != null) 'median': encodeDouble(median),
      if (p5 != null) 'p5': encodeDouble(p5),
      if (p95 != null) 'p95': encodeDouble(p95),
      if (buckets != null) 'buckets': encodeList(buckets),
    };
  }

  @override
  String toString() {
    final contents = [
      if (sum != null) 'sum=$sum',
      if (billableSum != null) 'billableSum=$billableSum',
      if (min != null) 'min=$min',
      if (max != null) 'max=$max',
      if (mean != null) 'mean=$mean',
      if (median != null) 'median=$median',
      if (p5 != null) 'p5=$p5',
      if (p95 != null) 'p95=$p95',
    ].join(',');
    return 'SupervisedTuningDatasetDistribution($contents)';
  }
}

/// Dataset bucket used to create a histogram for the distribution given a
/// population of values.
final class SupervisedTuningDatasetDistribution_DatasetBucket
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedTuningDatasetDistribution.DatasetBucket';

  /// Output only. Number of values in the bucket.
  final double? count;

  /// Output only. Left bound of the bucket.
  final double? left;

  /// Output only. Right bound of the bucket.
  final double? right;

  SupervisedTuningDatasetDistribution_DatasetBucket({
    this.count,
    this.left,
    this.right,
  }) : super(fullyQualifiedName);

  factory SupervisedTuningDatasetDistribution_DatasetBucket.fromJson(
    Map<String, dynamic> json,
  ) {
    return SupervisedTuningDatasetDistribution_DatasetBucket(
      count: decodeDouble(json['count']),
      left: decodeDouble(json['left']),
      right: decodeDouble(json['right']),
    );
  }

  @override
  Object toJson() {
    return {
      if (count != null) 'count': encodeDouble(count),
      if (left != null) 'left': encodeDouble(left),
      if (right != null) 'right': encodeDouble(right),
    };
  }

  @override
  String toString() {
    final contents = [
      if (count != null) 'count=$count',
      if (left != null) 'left=$left',
      if (right != null) 'right=$right',
    ].join(',');
    return 'DatasetBucket($contents)';
  }
}

/// Tuning data statistics for Supervised Tuning.
final class SupervisedTuningDataStats extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedTuningDataStats';

  /// Output only. Number of examples in the tuning dataset.
  final int? tuningDatasetExampleCount;

  /// Output only. Number of tuning characters in the tuning dataset.
  final int? totalTuningCharacterCount;

  /// Output only. Number of billable characters in the tuning dataset.
  final int? totalBillableCharacterCount;

  /// Output only. Number of billable tokens in the tuning dataset.
  final int? totalBillableTokenCount;

  /// Output only. Number of tuning steps for this Tuning Job.
  final int? tuningStepCount;

  /// Output only. Dataset distributions for the user input tokens.
  final SupervisedTuningDatasetDistribution? userInputTokenDistribution;

  /// Output only. Dataset distributions for the user output tokens.
  final SupervisedTuningDatasetDistribution? userOutputTokenDistribution;

  /// Output only. Dataset distributions for the messages per example.
  final SupervisedTuningDatasetDistribution? userMessagePerExampleDistribution;

  /// Output only. Sample user messages in the training dataset uri.
  final List<Content>? userDatasetExamples;

  /// Output only. The number of examples in the dataset that have been dropped.
  /// An example can be dropped for reasons including: too many tokens, contains
  /// an invalid image, contains too many images, etc.
  final int? totalTruncatedExampleCount;

  /// Output only. A partial sample of the indices (starting from 1) of the
  /// dropped examples.
  final List<int>? truncatedExampleIndices;

  /// Output only. For each index in `truncated_example_indices`, the user-facing
  /// reason why the example was dropped.
  final List<String>? droppedExampleReasons;

  SupervisedTuningDataStats({
    this.tuningDatasetExampleCount,
    this.totalTuningCharacterCount,
    this.totalBillableCharacterCount,
    this.totalBillableTokenCount,
    this.tuningStepCount,
    this.userInputTokenDistribution,
    this.userOutputTokenDistribution,
    this.userMessagePerExampleDistribution,
    this.userDatasetExamples,
    this.totalTruncatedExampleCount,
    this.truncatedExampleIndices,
    this.droppedExampleReasons,
  }) : super(fullyQualifiedName);

  factory SupervisedTuningDataStats.fromJson(Map<String, dynamic> json) {
    return SupervisedTuningDataStats(
      tuningDatasetExampleCount: decodeInt64(json['tuningDatasetExampleCount']),
      totalTuningCharacterCount: decodeInt64(json['totalTuningCharacterCount']),
      totalBillableCharacterCount: decodeInt64(
        json['totalBillableCharacterCount'],
      ),
      totalBillableTokenCount: decodeInt64(json['totalBillableTokenCount']),
      tuningStepCount: decodeInt64(json['tuningStepCount']),
      userInputTokenDistribution: decode(
        json['userInputTokenDistribution'],
        SupervisedTuningDatasetDistribution.fromJson,
      ),
      userOutputTokenDistribution: decode(
        json['userOutputTokenDistribution'],
        SupervisedTuningDatasetDistribution.fromJson,
      ),
      userMessagePerExampleDistribution: decode(
        json['userMessagePerExampleDistribution'],
        SupervisedTuningDatasetDistribution.fromJson,
      ),
      userDatasetExamples: decodeListMessage(
        json['userDatasetExamples'],
        Content.fromJson,
      ),
      totalTruncatedExampleCount: decodeInt64(
        json['totalTruncatedExampleCount'],
      ),
      truncatedExampleIndices: decodeList(json['truncatedExampleIndices']),
      droppedExampleReasons: decodeList(json['droppedExampleReasons']),
    );
  }

  @override
  Object toJson() {
    return {
      if (tuningDatasetExampleCount != null)
        'tuningDatasetExampleCount': encodeInt64(tuningDatasetExampleCount),
      if (totalTuningCharacterCount != null)
        'totalTuningCharacterCount': encodeInt64(totalTuningCharacterCount),
      if (totalBillableCharacterCount != null)
        'totalBillableCharacterCount': encodeInt64(totalBillableCharacterCount),
      if (totalBillableTokenCount != null)
        'totalBillableTokenCount': encodeInt64(totalBillableTokenCount),
      if (tuningStepCount != null)
        'tuningStepCount': encodeInt64(tuningStepCount),
      if (userInputTokenDistribution != null)
        'userInputTokenDistribution': userInputTokenDistribution!.toJson(),
      if (userOutputTokenDistribution != null)
        'userOutputTokenDistribution': userOutputTokenDistribution!.toJson(),
      if (userMessagePerExampleDistribution != null)
        'userMessagePerExampleDistribution': userMessagePerExampleDistribution!
            .toJson(),
      if (userDatasetExamples != null)
        'userDatasetExamples': encodeList(userDatasetExamples),
      if (totalTruncatedExampleCount != null)
        'totalTruncatedExampleCount': encodeInt64(totalTruncatedExampleCount),
      if (truncatedExampleIndices != null)
        'truncatedExampleIndices': truncatedExampleIndices,
      if (droppedExampleReasons != null)
        'droppedExampleReasons': droppedExampleReasons,
    };
  }

  @override
  String toString() {
    final contents = [
      if (tuningDatasetExampleCount != null)
        'tuningDatasetExampleCount=$tuningDatasetExampleCount',
      if (totalTuningCharacterCount != null)
        'totalTuningCharacterCount=$totalTuningCharacterCount',
      if (totalBillableCharacterCount != null)
        'totalBillableCharacterCount=$totalBillableCharacterCount',
      if (totalBillableTokenCount != null)
        'totalBillableTokenCount=$totalBillableTokenCount',
      if (tuningStepCount != null) 'tuningStepCount=$tuningStepCount',
      if (totalTruncatedExampleCount != null)
        'totalTruncatedExampleCount=$totalTruncatedExampleCount',
    ].join(',');
    return 'SupervisedTuningDataStats($contents)';
  }
}

/// Distribution computed over a tuning dataset.
final class DatasetDistribution extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DatasetDistribution';

  /// Output only. Sum of a given population of values.
  final double? sum;

  /// Output only. The minimum of the population values.
  final double? min;

  /// Output only. The maximum of the population values.
  final double? max;

  /// Output only. The arithmetic mean of the values in the population.
  final double? mean;

  /// Output only. The median of the values in the population.
  final double? median;

  /// Output only. The 5th percentile of the values in the population.
  final double? p5;

  /// Output only. The 95th percentile of the values in the population.
  final double? p95;

  /// Output only. Defines the histogram bucket.
  final List<DatasetDistribution_DistributionBucket>? buckets;

  DatasetDistribution({
    this.sum,
    this.min,
    this.max,
    this.mean,
    this.median,
    this.p5,
    this.p95,
    this.buckets,
  }) : super(fullyQualifiedName);

  factory DatasetDistribution.fromJson(Map<String, dynamic> json) {
    return DatasetDistribution(
      sum: decodeDouble(json['sum']),
      min: decodeDouble(json['min']),
      max: decodeDouble(json['max']),
      mean: decodeDouble(json['mean']),
      median: decodeDouble(json['median']),
      p5: decodeDouble(json['p5']),
      p95: decodeDouble(json['p95']),
      buckets: decodeListMessage(
        json['buckets'],
        DatasetDistribution_DistributionBucket.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (sum != null) 'sum': encodeDouble(sum),
      if (min != null) 'min': encodeDouble(min),
      if (max != null) 'max': encodeDouble(max),
      if (mean != null) 'mean': encodeDouble(mean),
      if (median != null) 'median': encodeDouble(median),
      if (p5 != null) 'p5': encodeDouble(p5),
      if (p95 != null) 'p95': encodeDouble(p95),
      if (buckets != null) 'buckets': encodeList(buckets),
    };
  }

  @override
  String toString() {
    final contents = [
      if (sum != null) 'sum=$sum',
      if (min != null) 'min=$min',
      if (max != null) 'max=$max',
      if (mean != null) 'mean=$mean',
      if (median != null) 'median=$median',
      if (p5 != null) 'p5=$p5',
      if (p95 != null) 'p95=$p95',
    ].join(',');
    return 'DatasetDistribution($contents)';
  }
}

/// Dataset bucket used to create a histogram for the distribution given a
/// population of values.
final class DatasetDistribution_DistributionBucket
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DatasetDistribution.DistributionBucket';

  /// Output only. Number of values in the bucket.
  final int? count;

  /// Output only. Left bound of the bucket.
  final double? left;

  /// Output only. Right bound of the bucket.
  final double? right;

  DatasetDistribution_DistributionBucket({this.count, this.left, this.right})
    : super(fullyQualifiedName);

  factory DatasetDistribution_DistributionBucket.fromJson(
    Map<String, dynamic> json,
  ) {
    return DatasetDistribution_DistributionBucket(
      count: decodeInt64(json['count']),
      left: decodeDouble(json['left']),
      right: decodeDouble(json['right']),
    );
  }

  @override
  Object toJson() {
    return {
      if (count != null) 'count': encodeInt64(count),
      if (left != null) 'left': encodeDouble(left),
      if (right != null) 'right': encodeDouble(right),
    };
  }

  @override
  String toString() {
    final contents = [
      if (count != null) 'count=$count',
      if (left != null) 'left=$left',
      if (right != null) 'right=$right',
    ].join(',');
    return 'DistributionBucket($contents)';
  }
}

/// Statistics computed over a tuning dataset.
final class DatasetStats extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DatasetStats';

  /// Output only. Number of examples in the tuning dataset.
  final int? tuningDatasetExampleCount;

  /// Output only. Number of tuning characters in the tuning dataset.
  final int? totalTuningCharacterCount;

  /// Output only. Number of billable characters in the tuning dataset.
  final int? totalBillableCharacterCount;

  /// Output only. Number of tuning steps for this Tuning Job.
  final int? tuningStepCount;

  /// Output only. Dataset distributions for the user input tokens.
  final DatasetDistribution? userInputTokenDistribution;

  /// Output only. Dataset distributions for the user output tokens.
  final DatasetDistribution? userOutputTokenDistribution;

  /// Output only. Dataset distributions for the messages per example.
  final DatasetDistribution? userMessagePerExampleDistribution;

  /// Output only. Sample user messages in the training dataset uri.
  final List<Content>? userDatasetExamples;

  DatasetStats({
    this.tuningDatasetExampleCount,
    this.totalTuningCharacterCount,
    this.totalBillableCharacterCount,
    this.tuningStepCount,
    this.userInputTokenDistribution,
    this.userOutputTokenDistribution,
    this.userMessagePerExampleDistribution,
    this.userDatasetExamples,
  }) : super(fullyQualifiedName);

  factory DatasetStats.fromJson(Map<String, dynamic> json) {
    return DatasetStats(
      tuningDatasetExampleCount: decodeInt64(json['tuningDatasetExampleCount']),
      totalTuningCharacterCount: decodeInt64(json['totalTuningCharacterCount']),
      totalBillableCharacterCount: decodeInt64(
        json['totalBillableCharacterCount'],
      ),
      tuningStepCount: decodeInt64(json['tuningStepCount']),
      userInputTokenDistribution: decode(
        json['userInputTokenDistribution'],
        DatasetDistribution.fromJson,
      ),
      userOutputTokenDistribution: decode(
        json['userOutputTokenDistribution'],
        DatasetDistribution.fromJson,
      ),
      userMessagePerExampleDistribution: decode(
        json['userMessagePerExampleDistribution'],
        DatasetDistribution.fromJson,
      ),
      userDatasetExamples: decodeListMessage(
        json['userDatasetExamples'],
        Content.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (tuningDatasetExampleCount != null)
        'tuningDatasetExampleCount': encodeInt64(tuningDatasetExampleCount),
      if (totalTuningCharacterCount != null)
        'totalTuningCharacterCount': encodeInt64(totalTuningCharacterCount),
      if (totalBillableCharacterCount != null)
        'totalBillableCharacterCount': encodeInt64(totalBillableCharacterCount),
      if (tuningStepCount != null)
        'tuningStepCount': encodeInt64(tuningStepCount),
      if (userInputTokenDistribution != null)
        'userInputTokenDistribution': userInputTokenDistribution!.toJson(),
      if (userOutputTokenDistribution != null)
        'userOutputTokenDistribution': userOutputTokenDistribution!.toJson(),
      if (userMessagePerExampleDistribution != null)
        'userMessagePerExampleDistribution': userMessagePerExampleDistribution!
            .toJson(),
      if (userDatasetExamples != null)
        'userDatasetExamples': encodeList(userDatasetExamples),
    };
  }

  @override
  String toString() {
    final contents = [
      if (tuningDatasetExampleCount != null)
        'tuningDatasetExampleCount=$tuningDatasetExampleCount',
      if (totalTuningCharacterCount != null)
        'totalTuningCharacterCount=$totalTuningCharacterCount',
      if (totalBillableCharacterCount != null)
        'totalBillableCharacterCount=$totalBillableCharacterCount',
      if (tuningStepCount != null) 'tuningStepCount=$tuningStepCount',
    ].join(',');
    return 'DatasetStats($contents)';
  }
}

/// Statistics computed for datasets used for distillation.
final class DistillationDataStats extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DistillationDataStats';

  /// Output only. Statistics computed for the training dataset.
  final DatasetStats? trainingDatasetStats;

  DistillationDataStats({this.trainingDatasetStats})
    : super(fullyQualifiedName);

  factory DistillationDataStats.fromJson(Map<String, dynamic> json) {
    return DistillationDataStats(
      trainingDatasetStats: decode(
        json['trainingDatasetStats'],
        DatasetStats.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingDatasetStats != null)
        'trainingDatasetStats': trainingDatasetStats!.toJson(),
    };
  }

  @override
  String toString() => 'DistillationDataStats()';
}

/// The tuning data statistic values for
/// `TuningJob`.
final class TuningDataStats extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TuningDataStats';

  /// The SFT Tuning data stats.
  final SupervisedTuningDataStats? supervisedTuningDataStats;

  /// Output only. Statistics for distillation.
  final DistillationDataStats? distillationDataStats;

  TuningDataStats({this.supervisedTuningDataStats, this.distillationDataStats})
    : super(fullyQualifiedName);

  factory TuningDataStats.fromJson(Map<String, dynamic> json) {
    return TuningDataStats(
      supervisedTuningDataStats: decode(
        json['supervisedTuningDataStats'],
        SupervisedTuningDataStats.fromJson,
      ),
      distillationDataStats: decode(
        json['distillationDataStats'],
        DistillationDataStats.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (supervisedTuningDataStats != null)
        'supervisedTuningDataStats': supervisedTuningDataStats!.toJson(),
      if (distillationDataStats != null)
        'distillationDataStats': distillationDataStats!.toJson(),
    };
  }

  @override
  String toString() => 'TuningDataStats()';
}

/// Hyperparameters for SFT.
final class SupervisedHyperParameters extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedHyperParameters';

  /// Optional. Number of complete passes the model makes over the entire
  /// training dataset during training.
  final int? epochCount;

  /// Optional. Multiplier for adjusting the default learning rate.
  /// Mutually exclusive with `learning_rate`.
  final double? learningRateMultiplier;

  /// Optional. Learning rate for tuning.
  /// Mutually exclusive with `learning_rate_multiplier`.
  /// This feature is only available for open source models.
  final double? learningRate;

  /// Optional. Adapter size for tuning.
  final SupervisedHyperParameters_AdapterSize? adapterSize;

  /// Optional. Batch size for tuning.
  /// This feature is only available for open source models.
  final int? batchSize;

  SupervisedHyperParameters({
    this.epochCount,
    this.learningRateMultiplier,
    this.learningRate,
    this.adapterSize,
    this.batchSize,
  }) : super(fullyQualifiedName);

  factory SupervisedHyperParameters.fromJson(Map<String, dynamic> json) {
    return SupervisedHyperParameters(
      epochCount: decodeInt64(json['epochCount']),
      learningRateMultiplier: decodeDouble(json['learningRateMultiplier']),
      learningRate: decodeDouble(json['learningRate']),
      adapterSize: decodeEnum(
        json['adapterSize'],
        SupervisedHyperParameters_AdapterSize.fromJson,
      ),
      batchSize: decodeInt64(json['batchSize']),
    );
  }

  @override
  Object toJson() {
    return {
      if (epochCount != null) 'epochCount': encodeInt64(epochCount),
      if (learningRateMultiplier != null)
        'learningRateMultiplier': encodeDouble(learningRateMultiplier),
      if (learningRate != null) 'learningRate': encodeDouble(learningRate),
      if (adapterSize != null) 'adapterSize': adapterSize!.toJson(),
      if (batchSize != null) 'batchSize': encodeInt64(batchSize),
    };
  }

  @override
  String toString() {
    final contents = [
      if (epochCount != null) 'epochCount=$epochCount',
      if (learningRateMultiplier != null)
        'learningRateMultiplier=$learningRateMultiplier',
      if (learningRate != null) 'learningRate=$learningRate',
      if (adapterSize != null) 'adapterSize=$adapterSize',
      if (batchSize != null) 'batchSize=$batchSize',
    ].join(',');
    return 'SupervisedHyperParameters($contents)';
  }
}

/// Supported adapter sizes for tuning.
final class SupervisedHyperParameters_AdapterSize extends protobuf.ProtoEnum {
  /// Adapter size is unspecified.
  static const adapterSizeUnspecified = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_UNSPECIFIED',
  );

  /// Adapter size 1.
  static const adapterSizeOne = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_ONE',
  );

  /// Adapter size 2.
  static const adapterSizeTwo = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_TWO',
  );

  /// Adapter size 4.
  static const adapterSizeFour = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_FOUR',
  );

  /// Adapter size 8.
  static const adapterSizeEight = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_EIGHT',
  );

  /// Adapter size 16.
  static const adapterSizeSixteen = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_SIXTEEN',
  );

  /// Adapter size 32.
  static const adapterSizeThirtyTwo = SupervisedHyperParameters_AdapterSize(
    'ADAPTER_SIZE_THIRTY_TWO',
  );

  const SupervisedHyperParameters_AdapterSize(super.value);

  factory SupervisedHyperParameters_AdapterSize.fromJson(String json) =>
      SupervisedHyperParameters_AdapterSize(json);

  @override
  String toString() => 'AdapterSize.$value';
}

/// Tuning Spec for Supervised Tuning for first party models.
final class SupervisedTuningSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SupervisedTuningSpec';

  /// Required. Training dataset used for tuning. The dataset can be specified as
  /// either a Cloud Storage path to a JSONL file or as the resource name of a
  /// Vertex Multimodal Dataset.
  final String? trainingDatasetUri;

  /// Optional. Validation dataset used for tuning. The dataset can be specified
  /// as either a Cloud Storage path to a JSONL file or as the resource name of a
  /// Vertex Multimodal Dataset.
  final String? validationDatasetUri;

  /// Optional. Hyperparameters for SFT.
  final SupervisedHyperParameters? hyperParameters;

  /// Optional. If set to true, disable intermediate checkpoints for SFT and only
  /// the last checkpoint will be exported. Otherwise, enable intermediate
  /// checkpoints for SFT. Default is false.
  final bool? exportLastCheckpointOnly;

  /// Optional. Evaluation Config for Tuning Job.
  final EvaluationConfig? evaluationConfig;

  /// Tuning mode.
  final SupervisedTuningSpec_TuningMode? tuningMode;

  SupervisedTuningSpec({
    this.trainingDatasetUri,
    this.validationDatasetUri,
    this.hyperParameters,
    this.exportLastCheckpointOnly,
    this.evaluationConfig,
    this.tuningMode,
  }) : super(fullyQualifiedName);

  factory SupervisedTuningSpec.fromJson(Map<String, dynamic> json) {
    return SupervisedTuningSpec(
      trainingDatasetUri: json['trainingDatasetUri'],
      validationDatasetUri: json['validationDatasetUri'],
      hyperParameters: decode(
        json['hyperParameters'],
        SupervisedHyperParameters.fromJson,
      ),
      exportLastCheckpointOnly: json['exportLastCheckpointOnly'],
      evaluationConfig: decode(
        json['evaluationConfig'],
        EvaluationConfig.fromJson,
      ),
      tuningMode: decodeEnum(
        json['tuningMode'],
        SupervisedTuningSpec_TuningMode.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri,
      if (validationDatasetUri != null)
        'validationDatasetUri': validationDatasetUri,
      if (hyperParameters != null) 'hyperParameters': hyperParameters!.toJson(),
      if (exportLastCheckpointOnly != null)
        'exportLastCheckpointOnly': exportLastCheckpointOnly,
      if (evaluationConfig != null)
        'evaluationConfig': evaluationConfig!.toJson(),
      if (tuningMode != null) 'tuningMode': tuningMode!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (trainingDatasetUri != null) 'trainingDatasetUri=$trainingDatasetUri',
      if (validationDatasetUri != null)
        'validationDatasetUri=$validationDatasetUri',
      if (exportLastCheckpointOnly != null)
        'exportLastCheckpointOnly=$exportLastCheckpointOnly',
      if (tuningMode != null) 'tuningMode=$tuningMode',
    ].join(',');
    return 'SupervisedTuningSpec($contents)';
  }
}

/// Supported tuning modes.
final class SupervisedTuningSpec_TuningMode extends protobuf.ProtoEnum {
  /// Tuning mode is unspecified.
  static const tuningModeUnspecified = SupervisedTuningSpec_TuningMode(
    'TUNING_MODE_UNSPECIFIED',
  );

  /// Full fine-tuning mode.
  static const tuningModeFull = SupervisedTuningSpec_TuningMode(
    'TUNING_MODE_FULL',
  );

  /// PEFT adapter tuning mode.
  static const tuningModePeftAdapter = SupervisedTuningSpec_TuningMode(
    'TUNING_MODE_PEFT_ADAPTER',
  );

  const SupervisedTuningSpec_TuningMode(super.value);

  factory SupervisedTuningSpec_TuningMode.fromJson(String json) =>
      SupervisedTuningSpec_TuningMode(json);

  @override
  String toString() => 'TuningMode.$value';
}

/// Tuning Spec for Distillation.
final class DistillationSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DistillationSpec';

  /// The base teacher model that is being distilled. See [Supported
  /// models](https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/tuning#supported_models).
  final String? baseTeacherModel;

  /// The resource name of the Tuned teacher model. Format:
  /// `projects/{project}/locations/{location}/models/{model}`.
  final String? tunedTeacherModelSource;

  /// Required. Cloud Storage path to file containing training dataset for
  /// tuning. The dataset must be formatted as a JSONL file.
  final String? trainingDatasetUri;

  /// Optional. Cloud Storage path to file containing validation dataset for
  /// tuning. The dataset must be formatted as a JSONL file.
  final String? validationDatasetUri;

  /// Optional. Hyperparameters for Distillation.
  final DistillationHyperParameters? hyperParameters;

  /// The student model that is being tuned, e.g., "google/gemma-2b-1.1-it".
  final String? studentModel;

  /// Required. A path in a Cloud Storage bucket, which will be treated as the
  /// root output directory of the distillation pipeline. It is used by the
  /// system to generate the paths of output artifacts.
  final String? pipelineRootDirectory;

  DistillationSpec({
    this.baseTeacherModel,
    this.tunedTeacherModelSource,
    this.trainingDatasetUri,
    this.validationDatasetUri,
    this.hyperParameters,
    this.studentModel,
    this.pipelineRootDirectory,
  }) : super(fullyQualifiedName);

  factory DistillationSpec.fromJson(Map<String, dynamic> json) {
    return DistillationSpec(
      baseTeacherModel: json['baseTeacherModel'],
      tunedTeacherModelSource: json['tunedTeacherModelSource'],
      trainingDatasetUri: json['trainingDatasetUri'],
      validationDatasetUri: json['validationDatasetUri'],
      hyperParameters: decode(
        json['hyperParameters'],
        DistillationHyperParameters.fromJson,
      ),
      studentModel: json['studentModel'],
      pipelineRootDirectory: json['pipelineRootDirectory'],
    );
  }

  @override
  Object toJson() {
    return {
      if (baseTeacherModel != null) 'baseTeacherModel': baseTeacherModel,
      if (tunedTeacherModelSource != null)
        'tunedTeacherModelSource': tunedTeacherModelSource,
      if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri,
      if (validationDatasetUri != null)
        'validationDatasetUri': validationDatasetUri,
      if (hyperParameters != null) 'hyperParameters': hyperParameters!.toJson(),
      if (studentModel != null) 'studentModel': studentModel,
      if (pipelineRootDirectory != null)
        'pipelineRootDirectory': pipelineRootDirectory,
    };
  }

  @override
  String toString() {
    final contents = [
      if (baseTeacherModel != null) 'baseTeacherModel=$baseTeacherModel',
      if (tunedTeacherModelSource != null)
        'tunedTeacherModelSource=$tunedTeacherModelSource',
      if (trainingDatasetUri != null) 'trainingDatasetUri=$trainingDatasetUri',
      if (validationDatasetUri != null)
        'validationDatasetUri=$validationDatasetUri',
      if (studentModel != null) 'studentModel=$studentModel',
      if (pipelineRootDirectory != null)
        'pipelineRootDirectory=$pipelineRootDirectory',
    ].join(',');
    return 'DistillationSpec($contents)';
  }
}

/// Hyperparameters for Distillation.
final class DistillationHyperParameters extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DistillationHyperParameters';

  /// Optional. Number of complete passes the model makes over the entire
  /// training dataset during training.
  final int? epochCount;

  /// Optional. Multiplier for adjusting the default learning rate.
  final double? learningRateMultiplier;

  /// Optional. Adapter size for distillation.
  final SupervisedHyperParameters_AdapterSize? adapterSize;

  DistillationHyperParameters({
    this.epochCount,
    this.learningRateMultiplier,
    this.adapterSize,
  }) : super(fullyQualifiedName);

  factory DistillationHyperParameters.fromJson(Map<String, dynamic> json) {
    return DistillationHyperParameters(
      epochCount: decodeInt64(json['epochCount']),
      learningRateMultiplier: decodeDouble(json['learningRateMultiplier']),
      adapterSize: decodeEnum(
        json['adapterSize'],
        SupervisedHyperParameters_AdapterSize.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (epochCount != null) 'epochCount': encodeInt64(epochCount),
      if (learningRateMultiplier != null)
        'learningRateMultiplier': encodeDouble(learningRateMultiplier),
      if (adapterSize != null) 'adapterSize': adapterSize!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (epochCount != null) 'epochCount=$epochCount',
      if (learningRateMultiplier != null)
        'learningRateMultiplier=$learningRateMultiplier',
      if (adapterSize != null) 'adapterSize=$adapterSize',
    ].join(',');
    return 'DistillationHyperParameters($contents)';
  }
}

/// Tuning spec for Partner models.
final class PartnerModelTuningSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PartnerModelTuningSpec';

  /// Required. Cloud Storage path to file containing training dataset for
  /// tuning. The dataset must be formatted as a JSONL file.
  final String? trainingDatasetUri;

  /// Optional. Cloud Storage path to file containing validation dataset for
  /// tuning. The dataset must be formatted as a JSONL file.
  final String? validationDatasetUri;

  /// Hyperparameters for tuning. The accepted hyper_parameters and their valid
  /// range of values will differ depending on the base model.
  final Map<String, protobuf.Value>? hyperParameters;

  PartnerModelTuningSpec({
    this.trainingDatasetUri,
    this.validationDatasetUri,
    this.hyperParameters,
  }) : super(fullyQualifiedName);

  factory PartnerModelTuningSpec.fromJson(Map<String, dynamic> json) {
    return PartnerModelTuningSpec(
      trainingDatasetUri: json['trainingDatasetUri'],
      validationDatasetUri: json['validationDatasetUri'],
      hyperParameters: decodeMapMessageCustom(
        json['hyperParameters'],
        protobuf.Value.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri,
      if (validationDatasetUri != null)
        'validationDatasetUri': validationDatasetUri,
      if (hyperParameters != null)
        'hyperParameters': encodeMap(hyperParameters),
    };
  }

  @override
  String toString() {
    final contents = [
      if (trainingDatasetUri != null) 'trainingDatasetUri=$trainingDatasetUri',
      if (validationDatasetUri != null)
        'validationDatasetUri=$validationDatasetUri',
    ].join(',');
    return 'PartnerModelTuningSpec($contents)';
  }
}

/// TunedModel Reference for legacy model migration.
final class TunedModelRef extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TunedModelRef';

  /// Support migration from model registry.
  final String? tunedModel;

  /// Support migration from tuning job list page, from gemini-1.0-pro-002
  /// to 1.5 and above.
  final String? tuningJob;

  /// Support migration from tuning job list page, from bison model to gemini
  /// model.
  final String? pipelineJob;

  TunedModelRef({this.tunedModel, this.tuningJob, this.pipelineJob})
    : super(fullyQualifiedName);

  factory TunedModelRef.fromJson(Map<String, dynamic> json) {
    return TunedModelRef(
      tunedModel: json['tunedModel'],
      tuningJob: json['tuningJob'],
      pipelineJob: json['pipelineJob'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tunedModel != null) 'tunedModel': tunedModel,
      if (tuningJob != null) 'tuningJob': tuningJob,
      if (pipelineJob != null) 'pipelineJob': pipelineJob,
    };
  }

  @override
  String toString() {
    final contents = [
      if (tunedModel != null) 'tunedModel=$tunedModel',
      if (tuningJob != null) 'tuningJob=$tuningJob',
      if (pipelineJob != null) 'pipelineJob=$pipelineJob',
    ].join(',');
    return 'TunedModelRef($contents)';
  }
}

/// Hyperparameters for Veo.
final class VeoHyperParameters extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VeoHyperParameters';

  /// Optional. Number of complete passes the model makes over the entire
  /// training dataset during training.
  final int? epochCount;

  /// Optional. Multiplier for adjusting the default learning rate.
  final double? learningRateMultiplier;

  /// Optional. The tuning task. Either I2V or T2V.
  final VeoHyperParameters_TuningTask? tuningTask;

  VeoHyperParameters({
    this.epochCount,
    this.learningRateMultiplier,
    this.tuningTask,
  }) : super(fullyQualifiedName);

  factory VeoHyperParameters.fromJson(Map<String, dynamic> json) {
    return VeoHyperParameters(
      epochCount: decodeInt64(json['epochCount']),
      learningRateMultiplier: decodeDouble(json['learningRateMultiplier']),
      tuningTask: decodeEnum(
        json['tuningTask'],
        VeoHyperParameters_TuningTask.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (epochCount != null) 'epochCount': encodeInt64(epochCount),
      if (learningRateMultiplier != null)
        'learningRateMultiplier': encodeDouble(learningRateMultiplier),
      if (tuningTask != null) 'tuningTask': tuningTask!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (epochCount != null) 'epochCount=$epochCount',
      if (learningRateMultiplier != null)
        'learningRateMultiplier=$learningRateMultiplier',
      if (tuningTask != null) 'tuningTask=$tuningTask',
    ].join(',');
    return 'VeoHyperParameters($contents)';
  }
}

/// An enum defining the tuning task used for Veo.
final class VeoHyperParameters_TuningTask extends protobuf.ProtoEnum {
  /// Default value. This value is unused.
  static const tuningTaskUnspecified = VeoHyperParameters_TuningTask(
    'TUNING_TASK_UNSPECIFIED',
  );

  /// Tuning task for image to video.
  static const tuningTaskI2V = VeoHyperParameters_TuningTask('TUNING_TASK_I2V');

  /// Tuning task for text to video.
  static const tuningTaskT2V = VeoHyperParameters_TuningTask('TUNING_TASK_T2V');

  const VeoHyperParameters_TuningTask(super.value);

  factory VeoHyperParameters_TuningTask.fromJson(String json) =>
      VeoHyperParameters_TuningTask(json);

  @override
  String toString() => 'TuningTask.$value';
}

/// Tuning Spec for Veo Model Tuning.
final class VeoTuningSpec extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VeoTuningSpec';

  /// Required. Training dataset used for tuning. The dataset can be specified as
  /// either a Cloud Storage path to a JSONL file or as the resource name of a
  /// Vertex Multimodal Dataset.
  final String? trainingDatasetUri;

  /// Optional. Validation dataset used for tuning. The dataset can be specified
  /// as either a Cloud Storage path to a JSONL file or as the resource name of a
  /// Vertex Multimodal Dataset.
  final String? validationDatasetUri;

  /// Optional. Hyperparameters for Veo.
  final VeoHyperParameters? hyperParameters;

  VeoTuningSpec({
    this.trainingDatasetUri,
    this.validationDatasetUri,
    this.hyperParameters,
  }) : super(fullyQualifiedName);

  factory VeoTuningSpec.fromJson(Map<String, dynamic> json) {
    return VeoTuningSpec(
      trainingDatasetUri: json['trainingDatasetUri'],
      validationDatasetUri: json['validationDatasetUri'],
      hyperParameters: decode(
        json['hyperParameters'],
        VeoHyperParameters.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (trainingDatasetUri != null) 'trainingDatasetUri': trainingDatasetUri,
      if (validationDatasetUri != null)
        'validationDatasetUri': validationDatasetUri,
      if (hyperParameters != null) 'hyperParameters': hyperParameters!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (trainingDatasetUri != null) 'trainingDatasetUri=$trainingDatasetUri',
      if (validationDatasetUri != null)
        'validationDatasetUri=$validationDatasetUri',
    ].join(',');
    return 'VeoTuningSpec($contents)';
  }
}

/// Evaluation Config for Tuning Job.
final class EvaluationConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluationConfig';

  /// Required. The metrics used for evaluation.
  final List<Metric>? metrics;

  /// Required. Config for evaluation output.
  final OutputConfig? outputConfig;

  /// Optional. Autorater config for evaluation.
  final AutoraterConfig? autoraterConfig;

  EvaluationConfig({this.metrics, this.outputConfig, this.autoraterConfig})
    : super(fullyQualifiedName);

  factory EvaluationConfig.fromJson(Map<String, dynamic> json) {
    return EvaluationConfig(
      metrics: decodeListMessage(json['metrics'], Metric.fromJson),
      outputConfig: decode(json['outputConfig'], OutputConfig.fromJson),
      autoraterConfig: decode(
        json['autoraterConfig'],
        AutoraterConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (metrics != null) 'metrics': encodeList(metrics),
      if (outputConfig != null) 'outputConfig': outputConfig!.toJson(),
      if (autoraterConfig != null) 'autoraterConfig': autoraterConfig!.toJson(),
    };
  }

  @override
  String toString() => 'EvaluationConfig()';
}

/// Evaluate Dataset Run Result for Tuning Job.
final class EvaluateDatasetRun extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.EvaluateDatasetRun';

  /// Output only. The operation ID of the evaluation run. Format:
  /// `projects/{project}/locations/{location}/operations/{operation_id}`.
  final String? operationName;

  /// Output only. The checkpoint id used in the evaluation run. Only populated
  /// when evaluating checkpoints.
  final String? checkpointId;

  /// Output only. Results for EvaluationService.EvaluateDataset.
  final EvaluateDatasetResponse? evaluateDatasetResponse;

  /// Output only. The error of the evaluation run if any.
  final Status? error;

  EvaluateDatasetRun({
    this.operationName,
    this.checkpointId,
    this.evaluateDatasetResponse,
    this.error,
  }) : super(fullyQualifiedName);

  factory EvaluateDatasetRun.fromJson(Map<String, dynamic> json) {
    return EvaluateDatasetRun(
      operationName: json['operationName'],
      checkpointId: json['checkpointId'],
      evaluateDatasetResponse: decode(
        json['evaluateDatasetResponse'],
        EvaluateDatasetResponse.fromJson,
      ),
      error: decode(json['error'], Status.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (operationName != null) 'operationName': operationName,
      if (checkpointId != null) 'checkpointId': checkpointId,
      if (evaluateDatasetResponse != null)
        'evaluateDatasetResponse': evaluateDatasetResponse!.toJson(),
      if (error != null) 'error': error!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (operationName != null) 'operationName=$operationName',
      if (checkpointId != null) 'checkpointId=$checkpointId',
    ].join(',');
    return 'EvaluateDatasetRun($contents)';
  }
}

/// TunedModelCheckpoint for the Tuned Model of a Tuning Job.
final class TunedModelCheckpoint extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.TunedModelCheckpoint';

  /// The ID of the checkpoint.
  final String? checkpointId;

  /// The epoch of the checkpoint.
  final int? epoch;

  /// The step of the checkpoint.
  final int? step;

  /// The Endpoint resource name that the checkpoint is deployed to. Format:
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`.
  final String? endpoint;

  TunedModelCheckpoint({
    this.checkpointId,
    this.epoch,
    this.step,
    this.endpoint,
  }) : super(fullyQualifiedName);

  factory TunedModelCheckpoint.fromJson(Map<String, dynamic> json) {
    return TunedModelCheckpoint(
      checkpointId: json['checkpointId'],
      epoch: decodeInt64(json['epoch']),
      step: decodeInt64(json['step']),
      endpoint: json['endpoint'],
    );
  }

  @override
  Object toJson() {
    return {
      if (checkpointId != null) 'checkpointId': checkpointId,
      if (epoch != null) 'epoch': encodeInt64(epoch),
      if (step != null) 'step': encodeInt64(step),
      if (endpoint != null) 'endpoint': endpoint,
    };
  }

  @override
  String toString() {
    final contents = [
      if (checkpointId != null) 'checkpointId=$checkpointId',
      if (epoch != null) 'epoch=$epoch',
      if (step != null) 'step=$step',
      if (endpoint != null) 'endpoint=$endpoint',
    ].join(',');
    return 'TunedModelCheckpoint($contents)';
  }
}

/// A pre-tuned model for continuous tuning.
final class PreTunedModel extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.PreTunedModel';

  /// The resource name of the Model.
  /// E.g., a model resource name with a specified version id or alias:
  ///
  /// `projects/{project}/locations/{location}/models/{model}@{version_id}`
  ///
  /// `projects/{project}/locations/{location}/models/{model}@{alias}`
  ///
  /// Or, omit the version id to use the default version:
  ///
  /// `projects/{project}/locations/{location}/models/{model}`
  final String? tunedModelName;

  /// Optional. The source checkpoint id. If not specified, the default
  /// checkpoint will be used.
  final String? checkpointId;

  /// Output only. The name of the base model this
  /// `PreTunedModel` was tuned
  /// from.
  final String? baseModel;

  PreTunedModel({this.tunedModelName, this.checkpointId, this.baseModel})
    : super(fullyQualifiedName);

  factory PreTunedModel.fromJson(Map<String, dynamic> json) {
    return PreTunedModel(
      tunedModelName: json['tunedModelName'],
      checkpointId: json['checkpointId'],
      baseModel: json['baseModel'],
    );
  }

  @override
  Object toJson() {
    return {
      if (tunedModelName != null) 'tunedModelName': tunedModelName,
      if (checkpointId != null) 'checkpointId': checkpointId,
      if (baseModel != null) 'baseModel': baseModel,
    };
  }

  @override
  String toString() {
    final contents = [
      if (tunedModelName != null) 'tunedModelName=$tunedModelName',
      if (checkpointId != null) 'checkpointId=$checkpointId',
      if (baseModel != null) 'baseModel=$baseModel',
    ].join(',');
    return 'PreTunedModel($contents)';
  }
}

/// A list of boolean values.
final class BoolArray extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.BoolArray';

  /// A list of bool values.
  final List<bool>? values;

  BoolArray({this.values}) : super(fullyQualifiedName);

  factory BoolArray.fromJson(Map<String, dynamic> json) {
    return BoolArray(values: decodeList(json['values']));
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': values};
  }

  @override
  String toString() => 'BoolArray()';
}

/// A list of double values.
final class DoubleArray extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DoubleArray';

  /// A list of double values.
  final List<double>? values;

  DoubleArray({this.values}) : super(fullyQualifiedName);

  factory DoubleArray.fromJson(Map<String, dynamic> json) {
    return DoubleArray(values: decodeList(json['values']));
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': values};
  }

  @override
  String toString() => 'DoubleArray()';
}

/// A list of int64 values.
final class Int64Array extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Int64Array';

  /// A list of int64 values.
  final List<int>? values;

  Int64Array({this.values}) : super(fullyQualifiedName);

  factory Int64Array.fromJson(Map<String, dynamic> json) {
    return Int64Array(values: decodeList(json['values']));
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': values};
  }

  @override
  String toString() => 'Int64Array()';
}

/// A list of string values.
final class StringArray extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StringArray';

  /// A list of string values.
  final List<String>? values;

  StringArray({this.values}) : super(fullyQualifiedName);

  factory StringArray.fromJson(Map<String, dynamic> json) {
    return StringArray(values: decodeList(json['values']));
  }

  @override
  Object toJson() {
    return {if (values != null) 'values': values};
  }

  @override
  String toString() => 'StringArray()';
}

/// A tensor value type.
final class Tensor extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Tensor';

  /// The data type of tensor.
  final Tensor_DataType? dtype;

  /// Shape of the tensor.
  final List<int>? shape;

  /// Type specific representations that make it easy to create tensor protos in
  /// all languages.  Only the representation corresponding to "dtype" can
  /// be set.  The values hold the flattened representation of the tensor in
  /// row major order.
  ///
  /// `BOOL`
  final List<bool>? boolVal;

  /// `STRING`
  final List<String>? stringVal;

  /// `STRING`
  final List<Uint8List>? bytesVal;

  /// `FLOAT`
  final List<double>? floatVal;

  /// `DOUBLE`
  final List<double>? doubleVal;

  /// `INT_8`
  /// `INT_16`
  /// `INT_32`
  final List<int>? intVal;

  /// `INT64`
  final List<int>? int64Val;

  /// `UINT8`
  /// `UINT16`
  /// `UINT32`
  final List<int>? uintVal;

  /// `UINT64`
  final List<int>? uint64Val;

  /// A list of tensor values.
  final List<Tensor>? listVal;

  /// A map of string to tensor.
  final Map<String, Tensor>? structVal;

  /// Serialized raw tensor content.
  final Uint8List? tensorVal;

  Tensor({
    this.dtype,
    this.shape,
    this.boolVal,
    this.stringVal,
    this.bytesVal,
    this.floatVal,
    this.doubleVal,
    this.intVal,
    this.int64Val,
    this.uintVal,
    this.uint64Val,
    this.listVal,
    this.structVal,
    this.tensorVal,
  }) : super(fullyQualifiedName);

  factory Tensor.fromJson(Map<String, dynamic> json) {
    return Tensor(
      dtype: decodeEnum(json['dtype'], Tensor_DataType.fromJson),
      shape: decodeList(json['shape']),
      boolVal: decodeList(json['boolVal']),
      stringVal: decodeList(json['stringVal']),
      bytesVal: decodeListBytes(json['bytesVal']),
      floatVal: decodeList(json['floatVal']),
      doubleVal: decodeList(json['doubleVal']),
      intVal: decodeList(json['intVal']),
      int64Val: decodeList(json['int64Val']),
      uintVal: decodeList(json['uintVal']),
      uint64Val: decodeList(json['uint64Val']),
      listVal: decodeListMessage(json['listVal'], Tensor.fromJson),
      structVal: decodeMapMessage(json['structVal'], Tensor.fromJson),
      tensorVal: decodeBytes(json['tensorVal']),
    );
  }

  @override
  Object toJson() {
    return {
      if (dtype != null) 'dtype': dtype!.toJson(),
      if (shape != null) 'shape': shape,
      if (boolVal != null) 'boolVal': boolVal,
      if (stringVal != null) 'stringVal': stringVal,
      if (bytesVal != null) 'bytesVal': encodeListBytes(bytesVal),
      if (floatVal != null) 'floatVal': floatVal,
      if (doubleVal != null) 'doubleVal': doubleVal,
      if (intVal != null) 'intVal': intVal,
      if (int64Val != null) 'int64Val': int64Val,
      if (uintVal != null) 'uintVal': uintVal,
      if (uint64Val != null) 'uint64Val': uint64Val,
      if (listVal != null) 'listVal': encodeList(listVal),
      if (structVal != null) 'structVal': encodeMap(structVal),
      if (tensorVal != null) 'tensorVal': encodeBytes(tensorVal),
    };
  }

  @override
  String toString() {
    final contents = [
      if (dtype != null) 'dtype=$dtype',
      if (tensorVal != null) 'tensorVal=$tensorVal',
    ].join(',');
    return 'Tensor($contents)';
  }
}

/// Data type of the tensor.
final class Tensor_DataType extends protobuf.ProtoEnum {
  /// Not a legal value for DataType. Used to indicate a DataType field has not
  /// been set.
  static const dataTypeUnspecified = Tensor_DataType('DATA_TYPE_UNSPECIFIED');

  /// Data types that all computation devices are expected to be
  /// capable to support.
  static const bool = Tensor_DataType('BOOL');

  static const string = Tensor_DataType('STRING');

  static const float = Tensor_DataType('FLOAT');

  static const double = Tensor_DataType('DOUBLE');

  static const int8 = Tensor_DataType('INT8');

  static const int16 = Tensor_DataType('INT16');

  static const int32 = Tensor_DataType('INT32');

  static const int64 = Tensor_DataType('INT64');

  static const uint8 = Tensor_DataType('UINT8');

  static const uint16 = Tensor_DataType('UINT16');

  static const uint32 = Tensor_DataType('UINT32');

  static const uint64 = Tensor_DataType('UINT64');

  const Tensor_DataType(super.value);

  factory Tensor_DataType.fromJson(String json) => Tensor_DataType(json);

  @override
  String toString() => 'DataType.$value';
}

/// The definition of a artifact type in MLMD.
final class ArtifactTypeSchema extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ArtifactTypeSchema';

  /// The name of the type. The format of the title must be:
  /// `<namespace>.<title>`.
  /// Examples:
  ///  - `aiplatform.Model`
  ///  - `acme.CustomModel`
  /// When this field is set, the type must be pre-registered in the MLMD
  /// store.
  final String? schemaTitle;

  /// Points to a YAML file stored on Cloud Storage describing the
  /// format.
  /// Deprecated. Use `PipelineArtifactTypeSchema.schema_title` or
  /// `PipelineArtifactTypeSchema.instance_schema` instead.
  final String? schemaUri;

  /// Contains a raw YAML string, describing the format of
  /// the properties of the type.
  final String? instanceSchema;

  /// The schema version of the artifact. If the value is not set, it defaults
  /// to the latest version in the system.
  final String? schemaVersion;

  ArtifactTypeSchema({
    this.schemaTitle,
    this.schemaUri,
    this.instanceSchema,
    this.schemaVersion,
  }) : super(fullyQualifiedName);

  factory ArtifactTypeSchema.fromJson(Map<String, dynamic> json) {
    return ArtifactTypeSchema(
      schemaTitle: json['schemaTitle'],
      schemaUri: json['schemaUri'],
      instanceSchema: json['instanceSchema'],
      schemaVersion: json['schemaVersion'],
    );
  }

  @override
  Object toJson() {
    return {
      if (schemaTitle != null) 'schemaTitle': schemaTitle,
      if (schemaUri != null) 'schemaUri': schemaUri,
      if (instanceSchema != null) 'instanceSchema': instanceSchema,
      if (schemaVersion != null) 'schemaVersion': schemaVersion,
    };
  }

  @override
  String toString() {
    final contents = [
      if (schemaTitle != null) 'schemaTitle=$schemaTitle',
      if (schemaUri != null) 'schemaUri=$schemaUri',
      if (instanceSchema != null) 'instanceSchema=$instanceSchema',
      if (schemaVersion != null) 'schemaVersion=$schemaVersion',
    ].join(',');
    return 'ArtifactTypeSchema($contents)';
  }
}

/// The definition of a runtime artifact.
final class RuntimeArtifact extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RuntimeArtifact';

  /// The name of an artifact.
  final String? name;

  /// The type of the artifact.
  final ArtifactTypeSchema? type;

  /// The URI of the artifact.
  final String? uri;

  /// The properties of the artifact.
  /// Deprecated. Use
  /// `RuntimeArtifact.metadata`
  /// instead.
  final Map<String, Value>? properties;

  /// The custom properties of the artifact.
  /// Deprecated. Use
  /// `RuntimeArtifact.metadata`
  /// instead.
  final Map<String, Value>? customProperties;

  /// Properties of the Artifact.
  final protobuf.Struct? metadata;

  RuntimeArtifact({
    this.name,
    this.type,
    this.uri,
    this.properties,
    this.customProperties,
    this.metadata,
  }) : super(fullyQualifiedName);

  factory RuntimeArtifact.fromJson(Map<String, dynamic> json) {
    return RuntimeArtifact(
      name: json['name'],
      type: decode(json['type'], ArtifactTypeSchema.fromJson),
      uri: json['uri'],
      properties: decodeMapMessage(json['properties'], Value.fromJson),
      customProperties: decodeMapMessage(
        json['customProperties'],
        Value.fromJson,
      ),
      metadata: decodeCustom(json['metadata'], protobuf.Struct.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (type != null) 'type': type!.toJson(),
      if (uri != null) 'uri': uri,
      if (properties != null) 'properties': encodeMap(properties),
      if (customProperties != null)
        'customProperties': encodeMap(customProperties),
      if (metadata != null) 'metadata': metadata!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (uri != null) 'uri=$uri',
    ].join(',');
    return 'RuntimeArtifact($contents)';
  }
}

/// Contains model information necessary to perform batch prediction without
/// requiring a full model import.
final class UnmanagedContainerModel extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UnmanagedContainerModel';

  /// The path to the directory containing the Model artifact and any of its
  /// supporting files.
  final String? artifactUri;

  /// Contains the schemata used in Model's predictions and explanations
  final PredictSchemata? predictSchemata;

  /// Input only. The specification of the container that is to be used when
  /// deploying this Model.
  final ModelContainerSpec? containerSpec;

  UnmanagedContainerModel({
    this.artifactUri,
    this.predictSchemata,
    this.containerSpec,
  }) : super(fullyQualifiedName);

  factory UnmanagedContainerModel.fromJson(Map<String, dynamic> json) {
    return UnmanagedContainerModel(
      artifactUri: json['artifactUri'],
      predictSchemata: decode(
        json['predictSchemata'],
        PredictSchemata.fromJson,
      ),
      containerSpec: decode(json['containerSpec'], ModelContainerSpec.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (artifactUri != null) 'artifactUri': artifactUri,
      if (predictSchemata != null) 'predictSchemata': predictSchemata!.toJson(),
      if (containerSpec != null) 'containerSpec': containerSpec!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (artifactUri != null) 'artifactUri=$artifactUri',
    ].join(',');
    return 'UnmanagedContainerModel($contents)';
  }
}

/// References an API call. It contains more information about long running
/// operation and Jobs that are triggered by the API call.
final class UserActionReference extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UserActionReference';

  /// For API calls that return a long running operation.
  /// Resource name of the long running operation.
  /// Format:
  /// `projects/{project}/locations/{location}/operations/{operation}`
  final String? operation;

  /// For API calls that start a LabelingJob.
  /// Resource name of the LabelingJob.
  /// Format:
  /// `projects/{project}/locations/{location}/dataLabelingJobs/{data_labeling_job}`
  final String? dataLabelingJob;

  /// The method name of the API RPC call. For example,
  /// "/google.cloud.aiplatform.{apiVersion}.DatasetService.CreateDataset"
  final String? method;

  UserActionReference({this.operation, this.dataLabelingJob, this.method})
    : super(fullyQualifiedName);

  factory UserActionReference.fromJson(Map<String, dynamic> json) {
    return UserActionReference(
      operation: json['operation'],
      dataLabelingJob: json['dataLabelingJob'],
      method: json['method'],
    );
  }

  @override
  Object toJson() {
    return {
      if (operation != null) 'operation': operation,
      if (dataLabelingJob != null) 'dataLabelingJob': dataLabelingJob,
      if (method != null) 'method': method,
    };
  }

  @override
  String toString() {
    final contents = [
      if (operation != null) 'operation=$operation',
      if (dataLabelingJob != null) 'dataLabelingJob=$dataLabelingJob',
      if (method != null) 'method=$method',
    ].join(',');
    return 'UserActionReference($contents)';
  }
}

/// Value is the value of the field.
final class Value extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Value';

  /// An integer value.
  final int? intValue;

  /// A double value.
  final double? doubleValue;

  /// A string value.
  final String? stringValue;

  Value({this.intValue, this.doubleValue, this.stringValue})
    : super(fullyQualifiedName);

  factory Value.fromJson(Map<String, dynamic> json) {
    return Value(
      intValue: decodeInt64(json['intValue']),
      doubleValue: decodeDouble(json['doubleValue']),
      stringValue: json['stringValue'],
    );
  }

  @override
  Object toJson() {
    return {
      if (intValue != null) 'intValue': encodeInt64(intValue),
      if (doubleValue != null) 'doubleValue': encodeDouble(doubleValue),
      if (stringValue != null) 'stringValue': stringValue,
    };
  }

  @override
  String toString() {
    final contents = [
      if (intValue != null) 'intValue=$intValue',
      if (doubleValue != null) 'doubleValue=$doubleValue',
      if (stringValue != null) 'stringValue=$stringValue',
    ].join(',');
    return 'Value($contents)';
  }
}

/// Config for the embedding model to use for RAG.
final class RagEmbeddingModelConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig';

  /// The Vertex AI Prediction Endpoint that either refers to a publisher model
  /// or an endpoint that is hosting a 1P fine-tuned text embedding model.
  /// Endpoints hosting non-1P fine-tuned text embedding models are
  /// currently not supported.
  /// This is used for dense vector search.
  final RagEmbeddingModelConfig_VertexPredictionEndpoint?
  vertexPredictionEndpoint;

  /// Configuration for hybrid search.
  final RagEmbeddingModelConfig_HybridSearchConfig? hybridSearchConfig;

  RagEmbeddingModelConfig({
    this.vertexPredictionEndpoint,
    this.hybridSearchConfig,
  }) : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig.fromJson(Map<String, dynamic> json) {
    return RagEmbeddingModelConfig(
      vertexPredictionEndpoint: decode(
        json['vertexPredictionEndpoint'],
        RagEmbeddingModelConfig_VertexPredictionEndpoint.fromJson,
      ),
      hybridSearchConfig: decode(
        json['hybridSearchConfig'],
        RagEmbeddingModelConfig_HybridSearchConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (vertexPredictionEndpoint != null)
        'vertexPredictionEndpoint': vertexPredictionEndpoint!.toJson(),
      if (hybridSearchConfig != null)
        'hybridSearchConfig': hybridSearchConfig!.toJson(),
    };
  }

  @override
  String toString() => 'RagEmbeddingModelConfig()';
}

/// Config representing a model hosted on Vertex Prediction Endpoint.
final class RagEmbeddingModelConfig_VertexPredictionEndpoint
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig.VertexPredictionEndpoint';

  /// Required. The endpoint resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/publishers/{publisher}/models/{model}`
  /// or
  /// `projects/{project}/locations/{location}/endpoints/{endpoint}`
  final String? endpoint;

  /// Output only. The resource name of the model that is deployed on the
  /// endpoint. Present only when the endpoint is not a publisher model.
  /// Pattern:
  /// `projects/{project}/locations/{location}/models/{model}`
  final String? model;

  /// Output only. Version ID of the model that is deployed on the endpoint.
  /// Present only when the endpoint is not a publisher model.
  final String? modelVersionId;

  RagEmbeddingModelConfig_VertexPredictionEndpoint({
    this.endpoint,
    this.model,
    this.modelVersionId,
  }) : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig_VertexPredictionEndpoint.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagEmbeddingModelConfig_VertexPredictionEndpoint(
      endpoint: json['endpoint'],
      model: json['model'],
      modelVersionId: json['modelVersionId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (endpoint != null) 'endpoint': endpoint,
      if (model != null) 'model': model,
      if (modelVersionId != null) 'modelVersionId': modelVersionId,
    };
  }

  @override
  String toString() {
    final contents = [
      if (endpoint != null) 'endpoint=$endpoint',
      if (model != null) 'model=$model',
      if (modelVersionId != null) 'modelVersionId=$modelVersionId',
    ].join(',');
    return 'VertexPredictionEndpoint($contents)';
  }
}

/// Configuration for sparse emebdding generation.
final class RagEmbeddingModelConfig_SparseEmbeddingConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig.SparseEmbeddingConfig';

  /// Use BM25 scoring algorithm.
  final RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25? bm25;

  RagEmbeddingModelConfig_SparseEmbeddingConfig({this.bm25})
    : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig_SparseEmbeddingConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagEmbeddingModelConfig_SparseEmbeddingConfig(
      bm25: decode(
        json['bm25'],
        RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (bm25 != null) 'bm25': bm25!.toJson()};
  }

  @override
  String toString() => 'SparseEmbeddingConfig()';
}

/// Message for BM25 parameters.
final class RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig.SparseEmbeddingConfig.Bm25';

  /// Optional. Use multilingual tokenizer if set to true.
  final bool? multilingual;

  /// Optional. The parameter to control term frequency saturation. It
  /// determines the scaling between the matching term frequency and final
  /// score. k1 is in the range of [1.2, 3]. The default value is 1.2.
  final double? k1;

  /// Optional. The parameter to control document length normalization. It
  /// determines how much the document length affects the final score. b is
  /// in the range of [0, 1]. The default value is 0.75.
  final double? b;

  RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25({
    this.multilingual,
    this.k1,
    this.b,
  }) : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagEmbeddingModelConfig_SparseEmbeddingConfig_Bm25(
      multilingual: json['multilingual'],
      k1: decodeDouble(json['k1']),
      b: decodeDouble(json['b']),
    );
  }

  @override
  Object toJson() {
    return {
      if (multilingual != null) 'multilingual': multilingual,
      if (k1 != null) 'k1': encodeDouble(k1),
      if (b != null) 'b': encodeDouble(b),
    };
  }

  @override
  String toString() {
    final contents = [
      if (multilingual != null) 'multilingual=$multilingual',
      if (k1 != null) 'k1=$k1',
      if (b != null) 'b=$b',
    ].join(',');
    return 'Bm25($contents)';
  }
}

/// Config for hybrid search.
final class RagEmbeddingModelConfig_HybridSearchConfig
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEmbeddingModelConfig.HybridSearchConfig';

  /// Optional. The configuration for sparse embedding generation. This field
  /// is optional the default behavior depends on the vector database choice on
  /// the RagCorpus.
  final RagEmbeddingModelConfig_SparseEmbeddingConfig? sparseEmbeddingConfig;

  /// Required. The Vertex AI Prediction Endpoint that hosts the embedding
  /// model for dense embedding generations.
  final RagEmbeddingModelConfig_VertexPredictionEndpoint?
  denseEmbeddingModelPredictionEndpoint;

  RagEmbeddingModelConfig_HybridSearchConfig({
    this.sparseEmbeddingConfig,
    this.denseEmbeddingModelPredictionEndpoint,
  }) : super(fullyQualifiedName);

  factory RagEmbeddingModelConfig_HybridSearchConfig.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagEmbeddingModelConfig_HybridSearchConfig(
      sparseEmbeddingConfig: decode(
        json['sparseEmbeddingConfig'],
        RagEmbeddingModelConfig_SparseEmbeddingConfig.fromJson,
      ),
      denseEmbeddingModelPredictionEndpoint: decode(
        json['denseEmbeddingModelPredictionEndpoint'],
        RagEmbeddingModelConfig_VertexPredictionEndpoint.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (sparseEmbeddingConfig != null)
        'sparseEmbeddingConfig': sparseEmbeddingConfig!.toJson(),
      if (denseEmbeddingModelPredictionEndpoint != null)
        'denseEmbeddingModelPredictionEndpoint':
            denseEmbeddingModelPredictionEndpoint!.toJson(),
    };
  }

  @override
  String toString() => 'HybridSearchConfig()';
}

/// Config for the Vector DB to use for RAG.
final class RagVectorDbConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig';

  /// The config for the RAG-managed Vector DB.
  final RagVectorDbConfig_RagManagedDb? ragManagedDb;

  /// The config for the Weaviate.
  final RagVectorDbConfig_Weaviate? weaviate;

  /// The config for the Pinecone.
  final RagVectorDbConfig_Pinecone? pinecone;

  /// The config for the Vertex Feature Store.
  final RagVectorDbConfig_VertexFeatureStore? vertexFeatureStore;

  /// The config for the Vertex Vector Search.
  final RagVectorDbConfig_VertexVectorSearch? vertexVectorSearch;

  /// Authentication config for the chosen Vector DB.
  final ApiAuth? apiAuth;

  /// Optional. Immutable. The embedding model config of the Vector DB.
  final RagEmbeddingModelConfig? ragEmbeddingModelConfig;

  RagVectorDbConfig({
    this.ragManagedDb,
    this.weaviate,
    this.pinecone,
    this.vertexFeatureStore,
    this.vertexVectorSearch,
    this.apiAuth,
    this.ragEmbeddingModelConfig,
  }) : super(fullyQualifiedName);

  factory RagVectorDbConfig.fromJson(Map<String, dynamic> json) {
    return RagVectorDbConfig(
      ragManagedDb: decode(
        json['ragManagedDb'],
        RagVectorDbConfig_RagManagedDb.fromJson,
      ),
      weaviate: decode(json['weaviate'], RagVectorDbConfig_Weaviate.fromJson),
      pinecone: decode(json['pinecone'], RagVectorDbConfig_Pinecone.fromJson),
      vertexFeatureStore: decode(
        json['vertexFeatureStore'],
        RagVectorDbConfig_VertexFeatureStore.fromJson,
      ),
      vertexVectorSearch: decode(
        json['vertexVectorSearch'],
        RagVectorDbConfig_VertexVectorSearch.fromJson,
      ),
      apiAuth: decode(json['apiAuth'], ApiAuth.fromJson),
      ragEmbeddingModelConfig: decode(
        json['ragEmbeddingModelConfig'],
        RagEmbeddingModelConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (ragManagedDb != null) 'ragManagedDb': ragManagedDb!.toJson(),
      if (weaviate != null) 'weaviate': weaviate!.toJson(),
      if (pinecone != null) 'pinecone': pinecone!.toJson(),
      if (vertexFeatureStore != null)
        'vertexFeatureStore': vertexFeatureStore!.toJson(),
      if (vertexVectorSearch != null)
        'vertexVectorSearch': vertexVectorSearch!.toJson(),
      if (apiAuth != null) 'apiAuth': apiAuth!.toJson(),
      if (ragEmbeddingModelConfig != null)
        'ragEmbeddingModelConfig': ragEmbeddingModelConfig!.toJson(),
    };
  }

  @override
  String toString() => 'RagVectorDbConfig()';
}

/// The config for the default RAG-managed Vector DB.
final class RagVectorDbConfig_RagManagedDb extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.RagManagedDb';

  /// Performs a KNN search on RagCorpus.
  /// Default choice if not specified.
  final RagVectorDbConfig_RagManagedDb_Knn? knn;

  /// Performs an ANN search on RagCorpus. Use this if you have a lot of
  /// files (> 10K) in your RagCorpus and want to reduce the search latency.
  final RagVectorDbConfig_RagManagedDb_Ann? ann;

  RagVectorDbConfig_RagManagedDb({this.knn, this.ann})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_RagManagedDb.fromJson(Map<String, dynamic> json) {
    return RagVectorDbConfig_RagManagedDb(
      knn: decode(json['knn'], RagVectorDbConfig_RagManagedDb_Knn.fromJson),
      ann: decode(json['ann'], RagVectorDbConfig_RagManagedDb_Ann.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (knn != null) 'knn': knn!.toJson(),
      if (ann != null) 'ann': ann!.toJson(),
    };
  }

  @override
  String toString() => 'RagManagedDb()';
}

/// Config for KNN search.
final class RagVectorDbConfig_RagManagedDb_Knn extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.RagManagedDb.KNN';

  RagVectorDbConfig_RagManagedDb_Knn() : super(fullyQualifiedName);

  factory RagVectorDbConfig_RagManagedDb_Knn.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagVectorDbConfig_RagManagedDb_Knn();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'KNN()';
}

/// Config for ANN search.
///
/// RagManagedDb uses a tree-based structure to partition data and
/// facilitate faster searches. As a tradeoff, it requires longer indexing
/// time and manual triggering of index rebuild via the ImportRagFiles and
/// UpdateRagCorpus API.
final class RagVectorDbConfig_RagManagedDb_Ann extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.RagManagedDb.ANN';

  /// The depth of the tree-based structure. Only depth values of 2 and 3 are
  /// supported.
  ///
  /// Recommended value is 2 if you have if you have O(10K) files in the
  /// RagCorpus and set this to 3 if more than that.
  ///
  /// Default value is 2.
  final int? treeDepth;

  /// Number of leaf nodes in the tree-based structure. Each leaf node
  /// contains groups of closely related vectors along with their
  /// corresponding centroid.
  ///
  /// Recommended value is 10 * sqrt(num of RagFiles in your RagCorpus).
  ///
  /// Default value is 500.
  final int? leafCount;

  RagVectorDbConfig_RagManagedDb_Ann({this.treeDepth, this.leafCount})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_RagManagedDb_Ann.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagVectorDbConfig_RagManagedDb_Ann(
      treeDepth: json['treeDepth'],
      leafCount: json['leafCount'],
    );
  }

  @override
  Object toJson() {
    return {
      if (treeDepth != null) 'treeDepth': treeDepth,
      if (leafCount != null) 'leafCount': leafCount,
    };
  }

  @override
  String toString() {
    final contents = [
      if (treeDepth != null) 'treeDepth=$treeDepth',
      if (leafCount != null) 'leafCount=$leafCount',
    ].join(',');
    return 'ANN($contents)';
  }
}

/// The config for the Weaviate.
final class RagVectorDbConfig_Weaviate extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.Weaviate';

  /// Weaviate DB instance HTTP endpoint. e.g. 34.56.78.90:8080
  /// Vertex RAG only supports HTTP connection to Weaviate.
  /// This value cannot be changed after it's set.
  final String? httpEndpoint;

  /// The corresponding collection this corpus maps to.
  /// This value cannot be changed after it's set.
  final String? collectionName;

  RagVectorDbConfig_Weaviate({this.httpEndpoint, this.collectionName})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_Weaviate.fromJson(Map<String, dynamic> json) {
    return RagVectorDbConfig_Weaviate(
      httpEndpoint: json['httpEndpoint'],
      collectionName: json['collectionName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (httpEndpoint != null) 'httpEndpoint': httpEndpoint,
      if (collectionName != null) 'collectionName': collectionName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (httpEndpoint != null) 'httpEndpoint=$httpEndpoint',
      if (collectionName != null) 'collectionName=$collectionName',
    ].join(',');
    return 'Weaviate($contents)';
  }
}

/// The config for the Pinecone.
final class RagVectorDbConfig_Pinecone extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.Pinecone';

  /// Pinecone index name.
  /// This value cannot be changed after it's set.
  final String? indexName;

  RagVectorDbConfig_Pinecone({this.indexName}) : super(fullyQualifiedName);

  factory RagVectorDbConfig_Pinecone.fromJson(Map<String, dynamic> json) {
    return RagVectorDbConfig_Pinecone(indexName: json['indexName']);
  }

  @override
  Object toJson() {
    return {if (indexName != null) 'indexName': indexName};
  }

  @override
  String toString() {
    final contents = [if (indexName != null) 'indexName=$indexName'].join(',');
    return 'Pinecone($contents)';
  }
}

/// The config for the Vertex Feature Store.
final class RagVectorDbConfig_VertexFeatureStore extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.VertexFeatureStore';

  /// The resource name of the FeatureView.
  /// Format:
  /// `projects/{project}/locations/{location}/featureOnlineStores/{feature_online_store}/featureViews/{feature_view}`
  final String? featureViewResourceName;

  RagVectorDbConfig_VertexFeatureStore({this.featureViewResourceName})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_VertexFeatureStore.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagVectorDbConfig_VertexFeatureStore(
      featureViewResourceName: json['featureViewResourceName'],
    );
  }

  @override
  Object toJson() {
    return {
      if (featureViewResourceName != null)
        'featureViewResourceName': featureViewResourceName,
    };
  }

  @override
  String toString() {
    final contents = [
      if (featureViewResourceName != null)
        'featureViewResourceName=$featureViewResourceName',
    ].join(',');
    return 'VertexFeatureStore($contents)';
  }
}

/// The config for the Vertex Vector Search.
final class RagVectorDbConfig_VertexVectorSearch extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagVectorDbConfig.VertexVectorSearch';

  /// The resource name of the Index Endpoint.
  /// Format:
  /// `projects/{project}/locations/{location}/indexEndpoints/{index_endpoint}`
  final String? indexEndpoint;

  /// The resource name of the Index.
  /// Format:
  /// `projects/{project}/locations/{location}/indexes/{index}`
  final String? index;

  RagVectorDbConfig_VertexVectorSearch({this.indexEndpoint, this.index})
    : super(fullyQualifiedName);

  factory RagVectorDbConfig_VertexVectorSearch.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagVectorDbConfig_VertexVectorSearch(
      indexEndpoint: json['indexEndpoint'],
      index: json['index'],
    );
  }

  @override
  Object toJson() {
    return {
      if (indexEndpoint != null) 'indexEndpoint': indexEndpoint,
      if (index != null) 'index': index,
    };
  }

  @override
  String toString() {
    final contents = [
      if (indexEndpoint != null) 'indexEndpoint=$indexEndpoint',
      if (index != null) 'index=$index',
    ].join(',');
    return 'VertexVectorSearch($contents)';
  }
}

/// RagFile status.
final class FileStatus extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.FileStatus';

  /// Output only. RagFile state.
  final FileStatus_State? state;

  /// Output only. Only when the `state` field is ERROR.
  final String? errorStatus;

  FileStatus({this.state, this.errorStatus}) : super(fullyQualifiedName);

  factory FileStatus.fromJson(Map<String, dynamic> json) {
    return FileStatus(
      state: decodeEnum(json['state'], FileStatus_State.fromJson),
      errorStatus: json['errorStatus'],
    );
  }

  @override
  Object toJson() {
    return {
      if (state != null) 'state': state!.toJson(),
      if (errorStatus != null) 'errorStatus': errorStatus,
    };
  }

  @override
  String toString() {
    final contents = [
      if (state != null) 'state=$state',
      if (errorStatus != null) 'errorStatus=$errorStatus',
    ].join(',');
    return 'FileStatus($contents)';
  }
}

/// RagFile state.
final class FileStatus_State extends protobuf.ProtoEnum {
  /// RagFile state is unspecified.
  static const stateUnspecified = FileStatus_State('STATE_UNSPECIFIED');

  /// RagFile resource has been created and indexed successfully.
  static const active = FileStatus_State('ACTIVE');

  /// RagFile resource is in a problematic state.
  /// See `error_message` field for details.
  static const error = FileStatus_State('ERROR');

  const FileStatus_State(super.value);

  factory FileStatus_State.fromJson(String json) => FileStatus_State(json);

  @override
  String toString() => 'State.$value';
}

/// Config for the Vertex AI Search.
final class VertexAiSearchConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.VertexAiSearchConfig';

  /// Vertex AI Search Serving Config resource full name. For example,
  /// `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}/servingConfigs/{serving_config}`
  /// or
  /// `projects/{project}/locations/{location}/collections/{collection}/dataStores/{data_store}/servingConfigs/{serving_config}`.
  final String? servingConfig;

  VertexAiSearchConfig({this.servingConfig}) : super(fullyQualifiedName);

  factory VertexAiSearchConfig.fromJson(Map<String, dynamic> json) {
    return VertexAiSearchConfig(servingConfig: json['servingConfig']);
  }

  @override
  Object toJson() {
    return {if (servingConfig != null) 'servingConfig': servingConfig};
  }

  @override
  String toString() {
    final contents = [
      if (servingConfig != null) 'servingConfig=$servingConfig',
    ].join(',');
    return 'VertexAiSearchConfig($contents)';
  }
}

/// RagCorpus status.
final class CorpusStatus extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CorpusStatus';

  /// Output only. RagCorpus life state.
  final CorpusStatus_State? state;

  /// Output only. Only when the `state` field is ERROR.
  final String? errorStatus;

  CorpusStatus({this.state, this.errorStatus}) : super(fullyQualifiedName);

  factory CorpusStatus.fromJson(Map<String, dynamic> json) {
    return CorpusStatus(
      state: decodeEnum(json['state'], CorpusStatus_State.fromJson),
      errorStatus: json['errorStatus'],
    );
  }

  @override
  Object toJson() {
    return {
      if (state != null) 'state': state!.toJson(),
      if (errorStatus != null) 'errorStatus': errorStatus,
    };
  }

  @override
  String toString() {
    final contents = [
      if (state != null) 'state=$state',
      if (errorStatus != null) 'errorStatus=$errorStatus',
    ].join(',');
    return 'CorpusStatus($contents)';
  }
}

/// RagCorpus life state.
final class CorpusStatus_State extends protobuf.ProtoEnum {
  /// This state is not supposed to happen.
  static const unknown = CorpusStatus_State('UNKNOWN');

  /// RagCorpus resource entry is initialized, but hasn't done validation.
  static const initialized = CorpusStatus_State('INITIALIZED');

  /// RagCorpus is provisioned successfully and is ready to serve.
  static const active = CorpusStatus_State('ACTIVE');

  /// RagCorpus is in a problematic situation.
  /// See `error_message` field for details.
  static const error = CorpusStatus_State('ERROR');

  const CorpusStatus_State(super.value);

  factory CorpusStatus_State.fromJson(String json) => CorpusStatus_State(json);

  @override
  String toString() => 'State.$value';
}

/// A RagCorpus is a RagFile container and a project can have multiple
/// RagCorpora.
final class RagCorpus extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagCorpus';

  /// Optional. Immutable. The config for the Vector DBs.
  final RagVectorDbConfig? vectorDbConfig;

  /// Optional. Immutable. The config for the Vertex AI Search.
  final VertexAiSearchConfig? vertexAiSearchConfig;

  /// Output only. The resource name of the RagCorpus.
  final String? name;

  /// Required. The display name of the RagCorpus.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Optional. The description of the RagCorpus.
  final String? description;

  /// Optional. Immutable. The embedding model config of the RagCorpus.
  final RagEmbeddingModelConfig? ragEmbeddingModelConfig;

  /// Optional. Immutable. The Vector DB config of the RagCorpus.
  final RagVectorDbConfig? ragVectorDbConfig;

  /// Output only. Timestamp when this RagCorpus was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this RagCorpus was last updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. RagCorpus state.
  final CorpusStatus? corpusStatus;

  /// Output only. Number of RagFiles in the RagCorpus.
  final int? ragFilesCount;

  /// Optional. Immutable. The CMEK key name used to encrypt at-rest data related
  /// to this Corpus. Only applicable to RagManagedDb option for Vector DB. This
  /// field can only be set at corpus creation time, and cannot be updated or
  /// deleted.
  final EncryptionSpec? encryptionSpec;

  /// Optional. The corpus type config of the RagCorpus.
  final RagCorpus_CorpusTypeConfig? corpusTypeConfig;

  RagCorpus({
    this.vectorDbConfig,
    this.vertexAiSearchConfig,
    this.name,
    this.displayName,
    this.description,
    this.ragEmbeddingModelConfig,
    this.ragVectorDbConfig,
    this.createTime,
    this.updateTime,
    this.corpusStatus,
    this.ragFilesCount,
    this.encryptionSpec,
    this.corpusTypeConfig,
  }) : super(fullyQualifiedName);

  factory RagCorpus.fromJson(Map<String, dynamic> json) {
    return RagCorpus(
      vectorDbConfig: decode(
        json['vectorDbConfig'],
        RagVectorDbConfig.fromJson,
      ),
      vertexAiSearchConfig: decode(
        json['vertexAiSearchConfig'],
        VertexAiSearchConfig.fromJson,
      ),
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      ragEmbeddingModelConfig: decode(
        json['ragEmbeddingModelConfig'],
        RagEmbeddingModelConfig.fromJson,
      ),
      ragVectorDbConfig: decode(
        json['ragVectorDbConfig'],
        RagVectorDbConfig.fromJson,
      ),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      corpusStatus: decode(json['corpusStatus'], CorpusStatus.fromJson),
      ragFilesCount: json['ragFilesCount'],
      encryptionSpec: decode(json['encryptionSpec'], EncryptionSpec.fromJson),
      corpusTypeConfig: decode(
        json['corpusTypeConfig'],
        RagCorpus_CorpusTypeConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (vectorDbConfig != null) 'vectorDbConfig': vectorDbConfig!.toJson(),
      if (vertexAiSearchConfig != null)
        'vertexAiSearchConfig': vertexAiSearchConfig!.toJson(),
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (ragEmbeddingModelConfig != null)
        'ragEmbeddingModelConfig': ragEmbeddingModelConfig!.toJson(),
      if (ragVectorDbConfig != null)
        'ragVectorDbConfig': ragVectorDbConfig!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (corpusStatus != null) 'corpusStatus': corpusStatus!.toJson(),
      if (ragFilesCount != null) 'ragFilesCount': ragFilesCount,
      if (encryptionSpec != null) 'encryptionSpec': encryptionSpec!.toJson(),
      if (corpusTypeConfig != null)
        'corpusTypeConfig': corpusTypeConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (ragFilesCount != null) 'ragFilesCount=$ragFilesCount',
    ].join(',');
    return 'RagCorpus($contents)';
  }
}

/// The config for the corpus type of the RagCorpus.
final class RagCorpus_CorpusTypeConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagCorpus.CorpusTypeConfig';

  /// Optional. Config for the document corpus.
  final RagCorpus_CorpusTypeConfig_DocumentCorpus? documentCorpus;

  /// Optional. Config for the memory corpus.
  final RagCorpus_CorpusTypeConfig_MemoryCorpus? memoryCorpus;

  RagCorpus_CorpusTypeConfig({this.documentCorpus, this.memoryCorpus})
    : super(fullyQualifiedName);

  factory RagCorpus_CorpusTypeConfig.fromJson(Map<String, dynamic> json) {
    return RagCorpus_CorpusTypeConfig(
      documentCorpus: decode(
        json['documentCorpus'],
        RagCorpus_CorpusTypeConfig_DocumentCorpus.fromJson,
      ),
      memoryCorpus: decode(
        json['memoryCorpus'],
        RagCorpus_CorpusTypeConfig_MemoryCorpus.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (documentCorpus != null) 'documentCorpus': documentCorpus!.toJson(),
      if (memoryCorpus != null) 'memoryCorpus': memoryCorpus!.toJson(),
    };
  }

  @override
  String toString() => 'CorpusTypeConfig()';
}

/// Config for the document corpus.
final class RagCorpus_CorpusTypeConfig_DocumentCorpus
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagCorpus.CorpusTypeConfig.DocumentCorpus';

  RagCorpus_CorpusTypeConfig_DocumentCorpus() : super(fullyQualifiedName);

  factory RagCorpus_CorpusTypeConfig_DocumentCorpus.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagCorpus_CorpusTypeConfig_DocumentCorpus();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'DocumentCorpus()';
}

/// Config for the memory corpus.
final class RagCorpus_CorpusTypeConfig_MemoryCorpus
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagCorpus.CorpusTypeConfig.MemoryCorpus';

  /// The LLM parser to use for the memory corpus.
  final RagFileParsingConfig_LlmParser? llmParser;

  RagCorpus_CorpusTypeConfig_MemoryCorpus({this.llmParser})
    : super(fullyQualifiedName);

  factory RagCorpus_CorpusTypeConfig_MemoryCorpus.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagCorpus_CorpusTypeConfig_MemoryCorpus(
      llmParser: decode(
        json['llmParser'],
        RagFileParsingConfig_LlmParser.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (llmParser != null) 'llmParser': llmParser!.toJson()};
  }

  @override
  String toString() => 'MemoryCorpus()';
}

/// A RagFile contains user data for chunking, embedding and indexing.
final class RagFile extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFile';

  /// Output only. Google Cloud Storage location of the RagFile.
  /// It does not support wildcards in the Cloud Storage uri for now.
  final GcsSource? gcsSource;

  /// Output only. Google Drive location. Supports importing individual files
  /// as well as Google Drive folders.
  final GoogleDriveSource? googleDriveSource;

  /// Output only. The RagFile is encapsulated and uploaded in the
  /// UploadRagFile request.
  final DirectUploadSource? directUploadSource;

  /// The RagFile is imported from a Slack channel.
  final SlackSource? slackSource;

  /// The RagFile is imported from a Jira query.
  final JiraSource? jiraSource;

  /// The RagFile is imported from a SharePoint source.
  final SharePointSources? sharePointSources;

  /// Output only. The resource name of the RagFile.
  final String? name;

  /// Required. The display name of the RagFile.
  /// The name can be up to 128 characters long and can consist of any UTF-8
  /// characters.
  final String? displayName;

  /// Optional. The description of the RagFile.
  final String? description;

  /// Output only. The size of the RagFile in bytes.
  final int? sizeBytes;

  /// Output only. The type of the RagFile.
  final RagFile_RagFileType? ragFileType;

  /// Output only. Timestamp when this RagFile was created.
  final protobuf.Timestamp? createTime;

  /// Output only. Timestamp when this RagFile was last updated.
  final protobuf.Timestamp? updateTime;

  /// Output only. State of the RagFile.
  final FileStatus? fileStatus;

  /// Output only. The metadata for metadata search. The contents will be
  /// be in JSON format.
  final String? userMetadata;

  RagFile({
    this.gcsSource,
    this.googleDriveSource,
    this.directUploadSource,
    this.slackSource,
    this.jiraSource,
    this.sharePointSources,
    this.name,
    this.displayName,
    this.description,
    this.sizeBytes,
    this.ragFileType,
    this.createTime,
    this.updateTime,
    this.fileStatus,
    this.userMetadata,
  }) : super(fullyQualifiedName);

  factory RagFile.fromJson(Map<String, dynamic> json) {
    return RagFile(
      gcsSource: decode(json['gcsSource'], GcsSource.fromJson),
      googleDriveSource: decode(
        json['googleDriveSource'],
        GoogleDriveSource.fromJson,
      ),
      directUploadSource: decode(
        json['directUploadSource'],
        DirectUploadSource.fromJson,
      ),
      slackSource: decode(json['slackSource'], SlackSource.fromJson),
      jiraSource: decode(json['jiraSource'], JiraSource.fromJson),
      sharePointSources: decode(
        json['sharePointSources'],
        SharePointSources.fromJson,
      ),
      name: json['name'],
      displayName: json['displayName'],
      description: json['description'],
      sizeBytes: decodeInt64(json['sizeBytes']),
      ragFileType: decodeEnum(
        json['ragFileType'],
        RagFile_RagFileType.fromJson,
      ),
      createTime: decodeCustom(json['createTime'], protobuf.Timestamp.fromJson),
      updateTime: decodeCustom(json['updateTime'], protobuf.Timestamp.fromJson),
      fileStatus: decode(json['fileStatus'], FileStatus.fromJson),
      userMetadata: json['userMetadata'],
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
      if (googleDriveSource != null)
        'googleDriveSource': googleDriveSource!.toJson(),
      if (directUploadSource != null)
        'directUploadSource': directUploadSource!.toJson(),
      if (slackSource != null) 'slackSource': slackSource!.toJson(),
      if (jiraSource != null) 'jiraSource': jiraSource!.toJson(),
      if (sharePointSources != null)
        'sharePointSources': sharePointSources!.toJson(),
      if (name != null) 'name': name,
      if (displayName != null) 'displayName': displayName,
      if (description != null) 'description': description,
      if (sizeBytes != null) 'sizeBytes': encodeInt64(sizeBytes),
      if (ragFileType != null) 'ragFileType': ragFileType!.toJson(),
      if (createTime != null) 'createTime': createTime!.toJson(),
      if (updateTime != null) 'updateTime': updateTime!.toJson(),
      if (fileStatus != null) 'fileStatus': fileStatus!.toJson(),
      if (userMetadata != null) 'userMetadata': userMetadata,
    };
  }

  @override
  String toString() {
    final contents = [
      if (name != null) 'name=$name',
      if (displayName != null) 'displayName=$displayName',
      if (description != null) 'description=$description',
      if (sizeBytes != null) 'sizeBytes=$sizeBytes',
      if (ragFileType != null) 'ragFileType=$ragFileType',
      if (userMetadata != null) 'userMetadata=$userMetadata',
    ].join(',');
    return 'RagFile($contents)';
  }
}

/// The type of the RagFile.
final class RagFile_RagFileType extends protobuf.ProtoEnum {
  /// RagFile type is unspecified.
  static const ragFileTypeUnspecified = RagFile_RagFileType(
    'RAG_FILE_TYPE_UNSPECIFIED',
  );

  /// RagFile type is TXT.
  static const ragFileTypeTxt = RagFile_RagFileType('RAG_FILE_TYPE_TXT');

  /// RagFile type is PDF.
  static const ragFileTypePdf = RagFile_RagFileType('RAG_FILE_TYPE_PDF');

  const RagFile_RagFileType(super.value);

  factory RagFile_RagFileType.fromJson(String json) =>
      RagFile_RagFileType(json);

  @override
  String toString() => 'RagFileType.$value';
}

/// A RagChunk includes the content of a chunk of a RagFile, and associated
/// metadata.
final class RagChunk extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagChunk';

  /// The content of the chunk.
  final String? text;

  /// If populated, represents where the chunk starts and ends in the document.
  final RagChunk_PageSpan? pageSpan;

  RagChunk({this.text, this.pageSpan}) : super(fullyQualifiedName);

  factory RagChunk.fromJson(Map<String, dynamic> json) {
    return RagChunk(
      text: json['text'],
      pageSpan: decode(json['pageSpan'], RagChunk_PageSpan.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (text != null) 'text': text,
      if (pageSpan != null) 'pageSpan': pageSpan!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (text != null) 'text=$text'].join(',');
    return 'RagChunk($contents)';
  }
}

/// Represents where the chunk starts and ends in the document.
final class RagChunk_PageSpan extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagChunk.PageSpan';

  /// Page where chunk starts in the document. Inclusive. 1-indexed.
  final int? firstPage;

  /// Page where chunk ends in the document. Inclusive. 1-indexed.
  final int? lastPage;

  RagChunk_PageSpan({this.firstPage, this.lastPage})
    : super(fullyQualifiedName);

  factory RagChunk_PageSpan.fromJson(Map<String, dynamic> json) {
    return RagChunk_PageSpan(
      firstPage: json['firstPage'],
      lastPage: json['lastPage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (firstPage != null) 'firstPage': firstPage,
      if (lastPage != null) 'lastPage': lastPage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (firstPage != null) 'firstPage=$firstPage',
      if (lastPage != null) 'lastPage=$lastPage',
    ].join(',');
    return 'PageSpan($contents)';
  }
}

/// Specifies the size and overlap of chunks for RagFiles.
final class RagFileChunkingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileChunkingConfig';

  /// Specifies the fixed length chunking config.
  final RagFileChunkingConfig_FixedLengthChunking? fixedLengthChunking;

  /// The size of the chunks.
  final int? chunkSize;

  /// The overlap between chunks.
  final int? chunkOverlap;

  RagFileChunkingConfig({
    this.fixedLengthChunking,
    this.chunkSize,
    this.chunkOverlap,
  }) : super(fullyQualifiedName);

  factory RagFileChunkingConfig.fromJson(Map<String, dynamic> json) {
    return RagFileChunkingConfig(
      fixedLengthChunking: decode(
        json['fixedLengthChunking'],
        RagFileChunkingConfig_FixedLengthChunking.fromJson,
      ),
      chunkSize: json['chunkSize'],
      chunkOverlap: json['chunkOverlap'],
    );
  }

  @override
  Object toJson() {
    return {
      if (fixedLengthChunking != null)
        'fixedLengthChunking': fixedLengthChunking!.toJson(),
      if (chunkSize != null) 'chunkSize': chunkSize,
      if (chunkOverlap != null) 'chunkOverlap': chunkOverlap,
    };
  }

  @override
  String toString() {
    final contents = [
      if (chunkSize != null) 'chunkSize=$chunkSize',
      if (chunkOverlap != null) 'chunkOverlap=$chunkOverlap',
    ].join(',');
    return 'RagFileChunkingConfig($contents)';
  }
}

/// Specifies the fixed length chunking config.
final class RagFileChunkingConfig_FixedLengthChunking
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileChunkingConfig.FixedLengthChunking';

  /// The size of the chunks.
  final int? chunkSize;

  /// The overlap between chunks.
  final int? chunkOverlap;

  RagFileChunkingConfig_FixedLengthChunking({this.chunkSize, this.chunkOverlap})
    : super(fullyQualifiedName);

  factory RagFileChunkingConfig_FixedLengthChunking.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagFileChunkingConfig_FixedLengthChunking(
      chunkSize: json['chunkSize'],
      chunkOverlap: json['chunkOverlap'],
    );
  }

  @override
  Object toJson() {
    return {
      if (chunkSize != null) 'chunkSize': chunkSize,
      if (chunkOverlap != null) 'chunkOverlap': chunkOverlap,
    };
  }

  @override
  String toString() {
    final contents = [
      if (chunkSize != null) 'chunkSize=$chunkSize',
      if (chunkOverlap != null) 'chunkOverlap=$chunkOverlap',
    ].join(',');
    return 'FixedLengthChunking($contents)';
  }
}

/// Specifies the transformation config for RagFiles.
final class RagFileTransformationConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileTransformationConfig';

  /// Specifies the chunking config for RagFiles.
  final RagFileChunkingConfig? ragFileChunkingConfig;

  RagFileTransformationConfig({this.ragFileChunkingConfig})
    : super(fullyQualifiedName);

  factory RagFileTransformationConfig.fromJson(Map<String, dynamic> json) {
    return RagFileTransformationConfig(
      ragFileChunkingConfig: decode(
        json['ragFileChunkingConfig'],
        RagFileChunkingConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (ragFileChunkingConfig != null)
        'ragFileChunkingConfig': ragFileChunkingConfig!.toJson(),
    };
  }

  @override
  String toString() => 'RagFileTransformationConfig()';
}

/// Specifies the parsing config for RagFiles.
final class RagFileParsingConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileParsingConfig';

  /// The Advanced Parser to use for RagFiles.
  final RagFileParsingConfig_AdvancedParser? advancedParser;

  /// The Layout Parser to use for RagFiles.
  final RagFileParsingConfig_LayoutParser? layoutParser;

  /// The LLM Parser to use for RagFiles.
  final RagFileParsingConfig_LlmParser? llmParser;

  /// Whether to use advanced PDF parsing.
  final bool? useAdvancedPdfParsing;

  RagFileParsingConfig({
    this.advancedParser,
    this.layoutParser,
    this.llmParser,
    this.useAdvancedPdfParsing,
  }) : super(fullyQualifiedName);

  factory RagFileParsingConfig.fromJson(Map<String, dynamic> json) {
    return RagFileParsingConfig(
      advancedParser: decode(
        json['advancedParser'],
        RagFileParsingConfig_AdvancedParser.fromJson,
      ),
      layoutParser: decode(
        json['layoutParser'],
        RagFileParsingConfig_LayoutParser.fromJson,
      ),
      llmParser: decode(
        json['llmParser'],
        RagFileParsingConfig_LlmParser.fromJson,
      ),
      useAdvancedPdfParsing: json['useAdvancedPdfParsing'],
    );
  }

  @override
  Object toJson() {
    return {
      if (advancedParser != null) 'advancedParser': advancedParser!.toJson(),
      if (layoutParser != null) 'layoutParser': layoutParser!.toJson(),
      if (llmParser != null) 'llmParser': llmParser!.toJson(),
      if (useAdvancedPdfParsing != null)
        'useAdvancedPdfParsing': useAdvancedPdfParsing,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useAdvancedPdfParsing != null)
        'useAdvancedPdfParsing=$useAdvancedPdfParsing',
    ].join(',');
    return 'RagFileParsingConfig($contents)';
  }
}

/// Specifies the advanced parsing for RagFiles.
final class RagFileParsingConfig_AdvancedParser extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileParsingConfig.AdvancedParser';

  /// Whether to use advanced PDF parsing.
  final bool? useAdvancedPdfParsing;

  RagFileParsingConfig_AdvancedParser({this.useAdvancedPdfParsing})
    : super(fullyQualifiedName);

  factory RagFileParsingConfig_AdvancedParser.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagFileParsingConfig_AdvancedParser(
      useAdvancedPdfParsing: json['useAdvancedPdfParsing'],
    );
  }

  @override
  Object toJson() {
    return {
      if (useAdvancedPdfParsing != null)
        'useAdvancedPdfParsing': useAdvancedPdfParsing,
    };
  }

  @override
  String toString() {
    final contents = [
      if (useAdvancedPdfParsing != null)
        'useAdvancedPdfParsing=$useAdvancedPdfParsing',
    ].join(',');
    return 'AdvancedParser($contents)';
  }
}

/// Document AI Layout Parser config.
final class RagFileParsingConfig_LayoutParser extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileParsingConfig.LayoutParser';

  /// The full resource name of a Document AI processor or processor version.
  /// The processor must have type `LAYOUT_PARSER_PROCESSOR`. If specified, the
  /// `additional_config.parse_as_scanned_pdf` field must be false.
  /// Format:
  /// * `projects/{project_id}/locations/{location}/processors/{processor_id}`
  /// * `projects/{project_id}/locations/{location}/processors/{processor_id}/processorVersions/{processor_version_id}`
  final String? processorName;

  /// The maximum number of requests the job is allowed to make to the Document
  /// AI processor per minute. Consult
  /// https://cloud.google.com/document-ai/quotas and the Quota page for your
  /// project to set an appropriate value here. If unspecified, a default value
  /// of 120 QPM would be used.
  final int? maxParsingRequestsPerMin;

  /// The maximum number of requests the job is allowed to make to the Document
  /// AI processor per minute in this project. Consult
  /// https://cloud.google.com/document-ai/quotas and the Quota page for your
  /// project to set an appropriate value here.
  /// If this value is not specified,
  /// max_parsing_requests_per_min will be used by indexing
  /// pipeline as the global limit.
  final int? globalMaxParsingRequestsPerMin;

  RagFileParsingConfig_LayoutParser({
    this.processorName,
    this.maxParsingRequestsPerMin,
    this.globalMaxParsingRequestsPerMin,
  }) : super(fullyQualifiedName);

  factory RagFileParsingConfig_LayoutParser.fromJson(
    Map<String, dynamic> json,
  ) {
    return RagFileParsingConfig_LayoutParser(
      processorName: json['processorName'],
      maxParsingRequestsPerMin: json['maxParsingRequestsPerMin'],
      globalMaxParsingRequestsPerMin: json['globalMaxParsingRequestsPerMin'],
    );
  }

  @override
  Object toJson() {
    return {
      if (processorName != null) 'processorName': processorName,
      if (maxParsingRequestsPerMin != null)
        'maxParsingRequestsPerMin': maxParsingRequestsPerMin,
      if (globalMaxParsingRequestsPerMin != null)
        'globalMaxParsingRequestsPerMin': globalMaxParsingRequestsPerMin,
    };
  }

  @override
  String toString() {
    final contents = [
      if (processorName != null) 'processorName=$processorName',
      if (maxParsingRequestsPerMin != null)
        'maxParsingRequestsPerMin=$maxParsingRequestsPerMin',
      if (globalMaxParsingRequestsPerMin != null)
        'globalMaxParsingRequestsPerMin=$globalMaxParsingRequestsPerMin',
    ].join(',');
    return 'LayoutParser($contents)';
  }
}

/// Specifies the LLM parsing for RagFiles.
final class RagFileParsingConfig_LlmParser extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileParsingConfig.LlmParser';

  /// The name of a LLM model used for parsing.
  /// Format:
  /// * `projects/{project_id}/locations/{location}/publishers/{publisher}/models/{model}`
  final String? modelName;

  /// The maximum number of requests the job is allowed to make to the
  /// LLM model per minute. Consult
  /// https://cloud.google.com/vertex-ai/generative-ai/docs/quotas
  /// and your document size to set an appropriate value here. If unspecified,
  /// a default value of 5000 QPM would be used.
  final int? maxParsingRequestsPerMin;

  /// The maximum number of requests the job is allowed to make to the
  /// LLM model per minute in this project. Consult
  /// https://cloud.google.com/vertex-ai/generative-ai/docs/quotas
  /// and your document size to set an appropriate value here.
  /// If this value is not specified,
  /// max_parsing_requests_per_min will be used by indexing pipeline job as the
  /// global limit.
  final int? globalMaxParsingRequestsPerMin;

  /// The prompt to use for parsing. If not specified, a default prompt will
  /// be used.
  final String? customParsingPrompt;

  RagFileParsingConfig_LlmParser({
    this.modelName,
    this.maxParsingRequestsPerMin,
    this.globalMaxParsingRequestsPerMin,
    this.customParsingPrompt,
  }) : super(fullyQualifiedName);

  factory RagFileParsingConfig_LlmParser.fromJson(Map<String, dynamic> json) {
    return RagFileParsingConfig_LlmParser(
      modelName: json['modelName'],
      maxParsingRequestsPerMin: json['maxParsingRequestsPerMin'],
      globalMaxParsingRequestsPerMin: json['globalMaxParsingRequestsPerMin'],
      customParsingPrompt: json['customParsingPrompt'],
    );
  }

  @override
  Object toJson() {
    return {
      if (modelName != null) 'modelName': modelName,
      if (maxParsingRequestsPerMin != null)
        'maxParsingRequestsPerMin': maxParsingRequestsPerMin,
      if (globalMaxParsingRequestsPerMin != null)
        'globalMaxParsingRequestsPerMin': globalMaxParsingRequestsPerMin,
      if (customParsingPrompt != null)
        'customParsingPrompt': customParsingPrompt,
    };
  }

  @override
  String toString() {
    final contents = [
      if (modelName != null) 'modelName=$modelName',
      if (maxParsingRequestsPerMin != null)
        'maxParsingRequestsPerMin=$maxParsingRequestsPerMin',
      if (globalMaxParsingRequestsPerMin != null)
        'globalMaxParsingRequestsPerMin=$globalMaxParsingRequestsPerMin',
      if (customParsingPrompt != null)
        'customParsingPrompt=$customParsingPrompt',
    ].join(',');
    return 'LlmParser($contents)';
  }
}

/// Metadata config for RagFile.
final class RagFileMetadataConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagFileMetadataConfig';

  /// Google Cloud Storage location. Supports importing individual files as
  /// well as entire Google Cloud Storage directories. Sample formats:
  /// - `gs://bucket_name/my_directory/object_name/metadata_schema.json`
  /// - `gs://bucket_name/my_directory`
  /// If providing a directory, the metadata schema will be read from
  /// the files that ends with "metadata_schema.json" in the directory.
  final GcsSource? gcsMetadataSchemaSource;

  /// Google Drive location. Supports importing individual files as
  /// well as Google Drive folders.
  /// If providing a folder, the metadata schema will be read from
  /// the files that ends with "metadata_schema.json" in the directory.
  final GoogleDriveSource? googleDriveMetadataSchemaSource;

  /// Inline metadata schema source. Must be a JSON string.
  final String? inlineMetadataSchemaSource;

  /// Google Cloud Storage location. Supports importing individual files as
  /// well as entire Google Cloud Storage directories. Sample formats:
  /// - `gs://bucket_name/my_directory/object_name/metadata.json`
  /// - `gs://bucket_name/my_directory`
  /// If providing a directory, the metadata will be read from
  /// the files that ends with "metadata.json" in the directory.
  final GcsSource? gcsMetadataSource;

  /// Google Drive location. Supports importing individual files as
  /// well as Google Drive folders.
  /// If providing a directory, the metadata will be read from
  /// the files that ends with "metadata.json" in the directory.
  final GoogleDriveSource? googleDriveMetadataSource;

  /// Inline metadata source. Must be a JSON string.
  final String? inlineMetadataSource;

  RagFileMetadataConfig({
    this.gcsMetadataSchemaSource,
    this.googleDriveMetadataSchemaSource,
    this.inlineMetadataSchemaSource,
    this.gcsMetadataSource,
    this.googleDriveMetadataSource,
    this.inlineMetadataSource,
  }) : super(fullyQualifiedName);

  factory RagFileMetadataConfig.fromJson(Map<String, dynamic> json) {
    return RagFileMetadataConfig(
      gcsMetadataSchemaSource: decode(
        json['gcsMetadataSchemaSource'],
        GcsSource.fromJson,
      ),
      googleDriveMetadataSchemaSource: decode(
        json['googleDriveMetadataSchemaSource'],
        GoogleDriveSource.fromJson,
      ),
      inlineMetadataSchemaSource: json['inlineMetadataSchemaSource'],
      gcsMetadataSource: decode(json['gcsMetadataSource'], GcsSource.fromJson),
      googleDriveMetadataSource: decode(
        json['googleDriveMetadataSource'],
        GoogleDriveSource.fromJson,
      ),
      inlineMetadataSource: json['inlineMetadataSource'],
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsMetadataSchemaSource != null)
        'gcsMetadataSchemaSource': gcsMetadataSchemaSource!.toJson(),
      if (googleDriveMetadataSchemaSource != null)
        'googleDriveMetadataSchemaSource': googleDriveMetadataSchemaSource!
            .toJson(),
      if (inlineMetadataSchemaSource != null)
        'inlineMetadataSchemaSource': inlineMetadataSchemaSource,
      if (gcsMetadataSource != null)
        'gcsMetadataSource': gcsMetadataSource!.toJson(),
      if (googleDriveMetadataSource != null)
        'googleDriveMetadataSource': googleDriveMetadataSource!.toJson(),
      if (inlineMetadataSource != null)
        'inlineMetadataSource': inlineMetadataSource,
    };
  }

  @override
  String toString() {
    final contents = [
      if (inlineMetadataSchemaSource != null)
        'inlineMetadataSchemaSource=$inlineMetadataSchemaSource',
      if (inlineMetadataSource != null)
        'inlineMetadataSource=$inlineMetadataSource',
    ].join(',');
    return 'RagFileMetadataConfig($contents)';
  }
}

/// Config for uploading RagFile.
final class UploadRagFileConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadRagFileConfig';

  /// Specifies the size and overlap of chunks after uploading RagFile.
  final RagFileChunkingConfig? ragFileChunkingConfig;

  /// Specifies the transformation config for RagFiles.
  final RagFileTransformationConfig? ragFileTransformationConfig;

  /// Specifies the metadata config for RagFiles.
  /// Including paths for metadata schema and metadata.
  /// Alteratively, inline metadata schema and metadata can be provided.
  final RagFileMetadataConfig? ragFileMetadataConfig;

  /// Optional. Specifies the parsing config for RagFiles.
  /// RAG will use the default parser if this field is not set.
  final RagFileParsingConfig? ragFileParsingConfig;

  UploadRagFileConfig({
    this.ragFileChunkingConfig,
    this.ragFileTransformationConfig,
    this.ragFileMetadataConfig,
    this.ragFileParsingConfig,
  }) : super(fullyQualifiedName);

  factory UploadRagFileConfig.fromJson(Map<String, dynamic> json) {
    return UploadRagFileConfig(
      ragFileChunkingConfig: decode(
        json['ragFileChunkingConfig'],
        RagFileChunkingConfig.fromJson,
      ),
      ragFileTransformationConfig: decode(
        json['ragFileTransformationConfig'],
        RagFileTransformationConfig.fromJson,
      ),
      ragFileMetadataConfig: decode(
        json['ragFileMetadataConfig'],
        RagFileMetadataConfig.fromJson,
      ),
      ragFileParsingConfig: decode(
        json['ragFileParsingConfig'],
        RagFileParsingConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (ragFileChunkingConfig != null)
        'ragFileChunkingConfig': ragFileChunkingConfig!.toJson(),
      if (ragFileTransformationConfig != null)
        'ragFileTransformationConfig': ragFileTransformationConfig!.toJson(),
      if (ragFileMetadataConfig != null)
        'ragFileMetadataConfig': ragFileMetadataConfig!.toJson(),
      if (ragFileParsingConfig != null)
        'ragFileParsingConfig': ragFileParsingConfig!.toJson(),
    };
  }

  @override
  String toString() => 'UploadRagFileConfig()';
}

/// Config for importing RagFiles.
final class ImportRagFilesConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportRagFilesConfig';

  /// Google Cloud Storage location. Supports importing individual files as
  /// well as entire Google Cloud Storage directories. Sample formats:
  /// - `gs://bucket_name/my_directory/object_name/my_file.txt`
  /// - `gs://bucket_name/my_directory`
  final GcsSource? gcsSource;

  /// Google Drive location. Supports importing individual files as
  /// well as Google Drive folders.
  final GoogleDriveSource? googleDriveSource;

  /// Slack channels with their corresponding access tokens.
  final SlackSource? slackSource;

  /// Jira queries with their corresponding authentication.
  final JiraSource? jiraSource;

  /// SharePoint sources.
  final SharePointSources? sharePointSources;

  /// The Cloud Storage path to write partial failures to.
  /// Deprecated. Prefer to use `import_result_gcs_sink`.
  final GcsDestination? partialFailureGcsSink;

  /// The BigQuery destination to write partial failures to. It should be a
  /// bigquery table resource name (e.g.
  /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
  /// table does not exist, it will be created with the expected schema. If the
  /// table exists, the schema will be validated and data will be added to this
  /// existing table.
  /// Deprecated. Prefer to use `import_result_bq_sink`.
  final BigQueryDestination? partialFailureBigquerySink;

  /// The Cloud Storage path to write import result to.
  final GcsDestination? importResultGcsSink;

  /// The BigQuery destination to write import result to. It should be a
  /// bigquery table resource name (e.g.
  /// "bq://projectId.bqDatasetId.bqTableId"). The dataset must exist. If the
  /// table does not exist, it will be created with the expected schema. If the
  /// table exists, the schema will be validated and data will be added to this
  /// existing table.
  final BigQueryDestination? importResultBigquerySink;

  /// Specifies the size and overlap of chunks after importing RagFiles.
  final RagFileChunkingConfig? ragFileChunkingConfig;

  /// Specifies the transformation config for RagFiles.
  final RagFileTransformationConfig? ragFileTransformationConfig;

  /// Optional. Specifies the parsing config for RagFiles.
  /// RAG will use the default parser if this field is not set.
  final RagFileParsingConfig? ragFileParsingConfig;

  /// Specifies the metadata config for RagFiles.
  /// Including paths for metadata schema and metadata.
  final RagFileMetadataConfig? ragFileMetadataConfig;

  /// Optional. The max number of queries per minute that this job is allowed to
  /// make to the embedding model specified on the corpus. This value is specific
  /// to this job and not shared across other import jobs. Consult the Quotas
  /// page on the project to set an appropriate value here.
  /// If unspecified, a default value of 1,000 QPM would be used.
  final int? maxEmbeddingRequestsPerMin;

  /// Optional. The max number of queries per minute that the indexing pipeline
  /// job is allowed to make to the embedding model specified in the project.
  /// Please follow the quota usage guideline of the embedding model you use to
  /// set the value properly.If this value is not specified,
  /// max_embedding_requests_per_min will be used by indexing pipeline job as the
  /// global limit.
  final int? globalMaxEmbeddingRequestsPerMin;

  /// Rebuilds the ANN index to optimize for recall on the imported data.
  /// Only applicable for RagCorpora running on RagManagedDb with
  /// `retrieval_strategy` set to `ANN`. The rebuild will be performed using the
  /// existing ANN config set on the RagCorpus. To change the ANN config, please
  /// use the UpdateRagCorpus API.
  ///
  /// Default is false, i.e., index is not rebuilt.
  final bool? rebuildAnnIndex;

  ImportRagFilesConfig({
    this.gcsSource,
    this.googleDriveSource,
    this.slackSource,
    this.jiraSource,
    this.sharePointSources,
    this.partialFailureGcsSink,
    this.partialFailureBigquerySink,
    this.importResultGcsSink,
    this.importResultBigquerySink,
    this.ragFileChunkingConfig,
    this.ragFileTransformationConfig,
    this.ragFileParsingConfig,
    this.ragFileMetadataConfig,
    this.maxEmbeddingRequestsPerMin,
    this.globalMaxEmbeddingRequestsPerMin,
    this.rebuildAnnIndex,
  }) : super(fullyQualifiedName);

  factory ImportRagFilesConfig.fromJson(Map<String, dynamic> json) {
    return ImportRagFilesConfig(
      gcsSource: decode(json['gcsSource'], GcsSource.fromJson),
      googleDriveSource: decode(
        json['googleDriveSource'],
        GoogleDriveSource.fromJson,
      ),
      slackSource: decode(json['slackSource'], SlackSource.fromJson),
      jiraSource: decode(json['jiraSource'], JiraSource.fromJson),
      sharePointSources: decode(
        json['sharePointSources'],
        SharePointSources.fromJson,
      ),
      partialFailureGcsSink: decode(
        json['partialFailureGcsSink'],
        GcsDestination.fromJson,
      ),
      partialFailureBigquerySink: decode(
        json['partialFailureBigquerySink'],
        BigQueryDestination.fromJson,
      ),
      importResultGcsSink: decode(
        json['importResultGcsSink'],
        GcsDestination.fromJson,
      ),
      importResultBigquerySink: decode(
        json['importResultBigquerySink'],
        BigQueryDestination.fromJson,
      ),
      ragFileChunkingConfig: decode(
        json['ragFileChunkingConfig'],
        RagFileChunkingConfig.fromJson,
      ),
      ragFileTransformationConfig: decode(
        json['ragFileTransformationConfig'],
        RagFileTransformationConfig.fromJson,
      ),
      ragFileParsingConfig: decode(
        json['ragFileParsingConfig'],
        RagFileParsingConfig.fromJson,
      ),
      ragFileMetadataConfig: decode(
        json['ragFileMetadataConfig'],
        RagFileMetadataConfig.fromJson,
      ),
      maxEmbeddingRequestsPerMin: json['maxEmbeddingRequestsPerMin'],
      globalMaxEmbeddingRequestsPerMin:
          json['globalMaxEmbeddingRequestsPerMin'],
      rebuildAnnIndex: json['rebuildAnnIndex'],
    );
  }

  @override
  Object toJson() {
    return {
      if (gcsSource != null) 'gcsSource': gcsSource!.toJson(),
      if (googleDriveSource != null)
        'googleDriveSource': googleDriveSource!.toJson(),
      if (slackSource != null) 'slackSource': slackSource!.toJson(),
      if (jiraSource != null) 'jiraSource': jiraSource!.toJson(),
      if (sharePointSources != null)
        'sharePointSources': sharePointSources!.toJson(),
      if (partialFailureGcsSink != null)
        'partialFailureGcsSink': partialFailureGcsSink!.toJson(),
      if (partialFailureBigquerySink != null)
        'partialFailureBigquerySink': partialFailureBigquerySink!.toJson(),
      if (importResultGcsSink != null)
        'importResultGcsSink': importResultGcsSink!.toJson(),
      if (importResultBigquerySink != null)
        'importResultBigquerySink': importResultBigquerySink!.toJson(),
      if (ragFileChunkingConfig != null)
        'ragFileChunkingConfig': ragFileChunkingConfig!.toJson(),
      if (ragFileTransformationConfig != null)
        'ragFileTransformationConfig': ragFileTransformationConfig!.toJson(),
      if (ragFileParsingConfig != null)
        'ragFileParsingConfig': ragFileParsingConfig!.toJson(),
      if (ragFileMetadataConfig != null)
        'ragFileMetadataConfig': ragFileMetadataConfig!.toJson(),
      if (maxEmbeddingRequestsPerMin != null)
        'maxEmbeddingRequestsPerMin': maxEmbeddingRequestsPerMin,
      if (globalMaxEmbeddingRequestsPerMin != null)
        'globalMaxEmbeddingRequestsPerMin': globalMaxEmbeddingRequestsPerMin,
      if (rebuildAnnIndex != null) 'rebuildAnnIndex': rebuildAnnIndex,
    };
  }

  @override
  String toString() {
    final contents = [
      if (maxEmbeddingRequestsPerMin != null)
        'maxEmbeddingRequestsPerMin=$maxEmbeddingRequestsPerMin',
      if (globalMaxEmbeddingRequestsPerMin != null)
        'globalMaxEmbeddingRequestsPerMin=$globalMaxEmbeddingRequestsPerMin',
      if (rebuildAnnIndex != null) 'rebuildAnnIndex=$rebuildAnnIndex',
    ].join(',');
    return 'ImportRagFilesConfig($contents)';
  }
}

/// Configuration message for RagManagedDb used by RagEngine.
final class RagManagedDbConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig';

  /// Deprecated: Please use `Scaled` tier instead.
  /// Sets the RagManagedDb to the Enterprise tier. This is the default tier
  /// if not explicitly chosen.
  final RagManagedDbConfig_Enterprise? enterprise;

  /// Sets the RagManagedDb to the Scaled tier.
  final RagManagedDbConfig_Scaled? scaled;

  /// Sets the RagManagedDb to the Basic tier.
  final RagManagedDbConfig_Basic? basic;

  /// Sets the RagManagedDb to the Unprovisioned tier.
  final RagManagedDbConfig_Unprovisioned? unprovisioned;

  RagManagedDbConfig({
    this.enterprise,
    this.scaled,
    this.basic,
    this.unprovisioned,
  }) : super(fullyQualifiedName);

  factory RagManagedDbConfig.fromJson(Map<String, dynamic> json) {
    return RagManagedDbConfig(
      enterprise: decode(
        json['enterprise'],
        RagManagedDbConfig_Enterprise.fromJson,
      ),
      scaled: decode(json['scaled'], RagManagedDbConfig_Scaled.fromJson),
      basic: decode(json['basic'], RagManagedDbConfig_Basic.fromJson),
      unprovisioned: decode(
        json['unprovisioned'],
        RagManagedDbConfig_Unprovisioned.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (enterprise != null) 'enterprise': enterprise!.toJson(),
      if (scaled != null) 'scaled': scaled!.toJson(),
      if (basic != null) 'basic': basic!.toJson(),
      if (unprovisioned != null) 'unprovisioned': unprovisioned!.toJson(),
    };
  }

  @override
  String toString() => 'RagManagedDbConfig()';
}

/// Deprecated: Please use `Scaled` tier instead.
/// Enterprise tier offers production grade performance along with
/// autoscaling functionality. It is suitable for customers with large
/// amounts of data or performance sensitive workloads.
final class RagManagedDbConfig_Enterprise extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig.Enterprise';

  RagManagedDbConfig_Enterprise() : super(fullyQualifiedName);

  factory RagManagedDbConfig_Enterprise.fromJson(Map<String, dynamic> json) {
    return RagManagedDbConfig_Enterprise();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'Enterprise()';
}

/// Scaled tier offers production grade performance along with
/// autoscaling functionality. It is suitable for customers with large
/// amounts of data or performance sensitive workloads.
final class RagManagedDbConfig_Scaled extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig.Scaled';

  RagManagedDbConfig_Scaled() : super(fullyQualifiedName);

  factory RagManagedDbConfig_Scaled.fromJson(Map<String, dynamic> json) {
    return RagManagedDbConfig_Scaled();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'Scaled()';
}

/// Basic tier is a cost-effective and low compute tier suitable for
/// the following cases:
/// * Experimenting with RagManagedDb.
/// * Small data size.
/// * Latency insensitive workload.
/// * Only using RAG Engine with external vector DBs.
///
/// NOTE: This is the default tier if not explicitly chosen.
final class RagManagedDbConfig_Basic extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig.Basic';

  RagManagedDbConfig_Basic() : super(fullyQualifiedName);

  factory RagManagedDbConfig_Basic.fromJson(Map<String, dynamic> json) {
    return RagManagedDbConfig_Basic();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'Basic()';
}

/// Disables the RAG Engine service and deletes all your data held
/// within this service. This will halt the billing of the service.
///
/// NOTE: Once deleted the data cannot be recovered. To start using
/// RAG Engine again, you will need to update the tier by calling the
/// UpdateRagEngineConfig API.
final class RagManagedDbConfig_Unprovisioned extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagManagedDbConfig.Unprovisioned';

  RagManagedDbConfig_Unprovisioned() : super(fullyQualifiedName);

  factory RagManagedDbConfig_Unprovisioned.fromJson(Map<String, dynamic> json) {
    return RagManagedDbConfig_Unprovisioned();
  }

  @override
  Object toJson() {
    return {};
  }

  @override
  String toString() => 'Unprovisioned()';
}

/// Config for RagEngine.
final class RagEngineConfig extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagEngineConfig';

  /// Identifier. The name of the RagEngineConfig.
  /// Format:
  /// `projects/{project}/locations/{location}/ragEngineConfig`
  final String? name;

  /// The config of the RagManagedDb used by RagEngine.
  final RagManagedDbConfig? ragManagedDbConfig;

  RagEngineConfig({this.name, this.ragManagedDbConfig})
    : super(fullyQualifiedName);

  factory RagEngineConfig.fromJson(Map<String, dynamic> json) {
    return RagEngineConfig(
      name: json['name'],
      ragManagedDbConfig: decode(
        json['ragManagedDbConfig'],
        RagManagedDbConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (name != null) 'name': name,
      if (ragManagedDbConfig != null)
        'ragManagedDbConfig': ragManagedDbConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [if (name != null) 'name=$name'].join(',');
    return 'RagEngineConfig($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.CreateRagCorpus`.
final class CreateRagCorpusRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateRagCorpusRequest';

  /// Required. The resource name of the Location to create the RagCorpus in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The RagCorpus to create.
  final RagCorpus ragCorpus;

  CreateRagCorpusRequest({required this.parent, required this.ragCorpus})
    : super(fullyQualifiedName);

  factory CreateRagCorpusRequest.fromJson(Map<String, dynamic> json) {
    return CreateRagCorpusRequest(
      parent: json['parent'],
      ragCorpus: decode(json['ragCorpus'], RagCorpus.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'ragCorpus': ragCorpus.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateRagCorpusRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.GetRagCorpus`
final class GetRagCorpusRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetRagCorpusRequest';

  /// Required. The name of the RagCorpus resource.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String name;

  GetRagCorpusRequest({required this.name}) : super(fullyQualifiedName);

  factory GetRagCorpusRequest.fromJson(Map<String, dynamic> json) {
    return GetRagCorpusRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetRagCorpusRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.ListRagCorpora`.
final class ListRagCorporaRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListRagCorporaRequest';

  /// Required. The resource name of the Location from which to list the
  /// RagCorpora. Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListRagCorporaResponse.next_page_token`
  /// of the previous
  /// `VertexRagDataService.ListRagCorpora`
  /// call.
  final String? pageToken;

  ListRagCorporaRequest({required this.parent, this.pageSize, this.pageToken})
    : super(fullyQualifiedName);

  factory ListRagCorporaRequest.fromJson(Map<String, dynamic> json) {
    return ListRagCorporaRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListRagCorporaRequest($contents)';
  }
}

/// Response message for
/// `VertexRagDataService.ListRagCorpora`.
final class ListRagCorporaResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListRagCorporaResponse';

  /// List of RagCorpora in the requested page.
  final List<RagCorpus>? ragCorpora;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListRagCorporaRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListRagCorporaResponse({this.ragCorpora, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListRagCorporaResponse.fromJson(Map<String, dynamic> json) {
    return ListRagCorporaResponse(
      ragCorpora: decodeListMessage(json['ragCorpora'], RagCorpus.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (ragCorpora != null) 'ragCorpora': encodeList(ragCorpora),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListRagCorporaResponse($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.DeleteRagCorpus`.
final class DeleteRagCorpusRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteRagCorpusRequest';

  /// Required. The name of the RagCorpus resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String name;

  /// Optional. If set to true, any RagFiles in this RagCorpus will also be
  /// deleted. Otherwise, the request will only work if the RagCorpus has no
  /// RagFiles.
  final bool? force;

  DeleteRagCorpusRequest({required this.name, this.force})
    : super(fullyQualifiedName);

  factory DeleteRagCorpusRequest.fromJson(Map<String, dynamic> json) {
    return DeleteRagCorpusRequest(name: json['name'], force: json['force']);
  }

  @override
  Object toJson() {
    return {'name': name, if (force != null) 'force': force};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (force != null) 'force=$force',
    ].join(',');
    return 'DeleteRagCorpusRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.UploadRagFile`.
final class UploadRagFileRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadRagFileRequest';

  /// Required. The name of the RagCorpus resource into which to upload the file.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String parent;

  /// Required. The RagFile to upload.
  final RagFile? ragFile;

  /// Required. The config for the RagFiles to be uploaded into the RagCorpus.
  /// `VertexRagDataService.UploadRagFile`.
  final UploadRagFileConfig? uploadRagFileConfig;

  UploadRagFileRequest({
    required this.parent,
    this.ragFile,
    this.uploadRagFileConfig,
  }) : super(fullyQualifiedName);

  factory UploadRagFileRequest.fromJson(Map<String, dynamic> json) {
    return UploadRagFileRequest(
      parent: json['parent'],
      ragFile: decode(json['ragFile'], RagFile.fromJson),
      uploadRagFileConfig: decode(
        json['uploadRagFileConfig'],
        UploadRagFileConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (ragFile != null) 'ragFile': ragFile!.toJson(),
      if (uploadRagFileConfig != null)
        'uploadRagFileConfig': uploadRagFileConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'UploadRagFileRequest($contents)';
  }
}

/// Response message for
/// `VertexRagDataService.UploadRagFile`.
final class UploadRagFileResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UploadRagFileResponse';

  /// The RagFile that had been uploaded into the RagCorpus.
  final RagFile? ragFile;

  /// The error that occurred while processing the RagFile.
  final Status? error;

  UploadRagFileResponse({this.ragFile, this.error}) : super(fullyQualifiedName);

  factory UploadRagFileResponse.fromJson(Map<String, dynamic> json) {
    return UploadRagFileResponse(
      ragFile: decode(json['ragFile'], RagFile.fromJson),
      error: decode(json['error'], Status.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (ragFile != null) 'ragFile': ragFile!.toJson(),
      if (error != null) 'error': error!.toJson(),
    };
  }

  @override
  String toString() => 'UploadRagFileResponse()';
}

/// Request message for
/// `VertexRagDataService.ImportRagFiles`.
final class ImportRagFilesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportRagFilesRequest';

  /// Required. The name of the RagCorpus resource into which to import files.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String parent;

  /// Required. The config for the RagFiles to be synced and imported into the
  /// RagCorpus.
  /// `VertexRagDataService.ImportRagFiles`.
  final ImportRagFilesConfig? importRagFilesConfig;

  ImportRagFilesRequest({required this.parent, this.importRagFilesConfig})
    : super(fullyQualifiedName);

  factory ImportRagFilesRequest.fromJson(Map<String, dynamic> json) {
    return ImportRagFilesRequest(
      parent: json['parent'],
      importRagFilesConfig: decode(
        json['importRagFilesConfig'],
        ImportRagFilesConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (importRagFilesConfig != null)
        'importRagFilesConfig': importRagFilesConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ImportRagFilesRequest($contents)';
  }
}

/// Response message for
/// `VertexRagDataService.ImportRagFiles`.
final class ImportRagFilesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportRagFilesResponse';

  /// The Google Cloud Storage path into which the partial failures were
  /// written.
  final String? partialFailuresGcsPath;

  /// The BigQuery table into which the partial failures were written.
  final String? partialFailuresBigqueryTable;

  /// The number of RagFiles that had been imported into the RagCorpus.
  final int? importedRagFilesCount;

  /// The number of RagFiles that had failed while importing into the RagCorpus.
  final int? failedRagFilesCount;

  /// The number of RagFiles that was skipped while importing into the RagCorpus.
  final int? skippedRagFilesCount;

  ImportRagFilesResponse({
    this.partialFailuresGcsPath,
    this.partialFailuresBigqueryTable,
    this.importedRagFilesCount,
    this.failedRagFilesCount,
    this.skippedRagFilesCount,
  }) : super(fullyQualifiedName);

  factory ImportRagFilesResponse.fromJson(Map<String, dynamic> json) {
    return ImportRagFilesResponse(
      partialFailuresGcsPath: json['partialFailuresGcsPath'],
      partialFailuresBigqueryTable: json['partialFailuresBigqueryTable'],
      importedRagFilesCount: decodeInt64(json['importedRagFilesCount']),
      failedRagFilesCount: decodeInt64(json['failedRagFilesCount']),
      skippedRagFilesCount: decodeInt64(json['skippedRagFilesCount']),
    );
  }

  @override
  Object toJson() {
    return {
      if (partialFailuresGcsPath != null)
        'partialFailuresGcsPath': partialFailuresGcsPath,
      if (partialFailuresBigqueryTable != null)
        'partialFailuresBigqueryTable': partialFailuresBigqueryTable,
      if (importedRagFilesCount != null)
        'importedRagFilesCount': encodeInt64(importedRagFilesCount),
      if (failedRagFilesCount != null)
        'failedRagFilesCount': encodeInt64(failedRagFilesCount),
      if (skippedRagFilesCount != null)
        'skippedRagFilesCount': encodeInt64(skippedRagFilesCount),
    };
  }

  @override
  String toString() {
    final contents = [
      if (partialFailuresGcsPath != null)
        'partialFailuresGcsPath=$partialFailuresGcsPath',
      if (partialFailuresBigqueryTable != null)
        'partialFailuresBigqueryTable=$partialFailuresBigqueryTable',
      if (importedRagFilesCount != null)
        'importedRagFilesCount=$importedRagFilesCount',
      if (failedRagFilesCount != null)
        'failedRagFilesCount=$failedRagFilesCount',
      if (skippedRagFilesCount != null)
        'skippedRagFilesCount=$skippedRagFilesCount',
    ].join(',');
    return 'ImportRagFilesResponse($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.GetRagFile`
final class GetRagFileRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetRagFileRequest';

  /// Required. The name of the RagFile resource.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
  final String name;

  GetRagFileRequest({required this.name}) : super(fullyQualifiedName);

  factory GetRagFileRequest.fromJson(Map<String, dynamic> json) {
    return GetRagFileRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetRagFileRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.ListRagFiles`.
final class ListRagFilesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListRagFilesRequest';

  /// Required. The resource name of the RagCorpus from which to list the
  /// RagFiles. Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String parent;

  /// Optional. The standard list page size.
  final int? pageSize;

  /// Optional. The standard list page token.
  /// Typically obtained via
  /// `ListRagFilesResponse.next_page_token`
  /// of the previous
  /// `VertexRagDataService.ListRagFiles`
  /// call.
  final String? pageToken;

  ListRagFilesRequest({required this.parent, this.pageSize, this.pageToken})
    : super(fullyQualifiedName);

  factory ListRagFilesRequest.fromJson(Map<String, dynamic> json) {
    return ListRagFilesRequest(
      parent: json['parent'],
      pageSize: json['pageSize'],
      pageToken: json['pageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageSize != null) 'pageSize': pageSize,
      if (pageToken != null) 'pageToken': pageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageSize != null) 'pageSize=$pageSize',
      if (pageToken != null) 'pageToken=$pageToken',
    ].join(',');
    return 'ListRagFilesRequest($contents)';
  }
}

/// Response message for
/// `VertexRagDataService.ListRagFiles`.
final class ListRagFilesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListRagFilesResponse';

  /// List of RagFiles in the requested page.
  final List<RagFile>? ragFiles;

  /// A token to retrieve the next page of results.
  /// Pass to
  /// `ListRagFilesRequest.page_token`
  /// to obtain that page.
  final String? nextPageToken;

  ListRagFilesResponse({this.ragFiles, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListRagFilesResponse.fromJson(Map<String, dynamic> json) {
    return ListRagFilesResponse(
      ragFiles: decodeListMessage(json['ragFiles'], RagFile.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (ragFiles != null) 'ragFiles': encodeList(ragFiles),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListRagFilesResponse($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.DeleteRagFile`.
final class DeleteRagFileRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteRagFileRequest';

  /// Required. The name of the RagFile resource to be deleted.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}/ragFiles/{rag_file}`
  final String name;

  /// Optional. If set to true, any errors generated by external vector database
  /// during the deletion will be ignored. The default value is false.
  final bool? forceDelete;

  DeleteRagFileRequest({required this.name, this.forceDelete})
    : super(fullyQualifiedName);

  factory DeleteRagFileRequest.fromJson(Map<String, dynamic> json) {
    return DeleteRagFileRequest(
      name: json['name'],
      forceDelete: json['forceDelete'],
    );
  }

  @override
  Object toJson() {
    return {'name': name, if (forceDelete != null) 'forceDelete': forceDelete};
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (forceDelete != null) 'forceDelete=$forceDelete',
    ].join(',');
    return 'DeleteRagFileRequest($contents)';
  }
}

/// Runtime operation information for
/// `VertexRagDataService.CreateRagCorpus`.
final class CreateRagCorpusOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateRagCorpusOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  CreateRagCorpusOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory CreateRagCorpusOperationMetadata.fromJson(Map<String, dynamic> json) {
    return CreateRagCorpusOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'CreateRagCorpusOperationMetadata()';
}

/// Request message for
/// `VertexRagDataService.GetRagEngineConfig`
final class GetRagEngineConfigRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetRagEngineConfigRequest';

  /// Required. The name of the RagEngineConfig resource.
  /// Format:
  /// `projects/{project}/locations/{location}/ragEngineConfig`
  final String name;

  GetRagEngineConfigRequest({required this.name}) : super(fullyQualifiedName);

  factory GetRagEngineConfigRequest.fromJson(Map<String, dynamic> json) {
    return GetRagEngineConfigRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetRagEngineConfigRequest($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.UpdateRagCorpus`.
final class UpdateRagCorpusRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateRagCorpusRequest';

  /// Required. The RagCorpus which replaces the resource on the server.
  final RagCorpus ragCorpus;

  UpdateRagCorpusRequest({required this.ragCorpus}) : super(fullyQualifiedName);

  factory UpdateRagCorpusRequest.fromJson(Map<String, dynamic> json) {
    return UpdateRagCorpusRequest(
      ragCorpus: decode(json['ragCorpus'], RagCorpus.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'ragCorpus': ragCorpus.toJson()};
  }

  @override
  String toString() => 'UpdateRagCorpusRequest()';
}

/// Runtime operation information for
/// `VertexRagDataService.UpdateRagCorpus`.
final class UpdateRagCorpusOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateRagCorpusOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateRagCorpusOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateRagCorpusOperationMetadata.fromJson(Map<String, dynamic> json) {
    return UpdateRagCorpusOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateRagCorpusOperationMetadata()';
}

/// Runtime operation information for
/// `VertexRagDataService.ImportRagFiles`.
final class ImportRagFilesOperationMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ImportRagFilesOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  /// The resource ID of RagCorpus that this operation is executed on.
  final int? ragCorpusId;

  /// Output only. The config that was passed in the ImportRagFilesRequest.
  final ImportRagFilesConfig? importRagFilesConfig;

  /// The progress percentage of the operation. Value is in the range [0, 100].
  /// This percentage is calculated as follows:
  ///    progress_percentage = 100 * (successes + failures + skips) / total
  final int? progressPercentage;

  ImportRagFilesOperationMetadata({
    this.genericMetadata,
    this.ragCorpusId,
    this.importRagFilesConfig,
    this.progressPercentage,
  }) : super(fullyQualifiedName);

  factory ImportRagFilesOperationMetadata.fromJson(Map<String, dynamic> json) {
    return ImportRagFilesOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      ragCorpusId: decodeInt64(json['ragCorpusId']),
      importRagFilesConfig: decode(
        json['importRagFilesConfig'],
        ImportRagFilesConfig.fromJson,
      ),
      progressPercentage: json['progressPercentage'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (ragCorpusId != null) 'ragCorpusId': encodeInt64(ragCorpusId),
      if (importRagFilesConfig != null)
        'importRagFilesConfig': importRagFilesConfig!.toJson(),
      if (progressPercentage != null) 'progressPercentage': progressPercentage,
    };
  }

  @override
  String toString() {
    final contents = [
      if (ragCorpusId != null) 'ragCorpusId=$ragCorpusId',
      if (progressPercentage != null) 'progressPercentage=$progressPercentage',
    ].join(',');
    return 'ImportRagFilesOperationMetadata($contents)';
  }
}

/// Request message for
/// `VertexRagDataService.UpdateRagEngineConfig`.
final class UpdateRagEngineConfigRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateRagEngineConfigRequest';

  /// Required. The updated RagEngineConfig.
  ///
  /// NOTE: Downgrading your RagManagedDb's ComputeTier could temporarily
  /// increase request latencies until the operation is fully complete.
  final RagEngineConfig ragEngineConfig;

  UpdateRagEngineConfigRequest({required this.ragEngineConfig})
    : super(fullyQualifiedName);

  factory UpdateRagEngineConfigRequest.fromJson(Map<String, dynamic> json) {
    return UpdateRagEngineConfigRequest(
      ragEngineConfig: decode(
        json['ragEngineConfig'],
        RagEngineConfig.fromJson,
      )!,
    );
  }

  @override
  Object toJson() {
    return {'ragEngineConfig': ragEngineConfig.toJson()};
  }

  @override
  String toString() => 'UpdateRagEngineConfigRequest()';
}

/// Runtime operation information for
/// `VertexRagDataService.UpdateRagEngineConfig`.
final class UpdateRagEngineConfigOperationMetadata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.UpdateRagEngineConfigOperationMetadata';

  /// The operation generic information.
  final GenericOperationMetadata? genericMetadata;

  UpdateRagEngineConfigOperationMetadata({this.genericMetadata})
    : super(fullyQualifiedName);

  factory UpdateRagEngineConfigOperationMetadata.fromJson(
    Map<String, dynamic> json,
  ) {
    return UpdateRagEngineConfigOperationMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
    };
  }

  @override
  String toString() => 'UpdateRagEngineConfigOperationMetadata()';
}

/// A query to retrieve relevant contexts.
final class RagQuery extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagQuery';

  /// Optional. The query in text format to get relevant contexts.
  final String? text;

  /// Optional. The number of contexts to retrieve.
  final int? similarityTopK;

  /// Optional. Configurations for hybrid search results ranking.
  final RagQuery_Ranking? ranking;

  /// Optional. The retrieval config for the query.
  final RagRetrievalConfig? ragRetrievalConfig;

  RagQuery({
    this.text,
    this.similarityTopK,
    this.ranking,
    this.ragRetrievalConfig,
  }) : super(fullyQualifiedName);

  factory RagQuery.fromJson(Map<String, dynamic> json) {
    return RagQuery(
      text: json['text'],
      similarityTopK: json['similarityTopK'],
      ranking: decode(json['ranking'], RagQuery_Ranking.fromJson),
      ragRetrievalConfig: decode(
        json['ragRetrievalConfig'],
        RagRetrievalConfig.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      if (text != null) 'text': text,
      if (similarityTopK != null) 'similarityTopK': similarityTopK,
      if (ranking != null) 'ranking': ranking!.toJson(),
      if (ragRetrievalConfig != null)
        'ragRetrievalConfig': ragRetrievalConfig!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (text != null) 'text=$text',
      if (similarityTopK != null) 'similarityTopK=$similarityTopK',
    ].join(',');
    return 'RagQuery($contents)';
  }
}

/// Configurations for hybrid search results ranking.
final class RagQuery_Ranking extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagQuery.Ranking';

  /// Optional. Alpha value controls the weight between dense and sparse vector
  /// search results. The range is [0, 1], while 0 means sparse vector search
  /// only and 1 means dense vector search only. The default value is 0.5 which
  /// balances sparse and dense vector search equally.
  final double? alpha;

  RagQuery_Ranking({this.alpha}) : super(fullyQualifiedName);

  factory RagQuery_Ranking.fromJson(Map<String, dynamic> json) {
    return RagQuery_Ranking(alpha: decodeDouble(json['alpha']));
  }

  @override
  Object toJson() {
    return {if (alpha != null) 'alpha': encodeDouble(alpha)};
  }

  @override
  String toString() {
    final contents = [if (alpha != null) 'alpha=$alpha'].join(',');
    return 'Ranking($contents)';
  }
}

/// Request message for
/// `VertexRagService.RetrieveContexts`.
final class RetrieveContextsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveContextsRequest';

  /// The data source for Vertex RagStore.
  final RetrieveContextsRequest_VertexRagStore? vertexRagStore;

  /// Required. The resource name of the Location from which to retrieve
  /// RagContexts. The users must have permission to make a call in the project.
  /// Format:
  /// `projects/{project}/locations/{location}`.
  final String parent;

  /// Required. Single RAG retrieve query.
  final RagQuery? query;

  RetrieveContextsRequest({
    this.vertexRagStore,
    required this.parent,
    this.query,
  }) : super(fullyQualifiedName);

  factory RetrieveContextsRequest.fromJson(Map<String, dynamic> json) {
    return RetrieveContextsRequest(
      vertexRagStore: decode(
        json['vertexRagStore'],
        RetrieveContextsRequest_VertexRagStore.fromJson,
      ),
      parent: json['parent'],
      query: decode(json['query'], RagQuery.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!.toJson(),
      'parent': parent,
      if (query != null) 'query': query!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'RetrieveContextsRequest($contents)';
  }
}

/// The data source for Vertex RagStore.
final class RetrieveContextsRequest_VertexRagStore
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveContextsRequest.VertexRagStore';

  /// Optional. Deprecated. Please use rag_resources to specify the data
  /// source.
  final List<String>? ragCorpora;

  /// Optional. The representation of the rag source. It can be used to specify
  /// corpus only or ragfiles. Currently only support one corpus or multiple
  /// files from one corpus. In the future we may open up multiple corpora
  /// support.
  final List<RetrieveContextsRequest_VertexRagStore_RagResource>? ragResources;

  /// Optional. Only return contexts with vector distance smaller than the
  /// threshold.
  final double? vectorDistanceThreshold;

  RetrieveContextsRequest_VertexRagStore({
    this.ragCorpora,
    this.ragResources,
    this.vectorDistanceThreshold,
  }) : super(fullyQualifiedName);

  factory RetrieveContextsRequest_VertexRagStore.fromJson(
    Map<String, dynamic> json,
  ) {
    return RetrieveContextsRequest_VertexRagStore(
      ragCorpora: decodeList(json['ragCorpora']),
      ragResources: decodeListMessage(
        json['ragResources'],
        RetrieveContextsRequest_VertexRagStore_RagResource.fromJson,
      ),
      vectorDistanceThreshold: decodeDouble(json['vectorDistanceThreshold']),
    );
  }

  @override
  Object toJson() {
    return {
      if (ragCorpora != null) 'ragCorpora': ragCorpora,
      if (ragResources != null) 'ragResources': encodeList(ragResources),
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold': encodeDouble(vectorDistanceThreshold),
    };
  }

  @override
  String toString() {
    final contents = [
      if (vectorDistanceThreshold != null)
        'vectorDistanceThreshold=$vectorDistanceThreshold',
    ].join(',');
    return 'VertexRagStore($contents)';
  }
}

/// The definition of the Rag resource.
final class RetrieveContextsRequest_VertexRagStore_RagResource
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveContextsRequest.VertexRagStore.RagResource';

  /// Optional. RagCorpora resource name.
  /// Format:
  /// `projects/{project}/locations/{location}/ragCorpora/{rag_corpus}`
  final String? ragCorpus;

  /// Optional. rag_file_id. The files should be in the same rag_corpus set
  /// in rag_corpus field.
  final List<String>? ragFileIds;

  RetrieveContextsRequest_VertexRagStore_RagResource({
    this.ragCorpus,
    this.ragFileIds,
  }) : super(fullyQualifiedName);

  factory RetrieveContextsRequest_VertexRagStore_RagResource.fromJson(
    Map<String, dynamic> json,
  ) {
    return RetrieveContextsRequest_VertexRagStore_RagResource(
      ragCorpus: json['ragCorpus'],
      ragFileIds: decodeList(json['ragFileIds']),
    );
  }

  @override
  Object toJson() {
    return {
      if (ragCorpus != null) 'ragCorpus': ragCorpus,
      if (ragFileIds != null) 'ragFileIds': ragFileIds,
    };
  }

  @override
  String toString() {
    final contents = [if (ragCorpus != null) 'ragCorpus=$ragCorpus'].join(',');
    return 'RagResource($contents)';
  }
}

/// Relevant contexts for one query.
final class RagContexts extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagContexts';

  /// All its contexts.
  final List<RagContexts_Context>? contexts;

  RagContexts({this.contexts}) : super(fullyQualifiedName);

  factory RagContexts.fromJson(Map<String, dynamic> json) {
    return RagContexts(
      contexts: decodeListMessage(
        json['contexts'],
        RagContexts_Context.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {if (contexts != null) 'contexts': encodeList(contexts)};
  }

  @override
  String toString() => 'RagContexts()';
}

/// A context of the query.
final class RagContexts_Context extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RagContexts.Context';

  /// If the file is imported from Cloud Storage or Google Drive, source_uri
  /// will be original file URI in Cloud Storage or Google Drive; if file is
  /// uploaded, source_uri will be file display name.
  final String? sourceUri;

  /// The file display name.
  final String? sourceDisplayName;

  /// The text chunk.
  final String? text;

  /// The distance between the query dense embedding vector and the context
  /// text vector.
  final double? distance;

  /// The distance between the query sparse embedding vector and the context
  /// text vector.
  final double? sparseDistance;

  /// According to the underlying Vector DB and the selected metric type, the
  /// score can be either the distance or the similarity between the query and
  /// the context and its range depends on the metric type.
  ///
  /// For example, if the metric type is COSINE_DISTANCE, it represents the
  /// distance between the query and the context. The larger the distance, the
  /// less relevant the context is to the query. The range is [0, 2], while 0
  /// means the most relevant and 2 means the least relevant.
  final double? score;

  /// Context of the retrieved chunk.
  final RagChunk? chunk;

  RagContexts_Context({
    this.sourceUri,
    this.sourceDisplayName,
    this.text,
    this.distance,
    this.sparseDistance,
    this.score,
    this.chunk,
  }) : super(fullyQualifiedName);

  factory RagContexts_Context.fromJson(Map<String, dynamic> json) {
    return RagContexts_Context(
      sourceUri: json['sourceUri'],
      sourceDisplayName: json['sourceDisplayName'],
      text: json['text'],
      distance: decodeDouble(json['distance']),
      sparseDistance: decodeDouble(json['sparseDistance']),
      score: decodeDouble(json['score']),
      chunk: decode(json['chunk'], RagChunk.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (sourceUri != null) 'sourceUri': sourceUri,
      if (sourceDisplayName != null) 'sourceDisplayName': sourceDisplayName,
      if (text != null) 'text': text,
      if (distance != null) 'distance': encodeDouble(distance),
      if (sparseDistance != null)
        'sparseDistance': encodeDouble(sparseDistance),
      if (score != null) 'score': encodeDouble(score),
      if (chunk != null) 'chunk': chunk!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (sourceUri != null) 'sourceUri=$sourceUri',
      if (sourceDisplayName != null) 'sourceDisplayName=$sourceDisplayName',
      if (text != null) 'text=$text',
      if (distance != null) 'distance=$distance',
      if (sparseDistance != null) 'sparseDistance=$sparseDistance',
      if (score != null) 'score=$score',
    ].join(',');
    return 'Context($contents)';
  }
}

/// Response message for
/// `VertexRagService.RetrieveContexts`.
final class RetrieveContextsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.RetrieveContextsResponse';

  /// The contexts of the query.
  final RagContexts? contexts;

  RetrieveContextsResponse({this.contexts}) : super(fullyQualifiedName);

  factory RetrieveContextsResponse.fromJson(Map<String, dynamic> json) {
    return RetrieveContextsResponse(
      contexts: decode(json['contexts'], RagContexts.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (contexts != null) 'contexts': contexts!.toJson()};
  }

  @override
  String toString() => 'RetrieveContextsResponse()';
}

/// Request message for AugmentPrompt.
final class AugmentPromptRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AugmentPromptRequest';

  /// Optional. Retrieves contexts from the Vertex RagStore.
  final VertexRagStore? vertexRagStore;

  /// Required. The resource name of the Location from which to augment prompt.
  /// The users must have permission to make a call in the project.
  /// Format:
  /// `projects/{project}/locations/{location}`.
  final String parent;

  /// Optional. Input content to augment, only text format is supported for now.
  final List<Content>? contents;

  /// Optional. Metadata of the backend deployed model.
  final AugmentPromptRequest_Model? model;

  AugmentPromptRequest({
    this.vertexRagStore,
    required this.parent,
    this.contents,
    this.model,
  }) : super(fullyQualifiedName);

  factory AugmentPromptRequest.fromJson(Map<String, dynamic> json) {
    return AugmentPromptRequest(
      vertexRagStore: decode(json['vertexRagStore'], VertexRagStore.fromJson),
      parent: json['parent'],
      contents: decodeListMessage(json['contents'], Content.fromJson),
      model: decode(json['model'], AugmentPromptRequest_Model.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (vertexRagStore != null) 'vertexRagStore': vertexRagStore!.toJson(),
      'parent': parent,
      if (contents != null) 'contents': encodeList(contents),
      if (model != null) 'model': model!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'AugmentPromptRequest($contents)';
  }
}

/// Metadata of the backend deployed model.
final class AugmentPromptRequest_Model extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AugmentPromptRequest.Model';

  /// Optional. The model that the user will send the augmented prompt for
  /// content generation.
  final String? model;

  /// Optional. The model version of the backend deployed model.
  final String? modelVersion;

  AugmentPromptRequest_Model({this.model, this.modelVersion})
    : super(fullyQualifiedName);

  factory AugmentPromptRequest_Model.fromJson(Map<String, dynamic> json) {
    return AugmentPromptRequest_Model(
      model: json['model'],
      modelVersion: json['modelVersion'],
    );
  }

  @override
  Object toJson() {
    return {
      if (model != null) 'model': model,
      if (modelVersion != null) 'modelVersion': modelVersion,
    };
  }

  @override
  String toString() {
    final contents = [
      if (model != null) 'model=$model',
      if (modelVersion != null) 'modelVersion=$modelVersion',
    ].join(',');
    return 'Model($contents)';
  }
}

/// Response message for AugmentPrompt.
final class AugmentPromptResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AugmentPromptResponse';

  /// Augmented prompt, only text format is supported for now.
  final List<Content>? augmentedPrompt;

  /// Retrieved facts from RAG data sources.
  final List<Fact>? facts;

  AugmentPromptResponse({this.augmentedPrompt, this.facts})
    : super(fullyQualifiedName);

  factory AugmentPromptResponse.fromJson(Map<String, dynamic> json) {
    return AugmentPromptResponse(
      augmentedPrompt: decodeListMessage(
        json['augmentedPrompt'],
        Content.fromJson,
      ),
      facts: decodeListMessage(json['facts'], Fact.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (augmentedPrompt != null)
        'augmentedPrompt': encodeList(augmentedPrompt),
      if (facts != null) 'facts': encodeList(facts),
    };
  }

  @override
  String toString() => 'AugmentPromptResponse()';
}

/// Request message for CorroborateContent.
final class CorroborateContentRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CorroborateContentRequest';

  /// Required. The resource name of the Location from which to corroborate text.
  /// The users must have permission to make a call in the project.
  /// Format:
  /// `projects/{project}/locations/{location}`.
  final String parent;

  /// Optional. Input content to corroborate, only text format is supported for
  /// now.
  final Content? content;

  /// Optional. Facts used to generate the text can also be used to corroborate
  /// the text.
  final List<Fact>? facts;

  /// Optional. Parameters that can be set to override default settings per
  /// request.
  final CorroborateContentRequest_Parameters? parameters;

  CorroborateContentRequest({
    required this.parent,
    this.content,
    this.facts,
    this.parameters,
  }) : super(fullyQualifiedName);

  factory CorroborateContentRequest.fromJson(Map<String, dynamic> json) {
    return CorroborateContentRequest(
      parent: json['parent'],
      content: decode(json['content'], Content.fromJson),
      facts: decodeListMessage(json['facts'], Fact.fromJson),
      parameters: decode(
        json['parameters'],
        CorroborateContentRequest_Parameters.fromJson,
      ),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (content != null) 'content': content!.toJson(),
      if (facts != null) 'facts': encodeList(facts),
      if (parameters != null) 'parameters': parameters!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CorroborateContentRequest($contents)';
  }
}

/// Parameters that can be overrided per request.
final class CorroborateContentRequest_Parameters extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CorroborateContentRequest.Parameters';

  /// Optional. Only return claims with citation score larger than the
  /// threshold.
  final double? citationThreshold;

  CorroborateContentRequest_Parameters({this.citationThreshold})
    : super(fullyQualifiedName);

  factory CorroborateContentRequest_Parameters.fromJson(
    Map<String, dynamic> json,
  ) {
    return CorroborateContentRequest_Parameters(
      citationThreshold: decodeDouble(json['citationThreshold']),
    );
  }

  @override
  Object toJson() {
    return {
      if (citationThreshold != null)
        'citationThreshold': encodeDouble(citationThreshold),
    };
  }

  @override
  String toString() {
    final contents = [
      if (citationThreshold != null) 'citationThreshold=$citationThreshold',
    ].join(',');
    return 'Parameters($contents)';
  }
}

/// Response message for CorroborateContent.
final class CorroborateContentResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CorroborateContentResponse';

  /// Confidence score of corroborating content. Value is [0,1] with 1 is the
  /// most confidence.
  final double? corroborationScore;

  /// Claims that are extracted from the input content and facts that support the
  /// claims.
  final List<Claim>? claims;

  CorroborateContentResponse({this.corroborationScore, this.claims})
    : super(fullyQualifiedName);

  factory CorroborateContentResponse.fromJson(Map<String, dynamic> json) {
    return CorroborateContentResponse(
      corroborationScore: decodeDouble(json['corroborationScore']),
      claims: decodeListMessage(json['claims'], Claim.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (corroborationScore != null)
        'corroborationScore': encodeDouble(corroborationScore),
      if (claims != null) 'claims': encodeList(claims),
    };
  }

  @override
  String toString() {
    final contents = [
      if (corroborationScore != null) 'corroborationScore=$corroborationScore',
    ].join(',');
    return 'CorroborateContentResponse($contents)';
  }
}

/// The fact used in grounding.
final class Fact extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Fact';

  /// Query that is used to retrieve this fact.
  final String? query;

  /// If present, it refers to the title of this fact.
  final String? title;

  /// If present, this uri links to the source of the fact.
  final String? uri;

  /// If present, the summary/snippet of the fact.
  final String? summary;

  /// If present, the distance between the query vector and this fact vector.
  final double? vectorDistance;

  /// If present, according to the underlying Vector DB and the selected metric
  /// type, the score can be either the distance or the similarity between the
  /// query and the fact and its range depends on the metric type.
  ///
  /// For example, if the metric type is COSINE_DISTANCE, it represents the
  /// distance between the query and the fact. The larger the distance, the less
  /// relevant the fact is to the query. The range is [0, 2], while 0 means the
  /// most relevant and 2 means the least relevant.
  final double? score;

  /// If present, chunk properties.
  final RagChunk? chunk;

  Fact({
    this.query,
    this.title,
    this.uri,
    this.summary,
    this.vectorDistance,
    this.score,
    this.chunk,
  }) : super(fullyQualifiedName);

  factory Fact.fromJson(Map<String, dynamic> json) {
    return Fact(
      query: json['query'],
      title: json['title'],
      uri: json['uri'],
      summary: json['summary'],
      vectorDistance: decodeDouble(json['vectorDistance']),
      score: decodeDouble(json['score']),
      chunk: decode(json['chunk'], RagChunk.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (query != null) 'query': query,
      if (title != null) 'title': title,
      if (uri != null) 'uri': uri,
      if (summary != null) 'summary': summary,
      if (vectorDistance != null)
        'vectorDistance': encodeDouble(vectorDistance),
      if (score != null) 'score': encodeDouble(score),
      if (chunk != null) 'chunk': chunk!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (query != null) 'query=$query',
      if (title != null) 'title=$title',
      if (uri != null) 'uri=$uri',
      if (summary != null) 'summary=$summary',
      if (vectorDistance != null) 'vectorDistance=$vectorDistance',
      if (score != null) 'score=$score',
    ].join(',');
    return 'Fact($contents)';
  }
}

/// Claim that is extracted from the input text and facts that support it.
final class Claim extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.Claim';

  /// Index in the input text where the claim starts (inclusive).
  final int? startIndex;

  /// Index in the input text where the claim ends (exclusive).
  final int? endIndex;

  /// Indexes of the facts supporting this claim.
  final List<int>? factIndexes;

  /// Confidence score of this corroboration.
  final double? score;

  Claim({this.startIndex, this.endIndex, this.factIndexes, this.score})
    : super(fullyQualifiedName);

  factory Claim.fromJson(Map<String, dynamic> json) {
    return Claim(
      startIndex: json['startIndex'],
      endIndex: json['endIndex'],
      factIndexes: decodeList(json['factIndexes']),
      score: decodeDouble(json['score']),
    );
  }

  @override
  Object toJson() {
    return {
      if (startIndex != null) 'startIndex': startIndex,
      if (endIndex != null) 'endIndex': endIndex,
      if (factIndexes != null) 'factIndexes': factIndexes,
      if (score != null) 'score': encodeDouble(score),
    };
  }

  @override
  String toString() {
    final contents = [
      if (startIndex != null) 'startIndex=$startIndex',
      if (endIndex != null) 'endIndex=$endIndex',
      if (score != null) 'score=$score',
    ].join(',');
    return 'Claim($contents)';
  }
}

/// Request message for
/// `VizierService.GetStudy`.
final class GetStudyRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetStudyRequest';

  /// Required. The name of the Study resource.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String name;

  GetStudyRequest({required this.name}) : super(fullyQualifiedName);

  factory GetStudyRequest.fromJson(Map<String, dynamic> json) {
    return GetStudyRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetStudyRequest($contents)';
  }
}

/// Request message for
/// `VizierService.CreateStudy`.
final class CreateStudyRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateStudyRequest';

  /// Required. The resource name of the Location to create the CustomJob in.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The Study configuration used to create the Study.
  final Study study;

  CreateStudyRequest({required this.parent, required this.study})
    : super(fullyQualifiedName);

  factory CreateStudyRequest.fromJson(Map<String, dynamic> json) {
    return CreateStudyRequest(
      parent: json['parent'],
      study: decode(json['study'], Study.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'study': study.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateStudyRequest($contents)';
  }
}

/// Request message for
/// `VizierService.ListStudies`.
final class ListStudiesRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListStudiesRequest';

  /// Required. The resource name of the Location to list the Study from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  final String? pageToken;

  /// Optional. The maximum number of studies to return per "page" of results.
  /// If unspecified, service will pick an appropriate default.
  final int? pageSize;

  ListStudiesRequest({required this.parent, this.pageToken, this.pageSize})
    : super(fullyQualifiedName);

  factory ListStudiesRequest.fromJson(Map<String, dynamic> json) {
    return ListStudiesRequest(
      parent: json['parent'],
      pageToken: json['pageToken'],
      pageSize: json['pageSize'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageToken != null) 'pageToken': pageToken,
      if (pageSize != null) 'pageSize': pageSize,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageToken != null) 'pageToken=$pageToken',
      if (pageSize != null) 'pageSize=$pageSize',
    ].join(',');
    return 'ListStudiesRequest($contents)';
  }
}

/// Response message for
/// `VizierService.ListStudies`.
final class ListStudiesResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListStudiesResponse';

  /// The studies associated with the project.
  final List<Study>? studies;

  /// Passes this token as the `page_token` field of the request for a
  /// subsequent call.
  /// If this field is omitted, there are no subsequent pages.
  final String? nextPageToken;

  ListStudiesResponse({this.studies, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListStudiesResponse.fromJson(Map<String, dynamic> json) {
    return ListStudiesResponse(
      studies: decodeListMessage(json['studies'], Study.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (studies != null) 'studies': encodeList(studies),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListStudiesResponse($contents)';
  }
}

/// Request message for
/// `VizierService.DeleteStudy`.
final class DeleteStudyRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteStudyRequest';

  /// Required. The name of the Study resource to be deleted.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String name;

  DeleteStudyRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteStudyRequest.fromJson(Map<String, dynamic> json) {
    return DeleteStudyRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteStudyRequest($contents)';
  }
}

/// Request message for
/// `VizierService.LookupStudy`.
final class LookupStudyRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.LookupStudyRequest';

  /// Required. The resource name of the Location to get the Study from.
  /// Format: `projects/{project}/locations/{location}`
  final String parent;

  /// Required. The user-defined display name of the Study
  final String? displayName;

  LookupStudyRequest({required this.parent, this.displayName})
    : super(fullyQualifiedName);

  factory LookupStudyRequest.fromJson(Map<String, dynamic> json) {
    return LookupStudyRequest(
      parent: json['parent'],
      displayName: json['displayName'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (displayName != null) 'displayName': displayName,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (displayName != null) 'displayName=$displayName',
    ].join(',');
    return 'LookupStudyRequest($contents)';
  }
}

/// Request message for
/// `VizierService.SuggestTrials`.
final class SuggestTrialsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SuggestTrialsRequest';

  /// Required. The project and location that the Study belongs to.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String parent;

  /// Required. The number of suggestions requested. It must be positive.
  final int? suggestionCount;

  /// Required. The identifier of the client that is requesting the suggestion.
  ///
  /// If multiple SuggestTrialsRequests have the same `client_id`,
  /// the service will return the identical suggested Trial if the Trial is
  /// pending, and provide a new Trial if the last suggested Trial was completed.
  final String? clientId;

  /// Optional. This allows you to specify the "context" for a Trial; a context
  /// is a slice (a subspace) of the search space.
  ///
  /// Typical uses for contexts:
  /// 1) You are using Vizier to tune a server for best performance, but there's
  ///   a strong weekly cycle.  The context specifies the day-of-week.
  ///   This allows Tuesday to generalize from Wednesday without assuming that
  ///   everything is identical.
  /// 2) Imagine you're optimizing some medical treatment for people.
  ///   As they walk in the door, you know certain facts about them
  ///   (e.g. sex, weight, height, blood-pressure).  Put that information in the
  ///   context, and Vizier will adapt its suggestions to the patient.
  /// 3) You want to do a fair A/B test efficiently.  Specify the "A" and "B"
  ///   conditions as contexts, and Vizier will generalize between "A" and "B"
  ///   conditions.  If they are similar, this will allow Vizier to converge
  ///   to the optimum faster than if "A" and "B" were separate Studies.
  ///   NOTE: You can also enter contexts as REQUESTED Trials, e.g. via the
  ///   CreateTrial() RPC; that's the asynchronous option where you don't need a
  ///   close association between contexts and suggestions.
  ///
  /// NOTE: All the Parameters you set in a context MUST be defined in the
  ///   Study.
  /// NOTE: You must supply 0 or $suggestion_count contexts.
  ///   If you don't supply any contexts, Vizier will make suggestions
  ///   from the full search space specified in the StudySpec; if you supply
  ///   a full set of context, each suggestion will match the corresponding
  ///   context.
  /// NOTE: A Context with no features set matches anything, and allows
  ///   suggestions from the full search space.
  /// NOTE: Contexts MUST lie within the search space specified in the
  ///   StudySpec.  It's an error if they don't.
  /// NOTE: Contexts preferentially match ACTIVE then REQUESTED trials before
  ///   new suggestions are generated.
  /// NOTE: Generation of suggestions involves a match between a Context and
  ///   (optionally) a REQUESTED trial; if that match is not fully specified, a
  ///   suggestion will be geneated in the merged subspace.
  final List<TrialContext>? contexts;

  SuggestTrialsRequest({
    required this.parent,
    this.suggestionCount,
    this.clientId,
    this.contexts,
  }) : super(fullyQualifiedName);

  factory SuggestTrialsRequest.fromJson(Map<String, dynamic> json) {
    return SuggestTrialsRequest(
      parent: json['parent'],
      suggestionCount: json['suggestionCount'],
      clientId: json['clientId'],
      contexts: decodeListMessage(json['contexts'], TrialContext.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (suggestionCount != null) 'suggestionCount': suggestionCount,
      if (clientId != null) 'clientId': clientId,
      if (contexts != null) 'contexts': encodeList(contexts),
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (suggestionCount != null) 'suggestionCount=$suggestionCount',
      if (clientId != null) 'clientId=$clientId',
    ].join(',');
    return 'SuggestTrialsRequest($contents)';
  }
}

/// Response message for
/// `VizierService.SuggestTrials`.
final class SuggestTrialsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SuggestTrialsResponse';

  /// A list of Trials.
  final List<Trial>? trials;

  /// The state of the Study.
  final Study_State? studyState;

  /// The time at which the operation was started.
  final protobuf.Timestamp? startTime;

  /// The time at which operation processing completed.
  final protobuf.Timestamp? endTime;

  SuggestTrialsResponse({
    this.trials,
    this.studyState,
    this.startTime,
    this.endTime,
  }) : super(fullyQualifiedName);

  factory SuggestTrialsResponse.fromJson(Map<String, dynamic> json) {
    return SuggestTrialsResponse(
      trials: decodeListMessage(json['trials'], Trial.fromJson),
      studyState: decodeEnum(json['studyState'], Study_State.fromJson),
      startTime: decodeCustom(json['startTime'], protobuf.Timestamp.fromJson),
      endTime: decodeCustom(json['endTime'], protobuf.Timestamp.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (trials != null) 'trials': encodeList(trials),
      if (studyState != null) 'studyState': studyState!.toJson(),
      if (startTime != null) 'startTime': startTime!.toJson(),
      if (endTime != null) 'endTime': endTime!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = [
      if (studyState != null) 'studyState=$studyState',
    ].join(',');
    return 'SuggestTrialsResponse($contents)';
  }
}

/// Details of operations that perform Trials suggestion.
final class SuggestTrialsMetadata extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.SuggestTrialsMetadata';

  /// Operation metadata for suggesting Trials.
  final GenericOperationMetadata? genericMetadata;

  /// The identifier of the client that is requesting the suggestion.
  ///
  /// If multiple SuggestTrialsRequests have the same `client_id`,
  /// the service will return the identical suggested Trial if the Trial is
  /// pending, and provide a new Trial if the last suggested Trial was completed.
  final String? clientId;

  SuggestTrialsMetadata({this.genericMetadata, this.clientId})
    : super(fullyQualifiedName);

  factory SuggestTrialsMetadata.fromJson(Map<String, dynamic> json) {
    return SuggestTrialsMetadata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      clientId: json['clientId'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (clientId != null) 'clientId': clientId,
    };
  }

  @override
  String toString() {
    final contents = [if (clientId != null) 'clientId=$clientId'].join(',');
    return 'SuggestTrialsMetadata($contents)';
  }
}

/// Request message for
/// `VizierService.CreateTrial`.
final class CreateTrialRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CreateTrialRequest';

  /// Required. The resource name of the Study to create the Trial in.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String parent;

  /// Required. The Trial to create.
  final Trial trial;

  CreateTrialRequest({required this.parent, required this.trial})
    : super(fullyQualifiedName);

  factory CreateTrialRequest.fromJson(Map<String, dynamic> json) {
    return CreateTrialRequest(
      parent: json['parent'],
      trial: decode(json['trial'], Trial.fromJson)!,
    );
  }

  @override
  Object toJson() {
    return {'parent': parent, 'trial': trial.toJson()};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.GetTrial`.
final class GetTrialRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.GetTrialRequest';

  /// Required. The name of the Trial resource.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String name;

  GetTrialRequest({required this.name}) : super(fullyQualifiedName);

  factory GetTrialRequest.fromJson(Map<String, dynamic> json) {
    return GetTrialRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.ListTrials`.
final class ListTrialsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTrialsRequest';

  /// Required. The resource name of the Study to list the Trial from.
  /// Format: `projects/{project}/locations/{location}/studies/{study}`
  final String parent;

  /// Optional. A page token to request the next page of results.
  /// If unspecified, there are no subsequent pages.
  final String? pageToken;

  /// Optional. The number of Trials to retrieve per "page" of results.
  /// If unspecified, the service will pick an appropriate default.
  final int? pageSize;

  ListTrialsRequest({required this.parent, this.pageToken, this.pageSize})
    : super(fullyQualifiedName);

  factory ListTrialsRequest.fromJson(Map<String, dynamic> json) {
    return ListTrialsRequest(
      parent: json['parent'],
      pageToken: json['pageToken'],
      pageSize: json['pageSize'],
    );
  }

  @override
  Object toJson() {
    return {
      'parent': parent,
      if (pageToken != null) 'pageToken': pageToken,
      if (pageSize != null) 'pageSize': pageSize,
    };
  }

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      if (pageToken != null) 'pageToken=$pageToken',
      if (pageSize != null) 'pageSize=$pageSize',
    ].join(',');
    return 'ListTrialsRequest($contents)';
  }
}

/// Response message for
/// `VizierService.ListTrials`.
final class ListTrialsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListTrialsResponse';

  /// The Trials associated with the Study.
  final List<Trial>? trials;

  /// Pass this token as the `page_token` field of the request for a
  /// subsequent call.
  /// If this field is omitted, there are no subsequent pages.
  final String? nextPageToken;

  ListTrialsResponse({this.trials, this.nextPageToken})
    : super(fullyQualifiedName);

  factory ListTrialsResponse.fromJson(Map<String, dynamic> json) {
    return ListTrialsResponse(
      trials: decodeListMessage(json['trials'], Trial.fromJson),
      nextPageToken: json['nextPageToken'],
    );
  }

  @override
  Object toJson() {
    return {
      if (trials != null) 'trials': encodeList(trials),
      if (nextPageToken != null) 'nextPageToken': nextPageToken,
    };
  }

  @override
  String toString() {
    final contents = [
      if (nextPageToken != null) 'nextPageToken=$nextPageToken',
    ].join(',');
    return 'ListTrialsResponse($contents)';
  }
}

/// Request message for
/// `VizierService.AddTrialMeasurement`.
final class AddTrialMeasurementRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.AddTrialMeasurementRequest';

  /// Required. The name of the trial to add measurement.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String trialName;

  /// Required. The measurement to be added to a Trial.
  final Measurement? measurement;

  AddTrialMeasurementRequest({required this.trialName, this.measurement})
    : super(fullyQualifiedName);

  factory AddTrialMeasurementRequest.fromJson(Map<String, dynamic> json) {
    return AddTrialMeasurementRequest(
      trialName: json['trialName'],
      measurement: decode(json['measurement'], Measurement.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      'trialName': trialName,
      if (measurement != null) 'measurement': measurement!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['trialName=$trialName'].join(',');
    return 'AddTrialMeasurementRequest($contents)';
  }
}

/// Request message for
/// `VizierService.CompleteTrial`.
final class CompleteTrialRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CompleteTrialRequest';

  /// Required. The Trial's name.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String name;

  /// Optional. If provided, it will be used as the completed Trial's
  /// final_measurement; Otherwise, the service will auto-select a
  /// previously reported measurement as the final-measurement
  final Measurement? finalMeasurement;

  /// Optional. True if the Trial cannot be run with the given Parameter, and
  /// final_measurement will be ignored.
  final bool? trialInfeasible;

  /// Optional. A human readable reason why the trial was infeasible. This should
  /// only be provided if `trial_infeasible` is true.
  final String? infeasibleReason;

  CompleteTrialRequest({
    required this.name,
    this.finalMeasurement,
    this.trialInfeasible,
    this.infeasibleReason,
  }) : super(fullyQualifiedName);

  factory CompleteTrialRequest.fromJson(Map<String, dynamic> json) {
    return CompleteTrialRequest(
      name: json['name'],
      finalMeasurement: decode(json['finalMeasurement'], Measurement.fromJson),
      trialInfeasible: json['trialInfeasible'],
      infeasibleReason: json['infeasibleReason'],
    );
  }

  @override
  Object toJson() {
    return {
      'name': name,
      if (finalMeasurement != null)
        'finalMeasurement': finalMeasurement!.toJson(),
      if (trialInfeasible != null) 'trialInfeasible': trialInfeasible,
      if (infeasibleReason != null) 'infeasibleReason': infeasibleReason,
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      if (trialInfeasible != null) 'trialInfeasible=$trialInfeasible',
      if (infeasibleReason != null) 'infeasibleReason=$infeasibleReason',
    ].join(',');
    return 'CompleteTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.DeleteTrial`.
final class DeleteTrialRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.DeleteTrialRequest';

  /// Required. The Trial's name.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String name;

  DeleteTrialRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteTrialRequest.fromJson(Map<String, dynamic> json) {
    return DeleteTrialRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.CheckTrialEarlyStoppingState`.
final class CheckTrialEarlyStoppingStateRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CheckTrialEarlyStoppingStateRequest';

  /// Required. The Trial's name.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String trialName;

  CheckTrialEarlyStoppingStateRequest({required this.trialName})
    : super(fullyQualifiedName);

  factory CheckTrialEarlyStoppingStateRequest.fromJson(
    Map<String, dynamic> json,
  ) {
    return CheckTrialEarlyStoppingStateRequest(trialName: json['trialName']);
  }

  @override
  Object toJson() {
    return {'trialName': trialName};
  }

  @override
  String toString() {
    final contents = ['trialName=$trialName'].join(',');
    return 'CheckTrialEarlyStoppingStateRequest($contents)';
  }
}

/// Response message for
/// `VizierService.CheckTrialEarlyStoppingState`.
final class CheckTrialEarlyStoppingStateResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CheckTrialEarlyStoppingStateResponse';

  /// True if the Trial should stop.
  final bool? shouldStop;

  CheckTrialEarlyStoppingStateResponse({this.shouldStop})
    : super(fullyQualifiedName);

  factory CheckTrialEarlyStoppingStateResponse.fromJson(
    Map<String, dynamic> json,
  ) {
    return CheckTrialEarlyStoppingStateResponse(shouldStop: json['shouldStop']);
  }

  @override
  Object toJson() {
    return {if (shouldStop != null) 'shouldStop': shouldStop};
  }

  @override
  String toString() {
    final contents = [
      if (shouldStop != null) 'shouldStop=$shouldStop',
    ].join(',');
    return 'CheckTrialEarlyStoppingStateResponse($contents)';
  }
}

/// This message will be placed in the metadata field of a
/// google.longrunning.Operation associated with a CheckTrialEarlyStoppingState
/// request.
final class CheckTrialEarlyStoppingStateMetatdata
    extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.CheckTrialEarlyStoppingStateMetatdata';

  /// Operation metadata for suggesting Trials.
  final GenericOperationMetadata? genericMetadata;

  /// The name of the Study that the Trial belongs to.
  final String? study;

  /// The Trial name.
  final String? trial;

  CheckTrialEarlyStoppingStateMetatdata({
    this.genericMetadata,
    this.study,
    this.trial,
  }) : super(fullyQualifiedName);

  factory CheckTrialEarlyStoppingStateMetatdata.fromJson(
    Map<String, dynamic> json,
  ) {
    return CheckTrialEarlyStoppingStateMetatdata(
      genericMetadata: decode(
        json['genericMetadata'],
        GenericOperationMetadata.fromJson,
      ),
      study: json['study'],
      trial: json['trial'],
    );
  }

  @override
  Object toJson() {
    return {
      if (genericMetadata != null) 'genericMetadata': genericMetadata!.toJson(),
      if (study != null) 'study': study,
      if (trial != null) 'trial': trial,
    };
  }

  @override
  String toString() {
    final contents = [
      if (study != null) 'study=$study',
      if (trial != null) 'trial=$trial',
    ].join(',');
    return 'CheckTrialEarlyStoppingStateMetatdata($contents)';
  }
}

/// Request message for
/// `VizierService.StopTrial`.
final class StopTrialRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.StopTrialRequest';

  /// Required. The Trial's name.
  /// Format:
  /// `projects/{project}/locations/{location}/studies/{study}/trials/{trial}`
  final String name;

  StopTrialRequest({required this.name}) : super(fullyQualifiedName);

  factory StopTrialRequest.fromJson(Map<String, dynamic> json) {
    return StopTrialRequest(name: json['name']);
  }

  @override
  Object toJson() {
    return {'name': name};
  }

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StopTrialRequest($contents)';
  }
}

/// Request message for
/// `VizierService.ListOptimalTrials`.
final class ListOptimalTrialsRequest extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListOptimalTrialsRequest';

  /// Required. The name of the Study that the optimal Trial belongs to.
  final String parent;

  ListOptimalTrialsRequest({required this.parent}) : super(fullyQualifiedName);

  factory ListOptimalTrialsRequest.fromJson(Map<String, dynamic> json) {
    return ListOptimalTrialsRequest(parent: json['parent']);
  }

  @override
  Object toJson() {
    return {'parent': parent};
  }

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ListOptimalTrialsRequest($contents)';
  }
}

/// Response message for
/// `VizierService.ListOptimalTrials`.
final class ListOptimalTrialsResponse extends protobuf.ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.aiplatform.v1beta1.ListOptimalTrialsResponse';

  /// The pareto-optimal Trials for multiple objective Study or the
  /// optimal trial for single objective Study. The definition of
  /// pareto-optimal can be checked in wiki page.
  /// https://en.wikipedia.org/wiki/Pareto_efficiency
  final List<Trial>? optimalTrials;

  ListOptimalTrialsResponse({this.optimalTrials}) : super(fullyQualifiedName);

  factory ListOptimalTrialsResponse.fromJson(Map<String, dynamic> json) {
    return ListOptimalTrialsResponse(
      optimalTrials: decodeListMessage(json['optimalTrials'], Trial.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (optimalTrials != null) 'optimalTrials': encodeList(optimalTrials),
    };
  }

  @override
  String toString() => 'ListOptimalTrialsResponse()';
}

/// Represents a hardware accelerator type.
final class AcceleratorType extends protobuf.ProtoEnum {
  /// Unspecified accelerator type, which means no accelerator.
  static const acceleratorTypeUnspecified = AcceleratorType(
    'ACCELERATOR_TYPE_UNSPECIFIED',
  );

  /// Deprecated: Nvidia Tesla K80 GPU has reached end of support,
  /// see https://cloud.google.com/compute/docs/eol/k80-eol.
  static const nvidiaTeslaK80 = AcceleratorType('NVIDIA_TESLA_K80');

  /// Nvidia Tesla P100 GPU.
  static const nvidiaTeslaP100 = AcceleratorType('NVIDIA_TESLA_P100');

  /// Nvidia Tesla V100 GPU.
  static const nvidiaTeslaV100 = AcceleratorType('NVIDIA_TESLA_V100');

  /// Nvidia Tesla P4 GPU.
  static const nvidiaTeslaP4 = AcceleratorType('NVIDIA_TESLA_P4');

  /// Nvidia Tesla T4 GPU.
  static const nvidiaTeslaT4 = AcceleratorType('NVIDIA_TESLA_T4');

  /// Nvidia Tesla A100 GPU.
  static const nvidiaTeslaA100 = AcceleratorType('NVIDIA_TESLA_A100');

  /// Nvidia A100 80GB GPU.
  static const nvidiaA10080Gb = AcceleratorType('NVIDIA_A100_80GB');

  /// Nvidia L4 GPU.
  static const nvidiaL4 = AcceleratorType('NVIDIA_L4');

  /// Nvidia H100 80Gb GPU.
  static const nvidiaH10080Gb = AcceleratorType('NVIDIA_H100_80GB');

  /// Nvidia H100 Mega 80Gb GPU.
  static const nvidiaH100Mega80Gb = AcceleratorType('NVIDIA_H100_MEGA_80GB');

  /// Nvidia H200 141Gb GPU.
  static const nvidiaH200141Gb = AcceleratorType('NVIDIA_H200_141GB');

  /// Nvidia B200 GPU.
  static const nvidiaB200 = AcceleratorType('NVIDIA_B200');

  /// Nvidia GB200 GPU.
  static const nvidiaGb200 = AcceleratorType('NVIDIA_GB200');

  /// Nvidia RTX Pro 6000 GPU.
  static const nvidiaRtxPro6000 = AcceleratorType('NVIDIA_RTX_PRO_6000');

  /// TPU v2.
  static const tpuV2 = AcceleratorType('TPU_V2');

  /// TPU v3.
  static const tpuV3 = AcceleratorType('TPU_V3');

  /// TPU v4.
  static const tpuV4Pod = AcceleratorType('TPU_V4_POD');

  /// TPU v5.
  static const tpuV5Litepod = AcceleratorType('TPU_V5_LITEPOD');

  const AcceleratorType(super.value);

  factory AcceleratorType.fromJson(String json) => AcceleratorType(json);

  @override
  String toString() => 'AcceleratorType.$value';
}

/// Harm categories that will block the content.
final class HarmCategory extends protobuf.ProtoEnum {
  /// The harm category is unspecified.
  static const harmCategoryUnspecified = HarmCategory(
    'HARM_CATEGORY_UNSPECIFIED',
  );

  /// The harm category is hate speech.
  static const harmCategoryHateSpeech = HarmCategory(
    'HARM_CATEGORY_HATE_SPEECH',
  );

  /// The harm category is dangerous content.
  static const harmCategoryDangerousContent = HarmCategory(
    'HARM_CATEGORY_DANGEROUS_CONTENT',
  );

  /// The harm category is harassment.
  static const harmCategoryHarassment = HarmCategory(
    'HARM_CATEGORY_HARASSMENT',
  );

  /// The harm category is sexually explicit content.
  static const harmCategorySexuallyExplicit = HarmCategory(
    'HARM_CATEGORY_SEXUALLY_EXPLICIT',
  );

  /// Deprecated: Election filter is not longer supported.
  /// The harm category is civic integrity.
  static const harmCategoryCivicIntegrity = HarmCategory(
    'HARM_CATEGORY_CIVIC_INTEGRITY',
  );

  /// The harm category is for jailbreak prompts.
  static const harmCategoryJailbreak = HarmCategory('HARM_CATEGORY_JAILBREAK');

  const HarmCategory(super.value);

  factory HarmCategory.fromJson(String json) => HarmCategory(json);

  @override
  String toString() => 'HarmCategory.$value';
}

/// Content Part modality
final class Modality extends protobuf.ProtoEnum {
  /// Unspecified modality.
  static const modalityUnspecified = Modality('MODALITY_UNSPECIFIED');

  /// Plain text.
  static const text = Modality('TEXT');

  /// Image.
  static const image = Modality('IMAGE');

  /// Video.
  static const video = Modality('VIDEO');

  /// Audio.
  static const audio = Modality('AUDIO');

  /// Document, e.g. PDF.
  static const document = Modality('DOCUMENT');

  const Modality(super.value);

  factory Modality.fromJson(String json) => Modality(json);

  @override
  String toString() => 'Modality.$value';
}

/// Stage field indicating the current progress of a deployment.
final class DeploymentStage extends protobuf.ProtoEnum {
  /// Default value. This value is unused.
  static const deploymentStageUnspecified = DeploymentStage(
    'DEPLOYMENT_STAGE_UNSPECIFIED',
  );

  /// The deployment is initializing and setting up the environment.
  static const startingDeployment = DeploymentStage('STARTING_DEPLOYMENT');

  /// The deployment is preparing the model assets.
  static const preparingModel = DeploymentStage('PREPARING_MODEL');

  /// The deployment is creating the underlying serving cluster.
  static const creatingServingCluster = DeploymentStage(
    'CREATING_SERVING_CLUSTER',
  );

  /// The deployment is adding nodes to the serving cluster.
  static const addingNodesToCluster = DeploymentStage(
    'ADDING_NODES_TO_CLUSTER',
  );

  /// The deployment is getting the container image for the model server.
  static const gettingContainerImage = DeploymentStage(
    'GETTING_CONTAINER_IMAGE',
  );

  /// The deployment is starting the model server.
  static const startingModelServer = DeploymentStage('STARTING_MODEL_SERVER');

  /// The deployment is performing finalization steps.
  static const finishingUp = DeploymentStage('FINISHING_UP');

  /// The deployment has terminated.
  static const deploymentTerminated = DeploymentStage('DEPLOYMENT_TERMINATED');

  const DeploymentStage(super.value);

  factory DeploymentStage.fromJson(String json) => DeploymentStage(json);

  @override
  String toString() => 'DeploymentStage.$value';
}

/// Pairwise prediction autorater preference.
final class PairwiseChoice extends protobuf.ProtoEnum {
  /// Unspecified prediction choice.
  static const pairwiseChoiceUnspecified = PairwiseChoice(
    'PAIRWISE_CHOICE_UNSPECIFIED',
  );

  /// Baseline prediction wins
  static const baseline = PairwiseChoice('BASELINE');

  /// Candidate prediction wins
  static const candidate = PairwiseChoice('CANDIDATE');

  /// Winner cannot be determined
  static const tie = PairwiseChoice('TIE');

  const PairwiseChoice(super.value);

  factory PairwiseChoice.fromJson(String json) => PairwiseChoice(json);

  @override
  String toString() => 'PairwiseChoice.$value';
}

/// Enum of location an HTTP element can be.
final class HttpElementLocation extends protobuf.ProtoEnum {
  static const httpInUnspecified = HttpElementLocation('HTTP_IN_UNSPECIFIED');

  /// Element is in the HTTP request query.
  static const httpInQuery = HttpElementLocation('HTTP_IN_QUERY');

  /// Element is in the HTTP request header.
  static const httpInHeader = HttpElementLocation('HTTP_IN_HEADER');

  /// Element is in the HTTP request path.
  static const httpInPath = HttpElementLocation('HTTP_IN_PATH');

  /// Element is in the HTTP request body.
  static const httpInBody = HttpElementLocation('HTTP_IN_BODY');

  /// Element is in the HTTP request cookie.
  static const httpInCookie = HttpElementLocation('HTTP_IN_COOKIE');

  const HttpElementLocation(super.value);

  factory HttpElementLocation.fromJson(String json) =>
      HttpElementLocation(json);

  @override
  String toString() => 'HttpElementLocation.$value';
}

/// Type of Auth.
final class AuthType extends protobuf.ProtoEnum {
  static const authTypeUnspecified = AuthType('AUTH_TYPE_UNSPECIFIED');

  /// No Auth.
  static const noAuth = AuthType('NO_AUTH');

  /// API Key Auth.
  static const apiKeyAuth = AuthType('API_KEY_AUTH');

  /// HTTP Basic Auth.
  static const httpBasicAuth = AuthType('HTTP_BASIC_AUTH');

  /// Google Service Account Auth.
  static const googleServiceAccountAuth = AuthType(
    'GOOGLE_SERVICE_ACCOUNT_AUTH',
  );

  /// OAuth auth.
  static const oauth = AuthType('OAUTH');

  /// OpenID Connect (OIDC) Auth.
  static const oidcAuth = AuthType('OIDC_AUTH');

  const AuthType(super.value);

  factory AuthType.fromJson(String json) => AuthType(json);

  @override
  String toString() => 'AuthType.$value';
}

/// Format of the data in the Feature View.
final class FeatureViewDataFormat extends protobuf.ProtoEnum {
  /// Not set. Will be treated as the KeyValue format.
  static const featureViewDataFormatUnspecified = FeatureViewDataFormat(
    'FEATURE_VIEW_DATA_FORMAT_UNSPECIFIED',
  );

  /// Return response data in key-value format.
  static const keyValue = FeatureViewDataFormat('KEY_VALUE');

  /// Return response data in proto Struct format.
  static const protoStruct = FeatureViewDataFormat('PROTO_STRUCT');

  const FeatureViewDataFormat(super.value);

  factory FeatureViewDataFormat.fromJson(String json) =>
      FeatureViewDataFormat(json);

  @override
  String toString() => 'FeatureViewDataFormat.$value';
}

/// Describes the state of a job.
final class JobState extends protobuf.ProtoEnum {
  /// The job state is unspecified.
  static const jobStateUnspecified = JobState('JOB_STATE_UNSPECIFIED');

  /// The job has been just created or resumed and processing has not yet begun.
  static const jobStateQueued = JobState('JOB_STATE_QUEUED');

  /// The service is preparing to run the job.
  static const jobStatePending = JobState('JOB_STATE_PENDING');

  /// The job is in progress.
  static const jobStateRunning = JobState('JOB_STATE_RUNNING');

  /// The job completed successfully.
  static const jobStateSucceeded = JobState('JOB_STATE_SUCCEEDED');

  /// The job failed.
  static const jobStateFailed = JobState('JOB_STATE_FAILED');

  /// The job is being cancelled. From this state the job may only go to
  /// either `JOB_STATE_SUCCEEDED`, `JOB_STATE_FAILED` or `JOB_STATE_CANCELLED`.
  static const jobStateCancelling = JobState('JOB_STATE_CANCELLING');

  /// The job has been cancelled.
  static const jobStateCancelled = JobState('JOB_STATE_CANCELLED');

  /// The job has been stopped, and can be resumed.
  static const jobStatePaused = JobState('JOB_STATE_PAUSED');

  /// The job has expired.
  static const jobStateExpired = JobState('JOB_STATE_EXPIRED');

  /// The job is being updated. Only jobs in the `RUNNING` state can be updated.
  /// After updating, the job goes back to the `RUNNING` state.
  static const jobStateUpdating = JobState('JOB_STATE_UPDATING');

  /// The job is partially succeeded, some results may be missing due to errors.
  static const jobStatePartiallySucceeded = JobState(
    'JOB_STATE_PARTIALLY_SUCCEEDED',
  );

  const JobState(super.value);

  factory JobState.fromJson(String json) => JobState(json);

  @override
  String toString() => 'JobState.$value';
}

/// The Model Monitoring Objective types.
final class ModelDeploymentMonitoringObjectiveType extends protobuf.ProtoEnum {
  /// Default value, should not be set.
  static const modelDeploymentMonitoringObjectiveTypeUnspecified =
      ModelDeploymentMonitoringObjectiveType(
        'MODEL_DEPLOYMENT_MONITORING_OBJECTIVE_TYPE_UNSPECIFIED',
      );

  /// Raw feature values' stats to detect skew between Training-Prediction
  /// datasets.
  static const rawFeatureSkew = ModelDeploymentMonitoringObjectiveType(
    'RAW_FEATURE_SKEW',
  );

  /// Raw feature values' stats to detect drift between Serving-Prediction
  /// datasets.
  static const rawFeatureDrift = ModelDeploymentMonitoringObjectiveType(
    'RAW_FEATURE_DRIFT',
  );

  /// Feature attribution scores to detect skew between Training-Prediction
  /// datasets.
  static const featureAttributionSkew = ModelDeploymentMonitoringObjectiveType(
    'FEATURE_ATTRIBUTION_SKEW',
  );

  /// Feature attribution scores to detect skew between Prediction datasets
  /// collected within different time windows.
  static const featureAttributionDrift = ModelDeploymentMonitoringObjectiveType(
    'FEATURE_ATTRIBUTION_DRIFT',
  );

  const ModelDeploymentMonitoringObjectiveType(super.value);

  factory ModelDeploymentMonitoringObjectiveType.fromJson(String json) =>
      ModelDeploymentMonitoringObjectiveType(json);

  @override
  String toString() => 'ModelDeploymentMonitoringObjectiveType.$value';
}

/// View enumeration of PublisherModel.
final class PublisherModelView extends protobuf.ProtoEnum {
  /// The default / unset value. The API will default to the BASIC view.
  static const publisherModelViewUnspecified = PublisherModelView(
    'PUBLISHER_MODEL_VIEW_UNSPECIFIED',
  );

  /// Include basic metadata about the publisher model, but not the full
  /// contents.
  static const publisherModelViewBasic = PublisherModelView(
    'PUBLISHER_MODEL_VIEW_BASIC',
  );

  /// Include everything.
  static const publisherModelViewFull = PublisherModelView(
    'PUBLISHER_MODEL_VIEW_FULL',
  );

  /// Include: VersionId, ModelVersionExternalName, and SupportedActions.
  static const publisherModelVersionViewBasic = PublisherModelView(
    'PUBLISHER_MODEL_VERSION_VIEW_BASIC',
  );

  const PublisherModelView(super.value);

  factory PublisherModelView.fromJson(String json) => PublisherModelView(json);

  @override
  String toString() => 'PublisherModelView.$value';
}

/// Represents a notebook runtime type.
final class NotebookRuntimeType extends protobuf.ProtoEnum {
  /// Unspecified notebook runtime type, NotebookRuntimeType will default to
  /// USER_DEFINED.
  static const notebookRuntimeTypeUnspecified = NotebookRuntimeType(
    'NOTEBOOK_RUNTIME_TYPE_UNSPECIFIED',
  );

  /// runtime or template with coustomized configurations from user.
  static const userDefined = NotebookRuntimeType('USER_DEFINED');

  /// runtime or template with system defined configurations.
  static const oneClick = NotebookRuntimeType('ONE_CLICK');

  const NotebookRuntimeType(super.value);

  factory NotebookRuntimeType.fromJson(String json) =>
      NotebookRuntimeType(json);

  @override
  String toString() => 'NotebookRuntimeType.$value';
}

/// Views for Get/List NotebookExecutionJob
final class NotebookExecutionJobView extends protobuf.ProtoEnum {
  /// When unspecified, the API defaults to the BASIC view.
  static const notebookExecutionJobViewUnspecified = NotebookExecutionJobView(
    'NOTEBOOK_EXECUTION_JOB_VIEW_UNSPECIFIED',
  );

  /// Includes all fields except for direct notebook inputs.
  static const notebookExecutionJobViewBasic = NotebookExecutionJobView(
    'NOTEBOOK_EXECUTION_JOB_VIEW_BASIC',
  );

  /// Includes all fields.
  static const notebookExecutionJobViewFull = NotebookExecutionJobView(
    'NOTEBOOK_EXECUTION_JOB_VIEW_FULL',
  );

  const NotebookExecutionJobView(super.value);

  factory NotebookExecutionJobView.fromJson(String json) =>
      NotebookExecutionJobView(json);

  @override
  String toString() => 'NotebookExecutionJobView.$value';
}

/// Type contains the list of OpenAPI data types as defined by
/// https://swagger.io/docs/specification/data-models/data-types/
final class Type extends protobuf.ProtoEnum {
  /// Not specified, should not be used.
  static const typeUnspecified = Type('TYPE_UNSPECIFIED');

  /// OpenAPI string type
  static const string = Type('STRING');

  /// OpenAPI number type
  static const number = Type('NUMBER');

  /// OpenAPI integer type
  static const integer = Type('INTEGER');

  /// OpenAPI boolean type
  static const boolean = Type('BOOLEAN');

  /// OpenAPI array type
  static const array = Type('ARRAY');

  /// OpenAPI object type
  static const object = Type('OBJECT');

  const Type(super.value);

  factory Type.fromJson(String json) => Type(json);

  @override
  String toString() => 'Type.$value';
}

/// Represents the failure policy of a pipeline. Currently, the default of a
/// pipeline is that the pipeline will continue to run until no more tasks can be
/// executed, also known as PIPELINE_FAILURE_POLICY_FAIL_SLOW. However, if a
/// pipeline is set to PIPELINE_FAILURE_POLICY_FAIL_FAST, it will stop scheduling
/// any new tasks when a task has failed. Any scheduled tasks will continue to
/// completion.
final class PipelineFailurePolicy extends protobuf.ProtoEnum {
  /// Default value, and follows fail slow behavior.
  static const pipelineFailurePolicyUnspecified = PipelineFailurePolicy(
    'PIPELINE_FAILURE_POLICY_UNSPECIFIED',
  );

  /// Indicates that the pipeline should continue to run until all possible
  /// tasks have been scheduled and completed.
  static const pipelineFailurePolicyFailSlow = PipelineFailurePolicy(
    'PIPELINE_FAILURE_POLICY_FAIL_SLOW',
  );

  /// Indicates that the pipeline should stop scheduling new tasks after a task
  /// has failed.
  static const pipelineFailurePolicyFailFast = PipelineFailurePolicy(
    'PIPELINE_FAILURE_POLICY_FAIL_FAST',
  );

  const PipelineFailurePolicy(super.value);

  factory PipelineFailurePolicy.fromJson(String json) =>
      PipelineFailurePolicy(json);

  @override
  String toString() => 'PipelineFailurePolicy.$value';
}

/// Describes the state of a pipeline.
final class PipelineState extends protobuf.ProtoEnum {
  /// The pipeline state is unspecified.
  static const pipelineStateUnspecified = PipelineState(
    'PIPELINE_STATE_UNSPECIFIED',
  );

  /// The pipeline has been created or resumed, and processing has not yet
  /// begun.
  static const pipelineStateQueued = PipelineState('PIPELINE_STATE_QUEUED');

  /// The service is preparing to run the pipeline.
  static const pipelineStatePending = PipelineState('PIPELINE_STATE_PENDING');

  /// The pipeline is in progress.
  static const pipelineStateRunning = PipelineState('PIPELINE_STATE_RUNNING');

  /// The pipeline completed successfully.
  static const pipelineStateSucceeded = PipelineState(
    'PIPELINE_STATE_SUCCEEDED',
  );

  /// The pipeline failed.
  static const pipelineStateFailed = PipelineState('PIPELINE_STATE_FAILED');

  /// The pipeline is being cancelled. From this state, the pipeline may only go
  /// to either PIPELINE_STATE_SUCCEEDED, PIPELINE_STATE_FAILED or
  /// PIPELINE_STATE_CANCELLED.
  static const pipelineStateCancelling = PipelineState(
    'PIPELINE_STATE_CANCELLING',
  );

  /// The pipeline has been cancelled.
  static const pipelineStateCancelled = PipelineState(
    'PIPELINE_STATE_CANCELLED',
  );

  /// The pipeline has been stopped, and can be resumed.
  static const pipelineStatePaused = PipelineState('PIPELINE_STATE_PAUSED');

  const PipelineState(super.value);

  factory PipelineState.fromJson(String json) => PipelineState(json);

  @override
  String toString() => 'PipelineState.$value';
}

/// The state of the PSC service automation.
final class PscautomationState extends protobuf.ProtoEnum {
  /// Should not be used.
  static const pscAutomationStateUnspecified = PscautomationState(
    'PSC_AUTOMATION_STATE_UNSPECIFIED',
  );

  /// The PSC service automation is successful.
  static const pscAutomationStateSuccessful = PscautomationState(
    'PSC_AUTOMATION_STATE_SUCCESSFUL',
  );

  /// The PSC service automation has failed.
  static const pscAutomationStateFailed = PscautomationState(
    'PSC_AUTOMATION_STATE_FAILED',
  );

  const PscautomationState(super.value);

  factory PscautomationState.fromJson(String json) => PscautomationState(json);

  @override
  String toString() => 'PSCAutomationState.$value';
}
