// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Cloud Natural Language API.
///
/// Provides natural language understanding technologies, such as sentiment
/// analysis, entity recognition, entity sentiment analysis, and other text
/// annotations, to developers.
library;

import 'package:google_cloud_gax/gax.dart';
import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:googleapis_auth/auth_io.dart' as auth;
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// Provides text analysis operations such as sentiment analysis and entity
/// recognition.
final class LanguageService {
  static const _host = 'language.googleapis.com';

  final ServiceClient _client;

  /// Creates a `LanguageService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `LanguageService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  LanguageService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `LanguageService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ArgumentError] if called without arguments and none of the above
  /// environment variables are set.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory LanguageService.fromApiKey([String? apiKey]) {
    apiKey ??= _apiKeys.map(environmentVariable).nonNulls.firstOrNull;
    if (apiKey == null) {
      throw ArgumentError(
        'apiKey or one of these environment variables must '
        'be set to an API key: ${_apiKeys.join(', ')}',
      );
    }
    return LanguageService(client: auth.clientViaApiKey(apiKey));
  }

  /// Analyzes the sentiment of the provided text.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnalyzeSentimentResponse> analyzeSentiment(
    AnalyzeSentimentRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/documents:analyzeSentiment');
    final response = await _client.post(url, body: request);
    return AnalyzeSentimentResponse.fromJson(response);
  }

  /// Finds named entities (currently proper names and common nouns) in the text
  /// along with entity types, probability, mentions for each entity, and
  /// other properties.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnalyzeEntitiesResponse> analyzeEntities(
    AnalyzeEntitiesRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/documents:analyzeEntities');
    final response = await _client.post(url, body: request);
    return AnalyzeEntitiesResponse.fromJson(response);
  }

  /// Classifies a document into categories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ClassifyTextResponse> classifyText(ClassifyTextRequest request) async {
    final url = Uri.https(_host, '/v2/documents:classifyText');
    final response = await _client.post(url, body: request);
    return ClassifyTextResponse.fromJson(response);
  }

  /// Moderates a document for harmful and sensitive categories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModerateTextResponse> moderateText(ModerateTextRequest request) async {
    final url = Uri.https(_host, '/v2/documents:moderateText');
    final response = await _client.post(url, body: request);
    return ModerateTextResponse.fromJson(response);
  }

  /// A convenience method that provides all features in one call.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnnotateTextResponse> annotateText(AnnotateTextRequest request) async {
    final url = Uri.https(_host, '/v2/documents:annotateText');
    final response = await _client.post(url, body: request);
    return AnnotateTextResponse.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Represents the input to API methods.
final class Document extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.Document';

  /// Required. If the type is not set or is `TYPE_UNSPECIFIED`,
  /// returns an `INVALID_ARGUMENT` error.
  final Document_Type type;

  /// The content of the input in string format.
  /// Cloud audit logging exempt since it is based on user data.
  final String content;

  /// The Google Cloud Storage URI where the file content is located.
  /// This URI must be of the form: gs://bucket_name/object_name. For more
  /// details, see https://cloud.google.com/storage/docs/reference-uris.
  /// NOTE: Cloud Storage object versioning is not supported.
  final String gcsContentUri;

  /// Optional. The language of the document (if not specified, the language is
  /// automatically detected). Both ISO and BCP-47 language codes are
  /// accepted.<br>
  /// [Language
  /// Support](https://cloud.google.com/natural-language/docs/languages) lists
  /// currently supported languages for each API method. If the language (either
  /// specified by the caller or automatically detected) is not supported by the
  /// called API method, an `INVALID_ARGUMENT` error is returned.
  final String languageCode;

  Document({
    this.type = Document_Type.$default,
    this.content = '',
    this.gcsContentUri = '',
    this.languageCode = '',
  }) : super(fullyQualifiedName);

  factory Document.fromJson(Map<String, dynamic> json) {
    return Document(
      type:
          decodeEnum(json['type'], Document_Type.fromJson) ??
          Document_Type.$default,
      content: json['content'] ?? '',
      gcsContentUri: json['gcsContentUri'] ?? '',
      languageCode: json['languageCode'] ?? '',
    );
  }

  @override
  Object toJson() {
    return {
      if (type.isNotDefault) 'type': type.toJson(),
      if (content.isNotDefault) 'content': content,
      if (gcsContentUri.isNotDefault) 'gcsContentUri': gcsContentUri,
      if (languageCode.isNotDefault) 'languageCode': languageCode,
    };
  }

  @override
  String toString() {
    final contents = [
      'type=$type',
      'content=$content',
      'gcsContentUri=$gcsContentUri',
      'languageCode=$languageCode',
    ].join(',');
    return 'Document($contents)';
  }
}

/// The document types enum.
final class Document_Type extends ProtoEnum {
  /// The content type is not specified.
  static const typeUnspecified = Document_Type('TYPE_UNSPECIFIED');

  /// Plain text
  static const plainText = Document_Type('PLAIN_TEXT');

  /// HTML
  static const html = Document_Type('HTML');

  /// The default value for [Document_Type].
  static const $default = typeUnspecified;

  const Document_Type(super.value);

  factory Document_Type.fromJson(String json) => Document_Type(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Represents a sentence in the input document.
final class Sentence extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.Sentence';

  /// The sentence text.
  final TextSpan? text;

  /// For calls to `AnalyzeSentiment` or if
  /// `AnnotateTextRequest.Features.extract_document_sentiment`
  /// is set to true, this field will contain the sentiment for the sentence.
  final Sentiment? sentiment;

  Sentence({this.text, this.sentiment}) : super(fullyQualifiedName);

  factory Sentence.fromJson(Map<String, dynamic> json) {
    return Sentence(
      text: decode(json['text'], TextSpan.fromJson),
      sentiment: decode(json['sentiment'], Sentiment.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (text != null) 'text': text!.toJson(),
      if (sentiment != null) 'sentiment': sentiment!.toJson(),
    };
  }

  @override
  String toString() => 'Sentence()';
}

/// Represents a phrase in the text that is a known entity, such as
/// a person, an organization, or location. The API associates information, such
/// as probability and mentions, with entities.
final class Entity extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.Entity';

  /// The representative name for the entity.
  final String name;

  /// The entity type.
  final Entity_Type type;

  /// Metadata associated with the entity.
  ///
  /// For the metadata
  /// associated with other entity types, see the Type table below.
  final Map<String, String> metadata;

  /// The mentions of this entity in the input document. The API currently
  /// supports proper noun mentions.
  final List<EntityMention> mentions;

  /// For calls to `AnalyzeEntitySentiment` or if
  /// `AnnotateTextRequest.Features.extract_entity_sentiment`
  /// is set to true, this field will contain the aggregate sentiment expressed
  /// for this entity in the provided document.
  final Sentiment? sentiment;

  Entity({
    this.name = '',
    this.type = Entity_Type.$default,
    this.metadata = const {},
    this.mentions = const [],
    this.sentiment,
  }) : super(fullyQualifiedName);

  factory Entity.fromJson(Map<String, dynamic> json) {
    return Entity(
      name: json['name'] ?? '',
      type:
          decodeEnum(json['type'], Entity_Type.fromJson) ??
          Entity_Type.$default,
      metadata: decodeMap(json['metadata']) ?? {},
      mentions:
          decodeListMessage(json['mentions'], EntityMention.fromJson) ?? [],
      sentiment: decode(json['sentiment'], Sentiment.fromJson),
    );
  }

  @override
  Object toJson() {
    return {
      if (name.isNotDefault) 'name': name,
      if (type.isNotDefault) 'type': type.toJson(),
      if (metadata.isNotDefault) 'metadata': metadata,
      if (mentions.isNotDefault) 'mentions': encodeList(mentions),
      if (sentiment != null) 'sentiment': sentiment!.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['name=$name', 'type=$type'].join(',');
    return 'Entity($contents)';
  }
}

/// The type of the entity. The table
/// below lists the associated fields for entities that have different
/// metadata.
final class Entity_Type extends ProtoEnum {
  /// Unknown
  static const unknown = Entity_Type('UNKNOWN');

  /// Person
  static const person = Entity_Type('PERSON');

  /// Location
  static const location = Entity_Type('LOCATION');

  /// Organization
  static const organization = Entity_Type('ORGANIZATION');

  /// Event
  static const event = Entity_Type('EVENT');

  /// Artwork
  static const workOfArt = Entity_Type('WORK_OF_ART');

  /// Consumer product
  static const consumerGood = Entity_Type('CONSUMER_GOOD');

  /// Other types of entities
  static const other = Entity_Type('OTHER');

  /// Phone number
  ///
  /// The metadata lists the phone number, formatted according to local
  /// convention, plus whichever additional elements appear in the text:
  ///
  /// * `number` - the actual number, broken down into sections as per local
  /// convention
  /// * `national_prefix` - country code, if detected
  /// * `area_code` - region or area code, if detected
  /// * `extension` - phone extension (to be dialed after connection), if
  /// detected
  static const phoneNumber = Entity_Type('PHONE_NUMBER');

  /// Address
  ///
  /// The metadata identifies the street number and locality plus whichever
  /// additional elements appear in the text:
  ///
  /// * `street_number` - street number
  /// * `locality` - city or town
  /// * `street_name` - street/route name, if detected
  /// * `postal_code` - postal code, if detected
  /// * `country` - country, if detected
  /// * `broad_region` - administrative area, such as the state, if detected
  /// * `narrow_region` - smaller administrative area, such as county, if
  /// detected
  /// * `sublocality` - used in Asian addresses to demark a district within a
  /// city, if detected
  static const address = Entity_Type('ADDRESS');

  /// Date
  ///
  /// The metadata identifies the components of the date:
  ///
  /// * `year` - four digit year, if detected
  /// * `month` - two digit month number, if detected
  /// * `day` - two digit day number, if detected
  static const date = Entity_Type('DATE');

  /// Number
  ///
  /// The metadata is the number itself.
  static const number = Entity_Type('NUMBER');

  /// Price
  ///
  /// The metadata identifies the `value` and `currency`.
  static const price = Entity_Type('PRICE');

  /// The default value for [Entity_Type].
  static const $default = unknown;

  const Entity_Type(super.value);

  factory Entity_Type.fromJson(String json) => Entity_Type(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Represents the feeling associated with the entire text or entities in
/// the text.
final class Sentiment extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.Sentiment';

  /// A non-negative number in the [0, +inf) range, which represents
  /// the absolute magnitude of sentiment regardless of score (positive or
  /// negative).
  final double magnitude;

  /// Sentiment score between -1.0 (negative sentiment) and 1.0
  /// (positive sentiment).
  final double score;

  Sentiment({this.magnitude = 0, this.score = 0}) : super(fullyQualifiedName);

  factory Sentiment.fromJson(Map<String, dynamic> json) {
    return Sentiment(
      magnitude: decodeDouble(json['magnitude']) ?? 0,
      score: decodeDouble(json['score']) ?? 0,
    );
  }

  @override
  Object toJson() {
    return {
      if (magnitude.isNotDefault) 'magnitude': encodeDouble(magnitude),
      if (score.isNotDefault) 'score': encodeDouble(score),
    };
  }

  @override
  String toString() {
    final contents = ['magnitude=$magnitude', 'score=$score'].join(',');
    return 'Sentiment($contents)';
  }
}

/// Represents a mention for an entity in the text. Currently, proper noun
/// mentions are supported.
final class EntityMention extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.EntityMention';

  /// The mention text.
  final TextSpan? text;

  /// The type of the entity mention.
  final EntityMention_Type type;

  /// For calls to `AnalyzeEntitySentiment` or if
  /// `AnnotateTextRequest.Features.extract_entity_sentiment`
  /// is set to true, this field will contain the sentiment expressed for this
  /// mention of the entity in the provided document.
  final Sentiment? sentiment;

  /// Probability score associated with the entity.
  ///
  /// The score shows the probability of the entity mention being the entity
  /// type. The score is in (0, 1] range.
  final double probability;

  EntityMention({
    this.text,
    this.type = EntityMention_Type.$default,
    this.sentiment,
    this.probability = 0,
  }) : super(fullyQualifiedName);

  factory EntityMention.fromJson(Map<String, dynamic> json) {
    return EntityMention(
      text: decode(json['text'], TextSpan.fromJson),
      type:
          decodeEnum(json['type'], EntityMention_Type.fromJson) ??
          EntityMention_Type.$default,
      sentiment: decode(json['sentiment'], Sentiment.fromJson),
      probability: decodeDouble(json['probability']) ?? 0,
    );
  }

  @override
  Object toJson() {
    return {
      if (text != null) 'text': text!.toJson(),
      if (type.isNotDefault) 'type': type.toJson(),
      if (sentiment != null) 'sentiment': sentiment!.toJson(),
      if (probability.isNotDefault) 'probability': encodeDouble(probability),
    };
  }

  @override
  String toString() {
    final contents = ['type=$type', 'probability=$probability'].join(',');
    return 'EntityMention($contents)';
  }
}

/// The supported types of mentions.
final class EntityMention_Type extends ProtoEnum {
  /// Unknown
  static const typeUnknown = EntityMention_Type('TYPE_UNKNOWN');

  /// Proper name
  static const proper = EntityMention_Type('PROPER');

  /// Common noun (or noun compound)
  static const common = EntityMention_Type('COMMON');

  /// The default value for [EntityMention_Type].
  static const $default = typeUnknown;

  const EntityMention_Type(super.value);

  factory EntityMention_Type.fromJson(String json) => EntityMention_Type(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Represents a text span in the input document.
final class TextSpan extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.TextSpan';

  /// The content of the text span, which is a substring of the document.
  final String content;

  /// The API calculates the beginning offset of the content in the original
  /// document according to the
  /// `EncodingType` specified in the API
  /// request.
  final int beginOffset;

  TextSpan({this.content = '', this.beginOffset = 0})
    : super(fullyQualifiedName);

  factory TextSpan.fromJson(Map<String, dynamic> json) {
    return TextSpan(
      content: json['content'] ?? '',
      beginOffset: json['beginOffset'] ?? 0,
    );
  }

  @override
  Object toJson() {
    return {
      if (content.isNotDefault) 'content': content,
      if (beginOffset.isNotDefault) 'beginOffset': beginOffset,
    };
  }

  @override
  String toString() {
    final contents = ['content=$content', 'beginOffset=$beginOffset'].join(',');
    return 'TextSpan($contents)';
  }
}

/// Represents a category returned from the text classifier.
final class ClassificationCategory extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ClassificationCategory';

  /// The name of the category representing the document.
  final String name;

  /// The classifier's confidence of the category. Number represents how certain
  /// the classifier is that this category represents the given text.
  final double confidence;

  /// Optional. The classifier's severity of the category. This is only present
  /// when the ModerateTextRequest.ModelVersion is set to MODEL_VERSION_2, and
  /// the corresponding category has a severity score.
  final double severity;

  ClassificationCategory({
    this.name = '',
    this.confidence = 0,
    this.severity = 0,
  }) : super(fullyQualifiedName);

  factory ClassificationCategory.fromJson(Map<String, dynamic> json) {
    return ClassificationCategory(
      name: json['name'] ?? '',
      confidence: decodeDouble(json['confidence']) ?? 0,
      severity: decodeDouble(json['severity']) ?? 0,
    );
  }

  @override
  Object toJson() {
    return {
      if (name.isNotDefault) 'name': name,
      if (confidence.isNotDefault) 'confidence': encodeDouble(confidence),
      if (severity.isNotDefault) 'severity': encodeDouble(severity),
    };
  }

  @override
  String toString() {
    final contents = [
      'name=$name',
      'confidence=$confidence',
      'severity=$severity',
    ].join(',');
    return 'ClassificationCategory($contents)';
  }
}

/// The sentiment analysis request message.
final class AnalyzeSentimentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnalyzeSentimentRequest';

  /// Required. Input document.
  final Document? document;

  /// The encoding type used by the API to calculate sentence offsets.
  final EncodingType encodingType;

  AnalyzeSentimentRequest({
    this.document,
    this.encodingType = EncodingType.$default,
  }) : super(fullyQualifiedName);

  factory AnalyzeSentimentRequest.fromJson(Map<String, dynamic> json) {
    return AnalyzeSentimentRequest(
      document: decode(json['document'], Document.fromJson),
      encodingType:
          decodeEnum(json['encodingType'], EncodingType.fromJson) ??
          EncodingType.$default,
    );
  }

  @override
  Object toJson() {
    return {
      if (document != null) 'document': document!.toJson(),
      if (encodingType.isNotDefault) 'encodingType': encodingType.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['encodingType=$encodingType'].join(',');
    return 'AnalyzeSentimentRequest($contents)';
  }
}

/// The sentiment analysis response message.
final class AnalyzeSentimentResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnalyzeSentimentResponse';

  /// The overall sentiment of the input document.
  final Sentiment? documentSentiment;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// The sentiment for all the sentences in the document.
  final List<Sentence> sentences;

  /// Whether the language is officially supported. The API may still return a
  /// response when the language is not supported, but it is on a best effort
  /// basis.
  final bool languageSupported;

  AnalyzeSentimentResponse({
    this.documentSentiment,
    this.languageCode = '',
    this.sentences = const [],
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory AnalyzeSentimentResponse.fromJson(Map<String, dynamic> json) {
    return AnalyzeSentimentResponse(
      documentSentiment: decode(json['documentSentiment'], Sentiment.fromJson),
      languageCode: json['languageCode'] ?? '',
      sentences: decodeListMessage(json['sentences'], Sentence.fromJson) ?? [],
      languageSupported: json['languageSupported'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      if (documentSentiment != null)
        'documentSentiment': documentSentiment!.toJson(),
      if (languageCode.isNotDefault) 'languageCode': languageCode,
      if (sentences.isNotDefault) 'sentences': encodeList(sentences),
      if (languageSupported.isNotDefault)
        'languageSupported': languageSupported,
    };
  }

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'AnalyzeSentimentResponse($contents)';
  }
}

/// The entity analysis request message.
final class AnalyzeEntitiesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnalyzeEntitiesRequest';

  /// Required. Input document.
  final Document? document;

  /// The encoding type used by the API to calculate offsets.
  final EncodingType encodingType;

  AnalyzeEntitiesRequest({
    this.document,
    this.encodingType = EncodingType.$default,
  }) : super(fullyQualifiedName);

  factory AnalyzeEntitiesRequest.fromJson(Map<String, dynamic> json) {
    return AnalyzeEntitiesRequest(
      document: decode(json['document'], Document.fromJson),
      encodingType:
          decodeEnum(json['encodingType'], EncodingType.fromJson) ??
          EncodingType.$default,
    );
  }

  @override
  Object toJson() {
    return {
      if (document != null) 'document': document!.toJson(),
      if (encodingType.isNotDefault) 'encodingType': encodingType.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['encodingType=$encodingType'].join(',');
    return 'AnalyzeEntitiesRequest($contents)';
  }
}

/// The entity analysis response message.
final class AnalyzeEntitiesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnalyzeEntitiesResponse';

  /// The recognized entities in the input document.
  final List<Entity> entities;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// Whether the language is officially supported. The API may still return a
  /// response when the language is not supported, but it is on a best effort
  /// basis.
  final bool languageSupported;

  AnalyzeEntitiesResponse({
    this.entities = const [],
    this.languageCode = '',
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory AnalyzeEntitiesResponse.fromJson(Map<String, dynamic> json) {
    return AnalyzeEntitiesResponse(
      entities: decodeListMessage(json['entities'], Entity.fromJson) ?? [],
      languageCode: json['languageCode'] ?? '',
      languageSupported: json['languageSupported'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      if (entities.isNotDefault) 'entities': encodeList(entities),
      if (languageCode.isNotDefault) 'languageCode': languageCode,
      if (languageSupported.isNotDefault)
        'languageSupported': languageSupported,
    };
  }

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'AnalyzeEntitiesResponse($contents)';
  }
}

/// The document classification request message.
final class ClassifyTextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ClassifyTextRequest';

  /// Required. Input document.
  final Document? document;

  ClassifyTextRequest({this.document}) : super(fullyQualifiedName);

  factory ClassifyTextRequest.fromJson(Map<String, dynamic> json) {
    return ClassifyTextRequest(
      document: decode(json['document'], Document.fromJson),
    );
  }

  @override
  Object toJson() {
    return {if (document != null) 'document': document!.toJson()};
  }

  @override
  String toString() => 'ClassifyTextRequest()';
}

/// The document classification response message.
final class ClassifyTextResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ClassifyTextResponse';

  /// Categories representing the input document.
  final List<ClassificationCategory> categories;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// Whether the language is officially supported. The API may still return a
  /// response when the language is not supported, but it is on a best effort
  /// basis.
  final bool languageSupported;

  ClassifyTextResponse({
    this.categories = const [],
    this.languageCode = '',
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory ClassifyTextResponse.fromJson(Map<String, dynamic> json) {
    return ClassifyTextResponse(
      categories:
          decodeListMessage(
            json['categories'],
            ClassificationCategory.fromJson,
          ) ??
          [],
      languageCode: json['languageCode'] ?? '',
      languageSupported: json['languageSupported'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      if (categories.isNotDefault) 'categories': encodeList(categories),
      if (languageCode.isNotDefault) 'languageCode': languageCode,
      if (languageSupported.isNotDefault)
        'languageSupported': languageSupported,
    };
  }

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'ClassifyTextResponse($contents)';
  }
}

/// The document moderation request message.
final class ModerateTextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ModerateTextRequest';

  /// Required. Input document.
  final Document? document;

  /// Optional. The model version to use for ModerateText.
  final ModerateTextRequest_ModelVersion modelVersion;

  ModerateTextRequest({
    this.document,
    this.modelVersion = ModerateTextRequest_ModelVersion.$default,
  }) : super(fullyQualifiedName);

  factory ModerateTextRequest.fromJson(Map<String, dynamic> json) {
    return ModerateTextRequest(
      document: decode(json['document'], Document.fromJson),
      modelVersion:
          decodeEnum(
            json['modelVersion'],
            ModerateTextRequest_ModelVersion.fromJson,
          ) ??
          ModerateTextRequest_ModelVersion.$default,
    );
  }

  @override
  Object toJson() {
    return {
      if (document != null) 'document': document!.toJson(),
      if (modelVersion.isNotDefault) 'modelVersion': modelVersion.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['modelVersion=$modelVersion'].join(',');
    return 'ModerateTextRequest($contents)';
  }
}

/// The model version to use for ModerateText.
final class ModerateTextRequest_ModelVersion extends ProtoEnum {
  /// The default model version.
  static const modelVersionUnspecified = ModerateTextRequest_ModelVersion(
    'MODEL_VERSION_UNSPECIFIED',
  );

  /// Use the v1 model, this model is used by default when not provided.
  /// The v1 model only returns probability (confidence) score for each
  /// category.
  static const modelVersion1 = ModerateTextRequest_ModelVersion(
    'MODEL_VERSION_1',
  );

  /// Use the v2 model.
  /// The v2 model only returns probability (confidence) score for each
  /// category, and returns severity score for a subset of the categories.
  static const modelVersion2 = ModerateTextRequest_ModelVersion(
    'MODEL_VERSION_2',
  );

  /// The default value for [ModerateTextRequest_ModelVersion].
  static const $default = modelVersionUnspecified;

  const ModerateTextRequest_ModelVersion(super.value);

  factory ModerateTextRequest_ModelVersion.fromJson(String json) =>
      ModerateTextRequest_ModelVersion(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ModelVersion.$value';
}

/// The document moderation response message.
final class ModerateTextResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ModerateTextResponse';

  /// Harmful and sensitive categories representing the input document.
  final List<ClassificationCategory> moderationCategories;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// Whether the language is officially supported. The API may still return a
  /// response when the language is not supported, but it is on a best effort
  /// basis.
  final bool languageSupported;

  ModerateTextResponse({
    this.moderationCategories = const [],
    this.languageCode = '',
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory ModerateTextResponse.fromJson(Map<String, dynamic> json) {
    return ModerateTextResponse(
      moderationCategories:
          decodeListMessage(
            json['moderationCategories'],
            ClassificationCategory.fromJson,
          ) ??
          [],
      languageCode: json['languageCode'] ?? '',
      languageSupported: json['languageSupported'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      if (moderationCategories.isNotDefault)
        'moderationCategories': encodeList(moderationCategories),
      if (languageCode.isNotDefault) 'languageCode': languageCode,
      if (languageSupported.isNotDefault)
        'languageSupported': languageSupported,
    };
  }

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'ModerateTextResponse($contents)';
  }
}

/// The request message for the text annotation API, which can perform multiple
/// analysis types in one call.
final class AnnotateTextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnnotateTextRequest';

  /// Required. Input document.
  final Document? document;

  /// Required. The enabled features.
  final AnnotateTextRequest_Features? features;

  /// The encoding type used by the API to calculate offsets.
  final EncodingType encodingType;

  AnnotateTextRequest({
    this.document,
    this.features,
    this.encodingType = EncodingType.$default,
  }) : super(fullyQualifiedName);

  factory AnnotateTextRequest.fromJson(Map<String, dynamic> json) {
    return AnnotateTextRequest(
      document: decode(json['document'], Document.fromJson),
      features: decode(json['features'], AnnotateTextRequest_Features.fromJson),
      encodingType:
          decodeEnum(json['encodingType'], EncodingType.fromJson) ??
          EncodingType.$default,
    );
  }

  @override
  Object toJson() {
    return {
      if (document != null) 'document': document!.toJson(),
      if (features != null) 'features': features!.toJson(),
      if (encodingType.isNotDefault) 'encodingType': encodingType.toJson(),
    };
  }

  @override
  String toString() {
    final contents = ['encodingType=$encodingType'].join(',');
    return 'AnnotateTextRequest($contents)';
  }
}

/// All available features.
/// Setting each one to true will enable that specific analysis for the input.
final class AnnotateTextRequest_Features extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnnotateTextRequest.Features';

  /// Optional. Extract entities.
  final bool extractEntities;

  /// Optional. Extract document-level sentiment.
  final bool extractDocumentSentiment;

  /// Optional. Classify the full document into categories.
  final bool classifyText;

  /// Optional. Moderate the document for harmful and sensitive categories.
  final bool moderateText;

  AnnotateTextRequest_Features({
    this.extractEntities = false,
    this.extractDocumentSentiment = false,
    this.classifyText = false,
    this.moderateText = false,
  }) : super(fullyQualifiedName);

  factory AnnotateTextRequest_Features.fromJson(Map<String, dynamic> json) {
    return AnnotateTextRequest_Features(
      extractEntities: json['extractEntities'] ?? false,
      extractDocumentSentiment: json['extractDocumentSentiment'] ?? false,
      classifyText: json['classifyText'] ?? false,
      moderateText: json['moderateText'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      if (extractEntities.isNotDefault) 'extractEntities': extractEntities,
      if (extractDocumentSentiment.isNotDefault)
        'extractDocumentSentiment': extractDocumentSentiment,
      if (classifyText.isNotDefault) 'classifyText': classifyText,
      if (moderateText.isNotDefault) 'moderateText': moderateText,
    };
  }

  @override
  String toString() {
    final contents = [
      'extractEntities=$extractEntities',
      'extractDocumentSentiment=$extractDocumentSentiment',
      'classifyText=$classifyText',
      'moderateText=$moderateText',
    ].join(',');
    return 'Features($contents)';
  }
}

/// The text annotations response message.
final class AnnotateTextResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnnotateTextResponse';

  /// Sentences in the input document. Populated if the user enables
  /// `AnnotateTextRequest.Features.extract_document_sentiment`.
  final List<Sentence> sentences;

  /// Entities, along with their semantic information, in the input document.
  /// Populated if the user enables
  /// `AnnotateTextRequest.Features.extract_entities`
  /// or
  /// `AnnotateTextRequest.Features.extract_entity_sentiment`.
  final List<Entity> entities;

  /// The overall sentiment for the document. Populated if the user enables
  /// `AnnotateTextRequest.Features.extract_document_sentiment`.
  final Sentiment? documentSentiment;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// Categories identified in the input document.
  final List<ClassificationCategory> categories;

  /// Harmful and sensitive categories identified in the input document.
  final List<ClassificationCategory> moderationCategories;

  /// Whether the language is officially supported by all requested features.
  /// The API may still return a response when the language is not supported, but
  /// it is on a best effort basis.
  final bool languageSupported;

  AnnotateTextResponse({
    this.sentences = const [],
    this.entities = const [],
    this.documentSentiment,
    this.languageCode = '',
    this.categories = const [],
    this.moderationCategories = const [],
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory AnnotateTextResponse.fromJson(Map<String, dynamic> json) {
    return AnnotateTextResponse(
      sentences: decodeListMessage(json['sentences'], Sentence.fromJson) ?? [],
      entities: decodeListMessage(json['entities'], Entity.fromJson) ?? [],
      documentSentiment: decode(json['documentSentiment'], Sentiment.fromJson),
      languageCode: json['languageCode'] ?? '',
      categories:
          decodeListMessage(
            json['categories'],
            ClassificationCategory.fromJson,
          ) ??
          [],
      moderationCategories:
          decodeListMessage(
            json['moderationCategories'],
            ClassificationCategory.fromJson,
          ) ??
          [],
      languageSupported: json['languageSupported'] ?? false,
    );
  }

  @override
  Object toJson() {
    return {
      if (sentences.isNotDefault) 'sentences': encodeList(sentences),
      if (entities.isNotDefault) 'entities': encodeList(entities),
      if (documentSentiment != null)
        'documentSentiment': documentSentiment!.toJson(),
      if (languageCode.isNotDefault) 'languageCode': languageCode,
      if (categories.isNotDefault) 'categories': encodeList(categories),
      if (moderationCategories.isNotDefault)
        'moderationCategories': encodeList(moderationCategories),
      if (languageSupported.isNotDefault)
        'languageSupported': languageSupported,
    };
  }

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'AnnotateTextResponse($contents)';
  }
}

/// Represents the text encoding that the caller uses to process the output.
/// Providing an `EncodingType` is recommended because the API provides the
/// beginning offsets for various outputs, such as tokens and mentions, and
/// languages that natively use different text encodings may access offsets
/// differently.
final class EncodingType extends ProtoEnum {
  /// If `EncodingType` is not specified, encoding-dependent information (such as
  /// `begin_offset`) will be set at `-1`.
  static const none = EncodingType('NONE');

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-8 encoding of the input. C++ and Go are examples of languages
  /// that use this encoding natively.
  static const utf8 = EncodingType('UTF8');

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-16 encoding of the input. Java and JavaScript are examples of
  /// languages that use this encoding natively.
  static const utf16 = EncodingType('UTF16');

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-32 encoding of the input. Python is an example of a language
  /// that uses this encoding natively.
  static const utf32 = EncodingType('UTF32');

  /// The default value for [EncodingType].
  static const $default = none;

  const EncodingType(super.value);

  factory EncodingType.fromJson(String json) => EncodingType(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'EncodingType.$value';
}
