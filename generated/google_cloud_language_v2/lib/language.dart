// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Cloud Natural Language API.
///
/// Provides natural language understanding technologies, such as sentiment
/// analysis, entity recognition, entity sentiment analysis, and other text
/// annotations, to developers.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// Provides text analysis operations such as sentiment analysis and entity
/// recognition.
final class LanguageService {
  static const _host = 'language.googleapis.com';

  final ServiceClient _client;

  /// Creates a `LanguageService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `LanguageService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  LanguageService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `LanguageService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory LanguageService.fromApiKey([String? apiKey]) =>
      LanguageService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Analyzes the sentiment of the provided text.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnalyzeSentimentResponse> analyzeSentiment(
    AnalyzeSentimentRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/documents:analyzeSentiment');
    final response = await _client.post(url, body: request);
    return AnalyzeSentimentResponse.fromJson(response);
  }

  /// Finds named entities (currently proper names and common nouns) in the text
  /// along with entity types, probability, mentions for each entity, and
  /// other properties.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnalyzeEntitiesResponse> analyzeEntities(
    AnalyzeEntitiesRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/documents:analyzeEntities');
    final response = await _client.post(url, body: request);
    return AnalyzeEntitiesResponse.fromJson(response);
  }

  /// Classifies a document into categories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ClassifyTextResponse> classifyText(ClassifyTextRequest request) async {
    final url = Uri.https(_host, '/v2/documents:classifyText');
    final response = await _client.post(url, body: request);
    return ClassifyTextResponse.fromJson(response);
  }

  /// Moderates a document for harmful and sensitive categories.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ModerateTextResponse> moderateText(ModerateTextRequest request) async {
    final url = Uri.https(_host, '/v2/documents:moderateText');
    final response = await _client.post(url, body: request);
    return ModerateTextResponse.fromJson(response);
  }

  /// A convenience method that provides all features in one call.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AnnotateTextResponse> annotateText(AnnotateTextRequest request) async {
    final url = Uri.https(_host, '/v2/documents:annotateText');
    final response = await _client.post(url, body: request);
    return AnnotateTextResponse.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Represents the input to API methods.
final class Document extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.Document';

  /// Required. If the type is not set or is `TYPE_UNSPECIFIED`,
  /// returns an `INVALID_ARGUMENT` error.
  final Document_Type type;

  /// The content of the input in string format.
  /// Cloud audit logging exempt since it is based on user data.
  final String? content;

  /// The Google Cloud Storage URI where the file content is located.
  /// This URI must be of the form: gs://bucket_name/object_name. For more
  /// details, see https://cloud.google.com/storage/docs/reference-uris.
  /// NOTE: Cloud Storage object versioning is not supported.
  final String? gcsContentUri;

  /// Optional. The language of the document (if not specified, the language is
  /// automatically detected). Both ISO and BCP-47 language codes are
  /// accepted.<br>
  /// [Language
  /// Support](https://cloud.google.com/natural-language/docs/languages) lists
  /// currently supported languages for each API method. If the language (either
  /// specified by the caller or automatically detected) is not supported by the
  /// called API method, an `INVALID_ARGUMENT` error is returned.
  final String languageCode;

  Document({
    this.type = Document_Type.$default,
    this.content,
    this.gcsContentUri,
    this.languageCode = '',
  }) : super(fullyQualifiedName);

  factory Document.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Document(
      type: switch (json['type']) {
        null => Document_Type.$default,
        Object $1 => Document_Type.fromJson($1),
      },
      content: switch (json['content']) {
        null => null,
        Object $1 => decodeString($1),
      },
      gcsContentUri: switch (json['gcsContentUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type.toJson(),
    if (content != null) 'content': content,
    if (gcsContentUri != null) 'gcsContentUri': gcsContentUri,
    if (languageCode.isNotDefault) 'languageCode': languageCode,
  };

  @override
  String toString() {
    final contents = [
      'type=$type',
      if (content != null) 'content=$content',
      if (gcsContentUri != null) 'gcsContentUri=$gcsContentUri',
      'languageCode=$languageCode',
    ].join(',');
    return 'Document($contents)';
  }
}

/// The document types enum.
final class Document_Type extends ProtoEnum {
  /// The content type is not specified.
  static const typeUnspecified = Document_Type('TYPE_UNSPECIFIED');

  /// Plain text
  static const plainText = Document_Type('PLAIN_TEXT');

  /// HTML
  static const html = Document_Type('HTML');

  /// The default value for [Document_Type].
  static const $default = typeUnspecified;

  const Document_Type(super.value);

  factory Document_Type.fromJson(Object? json) => Document_Type(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Represents a sentence in the input document.
final class Sentence extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.Sentence';

  /// The sentence text.
  final TextSpan? text;

  /// For calls to `AnalyzeSentiment` or if
  /// `AnnotateTextRequest.Features.extract_document_sentiment`
  /// is set to true, this field will contain the sentiment for the sentence.
  final Sentiment? sentiment;

  Sentence({this.text, this.sentiment}) : super(fullyQualifiedName);

  factory Sentence.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Sentence(
      text: switch (json['text']) {
        null => null,
        Object $1 => TextSpan.fromJson($1),
      },
      sentiment: switch (json['sentiment']) {
        null => null,
        Object $1 => Sentiment.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (text != null) 'text': text!.toJson(),
    if (sentiment != null) 'sentiment': sentiment!.toJson(),
  };

  @override
  String toString() => 'Sentence()';
}

/// Represents a phrase in the text that is a known entity, such as
/// a person, an organization, or location. The API associates information, such
/// as probability and mentions, with entities.
final class Entity extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.Entity';

  /// The representative name for the entity.
  final String name;

  /// The entity type.
  final Entity_Type type;

  /// Metadata associated with the entity.
  ///
  /// For the metadata
  /// associated with other entity types, see the Type table below.
  final Map<String, String> metadata;

  /// The mentions of this entity in the input document. The API currently
  /// supports proper noun mentions.
  final List<EntityMention> mentions;

  /// For calls to `AnalyzeEntitySentiment` or if
  /// `AnnotateTextRequest.Features.extract_entity_sentiment`
  /// is set to true, this field will contain the aggregate sentiment expressed
  /// for this entity in the provided document.
  final Sentiment? sentiment;

  Entity({
    this.name = '',
    this.type = Entity_Type.$default,
    this.metadata = const {},
    this.mentions = const [],
    this.sentiment,
  }) : super(fullyQualifiedName);

  factory Entity.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Entity(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      type: switch (json['type']) {
        null => Entity_Type.$default,
        Object $1 => Entity_Type.fromJson($1),
      },
      metadata: switch (json['metadata']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"metadata" is not an object'),
      },
      mentions: switch (json['mentions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) EntityMention.fromJson(i)],
        _ => throw const FormatException('"mentions" is not a list'),
      },
      sentiment: switch (json['sentiment']) {
        null => null,
        Object $1 => Sentiment.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (type.isNotDefault) 'type': type.toJson(),
    if (metadata.isNotDefault) 'metadata': metadata,
    if (mentions.isNotDefault) 'mentions': encodeList(mentions),
    if (sentiment != null) 'sentiment': sentiment!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'type=$type'].join(',');
    return 'Entity($contents)';
  }
}

/// The type of the entity. The table
/// below lists the associated fields for entities that have different
/// metadata.
final class Entity_Type extends ProtoEnum {
  /// Unknown
  static const unknown = Entity_Type('UNKNOWN');

  /// Person
  static const person = Entity_Type('PERSON');

  /// Location
  static const location = Entity_Type('LOCATION');

  /// Organization
  static const organization = Entity_Type('ORGANIZATION');

  /// Event
  static const event = Entity_Type('EVENT');

  /// Artwork
  static const workOfArt = Entity_Type('WORK_OF_ART');

  /// Consumer product
  static const consumerGood = Entity_Type('CONSUMER_GOOD');

  /// Other types of entities
  static const other = Entity_Type('OTHER');

  /// Phone number
  ///
  /// The metadata lists the phone number, formatted according to local
  /// convention, plus whichever additional elements appear in the text:
  ///
  /// * `number` - the actual number, broken down into sections as per local
  /// convention
  /// * `national_prefix` - country code, if detected
  /// * `area_code` - region or area code, if detected
  /// * `extension` - phone extension (to be dialed after connection), if
  /// detected
  static const phoneNumber = Entity_Type('PHONE_NUMBER');

  /// Address
  ///
  /// The metadata identifies the street number and locality plus whichever
  /// additional elements appear in the text:
  ///
  /// * `street_number` - street number
  /// * `locality` - city or town
  /// * `street_name` - street/route name, if detected
  /// * `postal_code` - postal code, if detected
  /// * `country` - country, if detected
  /// * `broad_region` - administrative area, such as the state, if detected
  /// * `narrow_region` - smaller administrative area, such as county, if
  /// detected
  /// * `sublocality` - used in Asian addresses to demark a district within a
  /// city, if detected
  static const address = Entity_Type('ADDRESS');

  /// Date
  ///
  /// The metadata identifies the components of the date:
  ///
  /// * `year` - four digit year, if detected
  /// * `month` - two digit month number, if detected
  /// * `day` - two digit day number, if detected
  static const date = Entity_Type('DATE');

  /// Number
  ///
  /// The metadata is the number itself.
  static const number = Entity_Type('NUMBER');

  /// Price
  ///
  /// The metadata identifies the `value` and `currency`.
  static const price = Entity_Type('PRICE');

  /// The default value for [Entity_Type].
  static const $default = unknown;

  const Entity_Type(super.value);

  factory Entity_Type.fromJson(Object? json) => Entity_Type(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Represents the feeling associated with the entire text or entities in
/// the text.
final class Sentiment extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.Sentiment';

  /// A non-negative number in the [0, +inf) range, which represents
  /// the absolute magnitude of sentiment regardless of score (positive or
  /// negative).
  final double magnitude;

  /// Sentiment score between -1.0 (negative sentiment) and 1.0
  /// (positive sentiment).
  final double score;

  Sentiment({this.magnitude = 0, this.score = 0}) : super(fullyQualifiedName);

  factory Sentiment.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Sentiment(
      magnitude: switch (json['magnitude']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      score: switch (json['score']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (magnitude.isNotDefault) 'magnitude': encodeDouble(magnitude),
    if (score.isNotDefault) 'score': encodeDouble(score),
  };

  @override
  String toString() {
    final contents = ['magnitude=$magnitude', 'score=$score'].join(',');
    return 'Sentiment($contents)';
  }
}

/// Represents a mention for an entity in the text. Currently, proper noun
/// mentions are supported.
final class EntityMention extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.EntityMention';

  /// The mention text.
  final TextSpan? text;

  /// The type of the entity mention.
  final EntityMention_Type type;

  /// For calls to `AnalyzeEntitySentiment` or if
  /// `AnnotateTextRequest.Features.extract_entity_sentiment`
  /// is set to true, this field will contain the sentiment expressed for this
  /// mention of the entity in the provided document.
  final Sentiment? sentiment;

  /// Probability score associated with the entity.
  ///
  /// The score shows the probability of the entity mention being the entity
  /// type. The score is in (0, 1] range.
  final double probability;

  EntityMention({
    this.text,
    this.type = EntityMention_Type.$default,
    this.sentiment,
    this.probability = 0,
  }) : super(fullyQualifiedName);

  factory EntityMention.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EntityMention(
      text: switch (json['text']) {
        null => null,
        Object $1 => TextSpan.fromJson($1),
      },
      type: switch (json['type']) {
        null => EntityMention_Type.$default,
        Object $1 => EntityMention_Type.fromJson($1),
      },
      sentiment: switch (json['sentiment']) {
        null => null,
        Object $1 => Sentiment.fromJson($1),
      },
      probability: switch (json['probability']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (text != null) 'text': text!.toJson(),
    if (type.isNotDefault) 'type': type.toJson(),
    if (sentiment != null) 'sentiment': sentiment!.toJson(),
    if (probability.isNotDefault) 'probability': encodeDouble(probability),
  };

  @override
  String toString() {
    final contents = ['type=$type', 'probability=$probability'].join(',');
    return 'EntityMention($contents)';
  }
}

/// The supported types of mentions.
final class EntityMention_Type extends ProtoEnum {
  /// Unknown
  static const typeUnknown = EntityMention_Type('TYPE_UNKNOWN');

  /// Proper name
  static const proper = EntityMention_Type('PROPER');

  /// Common noun (or noun compound)
  static const common = EntityMention_Type('COMMON');

  /// The default value for [EntityMention_Type].
  static const $default = typeUnknown;

  const EntityMention_Type(super.value);

  factory EntityMention_Type.fromJson(Object? json) =>
      EntityMention_Type(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Represents a text span in the input document.
final class TextSpan extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.language.v2.TextSpan';

  /// The content of the text span, which is a substring of the document.
  final String content;

  /// The API calculates the beginning offset of the content in the original
  /// document according to the
  /// `EncodingType` specified in the API
  /// request.
  final int beginOffset;

  TextSpan({this.content = '', this.beginOffset = 0})
    : super(fullyQualifiedName);

  factory TextSpan.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TextSpan(
      content: switch (json['content']) {
        null => '',
        Object $1 => decodeString($1),
      },
      beginOffset: switch (json['beginOffset']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (content.isNotDefault) 'content': content,
    if (beginOffset.isNotDefault) 'beginOffset': beginOffset,
  };

  @override
  String toString() {
    final contents = ['content=$content', 'beginOffset=$beginOffset'].join(',');
    return 'TextSpan($contents)';
  }
}

/// Represents a category returned from the text classifier.
final class ClassificationCategory extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ClassificationCategory';

  /// The name of the category representing the document.
  final String name;

  /// The classifier's confidence of the category. Number represents how certain
  /// the classifier is that this category represents the given text.
  final double confidence;

  /// Optional. The classifier's severity of the category. This is only present
  /// when the ModerateTextRequest.ModelVersion is set to MODEL_VERSION_2, and
  /// the corresponding category has a severity score.
  final double severity;

  ClassificationCategory({
    this.name = '',
    this.confidence = 0,
    this.severity = 0,
  }) : super(fullyQualifiedName);

  factory ClassificationCategory.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ClassificationCategory(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      confidence: switch (json['confidence']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      severity: switch (json['severity']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (confidence.isNotDefault) 'confidence': encodeDouble(confidence),
    if (severity.isNotDefault) 'severity': encodeDouble(severity),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'confidence=$confidence',
      'severity=$severity',
    ].join(',');
    return 'ClassificationCategory($contents)';
  }
}

/// The sentiment analysis request message.
final class AnalyzeSentimentRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnalyzeSentimentRequest';

  /// Required. Input document.
  final Document? document;

  /// The encoding type used by the API to calculate sentence offsets.
  final EncodingType encodingType;

  AnalyzeSentimentRequest({
    required this.document,
    this.encodingType = EncodingType.$default,
  }) : super(fullyQualifiedName);

  factory AnalyzeSentimentRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnalyzeSentimentRequest(
      document: switch (json['document']) {
        null => null,
        Object $1 => Document.fromJson($1),
      },
      encodingType: switch (json['encodingType']) {
        null => EncodingType.$default,
        Object $1 => EncodingType.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (document != null) 'document': document!.toJson(),
    if (encodingType.isNotDefault) 'encodingType': encodingType.toJson(),
  };

  @override
  String toString() {
    final contents = ['encodingType=$encodingType'].join(',');
    return 'AnalyzeSentimentRequest($contents)';
  }
}

/// The sentiment analysis response message.
final class AnalyzeSentimentResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnalyzeSentimentResponse';

  /// The overall sentiment of the input document.
  final Sentiment? documentSentiment;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// The sentiment for all the sentences in the document.
  final List<Sentence> sentences;

  /// Whether the language is officially supported. The API may still return a
  /// response when the language is not supported, but it is on a best effort
  /// basis.
  final bool languageSupported;

  AnalyzeSentimentResponse({
    this.documentSentiment,
    this.languageCode = '',
    this.sentences = const [],
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory AnalyzeSentimentResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnalyzeSentimentResponse(
      documentSentiment: switch (json['documentSentiment']) {
        null => null,
        Object $1 => Sentiment.fromJson($1),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sentences: switch (json['sentences']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Sentence.fromJson(i)],
        _ => throw const FormatException('"sentences" is not a list'),
      },
      languageSupported: switch (json['languageSupported']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (documentSentiment != null)
      'documentSentiment': documentSentiment!.toJson(),
    if (languageCode.isNotDefault) 'languageCode': languageCode,
    if (sentences.isNotDefault) 'sentences': encodeList(sentences),
    if (languageSupported.isNotDefault) 'languageSupported': languageSupported,
  };

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'AnalyzeSentimentResponse($contents)';
  }
}

/// The entity analysis request message.
final class AnalyzeEntitiesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnalyzeEntitiesRequest';

  /// Required. Input document.
  final Document? document;

  /// The encoding type used by the API to calculate offsets.
  final EncodingType encodingType;

  AnalyzeEntitiesRequest({
    required this.document,
    this.encodingType = EncodingType.$default,
  }) : super(fullyQualifiedName);

  factory AnalyzeEntitiesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnalyzeEntitiesRequest(
      document: switch (json['document']) {
        null => null,
        Object $1 => Document.fromJson($1),
      },
      encodingType: switch (json['encodingType']) {
        null => EncodingType.$default,
        Object $1 => EncodingType.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (document != null) 'document': document!.toJson(),
    if (encodingType.isNotDefault) 'encodingType': encodingType.toJson(),
  };

  @override
  String toString() {
    final contents = ['encodingType=$encodingType'].join(',');
    return 'AnalyzeEntitiesRequest($contents)';
  }
}

/// The entity analysis response message.
final class AnalyzeEntitiesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnalyzeEntitiesResponse';

  /// The recognized entities in the input document.
  final List<Entity> entities;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// Whether the language is officially supported. The API may still return a
  /// response when the language is not supported, but it is on a best effort
  /// basis.
  final bool languageSupported;

  AnalyzeEntitiesResponse({
    this.entities = const [],
    this.languageCode = '',
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory AnalyzeEntitiesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnalyzeEntitiesResponse(
      entities: switch (json['entities']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Entity.fromJson(i)],
        _ => throw const FormatException('"entities" is not a list'),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      languageSupported: switch (json['languageSupported']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (entities.isNotDefault) 'entities': encodeList(entities),
    if (languageCode.isNotDefault) 'languageCode': languageCode,
    if (languageSupported.isNotDefault) 'languageSupported': languageSupported,
  };

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'AnalyzeEntitiesResponse($contents)';
  }
}

/// The document classification request message.
final class ClassifyTextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ClassifyTextRequest';

  /// Required. Input document.
  final Document? document;

  ClassifyTextRequest({required this.document}) : super(fullyQualifiedName);

  factory ClassifyTextRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ClassifyTextRequest(
      document: switch (json['document']) {
        null => null,
        Object $1 => Document.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (document != null) 'document': document!.toJson()};

  @override
  String toString() => 'ClassifyTextRequest()';
}

/// The document classification response message.
final class ClassifyTextResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ClassifyTextResponse';

  /// Categories representing the input document.
  final List<ClassificationCategory> categories;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// Whether the language is officially supported. The API may still return a
  /// response when the language is not supported, but it is on a best effort
  /// basis.
  final bool languageSupported;

  ClassifyTextResponse({
    this.categories = const [],
    this.languageCode = '',
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory ClassifyTextResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ClassifyTextResponse(
      categories: switch (json['categories']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ClassificationCategory.fromJson(i),
        ],
        _ => throw const FormatException('"categories" is not a list'),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      languageSupported: switch (json['languageSupported']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (categories.isNotDefault) 'categories': encodeList(categories),
    if (languageCode.isNotDefault) 'languageCode': languageCode,
    if (languageSupported.isNotDefault) 'languageSupported': languageSupported,
  };

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'ClassifyTextResponse($contents)';
  }
}

/// The document moderation request message.
final class ModerateTextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ModerateTextRequest';

  /// Required. Input document.
  final Document? document;

  /// Optional. The model version to use for ModerateText.
  final ModerateTextRequest_ModelVersion modelVersion;

  ModerateTextRequest({
    required this.document,
    this.modelVersion = ModerateTextRequest_ModelVersion.$default,
  }) : super(fullyQualifiedName);

  factory ModerateTextRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModerateTextRequest(
      document: switch (json['document']) {
        null => null,
        Object $1 => Document.fromJson($1),
      },
      modelVersion: switch (json['modelVersion']) {
        null => ModerateTextRequest_ModelVersion.$default,
        Object $1 => ModerateTextRequest_ModelVersion.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (document != null) 'document': document!.toJson(),
    if (modelVersion.isNotDefault) 'modelVersion': modelVersion.toJson(),
  };

  @override
  String toString() {
    final contents = ['modelVersion=$modelVersion'].join(',');
    return 'ModerateTextRequest($contents)';
  }
}

/// The model version to use for ModerateText.
final class ModerateTextRequest_ModelVersion extends ProtoEnum {
  /// The default model version.
  static const modelVersionUnspecified = ModerateTextRequest_ModelVersion(
    'MODEL_VERSION_UNSPECIFIED',
  );

  /// Use the v1 model, this model is used by default when not provided.
  /// The v1 model only returns probability (confidence) score for each
  /// category.
  static const modelVersion1 = ModerateTextRequest_ModelVersion(
    'MODEL_VERSION_1',
  );

  /// Use the v2 model.
  /// The v2 model only returns probability (confidence) score for each
  /// category, and returns severity score for a subset of the categories.
  static const modelVersion2 = ModerateTextRequest_ModelVersion(
    'MODEL_VERSION_2',
  );

  /// The default value for [ModerateTextRequest_ModelVersion].
  static const $default = modelVersionUnspecified;

  const ModerateTextRequest_ModelVersion(super.value);

  factory ModerateTextRequest_ModelVersion.fromJson(Object? json) =>
      ModerateTextRequest_ModelVersion(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ModelVersion.$value';
}

/// The document moderation response message.
final class ModerateTextResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.ModerateTextResponse';

  /// Harmful and sensitive categories representing the input document.
  final List<ClassificationCategory> moderationCategories;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// Whether the language is officially supported. The API may still return a
  /// response when the language is not supported, but it is on a best effort
  /// basis.
  final bool languageSupported;

  ModerateTextResponse({
    this.moderationCategories = const [],
    this.languageCode = '',
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory ModerateTextResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ModerateTextResponse(
      moderationCategories: switch (json['moderationCategories']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ClassificationCategory.fromJson(i),
        ],
        _ => throw const FormatException(
          '"moderationCategories" is not a list',
        ),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      languageSupported: switch (json['languageSupported']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (moderationCategories.isNotDefault)
      'moderationCategories': encodeList(moderationCategories),
    if (languageCode.isNotDefault) 'languageCode': languageCode,
    if (languageSupported.isNotDefault) 'languageSupported': languageSupported,
  };

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'ModerateTextResponse($contents)';
  }
}

/// The request message for the text annotation API, which can perform multiple
/// analysis types in one call.
final class AnnotateTextRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnnotateTextRequest';

  /// Required. Input document.
  final Document? document;

  /// Required. The enabled features.
  final AnnotateTextRequest_Features? features;

  /// The encoding type used by the API to calculate offsets.
  final EncodingType encodingType;

  AnnotateTextRequest({
    required this.document,
    required this.features,
    this.encodingType = EncodingType.$default,
  }) : super(fullyQualifiedName);

  factory AnnotateTextRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnnotateTextRequest(
      document: switch (json['document']) {
        null => null,
        Object $1 => Document.fromJson($1),
      },
      features: switch (json['features']) {
        null => null,
        Object $1 => AnnotateTextRequest_Features.fromJson($1),
      },
      encodingType: switch (json['encodingType']) {
        null => EncodingType.$default,
        Object $1 => EncodingType.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (document != null) 'document': document!.toJson(),
    if (features != null) 'features': features!.toJson(),
    if (encodingType.isNotDefault) 'encodingType': encodingType.toJson(),
  };

  @override
  String toString() {
    final contents = ['encodingType=$encodingType'].join(',');
    return 'AnnotateTextRequest($contents)';
  }
}

/// All available features.
/// Setting each one to true will enable that specific analysis for the input.
final class AnnotateTextRequest_Features extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnnotateTextRequest.Features';

  /// Optional. Extract entities.
  final bool extractEntities;

  /// Optional. Extract document-level sentiment.
  final bool extractDocumentSentiment;

  /// Optional. Classify the full document into categories.
  final bool classifyText;

  /// Optional. Moderate the document for harmful and sensitive categories.
  final bool moderateText;

  AnnotateTextRequest_Features({
    this.extractEntities = false,
    this.extractDocumentSentiment = false,
    this.classifyText = false,
    this.moderateText = false,
  }) : super(fullyQualifiedName);

  factory AnnotateTextRequest_Features.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnnotateTextRequest_Features(
      extractEntities: switch (json['extractEntities']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      extractDocumentSentiment: switch (json['extractDocumentSentiment']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      classifyText: switch (json['classifyText']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      moderateText: switch (json['moderateText']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (extractEntities.isNotDefault) 'extractEntities': extractEntities,
    if (extractDocumentSentiment.isNotDefault)
      'extractDocumentSentiment': extractDocumentSentiment,
    if (classifyText.isNotDefault) 'classifyText': classifyText,
    if (moderateText.isNotDefault) 'moderateText': moderateText,
  };

  @override
  String toString() {
    final contents = [
      'extractEntities=$extractEntities',
      'extractDocumentSentiment=$extractDocumentSentiment',
      'classifyText=$classifyText',
      'moderateText=$moderateText',
    ].join(',');
    return 'Features($contents)';
  }
}

/// The text annotations response message.
final class AnnotateTextResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.language.v2.AnnotateTextResponse';

  /// Sentences in the input document. Populated if the user enables
  /// `AnnotateTextRequest.Features.extract_document_sentiment`.
  final List<Sentence> sentences;

  /// Entities, along with their semantic information, in the input document.
  /// Populated if the user enables
  /// `AnnotateTextRequest.Features.extract_entities`
  /// or
  /// `AnnotateTextRequest.Features.extract_entity_sentiment`.
  final List<Entity> entities;

  /// The overall sentiment for the document. Populated if the user enables
  /// `AnnotateTextRequest.Features.extract_document_sentiment`.
  final Sentiment? documentSentiment;

  /// The language of the text, which will be the same as the language specified
  /// in the request or, if not specified, the automatically-detected language.
  /// See `Document.language` field for more details.
  final String languageCode;

  /// Categories identified in the input document.
  final List<ClassificationCategory> categories;

  /// Harmful and sensitive categories identified in the input document.
  final List<ClassificationCategory> moderationCategories;

  /// Whether the language is officially supported by all requested features.
  /// The API may still return a response when the language is not supported, but
  /// it is on a best effort basis.
  final bool languageSupported;

  AnnotateTextResponse({
    this.sentences = const [],
    this.entities = const [],
    this.documentSentiment,
    this.languageCode = '',
    this.categories = const [],
    this.moderationCategories = const [],
    this.languageSupported = false,
  }) : super(fullyQualifiedName);

  factory AnnotateTextResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AnnotateTextResponse(
      sentences: switch (json['sentences']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Sentence.fromJson(i)],
        _ => throw const FormatException('"sentences" is not a list'),
      },
      entities: switch (json['entities']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Entity.fromJson(i)],
        _ => throw const FormatException('"entities" is not a list'),
      },
      documentSentiment: switch (json['documentSentiment']) {
        null => null,
        Object $1 => Sentiment.fromJson($1),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      categories: switch (json['categories']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ClassificationCategory.fromJson(i),
        ],
        _ => throw const FormatException('"categories" is not a list'),
      },
      moderationCategories: switch (json['moderationCategories']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ClassificationCategory.fromJson(i),
        ],
        _ => throw const FormatException(
          '"moderationCategories" is not a list',
        ),
      },
      languageSupported: switch (json['languageSupported']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (sentences.isNotDefault) 'sentences': encodeList(sentences),
    if (entities.isNotDefault) 'entities': encodeList(entities),
    if (documentSentiment != null)
      'documentSentiment': documentSentiment!.toJson(),
    if (languageCode.isNotDefault) 'languageCode': languageCode,
    if (categories.isNotDefault) 'categories': encodeList(categories),
    if (moderationCategories.isNotDefault)
      'moderationCategories': encodeList(moderationCategories),
    if (languageSupported.isNotDefault) 'languageSupported': languageSupported,
  };

  @override
  String toString() {
    final contents = [
      'languageCode=$languageCode',
      'languageSupported=$languageSupported',
    ].join(',');
    return 'AnnotateTextResponse($contents)';
  }
}

/// Represents the text encoding that the caller uses to process the output.
/// Providing an `EncodingType` is recommended because the API provides the
/// beginning offsets for various outputs, such as tokens and mentions, and
/// languages that natively use different text encodings may access offsets
/// differently.
final class EncodingType extends ProtoEnum {
  /// If `EncodingType` is not specified, encoding-dependent information (such as
  /// `begin_offset`) will be set at `-1`.
  static const none = EncodingType('NONE');

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-8 encoding of the input. C++ and Go are examples of languages
  /// that use this encoding natively.
  static const utf8 = EncodingType('UTF8');

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-16 encoding of the input. Java and JavaScript are examples of
  /// languages that use this encoding natively.
  static const utf16 = EncodingType('UTF16');

  /// Encoding-dependent information (such as `begin_offset`) is calculated based
  /// on the UTF-32 encoding of the input. Python is an example of a language
  /// that uses this encoding natively.
  static const utf32 = EncodingType('UTF32');

  /// The default value for [EncodingType].
  static const $default = none;

  const EncodingType(super.value);

  factory EncodingType.fromJson(Object? json) => EncodingType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'EncodingType.$value';
}
