// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Google RPC Types.
///
/// Defines RPC types.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';

part 'src/rpc.p.dart';

/// Describes the cause of the error with structured details.
///
/// Example of an error when contacting the "pubsub.googleapis.com" API when it
/// is not enabled:
///
///     { "reason": "API_DISABLED"
///       "domain": "googleapis.com"
///       "metadata": {
///         "resource": "projects/123",
///         "service": "pubsub.googleapis.com"
///       }
///     }
///
/// This response indicates that the pubsub.googleapis.com API is not enabled.
///
/// Example of an error that is returned when attempting to create a Spanner
/// instance in a region that is out of stock:
///
///     { "reason": "STOCKOUT"
///       "domain": "spanner.googleapis.com",
///       "metadata": {
///         "availableRegions": "us-central1,us-east2"
///       }
///     }
final class ErrorInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.ErrorInfo';

  /// The reason of the error. This is a constant value that identifies the
  /// proximate cause of the error. Error reasons are unique within a particular
  /// domain of errors. This should be at most 63 characters and match a
  /// regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`, which represents
  /// UPPER_SNAKE_CASE.
  final String reason;

  /// The logical grouping to which the "reason" belongs. The error domain
  /// is typically the registered service name of the tool or product that
  /// generates the error. Example: "pubsub.googleapis.com". If the error is
  /// generated by some common infrastructure, the error domain must be a
  /// globally unique value that identifies the infrastructure. For Google API
  /// infrastructure, the error domain is "googleapis.com".
  final String domain;

  /// Additional structured details about this error.
  ///
  /// Keys must match a regular expression of `[a-z][a-zA-Z0-9-_]+` but should
  /// ideally be lowerCamelCase. Also, they must be limited to 64 characters in
  /// length. When identifying the current value of an exceeded limit, the units
  /// should be contained in the key, not the value.  For example, rather than
  /// `{"instanceLimit": "100/request"}`, should be returned as,
  /// `{"instanceLimitPerRequest": "100"}`, if the client exceeds the number of
  /// instances that can be created in a single (batch) request.
  final Map<String, String> metadata;

  ErrorInfo({this.reason = '', this.domain = '', this.metadata = const {}})
    : super(fullyQualifiedName);

  factory ErrorInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ErrorInfo(
      reason: switch (json['reason']) {
        null => '',
        Object $1 => decodeString($1),
      },
      domain: switch (json['domain']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"metadata" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (reason.isNotDefault) 'reason': reason,
    if (domain.isNotDefault) 'domain': domain,
    if (metadata.isNotDefault) 'metadata': metadata,
  };

  @override
  String toString() {
    final contents = ['reason=$reason', 'domain=$domain'].join(',');
    return 'ErrorInfo($contents)';
  }
}

/// Describes when the clients can retry a failed request. Clients could ignore
/// the recommendation here or retry when this information is missing from error
/// responses.
///
/// It's always recommended that clients should use exponential backoff when
/// retrying.
///
/// Clients should wait until `retry_delay` amount of time has passed since
/// receiving the error response before retrying.  If retrying requests also
/// fail, clients should use an exponential backoff scheme to gradually increase
/// the delay between retries based on `retry_delay`, until either a maximum
/// number of retries have been reached or a maximum retry delay cap has been
/// reached.
final class RetryInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.RetryInfo';

  /// Clients should wait at least this long between retrying the same request.
  final Duration? retryDelay;

  RetryInfo({this.retryDelay}) : super(fullyQualifiedName);

  factory RetryInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RetryInfo(
      retryDelay: switch (json['retryDelay']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (retryDelay != null) 'retryDelay': retryDelay!.toJson(),
  };

  @override
  String toString() => 'RetryInfo()';
}

/// Describes additional debugging info.
final class DebugInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.DebugInfo';

  /// The stack trace entries indicating where the error occurred.
  final List<String> stackEntries;

  /// Additional debugging information provided by the server.
  final String detail;

  DebugInfo({this.stackEntries = const [], this.detail = ''})
    : super(fullyQualifiedName);

  factory DebugInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DebugInfo(
      stackEntries: switch (json['stackEntries']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"stackEntries" is not a list'),
      },
      detail: switch (json['detail']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (stackEntries.isNotDefault) 'stackEntries': stackEntries,
    if (detail.isNotDefault) 'detail': detail,
  };

  @override
  String toString() {
    final contents = ['detail=$detail'].join(',');
    return 'DebugInfo($contents)';
  }
}

/// Describes how a quota check failed.
///
/// For example if a daily limit was exceeded for the calling project,
/// a service could respond with a QuotaFailure detail containing the project
/// id and the description of the quota limit that was exceeded.  If the
/// calling project hasn't enabled the service in the developer console, then
/// a service could respond with the project id and set `service_disabled`
/// to true.
///
/// Also see RetryInfo and Help types for other details about handling a
/// quota failure.
final class QuotaFailure extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.QuotaFailure';

  /// Describes all quota violations.
  final List<QuotaFailure_Violation> violations;

  QuotaFailure({this.violations = const []}) : super(fullyQualifiedName);

  factory QuotaFailure.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuotaFailure(
      violations: switch (json['violations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) QuotaFailure_Violation.fromJson(i),
        ],
        _ => throw const FormatException('"violations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (violations.isNotDefault) 'violations': encodeList(violations),
  };

  @override
  String toString() => 'QuotaFailure()';
}

/// A message type used to describe a single quota violation.  For example, a
/// daily quota or a custom quota that was exceeded.
final class QuotaFailure_Violation extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.QuotaFailure.Violation';

  /// The subject on which the quota check failed.
  /// For example, "clientip:<ip address of client>" or "project:<Google
  /// developer project id>".
  final String subject;

  /// A description of how the quota check failed. Clients can use this
  /// description to find more about the quota configuration in the service's
  /// public documentation, or find the relevant quota limit to adjust through
  /// developer console.
  ///
  /// For example: "Service disabled" or "Daily Limit for read operations
  /// exceeded".
  final String description;

  /// The API Service from which the `QuotaFailure.Violation` orginates. In
  /// some cases, Quota issues originate from an API Service other than the one
  /// that was called. In other words, a dependency of the called API Service
  /// could be the cause of the `QuotaFailure`, and this field would have the
  /// dependency API service name.
  ///
  /// For example, if the called API is Kubernetes Engine API
  /// (container.googleapis.com), and a quota violation occurs in the
  /// Kubernetes Engine API itself, this field would be
  /// "container.googleapis.com". On the other hand, if the quota violation
  /// occurs when the Kubernetes Engine API creates VMs in the Compute Engine
  /// API (compute.googleapis.com), this field would be
  /// "compute.googleapis.com".
  final String apiService;

  /// The metric of the violated quota. A quota metric is a named counter to
  /// measure usage, such as API requests or CPUs. When an activity occurs in a
  /// service, such as Virtual Machine allocation, one or more quota metrics
  /// may be affected.
  ///
  /// For example, "compute.googleapis.com/cpus_per_vm_family",
  /// "storage.googleapis.com/internet_egress_bandwidth".
  final String quotaMetric;

  /// The id of the violated quota. Also know as "limit name", this is the
  /// unique identifier of a quota in the context of an API service.
  ///
  /// For example, "CPUS-PER-VM-FAMILY-per-project-region".
  final String quotaId;

  /// The dimensions of the violated quota. Every non-global quota is enforced
  /// on a set of dimensions. While quota metric defines what to count, the
  /// dimensions specify for what aspects the counter should be increased.
  ///
  /// For example, the quota "CPUs per region per VM family" enforces a limit
  /// on the metric "compute.googleapis.com/cpus_per_vm_family" on dimensions
  /// "region" and "vm_family". And if the violation occurred in region
  /// "us-central1" and for VM family "n1", the quota_dimensions would be,
  ///
  /// {
  ///   "region": "us-central1",
  ///   "vm_family": "n1",
  /// }
  ///
  /// When a quota is enforced globally, the quota_dimensions would always be
  /// empty.
  final Map<String, String> quotaDimensions;

  /// The enforced quota value at the time of the `QuotaFailure`.
  ///
  /// For example, if the enforced quota value at the time of the
  /// `QuotaFailure` on the number of CPUs is "10", then the value of this
  /// field would reflect this quantity.
  final int quotaValue;

  /// The new quota value being rolled out at the time of the violation. At the
  /// completion of the rollout, this value will be enforced in place of
  /// quota_value. If no rollout is in progress at the time of the violation,
  /// this field is not set.
  ///
  /// For example, if at the time of the violation a rollout is in progress
  /// changing the number of CPUs quota from 10 to 20, 20 would be the value of
  /// this field.
  final int? futureQuotaValue;

  QuotaFailure_Violation({
    this.subject = '',
    this.description = '',
    this.apiService = '',
    this.quotaMetric = '',
    this.quotaId = '',
    this.quotaDimensions = const {},
    this.quotaValue = 0,
    this.futureQuotaValue,
  }) : super(fullyQualifiedName);

  factory QuotaFailure_Violation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuotaFailure_Violation(
      subject: switch (json['subject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      apiService: switch (json['apiService']) {
        null => '',
        Object $1 => decodeString($1),
      },
      quotaMetric: switch (json['quotaMetric']) {
        null => '',
        Object $1 => decodeString($1),
      },
      quotaId: switch (json['quotaId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      quotaDimensions: switch (json['quotaDimensions']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"quotaDimensions" is not an object'),
      },
      quotaValue: switch (json['quotaValue']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      futureQuotaValue: switch (json['futureQuotaValue']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (subject.isNotDefault) 'subject': subject,
    if (description.isNotDefault) 'description': description,
    if (apiService.isNotDefault) 'apiService': apiService,
    if (quotaMetric.isNotDefault) 'quotaMetric': quotaMetric,
    if (quotaId.isNotDefault) 'quotaId': quotaId,
    if (quotaDimensions.isNotDefault) 'quotaDimensions': quotaDimensions,
    if (quotaValue.isNotDefault) 'quotaValue': encodeInt64(quotaValue),
    if (futureQuotaValue != null)
      'futureQuotaValue': encodeInt64(futureQuotaValue),
  };

  @override
  String toString() {
    final contents = [
      'subject=$subject',
      'description=$description',
      'apiService=$apiService',
      'quotaMetric=$quotaMetric',
      'quotaId=$quotaId',
      'quotaValue=$quotaValue',
      if (futureQuotaValue != null) 'futureQuotaValue=$futureQuotaValue',
    ].join(',');
    return 'Violation($contents)';
  }
}

/// Describes what preconditions have failed.
///
/// For example, if an RPC failed because it required the Terms of Service to be
/// acknowledged, it could list the terms of service violation in the
/// PreconditionFailure message.
final class PreconditionFailure extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.PreconditionFailure';

  /// Describes all precondition violations.
  final List<PreconditionFailure_Violation> violations;

  PreconditionFailure({this.violations = const []}) : super(fullyQualifiedName);

  factory PreconditionFailure.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PreconditionFailure(
      violations: switch (json['violations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) PreconditionFailure_Violation.fromJson(i),
        ],
        _ => throw const FormatException('"violations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (violations.isNotDefault) 'violations': encodeList(violations),
  };

  @override
  String toString() => 'PreconditionFailure()';
}

/// A message type used to describe a single precondition failure.
final class PreconditionFailure_Violation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.rpc.PreconditionFailure.Violation';

  /// The type of PreconditionFailure. We recommend using a service-specific
  /// enum type to define the supported precondition violation subjects. For
  /// example, "TOS" for "Terms of Service violation".
  final String type;

  /// The subject, relative to the type, that failed.
  /// For example, "google.com/cloud" relative to the "TOS" type would indicate
  /// which terms of service is being referenced.
  final String subject;

  /// A description of how the precondition failed. Developers can use this
  /// description to understand how to fix the failure.
  ///
  /// For example: "Terms of service not accepted".
  final String description;

  PreconditionFailure_Violation({
    this.type = '',
    this.subject = '',
    this.description = '',
  }) : super(fullyQualifiedName);

  factory PreconditionFailure_Violation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PreconditionFailure_Violation(
      type: switch (json['type']) {
        null => '',
        Object $1 => decodeString($1),
      },
      subject: switch (json['subject']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type,
    if (subject.isNotDefault) 'subject': subject,
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'type=$type',
      'subject=$subject',
      'description=$description',
    ].join(',');
    return 'Violation($contents)';
  }
}

/// Describes violations in a client request. This error type focuses on the
/// syntactic aspects of the request.
final class BadRequest extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.BadRequest';

  /// Describes all violations in a client request.
  final List<BadRequest_FieldViolation> fieldViolations;

  BadRequest({this.fieldViolations = const []}) : super(fullyQualifiedName);

  factory BadRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BadRequest(
      fieldViolations: switch (json['fieldViolations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) BadRequest_FieldViolation.fromJson(i),
        ],
        _ => throw const FormatException('"fieldViolations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (fieldViolations.isNotDefault)
      'fieldViolations': encodeList(fieldViolations),
  };

  @override
  String toString() => 'BadRequest()';
}

/// A message type used to describe a single bad request field.
final class BadRequest_FieldViolation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.rpc.BadRequest.FieldViolation';

  /// A path that leads to a field in the request body. The value will be a
  /// sequence of dot-separated identifiers that identify a protocol buffer
  /// field.
  ///
  /// Consider the following:
  ///
  ///     message CreateContactRequest {
  ///       message EmailAddress {
  ///         enum Type {
  ///           TYPE_UNSPECIFIED = 0;
  ///           HOME = 1;
  ///           WORK = 2;
  ///         }
  ///
  ///         optional string email = 1;
  ///         repeated EmailType type = 2;
  ///       }
  ///
  ///       string full_name = 1;
  ///       repeated EmailAddress email_addresses = 2;
  ///     }
  ///
  /// In this example, in proto `field` could take one of the following values:
  ///
  /// * `full_name` for a violation in the `full_name` value
  /// * `email_addresses[1].email` for a violation in the `email` field of the
  ///   first `email_addresses` message
  /// * `email_addresses[3].type[2]` for a violation in the second `type`
  ///   value in the third `email_addresses` message.
  ///
  /// In JSON, the same values are represented as:
  ///
  /// * `fullName` for a violation in the `fullName` value
  /// * `emailAddresses[1].email` for a violation in the `email` field of the
  ///   first `emailAddresses` message
  /// * `emailAddresses[3].type[2]` for a violation in the second `type`
  ///   value in the third `emailAddresses` message.
  final String field;

  /// A description of why the request element is bad.
  final String description;

  /// The reason of the field-level error. This is a constant value that
  /// identifies the proximate cause of the field-level error. It should
  /// uniquely identify the type of the FieldViolation within the scope of the
  /// google.rpc.ErrorInfo.domain. This should be at most 63
  /// characters and match a regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`,
  /// which represents UPPER_SNAKE_CASE.
  final String reason;

  /// Provides a localized error message for field-level errors that is safe to
  /// return to the API consumer.
  final LocalizedMessage? localizedMessage;

  BadRequest_FieldViolation({
    this.field = '',
    this.description = '',
    this.reason = '',
    this.localizedMessage,
  }) : super(fullyQualifiedName);

  factory BadRequest_FieldViolation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BadRequest_FieldViolation(
      field: switch (json['field']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      reason: switch (json['reason']) {
        null => '',
        Object $1 => decodeString($1),
      },
      localizedMessage: switch (json['localizedMessage']) {
        null => null,
        Object $1 => LocalizedMessage.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (field.isNotDefault) 'field': field,
    if (description.isNotDefault) 'description': description,
    if (reason.isNotDefault) 'reason': reason,
    if (localizedMessage != null)
      'localizedMessage': localizedMessage!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'field=$field',
      'description=$description',
      'reason=$reason',
    ].join(',');
    return 'FieldViolation($contents)';
  }
}

/// Contains metadata about the request that clients can attach when filing a bug
/// or providing other forms of feedback.
final class RequestInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.RequestInfo';

  /// An opaque string that should only be interpreted by the service generating
  /// it. For example, it can be used to identify requests in the service's logs.
  final String requestId;

  /// Any data that was used to serve this request. For example, an encrypted
  /// stack trace that can be sent back to the service provider for debugging.
  final String servingData;

  RequestInfo({this.requestId = '', this.servingData = ''})
    : super(fullyQualifiedName);

  factory RequestInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RequestInfo(
      requestId: switch (json['requestId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      servingData: switch (json['servingData']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (requestId.isNotDefault) 'requestId': requestId,
    if (servingData.isNotDefault) 'servingData': servingData,
  };

  @override
  String toString() {
    final contents = [
      'requestId=$requestId',
      'servingData=$servingData',
    ].join(',');
    return 'RequestInfo($contents)';
  }
}

/// Describes the resource that is being accessed.
final class ResourceInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.ResourceInfo';

  /// A name for the type of resource being accessed, e.g. "sql table",
  /// "cloud storage bucket", "file", "Google calendar"; or the type URL
  /// of the resource: e.g. "type.googleapis.com/google.pubsub.v1.Topic".
  final String resourceType;

  /// The name of the resource being accessed.  For example, a shared calendar
  /// name: "example.com_4fghdhgsrgh@group.calendar.google.com", if the current
  /// error is
  /// `google.rpc.Code.PERMISSION_DENIED`.
  final String resourceName;

  /// The owner of the resource (optional).
  /// For example, "user:<owner email>" or "project:<Google developer project
  /// id>".
  final String owner;

  /// Describes what error is encountered when accessing this resource.
  /// For example, updating a cloud project may require the `writer` permission
  /// on the developer console project.
  final String description;

  ResourceInfo({
    this.resourceType = '',
    this.resourceName = '',
    this.owner = '',
    this.description = '',
  }) : super(fullyQualifiedName);

  factory ResourceInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourceInfo(
      resourceType: switch (json['resourceType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      resourceName: switch (json['resourceName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      owner: switch (json['owner']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (resourceType.isNotDefault) 'resourceType': resourceType,
    if (resourceName.isNotDefault) 'resourceName': resourceName,
    if (owner.isNotDefault) 'owner': owner,
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'resourceType=$resourceType',
      'resourceName=$resourceName',
      'owner=$owner',
      'description=$description',
    ].join(',');
    return 'ResourceInfo($contents)';
  }
}

/// Provides links to documentation or for performing an out of band action.
///
/// For example, if a quota check failed with an error indicating the calling
/// project hasn't enabled the accessed service, this can contain a URL pointing
/// directly to the right place in the developer console to flip the bit.
final class Help extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.Help';

  /// URL(s) pointing to additional information on handling the current error.
  final List<Help_Link> links;

  Help({this.links = const []}) : super(fullyQualifiedName);

  factory Help.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Help(
      links: switch (json['links']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Help_Link.fromJson(i)],
        _ => throw const FormatException('"links" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (links.isNotDefault) 'links': encodeList(links)};

  @override
  String toString() => 'Help()';
}

/// Describes a URL link.
final class Help_Link extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.Help.Link';

  /// Describes what the link offers.
  final String description;

  /// The URL of the link.
  final String url;

  Help_Link({this.description = '', this.url = ''}) : super(fullyQualifiedName);

  factory Help_Link.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Help_Link(
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      url: switch (json['url']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (description.isNotDefault) 'description': description,
    if (url.isNotDefault) 'url': url,
  };

  @override
  String toString() {
    final contents = ['description=$description', 'url=$url'].join(',');
    return 'Link($contents)';
  }
}

/// Provides a localized error message that is safe to return to the user
/// which can be attached to an RPC error.
final class LocalizedMessage extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.LocalizedMessage';

  /// The locale used following the specification defined at
  /// https://www.rfc-editor.org/rfc/bcp/bcp47.txt.
  /// Examples are: "en-US", "fr-CH", "es-MX"
  final String locale;

  /// The localized error message in the above locale.
  final String message;

  LocalizedMessage({this.locale = '', this.message = ''})
    : super(fullyQualifiedName);

  factory LocalizedMessage.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LocalizedMessage(
      locale: switch (json['locale']) {
        null => '',
        Object $1 => decodeString($1),
      },
      message: switch (json['message']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (locale.isNotDefault) 'locale': locale,
    if (message.isNotDefault) 'message': message,
  };

  @override
  String toString() {
    final contents = ['locale=$locale', 'message=$message'].join(',');
    return 'LocalizedMessage($contents)';
  }
}

/// Represents an HTTP request.
final class HttpRequest extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.HttpRequest';

  /// The HTTP request method.
  final String method;

  /// The HTTP request URI.
  final String uri;

  /// The HTTP request headers. The ordering of the headers is significant.
  /// Multiple headers with the same key may present for the request.
  final List<HttpHeader> headers;

  /// The HTTP request body. If the body is not expected, it should be empty.
  final Uint8List body;

  HttpRequest({
    this.method = '',
    this.uri = '',
    this.headers = const [],
    Uint8List? body,
  }) : body = body ?? Uint8List(0),
       super(fullyQualifiedName);

  factory HttpRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HttpRequest(
      method: switch (json['method']) {
        null => '',
        Object $1 => decodeString($1),
      },
      uri: switch (json['uri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      headers: switch (json['headers']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) HttpHeader.fromJson(i)],
        _ => throw const FormatException('"headers" is not a list'),
      },
      body: switch (json['body']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (method.isNotDefault) 'method': method,
    if (uri.isNotDefault) 'uri': uri,
    if (headers.isNotDefault) 'headers': encodeList(headers),
    if (body.isNotDefault) 'body': encodeBytes(body),
  };

  @override
  String toString() {
    final contents = ['method=$method', 'uri=$uri', 'body=$body'].join(',');
    return 'HttpRequest($contents)';
  }
}

/// Represents an HTTP response.
final class HttpResponse extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.HttpResponse';

  /// The HTTP status code, such as 200 or 404.
  final int status;

  /// The HTTP reason phrase, such as "OK" or "Not Found".
  final String reason;

  /// The HTTP response headers. The ordering of the headers is significant.
  /// Multiple headers with the same key may present for the response.
  final List<HttpHeader> headers;

  /// The HTTP response body. If the body is not expected, it should be empty.
  final Uint8List body;

  HttpResponse({
    this.status = 0,
    this.reason = '',
    this.headers = const [],
    Uint8List? body,
  }) : body = body ?? Uint8List(0),
       super(fullyQualifiedName);

  factory HttpResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HttpResponse(
      status: switch (json['status']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      reason: switch (json['reason']) {
        null => '',
        Object $1 => decodeString($1),
      },
      headers: switch (json['headers']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) HttpHeader.fromJson(i)],
        _ => throw const FormatException('"headers" is not a list'),
      },
      body: switch (json['body']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (status.isNotDefault) 'status': status,
    if (reason.isNotDefault) 'reason': reason,
    if (headers.isNotDefault) 'headers': encodeList(headers),
    if (body.isNotDefault) 'body': encodeBytes(body),
  };

  @override
  String toString() {
    final contents = [
      'status=$status',
      'reason=$reason',
      'body=$body',
    ].join(',');
    return 'HttpResponse($contents)';
  }
}

/// Represents an HTTP header.
final class HttpHeader extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.HttpHeader';

  /// The HTTP header key. It is case insensitive.
  final String key;

  /// The HTTP header value.
  final String value;

  HttpHeader({this.key = '', this.value = ''}) : super(fullyQualifiedName);

  factory HttpHeader.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HttpHeader(
      key: switch (json['key']) {
        null => '',
        Object $1 => decodeString($1),
      },
      value: switch (json['value']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (key.isNotDefault) 'key': key,
    if (value.isNotDefault) 'value': value,
  };

  @override
  String toString() {
    final contents = ['key=$key', 'value=$value'].join(',');
    return 'HttpHeader($contents)';
  }
}

/// The `Status` type defines a logical error model that is suitable for
/// different programming environments, including REST APIs and RPC APIs. It is
/// used by [gRPC](https://github.com/grpc). Each `Status` message contains
/// three pieces of data: error code, error message, and error details.
///
/// You can find out more about this error model and how to work with it in the
/// [API Design Guide](https://cloud.google.com/apis/design/errors).
final class Status extends ProtoMessage {
  static const String fullyQualifiedName = 'google.rpc.Status';

  /// The status code, which should be an enum value of
  /// `google.rpc.Code`.
  final int code;

  /// A developer-facing error message, which should be in English. Any
  /// user-facing error message should be localized and sent in the
  /// `google.rpc.Status.details` field, or localized
  /// by the client.
  final String message;

  /// A list of messages that carry the error details.  There is a common set of
  /// message types for APIs to use.
  final List<Any> details;

  Status({this.code = 0, this.message = '', this.details = const []})
    : super(fullyQualifiedName);

  factory Status.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Status(
      code: switch (json['code']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      message: switch (json['message']) {
        null => '',
        Object $1 => decodeString($1),
      },
      details: switch (json['details']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Any.fromJson(i)],
        _ => throw const FormatException('"details" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (code.isNotDefault) 'code': code,
    if (message.isNotDefault) 'message': message,
    if (details.isNotDefault) 'details': encodeList(details),
  };

  @override
  String toString() {
    final contents = ['code=$code', 'message=$message'].join(',');
    return 'Status($contents)';
  }
}

/// The canonical error codes for gRPC APIs.
///
///
/// Sometimes multiple error codes may apply.  Services should return
/// the most specific error code that applies.  For example, prefer
/// `OUT_OF_RANGE` over `FAILED_PRECONDITION` if both codes apply.
/// Similarly prefer `NOT_FOUND` or `ALREADY_EXISTS` over `FAILED_PRECONDITION`.
final class Code extends ProtoEnum {
  /// Not an error; returned on success.
  ///
  /// HTTP Mapping: 200 OK
  static const ok = Code('OK');

  /// The operation was cancelled, typically by the caller.
  ///
  /// HTTP Mapping: 499 Client Closed Request
  static const cancelled = Code('CANCELLED');

  /// Unknown error.  For example, this error may be returned when
  /// a `Status` value received from another address space belongs to
  /// an error space that is not known in this address space.  Also
  /// errors raised by APIs that do not return enough error information
  /// may be converted to this error.
  ///
  /// HTTP Mapping: 500 Internal Server Error
  static const unknown = Code('UNKNOWN');

  /// The client specified an invalid argument.  Note that this differs
  /// from `FAILED_PRECONDITION`.  `INVALID_ARGUMENT` indicates arguments
  /// that are problematic regardless of the state of the system
  /// (e.g., a malformed file name).
  ///
  /// HTTP Mapping: 400 Bad Request
  static const invalidArgument = Code('INVALID_ARGUMENT');

  /// The deadline expired before the operation could complete. For operations
  /// that change the state of the system, this error may be returned
  /// even if the operation has completed successfully.  For example, a
  /// successful response from a server could have been delayed long
  /// enough for the deadline to expire.
  ///
  /// HTTP Mapping: 504 Gateway Timeout
  static const deadlineExceeded = Code('DEADLINE_EXCEEDED');

  /// Some requested entity (e.g., file or directory) was not found.
  ///
  /// Note to server developers: if a request is denied for an entire class
  /// of users, such as gradual feature rollout or undocumented allowlist,
  /// `NOT_FOUND` may be used. If a request is denied for some users within
  /// a class of users, such as user-based access control, `PERMISSION_DENIED`
  /// must be used.
  ///
  /// HTTP Mapping: 404 Not Found
  static const notFound = Code('NOT_FOUND');

  /// The entity that a client attempted to create (e.g., file or directory)
  /// already exists.
  ///
  /// HTTP Mapping: 409 Conflict
  static const alreadyExists = Code('ALREADY_EXISTS');

  /// The caller does not have permission to execute the specified
  /// operation. `PERMISSION_DENIED` must not be used for rejections
  /// caused by exhausting some resource (use `RESOURCE_EXHAUSTED`
  /// instead for those errors). `PERMISSION_DENIED` must not be
  /// used if the caller can not be identified (use `UNAUTHENTICATED`
  /// instead for those errors). This error code does not imply the
  /// request is valid or the requested entity exists or satisfies
  /// other pre-conditions.
  ///
  /// HTTP Mapping: 403 Forbidden
  static const permissionDenied = Code('PERMISSION_DENIED');

  /// The request does not have valid authentication credentials for the
  /// operation.
  ///
  /// HTTP Mapping: 401 Unauthorized
  static const unauthenticated = Code('UNAUTHENTICATED');

  /// Some resource has been exhausted, perhaps a per-user quota, or
  /// perhaps the entire file system is out of space.
  ///
  /// HTTP Mapping: 429 Too Many Requests
  static const resourceExhausted = Code('RESOURCE_EXHAUSTED');

  /// The operation was rejected because the system is not in a state
  /// required for the operation's execution.  For example, the directory
  /// to be deleted is non-empty, an rmdir operation is applied to
  /// a non-directory, etc.
  ///
  /// Service implementors can use the following guidelines to decide
  /// between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`:
  ///  (a) Use `UNAVAILABLE` if the client can retry just the failing call.
  ///  (b) Use `ABORTED` if the client should retry at a higher level. For
  ///      example, when a client-specified test-and-set fails, indicating the
  ///      client should restart a read-modify-write sequence.
  ///  (c) Use `FAILED_PRECONDITION` if the client should not retry until
  ///      the system state has been explicitly fixed. For example, if an "rmdir"
  ///      fails because the directory is non-empty, `FAILED_PRECONDITION`
  ///      should be returned since the client should not retry unless
  ///      the files are deleted from the directory.
  ///
  /// HTTP Mapping: 400 Bad Request
  static const failedPrecondition = Code('FAILED_PRECONDITION');

  /// The operation was aborted, typically due to a concurrency issue such as
  /// a sequencer check failure or transaction abort.
  ///
  /// See the guidelines above for deciding between `FAILED_PRECONDITION`,
  /// `ABORTED`, and `UNAVAILABLE`.
  ///
  /// HTTP Mapping: 409 Conflict
  static const aborted = Code('ABORTED');

  /// The operation was attempted past the valid range.  E.g., seeking or
  /// reading past end-of-file.
  ///
  /// Unlike `INVALID_ARGUMENT`, this error indicates a problem that may
  /// be fixed if the system state changes. For example, a 32-bit file
  /// system will generate `INVALID_ARGUMENT` if asked to read at an
  /// offset that is not in the range [0,2^32-1], but it will generate
  /// `OUT_OF_RANGE` if asked to read from an offset past the current
  /// file size.
  ///
  /// There is a fair bit of overlap between `FAILED_PRECONDITION` and
  /// `OUT_OF_RANGE`.  We recommend using `OUT_OF_RANGE` (the more specific
  /// error) when it applies so that callers who are iterating through
  /// a space can easily look for an `OUT_OF_RANGE` error to detect when
  /// they are done.
  ///
  /// HTTP Mapping: 400 Bad Request
  static const outOfRange = Code('OUT_OF_RANGE');

  /// The operation is not implemented or is not supported/enabled in this
  /// service.
  ///
  /// HTTP Mapping: 501 Not Implemented
  static const unimplemented = Code('UNIMPLEMENTED');

  /// Internal errors.  This means that some invariants expected by the
  /// underlying system have been broken.  This error code is reserved
  /// for serious errors.
  ///
  /// HTTP Mapping: 500 Internal Server Error
  static const internal = Code('INTERNAL');

  /// The service is currently unavailable.  This is most likely a
  /// transient condition, which can be corrected by retrying with
  /// a backoff. Note that it is not always safe to retry
  /// non-idempotent operations.
  ///
  /// See the guidelines above for deciding between `FAILED_PRECONDITION`,
  /// `ABORTED`, and `UNAVAILABLE`.
  ///
  /// HTTP Mapping: 503 Service Unavailable
  static const unavailable = Code('UNAVAILABLE');

  /// Unrecoverable data loss or corruption.
  ///
  /// HTTP Mapping: 500 Internal Server Error
  static const dataLoss = Code('DATA_LOSS');

  /// The default value for [Code].
  static const $default = ok;

  const Code(super.value);

  factory Code.fromJson(Object? json) => Code(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Code.$value';
}
