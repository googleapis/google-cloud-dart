// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Long Running Operations API.
///
/// Defines types and an abstract service to handle long-running operations.
///
/// [Long-running operations] are a common pattern to handle methods that may take
/// a significant amount of time to execute. Many Google APIs return an `Operation`
/// message (defined in this package) that are roughly analogous to a Future. The
/// operation will eventually complete, though it may still return an error on
/// completion. The client libraries provide helpers to simplify polling of these
/// operations.
///
/// [Long-running operations]: https://google.aip.dev/151
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/rpc.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:http/http.dart' as http;

part 'src/longrunning.p.dart';

const _apiKeys = ['GOOGLE_API_KEY'];

/// Manages long-running operations with an API service.
///
/// When an API method normally takes long time to complete, it can be designed
/// to return `Operation` to the client, and the
/// client can use this interface to receive the real response asynchronously by
/// polling the operation resource, or pass the operation resource to another API
/// (such as Pub/Sub API) to receive the response.  Any API service that returns
/// long-running operations should implement the `Operations` interface so
/// developers can have a consistent client experience.
final class Operations {
  static const _host = 'longrunning.googleapis.com';

  final ServiceClient _client;

  /// Creates a `Operations` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `Operations`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  Operations({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `Operations` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory Operations.fromApiKey([String? apiKey]) =>
      Operations(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Lists operations that match the specified filter in the request. If the
  /// server doesn't support this method, it returns `UNIMPLEMENTED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.name}', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Gets the latest state of a long-running operation.  Clients can use this
  /// method to poll the operation result at intervals as recommended by the API
  /// service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Operation> getOperation(GetOperationRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response);
  }

  /// Deletes a long-running operation. This method indicates that the client is
  /// no longer interested in the operation result. It does not cancel the
  /// operation. If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    await _client.delete(url);
  }

  /// Starts asynchronous cancellation on a long-running operation.  The server
  /// makes a best effort to cancel the operation, but success is not
  /// guaranteed.  If the server doesn't support this method, it returns
  /// `google.rpc.Code.UNIMPLEMENTED`.  Clients can use
  /// `Operations.GetOperation` or
  /// other methods to check whether the cancellation succeeded or whether the
  /// operation completed despite cancellation. On successful cancellation,
  /// the operation is not deleted; instead, it becomes an operation with
  /// an `Operation.error` value with a
  /// `google.rpc.Status.code` of `1`, corresponding to
  /// `Code.CANCELLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}:cancel');
    await _client.post(url, body: request);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// The request message for
/// `Operations.GetOperation`.
final class GetOperationRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.longrunning.GetOperationRequest';

  /// The name of the operation resource.
  final String name;

  GetOperationRequest({this.name = ''}) : super(fullyQualifiedName);

  factory GetOperationRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetOperationRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (name.isNotDefault) 'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetOperationRequest($contents)';
  }
}

/// The request message for
/// `Operations.ListOperations`.
final class ListOperationsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.longrunning.ListOperationsRequest';

  /// The name of the operation's parent resource.
  final String name;

  /// The standard list filter.
  final String filter;

  /// The standard list page size.
  final int pageSize;

  /// The standard list page token.
  final String pageToken;

  /// When set to `true`, operations that are reachable are returned as normal,
  /// and those that are unreachable are returned in the
  /// [ListOperationsResponse.unreachable] field.
  ///
  /// This can only be `true` when reading across collections e.g. when `parent`
  /// is set to `"projects/example/locations/-"`.
  ///
  /// This field is not by default supported and will result in an
  /// `UNIMPLEMENTED` error if set unless explicitly documented otherwise in
  /// service or product specific documentation.
  final bool returnPartialSuccess;

  ListOperationsRequest({
    this.name = '',
    this.filter = '',
    this.pageSize = 0,
    this.pageToken = '',
    this.returnPartialSuccess = false,
  }) : super(fullyQualifiedName);

  factory ListOperationsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListOperationsRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      returnPartialSuccess: switch (json['returnPartialSuccess']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (filter.isNotDefault) 'filter': filter,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (returnPartialSuccess.isNotDefault)
      'returnPartialSuccess': returnPartialSuccess,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'filter=$filter',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'returnPartialSuccess=$returnPartialSuccess',
    ].join(',');
    return 'ListOperationsRequest($contents)';
  }
}

/// The response message for
/// `Operations.ListOperations`.
final class ListOperationsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.longrunning.ListOperationsResponse';

  /// A list of operations that matches the specified filter in the request.
  final List<Operation> operations;

  /// The standard List next-page token.
  final String nextPageToken;

  /// Unordered list. Unreachable resources. Populated when the request sets
  /// `ListOperationsRequest.return_partial_success` and reads across
  /// collections e.g. when attempting to list all resources across all supported
  /// locations.
  final List<String> unreachable;

  ListOperationsResponse({
    this.operations = const [],
    this.nextPageToken = '',
    this.unreachable = const [],
  }) : super(fullyQualifiedName);

  factory ListOperationsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListOperationsResponse(
      operations: switch (json['operations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Operation.fromJson(i)],
        _ => throw const FormatException('"operations" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      unreachable: switch (json['unreachable']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"unreachable" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (operations.isNotDefault) 'operations': encodeList(operations),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
    if (unreachable.isNotDefault) 'unreachable': unreachable,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListOperationsResponse($contents)';
  }
}

/// The request message for
/// `Operations.CancelOperation`.
final class CancelOperationRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.longrunning.CancelOperationRequest';

  /// The name of the operation resource to be cancelled.
  final String name;

  CancelOperationRequest({this.name = ''}) : super(fullyQualifiedName);

  factory CancelOperationRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CancelOperationRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (name.isNotDefault) 'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'CancelOperationRequest($contents)';
  }
}

/// The request message for
/// `Operations.DeleteOperation`.
final class DeleteOperationRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.longrunning.DeleteOperationRequest';

  /// The name of the operation resource to be deleted.
  final String name;

  DeleteOperationRequest({this.name = ''}) : super(fullyQualifiedName);

  factory DeleteOperationRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteOperationRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (name.isNotDefault) 'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteOperationRequest($contents)';
  }
}

/// The request message for
/// `Operations.WaitOperation`.
final class WaitOperationRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.longrunning.WaitOperationRequest';

  /// The name of the operation resource to wait on.
  final String name;

  /// The maximum duration to wait before timing out. If left blank, the wait
  /// will be at most the time permitted by the underlying HTTP/RPC protocol.
  /// If RPC context deadline is also specified, the shorter one will be used.
  final Duration? timeout;

  WaitOperationRequest({this.name = '', this.timeout})
    : super(fullyQualifiedName);

  factory WaitOperationRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return WaitOperationRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      timeout: switch (json['timeout']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (timeout != null) 'timeout': timeout!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'WaitOperationRequest($contents)';
  }
}

/// A message representing the message types used by a long-running operation.
///
/// Example:
///
///     rpc Export(ExportRequest) returns (google.longrunning.Operation) {
///       option (google.longrunning.operation_info) = {
///         response_type: "ExportResponse"
///         metadata_type: "ExportMetadata"
///       };
///     }
final class OperationInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.longrunning.OperationInfo';

  /// Required. The message name of the primary return type for this
  /// long-running operation.
  /// This type will be used to deserialize the LRO's response.
  ///
  /// If the response is in a different package from the rpc, a fully-qualified
  /// message name must be used (e.g. `google.protobuf.Struct`).
  ///
  /// Note: Altering this value constitutes a breaking change.
  final String responseType;

  /// Required. The message name of the metadata type for this long-running
  /// operation.
  ///
  /// If the response is in a different package from the rpc, a fully-qualified
  /// message name must be used (e.g. `google.protobuf.Struct`).
  ///
  /// Note: Altering this value constitutes a breaking change.
  final String metadataType;

  OperationInfo({this.responseType = '', this.metadataType = ''})
    : super(fullyQualifiedName);

  factory OperationInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return OperationInfo(
      responseType: switch (json['responseType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadataType: switch (json['metadataType']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (responseType.isNotDefault) 'responseType': responseType,
    if (metadataType.isNotDefault) 'metadataType': metadataType,
  };

  @override
  String toString() {
    final contents = [
      'responseType=$responseType',
      'metadataType=$metadataType',
    ].join(',');
    return 'OperationInfo($contents)';
  }
}
