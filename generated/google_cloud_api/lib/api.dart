// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Service Config API.
///
/// Lets you define and config your API service.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';

/// `Authentication` defines the authentication configuration for API methods
/// provided by an API service.
///
/// Example:
///
///     name: calendar.googleapis.com
///     authentication:
///       providers:
///       - id: google_calendar_auth
///         jwks_uri: https://www.googleapis.com/oauth2/v1/certs
///         issuer: https://securetoken.google.com
///       rules:
///       - selector: "*"
///         requirements:
///           provider_id: google_calendar_auth
///       - selector: google.calendar.Delegate
///         oauth:
///           canonical_scopes: https://www.googleapis.com/auth/calendar.read
final class Authentication extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Authentication';

  /// A list of authentication rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<AuthenticationRule> rules;

  /// Defines a set of authentication providers that a service supports.
  final List<AuthProvider> providers;

  Authentication({this.rules = const [], this.providers = const []})
    : super(fullyQualifiedName);

  factory Authentication.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Authentication(
      rules: switch (json['rules']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) AuthenticationRule.fromJson(i),
        ],
        _ => throw const FormatException('"rules" is not a list'),
      },
      providers: switch (json['providers']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) AuthProvider.fromJson(i)],
        _ => throw const FormatException('"providers" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (rules.isNotDefault) 'rules': encodeList(rules),
    if (providers.isNotDefault) 'providers': encodeList(providers),
  };

  @override
  String toString() => 'Authentication()';
}

/// Authentication rules for the service.
///
/// By default, if a method has any authentication requirements, every request
/// must include a valid credential matching one of the requirements.
/// It's an error to include more than one kind of credential in a single
/// request.
///
/// If a method doesn't have any auth requirements, request credentials will be
/// ignored.
final class AuthenticationRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.AuthenticationRule';

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String selector;

  /// The requirements for OAuth credentials.
  final OauthRequirements? oauth;

  /// If true, the service accepts API keys without any other credential.
  /// This flag only applies to HTTP and gRPC requests.
  final bool allowWithoutCredential;

  /// Requirements for additional authentication providers.
  final List<AuthRequirement> requirements;

  AuthenticationRule({
    this.selector = '',
    this.oauth,
    this.allowWithoutCredential = false,
    this.requirements = const [],
  }) : super(fullyQualifiedName);

  factory AuthenticationRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthenticationRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      oauth: switch (json['oauth']) {
        null => null,
        Object $1 => OauthRequirements.fromJson($1),
      },
      allowWithoutCredential: switch (json['allowWithoutCredential']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      requirements: switch (json['requirements']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) AuthRequirement.fromJson(i)],
        _ => throw const FormatException('"requirements" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (oauth != null) 'oauth': oauth!.toJson(),
    if (allowWithoutCredential.isNotDefault)
      'allowWithoutCredential': allowWithoutCredential,
    if (requirements.isNotDefault) 'requirements': encodeList(requirements),
  };

  @override
  String toString() {
    final contents = [
      'selector=$selector',
      'allowWithoutCredential=$allowWithoutCredential',
    ].join(',');
    return 'AuthenticationRule($contents)';
  }
}

/// Specifies a location to extract JWT from an API request.
final class JwtLocation extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.JwtLocation';

  /// Specifies HTTP header name to extract JWT token.
  final String? header;

  /// Specifies URL query parameter name to extract JWT token.
  final String? query;

  /// Specifies cookie name to extract JWT token.
  final String? cookie;

  /// The value prefix. The value format is "value_prefix{token}"
  /// Only applies to "in" header type. Must be empty for "in" query type.
  /// If not empty, the header value has to match (case sensitive) this prefix.
  /// If not matched, JWT will not be extracted. If matched, JWT will be
  /// extracted after the prefix is removed.
  ///
  /// For example, for "Authorization: Bearer {JWT}",
  /// value_prefix="Bearer " with a space at the end.
  final String valuePrefix;

  JwtLocation({this.header, this.query, this.cookie, this.valuePrefix = ''})
    : super(fullyQualifiedName);

  factory JwtLocation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return JwtLocation(
      header: switch (json['header']) {
        null => null,
        Object $1 => decodeString($1),
      },
      query: switch (json['query']) {
        null => null,
        Object $1 => decodeString($1),
      },
      cookie: switch (json['cookie']) {
        null => null,
        Object $1 => decodeString($1),
      },
      valuePrefix: switch (json['valuePrefix']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (header != null) 'header': header,
    if (query != null) 'query': query,
    if (cookie != null) 'cookie': cookie,
    if (valuePrefix.isNotDefault) 'valuePrefix': valuePrefix,
  };

  @override
  String toString() {
    final contents = [
      if (header != null) 'header=$header',
      if (query != null) 'query=$query',
      if (cookie != null) 'cookie=$cookie',
      'valuePrefix=$valuePrefix',
    ].join(',');
    return 'JwtLocation($contents)';
  }
}

/// Configuration for an authentication provider, including support for
/// [JSON Web Token
/// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
final class AuthProvider extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.AuthProvider';

  /// The unique identifier of the auth provider. It will be referred to by
  /// `AuthRequirement.provider_id`.
  ///
  /// Example: "bookstore_auth".
  final String id;

  /// Identifies the principal that issued the JWT. See
  /// https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.1
  /// Usually a URL or an email address.
  ///
  /// Example: https://securetoken.google.com
  /// Example: 1234567-compute@developer.gserviceaccount.com
  final String issuer;

  /// URL of the provider's public key set to validate signature of the JWT. See
  /// [OpenID
  /// Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  /// Optional if the key set document:
  ///  - can be retrieved from
  ///    [OpenID
  ///    Discovery](https://openid.net/specs/openid-connect-discovery-1_0.html)
  ///    of the issuer.
  ///  - can be inferred from the email domain of the issuer (e.g. a Google
  ///  service account).
  ///
  /// Example: https://www.googleapis.com/oauth2/v1/certs
  final String jwksUri;

  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted. When this setting is absent, JWTs with audiences:
  ///   - "https://[service.name]/[google.protobuf.Api.name]"
  ///   - "https://[service.name]/"
  /// will be accepted.
  /// For example, if no audiences are in the setting, LibraryService API will
  /// accept JWTs with the following audiences:
  ///   -
  ///   https://library-example.googleapis.com/google.example.library.v1.LibraryService
  ///   - https://library-example.googleapis.com/
  ///
  /// Example:
  ///
  ///     audiences: bookstore_android.apps.googleusercontent.com,
  ///                bookstore_web.apps.googleusercontent.com
  final String audiences;

  /// Redirect URL if JWT token is required but not present or is expired.
  /// Implement authorizationUrl of securityDefinitions in OpenAPI spec.
  final String authorizationUrl;

  /// Defines the locations to extract the JWT.  For now it is only used by the
  /// Cloud Endpoints to store the OpenAPI extension [x-google-jwt-locations]
  /// (https://cloud.google.com/endpoints/docs/openapi/openapi-extensions#x-google-jwt-locations)
  ///
  /// JWT locations can be one of HTTP headers, URL query parameters or
  /// cookies. The rule is that the first match wins.
  ///
  /// If not specified,  default to use following 3 locations:
  ///    1) Authorization: Bearer
  ///    2) x-goog-iap-jwt-assertion
  ///    3) access_token query parameter
  ///
  /// Default locations can be specified as followings:
  ///    jwt_locations:
  ///    - header: Authorization
  ///      value_prefix: "Bearer "
  ///    - header: x-goog-iap-jwt-assertion
  ///    - query: access_token
  final List<JwtLocation> jwtLocations;

  AuthProvider({
    this.id = '',
    this.issuer = '',
    this.jwksUri = '',
    this.audiences = '',
    this.authorizationUrl = '',
    this.jwtLocations = const [],
  }) : super(fullyQualifiedName);

  factory AuthProvider.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthProvider(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      issuer: switch (json['issuer']) {
        null => '',
        Object $1 => decodeString($1),
      },
      jwksUri: switch (json['jwksUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      audiences: switch (json['audiences']) {
        null => '',
        Object $1 => decodeString($1),
      },
      authorizationUrl: switch (json['authorizationUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
      jwtLocations: switch (json['jwtLocations']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) JwtLocation.fromJson(i)],
        _ => throw const FormatException('"jwtLocations" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    if (issuer.isNotDefault) 'issuer': issuer,
    if (jwksUri.isNotDefault) 'jwksUri': jwksUri,
    if (audiences.isNotDefault) 'audiences': audiences,
    if (authorizationUrl.isNotDefault) 'authorizationUrl': authorizationUrl,
    if (jwtLocations.isNotDefault) 'jwtLocations': encodeList(jwtLocations),
  };

  @override
  String toString() {
    final contents = [
      'id=$id',
      'issuer=$issuer',
      'jwksUri=$jwksUri',
      'audiences=$audiences',
      'authorizationUrl=$authorizationUrl',
    ].join(',');
    return 'AuthProvider($contents)';
  }
}

/// OAuth scopes are a way to define data and permissions on data. For example,
/// there are scopes defined for "Read-only access to Google Calendar" and
/// "Access to Cloud Platform". Users can consent to a scope for an application,
/// giving it permission to access that data on their behalf.
///
/// OAuth scope specifications should be fairly coarse grained; a user will need
/// to see and understand the text description of what your scope means.
///
/// In most cases: use one or at most two OAuth scopes for an entire family of
/// products. If your product has multiple APIs, you should probably be sharing
/// the OAuth scope across all of those APIs.
///
/// When you need finer grained OAuth consent screens: talk with your product
/// management about how developers will use them in practice.
///
/// Please note that even though each of the canonical scopes is enough for a
/// request to be accepted and passed to the backend, a request can still fail
/// due to the backend requiring additional scopes or permissions.
final class OauthRequirements extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.OAuthRequirements';

  /// The list of publicly documented OAuth scopes that are allowed access. An
  /// OAuth token containing any of these scopes will be accepted.
  ///
  /// Example:
  ///
  ///      canonical_scopes: https://www.googleapis.com/auth/calendar,
  ///                        https://www.googleapis.com/auth/calendar.read
  final String canonicalScopes;

  OauthRequirements({this.canonicalScopes = ''}) : super(fullyQualifiedName);

  factory OauthRequirements.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return OauthRequirements(
      canonicalScopes: switch (json['canonicalScopes']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (canonicalScopes.isNotDefault) 'canonicalScopes': canonicalScopes,
  };

  @override
  String toString() {
    final contents = ['canonicalScopes=$canonicalScopes'].join(',');
    return 'OAuthRequirements($contents)';
  }
}

/// User-defined authentication requirements, including support for
/// [JSON Web Token
/// (JWT)](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32).
final class AuthRequirement extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.AuthRequirement';

  /// `id` from authentication provider.
  ///
  /// Example:
  ///
  ///     provider_id: bookstore_auth
  final String providerId;

  /// NOTE: This will be deprecated soon, once AuthProvider.audiences is
  /// implemented and accepted in all the runtime components.
  ///
  /// The list of JWT
  /// [audiences](https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32#section-4.1.3).
  /// that are allowed to access. A JWT containing any of these audiences will
  /// be accepted. When this setting is absent, only JWTs with audience
  /// "https://`Service_name`/`API_name`"
  /// will be accepted. For example, if no audiences are in the setting,
  /// LibraryService API will only accept JWTs with the following audience
  /// "https://library-example.googleapis.com/google.example.library.v1.LibraryService".
  ///
  /// Example:
  ///
  ///     audiences: bookstore_android.apps.googleusercontent.com,
  ///                bookstore_web.apps.googleusercontent.com
  final String audiences;

  AuthRequirement({this.providerId = '', this.audiences = ''})
    : super(fullyQualifiedName);

  factory AuthRequirement.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuthRequirement(
      providerId: switch (json['providerId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      audiences: switch (json['audiences']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (providerId.isNotDefault) 'providerId': providerId,
    if (audiences.isNotDefault) 'audiences': audiences,
  };

  @override
  String toString() {
    final contents = [
      'providerId=$providerId',
      'audiences=$audiences',
    ].join(',');
    return 'AuthRequirement($contents)';
  }
}

/// `Backend` defines the backend configuration for a service.
final class Backend extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Backend';

  /// A list of API backend rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<BackendRule> rules;

  Backend({this.rules = const []}) : super(fullyQualifiedName);

  factory Backend.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Backend(
      rules: switch (json['rules']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) BackendRule.fromJson(i)],
        _ => throw const FormatException('"rules" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (rules.isNotDefault) 'rules': encodeList(rules)};

  @override
  String toString() => 'Backend()';
}

/// A backend rule provides configuration for an individual API element.
final class BackendRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.BackendRule';

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String selector;

  /// The address of the API backend.
  ///
  /// The scheme is used to determine the backend protocol and security.
  /// The following schemes are accepted:
  ///
  ///    SCHEME        PROTOCOL    SECURITY
  ///    http://       HTTP        None
  ///    https://      HTTP        TLS
  ///    grpc://       gRPC        None
  ///    grpcs://      gRPC        TLS
  ///
  /// It is recommended to explicitly include a scheme. Leaving out the scheme
  /// may cause constrasting behaviors across platforms.
  ///
  /// If the port is unspecified, the default is:
  /// - 80 for schemes without TLS
  /// - 443 for schemes with TLS
  ///
  /// For HTTP backends, use `protocol`
  /// to specify the protocol version.
  final String address;

  /// The number of seconds to wait for a response from a request. The default
  /// varies based on the request protocol and deployment environment.
  final double deadline;

  /// Deprecated, do not use.
  final double minDeadline;

  /// The number of seconds to wait for the completion of a long running
  /// operation. The default is no deadline.
  final double operationDeadline;

  final BackendRule_PathTranslation pathTranslation;

  /// The JWT audience is used when generating a JWT ID token for the backend.
  /// This ID token will be added in the HTTP "authorization" header, and sent
  /// to the backend.
  final String? jwtAudience;

  /// When disable_auth is true, a JWT ID token won't be generated and the
  /// original "Authorization" HTTP header will be preserved. If the header is
  /// used to carry the original token and is expected by the backend, this
  /// field must be set to true to preserve the header.
  final bool? disableAuth;

  /// The protocol used for sending a request to the backend.
  /// The supported values are "http/1.1" and "h2".
  ///
  /// The default value is inferred from the scheme in the
  /// `address` field:
  ///
  ///    SCHEME        PROTOCOL
  ///    http://       http/1.1
  ///    https://      http/1.1
  ///    grpc://       h2
  ///    grpcs://      h2
  ///
  /// For secure HTTP backends (https://) that support HTTP/2, set this field
  /// to "h2" for improved performance.
  ///
  /// Configuring this field to non-default values is only supported for secure
  /// HTTP backends. This field will be ignored for all other backends.
  ///
  /// See
  /// https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids
  /// for more details on the supported values.
  final String protocol;

  /// The map between request protocol and the backend address.
  final Map<String, BackendRule> overridesByRequestProtocol;

  BackendRule({
    this.selector = '',
    this.address = '',
    this.deadline = 0,
    this.minDeadline = 0,
    this.operationDeadline = 0,
    this.pathTranslation = BackendRule_PathTranslation.$default,
    this.jwtAudience,
    this.disableAuth,
    this.protocol = '',
    this.overridesByRequestProtocol = const {},
  }) : super(fullyQualifiedName);

  factory BackendRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BackendRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      address: switch (json['address']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deadline: switch (json['deadline']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      minDeadline: switch (json['minDeadline']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      operationDeadline: switch (json['operationDeadline']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      pathTranslation: switch (json['pathTranslation']) {
        null => BackendRule_PathTranslation.$default,
        Object $1 => BackendRule_PathTranslation.fromJson($1),
      },
      jwtAudience: switch (json['jwtAudience']) {
        null => null,
        Object $1 => decodeString($1),
      },
      disableAuth: switch (json['disableAuth']) {
        null => null,
        Object $1 => decodeBool($1),
      },
      protocol: switch (json['protocol']) {
        null => '',
        Object $1 => decodeString($1),
      },
      overridesByRequestProtocol: switch (json['overridesByRequestProtocol']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): BackendRule.fromJson(e.value),
        },
        _ => throw const FormatException(
          '"overridesByRequestProtocol" is not an object',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (address.isNotDefault) 'address': address,
    if (deadline.isNotDefault) 'deadline': encodeDouble(deadline),
    if (minDeadline.isNotDefault) 'minDeadline': encodeDouble(minDeadline),
    if (operationDeadline.isNotDefault)
      'operationDeadline': encodeDouble(operationDeadline),
    if (pathTranslation.isNotDefault)
      'pathTranslation': pathTranslation.toJson(),
    if (jwtAudience != null) 'jwtAudience': jwtAudience,
    if (disableAuth != null) 'disableAuth': disableAuth,
    if (protocol.isNotDefault) 'protocol': protocol,
    if (overridesByRequestProtocol.isNotDefault)
      'overridesByRequestProtocol': encodeMap(overridesByRequestProtocol),
  };

  @override
  String toString() {
    final contents = [
      'selector=$selector',
      'address=$address',
      'deadline=$deadline',
      'minDeadline=$minDeadline',
      'operationDeadline=$operationDeadline',
      'pathTranslation=$pathTranslation',
      if (jwtAudience != null) 'jwtAudience=$jwtAudience',
      if (disableAuth != null) 'disableAuth=$disableAuth',
      'protocol=$protocol',
    ].join(',');
    return 'BackendRule($contents)';
  }
}

/// Path Translation specifies how to combine the backend address with the
/// request path in order to produce the appropriate forwarding URL for the
/// request.
///
/// Path Translation is applicable only to HTTP-based backends. Backends which
/// do not accept requests over HTTP/HTTPS should leave `path_translation`
/// unspecified.
final class BackendRule_PathTranslation extends ProtoEnum {
  static const pathTranslationUnspecified = BackendRule_PathTranslation(
    'PATH_TRANSLATION_UNSPECIFIED',
  );

  /// Use the backend address as-is, with no modification to the path. If the
  /// URL pattern contains variables, the variable names and values will be
  /// appended to the query string. If a query string parameter and a URL
  /// pattern variable have the same name, this may result in duplicate keys in
  /// the query string.
  ///
  /// # Examples
  ///
  /// Given the following operation config:
  ///
  ///     Method path:        /api/company/{cid}/user/{uid}
  ///     Backend address:    https://example.cloudfunctions.net/getUser
  ///
  /// Requests to the following request paths will call the backend at the
  /// translated path:
  ///
  ///     Request path: /api/company/widgetworks/user/johndoe
  ///     Translated:
  ///     https://example.cloudfunctions.net/getUser?cid=widgetworks&uid=johndoe
  ///
  ///     Request path: /api/company/widgetworks/user/johndoe?timezone=EST
  ///     Translated:
  ///     https://example.cloudfunctions.net/getUser?timezone=EST&cid=widgetworks&uid=johndoe
  static const constantAddress = BackendRule_PathTranslation(
    'CONSTANT_ADDRESS',
  );

  /// The request path will be appended to the backend address.
  ///
  /// # Examples
  ///
  /// Given the following operation config:
  ///
  ///     Method path:        /api/company/{cid}/user/{uid}
  ///     Backend address:    https://example.appspot.com
  ///
  /// Requests to the following request paths will call the backend at the
  /// translated path:
  ///
  ///     Request path: /api/company/widgetworks/user/johndoe
  ///     Translated:
  ///     https://example.appspot.com/api/company/widgetworks/user/johndoe
  ///
  ///     Request path: /api/company/widgetworks/user/johndoe?timezone=EST
  ///     Translated:
  ///     https://example.appspot.com/api/company/widgetworks/user/johndoe?timezone=EST
  static const appendPathToAddress = BackendRule_PathTranslation(
    'APPEND_PATH_TO_ADDRESS',
  );

  /// The default value for [BackendRule_PathTranslation].
  static const $default = pathTranslationUnspecified;

  const BackendRule_PathTranslation(super.value);

  factory BackendRule_PathTranslation.fromJson(Object? json) =>
      BackendRule_PathTranslation(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PathTranslation.$value';
}

/// Billing related configuration of the service.
///
/// The following example shows how to configure monitored resources and metrics
/// for billing, `consumer_destinations` is the only supported destination and
/// the monitored resources need at least one label key
/// `cloud.googleapis.com/location` to indicate the location of the billing
/// usage, using different monitored resources between monitoring and billing is
/// recommended so they can be evolved independently:
///
///
///     monitored_resources:
///     - type: library.googleapis.com/billing_branch
///       labels:
///       - key: cloud.googleapis.com/location
///         description: |
///           Predefined label to support billing location restriction.
///       - key: city
///         description: |
///           Custom label to define the city where the library branch is located
///           in.
///       - key: name
///         description: Custom label to define the name of the library branch.
///     metrics:
///     - name: library.googleapis.com/book/borrowed_count
///       metric_kind: DELTA
///       value_type: INT64
///       unit: "1"
///     billing:
///       consumer_destinations:
///       - monitored_resource: library.googleapis.com/billing_branch
///         metrics:
///         - library.googleapis.com/book/borrowed_count
final class Billing extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Billing';

  /// Billing configurations for sending metrics to the consumer project.
  /// There can be multiple consumer destinations per service, each one must have
  /// a different monitored resource type. A metric can be used in at most
  /// one consumer destination.
  final List<Billing_BillingDestination> consumerDestinations;

  Billing({this.consumerDestinations = const []}) : super(fullyQualifiedName);

  factory Billing.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Billing(
      consumerDestinations: switch (json['consumerDestinations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Billing_BillingDestination.fromJson(i),
        ],
        _ => throw const FormatException(
          '"consumerDestinations" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (consumerDestinations.isNotDefault)
      'consumerDestinations': encodeList(consumerDestinations),
  };

  @override
  String toString() => 'Billing()';
}

/// Configuration of a specific billing destination (Currently only support
/// bill against consumer project).
final class Billing_BillingDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Billing.BillingDestination';

  /// The monitored resource type. The type must be defined in
  /// `Service.monitored_resources`
  /// section.
  final String monitoredResource;

  /// Names of the metrics to report to this billing destination.
  /// Each name must be defined in
  /// `Service.metrics` section.
  final List<String> metrics;

  Billing_BillingDestination({
    this.monitoredResource = '',
    this.metrics = const [],
  }) : super(fullyQualifiedName);

  factory Billing_BillingDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Billing_BillingDestination(
      monitoredResource: switch (json['monitoredResource']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metrics: switch (json['metrics']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"metrics" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (monitoredResource.isNotDefault) 'monitoredResource': monitoredResource,
    if (metrics.isNotDefault) 'metrics': metrics,
  };

  @override
  String toString() {
    final contents = ['monitoredResource=$monitoredResource'].join(',');
    return 'BillingDestination($contents)';
  }
}

/// Required information for every language.
final class CommonLanguageSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.CommonLanguageSettings';

  /// Link to automatically generated reference documentation.  Example:
  /// https://cloud.google.com/nodejs/docs/reference/asset/latest
  final String referenceDocsUri;

  /// The destination where API teams want this client library to be published.
  final List<ClientLibraryDestination> destinations;

  /// Configuration for which RPCs should be generated in the GAPIC client.
  final SelectiveGapicGeneration? selectiveGapicGeneration;

  CommonLanguageSettings({
    this.referenceDocsUri = '',
    this.destinations = const [],
    this.selectiveGapicGeneration,
  }) : super(fullyQualifiedName);

  factory CommonLanguageSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CommonLanguageSettings(
      referenceDocsUri: switch (json['referenceDocsUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      destinations: switch (json['destinations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ClientLibraryDestination.fromJson(i),
        ],
        _ => throw const FormatException('"destinations" is not a list'),
      },
      selectiveGapicGeneration: switch (json['selectiveGapicGeneration']) {
        null => null,
        Object $1 => SelectiveGapicGeneration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (referenceDocsUri.isNotDefault) 'referenceDocsUri': referenceDocsUri,
    if (destinations.isNotDefault) 'destinations': encodeList(destinations),
    if (selectiveGapicGeneration != null)
      'selectiveGapicGeneration': selectiveGapicGeneration!.toJson(),
  };

  @override
  String toString() {
    final contents = ['referenceDocsUri=$referenceDocsUri'].join(',');
    return 'CommonLanguageSettings($contents)';
  }
}

/// Details about how and where to publish client libraries.
final class ClientLibrarySettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ClientLibrarySettings';

  /// Version of the API to apply these settings to. This is the full protobuf
  /// package for the API, ending in the version element.
  /// Examples: "google.cloud.speech.v1" and "google.spanner.admin.database.v1".
  final String version;

  /// Launch stage of this version of the API.
  final LaunchStage launchStage;

  /// When using transport=rest, the client request will encode enums as
  /// numbers rather than strings.
  final bool restNumericEnums;

  /// Settings for legacy Java features, supported in the Service YAML.
  final JavaSettings? javaSettings;

  /// Settings for C++ client libraries.
  final CppSettings? cppSettings;

  /// Settings for PHP client libraries.
  final PhpSettings? phpSettings;

  /// Settings for Python client libraries.
  final PythonSettings? pythonSettings;

  /// Settings for Node client libraries.
  final NodeSettings? nodeSettings;

  /// Settings for .NET client libraries.
  final DotnetSettings? dotnetSettings;

  /// Settings for Ruby client libraries.
  final RubySettings? rubySettings;

  /// Settings for Go client libraries.
  final GoSettings? goSettings;

  ClientLibrarySettings({
    this.version = '',
    this.launchStage = LaunchStage.$default,
    this.restNumericEnums = false,
    this.javaSettings,
    this.cppSettings,
    this.phpSettings,
    this.pythonSettings,
    this.nodeSettings,
    this.dotnetSettings,
    this.rubySettings,
    this.goSettings,
  }) : super(fullyQualifiedName);

  factory ClientLibrarySettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ClientLibrarySettings(
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
      launchStage: switch (json['launchStage']) {
        null => LaunchStage.$default,
        Object $1 => LaunchStage.fromJson($1),
      },
      restNumericEnums: switch (json['restNumericEnums']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      javaSettings: switch (json['javaSettings']) {
        null => null,
        Object $1 => JavaSettings.fromJson($1),
      },
      cppSettings: switch (json['cppSettings']) {
        null => null,
        Object $1 => CppSettings.fromJson($1),
      },
      phpSettings: switch (json['phpSettings']) {
        null => null,
        Object $1 => PhpSettings.fromJson($1),
      },
      pythonSettings: switch (json['pythonSettings']) {
        null => null,
        Object $1 => PythonSettings.fromJson($1),
      },
      nodeSettings: switch (json['nodeSettings']) {
        null => null,
        Object $1 => NodeSettings.fromJson($1),
      },
      dotnetSettings: switch (json['dotnetSettings']) {
        null => null,
        Object $1 => DotnetSettings.fromJson($1),
      },
      rubySettings: switch (json['rubySettings']) {
        null => null,
        Object $1 => RubySettings.fromJson($1),
      },
      goSettings: switch (json['goSettings']) {
        null => null,
        Object $1 => GoSettings.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (version.isNotDefault) 'version': version,
    if (launchStage.isNotDefault) 'launchStage': launchStage.toJson(),
    if (restNumericEnums.isNotDefault) 'restNumericEnums': restNumericEnums,
    if (javaSettings != null) 'javaSettings': javaSettings!.toJson(),
    if (cppSettings != null) 'cppSettings': cppSettings!.toJson(),
    if (phpSettings != null) 'phpSettings': phpSettings!.toJson(),
    if (pythonSettings != null) 'pythonSettings': pythonSettings!.toJson(),
    if (nodeSettings != null) 'nodeSettings': nodeSettings!.toJson(),
    if (dotnetSettings != null) 'dotnetSettings': dotnetSettings!.toJson(),
    if (rubySettings != null) 'rubySettings': rubySettings!.toJson(),
    if (goSettings != null) 'goSettings': goSettings!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'version=$version',
      'launchStage=$launchStage',
      'restNumericEnums=$restNumericEnums',
    ].join(',');
    return 'ClientLibrarySettings($contents)';
  }
}

/// This message configures the settings for publishing [Google Cloud Client
/// libraries](https://cloud.google.com/apis/docs/cloud-client-libraries)
/// generated from the service config.
final class Publishing extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Publishing';

  /// A list of API method settings, e.g. the behavior for methods that use the
  /// long-running operation pattern.
  final List<MethodSettings> methodSettings;

  /// Link to a *public* URI where users can report issues.  Example:
  /// https://issuetracker.google.com/issues/new?component=190865&template=1161103
  final String newIssueUri;

  /// Link to product home page.  Example:
  /// https://cloud.google.com/asset-inventory/docs/overview
  final String documentationUri;

  /// Used as a tracking tag when collecting data about the APIs developer
  /// relations artifacts like docs, packages delivered to package managers,
  /// etc.  Example: "speech".
  final String apiShortName;

  /// GitHub label to apply to issues and pull requests opened for this API.
  final String githubLabel;

  /// GitHub teams to be added to CODEOWNERS in the directory in GitHub
  /// containing source code for the client libraries for this API.
  final List<String> codeownerGithubTeams;

  /// A prefix used in sample code when demarking regions to be included in
  /// documentation.
  final String docTagPrefix;

  /// For whom the client library is being published.
  final ClientLibraryOrganization organization;

  /// Client library settings.  If the same version string appears multiple
  /// times in this list, then the last one wins.  Settings from earlier
  /// settings with the same version string are discarded.
  final List<ClientLibrarySettings> librarySettings;

  /// Optional link to proto reference documentation.  Example:
  /// https://cloud.google.com/pubsub/lite/docs/reference/rpc
  final String protoReferenceDocumentationUri;

  /// Optional link to REST reference documentation.  Example:
  /// https://cloud.google.com/pubsub/lite/docs/reference/rest
  final String restReferenceDocumentationUri;

  Publishing({
    this.methodSettings = const [],
    this.newIssueUri = '',
    this.documentationUri = '',
    this.apiShortName = '',
    this.githubLabel = '',
    this.codeownerGithubTeams = const [],
    this.docTagPrefix = '',
    this.organization = ClientLibraryOrganization.$default,
    this.librarySettings = const [],
    this.protoReferenceDocumentationUri = '',
    this.restReferenceDocumentationUri = '',
  }) : super(fullyQualifiedName);

  factory Publishing.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Publishing(
      methodSettings: switch (json['methodSettings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) MethodSettings.fromJson(i)],
        _ => throw const FormatException('"methodSettings" is not a list'),
      },
      newIssueUri: switch (json['newIssueUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      documentationUri: switch (json['documentationUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      apiShortName: switch (json['apiShortName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      githubLabel: switch (json['githubLabel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      codeownerGithubTeams: switch (json['codeownerGithubTeams']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"codeownerGithubTeams" is not a list',
        ),
      },
      docTagPrefix: switch (json['docTagPrefix']) {
        null => '',
        Object $1 => decodeString($1),
      },
      organization: switch (json['organization']) {
        null => ClientLibraryOrganization.$default,
        Object $1 => ClientLibraryOrganization.fromJson($1),
      },
      librarySettings: switch (json['librarySettings']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ClientLibrarySettings.fromJson(i),
        ],
        _ => throw const FormatException('"librarySettings" is not a list'),
      },
      protoReferenceDocumentationUri:
          switch (json['protoReferenceDocumentationUri']) {
            null => '',
            Object $1 => decodeString($1),
          },
      restReferenceDocumentationUri:
          switch (json['restReferenceDocumentationUri']) {
            null => '',
            Object $1 => decodeString($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (methodSettings.isNotDefault)
      'methodSettings': encodeList(methodSettings),
    if (newIssueUri.isNotDefault) 'newIssueUri': newIssueUri,
    if (documentationUri.isNotDefault) 'documentationUri': documentationUri,
    if (apiShortName.isNotDefault) 'apiShortName': apiShortName,
    if (githubLabel.isNotDefault) 'githubLabel': githubLabel,
    if (codeownerGithubTeams.isNotDefault)
      'codeownerGithubTeams': codeownerGithubTeams,
    if (docTagPrefix.isNotDefault) 'docTagPrefix': docTagPrefix,
    if (organization.isNotDefault) 'organization': organization.toJson(),
    if (librarySettings.isNotDefault)
      'librarySettings': encodeList(librarySettings),
    if (protoReferenceDocumentationUri.isNotDefault)
      'protoReferenceDocumentationUri': protoReferenceDocumentationUri,
    if (restReferenceDocumentationUri.isNotDefault)
      'restReferenceDocumentationUri': restReferenceDocumentationUri,
  };

  @override
  String toString() {
    final contents = [
      'newIssueUri=$newIssueUri',
      'documentationUri=$documentationUri',
      'apiShortName=$apiShortName',
      'githubLabel=$githubLabel',
      'docTagPrefix=$docTagPrefix',
      'organization=$organization',
      'protoReferenceDocumentationUri=$protoReferenceDocumentationUri',
      'restReferenceDocumentationUri=$restReferenceDocumentationUri',
    ].join(',');
    return 'Publishing($contents)';
  }
}

/// Settings for Java client libraries.
final class JavaSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.JavaSettings';

  /// The package name to use in Java. Clobbers the java_package option
  /// set in the protobuf. This should be used **only** by APIs
  /// who have already set the language_settings.java.package_name" field
  /// in gapic.yaml. API teams should use the protobuf java_package option
  /// where possible.
  ///
  /// Example of a YAML configuration::
  ///
  ///  publishing:
  ///    java_settings:
  ///      library_package: com.google.cloud.pubsub.v1
  final String libraryPackage;

  /// Configure the Java class name to use instead of the service's for its
  /// corresponding generated GAPIC client. Keys are fully-qualified
  /// service names as they appear in the protobuf (including the full
  /// the language_settings.java.interface_names" field in gapic.yaml. API
  /// teams should otherwise use the service name as it appears in the
  /// protobuf.
  ///
  /// Example of a YAML configuration::
  ///
  ///  publishing:
  ///    java_settings:
  ///      service_class_names:
  ///        - google.pubsub.v1.Publisher: TopicAdmin
  ///        - google.pubsub.v1.Subscriber: SubscriptionAdmin
  final Map<String, String> serviceClassNames;

  /// Some settings.
  final CommonLanguageSettings? common;

  JavaSettings({
    this.libraryPackage = '',
    this.serviceClassNames = const {},
    this.common,
  }) : super(fullyQualifiedName);

  factory JavaSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return JavaSettings(
      libraryPackage: switch (json['libraryPackage']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceClassNames: switch (json['serviceClassNames']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException(
          '"serviceClassNames" is not an object',
        ),
      },
      common: switch (json['common']) {
        null => null,
        Object $1 => CommonLanguageSettings.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (libraryPackage.isNotDefault) 'libraryPackage': libraryPackage,
    if (serviceClassNames.isNotDefault) 'serviceClassNames': serviceClassNames,
    if (common != null) 'common': common!.toJson(),
  };

  @override
  String toString() {
    final contents = ['libraryPackage=$libraryPackage'].join(',');
    return 'JavaSettings($contents)';
  }
}

/// Settings for C++ client libraries.
final class CppSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.CppSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  CppSettings({this.common}) : super(fullyQualifiedName);

  factory CppSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CppSettings(
      common: switch (json['common']) {
        null => null,
        Object $1 => CommonLanguageSettings.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (common != null) 'common': common!.toJson()};

  @override
  String toString() => 'CppSettings()';
}

/// Settings for Php client libraries.
final class PhpSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.PhpSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  PhpSettings({this.common}) : super(fullyQualifiedName);

  factory PhpSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PhpSettings(
      common: switch (json['common']) {
        null => null,
        Object $1 => CommonLanguageSettings.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (common != null) 'common': common!.toJson()};

  @override
  String toString() => 'PhpSettings()';
}

/// Settings for Python client libraries.
final class PythonSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.PythonSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  /// Experimental features to be included during client library generation.
  final PythonSettings_ExperimentalFeatures? experimentalFeatures;

  PythonSettings({this.common, this.experimentalFeatures})
    : super(fullyQualifiedName);

  factory PythonSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PythonSettings(
      common: switch (json['common']) {
        null => null,
        Object $1 => CommonLanguageSettings.fromJson($1),
      },
      experimentalFeatures: switch (json['experimentalFeatures']) {
        null => null,
        Object $1 => PythonSettings_ExperimentalFeatures.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (common != null) 'common': common!.toJson(),
    if (experimentalFeatures != null)
      'experimentalFeatures': experimentalFeatures!.toJson(),
  };

  @override
  String toString() => 'PythonSettings()';
}

/// Experimental features to be included during client library generation.
/// These fields will be deprecated once the feature graduates and is enabled
/// by default.
final class PythonSettings_ExperimentalFeatures extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.PythonSettings.ExperimentalFeatures';

  /// Enables generation of asynchronous REST clients if `rest` transport is
  /// enabled. By default, asynchronous REST clients will not be generated.
  /// This feature will be enabled by default 1 month after launching the
  /// feature in preview packages.
  final bool restAsyncIoEnabled;

  /// Enables generation of protobuf code using new types that are more
  /// Pythonic which are included in `protobuf>=5.29.x`. This feature will be
  /// enabled by default 1 month after launching the feature in preview
  /// packages.
  final bool protobufPythonicTypesEnabled;

  /// Disables generation of an unversioned Python package for this client
  /// library. This means that the module names will need to be versioned in
  /// import statements. For example `import google.cloud.library_v2` instead
  /// of `import google.cloud.library`.
  final bool unversionedPackageDisabled;

  PythonSettings_ExperimentalFeatures({
    this.restAsyncIoEnabled = false,
    this.protobufPythonicTypesEnabled = false,
    this.unversionedPackageDisabled = false,
  }) : super(fullyQualifiedName);

  factory PythonSettings_ExperimentalFeatures.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PythonSettings_ExperimentalFeatures(
      restAsyncIoEnabled: switch (json['restAsyncIoEnabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      protobufPythonicTypesEnabled:
          switch (json['protobufPythonicTypesEnabled']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      unversionedPackageDisabled: switch (json['unversionedPackageDisabled']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (restAsyncIoEnabled.isNotDefault)
      'restAsyncIoEnabled': restAsyncIoEnabled,
    if (protobufPythonicTypesEnabled.isNotDefault)
      'protobufPythonicTypesEnabled': protobufPythonicTypesEnabled,
    if (unversionedPackageDisabled.isNotDefault)
      'unversionedPackageDisabled': unversionedPackageDisabled,
  };

  @override
  String toString() {
    final contents = [
      'restAsyncIoEnabled=$restAsyncIoEnabled',
      'protobufPythonicTypesEnabled=$protobufPythonicTypesEnabled',
      'unversionedPackageDisabled=$unversionedPackageDisabled',
    ].join(',');
    return 'ExperimentalFeatures($contents)';
  }
}

/// Settings for Node client libraries.
final class NodeSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.NodeSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  NodeSettings({this.common}) : super(fullyQualifiedName);

  factory NodeSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return NodeSettings(
      common: switch (json['common']) {
        null => null,
        Object $1 => CommonLanguageSettings.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (common != null) 'common': common!.toJson()};

  @override
  String toString() => 'NodeSettings()';
}

/// Settings for Dotnet client libraries.
final class DotnetSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.DotnetSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  /// Map from original service names to renamed versions.
  /// This is used when the default generated types
  /// would cause a naming conflict. (Neither name is
  /// fully-qualified.)
  /// Example: Subscriber to SubscriberServiceApi.
  final Map<String, String> renamedServices;

  /// Map from full resource types to the effective short name
  /// for the resource. This is used when otherwise resource
  /// named from different services would cause naming collisions.
  /// Example entry:
  /// "datalabeling.googleapis.com/Dataset": "DataLabelingDataset"
  final Map<String, String> renamedResources;

  /// List of full resource types to ignore during generation.
  /// This is typically used for API-specific Location resources,
  /// which should be handled by the generator as if they were actually
  /// the common Location resources.
  /// Example entry: "documentai.googleapis.com/Location"
  final List<String> ignoredResources;

  /// Namespaces which must be aliased in snippets due to
  /// a known (but non-generator-predictable) naming collision
  final List<String> forcedNamespaceAliases;

  /// Method signatures (in the form "service.method(signature)")
  /// which are provided separately, so shouldn't be generated.
  /// Snippets *calling* these methods are still generated, however.
  final List<String> handwrittenSignatures;

  DotnetSettings({
    this.common,
    this.renamedServices = const {},
    this.renamedResources = const {},
    this.ignoredResources = const [],
    this.forcedNamespaceAliases = const [],
    this.handwrittenSignatures = const [],
  }) : super(fullyQualifiedName);

  factory DotnetSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DotnetSettings(
      common: switch (json['common']) {
        null => null,
        Object $1 => CommonLanguageSettings.fromJson($1),
      },
      renamedServices: switch (json['renamedServices']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"renamedServices" is not an object'),
      },
      renamedResources: switch (json['renamedResources']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"renamedResources" is not an object'),
      },
      ignoredResources: switch (json['ignoredResources']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"ignoredResources" is not a list'),
      },
      forcedNamespaceAliases: switch (json['forcedNamespaceAliases']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"forcedNamespaceAliases" is not a list',
        ),
      },
      handwrittenSignatures: switch (json['handwrittenSignatures']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"handwrittenSignatures" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (common != null) 'common': common!.toJson(),
    if (renamedServices.isNotDefault) 'renamedServices': renamedServices,
    if (renamedResources.isNotDefault) 'renamedResources': renamedResources,
    if (ignoredResources.isNotDefault) 'ignoredResources': ignoredResources,
    if (forcedNamespaceAliases.isNotDefault)
      'forcedNamespaceAliases': forcedNamespaceAliases,
    if (handwrittenSignatures.isNotDefault)
      'handwrittenSignatures': handwrittenSignatures,
  };

  @override
  String toString() => 'DotnetSettings()';
}

/// Settings for Ruby client libraries.
final class RubySettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.RubySettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  RubySettings({this.common}) : super(fullyQualifiedName);

  factory RubySettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RubySettings(
      common: switch (json['common']) {
        null => null,
        Object $1 => CommonLanguageSettings.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {if (common != null) 'common': common!.toJson()};

  @override
  String toString() => 'RubySettings()';
}

/// Settings for Go client libraries.
final class GoSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.GoSettings';

  /// Some settings.
  final CommonLanguageSettings? common;

  /// Map of service names to renamed services. Keys are the package relative
  /// service names and values are the name to be used for the service client
  /// and call options.
  ///
  /// publishing:
  ///   go_settings:
  ///     renamed_services:
  ///       Publisher: TopicAdmin
  final Map<String, String> renamedServices;

  GoSettings({this.common, this.renamedServices = const {}})
    : super(fullyQualifiedName);

  factory GoSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GoSettings(
      common: switch (json['common']) {
        null => null,
        Object $1 => CommonLanguageSettings.fromJson($1),
      },
      renamedServices: switch (json['renamedServices']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"renamedServices" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (common != null) 'common': common!.toJson(),
    if (renamedServices.isNotDefault) 'renamedServices': renamedServices,
  };

  @override
  String toString() => 'GoSettings()';
}

/// Describes the generator configuration for a method.
final class MethodSettings extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MethodSettings';

  /// The fully qualified name of the method, for which the options below apply.
  /// This is used to find the method to apply the options.
  ///
  /// Example:
  ///
  ///    publishing:
  ///      method_settings:
  ///      - selector: google.storage.control.v2.StorageControl.CreateFolder
  ///        # method settings for CreateFolder...
  final String selector;

  /// Describes settings to use for long-running operations when generating
  /// API methods for RPCs. Complements RPCs that use the annotations in
  /// google/longrunning/operations.proto.
  ///
  /// Example of a YAML configuration::
  ///
  ///    publishing:
  ///      method_settings:
  ///      - selector: google.cloud.speech.v2.Speech.BatchRecognize
  ///        long_running:
  ///          initial_poll_delay: 60s # 1 minute
  ///          poll_delay_multiplier: 1.5
  ///          max_poll_delay: 360s # 6 minutes
  ///          total_poll_timeout: 54000s # 90 minutes
  final MethodSettings_LongRunning? longRunning;

  /// List of top-level fields of the request message, that should be
  /// automatically populated by the client libraries based on their
  /// (google.api.field_info).format. Currently supported format: UUID4.
  ///
  /// Example of a YAML configuration:
  ///
  ///    publishing:
  ///      method_settings:
  ///      - selector: google.example.v1.ExampleService.CreateExample
  ///        auto_populated_fields:
  ///        - request_id
  final List<String> autoPopulatedFields;

  MethodSettings({
    this.selector = '',
    this.longRunning,
    this.autoPopulatedFields = const [],
  }) : super(fullyQualifiedName);

  factory MethodSettings.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MethodSettings(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      longRunning: switch (json['longRunning']) {
        null => null,
        Object $1 => MethodSettings_LongRunning.fromJson($1),
      },
      autoPopulatedFields: switch (json['autoPopulatedFields']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"autoPopulatedFields" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (longRunning != null) 'longRunning': longRunning!.toJson(),
    if (autoPopulatedFields.isNotDefault)
      'autoPopulatedFields': autoPopulatedFields,
  };

  @override
  String toString() {
    final contents = ['selector=$selector'].join(',');
    return 'MethodSettings($contents)';
  }
}

/// Describes settings to use when generating API methods that use the
/// long-running operation pattern.
/// All default values below are from those used in the client library
/// generators (e.g.
/// [Java](https://github.com/googleapis/gapic-generator-java/blob/04c2faa191a9b5a10b92392fe8482279c4404803/src/main/java/com/google/api/generator/gapic/composer/common/RetrySettingsComposer.java)).
final class MethodSettings_LongRunning extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.MethodSettings.LongRunning';

  /// Initial delay after which the first poll request will be made.
  /// Default value: 5 seconds.
  final Duration? initialPollDelay;

  /// Multiplier to gradually increase delay between subsequent polls until it
  /// reaches max_poll_delay.
  /// Default value: 1.5.
  final double pollDelayMultiplier;

  /// Maximum time between two subsequent poll requests.
  /// Default value: 45 seconds.
  final Duration? maxPollDelay;

  /// Total polling timeout.
  /// Default value: 5 minutes.
  final Duration? totalPollTimeout;

  MethodSettings_LongRunning({
    this.initialPollDelay,
    this.pollDelayMultiplier = 0,
    this.maxPollDelay,
    this.totalPollTimeout,
  }) : super(fullyQualifiedName);

  factory MethodSettings_LongRunning.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MethodSettings_LongRunning(
      initialPollDelay: switch (json['initialPollDelay']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      pollDelayMultiplier: switch (json['pollDelayMultiplier']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      maxPollDelay: switch (json['maxPollDelay']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      totalPollTimeout: switch (json['totalPollTimeout']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (initialPollDelay != null)
      'initialPollDelay': initialPollDelay!.toJson(),
    if (pollDelayMultiplier.isNotDefault)
      'pollDelayMultiplier': encodeDouble(pollDelayMultiplier),
    if (maxPollDelay != null) 'maxPollDelay': maxPollDelay!.toJson(),
    if (totalPollTimeout != null)
      'totalPollTimeout': totalPollTimeout!.toJson(),
  };

  @override
  String toString() {
    final contents = ['pollDelayMultiplier=$pollDelayMultiplier'].join(',');
    return 'LongRunning($contents)';
  }
}

/// This message is used to configure the generation of a subset of the RPCs in
/// a service for client libraries.
final class SelectiveGapicGeneration extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.SelectiveGapicGeneration';

  /// An allowlist of the fully qualified names of RPCs that should be included
  /// on public client surfaces.
  final List<String> methods;

  /// Setting this to true indicates to the client generators that methods
  /// that would be excluded from the generation should instead be generated
  /// in a way that indicates these methods should not be consumed by
  /// end users. How this is expressed is up to individual language
  /// implementations to decide. Some examples may be: added annotations,
  /// obfuscated identifiers, or other language idiomatic patterns.
  final bool generateOmittedAsInternal;

  SelectiveGapicGeneration({
    this.methods = const [],
    this.generateOmittedAsInternal = false,
  }) : super(fullyQualifiedName);

  factory SelectiveGapicGeneration.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SelectiveGapicGeneration(
      methods: switch (json['methods']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"methods" is not a list'),
      },
      generateOmittedAsInternal: switch (json['generateOmittedAsInternal']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (methods.isNotDefault) 'methods': methods,
    if (generateOmittedAsInternal.isNotDefault)
      'generateOmittedAsInternal': generateOmittedAsInternal,
  };

  @override
  String toString() {
    final contents = [
      'generateOmittedAsInternal=$generateOmittedAsInternal',
    ].join(',');
    return 'SelectiveGapicGeneration($contents)';
  }
}

/// Output generated from semantically comparing two versions of a service
/// configuration.
///
/// Includes detailed information about a field that have changed with
/// applicable advice about potential consequences for the change, such as
/// backwards-incompatibility.
final class ConfigChange extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ConfigChange';

  /// Object hierarchy path to the change, with levels separated by a '.'
  /// character. For repeated fields, an applicable unique identifier field is
  /// used for the index (usually selector, name, or id). For maps, the term
  /// 'key' is used. If the field has no unique identifier, the numeric index
  /// is used.
  /// Examples:
  /// - visibility.rules[selector=="google.LibraryService.ListBooks"].restriction
  /// - quota.metric_rules[selector=="google"].metric_costs[key=="reads"].value
  /// - logging.producer_destinations[0]
  final String element;

  /// Value of the changed object in the old Service configuration,
  /// in JSON format. This field will not be populated if ChangeType == ADDED.
  final String oldValue;

  /// Value of the changed object in the new Service configuration,
  /// in JSON format. This field will not be populated if ChangeType == REMOVED.
  final String newValue;

  /// The type for this change, either ADDED, REMOVED, or MODIFIED.
  final ChangeType changeType;

  /// Collection of advice provided for this change, useful for determining the
  /// possible impact of this change.
  final List<Advice> advices;

  ConfigChange({
    this.element = '',
    this.oldValue = '',
    this.newValue = '',
    this.changeType = ChangeType.$default,
    this.advices = const [],
  }) : super(fullyQualifiedName);

  factory ConfigChange.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ConfigChange(
      element: switch (json['element']) {
        null => '',
        Object $1 => decodeString($1),
      },
      oldValue: switch (json['oldValue']) {
        null => '',
        Object $1 => decodeString($1),
      },
      newValue: switch (json['newValue']) {
        null => '',
        Object $1 => decodeString($1),
      },
      changeType: switch (json['changeType']) {
        null => ChangeType.$default,
        Object $1 => ChangeType.fromJson($1),
      },
      advices: switch (json['advices']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Advice.fromJson(i)],
        _ => throw const FormatException('"advices" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (element.isNotDefault) 'element': element,
    if (oldValue.isNotDefault) 'oldValue': oldValue,
    if (newValue.isNotDefault) 'newValue': newValue,
    if (changeType.isNotDefault) 'changeType': changeType.toJson(),
    if (advices.isNotDefault) 'advices': encodeList(advices),
  };

  @override
  String toString() {
    final contents = [
      'element=$element',
      'oldValue=$oldValue',
      'newValue=$newValue',
      'changeType=$changeType',
    ].join(',');
    return 'ConfigChange($contents)';
  }
}

/// Generated advice about this change, used for providing more
/// information about how a change will affect the existing service.
final class Advice extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Advice';

  /// Useful description for why this advice was applied and what actions should
  /// be taken to mitigate any implied risks.
  final String description;

  Advice({this.description = ''}) : super(fullyQualifiedName);

  factory Advice.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Advice(
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (description.isNotDefault) 'description': description};

  @override
  String toString() {
    final contents = ['description=$description'].join(',');
    return 'Advice($contents)';
  }
}

/// A descriptor for defining project properties for a service. One service may
/// have many consumer projects, and the service may want to behave differently
/// depending on some properties on the project. For example, a project may be
/// associated with a school, or a business, or a government agency, a business
/// type property on the project may affect how a service responds to the client.
/// This descriptor defines which properties are allowed to be set on a project.
///
/// Example:
///
///    project_properties:
///      properties:
///      - name: NO_WATERMARK
///        type: BOOL
///        description: Allows usage of the API without watermarks.
///      - name: EXTENDED_TILE_CACHE_PERIOD
///        type: INT64
final class ProjectProperties extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ProjectProperties';

  /// List of per consumer project-specific properties.
  final List<Property> properties;

  ProjectProperties({this.properties = const []}) : super(fullyQualifiedName);

  factory ProjectProperties.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ProjectProperties(
      properties: switch (json['properties']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Property.fromJson(i)],
        _ => throw const FormatException('"properties" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (properties.isNotDefault) 'properties': encodeList(properties),
  };

  @override
  String toString() => 'ProjectProperties()';
}

/// Defines project properties.
///
/// API services can define properties that can be assigned to consumer projects
/// so that backends can perform response customization without having to make
/// additional calls or maintain additional storage. For example, Maps API
/// defines properties that controls map tile cache period, or whether to embed a
/// watermark in a result.
///
/// These values can be set via API producer console. Only API providers can
/// define and set these properties.
final class Property extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Property';

  /// The name of the property (a.k.a key).
  final String name;

  /// The type of this property.
  final Property_PropertyType type;

  /// The description of the property
  final String description;

  Property({
    this.name = '',
    this.type = Property_PropertyType.$default,
    this.description = '',
  }) : super(fullyQualifiedName);

  factory Property.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Property(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      type: switch (json['type']) {
        null => Property_PropertyType.$default,
        Object $1 => Property_PropertyType.fromJson($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (type.isNotDefault) 'type': type.toJson(),
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'type=$type',
      'description=$description',
    ].join(',');
    return 'Property($contents)';
  }
}

/// Supported data type of the property values
final class Property_PropertyType extends ProtoEnum {
  /// The type is unspecified, and will result in an error.
  static const unspecified = Property_PropertyType('UNSPECIFIED');

  /// The type is `int64`.
  static const int64 = Property_PropertyType('INT64');

  /// The type is `bool`.
  static const bool$ = Property_PropertyType('BOOL');

  /// The type is `string`.
  static const string = Property_PropertyType('STRING');

  /// The type is 'double'.
  static const double$ = Property_PropertyType('DOUBLE');

  /// The default value for [Property_PropertyType].
  static const $default = unspecified;

  const Property_PropertyType(super.value);

  factory Property_PropertyType.fromJson(Object? json) =>
      Property_PropertyType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'PropertyType.$value';
}

/// `Context` defines which contexts an API requests.
///
/// Example:
///
///     context:
///       rules:
///       - selector: "*"
///         requested:
///         - google.rpc.context.ProjectContext
///         - google.rpc.context.OriginContext
///
/// The above specifies that all methods in the API request
/// `google.rpc.context.ProjectContext` and
/// `google.rpc.context.OriginContext`.
///
/// Available context types are defined in package
/// `google.rpc.context`.
///
/// This also provides mechanism to allowlist any protobuf message extension that
/// can be sent in grpc metadata using x-goog-ext-<extension_id>-bin and
/// x-goog-ext-<extension_id>-jspb format. For example, list any service
/// specific protobuf types that can appear in grpc metadata as follows in your
/// yaml file:
///
/// Example:
///
///     context:
///       rules:
///        - selector: "google.example.library.v1.LibraryService.CreateBook"
///          allowed_request_extensions:
///          - google.foo.v1.NewExtension
///          allowed_response_extensions:
///          - google.foo.v1.NewExtension
///
/// You can also specify extension ID instead of fully qualified extension name
/// here.
final class Context extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Context';

  /// A list of RPC context rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<ContextRule> rules;

  Context({this.rules = const []}) : super(fullyQualifiedName);

  factory Context.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Context(
      rules: switch (json['rules']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) ContextRule.fromJson(i)],
        _ => throw const FormatException('"rules" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (rules.isNotDefault) 'rules': encodeList(rules)};

  @override
  String toString() => 'Context()';
}

/// A context rule provides information about the context for an individual API
/// element.
final class ContextRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ContextRule';

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String selector;

  /// A list of full type names of requested contexts, only the requested context
  /// will be made available to the backend.
  final List<String> requested;

  /// A list of full type names of provided contexts. It is used to support
  /// propagating HTTP headers and ETags from the response extension.
  final List<String> provided;

  /// A list of full type names or extension IDs of extensions allowed in grpc
  /// side channel from client to backend.
  final List<String> allowedRequestExtensions;

  /// A list of full type names or extension IDs of extensions allowed in grpc
  /// side channel from backend to client.
  final List<String> allowedResponseExtensions;

  ContextRule({
    this.selector = '',
    this.requested = const [],
    this.provided = const [],
    this.allowedRequestExtensions = const [],
    this.allowedResponseExtensions = const [],
  }) : super(fullyQualifiedName);

  factory ContextRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ContextRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requested: switch (json['requested']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"requested" is not a list'),
      },
      provided: switch (json['provided']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"provided" is not a list'),
      },
      allowedRequestExtensions: switch (json['allowedRequestExtensions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"allowedRequestExtensions" is not a list',
        ),
      },
      allowedResponseExtensions: switch (json['allowedResponseExtensions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"allowedResponseExtensions" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (requested.isNotDefault) 'requested': requested,
    if (provided.isNotDefault) 'provided': provided,
    if (allowedRequestExtensions.isNotDefault)
      'allowedRequestExtensions': allowedRequestExtensions,
    if (allowedResponseExtensions.isNotDefault)
      'allowedResponseExtensions': allowedResponseExtensions,
  };

  @override
  String toString() {
    final contents = ['selector=$selector'].join(',');
    return 'ContextRule($contents)';
  }
}

/// Selects and configures the service controller used by the service.
///
/// Example:
///
///     control:
///       environment: servicecontrol.googleapis.com
final class Control extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Control';

  /// The service controller environment to use. If empty, no control plane
  /// feature (like quota and billing) will be enabled. The recommended value for
  /// most services is servicecontrol.googleapis.com
  final String environment;

  /// Defines policies applying to the API methods of the service.
  final List<MethodPolicy> methodPolicies;

  Control({this.environment = '', this.methodPolicies = const []})
    : super(fullyQualifiedName);

  factory Control.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Control(
      environment: switch (json['environment']) {
        null => '',
        Object $1 => decodeString($1),
      },
      methodPolicies: switch (json['methodPolicies']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) MethodPolicy.fromJson(i)],
        _ => throw const FormatException('"methodPolicies" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (environment.isNotDefault) 'environment': environment,
    if (methodPolicies.isNotDefault)
      'methodPolicies': encodeList(methodPolicies),
  };

  @override
  String toString() {
    final contents = ['environment=$environment'].join(',');
    return 'Control($contents)';
  }
}

/// `Distribution` contains summary statistics for a population of values. It
/// optionally contains a histogram representing the distribution of those values
/// across a set of buckets.
///
/// The summary statistics are the count, mean, sum of the squared deviation from
/// the mean, the minimum, and the maximum of the set of population of values.
/// The histogram is based on a sequence of buckets and gives a count of values
/// that fall into each bucket. The boundaries of the buckets are given either
/// explicitly or by formulas for buckets of fixed or exponentially increasing
/// widths.
///
/// Although it is not forbidden, it is generally a bad idea to include
/// non-finite values (infinities or NaNs) in the population of values, as this
/// will render the `mean` and `sum_of_squared_deviation` fields meaningless.
final class Distribution extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Distribution';

  /// The number of values in the population. Must be non-negative. This value
  /// must equal the sum of the values in `bucket_counts` if a histogram is
  /// provided.
  final int count;

  /// The arithmetic mean of the values in the population. If `count` is zero
  /// then this field must be zero.
  final double mean;

  /// The sum of squared deviations from the mean of the values in the
  /// population. For values x_i this is:
  ///
  ///     Sum[i=1..n]((x_i - mean)^2)
  ///
  /// Knuth, "The Art of Computer Programming", Vol. 2, page 232, 3rd edition
  /// describes Welford's method for accumulating this sum in one pass.
  ///
  /// If `count` is zero then this field must be zero.
  final double sumOfSquaredDeviation;

  /// If specified, contains the range of the population values. The field
  /// must not be present if the `count` is zero.
  final Distribution_Range? range;

  /// Defines the histogram bucket boundaries. If the distribution does not
  /// contain a histogram, then omit this field.
  final Distribution_BucketOptions? bucketOptions;

  /// The number of values in each bucket of the histogram, as described in
  /// `bucket_options`. If the distribution does not have a histogram, then omit
  /// this field. If there is a histogram, then the sum of the values in
  /// `bucket_counts` must equal the value in the `count` field of the
  /// distribution.
  ///
  /// If present, `bucket_counts` should contain N values, where N is the number
  /// of buckets specified in `bucket_options`. If you supply fewer than N
  /// values, the remaining values are assumed to be 0.
  ///
  /// The order of the values in `bucket_counts` follows the bucket numbering
  /// schemes described for the three bucket types. The first value must be the
  /// count for the underflow bucket (number 0). The next N-2 values are the
  /// counts for the finite buckets (number 1 through N-2). The N'th value in
  /// `bucket_counts` is the count for the overflow bucket (number N-1).
  final List<int> bucketCounts;

  /// Must be in increasing order of `value` field.
  final List<Distribution_Exemplar> exemplars;

  Distribution({
    this.count = 0,
    this.mean = 0,
    this.sumOfSquaredDeviation = 0,
    this.range,
    this.bucketOptions,
    this.bucketCounts = const [],
    this.exemplars = const [],
  }) : super(fullyQualifiedName);

  factory Distribution.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Distribution(
      count: switch (json['count']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      mean: switch (json['mean']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      sumOfSquaredDeviation: switch (json['sumOfSquaredDeviation']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      range: switch (json['range']) {
        null => null,
        Object $1 => Distribution_Range.fromJson($1),
      },
      bucketOptions: switch (json['bucketOptions']) {
        null => null,
        Object $1 => Distribution_BucketOptions.fromJson($1),
      },
      bucketCounts: switch (json['bucketCounts']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeInt64(i)],
        _ => throw const FormatException('"bucketCounts" is not a list'),
      },
      exemplars: switch (json['exemplars']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Distribution_Exemplar.fromJson(i),
        ],
        _ => throw const FormatException('"exemplars" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (count.isNotDefault) 'count': encodeInt64(count),
    if (mean.isNotDefault) 'mean': encodeDouble(mean),
    if (sumOfSquaredDeviation.isNotDefault)
      'sumOfSquaredDeviation': encodeDouble(sumOfSquaredDeviation),
    if (range != null) 'range': range!.toJson(),
    if (bucketOptions != null) 'bucketOptions': bucketOptions!.toJson(),
    if (bucketCounts.isNotDefault) 'bucketCounts': bucketCounts,
    if (exemplars.isNotDefault) 'exemplars': encodeList(exemplars),
  };

  @override
  String toString() {
    final contents = [
      'count=$count',
      'mean=$mean',
      'sumOfSquaredDeviation=$sumOfSquaredDeviation',
    ].join(',');
    return 'Distribution($contents)';
  }
}

/// The range of the population values.
final class Distribution_Range extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Distribution.Range';

  /// The minimum of the population values.
  final double min;

  /// The maximum of the population values.
  final double max;

  Distribution_Range({this.min = 0, this.max = 0}) : super(fullyQualifiedName);

  factory Distribution_Range.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Distribution_Range(
      min: switch (json['min']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      max: switch (json['max']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (min.isNotDefault) 'min': encodeDouble(min),
    if (max.isNotDefault) 'max': encodeDouble(max),
  };

  @override
  String toString() {
    final contents = ['min=$min', 'max=$max'].join(',');
    return 'Range($contents)';
  }
}

/// `BucketOptions` describes the bucket boundaries used to create a histogram
/// for the distribution. The buckets can be in a linear sequence, an
/// exponential sequence, or each bucket can be specified explicitly.
/// `BucketOptions` does not include the number of values in each bucket.
///
/// A bucket has an inclusive lower bound and exclusive upper bound for the
/// values that are counted for that bucket. The upper bound of a bucket must
/// be strictly greater than the lower bound. The sequence of N buckets for a
/// distribution consists of an underflow bucket (number 0), zero or more
/// finite buckets (number 1 through N - 2) and an overflow bucket (number N -
/// 1). The buckets are contiguous: the lower bound of bucket i (i > 0) is the
/// same as the upper bound of bucket i - 1. The buckets span the whole range
/// of finite values: lower bound of the underflow bucket is -infinity and the
/// upper bound of the overflow bucket is +infinity. The finite buckets are
/// so-called because both bounds are finite.
final class Distribution_BucketOptions extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Distribution.BucketOptions';

  /// The linear bucket.
  final Distribution_BucketOptions_Linear? linearBuckets;

  /// The exponential buckets.
  final Distribution_BucketOptions_Exponential? exponentialBuckets;

  /// The explicit buckets.
  final Distribution_BucketOptions_Explicit? explicitBuckets;

  Distribution_BucketOptions({
    this.linearBuckets,
    this.exponentialBuckets,
    this.explicitBuckets,
  }) : super(fullyQualifiedName);

  factory Distribution_BucketOptions.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Distribution_BucketOptions(
      linearBuckets: switch (json['linearBuckets']) {
        null => null,
        Object $1 => Distribution_BucketOptions_Linear.fromJson($1),
      },
      exponentialBuckets: switch (json['exponentialBuckets']) {
        null => null,
        Object $1 => Distribution_BucketOptions_Exponential.fromJson($1),
      },
      explicitBuckets: switch (json['explicitBuckets']) {
        null => null,
        Object $1 => Distribution_BucketOptions_Explicit.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (linearBuckets != null) 'linearBuckets': linearBuckets!.toJson(),
    if (exponentialBuckets != null)
      'exponentialBuckets': exponentialBuckets!.toJson(),
    if (explicitBuckets != null) 'explicitBuckets': explicitBuckets!.toJson(),
  };

  @override
  String toString() => 'BucketOptions()';
}

/// Specifies a linear sequence of buckets that all have the same width
/// (except overflow and underflow). Each bucket represents a constant
/// absolute uncertainty on the specific value in the bucket.
///
/// There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
/// following boundaries:
///
///    Upper bound (0 <= i < N-1):     offset + (width * i).
///
///    Lower bound (1 <= i < N):       offset + (width * (i - 1)).
final class Distribution_BucketOptions_Linear extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Distribution.BucketOptions.Linear';

  /// Must be greater than 0.
  final int numFiniteBuckets;

  /// Must be greater than 0.
  final double width;

  /// Lower bound of the first bucket.
  final double offset;

  Distribution_BucketOptions_Linear({
    this.numFiniteBuckets = 0,
    this.width = 0,
    this.offset = 0,
  }) : super(fullyQualifiedName);

  factory Distribution_BucketOptions_Linear.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Distribution_BucketOptions_Linear(
      numFiniteBuckets: switch (json['numFiniteBuckets']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      width: switch (json['width']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      offset: switch (json['offset']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (numFiniteBuckets.isNotDefault) 'numFiniteBuckets': numFiniteBuckets,
    if (width.isNotDefault) 'width': encodeDouble(width),
    if (offset.isNotDefault) 'offset': encodeDouble(offset),
  };

  @override
  String toString() {
    final contents = [
      'numFiniteBuckets=$numFiniteBuckets',
      'width=$width',
      'offset=$offset',
    ].join(',');
    return 'Linear($contents)';
  }
}

/// Specifies an exponential sequence of buckets that have a width that is
/// proportional to the value of the lower bound. Each bucket represents a
/// constant relative uncertainty on a specific value in the bucket.
///
/// There are `num_finite_buckets + 2` (= N) buckets. Bucket `i` has the
/// following boundaries:
///
///    Upper bound (0 <= i < N-1):     scale * (growth_factor ^ i).
///
///    Lower bound (1 <= i < N):       scale * (growth_factor ^ (i - 1)).
final class Distribution_BucketOptions_Exponential extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Distribution.BucketOptions.Exponential';

  /// Must be greater than 0.
  final int numFiniteBuckets;

  /// Must be greater than 1.
  final double growthFactor;

  /// Must be greater than 0.
  final double scale;

  Distribution_BucketOptions_Exponential({
    this.numFiniteBuckets = 0,
    this.growthFactor = 0,
    this.scale = 0,
  }) : super(fullyQualifiedName);

  factory Distribution_BucketOptions_Exponential.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Distribution_BucketOptions_Exponential(
      numFiniteBuckets: switch (json['numFiniteBuckets']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      growthFactor: switch (json['growthFactor']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      scale: switch (json['scale']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (numFiniteBuckets.isNotDefault) 'numFiniteBuckets': numFiniteBuckets,
    if (growthFactor.isNotDefault) 'growthFactor': encodeDouble(growthFactor),
    if (scale.isNotDefault) 'scale': encodeDouble(scale),
  };

  @override
  String toString() {
    final contents = [
      'numFiniteBuckets=$numFiniteBuckets',
      'growthFactor=$growthFactor',
      'scale=$scale',
    ].join(',');
    return 'Exponential($contents)';
  }
}

/// Specifies a set of buckets with arbitrary widths.
///
/// There are `size(bounds) + 1` (= N) buckets. Bucket `i` has the following
/// boundaries:
///
///    Upper bound (0 <= i < N-1):     bounds[i]
///    Lower bound (1 <= i < N);       bounds[i - 1]
///
/// The `bounds` field must contain at least one element. If `bounds` has
/// only one element, then there are no finite buckets, and that single
/// element is the common boundary of the overflow and underflow buckets.
final class Distribution_BucketOptions_Explicit extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Distribution.BucketOptions.Explicit';

  /// The values must be monotonically increasing.
  final List<double> bounds;

  Distribution_BucketOptions_Explicit({this.bounds = const []})
    : super(fullyQualifiedName);

  factory Distribution_BucketOptions_Explicit.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Distribution_BucketOptions_Explicit(
      bounds: switch (json['bounds']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeDouble(i)],
        _ => throw const FormatException('"bounds" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (bounds.isNotDefault) 'bounds': bounds};

  @override
  String toString() => 'Explicit()';
}

/// Exemplars are example points that may be used to annotate aggregated
/// distribution values. They are metadata that gives information about a
/// particular value added to a Distribution bucket, such as a trace ID that
/// was active when a value was added. They may contain further information,
/// such as a example values and timestamps, origin, etc.
final class Distribution_Exemplar extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Distribution.Exemplar';

  /// Value of the exemplar point. This value determines to which bucket the
  /// exemplar belongs.
  final double value;

  /// The observation (sampling) time of the above value.
  final Timestamp? timestamp;

  /// Contextual information about the example value. Examples are:
  ///
  ///   Trace: type.googleapis.com/google.monitoring.v3.SpanContext
  ///
  ///   Literal string: type.googleapis.com/google.protobuf.StringValue
  ///
  ///   Labels dropped during aggregation:
  ///     type.googleapis.com/google.monitoring.v3.DroppedLabels
  ///
  /// There may be only a single attachment of any given message type in a
  /// single exemplar, and this is enforced by the system.
  final List<Any> attachments;

  Distribution_Exemplar({
    this.value = 0,
    this.timestamp,
    this.attachments = const [],
  }) : super(fullyQualifiedName);

  factory Distribution_Exemplar.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Distribution_Exemplar(
      value: switch (json['value']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      timestamp: switch (json['timestamp']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      attachments: switch (json['attachments']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Any.fromJson(i)],
        _ => throw const FormatException('"attachments" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (value.isNotDefault) 'value': encodeDouble(value),
    if (timestamp != null) 'timestamp': timestamp!.toJson(),
    if (attachments.isNotDefault) 'attachments': encodeList(attachments),
  };

  @override
  String toString() {
    final contents = ['value=$value'].join(',');
    return 'Exemplar($contents)';
  }
}

/// `Documentation` provides the information for describing a service.
///
/// Example:
/// <pre><code>documentation:
///   summary: >
///     The Google Calendar API gives access
///     to most calendar features.
///   pages:
///   - name: Overview
///     content: &#40;== include google/foo/overview.md ==&#41;
///   - name: Tutorial
///     content: &#40;== include google/foo/tutorial.md ==&#41;
///     subpages:
///     - name: Java
///       content: &#40;== include google/foo/tutorial_java.md ==&#41;
///   rules:
///   - selector: google.calendar.Calendar.Get
///     description: >
///       ...
///   - selector: google.calendar.Calendar.Put
///     description: >
///       ...
/// </code></pre>
/// Documentation is provided in markdown syntax. In addition to
/// standard markdown features, definition lists, tables and fenced
/// code blocks are supported. Section headers can be provided and are
/// interpreted relative to the section nesting of the context where
/// a documentation fragment is embedded.
///
/// Documentation from the IDL is merged with documentation defined
/// via the config at normalization time, where documentation provided
/// by config rules overrides IDL provided.
///
/// A number of constructs specific to the API platform are supported
/// in documentation text.
///
/// In order to reference a proto element, the following
/// notation can be used:
/// <pre><code>&#91;fully.qualified.proto.name]&#91;]</code></pre>
/// To override the display text used for the link, this can be used:
/// <pre><code>&#91;display text]&#91;fully.qualified.proto.name]</code></pre>
/// Text can be excluded from doc using the following notation:
/// <pre><code>&#40;-- internal comment --&#41;</code></pre>
///
/// A few directives are available in documentation. Note that
/// directives must appear on a single line to be properly
/// identified. The `include` directive includes a markdown file from
/// an external source:
/// <pre><code>&#40;== include path/to/file ==&#41;</code></pre>
/// The `resource_for` directive marks a message to be the resource of
/// a collection in REST view. If it is not specified, tools attempt
/// to infer the resource from the operations in a collection:
/// <pre><code>&#40;== resource_for v1.shelves.books ==&#41;</code></pre>
/// The directive `suppress_warning` does not directly affect documentation
/// and is documented together with service config validation.
final class Documentation extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Documentation';

  /// A short description of what the service does. The summary must be plain
  /// text. It becomes the overview of the service displayed in Google Cloud
  /// Console.
  /// NOTE: This field is equivalent to the standard field `description`.
  final String summary;

  /// The top level pages for the documentation set.
  final List<Page> pages;

  /// A list of documentation rules that apply to individual API elements.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<DocumentationRule> rules;

  /// The URL to the root of documentation.
  final String documentationRootUrl;

  /// Specifies the service root url if the default one (the service name
  /// from the yaml file) is not suitable. This can be seen in any fully
  /// specified service urls as well as sections that show a base that other
  /// urls are relative to.
  final String serviceRootUrl;

  /// Declares a single overview page. For example:
  /// <pre><code>documentation:
  ///   summary: ...
  ///   overview: &#40;== include overview.md ==&#41;
  /// </code></pre>
  /// This is a shortcut for the following declaration (using pages style):
  /// <pre><code>documentation:
  ///   summary: ...
  ///   pages:
  ///   - name: Overview
  ///     content: &#40;== include overview.md ==&#41;
  /// </code></pre>
  /// Note: you cannot specify both `overview` field and `pages` field.
  final String overview;

  Documentation({
    this.summary = '',
    this.pages = const [],
    this.rules = const [],
    this.documentationRootUrl = '',
    this.serviceRootUrl = '',
    this.overview = '',
  }) : super(fullyQualifiedName);

  factory Documentation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Documentation(
      summary: switch (json['summary']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pages: switch (json['pages']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Page.fromJson(i)],
        _ => throw const FormatException('"pages" is not a list'),
      },
      rules: switch (json['rules']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) DocumentationRule.fromJson(i)],
        _ => throw const FormatException('"rules" is not a list'),
      },
      documentationRootUrl: switch (json['documentationRootUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceRootUrl: switch (json['serviceRootUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
      overview: switch (json['overview']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (summary.isNotDefault) 'summary': summary,
    if (pages.isNotDefault) 'pages': encodeList(pages),
    if (rules.isNotDefault) 'rules': encodeList(rules),
    if (documentationRootUrl.isNotDefault)
      'documentationRootUrl': documentationRootUrl,
    if (serviceRootUrl.isNotDefault) 'serviceRootUrl': serviceRootUrl,
    if (overview.isNotDefault) 'overview': overview,
  };

  @override
  String toString() {
    final contents = [
      'summary=$summary',
      'documentationRootUrl=$documentationRootUrl',
      'serviceRootUrl=$serviceRootUrl',
      'overview=$overview',
    ].join(',');
    return 'Documentation($contents)';
  }
}

/// A documentation rule provides information about individual API elements.
final class DocumentationRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.DocumentationRule';

  /// The selector is a comma-separated list of patterns for any element such as
  /// a method, a field, an enum value. Each pattern is a qualified name of the
  /// element which may end in "*", indicating a wildcard. Wildcards are only
  /// allowed at the end and for a whole component of the qualified name,
  /// i.e. "foo.*" is ok, but not "foo.b*" or "foo.*.bar". A wildcard will match
  /// one or more components. To specify a default for all applicable elements,
  /// the whole pattern "*" is used.
  final String selector;

  /// Description of the selected proto element (e.g. a message, a method, a
  /// 'service' definition, or a field). Defaults to leading & trailing comments
  /// taken from the proto source definition of the proto element.
  final String description;

  /// Deprecation description of the selected element(s). It can be provided if
  /// an element is marked as `deprecated`.
  final String deprecationDescription;

  DocumentationRule({
    this.selector = '',
    this.description = '',
    this.deprecationDescription = '',
  }) : super(fullyQualifiedName);

  factory DocumentationRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DocumentationRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      deprecationDescription: switch (json['deprecationDescription']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (description.isNotDefault) 'description': description,
    if (deprecationDescription.isNotDefault)
      'deprecationDescription': deprecationDescription,
  };

  @override
  String toString() {
    final contents = [
      'selector=$selector',
      'description=$description',
      'deprecationDescription=$deprecationDescription',
    ].join(',');
    return 'DocumentationRule($contents)';
  }
}

/// Represents a documentation page. A page can contain subpages to represent
/// nested documentation set structure.
final class Page extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Page';

  /// The name of the page. It will be used as an identity of the page to
  /// generate URI of the page, text of the link to this page in navigation,
  /// etc. The full page name (start from the root page name to this page
  /// concatenated with `.`) can be used as reference to the page in your
  /// documentation. For example:
  /// <pre><code>pages:
  /// - name: Tutorial
  ///   content: &#40;== include tutorial.md ==&#41;
  ///   subpages:
  ///   - name: Java
  ///     content: &#40;== include tutorial_java.md ==&#41;
  /// </code></pre>
  /// You can reference `Java` page using Markdown reference link syntax:
  /// ``Java``.
  final String name;

  /// The Markdown content of the page. You can use ```(== include {path}
  /// ==)``` to include content from a Markdown file. The content can be used
  /// to produce the documentation page such as HTML format page.
  final String content;

  /// Subpages of this page. The order of subpages specified here will be
  /// honored in the generated docset.
  final List<Page> subpages;

  Page({this.name = '', this.content = '', this.subpages = const []})
    : super(fullyQualifiedName);

  factory Page.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Page(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      content: switch (json['content']) {
        null => '',
        Object $1 => decodeString($1),
      },
      subpages: switch (json['subpages']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Page.fromJson(i)],
        _ => throw const FormatException('"subpages" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (content.isNotDefault) 'content': content,
    if (subpages.isNotDefault) 'subpages': encodeList(subpages),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'content=$content'].join(',');
    return 'Page($contents)';
  }
}

/// `Endpoint` describes a network address of a service that serves a set of
/// APIs. It is commonly known as a service endpoint. A service may expose
/// any number of service endpoints, and all service endpoints share the same
/// service definition, such as quota limits and monitoring metrics.
///
/// Example:
///
///     type: google.api.Service
///     name: library-example.googleapis.com
///     endpoints:
///       # Declares network address `https://library-example.googleapis.com`
///       # for service `library-example.googleapis.com`. The `https` scheme
///       # is implicit for all service endpoints. Other schemes may be
///       # supported in the future.
///     - name: library-example.googleapis.com
///       allow_cors: false
///     - name: content-staging-library-example.googleapis.com
///       # Allows HTTP OPTIONS calls to be passed to the API frontend, for it
///       # to decide whether the subsequent cross-origin request is allowed
///       # to proceed.
///       allow_cors: true
final class Endpoint extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Endpoint';

  /// The canonical name of this endpoint.
  final String name;

  /// Aliases for this endpoint, these will be served by the same UrlMap as the
  /// parent endpoint, and will be provisioned in the GCP stack for the Regional
  /// Endpoints.
  final List<String> aliases;

  /// The specification of an Internet routable address of API frontend that will
  /// handle requests to this [API
  /// Endpoint](https://cloud.google.com/apis/design/glossary). It should be
  /// either a valid IPv4 address or a fully-qualified domain name. For example,
  /// "8.8.8.8" or "myservice.appspot.com".
  final String target;

  /// Allowing
  /// [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing), aka
  /// cross-domain traffic, would allow the backends served from this endpoint to
  /// receive and respond to HTTP OPTIONS requests. The response will be used by
  /// the browser to determine whether the subsequent cross-origin request is
  /// allowed to proceed.
  final bool allowCors;

  Endpoint({
    this.name = '',
    this.aliases = const [],
    this.target = '',
    this.allowCors = false,
  }) : super(fullyQualifiedName);

  factory Endpoint.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Endpoint(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      aliases: switch (json['aliases']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"aliases" is not a list'),
      },
      target: switch (json['target']) {
        null => '',
        Object $1 => decodeString($1),
      },
      allowCors: switch (json['allowCors']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (aliases.isNotDefault) 'aliases': aliases,
    if (target.isNotDefault) 'target': target,
    if (allowCors.isNotDefault) 'allowCors': allowCors,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'target=$target',
      'allowCors=$allowCors',
    ].join(',');
    return 'Endpoint($contents)';
  }
}

/// Rich semantic information of an API field beyond basic typing.
final class FieldInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.FieldInfo';

  /// The standard format of a field value. This does not explicitly configure
  /// any API consumer, just documents the API's format for the field it is
  /// applied to.
  final FieldInfo_Format format;

  /// The type(s) that the annotated, generic field may represent.
  ///
  /// Currently, this must only be used on fields of type `google.protobuf.Any`.
  /// Supporting other generic types may be considered in the future.
  final List<TypeReference> referencedTypes;

  FieldInfo({
    this.format = FieldInfo_Format.$default,
    this.referencedTypes = const [],
  }) : super(fullyQualifiedName);

  factory FieldInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FieldInfo(
      format: switch (json['format']) {
        null => FieldInfo_Format.$default,
        Object $1 => FieldInfo_Format.fromJson($1),
      },
      referencedTypes: switch (json['referencedTypes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) TypeReference.fromJson(i)],
        _ => throw const FormatException('"referencedTypes" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (format.isNotDefault) 'format': format.toJson(),
    if (referencedTypes.isNotDefault)
      'referencedTypes': encodeList(referencedTypes),
  };

  @override
  String toString() {
    final contents = ['format=$format'].join(',');
    return 'FieldInfo($contents)';
  }
}

/// The standard format of a field value. The supported formats are all backed
/// by either an RFC defined by the IETF or a Google-defined AIP.
final class FieldInfo_Format extends ProtoEnum {
  /// Default, unspecified value.
  static const formatUnspecified = FieldInfo_Format('FORMAT_UNSPECIFIED');

  /// Universally Unique Identifier, version 4, value as defined by
  /// https://datatracker.ietf.org/doc/html/rfc4122. The value may be
  /// normalized to entirely lowercase letters. For example, the value
  /// `F47AC10B-58CC-0372-8567-0E02B2C3D479` would be normalized to
  /// `f47ac10b-58cc-0372-8567-0e02b2c3d479`.
  static const uuid4 = FieldInfo_Format('UUID4');

  /// Internet Protocol v4 value as defined by [RFC
  /// 791](https://datatracker.ietf.org/doc/html/rfc791). The value may be
  /// condensed, with leading zeros in each octet stripped. For example,
  /// `001.022.233.040` would be condensed to `1.22.233.40`.
  static const ipv4 = FieldInfo_Format('IPV4');

  /// Internet Protocol v6 value as defined by [RFC
  /// 2460](https://datatracker.ietf.org/doc/html/rfc2460). The value may be
  /// normalized to entirely lowercase letters with zeros compressed, following
  /// [RFC 5952](https://datatracker.ietf.org/doc/html/rfc5952). For example,
  /// the value `2001:0DB8:0::0` would be normalized to `2001:db8::`.
  static const ipv6 = FieldInfo_Format('IPV6');

  /// An IP address in either v4 or v6 format as described by the individual
  /// values defined herein. See the comments on the IPV4 and IPV6 types for
  /// allowed normalizations of each.
  static const ipv4OrIpv6 = FieldInfo_Format('IPV4_OR_IPV6');

  /// The default value for [FieldInfo_Format].
  static const $default = formatUnspecified;

  const FieldInfo_Format(super.value);

  factory FieldInfo_Format.fromJson(Object? json) =>
      FieldInfo_Format(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Format.$value';
}

/// A reference to a message type, for use in `FieldInfo`.
final class TypeReference extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.TypeReference';

  /// The name of the type that the annotated, generic field may represent.
  /// If the type is in the same protobuf package, the value can be the simple
  /// message name e.g., `"MyMessage"`. Otherwise, the value must be the
  /// fully-qualified message name e.g., `"google.library.v1.Book"`.
  ///
  /// If the type(s) are unknown to the service (e.g. the field accepts generic
  /// user input), use the wildcard `"*"` to denote this behavior.
  ///
  /// See [AIP-202](https://google.aip.dev/202#type-references) for more details.
  final String typeName;

  TypeReference({this.typeName = ''}) : super(fullyQualifiedName);

  factory TypeReference.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TypeReference(
      typeName: switch (json['typeName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (typeName.isNotDefault) 'typeName': typeName};

  @override
  String toString() {
    final contents = ['typeName=$typeName'].join(',');
    return 'TypeReference($contents)';
  }
}

/// Defines the HTTP configuration for an API service. It contains a list of
/// `HttpRule`, each specifying the mapping of an RPC method
/// to one or more HTTP REST API methods.
final class Http extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Http';

  /// A list of HTTP configuration rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<HttpRule> rules;

  /// When set to true, URL path parameters will be fully URI-decoded except in
  /// cases of single segment matches in reserved expansion, where "%2F" will be
  /// left encoded.
  ///
  /// The default behavior is to not decode RFC 6570 reserved characters in multi
  /// segment matches.
  final bool fullyDecodeReservedExpansion;

  Http({this.rules = const [], this.fullyDecodeReservedExpansion = false})
    : super(fullyQualifiedName);

  factory Http.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Http(
      rules: switch (json['rules']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) HttpRule.fromJson(i)],
        _ => throw const FormatException('"rules" is not a list'),
      },
      fullyDecodeReservedExpansion:
          switch (json['fullyDecodeReservedExpansion']) {
            null => false,
            Object $1 => decodeBool($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (rules.isNotDefault) 'rules': encodeList(rules),
    if (fullyDecodeReservedExpansion.isNotDefault)
      'fullyDecodeReservedExpansion': fullyDecodeReservedExpansion,
  };

  @override
  String toString() {
    final contents = [
      'fullyDecodeReservedExpansion=$fullyDecodeReservedExpansion',
    ].join(',');
    return 'Http($contents)';
  }
}

/// gRPC Transcoding
///
/// gRPC Transcoding is a feature for mapping between a gRPC method and one or
/// more HTTP REST endpoints. It allows developers to build a single API service
/// that supports both gRPC APIs and REST APIs. Many systems, including [Google
/// APIs](https://github.com/googleapis/googleapis),
/// [Cloud Endpoints](https://cloud.google.com/endpoints), [gRPC
/// Gateway](https://github.com/grpc-ecosystem/grpc-gateway),
/// and [Envoy](https://github.com/envoyproxy/envoy) proxy support this feature
/// and use it for large scale production services.
///
/// `HttpRule` defines the schema of the gRPC/REST mapping. The mapping specifies
/// how different portions of the gRPC request message are mapped to the URL
/// path, URL query parameters, and HTTP request body. It also controls how the
/// gRPC response message is mapped to the HTTP response body. `HttpRule` is
/// typically specified as an `google.api.http` annotation on the gRPC method.
///
/// Each mapping specifies a URL path template and an HTTP method. The path
/// template may refer to one or more fields in the gRPC request message, as long
/// as each field is a non-repeated field with a primitive (non-message) type.
/// The path template controls how fields of the request message are mapped to
/// the URL path.
///
/// Example:
///
///     service Messaging {
///       rpc GetMessage(GetMessageRequest) returns (Message) {
///         option (google.api.http) = {
///             get: "/v1/{name=messages/*}"
///         };
///       }
///     }
///     message GetMessageRequest {
///       string name = 1; // Mapped to URL path.
///     }
///     message Message {
///       string text = 1; // The resource content.
///     }
///
/// This enables an HTTP REST to gRPC mapping as below:
///
/// - HTTP: `GET /v1/messages/123456`
/// - gRPC: `GetMessage(name: "messages/123456")`
///
/// Any fields in the request message which are not bound by the path template
/// automatically become HTTP query parameters if there is no HTTP request body.
/// For example:
///
///     service Messaging {
///       rpc GetMessage(GetMessageRequest) returns (Message) {
///         option (google.api.http) = {
///             get:"/v1/messages/{message_id}"
///         };
///       }
///     }
///     message GetMessageRequest {
///       message SubMessage {
///         string subfield = 1;
///       }
///       string message_id = 1; // Mapped to URL path.
///       int64 revision = 2;    // Mapped to URL query parameter `revision`.
///       SubMessage sub = 3;    // Mapped to URL query parameter `sub.subfield`.
///     }
///
/// This enables a HTTP JSON to RPC mapping as below:
///
/// - HTTP: `GET /v1/messages/123456?revision=2&sub.subfield=foo`
/// - gRPC: `GetMessage(message_id: "123456" revision: 2 sub:
/// SubMessage(subfield: "foo"))`
///
/// Note that fields which are mapped to URL query parameters must have a
/// primitive type or a repeated primitive type or a non-repeated message type.
/// In the case of a repeated type, the parameter can be repeated in the URL
/// as `...?param=A&param=B`. In the case of a message type, each field of the
/// message is mapped to a separate parameter, such as
/// `...?foo.a=A&foo.b=B&foo.c=C`.
///
/// For HTTP methods that allow a request body, the `body` field
/// specifies the mapping. Consider a REST update method on the
/// message resource collection:
///
///     service Messaging {
///       rpc UpdateMessage(UpdateMessageRequest) returns (Message) {
///         option (google.api.http) = {
///           patch: "/v1/messages/{message_id}"
///           body: "message"
///         };
///       }
///     }
///     message UpdateMessageRequest {
///       string message_id = 1; // mapped to the URL
///       Message message = 2;   // mapped to the body
///     }
///
/// The following HTTP JSON to RPC mapping is enabled, where the
/// representation of the JSON in the request body is determined by
/// protos JSON encoding:
///
/// - HTTP: `PATCH /v1/messages/123456 { "text": "Hi!" }`
/// - gRPC: `UpdateMessage(message_id: "123456" message { text: "Hi!" })`
///
/// The special name `*` can be used in the body mapping to define that
/// every field not bound by the path template should be mapped to the
/// request body.  This enables the following alternative definition of
/// the update method:
///
///     service Messaging {
///       rpc UpdateMessage(Message) returns (Message) {
///         option (google.api.http) = {
///           patch: "/v1/messages/{message_id}"
///           body: "*"
///         };
///       }
///     }
///     message Message {
///       string message_id = 1;
///       string text = 2;
///     }
///
///
/// The following HTTP JSON to RPC mapping is enabled:
///
/// - HTTP: `PATCH /v1/messages/123456 { "text": "Hi!" }`
/// - gRPC: `UpdateMessage(message_id: "123456" text: "Hi!")`
///
/// Note that when using `*` in the body mapping, it is not possible to
/// have HTTP parameters, as all fields not bound by the path end in
/// the body. This makes this option more rarely used in practice when
/// defining REST APIs. The common usage of `*` is in custom methods
/// which don't use the URL at all for transferring data.
///
/// It is possible to define multiple HTTP methods for one RPC by using
/// the `additional_bindings` option. Example:
///
///     service Messaging {
///       rpc GetMessage(GetMessageRequest) returns (Message) {
///         option (google.api.http) = {
///           get: "/v1/messages/{message_id}"
///           additional_bindings {
///             get: "/v1/users/{user_id}/messages/{message_id}"
///           }
///         };
///       }
///     }
///     message GetMessageRequest {
///       string message_id = 1;
///       string user_id = 2;
///     }
///
/// This enables the following two alternative HTTP JSON to RPC mappings:
///
/// - HTTP: `GET /v1/messages/123456`
/// - gRPC: `GetMessage(message_id: "123456")`
///
/// - HTTP: `GET /v1/users/me/messages/123456`
/// - gRPC: `GetMessage(user_id: "me" message_id: "123456")`
///
/// Rules for HTTP mapping
///
/// 1. Leaf request fields (recursive expansion nested messages in the request
///    message) are classified into three categories:
///    - Fields referred by the path template. They are passed via the URL path.
///    - Fields referred by the `HttpRule.body`. They
///    are passed via the HTTP
///      request body.
///    - All other fields are passed via the URL query parameters, and the
///      parameter name is the field path in the request message. A repeated
///      field can be represented as multiple query parameters under the same
///      name.
///  2. If `HttpRule.body` is "*", there is no URL
///  query parameter, all fields
///     are passed via URL path and HTTP request body.
///  3. If `HttpRule.body` is omitted, there is no HTTP
///  request body, all
///     fields are passed via URL path and URL query parameters.
///
/// Path template syntax
///
///     Template = "/" Segments [ Verb ] ;
///     Segments = Segment { "/" Segment } ;
///     Segment  = "*" | "**" | LITERAL | Variable ;
///     Variable = "{" FieldPath [ "=" Segments ] "}" ;
///     FieldPath = IDENT { "." IDENT } ;
///     Verb     = ":" LITERAL ;
///
/// The syntax `*` matches a single URL path segment. The syntax `**` matches
/// zero or more URL path segments, which must be the last part of the URL path
/// except the `Verb`.
///
/// The syntax `Variable` matches part of the URL path as specified by its
/// template. A variable template must not contain other variables. If a variable
/// matches a single path segment, its template may be omitted, e.g. `{var}`
/// is equivalent to `{var=*}`.
///
/// The syntax `LITERAL` matches literal text in the URL path. If the `LITERAL`
/// contains any reserved character, such characters should be percent-encoded
/// before the matching.
///
/// If a variable contains exactly one path segment, such as `"{var}"` or
/// `"{var=*}"`, when such a variable is expanded into a URL path on the client
/// side, all characters except `[-_.~0-9a-zA-Z]` are percent-encoded. The
/// server side does the reverse decoding. Such variables show up in the
/// [Discovery
/// Document](https://developers.google.com/discovery/v1/reference/apis) as
/// `{var}`.
///
/// If a variable contains multiple path segments, such as `"{var=foo/*}"`
/// or `"{var=**}"`, when such a variable is expanded into a URL path on the
/// client side, all characters except `[-_.~/0-9a-zA-Z]` are percent-encoded.
/// The server side does the reverse decoding, except "%2F" and "%2f" are left
/// unchanged. Such variables show up in the
/// [Discovery
/// Document](https://developers.google.com/discovery/v1/reference/apis) as
/// `{+var}`.
///
/// Using gRPC API Service Configuration
///
/// gRPC API Service Configuration (service config) is a configuration language
/// for configuring a gRPC service to become a user-facing product. The
/// service config is simply the YAML representation of the `google.api.Service`
/// proto message.
///
/// As an alternative to annotating your proto file, you can configure gRPC
/// transcoding in your service config YAML files. You do this by specifying a
/// `HttpRule` that maps the gRPC method to a REST endpoint, achieving the same
/// effect as the proto annotation. This can be particularly useful if you
/// have a proto that is reused in multiple services. Note that any transcoding
/// specified in the service config will override any matching transcoding
/// configuration in the proto.
///
/// The following example selects a gRPC method and applies an `HttpRule` to it:
///
///     http:
///       rules:
///         - selector: example.v1.Messaging.GetMessage
///           get: /v1/messages/{message_id}/{sub.subfield}
///
/// Special notes
///
/// When gRPC Transcoding is used to map a gRPC to JSON REST endpoints, the
/// proto to JSON conversion must follow the [proto3
/// specification](https://developers.google.com/protocol-buffers/docs/proto3#json).
///
/// While the single segment variable follows the semantics of
/// [RFC 6570](https://tools.ietf.org/html/rfc6570) Section 3.2.2 Simple String
/// Expansion, the multi segment variable **does not** follow RFC 6570 Section
/// 3.2.3 Reserved Expansion. The reason is that the Reserved Expansion
/// does not expand special characters like `?` and `#`, which would lead
/// to invalid URLs. As the result, gRPC Transcoding uses a custom encoding
/// for multi segment variables.
///
/// The path variables **must not** refer to any repeated or mapped field,
/// because client libraries are not capable of handling such variable expansion.
///
/// The path variables **must not** capture the leading "/" character. The reason
/// is that the most common use case "{var}" does not capture the leading "/"
/// character. For consistency, all path variables must share the same behavior.
///
/// Repeated message fields must not be mapped to URL query parameters, because
/// no client library can support such complicated mapping.
///
/// If an API needs to use a JSON array for request or response body, it can map
/// the request or response body to a repeated field. However, some gRPC
/// Transcoding implementations may not support this feature.
final class HttpRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.HttpRule';

  /// Selects a method to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String selector;

  /// Maps to HTTP GET. Used for listing and getting information about
  /// resources.
  final String? get;

  /// Maps to HTTP PUT. Used for replacing a resource.
  final String? put;

  /// Maps to HTTP POST. Used for creating a resource or performing an action.
  final String? post;

  /// Maps to HTTP DELETE. Used for deleting a resource.
  final String? delete;

  /// Maps to HTTP PATCH. Used for updating a resource.
  final String? patch;

  /// The custom pattern is used for specifying an HTTP method that is not
  /// included in the `pattern` field, such as HEAD, or "*" to leave the
  /// HTTP method unspecified for this rule. The wild-card rule is useful
  /// for services that provide content to Web (HTML) clients.
  final CustomHttpPattern? custom;

  /// The name of the request field whose value is mapped to the HTTP request
  /// body, or `*` for mapping all request fields not captured by the path
  /// pattern to the HTTP body, or omitted for not having any HTTP request body.
  ///
  /// NOTE: the referred field must be present at the top-level of the request
  /// message type.
  final String body;

  /// Optional. The name of the response field whose value is mapped to the HTTP
  /// response body. When omitted, the entire response message will be used
  /// as the HTTP response body.
  ///
  /// NOTE: The referred field must be present at the top-level of the response
  /// message type.
  final String responseBody;

  /// Additional HTTP bindings for the selector. Nested bindings must
  /// not contain an `additional_bindings` field themselves (that is,
  /// the nesting may only be one level deep).
  final List<HttpRule> additionalBindings;

  HttpRule({
    this.selector = '',
    this.get,
    this.put,
    this.post,
    this.delete,
    this.patch,
    this.custom,
    this.body = '',
    this.responseBody = '',
    this.additionalBindings = const [],
  }) : super(fullyQualifiedName);

  factory HttpRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HttpRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      get: switch (json['get']) {
        null => null,
        Object $1 => decodeString($1),
      },
      put: switch (json['put']) {
        null => null,
        Object $1 => decodeString($1),
      },
      post: switch (json['post']) {
        null => null,
        Object $1 => decodeString($1),
      },
      delete: switch (json['delete']) {
        null => null,
        Object $1 => decodeString($1),
      },
      patch: switch (json['patch']) {
        null => null,
        Object $1 => decodeString($1),
      },
      custom: switch (json['custom']) {
        null => null,
        Object $1 => CustomHttpPattern.fromJson($1),
      },
      body: switch (json['body']) {
        null => '',
        Object $1 => decodeString($1),
      },
      responseBody: switch (json['responseBody']) {
        null => '',
        Object $1 => decodeString($1),
      },
      additionalBindings: switch (json['additionalBindings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) HttpRule.fromJson(i)],
        _ => throw const FormatException('"additionalBindings" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (get != null) 'get': get,
    if (put != null) 'put': put,
    if (post != null) 'post': post,
    if (delete != null) 'delete': delete,
    if (patch != null) 'patch': patch,
    if (custom != null) 'custom': custom!.toJson(),
    if (body.isNotDefault) 'body': body,
    if (responseBody.isNotDefault) 'responseBody': responseBody,
    if (additionalBindings.isNotDefault)
      'additionalBindings': encodeList(additionalBindings),
  };

  @override
  String toString() {
    final contents = [
      'selector=$selector',
      if (get != null) 'get=$get',
      if (put != null) 'put=$put',
      if (post != null) 'post=$post',
      if (delete != null) 'delete=$delete',
      if (patch != null) 'patch=$patch',
      'body=$body',
      'responseBody=$responseBody',
    ].join(',');
    return 'HttpRule($contents)';
  }
}

/// A custom pattern is used for defining custom HTTP verb.
final class CustomHttpPattern extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.CustomHttpPattern';

  /// The name of this custom HTTP verb.
  final String kind;

  /// The path matched by this custom verb.
  final String path;

  CustomHttpPattern({this.kind = '', this.path = ''})
    : super(fullyQualifiedName);

  factory CustomHttpPattern.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CustomHttpPattern(
      kind: switch (json['kind']) {
        null => '',
        Object $1 => decodeString($1),
      },
      path: switch (json['path']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (kind.isNotDefault) 'kind': kind,
    if (path.isNotDefault) 'path': path,
  };

  @override
  String toString() {
    final contents = ['kind=$kind', 'path=$path'].join(',');
    return 'CustomHttpPattern($contents)';
  }
}

/// Message that represents an arbitrary HTTP body. It should only be used for
/// payload formats that can't be represented as JSON, such as raw binary or
/// an HTML page.
///
///
/// This message can be used both in streaming and non-streaming API methods in
/// the request as well as the response.
///
/// It can be used as a top-level request field, which is convenient if one
/// wants to extract parameters from either the URL or HTTP template into the
/// request fields and also want access to the raw HTTP body.
///
/// Example:
///
///     message GetResourceRequest {
///       // A unique request id.
///       string request_id = 1;
///
///       // The raw HTTP body is bound to this field.
///       google.api.HttpBody http_body = 2;
///
///     }
///
///     service ResourceService {
///       rpc GetResource(GetResourceRequest)
///         returns (google.api.HttpBody);
///       rpc UpdateResource(google.api.HttpBody)
///         returns (google.protobuf.Empty);
///
///     }
///
/// Example with streaming methods:
///
///     service CaldavService {
///       rpc GetCalendar(stream google.api.HttpBody)
///         returns (stream google.api.HttpBody);
///       rpc UpdateCalendar(stream google.api.HttpBody)
///         returns (stream google.api.HttpBody);
///
///     }
///
/// Use of this type only changes how the request and response bodies are
/// handled, all other features will continue to work unchanged.
final class HttpBody extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.HttpBody';

  /// The HTTP Content-Type header value specifying the content type of the body.
  final String contentType;

  /// The HTTP request/response body as raw binary.
  final Uint8List data;

  /// Application specific response metadata. Must be set in the first response
  /// for streaming APIs.
  final List<Any> extensions;

  HttpBody({this.contentType = '', Uint8List? data, this.extensions = const []})
    : data = data ?? Uint8List(0),
      super(fullyQualifiedName);

  factory HttpBody.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HttpBody(
      contentType: switch (json['contentType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      data: switch (json['data']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
      extensions: switch (json['extensions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Any.fromJson(i)],
        _ => throw const FormatException('"extensions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (contentType.isNotDefault) 'contentType': contentType,
    if (data.isNotDefault) 'data': encodeBytes(data),
    if (extensions.isNotDefault) 'extensions': encodeList(extensions),
  };

  @override
  String toString() {
    final contents = ['contentType=$contentType', 'data=$data'].join(',');
    return 'HttpBody($contents)';
  }
}

/// A description of a label.
final class LabelDescriptor extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.LabelDescriptor';

  /// The label key.
  final String key;

  /// The type of data that can be assigned to the label.
  final LabelDescriptor_ValueType valueType;

  /// A human-readable description for the label.
  final String description;

  LabelDescriptor({
    this.key = '',
    this.valueType = LabelDescriptor_ValueType.$default,
    this.description = '',
  }) : super(fullyQualifiedName);

  factory LabelDescriptor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LabelDescriptor(
      key: switch (json['key']) {
        null => '',
        Object $1 => decodeString($1),
      },
      valueType: switch (json['valueType']) {
        null => LabelDescriptor_ValueType.$default,
        Object $1 => LabelDescriptor_ValueType.fromJson($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (key.isNotDefault) 'key': key,
    if (valueType.isNotDefault) 'valueType': valueType.toJson(),
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'key=$key',
      'valueType=$valueType',
      'description=$description',
    ].join(',');
    return 'LabelDescriptor($contents)';
  }
}

/// Value types that can be used as label values.
final class LabelDescriptor_ValueType extends ProtoEnum {
  /// A variable-length string. This is the default.
  static const string = LabelDescriptor_ValueType('STRING');

  /// Boolean; true or false.
  static const bool$ = LabelDescriptor_ValueType('BOOL');

  /// A 64-bit signed integer.
  static const int64 = LabelDescriptor_ValueType('INT64');

  /// The default value for [LabelDescriptor_ValueType].
  static const $default = string;

  const LabelDescriptor_ValueType(super.value);

  factory LabelDescriptor_ValueType.fromJson(Object? json) =>
      LabelDescriptor_ValueType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ValueType.$value';
}

/// A description of a log type. Example in YAML format:
///
///     - name: library.googleapis.com/activity_history
///       description: The history of borrowing and returning library items.
///       display_name: Activity
///       labels:
///       - key: /customer_id
///         description: Identifier of a library customer
final class LogDescriptor extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.LogDescriptor';

  /// The name of the log. It must be less than 512 characters long and can
  /// include the following characters: upper- and lower-case alphanumeric
  /// characters [A-Za-z0-9], and punctuation characters including
  /// slash, underscore, hyphen, period [/_-.].
  final String name;

  /// The set of labels that are available to describe a specific log entry.
  /// Runtime requests that contain labels not specified here are
  /// considered invalid.
  final List<LabelDescriptor> labels;

  /// A human-readable description of this log. This information appears in
  /// the documentation and can contain details.
  final String description;

  /// The human-readable name for this log. This information appears on
  /// the user interface and should be concise.
  final String displayName;

  LogDescriptor({
    this.name = '',
    this.labels = const [],
    this.description = '',
    this.displayName = '',
  }) : super(fullyQualifiedName);

  factory LogDescriptor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LogDescriptor(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) LabelDescriptor.fromJson(i)],
        _ => throw const FormatException('"labels" is not a list'),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (labels.isNotDefault) 'labels': encodeList(labels),
    if (description.isNotDefault) 'description': description,
    if (displayName.isNotDefault) 'displayName': displayName,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'description=$description',
      'displayName=$displayName',
    ].join(',');
    return 'LogDescriptor($contents)';
  }
}

/// Logging configuration of the service.
///
/// The following example shows how to configure logs to be sent to the
/// producer and consumer projects. In the example, the `activity_history`
/// log is sent to both the producer and consumer projects, whereas the
/// `purchase_history` log is only sent to the producer project.
///
///     monitored_resources:
///     - type: library.googleapis.com/branch
///       labels:
///       - key: /city
///         description: The city where the library branch is located in.
///       - key: /name
///         description: The name of the branch.
///     logs:
///     - name: activity_history
///       labels:
///       - key: /customer_id
///     - name: purchase_history
///     logging:
///       producer_destinations:
///       - monitored_resource: library.googleapis.com/branch
///         logs:
///         - activity_history
///         - purchase_history
///       consumer_destinations:
///       - monitored_resource: library.googleapis.com/branch
///         logs:
///         - activity_history
final class Logging extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Logging';

  /// Logging configurations for sending logs to the producer project.
  /// There can be multiple producer destinations, each one must have a
  /// different monitored resource type. A log can be used in at most
  /// one producer destination.
  final List<Logging_LoggingDestination> producerDestinations;

  /// Logging configurations for sending logs to the consumer project.
  /// There can be multiple consumer destinations, each one must have a
  /// different monitored resource type. A log can be used in at most
  /// one consumer destination.
  final List<Logging_LoggingDestination> consumerDestinations;

  Logging({
    this.producerDestinations = const [],
    this.consumerDestinations = const [],
  }) : super(fullyQualifiedName);

  factory Logging.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Logging(
      producerDestinations: switch (json['producerDestinations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Logging_LoggingDestination.fromJson(i),
        ],
        _ => throw const FormatException(
          '"producerDestinations" is not a list',
        ),
      },
      consumerDestinations: switch (json['consumerDestinations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Logging_LoggingDestination.fromJson(i),
        ],
        _ => throw const FormatException(
          '"consumerDestinations" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (producerDestinations.isNotDefault)
      'producerDestinations': encodeList(producerDestinations),
    if (consumerDestinations.isNotDefault)
      'consumerDestinations': encodeList(consumerDestinations),
  };

  @override
  String toString() => 'Logging()';
}

/// Configuration of a specific logging destination (the producer project
/// or the consumer project).
final class Logging_LoggingDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Logging.LoggingDestination';

  /// The monitored resource type. The type must be defined in the
  /// `Service.monitored_resources`
  /// section.
  final String monitoredResource;

  /// Names of the logs to be sent to this destination. Each name must
  /// be defined in the `Service.logs` section. If the
  /// log name is not a domain scoped name, it will be automatically prefixed
  /// with the service name followed by "/".
  final List<String> logs;

  Logging_LoggingDestination({
    this.monitoredResource = '',
    this.logs = const [],
  }) : super(fullyQualifiedName);

  factory Logging_LoggingDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Logging_LoggingDestination(
      monitoredResource: switch (json['monitoredResource']) {
        null => '',
        Object $1 => decodeString($1),
      },
      logs: switch (json['logs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"logs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (monitoredResource.isNotDefault) 'monitoredResource': monitoredResource,
    if (logs.isNotDefault) 'logs': logs,
  };

  @override
  String toString() {
    final contents = ['monitoredResource=$monitoredResource'].join(',');
    return 'LoggingDestination($contents)';
  }
}

/// Defines a metric type and its schema. Once a metric descriptor is created,
/// deleting or altering it stops data collection and makes the metric type's
/// existing data unusable.
final class MetricDescriptor extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MetricDescriptor';

  /// The resource name of the metric descriptor.
  final String name;

  /// The metric type, including its DNS name prefix. The type is not
  /// URL-encoded. All user-defined metric types have the DNS name
  /// `custom.googleapis.com` or `external.googleapis.com`. Metric types should
  /// use a natural hierarchical grouping. For example:
  ///
  ///     "custom.googleapis.com/invoice/paid/amount"
  ///     "external.googleapis.com/prometheus/up"
  ///     "appengine.googleapis.com/http/server/response_latencies"
  final String type;

  /// The set of labels that can be used to describe a specific
  /// instance of this metric type. For example, the
  /// `appengine.googleapis.com/http/server/response_latencies` metric
  /// type has a label for the HTTP response code, `response_code`, so
  /// you can look at latencies for successful responses or just
  /// for responses that failed.
  final List<LabelDescriptor> labels;

  /// Whether the metric records instantaneous values, changes to a value, etc.
  /// Some combinations of `metric_kind` and `value_type` might not be supported.
  final MetricDescriptor_MetricKind metricKind;

  /// Whether the measurement is an integer, a floating-point number, etc.
  /// Some combinations of `metric_kind` and `value_type` might not be supported.
  final MetricDescriptor_ValueType valueType;

  /// The units in which the metric value is reported. It is only applicable
  /// if the `value_type` is `INT64`, `DOUBLE`, or `DISTRIBUTION`. The `unit`
  /// defines the representation of the stored metric values.
  ///
  /// Different systems might scale the values to be more easily displayed (so a
  /// value of `0.02kBy` _might_ be displayed as `20By`, and a value of
  /// `3523kBy` _might_ be displayed as `3.5MBy`). However, if the `unit` is
  /// `kBy`, then the value of the metric is always in thousands of bytes, no
  /// matter how it might be displayed.
  ///
  /// If you want a custom metric to record the exact number of CPU-seconds used
  /// by a job, you can create an `INT64 CUMULATIVE` metric whose `unit` is
  /// `s{CPU}` (or equivalently `1s{CPU}` or just `s`). If the job uses 12,005
  /// CPU-seconds, then the value is written as `12005`.
  ///
  /// Alternatively, if you want a custom metric to record data in a more
  /// granular way, you can create a `DOUBLE CUMULATIVE` metric whose `unit` is
  /// `ks{CPU}`, and then write the value `12.005` (which is `12005/1000`),
  /// or use `Kis{CPU}` and write `11.723` (which is `12005/1024`).
  ///
  /// The supported units are a subset of [The Unified Code for Units of
  /// Measure](https://unitsofmeasure.org/ucum.html) standard:
  ///
  /// **Basic units (UNIT)**
  ///
  /// * `bit`   bit
  /// * `By`    byte
  /// * `s`     second
  /// * `min`   minute
  /// * `h`     hour
  /// * `d`     day
  /// * `1`     dimensionless
  ///
  /// **Prefixes (PREFIX)**
  ///
  /// * `k`     kilo    (10^3)
  /// * `M`     mega    (10^6)
  /// * `G`     giga    (10^9)
  /// * `T`     tera    (10^12)
  /// * `P`     peta    (10^15)
  /// * `E`     exa     (10^18)
  /// * `Z`     zetta   (10^21)
  /// * `Y`     yotta   (10^24)
  ///
  /// * `m`     milli   (10^-3)
  /// * `u`     micro   (10^-6)
  /// * `n`     nano    (10^-9)
  /// * `p`     pico    (10^-12)
  /// * `f`     femto   (10^-15)
  /// * `a`     atto    (10^-18)
  /// * `z`     zepto   (10^-21)
  /// * `y`     yocto   (10^-24)
  ///
  /// * `Ki`    kibi    (2^10)
  /// * `Mi`    mebi    (2^20)
  /// * `Gi`    gibi    (2^30)
  /// * `Ti`    tebi    (2^40)
  /// * `Pi`    pebi    (2^50)
  ///
  /// **Grammar**
  ///
  /// The grammar also includes these connectors:
  ///
  /// * `/`    division or ratio (as an infix operator). For examples,
  ///          `kBy/{email}` or `MiBy/10ms` (although you should almost never
  ///          have `/s` in a metric `unit`; rates should always be computed at
  ///          query time from the underlying cumulative or delta value).
  /// * `.`    multiplication or composition (as an infix operator). For
  ///          examples, `GBy.d` or `k{watt}.h`.
  ///
  /// The grammar for a unit is as follows:
  ///
  ///     Expression = Component { "." Component } { "/" Component } ;
  ///
  ///     Component = ( [ PREFIX ] UNIT | "%" ) [ Annotation ]
  ///               | Annotation
  ///               | "1"
  ///               ;
  ///
  ///     Annotation = "{" NAME "}" ;
  ///
  /// Notes:
  ///
  /// * `Annotation` is just a comment if it follows a `UNIT`. If the annotation
  ///    is used alone, then the unit is equivalent to `1`. For examples,
  ///    `{request}/s == 1/s`, `By{transmitted}/s == By/s`.
  /// * `NAME` is a sequence of non-blank printable ASCII characters not
  ///    containing `{` or `}`.
  /// * `1` represents a unitary [dimensionless
  ///    unit](https://en.wikipedia.org/wiki/Dimensionless_quantity) of 1, such
  ///    as in `1/s`. It is typically used when none of the basic units are
  ///    appropriate. For example, "new users per day" can be represented as
  ///    `1/d` or `{new-users}/d` (and a metric value `5` would mean "5 new
  ///    users). Alternatively, "thousands of page views per day" would be
  ///    represented as `1000/d` or `k1/d` or `k{page_views}/d` (and a metric
  ///    value of `5.3` would mean "5300 page views per day").
  /// * `%` represents dimensionless value of 1/100, and annotates values giving
  ///    a percentage (so the metric values are typically in the range of 0..100,
  ///    and a metric value `3` means "3 percent").
  /// * `10^2.%` indicates a metric contains a ratio, typically in the range
  ///    0..1, that will be multiplied by 100 and displayed as a percentage
  ///    (so a metric value `0.03` means "3 percent").
  final String unit;

  /// A detailed description of the metric, which can be used in documentation.
  final String description;

  /// A concise name for the metric, which can be displayed in user interfaces.
  /// Use sentence case without an ending period, for example "Request count".
  /// This field is optional but it is recommended to be set for any metrics
  /// associated with user-visible concepts, such as Quota.
  final String displayName;

  /// Optional. Metadata which can be used to guide usage of the metric.
  final MetricDescriptor_MetricDescriptorMetadata? metadata;

  /// Optional. The launch stage of the metric definition.
  final LaunchStage launchStage;

  /// Read-only. If present, then a [time
  /// series][google.monitoring.v3.TimeSeries], which is identified partially by
  /// a metric type and a
  /// `MonitoredResourceDescriptor`, that
  /// is associated with this metric type can only be associated with one of the
  /// monitored resource types listed here.
  final List<String> monitoredResourceTypes;

  MetricDescriptor({
    this.name = '',
    this.type = '',
    this.labels = const [],
    this.metricKind = MetricDescriptor_MetricKind.$default,
    this.valueType = MetricDescriptor_ValueType.$default,
    this.unit = '',
    this.description = '',
    this.displayName = '',
    this.metadata,
    this.launchStage = LaunchStage.$default,
    this.monitoredResourceTypes = const [],
  }) : super(fullyQualifiedName);

  factory MetricDescriptor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetricDescriptor(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      type: switch (json['type']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) LabelDescriptor.fromJson(i)],
        _ => throw const FormatException('"labels" is not a list'),
      },
      metricKind: switch (json['metricKind']) {
        null => MetricDescriptor_MetricKind.$default,
        Object $1 => MetricDescriptor_MetricKind.fromJson($1),
      },
      valueType: switch (json['valueType']) {
        null => MetricDescriptor_ValueType.$default,
        Object $1 => MetricDescriptor_ValueType.fromJson($1),
      },
      unit: switch (json['unit']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metadata: switch (json['metadata']) {
        null => null,
        Object $1 => MetricDescriptor_MetricDescriptorMetadata.fromJson($1),
      },
      launchStage: switch (json['launchStage']) {
        null => LaunchStage.$default,
        Object $1 => LaunchStage.fromJson($1),
      },
      monitoredResourceTypes: switch (json['monitoredResourceTypes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException(
          '"monitoredResourceTypes" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (type.isNotDefault) 'type': type,
    if (labels.isNotDefault) 'labels': encodeList(labels),
    if (metricKind.isNotDefault) 'metricKind': metricKind.toJson(),
    if (valueType.isNotDefault) 'valueType': valueType.toJson(),
    if (unit.isNotDefault) 'unit': unit,
    if (description.isNotDefault) 'description': description,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (metadata != null) 'metadata': metadata!.toJson(),
    if (launchStage.isNotDefault) 'launchStage': launchStage.toJson(),
    if (monitoredResourceTypes.isNotDefault)
      'monitoredResourceTypes': monitoredResourceTypes,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'type=$type',
      'metricKind=$metricKind',
      'valueType=$valueType',
      'unit=$unit',
      'description=$description',
      'displayName=$displayName',
      'launchStage=$launchStage',
    ].join(',');
    return 'MetricDescriptor($contents)';
  }
}

/// Additional annotations that can be used to guide the usage of a metric.
final class MetricDescriptor_MetricDescriptorMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.MetricDescriptor.MetricDescriptorMetadata';

  /// Deprecated. Must use the
  /// `MetricDescriptor.launch_stage`
  /// instead.
  final LaunchStage launchStage;

  /// The sampling period of metric data points. For metrics which are written
  /// periodically, consecutive data points are stored at this time interval,
  /// excluding data loss due to errors. Metrics with a higher granularity have
  /// a smaller sampling period.
  final Duration? samplePeriod;

  /// The delay of data points caused by ingestion. Data points older than this
  /// age are guaranteed to be ingested and available to be read, excluding
  /// data loss due to errors.
  final Duration? ingestDelay;

  /// The scope of the timeseries data of the metric.
  final List<
    MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel
  >
  timeSeriesResourceHierarchyLevel;

  MetricDescriptor_MetricDescriptorMetadata({
    this.launchStage = LaunchStage.$default,
    this.samplePeriod,
    this.ingestDelay,
    this.timeSeriesResourceHierarchyLevel = const [],
  }) : super(fullyQualifiedName);

  factory MetricDescriptor_MetricDescriptorMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetricDescriptor_MetricDescriptorMetadata(
      launchStage: switch (json['launchStage']) {
        null => LaunchStage.$default,
        Object $1 => LaunchStage.fromJson($1),
      },
      samplePeriod: switch (json['samplePeriod']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      ingestDelay: switch (json['ingestDelay']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      timeSeriesResourceHierarchyLevel:
          switch (json['timeSeriesResourceHierarchyLevel']) {
            null => [],
            List<Object?> $1 => [
              for (final i in $1)
                MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel.fromJson(
                  i,
                ),
            ],
            _ => throw const FormatException(
              '"timeSeriesResourceHierarchyLevel" is not a list',
            ),
          },
    );
  }

  @override
  Object toJson() => {
    if (launchStage.isNotDefault) 'launchStage': launchStage.toJson(),
    if (samplePeriod != null) 'samplePeriod': samplePeriod!.toJson(),
    if (ingestDelay != null) 'ingestDelay': ingestDelay!.toJson(),
    if (timeSeriesResourceHierarchyLevel.isNotDefault)
      'timeSeriesResourceHierarchyLevel': encodeList(
        timeSeriesResourceHierarchyLevel,
      ),
  };

  @override
  String toString() {
    final contents = ['launchStage=$launchStage'].join(',');
    return 'MetricDescriptorMetadata($contents)';
  }
}

/// The resource hierarchy level of the timeseries data of a metric.
final class MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel
    extends ProtoEnum {
  /// Do not use this default value.
  static const timeSeriesResourceHierarchyLevelUnspecified =
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
        'TIME_SERIES_RESOURCE_HIERARCHY_LEVEL_UNSPECIFIED',
      );

  /// Scopes a metric to a project.
  static const project =
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
        'PROJECT',
      );

  /// Scopes a metric to an organization.
  static const organization =
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
        'ORGANIZATION',
      );

  /// Scopes a metric to a folder.
  static const folder =
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
        'FOLDER',
      );

  /// The default value for [MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel].
  static const $default = timeSeriesResourceHierarchyLevelUnspecified;

  const MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
    super.value,
  );

  factory MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel.fromJson(
    Object? json,
  ) =>
      MetricDescriptor_MetricDescriptorMetadata_TimeSeriesResourceHierarchyLevel(
        json as String,
      );

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'TimeSeriesResourceHierarchyLevel.$value';
}

/// The kind of measurement. It describes how the data is reported.
/// For information on setting the start time and end time based on
/// the MetricKind, see `TimeInterval`.
final class MetricDescriptor_MetricKind extends ProtoEnum {
  /// Do not use this default value.
  static const metricKindUnspecified = MetricDescriptor_MetricKind(
    'METRIC_KIND_UNSPECIFIED',
  );

  /// An instantaneous measurement of a value.
  static const gauge = MetricDescriptor_MetricKind('GAUGE');

  /// The change in a value during a time interval.
  static const delta = MetricDescriptor_MetricKind('DELTA');

  /// A value accumulated over a time interval.  Cumulative
  /// measurements in a time series should have the same start time
  /// and increasing end times, until an event resets the cumulative
  /// value to zero and sets a new start time for the following
  /// points.
  static const cumulative = MetricDescriptor_MetricKind('CUMULATIVE');

  /// The default value for [MetricDescriptor_MetricKind].
  static const $default = metricKindUnspecified;

  const MetricDescriptor_MetricKind(super.value);

  factory MetricDescriptor_MetricKind.fromJson(Object? json) =>
      MetricDescriptor_MetricKind(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'MetricKind.$value';
}

/// The value type of a metric.
final class MetricDescriptor_ValueType extends ProtoEnum {
  /// Do not use this default value.
  static const valueTypeUnspecified = MetricDescriptor_ValueType(
    'VALUE_TYPE_UNSPECIFIED',
  );

  /// The value is a boolean.
  /// This value type can be used only if the metric kind is `GAUGE`.
  static const bool$ = MetricDescriptor_ValueType('BOOL');

  /// The value is a signed 64-bit integer.
  static const int64 = MetricDescriptor_ValueType('INT64');

  /// The value is a double precision floating point number.
  static const double$ = MetricDescriptor_ValueType('DOUBLE');

  /// The value is a text string.
  /// This value type can be used only if the metric kind is `GAUGE`.
  static const string = MetricDescriptor_ValueType('STRING');

  /// The value is a [`Distribution`][google.api.Distribution].
  static const distribution = MetricDescriptor_ValueType('DISTRIBUTION');

  /// The value is money.
  static const money = MetricDescriptor_ValueType('MONEY');

  /// The default value for [MetricDescriptor_ValueType].
  static const $default = valueTypeUnspecified;

  const MetricDescriptor_ValueType(super.value);

  factory MetricDescriptor_ValueType.fromJson(Object? json) =>
      MetricDescriptor_ValueType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ValueType.$value';
}

/// A specific metric, identified by specifying values for all of the
/// labels of a [`MetricDescriptor`][google.api.MetricDescriptor].
final class Metric extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Metric';

  /// An existing metric type, see
  /// `google.api.MetricDescriptor`. For example,
  /// `custom.googleapis.com/invoice/paid/amount`.
  final String type;

  /// The set of label values that uniquely identify this metric. All
  /// labels listed in the `MetricDescriptor` must be assigned values.
  final Map<String, String> labels;

  Metric({this.type = '', this.labels = const {}}) : super(fullyQualifiedName);

  factory Metric.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Metric(
      type: switch (json['type']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type,
    if (labels.isNotDefault) 'labels': labels,
  };

  @override
  String toString() {
    final contents = ['type=$type'].join(',');
    return 'Metric($contents)';
  }
}

/// An object that describes the schema of a
/// `MonitoredResource` object using a type name
/// and a set of labels.  For example, the monitored resource descriptor for
/// Google Compute Engine VM instances has a type of
/// `"gce_instance"` and specifies the use of the labels `"instance_id"` and
/// `"zone"` to identify particular VM instances.
///
/// Different APIs can support different monitored resource types. APIs generally
/// provide a `list` method that returns the monitored resource descriptors used
/// by the API.
final class MonitoredResourceDescriptor extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.MonitoredResourceDescriptor';

  /// Optional. The resource name of the monitored resource descriptor:
  /// `"projects/{project_id}/monitoredResourceDescriptors/{type}"` where
  /// {type} is the value of the `type` field in this object and
  /// {project_id} is a project ID that provides API-specific context for
  /// accessing the type.  APIs that do not use project information can use the
  /// resource name format `"monitoredResourceDescriptors/{type}"`.
  final String name;

  /// Required. The monitored resource type. For example, the type
  /// `"cloudsql_database"` represents databases in Google Cloud SQL.
  ///  For a list of types, see [Monitored resource
  ///  types](https://cloud.google.com/monitoring/api/resources)
  /// and [Logging resource
  /// types](https://cloud.google.com/logging/docs/api/v2/resource-list).
  final String type;

  /// Optional. A concise name for the monitored resource type that might be
  /// displayed in user interfaces. It should be a Title Cased Noun Phrase,
  /// without any article or other determiners. For example,
  /// `"Google Cloud SQL Database"`.
  final String displayName;

  /// Optional. A detailed description of the monitored resource type that might
  /// be used in documentation.
  final String description;

  /// Required. A set of labels used to describe instances of this monitored
  /// resource type. For example, an individual Google Cloud SQL database is
  /// identified by values for the labels `"database_id"` and `"zone"`.
  final List<LabelDescriptor> labels;

  /// Optional. The launch stage of the monitored resource definition.
  final LaunchStage launchStage;

  MonitoredResourceDescriptor({
    this.name = '',
    this.type = '',
    this.displayName = '',
    this.description = '',
    this.labels = const [],
    this.launchStage = LaunchStage.$default,
  }) : super(fullyQualifiedName);

  factory MonitoredResourceDescriptor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MonitoredResourceDescriptor(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      type: switch (json['type']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) LabelDescriptor.fromJson(i)],
        _ => throw const FormatException('"labels" is not a list'),
      },
      launchStage: switch (json['launchStage']) {
        null => LaunchStage.$default,
        Object $1 => LaunchStage.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (type.isNotDefault) 'type': type,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (labels.isNotDefault) 'labels': encodeList(labels),
    if (launchStage.isNotDefault) 'launchStage': launchStage.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'type=$type',
      'displayName=$displayName',
      'description=$description',
      'launchStage=$launchStage',
    ].join(',');
    return 'MonitoredResourceDescriptor($contents)';
  }
}

/// An object representing a resource that can be used for monitoring, logging,
/// billing, or other purposes. Examples include virtual machine instances,
/// databases, and storage devices such as disks. The `type` field identifies a
/// `MonitoredResourceDescriptor` object
/// that describes the resource's schema. Information in the `labels` field
/// identifies the actual resource and its attributes according to the schema.
/// For example, a particular Compute Engine VM instance could be represented by
/// the following object, because the
/// `MonitoredResourceDescriptor` for
/// `"gce_instance"` has labels
/// `"project_id"`, `"instance_id"` and `"zone"`:
///
///     { "type": "gce_instance",
///       "labels": { "project_id": "my-project",
///                   "instance_id": "12345678901234",
///                   "zone": "us-central1-a" }}
final class MonitoredResource extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MonitoredResource';

  /// Required. The monitored resource type. This field must match
  /// the `type` field of a
  /// `MonitoredResourceDescriptor`
  /// object. For example, the type of a Compute Engine VM instance is
  /// `gce_instance`. Some descriptors include the service name in the type; for
  /// example, the type of a Datastream stream is
  /// `datastream.googleapis.com/Stream`.
  final String type;

  /// Required. Values for all of the labels listed in the associated monitored
  /// resource descriptor. For example, Compute Engine VM instances use the
  /// labels `"project_id"`, `"instance_id"`, and `"zone"`.
  final Map<String, String> labels;

  MonitoredResource({this.type = '', this.labels = const {}})
    : super(fullyQualifiedName);

  factory MonitoredResource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MonitoredResource(
      type: switch (json['type']) {
        null => '',
        Object $1 => decodeString($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type,
    if (labels.isNotDefault) 'labels': labels,
  };

  @override
  String toString() {
    final contents = ['type=$type'].join(',');
    return 'MonitoredResource($contents)';
  }
}

/// Auxiliary metadata for a `MonitoredResource`
/// object. `MonitoredResource` objects contain the
/// minimum set of information to uniquely identify a monitored resource
/// instance. There is some other useful auxiliary metadata. Monitoring and
/// Logging use an ingestion pipeline to extract metadata for cloud resources of
/// all types, and store the metadata in this message.
final class MonitoredResourceMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.MonitoredResourceMetadata';

  /// Output only. Values for predefined system metadata labels.
  /// System labels are a kind of metadata extracted by Google, including
  /// "machine_image", "vpc", "subnet_id",
  /// "security_group", "name", etc.
  /// System label values can be only strings, Boolean values, or a list of
  /// strings. For example:
  ///
  ///     { "name": "my-test-instance",
  ///       "security_group": ["a", "b", "c"],
  ///       "spot_instance": false }
  final Struct? systemLabels;

  /// Output only. A map of user-defined metadata labels.
  final Map<String, String> userLabels;

  MonitoredResourceMetadata({this.systemLabels, this.userLabels = const {}})
    : super(fullyQualifiedName);

  factory MonitoredResourceMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MonitoredResourceMetadata(
      systemLabels: switch (json['systemLabels']) {
        null => null,
        Object $1 => Struct.fromJson($1),
      },
      userLabels: switch (json['userLabels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"userLabels" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (systemLabels != null) 'systemLabels': systemLabels!.toJson(),
    if (userLabels.isNotDefault) 'userLabels': userLabels,
  };

  @override
  String toString() => 'MonitoredResourceMetadata()';
}

/// Monitoring configuration of the service.
///
/// The example below shows how to configure monitored resources and metrics
/// for monitoring. In the example, a monitored resource and two metrics are
/// defined. The `library.googleapis.com/book/returned_count` metric is sent
/// to both producer and consumer projects, whereas the
/// `library.googleapis.com/book/num_overdue` metric is only sent to the
/// consumer project.
///
///     monitored_resources:
///     - type: library.googleapis.com/Branch
///       display_name: "Library Branch"
///       description: "A branch of a library."
///       launch_stage: GA
///       labels:
///       - key: resource_container
///         description: "The Cloud container (ie. project id) for the Branch."
///       - key: location
///         description: "The location of the library branch."
///       - key: branch_id
///         description: "The id of the branch."
///     metrics:
///     - name: library.googleapis.com/book/returned_count
///       display_name: "Books Returned"
///       description: "The count of books that have been returned."
///       launch_stage: GA
///       metric_kind: DELTA
///       value_type: INT64
///       unit: "1"
///       labels:
///       - key: customer_id
///         description: "The id of the customer."
///     - name: library.googleapis.com/book/num_overdue
///       display_name: "Books Overdue"
///       description: "The current number of overdue books."
///       launch_stage: GA
///       metric_kind: GAUGE
///       value_type: INT64
///       unit: "1"
///       labels:
///       - key: customer_id
///         description: "The id of the customer."
///     monitoring:
///       producer_destinations:
///       - monitored_resource: library.googleapis.com/Branch
///         metrics:
///         - library.googleapis.com/book/returned_count
///       consumer_destinations:
///       - monitored_resource: library.googleapis.com/Branch
///         metrics:
///         - library.googleapis.com/book/returned_count
///         - library.googleapis.com/book/num_overdue
final class Monitoring extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Monitoring';

  /// Monitoring configurations for sending metrics to the producer project.
  /// There can be multiple producer destinations. A monitored resource type may
  /// appear in multiple monitoring destinations if different aggregations are
  /// needed for different sets of metrics associated with that monitored
  /// resource type. A monitored resource and metric pair may only be used once
  /// in the Monitoring configuration.
  final List<Monitoring_MonitoringDestination> producerDestinations;

  /// Monitoring configurations for sending metrics to the consumer project.
  /// There can be multiple consumer destinations. A monitored resource type may
  /// appear in multiple monitoring destinations if different aggregations are
  /// needed for different sets of metrics associated with that monitored
  /// resource type. A monitored resource and metric pair may only be used once
  /// in the Monitoring configuration.
  final List<Monitoring_MonitoringDestination> consumerDestinations;

  Monitoring({
    this.producerDestinations = const [],
    this.consumerDestinations = const [],
  }) : super(fullyQualifiedName);

  factory Monitoring.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Monitoring(
      producerDestinations: switch (json['producerDestinations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Monitoring_MonitoringDestination.fromJson(i),
        ],
        _ => throw const FormatException(
          '"producerDestinations" is not a list',
        ),
      },
      consumerDestinations: switch (json['consumerDestinations']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Monitoring_MonitoringDestination.fromJson(i),
        ],
        _ => throw const FormatException(
          '"consumerDestinations" is not a list',
        ),
      },
    );
  }

  @override
  Object toJson() => {
    if (producerDestinations.isNotDefault)
      'producerDestinations': encodeList(producerDestinations),
    if (consumerDestinations.isNotDefault)
      'consumerDestinations': encodeList(consumerDestinations),
  };

  @override
  String toString() => 'Monitoring()';
}

/// Configuration of a specific monitoring destination (the producer project
/// or the consumer project).
final class Monitoring_MonitoringDestination extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.api.Monitoring.MonitoringDestination';

  /// The monitored resource type. The type must be defined in
  /// `Service.monitored_resources`
  /// section.
  final String monitoredResource;

  /// Types of the metrics to report to this monitoring destination.
  /// Each type must be defined in
  /// `Service.metrics` section.
  final List<String> metrics;

  Monitoring_MonitoringDestination({
    this.monitoredResource = '',
    this.metrics = const [],
  }) : super(fullyQualifiedName);

  factory Monitoring_MonitoringDestination.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Monitoring_MonitoringDestination(
      monitoredResource: switch (json['monitoredResource']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metrics: switch (json['metrics']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"metrics" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (monitoredResource.isNotDefault) 'monitoredResource': monitoredResource,
    if (metrics.isNotDefault) 'metrics': metrics,
  };

  @override
  String toString() {
    final contents = ['monitoredResource=$monitoredResource'].join(',');
    return 'MonitoringDestination($contents)';
  }
}

/// Google API Policy Annotation
///
/// This message defines a simple API policy annotation that can be used to
/// annotate API request and response message fields with applicable policies.
/// One field may have multiple applicable policies that must all be satisfied
/// before a request can be processed. This policy annotation is used to
/// generate the overall policy that will be used for automatic runtime
/// policy enforcement and documentation generation.
final class FieldPolicy extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.FieldPolicy';

  /// Selects one or more request or response message fields to apply this
  /// `FieldPolicy`.
  ///
  /// When a `FieldPolicy` is used in proto annotation, the selector must
  /// be left as empty. The service config generator will automatically fill
  /// the correct value.
  ///
  /// When a `FieldPolicy` is used in service config, the selector must be a
  /// comma-separated string with valid request or response field paths,
  /// such as "foo.bar" or "foo.bar,foo.baz".
  final String selector;

  /// Specifies the required permission(s) for the resource referred to by the
  /// field. It requires the field contains a valid resource reference, and
  /// the request must pass the permission checks to proceed. For example,
  /// "resourcemanager.projects.get".
  final String resourcePermission;

  /// Specifies the resource type for the resource referred to by the field.
  final String resourceType;

  FieldPolicy({
    this.selector = '',
    this.resourcePermission = '',
    this.resourceType = '',
  }) : super(fullyQualifiedName);

  factory FieldPolicy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return FieldPolicy(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      resourcePermission: switch (json['resourcePermission']) {
        null => '',
        Object $1 => decodeString($1),
      },
      resourceType: switch (json['resourceType']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (resourcePermission.isNotDefault)
      'resourcePermission': resourcePermission,
    if (resourceType.isNotDefault) 'resourceType': resourceType,
  };

  @override
  String toString() {
    final contents = [
      'selector=$selector',
      'resourcePermission=$resourcePermission',
      'resourceType=$resourceType',
    ].join(',');
    return 'FieldPolicy($contents)';
  }
}

/// Defines policies applying to an RPC method.
final class MethodPolicy extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MethodPolicy';

  /// Selects a method to which these policies should be enforced, for example,
  /// "google.pubsub.v1.Subscriber.CreateSubscription".
  ///
  /// Refer to `selector` for syntax
  /// details.
  ///
  /// NOTE: This field must not be set in the proto annotation. It will be
  /// automatically filled by the service config compiler .
  final String selector;

  /// Policies that are applicable to the request message.
  final List<FieldPolicy> requestPolicies;

  MethodPolicy({this.selector = '', this.requestPolicies = const []})
    : super(fullyQualifiedName);

  factory MethodPolicy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MethodPolicy(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requestPolicies: switch (json['requestPolicies']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) FieldPolicy.fromJson(i)],
        _ => throw const FormatException('"requestPolicies" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (requestPolicies.isNotDefault)
      'requestPolicies': encodeList(requestPolicies),
  };

  @override
  String toString() {
    final contents = ['selector=$selector'].join(',');
    return 'MethodPolicy($contents)';
  }
}

/// Quota configuration helps to achieve fairness and budgeting in service
/// usage.
///
/// The metric based quota configuration works this way:
/// - The service configuration defines a set of metrics.
/// - For API calls, the quota.metric_rules maps methods to metrics with
///   corresponding costs.
/// - The quota.limits defines limits on the metrics, which will be used for
///   quota checks at runtime.
///
/// An example quota configuration in yaml format:
///
///    quota:
///      limits:
///
///      - name: apiWriteQpsPerProject
///        metric: library.googleapis.com/write_calls
///        unit: "1/min/{project}"  # rate limit for consumer projects
///        values:
///          STANDARD: 10000
///
///
///      (The metric rules bind all methods to the read_calls metric,
///       except for the UpdateBook and DeleteBook methods. These two methods
///       are mapped to the write_calls metric, with the UpdateBook method
///       consuming at twice rate as the DeleteBook method.)
///      metric_rules:
///      - selector: "*"
///        metric_costs:
///          library.googleapis.com/read_calls: 1
///      - selector: google.example.library.v1.LibraryService.UpdateBook
///        metric_costs:
///          library.googleapis.com/write_calls: 2
///      - selector: google.example.library.v1.LibraryService.DeleteBook
///        metric_costs:
///          library.googleapis.com/write_calls: 1
///
///  Corresponding Metric definition:
///
///      metrics:
///      - name: library.googleapis.com/read_calls
///        display_name: Read requests
///        metric_kind: DELTA
///        value_type: INT64
///
///      - name: library.googleapis.com/write_calls
///        display_name: Write requests
///        metric_kind: DELTA
///        value_type: INT64
final class Quota extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Quota';

  /// List of QuotaLimit definitions for the service.
  final List<QuotaLimit> limits;

  /// List of MetricRule definitions, each one mapping a selected method to one
  /// or more metrics.
  final List<MetricRule> metricRules;

  Quota({this.limits = const [], this.metricRules = const []})
    : super(fullyQualifiedName);

  factory Quota.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Quota(
      limits: switch (json['limits']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) QuotaLimit.fromJson(i)],
        _ => throw const FormatException('"limits" is not a list'),
      },
      metricRules: switch (json['metricRules']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) MetricRule.fromJson(i)],
        _ => throw const FormatException('"metricRules" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (limits.isNotDefault) 'limits': encodeList(limits),
    if (metricRules.isNotDefault) 'metricRules': encodeList(metricRules),
  };

  @override
  String toString() => 'Quota()';
}

/// Bind API methods to metrics. Binding a method to a metric causes that
/// metric's configured quota behaviors to apply to the method call.
final class MetricRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.MetricRule';

  /// Selects the methods to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String selector;

  /// Metrics to update when the selected methods are called, and the associated
  /// cost applied to each metric.
  ///
  /// The key of the map is the metric name, and the values are the amount
  /// increased for the metric against which the quota limits are defined.
  /// The value must not be negative.
  final Map<String, int> metricCosts;

  MetricRule({this.selector = '', this.metricCosts = const {}})
    : super(fullyQualifiedName);

  factory MetricRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return MetricRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metricCosts: switch (json['metricCosts']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries) decodeString(e.key): decodeInt64(e.value),
        },
        _ => throw const FormatException('"metricCosts" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (metricCosts.isNotDefault) 'metricCosts': metricCosts,
  };

  @override
  String toString() {
    final contents = ['selector=$selector'].join(',');
    return 'MetricRule($contents)';
  }
}

/// `QuotaLimit` defines a specific limit that applies over a specified duration
/// for a limit type. There can be at most one limit for a duration and limit
/// type combination defined within a `QuotaGroup`.
final class QuotaLimit extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.QuotaLimit';

  /// Name of the quota limit.
  ///
  /// The name must be provided, and it must be unique within the service. The
  /// name can only include alphanumeric characters as well as '-'.
  ///
  /// The maximum length of the limit name is 64 characters.
  final String name;

  /// Optional. User-visible, extended description for this quota limit.
  /// Should be used only when more context is needed to understand this limit
  /// than provided by the limit's display name (see: `display_name`).
  final String description;

  /// Default number of tokens that can be consumed during the specified
  /// duration. This is the number of tokens assigned when a client
  /// application developer activates the service for his/her project.
  ///
  /// Specifying a value of 0 will block all requests. This can be used if you
  /// are provisioning quota to selected consumers and blocking others.
  /// Similarly, a value of -1 will indicate an unlimited quota. No other
  /// negative values are allowed.
  ///
  /// Used by group-based quotas only.
  final int defaultLimit;

  /// Maximum number of tokens that can be consumed during the specified
  /// duration. Client application developers can override the default limit up
  /// to this maximum. If specified, this value cannot be set to a value less
  /// than the default limit. If not specified, it is set to the default limit.
  ///
  /// To allow clients to apply overrides with no upper bound, set this to -1,
  /// indicating unlimited maximum quota.
  ///
  /// Used by group-based quotas only.
  final int maxLimit;

  /// Free tier value displayed in the Developers Console for this limit.
  /// The free tier is the number of tokens that will be subtracted from the
  /// billed amount when billing is enabled.
  /// This field can only be set on a limit with duration "1d", in a billable
  /// group; it is invalid on any other limit. If this field is not set, it
  /// defaults to 0, indicating that there is no free tier for this service.
  ///
  /// Used by group-based quotas only.
  final int freeTier;

  /// Duration of this limit in textual notation. Must be "100s" or "1d".
  ///
  /// Used by group-based quotas only.
  final String duration;

  /// The name of the metric this quota limit applies to. The quota limits with
  /// the same metric will be checked together during runtime. The metric must be
  /// defined within the service config.
  final String metric;

  /// Specify the unit of the quota limit. It uses the same syntax as
  /// `MetricDescriptor.unit`. The supported
  /// unit kinds are determined by the quota backend system.
  ///
  /// Here are some examples:
  /// * "1/min/{project}" for quota per minute per project.
  ///
  /// Note: the order of unit components is insignificant.
  /// The "1" at the beginning is required to follow the metric unit syntax.
  final String unit;

  /// Tiered limit values. You must specify this as a key:value pair, with an
  /// integer value that is the maximum number of requests allowed for the
  /// specified unit. Currently only STANDARD is supported.
  final Map<String, int> values;

  /// User-visible display name for this limit.
  /// Optional. If not set, the UI will provide a default display name based on
  /// the quota configuration. This field can be used to override the default
  /// display name generated from the configuration.
  final String displayName;

  QuotaLimit({
    this.name = '',
    this.description = '',
    this.defaultLimit = 0,
    this.maxLimit = 0,
    this.freeTier = 0,
    this.duration = '',
    this.metric = '',
    this.unit = '',
    this.values = const {},
    this.displayName = '',
  }) : super(fullyQualifiedName);

  factory QuotaLimit.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return QuotaLimit(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      defaultLimit: switch (json['defaultLimit']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      maxLimit: switch (json['maxLimit']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      freeTier: switch (json['freeTier']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      duration: switch (json['duration']) {
        null => '',
        Object $1 => decodeString($1),
      },
      metric: switch (json['metric']) {
        null => '',
        Object $1 => decodeString($1),
      },
      unit: switch (json['unit']) {
        null => '',
        Object $1 => decodeString($1),
      },
      values: switch (json['values']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries) decodeString(e.key): decodeInt64(e.value),
        },
        _ => throw const FormatException('"values" is not an object'),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (description.isNotDefault) 'description': description,
    if (defaultLimit.isNotDefault) 'defaultLimit': encodeInt64(defaultLimit),
    if (maxLimit.isNotDefault) 'maxLimit': encodeInt64(maxLimit),
    if (freeTier.isNotDefault) 'freeTier': encodeInt64(freeTier),
    if (duration.isNotDefault) 'duration': duration,
    if (metric.isNotDefault) 'metric': metric,
    if (unit.isNotDefault) 'unit': unit,
    if (values.isNotDefault) 'values': values,
    if (displayName.isNotDefault) 'displayName': displayName,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'description=$description',
      'defaultLimit=$defaultLimit',
      'maxLimit=$maxLimit',
      'freeTier=$freeTier',
      'duration=$duration',
      'metric=$metric',
      'unit=$unit',
      'displayName=$displayName',
    ].join(',');
    return 'QuotaLimit($contents)';
  }
}

/// A simple descriptor of a resource type.
///
/// ResourceDescriptor annotates a resource message (either by means of a
/// protobuf annotation or use in the service config), and associates the
/// resource's schema, the resource type, and the pattern of the resource name.
///
/// Example:
///
///     message Topic {
///       // Indicates this message defines a resource schema.
///       // Declares the resource type in the format of {service}/{kind}.
///       // For Kubernetes resources, the format is {api group}/{kind}.
///       option (google.api.resource) = {
///         type: "pubsub.googleapis.com/Topic"
///         pattern: "projects/{project}/topics/{topic}"
///       };
///     }
///
/// The ResourceDescriptor Yaml config will look like:
///
///     resources:
///     - type: "pubsub.googleapis.com/Topic"
///       pattern: "projects/{project}/topics/{topic}"
///
/// Sometimes, resources have multiple patterns, typically because they can
/// live under multiple parents.
///
/// Example:
///
///     message LogEntry {
///       option (google.api.resource) = {
///         type: "logging.googleapis.com/LogEntry"
///         pattern: "projects/{project}/logs/{log}"
///         pattern: "folders/{folder}/logs/{log}"
///         pattern: "organizations/{organization}/logs/{log}"
///         pattern: "billingAccounts/{billing_account}/logs/{log}"
///       };
///     }
///
/// The ResourceDescriptor Yaml config will look like:
///
///     resources:
///     - type: 'logging.googleapis.com/LogEntry'
///       pattern: "projects/{project}/logs/{log}"
///       pattern: "folders/{folder}/logs/{log}"
///       pattern: "organizations/{organization}/logs/{log}"
///       pattern: "billingAccounts/{billing_account}/logs/{log}"
final class ResourceDescriptor extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ResourceDescriptor';

  /// The resource type. It must be in the format of
  /// {service_name}/{resource_type_kind}. The `resource_type_kind` must be
  /// singular and must not include version numbers.
  ///
  /// Example: `storage.googleapis.com/Bucket`
  ///
  /// The value of the resource_type_kind must follow the regular expression
  /// /[A-Za-z][a-zA-Z0-9]+/. It should start with an upper case character and
  /// should use PascalCase (UpperCamelCase). The maximum number of
  /// characters allowed for the `resource_type_kind` is 100.
  final String type;

  /// Optional. The relative resource name pattern associated with this resource
  /// type. The DNS prefix of the full resource name shouldn't be specified here.
  ///
  /// The path pattern must follow the syntax, which aligns with HTTP binding
  /// syntax:
  ///
  ///     Template = Segment { "/" Segment } ;
  ///     Segment = LITERAL | Variable ;
  ///     Variable = "{" LITERAL "}" ;
  ///
  /// Examples:
  ///
  ///     - "projects/{project}/topics/{topic}"
  ///     - "projects/{project}/knowledgeBases/{knowledge_base}"
  ///
  /// The components in braces correspond to the IDs for each resource in the
  /// hierarchy. It is expected that, if multiple patterns are provided,
  /// the same component name (e.g. "project") refers to IDs of the same
  /// type of resource.
  final List<String> pattern;

  /// Optional. The field on the resource that designates the resource name
  /// field. If omitted, this is assumed to be "name".
  final String nameField;

  /// Optional. The historical or future-looking state of the resource pattern.
  ///
  /// Example:
  ///
  ///     // The InspectTemplate message originally only supported resource
  ///     // names with organization, and project was added later.
  ///     message InspectTemplate {
  ///       option (google.api.resource) = {
  ///         type: "dlp.googleapis.com/InspectTemplate"
  ///         pattern:
  ///         "organizations/{organization}/inspectTemplates/{inspect_template}"
  ///         pattern: "projects/{project}/inspectTemplates/{inspect_template}"
  ///         history: ORIGINALLY_SINGLE_PATTERN
  ///       };
  ///     }
  final ResourceDescriptor_History history;

  /// The plural name used in the resource name and permission names, such as
  /// 'projects' for the resource name of 'projects/{project}' and the permission
  /// name of 'cloudresourcemanager.googleapis.com/projects.get'. One exception
  /// to this is for Nested Collections that have stuttering names, as defined
  /// in [AIP-122](https://google.aip.dev/122#nested-collections), where the
  /// collection ID in the resource name pattern does not necessarily directly
  /// match the `plural` value.
  ///
  /// It is the same concept of the `plural` field in k8s CRD spec
  /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/
  ///
  /// Note: The plural form is required even for singleton resources. See
  /// https://aip.dev/156
  final String plural;

  /// The same concept of the `singular` field in k8s CRD spec
  /// https://kubernetes.io/docs/tasks/access-kubernetes-api/custom-resources/custom-resource-definitions/
  /// Such as "project" for the `resourcemanager.googleapis.com/Project` type.
  final String singular;

  /// Style flag(s) for this resource.
  /// These indicate that a resource is expected to conform to a given
  /// style. See the specific style flags for additional information.
  final List<ResourceDescriptor_Style> style;

  ResourceDescriptor({
    this.type = '',
    this.pattern = const [],
    this.nameField = '',
    this.history = ResourceDescriptor_History.$default,
    this.plural = '',
    this.singular = '',
    this.style = const [],
  }) : super(fullyQualifiedName);

  factory ResourceDescriptor.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourceDescriptor(
      type: switch (json['type']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pattern: switch (json['pattern']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"pattern" is not a list'),
      },
      nameField: switch (json['nameField']) {
        null => '',
        Object $1 => decodeString($1),
      },
      history: switch (json['history']) {
        null => ResourceDescriptor_History.$default,
        Object $1 => ResourceDescriptor_History.fromJson($1),
      },
      plural: switch (json['plural']) {
        null => '',
        Object $1 => decodeString($1),
      },
      singular: switch (json['singular']) {
        null => '',
        Object $1 => decodeString($1),
      },
      style: switch (json['style']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ResourceDescriptor_Style.fromJson(i),
        ],
        _ => throw const FormatException('"style" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type,
    if (pattern.isNotDefault) 'pattern': pattern,
    if (nameField.isNotDefault) 'nameField': nameField,
    if (history.isNotDefault) 'history': history.toJson(),
    if (plural.isNotDefault) 'plural': plural,
    if (singular.isNotDefault) 'singular': singular,
    if (style.isNotDefault) 'style': encodeList(style),
  };

  @override
  String toString() {
    final contents = [
      'type=$type',
      'nameField=$nameField',
      'history=$history',
      'plural=$plural',
      'singular=$singular',
    ].join(',');
    return 'ResourceDescriptor($contents)';
  }
}

/// A description of the historical or future-looking state of the
/// resource pattern.
final class ResourceDescriptor_History extends ProtoEnum {
  /// The "unset" value.
  static const historyUnspecified = ResourceDescriptor_History(
    'HISTORY_UNSPECIFIED',
  );

  /// The resource originally had one pattern and launched as such, and
  /// additional patterns were added later.
  static const originallySinglePattern = ResourceDescriptor_History(
    'ORIGINALLY_SINGLE_PATTERN',
  );

  /// The resource has one pattern, but the API owner expects to add more
  /// later. (This is the inverse of ORIGINALLY_SINGLE_PATTERN, and prevents
  /// that from being necessary once there are multiple patterns.)
  static const futureMultiPattern = ResourceDescriptor_History(
    'FUTURE_MULTI_PATTERN',
  );

  /// The default value for [ResourceDescriptor_History].
  static const $default = historyUnspecified;

  const ResourceDescriptor_History(super.value);

  factory ResourceDescriptor_History.fromJson(Object? json) =>
      ResourceDescriptor_History(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'History.$value';
}

/// A flag representing a specific style that a resource claims to conform to.
final class ResourceDescriptor_Style extends ProtoEnum {
  /// The unspecified value. Do not use.
  static const styleUnspecified = ResourceDescriptor_Style('STYLE_UNSPECIFIED');

  /// This resource is intended to be "declarative-friendly".
  ///
  /// Declarative-friendly resources must be more strictly consistent, and
  /// setting this to true communicates to tools that this resource should
  /// adhere to declarative-friendly expectations.
  ///
  /// Note: This is used by the API linter (linter.aip.dev) to enable
  /// additional checks.
  static const declarativeFriendly = ResourceDescriptor_Style(
    'DECLARATIVE_FRIENDLY',
  );

  /// The default value for [ResourceDescriptor_Style].
  static const $default = styleUnspecified;

  const ResourceDescriptor_Style(super.value);

  factory ResourceDescriptor_Style.fromJson(Object? json) =>
      ResourceDescriptor_Style(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Style.$value';
}

/// Defines a proto annotation that describes a string field that refers to
/// an API resource.
final class ResourceReference extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.ResourceReference';

  /// The resource type that the annotated field references.
  ///
  /// Example:
  ///
  ///     message Subscription {
  ///       string topic = 2 [(google.api.resource_reference) = {
  ///         type: "pubsub.googleapis.com/Topic"
  ///       }];
  ///     }
  ///
  /// Occasionally, a field may reference an arbitrary resource. In this case,
  /// APIs use the special value * in their resource reference.
  ///
  /// Example:
  ///
  ///     message GetIamPolicyRequest {
  ///       string resource = 2 [(google.api.resource_reference) = {
  ///         type: "*"
  ///       }];
  ///     }
  final String type;

  /// The resource type of a child collection that the annotated field
  /// references. This is useful for annotating the `parent` field that
  /// doesn't have a fixed resource type.
  ///
  /// Example:
  ///
  ///     message ListLogEntriesRequest {
  ///       string parent = 1 [(google.api.resource_reference) = {
  ///         child_type: "logging.googleapis.com/LogEntry"
  ///       };
  ///     }
  final String childType;

  ResourceReference({this.type = '', this.childType = ''})
    : super(fullyQualifiedName);

  factory ResourceReference.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourceReference(
      type: switch (json['type']) {
        null => '',
        Object $1 => decodeString($1),
      },
      childType: switch (json['childType']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type,
    if (childType.isNotDefault) 'childType': childType,
  };

  @override
  String toString() {
    final contents = ['type=$type', 'childType=$childType'].join(',');
    return 'ResourceReference($contents)';
  }
}

/// Specifies the routing information that should be sent along with the request
/// in the form of routing header.
/// **NOTE:** All service configuration rules follow the "last one wins" order.
///
/// The examples below will apply to an RPC which has the following request type:
///
/// Message Definition:
///
///     message Request {
///       // The name of the Table
///       // Values can be of the following formats:
///       // - `projects/<project>/tables/<table>`
///       // - `projects/<project>/instances/<instance>/tables/<table>`
///       // - `region/<region>/zones/<zone>/tables/<table>`
///       string table_name = 1;
///
///       // This value specifies routing for replication.
///       // It can be in the following formats:
///       // - `profiles/<profile_id>`
///       // - a legacy `profile_id` that can be any string
///       string app_profile_id = 2;
///     }
///
/// Example message:
///
///     {
///       table_name: projects/proj_foo/instances/instance_bar/table/table_baz,
///       app_profile_id: profiles/prof_qux
///     }
///
/// The routing header consists of one or multiple key-value pairs. Every key
/// and value must be percent-encoded, and joined together in the format of
/// `key1=value1&key2=value2`.
/// The examples below skip the percent-encoding for readability.
///
/// Example 1
///
/// Extracting a field from the request to put into the routing header
/// unchanged, with the key equal to the field name.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `app_profile_id`.
///       routing_parameters {
///         field: "app_profile_id"
///       }
///     };
///
/// result:
///
///     x-goog-request-params: app_profile_id=profiles/prof_qux
///
/// Example 2
///
/// Extracting a field from the request to put into the routing header
/// unchanged, with the key different from the field name.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `app_profile_id`, but name it `routing_id` in the header.
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "{routing_id=**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params: routing_id=profiles/prof_qux
///
/// Example 3
///
/// Extracting a field from the request to put into the routing
/// header, while matching a path template syntax on the field's value.
///
/// NB: it is more useful to send nothing than to send garbage for the purpose
/// of dynamic routing, since garbage pollutes cache. Thus the matching.
///
/// Sub-example 3a
///
/// The field matches the template.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `table_name`, if it's well-formed (with project-based
///       // syntax).
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_name=projects/*/instances/*/**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     table_name=projects/proj_foo/instances/instance_bar/table/table_baz
///
/// Sub-example 3b
///
/// The field does not match the template.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `table_name`, if it's well-formed (with region-based
///       // syntax).
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_name=regions/*/zones/*/**}"
///       }
///     };
///
/// result:
///
///     <no routing header will be sent>
///
/// Sub-example 3c
///
/// Multiple alternative conflictingly named path templates are
/// specified. The one that matches is used to construct the header.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take the `table_name`, if it's well-formed, whether
///       // using the region- or projects-based syntax.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_name=regions/*/zones/*/**}"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_name=projects/*/instances/*/**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     table_name=projects/proj_foo/instances/instance_bar/table/table_baz
///
/// Example 4
///
/// Extracting a single routing header key-value pair by matching a
/// template syntax on (a part of) a single request field.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // Take just the project id from the `table_name` field.
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*}/**"
///       }
///     };
///
/// result:
///
///     x-goog-request-params: routing_id=projects/proj_foo
///
/// Example 5
///
/// Extracting a single routing header key-value pair by matching
/// several conflictingly named path templates on (parts of) a single request
/// field. The last template to match "wins" the conflict.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // If the `table_name` does not have instances information,
///       // take just the project id for routing.
///       // Otherwise take project + instance.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*}/**"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*/instances/*}/**"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     routing_id=projects/proj_foo/instances/instance_bar
///
/// Example 6
///
/// Extracting multiple routing header key-value pairs by matching
/// several non-conflicting path templates on (parts of) a single request field.
///
/// Sub-example 6a
///
/// Make the templates strict, so that if the `table_name` does not
/// have an instance information, nothing is sent.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // The routing code needs two keys instead of one composite
///       // but works only for the tables with the "project-instance" name
///       // syntax.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{project_id=projects/*}/instances/*/**"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "projects/*/{instance_id=instances/*}/**"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     project_id=projects/proj_foo&instance_id=instances/instance_bar
///
/// Sub-example 6b
///
/// Make the templates loose, so that if the `table_name` does not
/// have an instance information, just the project id part is sent.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // The routing code wants two keys instead of one composite
///       // but will work with just the `project_id` for tables without
///       // an instance in the `table_name`.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{project_id=projects/*}/**"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "projects/*/{instance_id=instances/*}/**"
///       }
///     };
///
/// result (is the same as 6a for our example message because it has the instance
/// information):
///
///     x-goog-request-params:
///     project_id=projects/proj_foo&instance_id=instances/instance_bar
///
/// Example 7
///
/// Extracting multiple routing header key-value pairs by matching
/// several path templates on multiple request fields.
///
/// NB: note that here there is no way to specify sending nothing if one of the
/// fields does not match its template. E.g. if the `table_name` is in the wrong
/// format, the `project_id` will not be sent, but the `routing_id` will be.
/// The backend routing code has to be aware of that and be prepared to not
/// receive a full complement of keys if it expects multiple.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // The routing needs both `project_id` and `routing_id`
///       // (from the `app_profile_id` field) for routing.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{project_id=projects/*}/**"
///       }
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "{routing_id=**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     project_id=projects/proj_foo&routing_id=profiles/prof_qux
///
/// Example 8
///
/// Extracting a single routing header key-value pair by matching
/// several conflictingly named path templates on several request fields. The
/// last template to match "wins" the conflict.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // The `routing_id` can be a project id or a region id depending on
///       // the table name format, but only if the `app_profile_id` is not set.
///       // If `app_profile_id` is set it should be used instead.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*}/**"
///       }
///       routing_parameters {
///          field: "table_name"
///          path_template: "{routing_id=regions/*}/**"
///       }
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "{routing_id=**}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params: routing_id=profiles/prof_qux
///
/// Example 9
///
/// Bringing it all together.
///
/// annotation:
///
///     option (google.api.routing) = {
///       // For routing both `table_location` and a `routing_id` are needed.
///       //
///       // table_location can be either an instance id or a region+zone id.
///       //
///       // For `routing_id`, take the value of `app_profile_id`
///       // - If it's in the format `profiles/<profile_id>`, send
///       // just the `<profile_id>` part.
///       // - If it's any other literal, send it as is.
///       // If the `app_profile_id` is empty, and the `table_name` starts with
///       // the project_id, send that instead.
///
///       routing_parameters {
///         field: "table_name"
///         path_template: "projects/*/{table_location=instances/*}/tables/*"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "{table_location=regions/*/zones/*}/tables/*"
///       }
///       routing_parameters {
///         field: "table_name"
///         path_template: "{routing_id=projects/*}/**"
///       }
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "{routing_id=**}"
///       }
///       routing_parameters {
///         field: "app_profile_id"
///         path_template: "profiles/{routing_id=*}"
///       }
///     };
///
/// result:
///
///     x-goog-request-params:
///     table_location=instances/instance_bar&routing_id=prof_qux
final class RoutingRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.RoutingRule';

  /// A collection of Routing Parameter specifications.
  /// **NOTE:** If multiple Routing Parameters describe the same key
  /// (via the `path_template` field or via the `field` field when
  /// `path_template` is not provided), "last one wins" rule
  /// determines which Parameter gets used.
  /// See the examples for more details.
  final List<RoutingParameter> routingParameters;

  RoutingRule({this.routingParameters = const []}) : super(fullyQualifiedName);

  factory RoutingRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RoutingRule(
      routingParameters: switch (json['routingParameters']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) RoutingParameter.fromJson(i)],
        _ => throw const FormatException('"routingParameters" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (routingParameters.isNotDefault)
      'routingParameters': encodeList(routingParameters),
  };

  @override
  String toString() => 'RoutingRule()';
}

/// A projection from an input message to the GRPC or REST header.
final class RoutingParameter extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.RoutingParameter';

  /// A request field to extract the header key-value pair from.
  final String field;

  /// A pattern matching the key-value field. Optional.
  /// If not specified, the whole field specified in the `field` field will be
  /// taken as value, and its name used as key. If specified, it MUST contain
  /// exactly one named segment (along with any number of unnamed segments) The
  /// pattern will be matched over the field specified in the `field` field, then
  /// if the match is successful:
  /// - the name of the single named segment will be used as a header name,
  /// - the match value of the segment will be used as a header value;
  /// if the match is NOT successful, nothing will be sent.
  ///
  /// Example:
  ///
  ///               -- This is a field in the request message
  ///              |   that the header value will be extracted from.
  ///              |
  ///              |                     -- This is the key name in the
  ///              |                    |   routing header.
  ///              V                    |
  ///     field: "table_name"           v
  ///     path_template: "projects/*/{table_location=instances/*}/tables/*"
  ///                                                ^            ^
  ///                                                |            |
  ///       In the {} brackets is the pattern that --             |
  ///       specifies what to extract from the                    |
  ///       field as a value to be sent.                          |
  ///                                                             |
  ///      The string in the field must match the whole pattern --
  ///      before brackets, inside brackets, after brackets.
  ///
  /// When looking at this specific example, we can see that:
  /// - A key-value pair with the key `table_location`
  ///   and the value matching `instances/*` should be added
  ///   to the x-goog-request-params routing header.
  /// - The value is extracted from the request message's `table_name` field
  ///   if it matches the full pattern specified:
  ///   `projects/*/instances/*/tables/*`.
  ///
  /// **NB:** If the `path_template` field is not provided, the key name is
  /// equal to the field name, and the whole field should be sent as a value.
  /// This makes the pattern for the field and the value functionally equivalent
  /// to `**`, and the configuration
  ///
  ///     {
  ///       field: "table_name"
  ///     }
  ///
  /// is a functionally equivalent shorthand to:
  ///
  ///     {
  ///       field: "table_name"
  ///       path_template: "{table_name=**}"
  ///     }
  ///
  /// See Example 1 for more details.
  final String pathTemplate;

  RoutingParameter({this.field = '', this.pathTemplate = ''})
    : super(fullyQualifiedName);

  factory RoutingParameter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RoutingParameter(
      field: switch (json['field']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pathTemplate: switch (json['pathTemplate']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (field.isNotDefault) 'field': field,
    if (pathTemplate.isNotDefault) 'pathTemplate': pathTemplate,
  };

  @override
  String toString() {
    final contents = ['field=$field', 'pathTemplate=$pathTemplate'].join(',');
    return 'RoutingParameter($contents)';
  }
}

/// `Service` is the root object of Google API service configuration (service
/// config). It describes the basic information about a logical service,
/// such as the service name and the user-facing title, and delegates other
/// aspects to sub-sections. Each sub-section is either a proto message or a
/// repeated proto message that configures a specific aspect, such as auth.
/// For more information, see each proto message definition.
///
/// Example:
///
///     type: google.api.Service
///     name: calendar.googleapis.com
///     title: Google Calendar API
///     apis:
///     - name: google.calendar.v3.Calendar
///
///     visibility:
///       rules:
///       - selector: "google.calendar.v3.*"
///         restriction: PREVIEW
///     backend:
///       rules:
///       - selector: "google.calendar.v3.*"
///         address: calendar.example.com
///
///     authentication:
///       providers:
///       - id: google_calendar_auth
///         jwks_uri: https://www.googleapis.com/oauth2/v1/certs
///         issuer: https://securetoken.google.com
///       rules:
///       - selector: "*"
///         requirements:
///           provider_id: google_calendar_auth
final class Service extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Service';

  /// The service name, which is a DNS-like logical identifier for the
  /// service, such as `calendar.googleapis.com`. The service name
  /// typically goes through DNS verification to make sure the owner
  /// of the service also owns the DNS name.
  final String name;

  /// The product title for this service, it is the name displayed in Google
  /// Cloud Console.
  final String title;

  /// The Google project that owns this service.
  final String producerProjectId;

  /// A unique ID for a specific instance of this message, typically assigned
  /// by the client for tracking purpose. Must be no longer than 63 characters
  /// and only lower case letters, digits, '.', '_' and '-' are allowed. If
  /// empty, the server may choose to generate one instead.
  final String id;

  /// A list of API interfaces exported by this service. Only the `name` field
  /// of the `google.protobuf.Api` needs to be provided by
  /// the configuration author, as the remaining fields will be derived from the
  /// IDL during the normalization process. It is an error to specify an API
  /// interface here which cannot be resolved against the associated IDL files.
  final List<Api> apis;

  /// A list of all proto message types included in this API service.
  /// Types referenced directly or indirectly by the `apis` are automatically
  /// included.  Messages which are not referenced but shall be included, such as
  /// types used by the `google.protobuf.Any` type, should be listed here by
  /// name by the configuration author. Example:
  ///
  ///     types:
  ///     - name: google.protobuf.Int32
  final List<Type> types;

  /// A list of all enum types included in this API service.  Enums referenced
  /// directly or indirectly by the `apis` are automatically included.  Enums
  /// which are not referenced but shall be included should be listed here by
  /// name by the configuration author. Example:
  ///
  ///     enums:
  ///     - name: google.someapi.v1.SomeEnum
  final List<Enum> enums;

  /// Additional API documentation.
  final Documentation? documentation;

  /// API backend configuration.
  final Backend? backend;

  /// HTTP configuration.
  final Http? http;

  /// Quota configuration.
  final Quota? quota;

  /// Auth configuration.
  final Authentication? authentication;

  /// Context configuration.
  final Context? context;

  /// Configuration controlling usage of this service.
  final Usage? usage;

  /// Configuration for network endpoints.  If this is empty, then an endpoint
  /// with the same name as the service is automatically generated to service all
  /// defined APIs.
  final List<Endpoint> endpoints;

  /// Configuration for the service control plane.
  final Control? control;

  /// Defines the logs used by this service.
  final List<LogDescriptor> logs;

  /// Defines the metrics used by this service.
  final List<MetricDescriptor> metrics;

  /// Defines the monitored resources used by this service. This is required
  /// by the `Service.monitoring` and
  /// `Service.logging` configurations.
  final List<MonitoredResourceDescriptor> monitoredResources;

  /// Billing configuration.
  final Billing? billing;

  /// Logging configuration.
  final Logging? logging;

  /// Monitoring configuration.
  final Monitoring? monitoring;

  /// System parameter configuration.
  final SystemParameters? systemParameters;

  /// Output only. The source information for this configuration if available.
  final SourceInfo? sourceInfo;

  /// Settings for [Google Cloud Client
  /// libraries](https://cloud.google.com/apis/docs/cloud-client-libraries)
  /// generated from APIs defined as protocol buffers.
  final Publishing? publishing;

  /// Obsolete. Do not use.
  ///
  /// This field has no semantic meaning. The service config compiler always
  /// sets this field to `3`.
  final Uint32Value? configVersion;

  Service({
    this.name = '',
    this.title = '',
    this.producerProjectId = '',
    this.id = '',
    this.apis = const [],
    this.types = const [],
    this.enums = const [],
    this.documentation,
    this.backend,
    this.http,
    this.quota,
    this.authentication,
    this.context,
    this.usage,
    this.endpoints = const [],
    this.control,
    this.logs = const [],
    this.metrics = const [],
    this.monitoredResources = const [],
    this.billing,
    this.logging,
    this.monitoring,
    this.systemParameters,
    this.sourceInfo,
    this.publishing,
    this.configVersion,
  }) : super(fullyQualifiedName);

  factory Service.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Service(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
      producerProjectId: switch (json['producerProjectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      apis: switch (json['apis']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Api.fromJson(i)],
        _ => throw const FormatException('"apis" is not a list'),
      },
      types: switch (json['types']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Type.fromJson(i)],
        _ => throw const FormatException('"types" is not a list'),
      },
      enums: switch (json['enums']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Enum.fromJson(i)],
        _ => throw const FormatException('"enums" is not a list'),
      },
      documentation: switch (json['documentation']) {
        null => null,
        Object $1 => Documentation.fromJson($1),
      },
      backend: switch (json['backend']) {
        null => null,
        Object $1 => Backend.fromJson($1),
      },
      http: switch (json['http']) {
        null => null,
        Object $1 => Http.fromJson($1),
      },
      quota: switch (json['quota']) {
        null => null,
        Object $1 => Quota.fromJson($1),
      },
      authentication: switch (json['authentication']) {
        null => null,
        Object $1 => Authentication.fromJson($1),
      },
      context: switch (json['context']) {
        null => null,
        Object $1 => Context.fromJson($1),
      },
      usage: switch (json['usage']) {
        null => null,
        Object $1 => Usage.fromJson($1),
      },
      endpoints: switch (json['endpoints']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Endpoint.fromJson(i)],
        _ => throw const FormatException('"endpoints" is not a list'),
      },
      control: switch (json['control']) {
        null => null,
        Object $1 => Control.fromJson($1),
      },
      logs: switch (json['logs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) LogDescriptor.fromJson(i)],
        _ => throw const FormatException('"logs" is not a list'),
      },
      metrics: switch (json['metrics']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) MetricDescriptor.fromJson(i)],
        _ => throw const FormatException('"metrics" is not a list'),
      },
      monitoredResources: switch (json['monitoredResources']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) MonitoredResourceDescriptor.fromJson(i),
        ],
        _ => throw const FormatException('"monitoredResources" is not a list'),
      },
      billing: switch (json['billing']) {
        null => null,
        Object $1 => Billing.fromJson($1),
      },
      logging: switch (json['logging']) {
        null => null,
        Object $1 => Logging.fromJson($1),
      },
      monitoring: switch (json['monitoring']) {
        null => null,
        Object $1 => Monitoring.fromJson($1),
      },
      systemParameters: switch (json['systemParameters']) {
        null => null,
        Object $1 => SystemParameters.fromJson($1),
      },
      sourceInfo: switch (json['sourceInfo']) {
        null => null,
        Object $1 => SourceInfo.fromJson($1),
      },
      publishing: switch (json['publishing']) {
        null => null,
        Object $1 => Publishing.fromJson($1),
      },
      configVersion: switch (json['configVersion']) {
        null => null,
        Object $1 => Uint32Value.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (title.isNotDefault) 'title': title,
    if (producerProjectId.isNotDefault) 'producerProjectId': producerProjectId,
    if (id.isNotDefault) 'id': id,
    if (apis.isNotDefault) 'apis': encodeList(apis),
    if (types.isNotDefault) 'types': encodeList(types),
    if (enums.isNotDefault) 'enums': encodeList(enums),
    if (documentation != null) 'documentation': documentation!.toJson(),
    if (backend != null) 'backend': backend!.toJson(),
    if (http != null) 'http': http!.toJson(),
    if (quota != null) 'quota': quota!.toJson(),
    if (authentication != null) 'authentication': authentication!.toJson(),
    if (context != null) 'context': context!.toJson(),
    if (usage != null) 'usage': usage!.toJson(),
    if (endpoints.isNotDefault) 'endpoints': encodeList(endpoints),
    if (control != null) 'control': control!.toJson(),
    if (logs.isNotDefault) 'logs': encodeList(logs),
    if (metrics.isNotDefault) 'metrics': encodeList(metrics),
    if (monitoredResources.isNotDefault)
      'monitoredResources': encodeList(monitoredResources),
    if (billing != null) 'billing': billing!.toJson(),
    if (logging != null) 'logging': logging!.toJson(),
    if (monitoring != null) 'monitoring': monitoring!.toJson(),
    if (systemParameters != null)
      'systemParameters': systemParameters!.toJson(),
    if (sourceInfo != null) 'sourceInfo': sourceInfo!.toJson(),
    if (publishing != null) 'publishing': publishing!.toJson(),
    if (configVersion != null) 'configVersion': configVersion!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'title=$title',
      'producerProjectId=$producerProjectId',
      'id=$id',
    ].join(',');
    return 'Service($contents)';
  }
}

/// Source information used to create a Service Config
final class SourceInfo extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.SourceInfo';

  /// All files used during config generation.
  final List<Any> sourceFiles;

  SourceInfo({this.sourceFiles = const []}) : super(fullyQualifiedName);

  factory SourceInfo.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SourceInfo(
      sourceFiles: switch (json['sourceFiles']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Any.fromJson(i)],
        _ => throw const FormatException('"sourceFiles" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (sourceFiles.isNotDefault) 'sourceFiles': encodeList(sourceFiles),
  };

  @override
  String toString() => 'SourceInfo()';
}

/// ### System parameter configuration
///
/// A system parameter is a special kind of parameter defined by the API
/// system, not by an individual API. It is typically mapped to an HTTP header
/// and/or a URL query parameter. This configuration specifies which methods
/// change the names of the system parameters.
final class SystemParameters extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.SystemParameters';

  /// Define system parameters.
  ///
  /// The parameters defined here will override the default parameters
  /// implemented by the system. If this field is missing from the service
  /// config, default system parameters will be used. Default system parameters
  /// and names is implementation-dependent.
  ///
  /// Example: define api key for all methods
  ///
  ///     system_parameters
  ///       rules:
  ///         - selector: "*"
  ///           parameters:
  ///             - name: api_key
  ///               url_query_parameter: api_key
  ///
  ///
  /// Example: define 2 api key names for a specific method.
  ///
  ///     system_parameters
  ///       rules:
  ///         - selector: "/ListShelves"
  ///           parameters:
  ///             - name: api_key
  ///               http_header: Api-Key1
  ///             - name: api_key
  ///               http_header: Api-Key2
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<SystemParameterRule> rules;

  SystemParameters({this.rules = const []}) : super(fullyQualifiedName);

  factory SystemParameters.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SystemParameters(
      rules: switch (json['rules']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) SystemParameterRule.fromJson(i),
        ],
        _ => throw const FormatException('"rules" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (rules.isNotDefault) 'rules': encodeList(rules)};

  @override
  String toString() => 'SystemParameters()';
}

/// Define a system parameter rule mapping system parameter definitions to
/// methods.
final class SystemParameterRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.SystemParameterRule';

  /// Selects the methods to which this rule applies. Use '*' to indicate all
  /// methods in all APIs.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String selector;

  /// Define parameters. Multiple names may be defined for a parameter.
  /// For a given method call, only one of them should be used. If multiple
  /// names are used the behavior is implementation-dependent.
  /// If none of the specified names are present the behavior is
  /// parameter-dependent.
  final List<SystemParameter> parameters;

  SystemParameterRule({this.selector = '', this.parameters = const []})
    : super(fullyQualifiedName);

  factory SystemParameterRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SystemParameterRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      parameters: switch (json['parameters']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SystemParameter.fromJson(i)],
        _ => throw const FormatException('"parameters" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (parameters.isNotDefault) 'parameters': encodeList(parameters),
  };

  @override
  String toString() {
    final contents = ['selector=$selector'].join(',');
    return 'SystemParameterRule($contents)';
  }
}

/// Define a parameter's name and location. The parameter may be passed as either
/// an HTTP header or a URL query parameter, and if both are passed the behavior
/// is implementation-dependent.
final class SystemParameter extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.SystemParameter';

  /// Define the name of the parameter, such as "api_key" . It is case sensitive.
  final String name;

  /// Define the HTTP header name to use for the parameter. It is case
  /// insensitive.
  final String httpHeader;

  /// Define the URL query parameter name to use for the parameter. It is case
  /// sensitive.
  final String urlQueryParameter;

  SystemParameter({
    this.name = '',
    this.httpHeader = '',
    this.urlQueryParameter = '',
  }) : super(fullyQualifiedName);

  factory SystemParameter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SystemParameter(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      httpHeader: switch (json['httpHeader']) {
        null => '',
        Object $1 => decodeString($1),
      },
      urlQueryParameter: switch (json['urlQueryParameter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (httpHeader.isNotDefault) 'httpHeader': httpHeader,
    if (urlQueryParameter.isNotDefault) 'urlQueryParameter': urlQueryParameter,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'httpHeader=$httpHeader',
      'urlQueryParameter=$urlQueryParameter',
    ].join(',');
    return 'SystemParameter($contents)';
  }
}

/// Configuration controlling usage of a service.
final class Usage extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Usage';

  /// Requirements that must be satisfied before a consumer project can use the
  /// service. Each requirement is of the form <service.name>/<requirement-id>;
  /// for example 'serviceusage.googleapis.com/billing-enabled'.
  ///
  /// For Google APIs, a Terms of Service requirement must be included here.
  /// Google Cloud APIs must include "serviceusage.googleapis.com/tos/cloud".
  /// Other Google APIs should include
  /// "serviceusage.googleapis.com/tos/universal". Additional ToS can be
  /// included based on the business needs.
  final List<String> requirements;

  /// A list of usage rules that apply to individual API methods.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<UsageRule> rules;

  /// The full resource name of a channel used for sending notifications to the
  /// service producer.
  ///
  /// Google Service Management currently only supports
  /// [Google Cloud Pub/Sub](https://cloud.google.com/pubsub) as a notification
  /// channel. To use Google Cloud Pub/Sub as the channel, this must be the name
  /// of a Cloud Pub/Sub topic that uses the Cloud Pub/Sub topic name format
  /// documented in https://cloud.google.com/pubsub/docs/overview.
  final String producerNotificationChannel;

  Usage({
    this.requirements = const [],
    this.rules = const [],
    this.producerNotificationChannel = '',
  }) : super(fullyQualifiedName);

  factory Usage.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Usage(
      requirements: switch (json['requirements']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"requirements" is not a list'),
      },
      rules: switch (json['rules']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) UsageRule.fromJson(i)],
        _ => throw const FormatException('"rules" is not a list'),
      },
      producerNotificationChannel:
          switch (json['producerNotificationChannel']) {
            null => '',
            Object $1 => decodeString($1),
          },
    );
  }

  @override
  Object toJson() => {
    if (requirements.isNotDefault) 'requirements': requirements,
    if (rules.isNotDefault) 'rules': encodeList(rules),
    if (producerNotificationChannel.isNotDefault)
      'producerNotificationChannel': producerNotificationChannel,
  };

  @override
  String toString() {
    final contents = [
      'producerNotificationChannel=$producerNotificationChannel',
    ].join(',');
    return 'Usage($contents)';
  }
}

/// Usage configuration rules for the service.
///
/// NOTE: Under development.
///
///
/// Use this rule to configure unregistered calls for the service. Unregistered
/// calls are calls that do not contain consumer project identity.
/// (Example: calls that do not contain an API key).
/// By default, API methods do not allow unregistered calls, and each method call
/// must be identified by a consumer project identity. Use this rule to
/// allow/disallow unregistered calls.
///
/// Example of an API that wants to allow unregistered calls for entire service.
///
///     usage:
///       rules:
///       - selector: "*"
///         allow_unregistered_calls: true
///
/// Example of a method that wants to allow unregistered calls.
///
///     usage:
///       rules:
///       - selector: "google.example.library.v1.LibraryService.CreateBook"
///         allow_unregistered_calls: true
final class UsageRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.UsageRule';

  /// Selects the methods to which this rule applies. Use '*' to indicate all
  /// methods in all APIs.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String selector;

  /// If true, the selected method allows unregistered calls, e.g. calls
  /// that don't identify any user or application.
  final bool allowUnregisteredCalls;

  /// If true, the selected method should skip service control and the control
  /// plane features, such as quota and billing, will not be available.
  /// This flag is used by Google Cloud Endpoints to bypass checks for internal
  /// methods, such as service health check methods.
  final bool skipServiceControl;

  UsageRule({
    this.selector = '',
    this.allowUnregisteredCalls = false,
    this.skipServiceControl = false,
  }) : super(fullyQualifiedName);

  factory UsageRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UsageRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      allowUnregisteredCalls: switch (json['allowUnregisteredCalls']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      skipServiceControl: switch (json['skipServiceControl']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (allowUnregisteredCalls.isNotDefault)
      'allowUnregisteredCalls': allowUnregisteredCalls,
    if (skipServiceControl.isNotDefault)
      'skipServiceControl': skipServiceControl,
  };

  @override
  String toString() {
    final contents = [
      'selector=$selector',
      'allowUnregisteredCalls=$allowUnregisteredCalls',
      'skipServiceControl=$skipServiceControl',
    ].join(',');
    return 'UsageRule($contents)';
  }
}

/// `Visibility` restricts service consumer's access to service elements,
/// such as whether an application can call a visibility-restricted method.
/// The restriction is expressed by applying visibility labels on service
/// elements. The visibility labels are elsewhere linked to service consumers.
///
/// A service can define multiple visibility labels, but a service consumer
/// should be granted at most one visibility label. Multiple visibility
/// labels for a single service consumer are not supported.
///
/// If an element and all its parents have no visibility label, its visibility
/// is unconditionally granted.
///
/// Example:
///
///     visibility:
///       rules:
///       - selector: google.calendar.Calendar.EnhancedSearch
///         restriction: PREVIEW
///       - selector: google.calendar.Calendar.Delegate
///         restriction: INTERNAL
///
/// Here, all methods are publicly visible except for the restricted methods
/// EnhancedSearch and Delegate.
final class Visibility extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.Visibility';

  /// A list of visibility rules that apply to individual API elements.
  ///
  /// **NOTE:** All service configuration rules follow "last one wins" order.
  final List<VisibilityRule> rules;

  Visibility({this.rules = const []}) : super(fullyQualifiedName);

  factory Visibility.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Visibility(
      rules: switch (json['rules']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) VisibilityRule.fromJson(i)],
        _ => throw const FormatException('"rules" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (rules.isNotDefault) 'rules': encodeList(rules)};

  @override
  String toString() => 'Visibility()';
}

/// A visibility rule provides visibility configuration for an individual API
/// element.
final class VisibilityRule extends ProtoMessage {
  static const String fullyQualifiedName = 'google.api.VisibilityRule';

  /// Selects methods, messages, fields, enums, etc. to which this rule applies.
  ///
  /// Refer to `selector` for syntax
  /// details.
  final String selector;

  /// A comma-separated list of visibility labels that apply to the `selector`.
  /// Any of the listed labels can be used to grant the visibility.
  ///
  /// If a rule has multiple labels, removing one of the labels but not all of
  /// them can break clients.
  ///
  /// Example:
  ///
  ///     visibility:
  ///       rules:
  ///       - selector: google.calendar.Calendar.EnhancedSearch
  ///         restriction: INTERNAL, PREVIEW
  ///
  /// Removing INTERNAL from this restriction will break clients that rely on
  /// this method and only had access to it through INTERNAL.
  final String restriction;

  VisibilityRule({this.selector = '', this.restriction = ''})
    : super(fullyQualifiedName);

  factory VisibilityRule.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return VisibilityRule(
      selector: switch (json['selector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      restriction: switch (json['restriction']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (selector.isNotDefault) 'selector': selector,
    if (restriction.isNotDefault) 'restriction': restriction,
  };

  @override
  String toString() {
    final contents = [
      'selector=$selector',
      'restriction=$restriction',
    ].join(',');
    return 'VisibilityRule($contents)';
  }
}

/// The organization for which the client libraries are being published.
/// Affects the url where generated docs are published, etc.
final class ClientLibraryOrganization extends ProtoEnum {
  /// Not useful.
  static const clientLibraryOrganizationUnspecified = ClientLibraryOrganization(
    'CLIENT_LIBRARY_ORGANIZATION_UNSPECIFIED',
  );

  /// Google Cloud Platform Org.
  static const cloud = ClientLibraryOrganization('CLOUD');

  /// Ads (Advertising) Org.
  static const ads = ClientLibraryOrganization('ADS');

  /// Photos Org.
  static const photos = ClientLibraryOrganization('PHOTOS');

  /// Street View Org.
  static const streetView = ClientLibraryOrganization('STREET_VIEW');

  /// Shopping Org.
  static const shopping = ClientLibraryOrganization('SHOPPING');

  /// Geo Org.
  static const geo = ClientLibraryOrganization('GEO');

  /// Generative AI - https://developers.generativeai.google
  static const generativeAi = ClientLibraryOrganization('GENERATIVE_AI');

  /// The default value for [ClientLibraryOrganization].
  static const $default = clientLibraryOrganizationUnspecified;

  const ClientLibraryOrganization(super.value);

  factory ClientLibraryOrganization.fromJson(Object? json) =>
      ClientLibraryOrganization(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ClientLibraryOrganization.$value';
}

/// To where should client libraries be published?
final class ClientLibraryDestination extends ProtoEnum {
  /// Client libraries will neither be generated nor published to package
  /// managers.
  static const clientLibraryDestinationUnspecified = ClientLibraryDestination(
    'CLIENT_LIBRARY_DESTINATION_UNSPECIFIED',
  );

  /// Generate the client library in a repo under github.com/googleapis,
  /// but don't publish it to package managers.
  static const github = ClientLibraryDestination('GITHUB');

  /// Publish the library to package managers like nuget.org and npmjs.com.
  static const packageManager = ClientLibraryDestination('PACKAGE_MANAGER');

  /// The default value for [ClientLibraryDestination].
  static const $default = clientLibraryDestinationUnspecified;

  const ClientLibraryDestination(super.value);

  factory ClientLibraryDestination.fromJson(Object? json) =>
      ClientLibraryDestination(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ClientLibraryDestination.$value';
}

/// Classifies set of possible modifications to an object in the service
/// configuration.
final class ChangeType extends ProtoEnum {
  /// No value was provided.
  static const changeTypeUnspecified = ChangeType('CHANGE_TYPE_UNSPECIFIED');

  /// The changed object exists in the 'new' service configuration, but not
  /// in the 'old' service configuration.
  static const added = ChangeType('ADDED');

  /// The changed object exists in the 'old' service configuration, but not
  /// in the 'new' service configuration.
  static const removed = ChangeType('REMOVED');

  /// The changed object exists in both service configurations, but its value
  /// is different.
  static const modified = ChangeType('MODIFIED');

  /// The default value for [ChangeType].
  static const $default = changeTypeUnspecified;

  const ChangeType(super.value);

  factory ChangeType.fromJson(Object? json) => ChangeType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ChangeType.$value';
}

/// Defines the supported values for `google.rpc.ErrorInfo.reason` for the
/// `googleapis.com` error domain. This error domain is reserved for [Service
/// Infrastructure](https://cloud.google.com/service-infrastructure/docs/overview).
/// For each error info of this domain, the metadata key "service" refers to the
/// logical identifier of an API service, such as "pubsub.googleapis.com". The
/// "consumer" refers to the entity that consumes an API Service. It typically is
/// a Google project that owns the client application or the server resource,
/// such as "projects/123". Other metadata keys are specific to each error
/// reason. For more information, see the definition of the specific error
/// reason.
final class ErrorReason extends ProtoEnum {
  /// Do not use this default value.
  static const errorReasonUnspecified = ErrorReason('ERROR_REASON_UNSPECIFIED');

  /// The request is calling a disabled service for a consumer.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" contacting
  /// "pubsub.googleapis.com" service which is disabled:
  ///
  ///     { "reason": "SERVICE_DISABLED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com"
  ///       }
  ///     }
  ///
  /// This response indicates the "pubsub.googleapis.com" has been disabled in
  /// "projects/123".
  static const serviceDisabled = ErrorReason('SERVICE_DISABLED');

  /// The request whose associated billing account is disabled.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to contact
  /// "pubsub.googleapis.com" service because the associated billing account is
  /// disabled:
  ///
  ///     { "reason": "BILLING_DISABLED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com"
  ///       }
  ///     }
  ///
  /// This response indicates the billing account associated has been disabled.
  static const billingDisabled = ErrorReason('BILLING_DISABLED');

  /// The request is denied because the provided [API
  /// key](https://cloud.google.com/docs/authentication/api-keys) is invalid. It
  /// may be in a bad format, cannot be found, or has been expired).
  ///
  /// Example of an ErrorInfo when the request is contacting
  /// "storage.googleapis.com" service with an invalid API key:
  ///
  ///     { "reason": "API_KEY_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///       }
  ///     }
  static const apiKeyInvalid = ErrorReason('API_KEY_INVALID');

  /// The request is denied because it violates [API key API
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_api_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call the
  /// "storage.googleapis.com" service because this service is restricted in the
  /// API key:
  ///
  ///     { "reason": "API_KEY_SERVICE_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const apiKeyServiceBlocked = ErrorReason('API_KEY_SERVICE_BLOCKED');

  /// The request is denied because it violates [API key HTTP
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_http_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// "storage.googleapis.com" service because the http referrer of the request
  /// violates API key HTTP restrictions:
  ///
  ///     { "reason": "API_KEY_HTTP_REFERRER_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com",
  ///       }
  ///     }
  static const apiKeyHttpReferrerBlocked = ErrorReason(
    'API_KEY_HTTP_REFERRER_BLOCKED',
  );

  /// The request is denied because it violates [API key IP address
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// "storage.googleapis.com" service because the caller IP of the request
  /// violates API key IP address restrictions:
  ///
  ///     { "reason": "API_KEY_IP_ADDRESS_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com",
  ///       }
  ///     }
  static const apiKeyIpAddressBlocked = ErrorReason(
    'API_KEY_IP_ADDRESS_BLOCKED',
  );

  /// The request is denied because it violates [API key Android application
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// "storage.googleapis.com" service because the request from the Android apps
  /// violates the API key Android application restrictions:
  ///
  ///     { "reason": "API_KEY_ANDROID_APP_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const apiKeyAndroidAppBlocked = ErrorReason(
    'API_KEY_ANDROID_APP_BLOCKED',
  );

  /// The request is denied because it violates [API key iOS application
  /// restrictions](https://cloud.google.com/docs/authentication/api-keys#adding_application_restrictions).
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// "storage.googleapis.com" service because the request from the iOS apps
  /// violates the API key iOS application restrictions:
  ///
  ///     { "reason": "API_KEY_IOS_APP_BLOCKED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const apiKeyIosAppBlocked = ErrorReason('API_KEY_IOS_APP_BLOCKED');

  /// The request is denied because there is not enough rate quota for the
  /// consumer.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to contact
  /// "pubsub.googleapis.com" service because consumer's rate quota usage has
  /// reached the maximum value set for the quota limit
  /// "ReadsPerMinutePerProject" on the quota metric
  /// "pubsub.googleapis.com/read_requests":
  ///
  ///     { "reason": "RATE_LIMIT_EXCEEDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com",
  ///         "quota_metric": "pubsub.googleapis.com/read_requests",
  ///         "quota_limit": "ReadsPerMinutePerProject"
  ///       }
  ///     }
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" checks quota on
  /// the service "dataflow.googleapis.com" and hits the organization quota
  /// limit "DefaultRequestsPerMinutePerOrganization" on the metric
  /// "dataflow.googleapis.com/default_requests".
  ///
  ///     { "reason": "RATE_LIMIT_EXCEEDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "dataflow.googleapis.com",
  ///         "quota_metric": "dataflow.googleapis.com/default_requests",
  ///         "quota_limit": "DefaultRequestsPerMinutePerOrganization"
  ///       }
  ///     }
  static const rateLimitExceeded = ErrorReason('RATE_LIMIT_EXCEEDED');

  /// The request is denied because there is not enough resource quota for the
  /// consumer.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to contact
  /// "compute.googleapis.com" service because consumer's resource quota usage
  /// has reached the maximum value set for the quota limit "VMsPerProject"
  /// on the quota metric "compute.googleapis.com/vms":
  ///
  ///     { "reason": "RESOURCE_QUOTA_EXCEEDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "compute.googleapis.com",
  ///         "quota_metric": "compute.googleapis.com/vms",
  ///         "quota_limit": "VMsPerProject"
  ///       }
  ///     }
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" checks resource
  /// quota on the service "dataflow.googleapis.com" and hits the organization
  /// quota limit "jobs-per-organization" on the metric
  /// "dataflow.googleapis.com/job_count".
  ///
  ///     { "reason": "RESOURCE_QUOTA_EXCEEDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "dataflow.googleapis.com",
  ///         "quota_metric": "dataflow.googleapis.com/job_count",
  ///         "quota_limit": "jobs-per-organization"
  ///       }
  ///     }
  static const resourceQuotaExceeded = ErrorReason('RESOURCE_QUOTA_EXCEEDED');

  /// The request whose associated billing account address is in a tax restricted
  /// location, violates the local tax restrictions when creating resources in
  /// the restricted region.
  ///
  /// Example of an ErrorInfo when creating the Cloud Storage Bucket in the
  /// container "projects/123" under a tax restricted region
  /// "locations/asia-northeast3":
  ///
  ///     { "reason": "LOCATION_TAX_POLICY_VIOLATED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com",
  ///         "location": "locations/asia-northeast3"
  ///       }
  ///     }
  ///
  /// This response indicates creating the Cloud Storage Bucket in
  /// "locations/asia-northeast3" violates the location tax restriction.
  static const locationTaxPolicyViolated = ErrorReason(
    'LOCATION_TAX_POLICY_VIOLATED',
  );

  /// The request is denied because the caller does not have required permission
  /// on the user project "projects/123" or the user project is invalid. For more
  /// information, check the [userProject System
  /// Parameters](https://cloud.google.com/apis/docs/system-parameters).
  ///
  /// Example of an ErrorInfo when the caller is calling Cloud Storage service
  /// with insufficient permissions on the user project:
  ///
  ///     { "reason": "USER_PROJECT_DENIED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const userProjectDenied = ErrorReason('USER_PROJECT_DENIED');

  /// The request is denied because the consumer "projects/123" is suspended due
  /// to Terms of Service(Tos) violations. Check [Project suspension
  /// guidelines](https://cloud.google.com/resource-manager/docs/project-suspension-guidelines)
  /// for more information.
  ///
  /// Example of an ErrorInfo when calling Cloud Storage service with the
  /// suspended consumer "projects/123":
  ///
  ///     { "reason": "CONSUMER_SUSPENDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const consumerSuspended = ErrorReason('CONSUMER_SUSPENDED');

  /// The request is denied because the associated consumer is invalid. It may be
  /// in a bad format, cannot be found, or have been deleted.
  ///
  /// Example of an ErrorInfo when calling Cloud Storage service with the
  /// invalid consumer "projects/123":
  ///
  ///     { "reason": "CONSUMER_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const consumerInvalid = ErrorReason('CONSUMER_INVALID');

  /// The request is denied because it violates [VPC Service
  /// Controls](https://cloud.google.com/vpc-service-controls/docs/overview).
  /// The 'uid' field is a random generated identifier that customer can use it
  /// to search the audit log for a request rejected by VPC Service Controls. For
  /// more information, please refer [VPC Service Controls
  /// Troubleshooting](https://cloud.google.com/vpc-service-controls/docs/troubleshooting#unique-id)
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to call
  /// Cloud Storage service because the request is prohibited by the VPC Service
  /// Controls.
  ///
  ///     { "reason": "SECURITY_POLICY_VIOLATED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "uid": "123456789abcde",
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const securityPolicyViolated = ErrorReason('SECURITY_POLICY_VIOLATED');

  /// The request is denied because the provided access token has expired.
  ///
  /// Example of an ErrorInfo when the request is calling Cloud Storage service
  /// with an expired access token:
  ///
  ///     { "reason": "ACCESS_TOKEN_EXPIRED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject"
  ///       }
  ///     }
  static const accessTokenExpired = ErrorReason('ACCESS_TOKEN_EXPIRED');

  /// The request is denied because the provided access token doesn't have at
  /// least one of the acceptable scopes required for the API. Please check
  /// [OAuth 2.0 Scopes for Google
  /// APIs](https://developers.google.com/identity/protocols/oauth2/scopes) for
  /// the list of the OAuth 2.0 scopes that you might need to request to access
  /// the API.
  ///
  /// Example of an ErrorInfo when the request is calling Cloud Storage service
  /// with an access token that is missing required scopes:
  ///
  ///     { "reason": "ACCESS_TOKEN_SCOPE_INSUFFICIENT",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject"
  ///       }
  ///     }
  static const accessTokenScopeInsufficient = ErrorReason(
    'ACCESS_TOKEN_SCOPE_INSUFFICIENT',
  );

  /// The request is denied because the account associated with the provided
  /// access token is in an invalid state, such as disabled or deleted.
  /// For more information, see https://cloud.google.com/docs/authentication.
  ///
  /// Warning: For privacy reasons, the server may not be able to disclose the
  /// email address for some accounts. The client MUST NOT depend on the
  /// availability of the `email` attribute.
  ///
  /// Example of an ErrorInfo when the request is to the Cloud Storage API with
  /// an access token that is associated with a disabled or deleted [service
  /// account](http://cloud/iam/docs/service-accounts):
  ///
  ///     { "reason": "ACCOUNT_STATE_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject",
  ///         "email": "user@123.iam.gserviceaccount.com"
  ///       }
  ///     }
  static const accountStateInvalid = ErrorReason('ACCOUNT_STATE_INVALID');

  /// The request is denied because the type of the provided access token is not
  /// supported by the API being called.
  ///
  /// Example of an ErrorInfo when the request is to the Cloud Storage API with
  /// an unsupported token type.
  ///
  ///     { "reason": "ACCESS_TOKEN_TYPE_UNSUPPORTED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject"
  ///       }
  ///     }
  static const accessTokenTypeUnsupported = ErrorReason(
    'ACCESS_TOKEN_TYPE_UNSUPPORTED',
  );

  /// The request is denied because the request doesn't have any authentication
  /// credentials. For more information regarding the supported authentication
  /// strategies for Google Cloud APIs, see
  /// https://cloud.google.com/docs/authentication.
  ///
  /// Example of an ErrorInfo when the request is to the Cloud Storage API
  /// without any authentication credentials.
  ///
  ///     { "reason": "CREDENTIALS_MISSING",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject"
  ///       }
  ///     }
  static const credentialsMissing = ErrorReason('CREDENTIALS_MISSING');

  /// The request is denied because the provided project owning the resource
  /// which acts as the [API
  /// consumer](https://cloud.google.com/apis/design/glossary#api_consumer) is
  /// invalid. It may be in a bad format or empty.
  ///
  /// Example of an ErrorInfo when the request is to the Cloud Functions API,
  /// but the offered resource project in the request in a bad format which can't
  /// perform the ListFunctions method.
  ///
  ///     { "reason": "RESOURCE_PROJECT_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "cloudfunctions.googleapis.com",
  ///         "method":
  ///         "google.cloud.functions.v1.CloudFunctionsService.ListFunctions"
  ///       }
  ///     }
  static const resourceProjectInvalid = ErrorReason('RESOURCE_PROJECT_INVALID');

  /// The request is denied because the provided session cookie is missing,
  /// invalid or failed to decode.
  ///
  /// Example of an ErrorInfo when the request is calling Cloud Storage service
  /// with a SID cookie which can't be decoded.
  ///
  ///     { "reason": "SESSION_COOKIE_INVALID",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject",
  ///         "cookie": "SID"
  ///       }
  ///     }
  static const sessionCookieInvalid = ErrorReason('SESSION_COOKIE_INVALID');

  /// The request is denied because the user is from a Google Workspace customer
  /// that blocks their users from accessing a particular service.
  ///
  /// Example scenario: https://support.google.com/a/answer/9197205?hl=en
  ///
  /// Example of an ErrorInfo when access to Google Cloud Storage service is
  /// blocked by the Google Workspace administrator:
  ///
  ///     { "reason": "USER_BLOCKED_BY_ADMIN",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "storage.googleapis.com",
  ///         "method": "google.storage.v1.Storage.GetObject",
  ///       }
  ///     }
  static const userBlockedByAdmin = ErrorReason('USER_BLOCKED_BY_ADMIN');

  /// The request is denied because the resource service usage is restricted
  /// by administrators according to the organization policy constraint.
  /// For more information see
  /// https://cloud.google.com/resource-manager/docs/organization-policy/restricting-services.
  ///
  /// Example of an ErrorInfo when access to Google Cloud Storage service is
  /// restricted by Resource Usage Restriction policy:
  ///
  ///     { "reason": "RESOURCE_USAGE_RESTRICTION_VIOLATED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/project-123",
  ///         "service": "storage.googleapis.com"
  ///       }
  ///     }
  static const resourceUsageRestrictionViolated = ErrorReason(
    'RESOURCE_USAGE_RESTRICTION_VIOLATED',
  );

  /// Unimplemented. Do not use.
  ///
  /// The request is denied because it contains unsupported system parameters in
  /// URL query parameters or HTTP headers. For more information,
  /// see https://cloud.google.com/apis/docs/system-parameters
  ///
  /// Example of an ErrorInfo when access "pubsub.googleapis.com" service with
  /// a request header of "x-goog-user-ip":
  ///
  ///     { "reason": "SYSTEM_PARAMETER_UNSUPPORTED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "service": "pubsub.googleapis.com"
  ///         "parameter": "x-goog-user-ip"
  ///       }
  ///     }
  static const systemParameterUnsupported = ErrorReason(
    'SYSTEM_PARAMETER_UNSUPPORTED',
  );

  /// The request is denied because it violates Org Restriction: the requested
  /// resource does not belong to allowed organizations specified in
  /// "X-Goog-Allowed-Resources" header.
  ///
  /// Example of an ErrorInfo when accessing a GCP resource that is restricted by
  /// Org Restriction for "pubsub.googleapis.com" service.
  ///
  /// {
  ///   reason: "ORG_RESTRICTION_VIOLATION"
  ///   domain: "googleapis.com"
  ///   metadata {
  ///     "consumer":"projects/123456"
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  static const orgRestrictionViolation = ErrorReason(
    'ORG_RESTRICTION_VIOLATION',
  );

  /// The request is denied because "X-Goog-Allowed-Resources" header is in a bad
  /// format.
  ///
  /// Example of an ErrorInfo when
  /// accessing "pubsub.googleapis.com" service with an invalid
  /// "X-Goog-Allowed-Resources" request header.
  ///
  /// {
  ///   reason: "ORG_RESTRICTION_HEADER_INVALID"
  ///   domain: "googleapis.com"
  ///   metadata {
  ///     "consumer":"projects/123456"
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  static const orgRestrictionHeaderInvalid = ErrorReason(
    'ORG_RESTRICTION_HEADER_INVALID',
  );

  /// Unimplemented. Do not use.
  ///
  /// The request is calling a service that is not visible to the consumer.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" contacting
  ///  "pubsub.googleapis.com" service which is not visible to the consumer.
  ///
  ///     { "reason": "SERVICE_NOT_VISIBLE",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com"
  ///       }
  ///     }
  ///
  /// This response indicates the "pubsub.googleapis.com" is not visible to
  /// "projects/123" (or it may not exist).
  static const serviceNotVisible = ErrorReason('SERVICE_NOT_VISIBLE');

  /// The request is related to a project for which GCP access is suspended.
  ///
  /// Example of an ErrorInfo when the consumer "projects/123" fails to contact
  /// "pubsub.googleapis.com" service because GCP access is suspended:
  ///
  ///     { "reason": "GCP_SUSPENDED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "pubsub.googleapis.com"
  ///       }
  ///     }
  ///
  /// This response indicates the associated GCP account has been suspended.
  static const gcpSuspended = ErrorReason('GCP_SUSPENDED');

  /// The request violates the location policies when creating resources in
  /// the restricted region.
  ///
  /// Example of an ErrorInfo when creating the Cloud Storage Bucket by
  /// "projects/123" for service storage.googleapis.com:
  ///
  ///     { "reason": "LOCATION_POLICY_VIOLATED",
  ///       "domain": "googleapis.com",
  ///       "metadata": {
  ///         "consumer": "projects/123",
  ///         "service": "storage.googleapis.com",
  ///       }
  ///     }
  ///
  /// This response indicates creating the Cloud Storage Bucket in
  /// "locations/asia-northeast3" violates at least one location policy.
  /// The troubleshooting guidance is provided in the Help links.
  static const locationPolicyViolated = ErrorReason('LOCATION_POLICY_VIOLATED');

  /// The request is denied because origin request header is missing.
  ///
  /// Example of an ErrorInfo when
  /// accessing "pubsub.googleapis.com" service with an empty "Origin" request
  /// header.
  ///
  /// {
  ///   reason: "MISSING_ORIGIN"
  ///   domain: "googleapis.com"
  ///   metadata {
  ///     "consumer":"projects/123456"
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  static const missingOrigin = ErrorReason('MISSING_ORIGIN');

  /// The request is denied because the request contains more than one credential
  /// type that are individually acceptable, but not together. The customer
  /// should retry their request with only one set of credentials.
  ///
  /// Example of an ErrorInfo when
  /// accessing "pubsub.googleapis.com" service with overloaded credentials.
  ///
  /// {
  ///   reason: "OVERLOADED_CREDENTIALS"
  ///   domain: "googleapis.com"
  ///   metadata {
  ///     "consumer":"projects/123456"
  ///     "service": "pubsub.googleapis.com"
  ///   }
  /// }
  static const overloadedCredentials = ErrorReason('OVERLOADED_CREDENTIALS');

  /// The default value for [ErrorReason].
  static const $default = errorReasonUnspecified;

  const ErrorReason(super.value);

  factory ErrorReason.fromJson(Object? json) => ErrorReason(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ErrorReason.$value';
}

/// An indicator of the behavior of a given field (for example, that a field
/// is required in requests, or given as output but ignored as input).
/// This **does not** change the behavior in protocol buffers itself; it only
/// denotes the behavior and may affect how API tooling handles the field.
///
/// Note: This enum **may** receive new values in the future.
final class FieldBehavior extends ProtoEnum {
  /// Conventional default for enums. Do not use this.
  static const fieldBehaviorUnspecified = FieldBehavior(
    'FIELD_BEHAVIOR_UNSPECIFIED',
  );

  /// Specifically denotes a field as optional.
  /// While all fields in protocol buffers are optional, this may be specified
  /// for emphasis if appropriate.
  static const optional = FieldBehavior('OPTIONAL');

  /// Denotes a field as required.
  /// This indicates that the field **must** be provided as part of the request,
  /// and failure to do so will cause an error (usually `INVALID_ARGUMENT`).
  static const required = FieldBehavior('REQUIRED');

  /// Denotes a field as output only.
  /// This indicates that the field is provided in responses, but including the
  /// field in a request does nothing (the server *must* ignore it and
  /// *must not* throw an error as a result of the field's presence).
  static const outputOnly = FieldBehavior('OUTPUT_ONLY');

  /// Denotes a field as input only.
  /// This indicates that the field is provided in requests, and the
  /// corresponding field is not included in output.
  static const inputOnly = FieldBehavior('INPUT_ONLY');

  /// Denotes a field as immutable.
  /// This indicates that the field may be set once in a request to create a
  /// resource, but may not be changed thereafter.
  static const immutable = FieldBehavior('IMMUTABLE');

  /// Denotes that a (repeated) field is an unordered list.
  /// This indicates that the service may provide the elements of the list
  /// in any arbitrary  order, rather than the order the user originally
  /// provided. Additionally, the list's order may or may not be stable.
  static const unorderedList = FieldBehavior('UNORDERED_LIST');

  /// Denotes that this field returns a non-empty default value if not set.
  /// This indicates that if the user provides the empty value in a request,
  /// a non-empty value will be returned. The user will not be aware of what
  /// non-empty value to expect.
  static const nonEmptyDefault = FieldBehavior('NON_EMPTY_DEFAULT');

  /// Denotes that the field in a resource (a message annotated with
  /// google.api.resource) is used in the resource name to uniquely identify the
  /// resource. For AIP-compliant APIs, this should only be applied to the
  /// `name` field on the resource.
  ///
  /// This behavior should not be applied to references to other resources within
  /// the message.
  ///
  /// The identifier field of resources often have different field behavior
  /// depending on the request it is embedded in (e.g. for Create methods name
  /// is optional and unused, while for Update methods it is required). Instead
  /// of method-specific annotations, only `IDENTIFIER` is required.
  static const identifier = FieldBehavior('IDENTIFIER');

  /// The default value for [FieldBehavior].
  static const $default = fieldBehaviorUnspecified;

  const FieldBehavior(super.value);

  factory FieldBehavior.fromJson(Object? json) => FieldBehavior(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'FieldBehavior.$value';
}

/// The launch stage as defined by [Google Cloud Platform
/// Launch Stages](https://cloud.google.com/terms/launch-stages).
final class LaunchStage extends ProtoEnum {
  /// Do not use this default value.
  static const launchStageUnspecified = LaunchStage('LAUNCH_STAGE_UNSPECIFIED');

  /// The feature is not yet implemented. Users can not use it.
  static const unimplemented = LaunchStage('UNIMPLEMENTED');

  /// Prelaunch features are hidden from users and are only visible internally.
  static const prelaunch = LaunchStage('PRELAUNCH');

  /// Early Access features are limited to a closed group of testers. To use
  /// these features, you must sign up in advance and sign a Trusted Tester
  /// agreement (which includes confidentiality provisions). These features may
  /// be unstable, changed in backward-incompatible ways, and are not
  /// guaranteed to be released.
  static const earlyAccess = LaunchStage('EARLY_ACCESS');

  /// Alpha is a limited availability test for releases before they are cleared
  /// for widespread use. By Alpha, all significant design issues are resolved
  /// and we are in the process of verifying functionality. Alpha customers
  /// need to apply for access, agree to applicable terms, and have their
  /// projects allowlisted. Alpha releases don't have to be feature complete,
  /// no SLAs are provided, and there are no technical support obligations, but
  /// they will be far enough along that customers can actually use them in
  /// test environments or for limited-use tests -- just like they would in
  /// normal production cases.
  static const alpha = LaunchStage('ALPHA');

  /// Beta is the point at which we are ready to open a release for any
  /// customer to use. There are no SLA or technical support obligations in a
  /// Beta release. Products will be complete from a feature perspective, but
  /// may have some open outstanding issues. Beta releases are suitable for
  /// limited production use cases.
  static const beta = LaunchStage('BETA');

  /// GA features are open to all developers and are considered stable and
  /// fully qualified for production use.
  static const ga = LaunchStage('GA');

  /// Deprecated features are scheduled to be shut down and removed. For more
  /// information, see the "Deprecation Policy" section of our [Terms of
  /// Service](https://cloud.google.com/terms/)
  /// and the [Google Cloud Platform Subject to the Deprecation
  /// Policy](https://cloud.google.com/terms/deprecation) documentation.
  static const deprecated = LaunchStage('DEPRECATED');

  /// The default value for [LaunchStage].
  static const $default = launchStageUnspecified;

  const LaunchStage(super.value);

  factory LaunchStage.fromJson(Object? json) => LaunchStage(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'LaunchStage.$value';
}
