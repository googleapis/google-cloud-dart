// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Secret Manager API.
///
/// Stores sensitive data such as API keys, passwords, and certificates.
/// Provides convenience while improving security.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_iam_v1/iam.dart';
import 'package:google_cloud_location/location.dart';
import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// Secret Manager Service
///
/// Manages secrets and operations using those secrets. Implements a REST
/// model with the following objects:
///
/// * `Secret`
/// * `SecretVersion`
final class SecretManagerService {
  static const _host = 'secretmanager.googleapis.com';

  final ServiceClient _client;

  /// Creates a `SecretManagerService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `SecretManagerService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  SecretManagerService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `SecretManagerService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory SecretManagerService.fromApiKey([String? apiKey]) =>
      SecretManagerService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Lists `Secrets`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSecretsResponse> listSecrets(ListSecretsRequest request) async {
    final url = Uri.https(_host, '/v1/${request.parent}/secrets', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
    });
    final response = await _client.get(url);
    return ListSecretsResponse.fromJson(response);
  }

  /// Creates a new `Secret` containing no
  /// `SecretVersions`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Secret> createSecret(CreateSecretRequest request) async {
    final url = Uri.https(_host, '/v1/${request.parent}/secrets', {
      if (request.secretId case final $1 when $1.isNotDefault) 'secretId': $1,
    });
    final response = await _client.post(url, body: request.secret);
    return Secret.fromJson(response);
  }

  /// Creates a new `SecretVersion`
  /// containing secret data and attaches it to an existing
  /// `Secret`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SecretVersion> addSecretVersion(
    AddSecretVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.parent}:addVersion');
    final response = await _client.post(url, body: request);
    return SecretVersion.fromJson(response);
  }

  /// Gets metadata for a given `Secret`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Secret> getSecret(GetSecretRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    final response = await _client.get(url);
    return Secret.fromJson(response);
  }

  /// Updates metadata of an existing
  /// `Secret`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Secret> updateSecret(UpdateSecretRequest request) async {
    final url = Uri.https(_host, '/v1/${request.secret!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.secret);
    return Secret.fromJson(response);
  }

  /// Deletes a `Secret`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteSecret(DeleteSecretRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}', {
      if (request.etag case final $1 when $1.isNotDefault) 'etag': $1,
    });
    await _client.delete(url);
  }

  /// Lists `SecretVersions`. This
  /// call does not return secret data.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSecretVersionsResponse> listSecretVersions(
    ListSecretVersionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.parent}/versions', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
    });
    final response = await _client.get(url);
    return ListSecretVersionsResponse.fromJson(response);
  }

  /// Gets metadata for a
  /// `SecretVersion`.
  ///
  /// `projects/*/secrets/*/versions/latest` is an alias to the most recently
  /// created `SecretVersion`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SecretVersion> getSecretVersion(
    GetSecretVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    final response = await _client.get(url);
    return SecretVersion.fromJson(response);
  }

  /// Accesses a `SecretVersion`.
  /// This call returns the secret data.
  ///
  /// `projects/*/secrets/*/versions/latest` is an alias to the most recently
  /// created `SecretVersion`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<AccessSecretVersionResponse> accessSecretVersion(
    AccessSecretVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.name}:access');
    final response = await _client.get(url);
    return AccessSecretVersionResponse.fromJson(response);
  }

  /// Disables a `SecretVersion`.
  ///
  /// Sets the `state` of the
  /// `SecretVersion` to
  /// `DISABLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SecretVersion> disableSecretVersion(
    DisableSecretVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.name}:disable');
    final response = await _client.post(url, body: request);
    return SecretVersion.fromJson(response);
  }

  /// Enables a `SecretVersion`.
  ///
  /// Sets the `state` of the
  /// `SecretVersion` to
  /// `ENABLED`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SecretVersion> enableSecretVersion(
    EnableSecretVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.name}:enable');
    final response = await _client.post(url, body: request);
    return SecretVersion.fromJson(response);
  }

  /// Destroys a `SecretVersion`.
  ///
  /// Sets the `state` of the
  /// `SecretVersion` to
  /// `DESTROYED`
  /// and irrevocably destroys the secret data.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SecretVersion> destroySecretVersion(
    DestroySecretVersionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.name}:destroy');
    final response = await _client.post(url, body: request);
    return SecretVersion.fromJson(response);
  }

  /// Sets the access control policy on the specified secret. Replaces any
  /// existing policy.
  ///
  /// Permissions on
  /// `SecretVersions` are enforced
  /// according to the policy set on the associated
  /// `Secret`.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a secret.
  /// Returns empty policy if the secret exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:getIamPolicy', {
      if (request.options!.requestedPolicyVersion case final $1
          when $1.isNotDefault)
        'options.requestedPolicyVersion': '${$1}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has for the specified secret.
  /// If the secret does not exist, this call returns an empty set of
  /// permissions, not a NOT_FOUND error.
  ///
  /// Note: This operation is designed to be used for building permission-aware
  /// UIs and command-line tools, not for authorization checking. This operation
  /// may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.resource}:testIamPermissions');
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Gets information about a location.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/v1/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A `Secret` is a logical secret whose
/// value and versions can be accessed.
///
/// A `Secret` is made up of zero or more
/// `SecretVersions` that represent
/// the secret data.
final class Secret extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.Secret';

  /// Output only. The resource name of the
  /// `Secret` in the format
  /// `projects/*/secrets/*`.
  final String name;

  /// Optional. Immutable. The replication policy of the secret data attached to
  /// the `Secret`.
  ///
  /// The replication policy cannot be changed after the Secret has been created.
  final Replication? replication;

  /// Output only. The time at which the
  /// `Secret` was created.
  final Timestamp? createTime;

  /// The labels assigned to this Secret.
  ///
  /// Label keys must be between 1 and 63 characters long, have a UTF-8 encoding
  /// of maximum 128 bytes, and must conform to the following PCRE regular
  /// expression: `[\p{Ll}\p{Lo}][\p{Ll}\p{Lo}\p{N}_-]{0,62}`
  ///
  /// Label values must be between 0 and 63 characters long, have a UTF-8
  /// encoding of maximum 128 bytes, and must conform to the following PCRE
  /// regular expression: `[\p{Ll}\p{Lo}\p{N}_-]{0,63}`
  ///
  /// No more than 64 labels can be assigned to a given resource.
  final Map<String, String> labels;

  /// Optional. A list of up to 10 Pub/Sub topics to which messages are published
  /// when control plane operations are called on the secret or its versions.
  final List<Topic> topics;

  /// Optional. Timestamp in UTC when the
  /// `Secret` is scheduled to expire.
  /// This is always provided on output, regardless of what was sent on input.
  final Timestamp? expireTime;

  /// Input only. The TTL for the
  /// `Secret`.
  final Duration? ttl;

  /// Optional. Etag of the currently stored
  /// `Secret`.
  final String etag;

  /// Optional. Rotation policy attached to the
  /// `Secret`. May be excluded if there is
  /// no rotation policy.
  final Rotation? rotation;

  /// Optional. Mapping from version alias to version name.
  ///
  /// A version alias is a string with a maximum length of 63 characters and can
  /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`)
  /// and underscore ('_') characters. An alias string must start with a
  /// letter and cannot be the string 'latest' or 'NEW'.
  /// No more than 50 aliases can be assigned to a given secret.
  ///
  /// Version-Alias pairs will be viewable via GetSecret and modifiable via
  /// UpdateSecret. Access by alias is only be supported on
  /// GetSecretVersion and AccessSecretVersion.
  final Map<String, int> versionAliases;

  /// Optional. Custom metadata about the secret.
  ///
  /// Annotations are distinct from various forms of labels.
  /// Annotations exist to allow client tools to store their own state
  /// information without requiring a database.
  ///
  /// Annotation keys must be between 1 and 63 characters long, have a UTF-8
  /// encoding of maximum 128 bytes, begin and end with an alphanumeric character
  /// ([a-z0-9A-Z]), and may have dashes (-), underscores (_), dots (.), and
  /// alphanumerics in between these symbols.
  ///
  /// The total size of annotation keys and values must be less than 16KiB.
  final Map<String, String> annotations;

  /// Optional. Secret Version TTL after destruction request
  ///
  /// This is a part of the Delayed secret version destroy feature.
  /// For secret with TTL>0, version destruction doesn't happen immediately
  /// on calling destroy instead the version goes to a disabled state and
  /// destruction happens after the TTL expires.
  final Duration? versionDestroyTtl;

  /// Optional. The customer-managed encryption configuration of the regionalized
  /// secrets. If no configuration is provided, Google-managed default encryption
  /// is used.
  ///
  /// Updates to the `Secret` encryption
  /// configuration only apply to
  /// `SecretVersions` added
  /// afterwards. They do not apply retroactively to existing
  /// `SecretVersions`.
  final CustomerManagedEncryption? customerManagedEncryption;

  /// Optional. Input only. Immutable. Mapping of Tag keys/values directly bound
  /// to this resource. For example:
  ///   "123/environment": "production",
  ///   "123/costCenter": "marketing"
  ///
  /// Tags are used to organize and group resources.
  ///
  /// Tags can be used to control policy evaluation for the resource.
  final Map<String, String> tags;

  Secret({
    this.name = '',
    this.replication,
    this.createTime,
    this.labels = const {},
    this.topics = const [],
    this.expireTime,
    this.ttl,
    this.etag = '',
    this.rotation,
    this.versionAliases = const {},
    this.annotations = const {},
    this.versionDestroyTtl,
    this.customerManagedEncryption,
    this.tags = const {},
  }) : super(fullyQualifiedName);

  factory Secret.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Secret(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      replication: switch (json['replication']) {
        null => null,
        Object $1 => Replication.fromJson($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      topics: switch (json['topics']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Topic.fromJson(i)],
        _ => throw const FormatException('"topics" is not a list'),
      },
      expireTime: switch (json['expireTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      ttl: switch (json['ttl']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      rotation: switch (json['rotation']) {
        null => null,
        Object $1 => Rotation.fromJson($1),
      },
      versionAliases: switch (json['versionAliases']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries) decodeString(e.key): decodeInt64(e.value),
        },
        _ => throw const FormatException('"versionAliases" is not an object'),
      },
      annotations: switch (json['annotations']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"annotations" is not an object'),
      },
      versionDestroyTtl: switch (json['versionDestroyTtl']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      customerManagedEncryption: switch (json['customerManagedEncryption']) {
        null => null,
        Object $1 => CustomerManagedEncryption.fromJson($1),
      },
      tags: switch (json['tags']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"tags" is not an object'),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (replication != null) 'replication': replication!.toJson(),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (topics.isNotDefault) 'topics': encodeList(topics),
    if (expireTime != null) 'expireTime': expireTime!.toJson(),
    if (ttl != null) 'ttl': ttl!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (rotation != null) 'rotation': rotation!.toJson(),
    if (versionAliases.isNotDefault) 'versionAliases': versionAliases,
    if (annotations.isNotDefault) 'annotations': annotations,
    if (versionDestroyTtl != null)
      'versionDestroyTtl': versionDestroyTtl!.toJson(),
    if (customerManagedEncryption != null)
      'customerManagedEncryption': customerManagedEncryption!.toJson(),
    if (tags.isNotDefault) 'tags': tags,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'etag=$etag'].join(',');
    return 'Secret($contents)';
  }
}

/// A secret version resource in the Secret Manager API.
final class SecretVersion extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.SecretVersion';

  /// Output only. The resource name of the
  /// `SecretVersion` in the format
  /// `projects/*/secrets/*/versions/*`.
  ///
  /// `SecretVersion` IDs in a
  /// `Secret` start at 1 and are
  /// incremented for each subsequent version of the secret.
  final String name;

  /// Output only. The time at which the
  /// `SecretVersion` was created.
  final Timestamp? createTime;

  /// Output only. The time this
  /// `SecretVersion` was destroyed.
  /// Only present if `state`
  /// is
  /// `DESTROYED`.
  final Timestamp? destroyTime;

  /// Output only. The current state of the
  /// `SecretVersion`.
  final SecretVersion_State state;

  /// The replication status of the
  /// `SecretVersion`.
  final ReplicationStatus? replicationStatus;

  /// Output only. Etag of the currently stored
  /// `SecretVersion`.
  final String etag;

  /// Output only. True if payload checksum specified in
  /// `SecretPayload` object has
  /// been received by
  /// `SecretManagerService`
  /// on
  /// `SecretManagerService.AddSecretVersion`.
  final bool clientSpecifiedPayloadChecksum;

  /// Optional. Output only. Scheduled destroy time for secret version.
  /// This is a part of the Delayed secret version destroy feature. For a
  /// Secret with a valid version destroy TTL, when a secert version is
  /// destroyed, version is moved to disabled state and it is scheduled for
  /// destruction Version is destroyed only after the scheduled_destroy_time.
  final Timestamp? scheduledDestroyTime;

  /// Output only. The customer-managed encryption status of the
  /// `SecretVersion`. Only
  /// populated if customer-managed encryption is used and
  /// `Secret` is a regionalized secret.
  final CustomerManagedEncryptionStatus? customerManagedEncryption;

  SecretVersion({
    this.name = '',
    this.createTime,
    this.destroyTime,
    this.state = SecretVersion_State.$default,
    this.replicationStatus,
    this.etag = '',
    this.clientSpecifiedPayloadChecksum = false,
    this.scheduledDestroyTime,
    this.customerManagedEncryption,
  }) : super(fullyQualifiedName);

  factory SecretVersion.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SecretVersion(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      destroyTime: switch (json['destroyTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      state: switch (json['state']) {
        null => SecretVersion_State.$default,
        Object $1 => SecretVersion_State.fromJson($1),
      },
      replicationStatus: switch (json['replicationStatus']) {
        null => null,
        Object $1 => ReplicationStatus.fromJson($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
      clientSpecifiedPayloadChecksum:
          switch (json['clientSpecifiedPayloadChecksum']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      scheduledDestroyTime: switch (json['scheduledDestroyTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      customerManagedEncryption: switch (json['customerManagedEncryption']) {
        null => null,
        Object $1 => CustomerManagedEncryptionStatus.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (destroyTime != null) 'destroyTime': destroyTime!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (replicationStatus != null)
      'replicationStatus': replicationStatus!.toJson(),
    if (etag.isNotDefault) 'etag': etag,
    if (clientSpecifiedPayloadChecksum.isNotDefault)
      'clientSpecifiedPayloadChecksum': clientSpecifiedPayloadChecksum,
    if (scheduledDestroyTime != null)
      'scheduledDestroyTime': scheduledDestroyTime!.toJson(),
    if (customerManagedEncryption != null)
      'customerManagedEncryption': customerManagedEncryption!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'state=$state',
      'etag=$etag',
      'clientSpecifiedPayloadChecksum=$clientSpecifiedPayloadChecksum',
    ].join(',');
    return 'SecretVersion($contents)';
  }
}

/// The state of a
/// `SecretVersion`, indicating if
/// it can be accessed.
final class SecretVersion_State extends ProtoEnum {
  /// Not specified. This value is unused and invalid.
  static const stateUnspecified = SecretVersion_State('STATE_UNSPECIFIED');

  /// The `SecretVersion` may be
  /// accessed.
  static const enabled = SecretVersion_State('ENABLED');

  /// The `SecretVersion` may not
  /// be accessed, but the secret data is still available and can be placed
  /// back into the
  /// `ENABLED`
  /// state.
  static const disabled = SecretVersion_State('DISABLED');

  /// The `SecretVersion` is
  /// destroyed and the secret data is no longer stored. A version may not
  /// leave this state once entered.
  static const destroyed = SecretVersion_State('DESTROYED');

  /// The default value for [SecretVersion_State].
  static const $default = stateUnspecified;

  const SecretVersion_State(super.value);

  factory SecretVersion_State.fromJson(Object? json) =>
      SecretVersion_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// A policy that defines the replication and encryption configuration of data.
final class Replication extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.Replication';

  /// The `Secret` will automatically be
  /// replicated without any restrictions.
  final Replication_Automatic? automatic;

  /// The `Secret` will only be
  /// replicated into the locations specified.
  final Replication_UserManaged? userManaged;

  Replication({this.automatic, this.userManaged}) : super(fullyQualifiedName);

  factory Replication.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Replication(
      automatic: switch (json['automatic']) {
        null => null,
        Object $1 => Replication_Automatic.fromJson($1),
      },
      userManaged: switch (json['userManaged']) {
        null => null,
        Object $1 => Replication_UserManaged.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (automatic != null) 'automatic': automatic!.toJson(),
    if (userManaged != null) 'userManaged': userManaged!.toJson(),
  };

  @override
  String toString() => 'Replication()';
}

/// A replication policy that replicates the
/// `Secret` payload without any
/// restrictions.
final class Replication_Automatic extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.Replication.Automatic';

  /// Optional. The customer-managed encryption configuration of the
  /// `Secret`. If no configuration is
  /// provided, Google-managed default encryption is used.
  ///
  /// Updates to the `Secret` encryption
  /// configuration only apply to
  /// `SecretVersions` added
  /// afterwards. They do not apply retroactively to existing
  /// `SecretVersions`.
  final CustomerManagedEncryption? customerManagedEncryption;

  Replication_Automatic({this.customerManagedEncryption})
    : super(fullyQualifiedName);

  factory Replication_Automatic.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Replication_Automatic(
      customerManagedEncryption: switch (json['customerManagedEncryption']) {
        null => null,
        Object $1 => CustomerManagedEncryption.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (customerManagedEncryption != null)
      'customerManagedEncryption': customerManagedEncryption!.toJson(),
  };

  @override
  String toString() => 'Automatic()';
}

/// A replication policy that replicates the
/// `Secret` payload into the locations
/// specified in
/// `Replication.UserManaged.replicas`
final class Replication_UserManaged extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.Replication.UserManaged';

  /// Required. The list of Replicas for this
  /// `Secret`.
  ///
  /// Cannot be empty.
  final List<Replication_UserManaged_Replica> replicas;

  Replication_UserManaged({required this.replicas}) : super(fullyQualifiedName);

  factory Replication_UserManaged.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Replication_UserManaged(
      replicas: switch (json['replicas']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) Replication_UserManaged_Replica.fromJson(i),
        ],
        _ => throw const FormatException('"replicas" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'replicas': encodeList(replicas)};

  @override
  String toString() => 'UserManaged()';
}

/// Represents a Replica for this
/// `Secret`.
final class Replication_UserManaged_Replica extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.Replication.UserManaged.Replica';

  /// The canonical IDs of the location to replicate data.
  /// For example: `"us-east1"`.
  final String location;

  /// Optional. The customer-managed encryption configuration of the
  /// [User-Managed Replica][Replication.UserManaged.Replica]. If no
  /// configuration is provided, Google-managed default encryption is used.
  ///
  /// Updates to the `Secret`
  /// encryption configuration only apply to
  /// `SecretVersions` added
  /// afterwards. They do not apply retroactively to existing
  /// `SecretVersions`.
  final CustomerManagedEncryption? customerManagedEncryption;

  Replication_UserManaged_Replica({
    this.location = '',
    this.customerManagedEncryption,
  }) : super(fullyQualifiedName);

  factory Replication_UserManaged_Replica.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Replication_UserManaged_Replica(
      location: switch (json['location']) {
        null => '',
        Object $1 => decodeString($1),
      },
      customerManagedEncryption: switch (json['customerManagedEncryption']) {
        null => null,
        Object $1 => CustomerManagedEncryption.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (location.isNotDefault) 'location': location,
    if (customerManagedEncryption != null)
      'customerManagedEncryption': customerManagedEncryption!.toJson(),
  };

  @override
  String toString() {
    final contents = ['location=$location'].join(',');
    return 'Replica($contents)';
  }
}

/// Configuration for encrypting secret payloads using customer-managed
/// encryption keys (CMEK).
final class CustomerManagedEncryption extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.CustomerManagedEncryption';

  /// Required. The resource name of the Cloud KMS CryptoKey used to encrypt
  /// secret payloads.
  ///
  /// For secrets using the
  /// `UserManaged`
  /// replication policy type, Cloud KMS CryptoKeys must reside in the same
  /// location as the [replica location][Secret.UserManaged.Replica.location].
  ///
  /// For secrets using the
  /// `Automatic`
  /// replication policy type, Cloud KMS CryptoKeys must reside in `global`.
  ///
  /// The expected format is `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
  final String kmsKeyName;

  CustomerManagedEncryption({required this.kmsKeyName})
    : super(fullyQualifiedName);

  factory CustomerManagedEncryption.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CustomerManagedEncryption(
      kmsKeyName: switch (json['kmsKeyName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'kmsKeyName': kmsKeyName};

  @override
  String toString() {
    final contents = ['kmsKeyName=$kmsKeyName'].join(',');
    return 'CustomerManagedEncryption($contents)';
  }
}

/// The replication status of a
/// `SecretVersion`.
final class ReplicationStatus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.ReplicationStatus';

  /// Describes the replication status of a
  /// `SecretVersion` with
  /// automatic replication.
  ///
  /// Only populated if the parent
  /// `Secret` has an automatic
  /// replication policy.
  final ReplicationStatus_AutomaticStatus? automatic;

  /// Describes the replication status of a
  /// `SecretVersion` with
  /// user-managed replication.
  ///
  /// Only populated if the parent
  /// `Secret` has a user-managed
  /// replication policy.
  final ReplicationStatus_UserManagedStatus? userManaged;

  ReplicationStatus({this.automatic, this.userManaged})
    : super(fullyQualifiedName);

  factory ReplicationStatus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReplicationStatus(
      automatic: switch (json['automatic']) {
        null => null,
        Object $1 => ReplicationStatus_AutomaticStatus.fromJson($1),
      },
      userManaged: switch (json['userManaged']) {
        null => null,
        Object $1 => ReplicationStatus_UserManagedStatus.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (automatic != null) 'automatic': automatic!.toJson(),
    if (userManaged != null) 'userManaged': userManaged!.toJson(),
  };

  @override
  String toString() => 'ReplicationStatus()';
}

/// The replication status of a
/// `SecretVersion` using
/// automatic replication.
///
/// Only populated if the parent `Secret`
/// has an automatic replication policy.
final class ReplicationStatus_AutomaticStatus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.ReplicationStatus.AutomaticStatus';

  /// Output only. The customer-managed encryption status of the
  /// `SecretVersion`. Only
  /// populated if customer-managed encryption is used.
  final CustomerManagedEncryptionStatus? customerManagedEncryption;

  ReplicationStatus_AutomaticStatus({this.customerManagedEncryption})
    : super(fullyQualifiedName);

  factory ReplicationStatus_AutomaticStatus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReplicationStatus_AutomaticStatus(
      customerManagedEncryption: switch (json['customerManagedEncryption']) {
        null => null,
        Object $1 => CustomerManagedEncryptionStatus.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (customerManagedEncryption != null)
      'customerManagedEncryption': customerManagedEncryption!.toJson(),
  };

  @override
  String toString() => 'AutomaticStatus()';
}

/// The replication status of a
/// `SecretVersion` using
/// user-managed replication.
///
/// Only populated if the parent `Secret`
/// has a user-managed replication policy.
final class ReplicationStatus_UserManagedStatus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.ReplicationStatus.UserManagedStatus';

  /// Output only. The list of replica statuses for the
  /// `SecretVersion`.
  final List<ReplicationStatus_UserManagedStatus_ReplicaStatus> replicas;

  ReplicationStatus_UserManagedStatus({this.replicas = const []})
    : super(fullyQualifiedName);

  factory ReplicationStatus_UserManagedStatus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ReplicationStatus_UserManagedStatus(
      replicas: switch (json['replicas']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1)
            ReplicationStatus_UserManagedStatus_ReplicaStatus.fromJson(i),
        ],
        _ => throw const FormatException('"replicas" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (replicas.isNotDefault) 'replicas': encodeList(replicas),
  };

  @override
  String toString() => 'UserManagedStatus()';
}

/// Describes the status of a user-managed replica for the
/// `SecretVersion`.
final class ReplicationStatus_UserManagedStatus_ReplicaStatus
    extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.ReplicationStatus.UserManagedStatus.ReplicaStatus';

  /// Output only. The canonical ID of the replica location.
  /// For example: `"us-east1"`.
  final String location;

  /// Output only. The customer-managed encryption status of the
  /// `SecretVersion`. Only
  /// populated if customer-managed encryption is used.
  final CustomerManagedEncryptionStatus? customerManagedEncryption;

  ReplicationStatus_UserManagedStatus_ReplicaStatus({
    this.location = '',
    this.customerManagedEncryption,
  }) : super(fullyQualifiedName);

  factory ReplicationStatus_UserManagedStatus_ReplicaStatus.fromJson(
    Object? j,
  ) {
    final json = j as Map<String, Object?>;
    return ReplicationStatus_UserManagedStatus_ReplicaStatus(
      location: switch (json['location']) {
        null => '',
        Object $1 => decodeString($1),
      },
      customerManagedEncryption: switch (json['customerManagedEncryption']) {
        null => null,
        Object $1 => CustomerManagedEncryptionStatus.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (location.isNotDefault) 'location': location,
    if (customerManagedEncryption != null)
      'customerManagedEncryption': customerManagedEncryption!.toJson(),
  };

  @override
  String toString() {
    final contents = ['location=$location'].join(',');
    return 'ReplicaStatus($contents)';
  }
}

/// Describes the status of customer-managed encryption.
final class CustomerManagedEncryptionStatus extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.CustomerManagedEncryptionStatus';

  /// Required. The resource name of the Cloud KMS CryptoKeyVersion used to
  /// encrypt the secret payload, in the following format:
  /// `projects/*/locations/*/keyRings/*/cryptoKeys/*/versions/*`.
  final String kmsKeyVersionName;

  CustomerManagedEncryptionStatus({required this.kmsKeyVersionName})
    : super(fullyQualifiedName);

  factory CustomerManagedEncryptionStatus.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CustomerManagedEncryptionStatus(
      kmsKeyVersionName: switch (json['kmsKeyVersionName']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'kmsKeyVersionName': kmsKeyVersionName};

  @override
  String toString() {
    final contents = ['kmsKeyVersionName=$kmsKeyVersionName'].join(',');
    return 'CustomerManagedEncryptionStatus($contents)';
  }
}

/// A Pub/Sub topic which Secret Manager will publish to when control plane
/// events occur on this secret.
final class Topic extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.Topic';

  /// Identifier. The resource name of the Pub/Sub topic that will be published
  /// to, in the following format: `projects/*/topics/*`. For publication to
  /// succeed, the Secret Manager service agent must have the
  /// `pubsub.topic.publish` permission on the topic. The Pub/Sub Publisher role
  /// (`roles/pubsub.publisher`) includes this permission.
  final String name;

  Topic({this.name = ''}) : super(fullyQualifiedName);

  factory Topic.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Topic(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (name.isNotDefault) 'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'Topic($contents)';
  }
}

/// The rotation time and period for a
/// `Secret`. At next_rotation_time, Secret
/// Manager will send a Pub/Sub notification to the topics configured on the
/// Secret. `Secret.topics` must be
/// set to configure rotation.
final class Rotation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.Rotation';

  /// Optional. Timestamp in UTC at which the
  /// `Secret` is scheduled to rotate.
  /// Cannot be set to less than 300s (5 min) in the future and at most
  /// 3153600000s (100 years).
  ///
  /// `next_rotation_time`
  /// MUST  be set if
  /// `rotation_period`
  /// is set.
  final Timestamp? nextRotationTime;

  /// Input only. The Duration between rotation notifications. Must be in seconds
  /// and at least 3600s (1h) and at most 3153600000s (100 years).
  ///
  /// If
  /// `rotation_period`
  /// is set,
  /// `next_rotation_time`
  /// must be set.
  /// `next_rotation_time`
  /// will be advanced by this period when the service automatically sends
  /// rotation notifications.
  final Duration? rotationPeriod;

  Rotation({this.nextRotationTime, this.rotationPeriod})
    : super(fullyQualifiedName);

  factory Rotation.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Rotation(
      nextRotationTime: switch (json['nextRotationTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      rotationPeriod: switch (json['rotationPeriod']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (nextRotationTime != null)
      'nextRotationTime': nextRotationTime!.toJson(),
    if (rotationPeriod != null) 'rotationPeriod': rotationPeriod!.toJson(),
  };

  @override
  String toString() => 'Rotation()';
}

/// A secret payload resource in the Secret Manager API. This contains the
/// sensitive secret payload that is associated with a
/// `SecretVersion`.
final class SecretPayload extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.SecretPayload';

  /// The secret data. Must be no larger than 64KiB.
  final Uint8List data;

  /// Optional. If specified,
  /// `SecretManagerService`
  /// will verify the integrity of the received
  /// `data` on
  /// `SecretManagerService.AddSecretVersion`
  /// calls using the crc32c checksum and store it to include in future
  /// `SecretManagerService.AccessSecretVersion`
  /// responses. If a checksum is not provided in the
  /// `SecretManagerService.AddSecretVersion`
  /// request, the
  /// `SecretManagerService`
  /// will generate and store one for you.
  ///
  /// The CRC32C value is encoded as a Int64 for compatibility, and can be
  /// safely downconverted to uint32 in languages that support this type.
  /// https://cloud.google.com/apis/design/design_patterns#integer_types
  final int? dataCrc32C;

  SecretPayload({Uint8List? data, this.dataCrc32C})
    : data = data ?? Uint8List(0),
      super(fullyQualifiedName);

  factory SecretPayload.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SecretPayload(
      data: switch (json['data']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
      dataCrc32C: switch (json['dataCrc32c']) {
        null => null,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (data.isNotDefault) 'data': encodeBytes(data),
    if (dataCrc32C != null) 'dataCrc32c': encodeInt64(dataCrc32C),
  };

  @override
  String toString() {
    final contents = [
      'data=$data',
      if (dataCrc32C != null) 'dataCrc32c=$dataCrc32C',
    ].join(',');
    return 'SecretPayload($contents)';
  }
}

/// Request message for
/// `SecretManagerService.ListSecrets`.
final class ListSecretsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.ListSecretsRequest';

  /// Required. The resource name of the project associated with the
  /// `Secrets`, in the format `projects/*`
  /// or `projects/*/locations/*`
  final String parent;

  /// Optional. The maximum number of results to be returned in a single page. If
  /// set to 0, the server decides the number of results to return. If the
  /// number is greater than 25000, it is capped at 25000.
  final int pageSize;

  /// Optional. Pagination token, returned earlier via
  /// `ListSecretsResponse.next_page_token`.
  final String pageToken;

  /// Optional. Filter string, adhering to the rules in
  /// [List-operation
  /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
  /// only secrets matching the filter. If filter is empty, all secrets are
  /// listed.
  final String filter;

  ListSecretsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
  }) : super(fullyQualifiedName);

  factory ListSecretsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSecretsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
    ].join(',');
    return 'ListSecretsRequest($contents)';
  }
}

/// Response message for
/// `SecretManagerService.ListSecrets`.
final class ListSecretsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.ListSecretsResponse';

  /// The list of `Secrets` sorted in
  /// reverse by create_time (newest first).
  final List<Secret> secrets;

  /// A token to retrieve the next page of results. Pass this value in
  /// `ListSecretsRequest.page_token`
  /// to retrieve the next page.
  final String nextPageToken;

  /// The total number of `Secrets` but 0
  /// when the
  /// `ListSecretsRequest.filter`
  /// field is set.
  final int totalSize;

  ListSecretsResponse({
    this.secrets = const [],
    this.nextPageToken = '',
    this.totalSize = 0,
  }) : super(fullyQualifiedName);

  factory ListSecretsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSecretsResponse(
      secrets: switch (json['secrets']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Secret.fromJson(i)],
        _ => throw const FormatException('"secrets" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      totalSize: switch (json['totalSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (secrets.isNotDefault) 'secrets': encodeList(secrets),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
    if (totalSize.isNotDefault) 'totalSize': totalSize,
  };

  @override
  String toString() {
    final contents = [
      'nextPageToken=$nextPageToken',
      'totalSize=$totalSize',
    ].join(',');
    return 'ListSecretsResponse($contents)';
  }
}

/// Request message for
/// `SecretManagerService.CreateSecret`.
final class CreateSecretRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.CreateSecretRequest';

  /// Required. The resource name of the project to associate with the
  /// `Secret`, in the format `projects/*`
  /// or `projects/*/locations/*`.
  final String parent;

  /// Required. This must be unique within the project.
  ///
  /// A secret ID is a string with a maximum length of 255 characters and can
  /// contain uppercase and lowercase letters, numerals, and the hyphen (`-`) and
  /// underscore (`_`) characters.
  final String secretId;

  /// Required. A `Secret` with initial
  /// field values.
  final Secret? secret;

  CreateSecretRequest({
    required this.parent,
    required this.secretId,
    required this.secret,
  }) : super(fullyQualifiedName);

  factory CreateSecretRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateSecretRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      secretId: switch (json['secretId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      secret: switch (json['secret']) {
        null => null,
        Object $1 => Secret.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    'secretId': secretId,
    if (secret != null) 'secret': secret!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'secretId=$secretId'].join(',');
    return 'CreateSecretRequest($contents)';
  }
}

/// Request message for
/// `SecretManagerService.AddSecretVersion`.
final class AddSecretVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.AddSecretVersionRequest';

  /// Required. The resource name of the
  /// `Secret` to associate with the
  /// `SecretVersion` in the format
  /// `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
  final String parent;

  /// Required. The secret payload of the
  /// `SecretVersion`.
  final SecretPayload? payload;

  AddSecretVersionRequest({required this.parent, required this.payload})
    : super(fullyQualifiedName);

  factory AddSecretVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AddSecretVersionRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      payload: switch (json['payload']) {
        null => null,
        Object $1 => SecretPayload.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (payload != null) 'payload': payload!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'AddSecretVersionRequest($contents)';
  }
}

/// Request message for
/// `SecretManagerService.GetSecret`.
final class GetSecretRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.GetSecretRequest';

  /// Required. The resource name of the
  /// `Secret`, in the format
  /// `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
  final String name;

  GetSecretRequest({required this.name}) : super(fullyQualifiedName);

  factory GetSecretRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetSecretRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetSecretRequest($contents)';
  }
}

/// Request message for
/// `SecretManagerService.ListSecretVersions`.
final class ListSecretVersionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.ListSecretVersionsRequest';

  /// Required. The resource name of the
  /// `Secret` associated with the
  /// `SecretVersions` to list, in
  /// the format `projects/*/secrets/*` or `projects/*/locations/*/secrets/*`.
  final String parent;

  /// Optional. The maximum number of results to be returned in a single page. If
  /// set to 0, the server decides the number of results to return. If the
  /// number is greater than 25000, it is capped at 25000.
  final int pageSize;

  /// Optional. Pagination token, returned earlier via
  /// ListSecretVersionsResponse.next_page_token][].
  final String pageToken;

  /// Optional. Filter string, adhering to the rules in
  /// [List-operation
  /// filtering](https://cloud.google.com/secret-manager/docs/filtering). List
  /// only secret versions matching the filter. If filter is empty, all secret
  /// versions are listed.
  final String filter;

  ListSecretVersionsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
  }) : super(fullyQualifiedName);

  factory ListSecretVersionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSecretVersionsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
    ].join(',');
    return 'ListSecretVersionsRequest($contents)';
  }
}

/// Response message for
/// `SecretManagerService.ListSecretVersions`.
final class ListSecretVersionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.ListSecretVersionsResponse';

  /// The list of `SecretVersions`
  /// sorted in reverse by create_time (newest first).
  final List<SecretVersion> versions;

  /// A token to retrieve the next page of results. Pass this value in
  /// `ListSecretVersionsRequest.page_token`
  /// to retrieve the next page.
  final String nextPageToken;

  /// The total number of
  /// `SecretVersions` but 0 when
  /// the
  /// `ListSecretsRequest.filter`
  /// field is set.
  final int totalSize;

  ListSecretVersionsResponse({
    this.versions = const [],
    this.nextPageToken = '',
    this.totalSize = 0,
  }) : super(fullyQualifiedName);

  factory ListSecretVersionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListSecretVersionsResponse(
      versions: switch (json['versions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SecretVersion.fromJson(i)],
        _ => throw const FormatException('"versions" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      totalSize: switch (json['totalSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (versions.isNotDefault) 'versions': encodeList(versions),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
    if (totalSize.isNotDefault) 'totalSize': totalSize,
  };

  @override
  String toString() {
    final contents = [
      'nextPageToken=$nextPageToken',
      'totalSize=$totalSize',
    ].join(',');
    return 'ListSecretVersionsResponse($contents)';
  }
}

/// Request message for
/// `SecretManagerService.GetSecretVersion`.
final class GetSecretVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.GetSecretVersionRequest';

  /// Required. The resource name of the
  /// `SecretVersion` in the format
  /// `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  ///
  /// `projects/*/secrets/*/versions/latest` or
  /// `projects/*/locations/*/secrets/*/versions/latest` is an alias to the most
  /// recently created
  /// `SecretVersion`.
  final String name;

  GetSecretVersionRequest({required this.name}) : super(fullyQualifiedName);

  factory GetSecretVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetSecretVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetSecretVersionRequest($contents)';
  }
}

/// Request message for
/// `SecretManagerService.UpdateSecret`.
final class UpdateSecretRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.UpdateSecretRequest';

  /// Required. `Secret` with updated field
  /// values.
  final Secret? secret;

  /// Required. Specifies the fields to be updated.
  final FieldMask? updateMask;

  UpdateSecretRequest({required this.secret, required this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateSecretRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateSecretRequest(
      secret: switch (json['secret']) {
        null => null,
        Object $1 => Secret.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (secret != null) 'secret': secret!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateSecretRequest()';
}

/// Request message for
/// `SecretManagerService.AccessSecretVersion`.
final class AccessSecretVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.AccessSecretVersionRequest';

  /// Required. The resource name of the
  /// `SecretVersion` in the format
  /// `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  ///
  /// `projects/*/secrets/*/versions/latest` or
  /// `projects/*/locations/*/secrets/*/versions/latest` is an alias to the most
  /// recently created
  /// `SecretVersion`.
  final String name;

  AccessSecretVersionRequest({required this.name}) : super(fullyQualifiedName);

  factory AccessSecretVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AccessSecretVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AccessSecretVersionRequest($contents)';
  }
}

/// Response message for
/// `SecretManagerService.AccessSecretVersion`.
final class AccessSecretVersionResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.AccessSecretVersionResponse';

  /// The resource name of the
  /// `SecretVersion` in the format
  /// `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  final String name;

  /// Secret payload
  final SecretPayload? payload;

  AccessSecretVersionResponse({this.name = '', this.payload})
    : super(fullyQualifiedName);

  factory AccessSecretVersionResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AccessSecretVersionResponse(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      payload: switch (json['payload']) {
        null => null,
        Object $1 => SecretPayload.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (payload != null) 'payload': payload!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AccessSecretVersionResponse($contents)';
  }
}

/// Request message for
/// `SecretManagerService.DeleteSecret`.
final class DeleteSecretRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.DeleteSecretRequest';

  /// Required. The resource name of the
  /// `Secret` to delete in the format
  /// `projects/*/secrets/*`.
  final String name;

  /// Optional. Etag of the `Secret`. The
  /// request succeeds if it matches the etag of the currently stored secret
  /// object. If the etag is omitted, the request succeeds.
  final String etag;

  DeleteSecretRequest({required this.name, this.etag = ''})
    : super(fullyQualifiedName);

  factory DeleteSecretRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteSecretRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (etag.isNotDefault) 'etag': etag};

  @override
  String toString() {
    final contents = ['name=$name', 'etag=$etag'].join(',');
    return 'DeleteSecretRequest($contents)';
  }
}

/// Request message for
/// `SecretManagerService.DisableSecretVersion`.
final class DisableSecretVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.DisableSecretVersionRequest';

  /// Required. The resource name of the
  /// `SecretVersion` to disable in
  /// the format `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  final String name;

  /// Optional. Etag of the
  /// `SecretVersion`. The request
  /// succeeds if it matches the etag of the currently stored secret version
  /// object. If the etag is omitted, the request succeeds.
  final String etag;

  DisableSecretVersionRequest({required this.name, this.etag = ''})
    : super(fullyQualifiedName);

  factory DisableSecretVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DisableSecretVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (etag.isNotDefault) 'etag': etag};

  @override
  String toString() {
    final contents = ['name=$name', 'etag=$etag'].join(',');
    return 'DisableSecretVersionRequest($contents)';
  }
}

/// Request message for
/// `SecretManagerService.EnableSecretVersion`.
final class EnableSecretVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.EnableSecretVersionRequest';

  /// Required. The resource name of the
  /// `SecretVersion` to enable in
  /// the format `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  final String name;

  /// Optional. Etag of the
  /// `SecretVersion`. The request
  /// succeeds if it matches the etag of the currently stored secret version
  /// object. If the etag is omitted, the request succeeds.
  final String etag;

  EnableSecretVersionRequest({required this.name, this.etag = ''})
    : super(fullyQualifiedName);

  factory EnableSecretVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EnableSecretVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (etag.isNotDefault) 'etag': etag};

  @override
  String toString() {
    final contents = ['name=$name', 'etag=$etag'].join(',');
    return 'EnableSecretVersionRequest($contents)';
  }
}

/// Request message for
/// `SecretManagerService.DestroySecretVersion`.
final class DestroySecretVersionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.secretmanager.v1.DestroySecretVersionRequest';

  /// Required. The resource name of the
  /// `SecretVersion` to destroy in
  /// the format `projects/*/secrets/*/versions/*` or
  /// `projects/*/locations/*/secrets/*/versions/*`.
  final String name;

  /// Optional. Etag of the
  /// `SecretVersion`. The request
  /// succeeds if it matches the etag of the currently stored secret version
  /// object. If the etag is omitted, the request succeeds.
  final String etag;

  DestroySecretVersionRequest({required this.name, this.etag = ''})
    : super(fullyQualifiedName);

  factory DestroySecretVersionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DestroySecretVersionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      etag: switch (json['etag']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name, if (etag.isNotDefault) 'etag': etag};

  @override
  String toString() {
    final contents = ['name=$name', 'etag=$etag'].join(',');
    return 'DestroySecretVersionRequest($contents)';
  }
}
