// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Cloud Functions API.
///
/// Manages lightweight user-provided functions executed in response to events.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_iam_v1/iam.dart';
import 'package:google_cloud_location/location.dart';
import 'package:google_cloud_longrunning/longrunning.dart';
import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/rpc.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:google_cloud_type/type.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// Google Cloud Functions is used to deploy functions that are executed by
/// Google in response to various events. Data connected with that event is
/// passed to a function as the input data.
///
/// A **function** is a resource which describes a function that should be
/// executed and how it is triggered.
final class FunctionService {
  static const _host = 'cloudfunctions.googleapis.com';

  final ServiceClient _client;

  /// Creates a `FunctionService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `FunctionService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  FunctionService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `FunctionService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory FunctionService.fromApiKey([String? apiKey]) =>
      FunctionService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Returns a function with the given name from the requested project.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Function$> getFunction(GetFunctionRequest request) async {
    final url = Uri.https(_host, '/v2/${request.name}', {
      if (request.revision case final $1 when $1.isNotDefault) 'revision': $1,
    });
    final response = await _client.get(url);
    return Function$.fromJson(response);
  }

  /// Returns a list of functions that belong to the requested project.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListFunctionsResponse> listFunctions(
    ListFunctionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.parent}/functions', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.orderBy case final $1 when $1.isNotDefault) 'orderBy': $1,
    });
    final response = await _client.get(url);
    return ListFunctionsResponse.fromJson(response);
  }

  /// Creates a new function. If a function with the given name already exists in
  /// the specified project, the long running operation will return
  /// `ALREADY_EXISTS` error.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Function$, OperationMetadata>> createFunction(
    CreateFunctionRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.parent}/functions', {
      if (request.functionId case final $1 when $1.isNotDefault)
        'functionId': $1,
    });
    final response = await _client.post(url, body: request.function);
    return Operation.fromJson(
      response,
      OperationHelper(Function$.fromJson, OperationMetadata.fromJson),
    );
  }

  /// Updates existing function.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Function$, OperationMetadata>> updateFunction(
    UpdateFunctionRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.function!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.function);
    return Operation.fromJson(
      response,
      OperationHelper(Function$.fromJson, OperationMetadata.fromJson),
    );
  }

  /// Deletes a function with the given name from the specified project. If the
  /// given function is used by some trigger, the trigger will be updated to
  /// remove this function.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<Empty, OperationMetadata>> deleteFunction(
    DeleteFunctionRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.name}');
    final response = await _client.delete(url);
    return Operation.fromJson(
      response,
      OperationHelper(Empty.fromJson, OperationMetadata.fromJson),
    );
  }

  /// Returns a signed URL for uploading a function source code.
  /// For more information about the signed URL usage see:
  /// https://cloud.google.com/storage/docs/access-control/signed-urls.
  /// Once the function source code upload is complete, the used signed
  /// URL should be provided in CreateFunction or UpdateFunction request
  /// as a reference to the function source code.
  ///
  /// When uploading source code to the generated signed URL, please follow
  /// these restrictions:
  ///
  /// * Source file type should be a zip file.
  /// * No credentials should be attached - the signed URLs provide access to the
  ///   target bucket using internal service identity; if credentials were
  ///   attached, the identity from the credentials would be used, but that
  ///   identity does not have permissions to upload files to the URL.
  ///
  /// When making a HTTP PUT request, specify this header:
  ///
  /// * `content-type: application/zip`
  ///
  /// Do not specify this header:
  ///
  /// * `Authorization: Bearer YOUR_TOKEN`
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GenerateUploadUrlResponse> generateUploadUrl(
    GenerateUploadUrlRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v2/${request.parent}/functions:generateUploadUrl',
    );
    final response = await _client.post(url, body: request);
    return GenerateUploadUrlResponse.fromJson(response);
  }

  /// Returns a signed URL for downloading deployed function source code.
  /// The URL is only valid for a limited period and should be used within
  /// 30 minutes of generation.
  /// For more information about the signed URL usage see:
  /// https://cloud.google.com/storage/docs/access-control/signed-urls
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<GenerateDownloadUrlResponse> generateDownloadUrl(
    GenerateDownloadUrlRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.name}:generateDownloadUrl');
    final response = await _client.post(url, body: request);
    return GenerateDownloadUrlResponse.fromJson(response);
  }

  /// Returns a list of runtimes that are supported for the requested project.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListRuntimesResponse> listRuntimes(ListRuntimesRequest request) async {
    final url = Uri.https(_host, '/v2/${request.parent}/runtimes', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
    });
    final response = await _client.get(url);
    return ListRuntimesResponse.fromJson(response);
  }

  /// Lists information about the supported locations for this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Sets the access control policy on the specified resource. Replaces
  /// any existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED`
  /// errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v2/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource. Returns an empty policy
  /// if the resource exists and does not have a policy set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v2/${request.resource}:getIamPolicy', {
      if (request.options!.requestedPolicyVersion case final $1
          when $1.isNotDefault)
        'options.requestedPolicyVersion': '${$1}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource. If the
  /// resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building
  /// permission-aware UIs and command-line tools, not for authorization
  /// checking. This operation may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.resource}:testIamPermissions');
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v2/${request.name}/operations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/v2/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Describes a Cloud Function that contains user computation executed in
/// response to an event. It encapsulates function and trigger configurations.
final class Function$ extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.functions.v2.Function';

  /// A user-defined name of the function. Function names must be unique
  /// globally and match pattern `projects/*/locations/*/functions/*`
  final String name;

  /// User-provided description of a function.
  final String description;

  /// Describes the Build step of the function that builds a container from the
  /// given source.
  final BuildConfig? buildConfig;

  /// Describes the Service being deployed. Currently deploys services to Cloud
  /// Run (fully managed).
  final ServiceConfig? serviceConfig;

  /// An Eventarc trigger managed by Google Cloud Functions that fires events in
  /// response to a condition in another service.
  final EventTrigger? eventTrigger;

  /// Output only. State of the function.
  final Function$_State state;

  /// Output only. The last update timestamp of a Cloud Function.
  final Timestamp? updateTime;

  /// Labels associated with this Cloud Function.
  final Map<String, String> labels;

  /// Output only. State Messages for this Cloud Function.
  final List<StateMessage> stateMessages;

  /// Describe whether the function is 1st Gen or 2nd Gen.
  final Environment environment;

  /// Output only. The deployed url for the function.
  final String url;

  /// Resource name of a KMS crypto key (managed by the user) used to
  /// encrypt/decrypt function resources.
  ///
  /// It must match the pattern
  /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
  final String kmsKeyName;

  /// Output only. Reserved for future use.
  final bool satisfiesPzs;

  /// Output only. The create timestamp of a Cloud Function. This is only
  /// applicable to 2nd Gen functions.
  final Timestamp? createTime;

  Function$({
    this.name = '',
    this.description = '',
    this.buildConfig,
    this.serviceConfig,
    this.eventTrigger,
    this.state = Function$_State.$default,
    this.updateTime,
    this.labels = const {},
    this.stateMessages = const [],
    this.environment = Environment.$default,
    this.url = '',
    this.kmsKeyName = '',
    this.satisfiesPzs = false,
    this.createTime,
  }) : super(fullyQualifiedName);

  factory Function$.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Function$(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      buildConfig: switch (json['buildConfig']) {
        null => null,
        Object $1 => BuildConfig.fromJson($1),
      },
      serviceConfig: switch (json['serviceConfig']) {
        null => null,
        Object $1 => ServiceConfig.fromJson($1),
      },
      eventTrigger: switch (json['eventTrigger']) {
        null => null,
        Object $1 => EventTrigger.fromJson($1),
      },
      state: switch (json['state']) {
        null => Function$_State.$default,
        Object $1 => Function$_State.fromJson($1),
      },
      updateTime: switch (json['updateTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      labels: switch (json['labels']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException('"labels" is not an object'),
      },
      stateMessages: switch (json['stateMessages']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) StateMessage.fromJson(i)],
        _ => throw const FormatException('"stateMessages" is not a list'),
      },
      environment: switch (json['environment']) {
        null => Environment.$default,
        Object $1 => Environment.fromJson($1),
      },
      url: switch (json['url']) {
        null => '',
        Object $1 => decodeString($1),
      },
      kmsKeyName: switch (json['kmsKeyName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      satisfiesPzs: switch (json['satisfiesPzs']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (description.isNotDefault) 'description': description,
    if (buildConfig != null) 'buildConfig': buildConfig!.toJson(),
    if (serviceConfig != null) 'serviceConfig': serviceConfig!.toJson(),
    if (eventTrigger != null) 'eventTrigger': eventTrigger!.toJson(),
    if (state.isNotDefault) 'state': state.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (labels.isNotDefault) 'labels': labels,
    if (stateMessages.isNotDefault) 'stateMessages': encodeList(stateMessages),
    if (environment.isNotDefault) 'environment': environment.toJson(),
    if (url.isNotDefault) 'url': url,
    if (kmsKeyName.isNotDefault) 'kmsKeyName': kmsKeyName,
    if (satisfiesPzs.isNotDefault) 'satisfiesPzs': satisfiesPzs,
    if (createTime != null) 'createTime': createTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'description=$description',
      'state=$state',
      'environment=$environment',
      'url=$url',
      'kmsKeyName=$kmsKeyName',
      'satisfiesPzs=$satisfiesPzs',
    ].join(',');
    return 'Function($contents)';
  }
}

/// Describes the current state of the function.
final class Function$_State extends ProtoEnum {
  /// Not specified. Invalid state.
  static const stateUnspecified = Function$_State('STATE_UNSPECIFIED');

  /// Function has been successfully deployed and is serving.
  static const active = Function$_State('ACTIVE');

  /// Function deployment failed and the function is not serving.
  static const failed = Function$_State('FAILED');

  /// Function is being created or updated.
  static const deploying = Function$_State('DEPLOYING');

  /// Function is being deleted.
  static const deleting = Function$_State('DELETING');

  /// Function deployment failed and the function serving state is undefined.
  /// The function should be updated or deleted to move it out of this state.
  static const unknown = Function$_State('UNKNOWN');

  /// The default value for [Function$_State].
  static const $default = stateUnspecified;

  const Function$_State(super.value);

  factory Function$_State.fromJson(Object? json) =>
      Function$_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// Informational messages about the state of the Cloud Function or Operation.
final class StateMessage extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.StateMessage';

  /// Severity of the state message.
  final StateMessage_Severity severity;

  /// One-word CamelCase type of the state message.
  final String type;

  /// The message.
  final String message;

  StateMessage({
    this.severity = StateMessage_Severity.$default,
    this.type = '',
    this.message = '',
  }) : super(fullyQualifiedName);

  factory StateMessage.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StateMessage(
      severity: switch (json['severity']) {
        null => StateMessage_Severity.$default,
        Object $1 => StateMessage_Severity.fromJson($1),
      },
      type: switch (json['type']) {
        null => '',
        Object $1 => decodeString($1),
      },
      message: switch (json['message']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (severity.isNotDefault) 'severity': severity.toJson(),
    if (type.isNotDefault) 'type': type,
    if (message.isNotDefault) 'message': message,
  };

  @override
  String toString() {
    final contents = [
      'severity=$severity',
      'type=$type',
      'message=$message',
    ].join(',');
    return 'StateMessage($contents)';
  }
}

/// Severity of the state message.
final class StateMessage_Severity extends ProtoEnum {
  /// Not specified. Invalid severity.
  static const severityUnspecified = StateMessage_Severity(
    'SEVERITY_UNSPECIFIED',
  );

  /// ERROR-level severity.
  static const error = StateMessage_Severity('ERROR');

  /// WARNING-level severity.
  static const warning = StateMessage_Severity('WARNING');

  /// INFO-level severity.
  static const info = StateMessage_Severity('INFO');

  /// The default value for [StateMessage_Severity].
  static const $default = severityUnspecified;

  const StateMessage_Severity(super.value);

  factory StateMessage_Severity.fromJson(Object? json) =>
      StateMessage_Severity(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Severity.$value';
}

/// Location of the source in an archive file in Google Cloud Storage.
final class StorageSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.StorageSource';

  /// Google Cloud Storage bucket containing the source (see
  /// [Bucket Name
  /// Requirements](https://cloud.google.com/storage/docs/bucket-naming#requirements)).
  final String bucket;

  /// Google Cloud Storage object containing the source.
  ///
  /// This object must be a gzipped archive file (`.tar.gz`) containing source to
  /// build.
  final String object;

  /// Google Cloud Storage generation for the object. If the generation is
  /// omitted, the latest generation will be used.
  final int generation;

  /// When the specified storage bucket is a 1st gen function uploard url bucket,
  /// this field should be set as the generated upload url for 1st gen
  /// deployment.
  final String sourceUploadUrl;

  StorageSource({
    this.bucket = '',
    this.object = '',
    this.generation = 0,
    this.sourceUploadUrl = '',
  }) : super(fullyQualifiedName);

  factory StorageSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return StorageSource(
      bucket: switch (json['bucket']) {
        null => '',
        Object $1 => decodeString($1),
      },
      object: switch (json['object']) {
        null => '',
        Object $1 => decodeString($1),
      },
      generation: switch (json['generation']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      sourceUploadUrl: switch (json['sourceUploadUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (bucket.isNotDefault) 'bucket': bucket,
    if (object.isNotDefault) 'object': object,
    if (generation.isNotDefault) 'generation': encodeInt64(generation),
    if (sourceUploadUrl.isNotDefault) 'sourceUploadUrl': sourceUploadUrl,
  };

  @override
  String toString() {
    final contents = [
      'bucket=$bucket',
      'object=$object',
      'generation=$generation',
      'sourceUploadUrl=$sourceUploadUrl',
    ].join(',');
    return 'StorageSource($contents)';
  }
}

/// Location of the source in a Google Cloud Source Repository.
final class RepoSource extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.RepoSource';

  /// Regex matching branches to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  final String? branchName;

  /// Regex matching tags to build.
  ///
  /// The syntax of the regular expressions accepted is the syntax accepted by
  /// RE2 and described at https://github.com/google/re2/wiki/Syntax
  final String? tagName;

  /// Explicit commit SHA to build.
  final String? commitSha;

  /// ID of the project that owns the Cloud Source Repository. If omitted, the
  /// project ID requesting the build is assumed.
  final String projectId;

  /// Name of the Cloud Source Repository.
  final String repoName;

  /// Directory, relative to the source root, in which to run the build.
  ///
  /// This must be a relative path. If a step's `dir` is specified and is an
  /// absolute path, this value is ignored for that step's execution.
  /// eg. helloworld (no leading slash allowed)
  final String dir;

  /// Only trigger a build if the revision regex does NOT match the revision
  /// regex.
  final bool invertRegex;

  RepoSource({
    this.branchName,
    this.tagName,
    this.commitSha,
    this.projectId = '',
    this.repoName = '',
    this.dir = '',
    this.invertRegex = false,
  }) : super(fullyQualifiedName);

  factory RepoSource.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return RepoSource(
      branchName: switch (json['branchName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      tagName: switch (json['tagName']) {
        null => null,
        Object $1 => decodeString($1),
      },
      commitSha: switch (json['commitSha']) {
        null => null,
        Object $1 => decodeString($1),
      },
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      repoName: switch (json['repoName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      dir: switch (json['dir']) {
        null => '',
        Object $1 => decodeString($1),
      },
      invertRegex: switch (json['invertRegex']) {
        null => false,
        Object $1 => decodeBool($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (branchName != null) 'branchName': branchName,
    if (tagName != null) 'tagName': tagName,
    if (commitSha != null) 'commitSha': commitSha,
    if (projectId.isNotDefault) 'projectId': projectId,
    if (repoName.isNotDefault) 'repoName': repoName,
    if (dir.isNotDefault) 'dir': dir,
    if (invertRegex.isNotDefault) 'invertRegex': invertRegex,
  };

  @override
  String toString() {
    final contents = [
      if (branchName != null) 'branchName=$branchName',
      if (tagName != null) 'tagName=$tagName',
      if (commitSha != null) 'commitSha=$commitSha',
      'projectId=$projectId',
      'repoName=$repoName',
      'dir=$dir',
      'invertRegex=$invertRegex',
    ].join(',');
    return 'RepoSource($contents)';
  }
}

/// The location of the function source code.
final class Source extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.functions.v2.Source';

  /// If provided, get the source from this location in Google Cloud Storage.
  final StorageSource? storageSource;

  /// If provided, get the source from this location in a Cloud Source
  /// Repository.
  final RepoSource? repoSource;

  /// If provided, get the source from GitHub repository. This option is valid
  /// only for GCF 1st Gen function.
  /// Example: https://github.com/<user>/<repo>/blob/<commit>/<path-to-code>
  final String? gitUri;

  Source({this.storageSource, this.repoSource, this.gitUri})
    : super(fullyQualifiedName);

  factory Source.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Source(
      storageSource: switch (json['storageSource']) {
        null => null,
        Object $1 => StorageSource.fromJson($1),
      },
      repoSource: switch (json['repoSource']) {
        null => null,
        Object $1 => RepoSource.fromJson($1),
      },
      gitUri: switch (json['gitUri']) {
        null => null,
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (storageSource != null) 'storageSource': storageSource!.toJson(),
    if (repoSource != null) 'repoSource': repoSource!.toJson(),
    if (gitUri != null) 'gitUri': gitUri,
  };

  @override
  String toString() {
    final contents = [if (gitUri != null) 'gitUri=$gitUri'].join(',');
    return 'Source($contents)';
  }
}

/// Provenance of the source. Ways to find the original source, or verify that
/// some source was used for this build.
final class SourceProvenance extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.SourceProvenance';

  /// A copy of the build's `source.storage_source`, if exists, with any
  /// generations resolved.
  final StorageSource? resolvedStorageSource;

  /// A copy of the build's `source.repo_source`, if exists, with any
  /// revisions resolved.
  final RepoSource? resolvedRepoSource;

  /// A copy of the build's `source.git_uri`, if exists, with any commits
  /// resolved.
  final String gitUri;

  SourceProvenance({
    this.resolvedStorageSource,
    this.resolvedRepoSource,
    this.gitUri = '',
  }) : super(fullyQualifiedName);

  factory SourceProvenance.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SourceProvenance(
      resolvedStorageSource: switch (json['resolvedStorageSource']) {
        null => null,
        Object $1 => StorageSource.fromJson($1),
      },
      resolvedRepoSource: switch (json['resolvedRepoSource']) {
        null => null,
        Object $1 => RepoSource.fromJson($1),
      },
      gitUri: switch (json['gitUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (resolvedStorageSource != null)
      'resolvedStorageSource': resolvedStorageSource!.toJson(),
    if (resolvedRepoSource != null)
      'resolvedRepoSource': resolvedRepoSource!.toJson(),
    if (gitUri.isNotDefault) 'gitUri': gitUri,
  };

  @override
  String toString() {
    final contents = ['gitUri=$gitUri'].join(',');
    return 'SourceProvenance($contents)';
  }
}

/// Describes the Build step of the function that builds a container from the
/// given source.
final class BuildConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.BuildConfig';

  final AutomaticUpdatePolicy? automaticUpdatePolicy;

  final OnDeployUpdatePolicy? onDeployUpdatePolicy;

  /// Output only. The Cloud Build name of the latest successful deployment of
  /// the function.
  final String build;

  /// The runtime in which to run the function. Required when deploying a new
  /// function, optional when updating an existing function. For a complete
  /// list of possible choices, see the
  /// [`gcloud` command
  /// reference](https://cloud.google.com/sdk/gcloud/reference/functions/deploy#--runtime).
  final String runtime;

  /// The name of the function (as defined in source code) that will be
  /// executed. Defaults to the resource name suffix, if not specified. For
  /// backward compatibility, if function with given name is not found, then the
  /// system will try to use function named "function".
  /// For Node.js this is name of a function exported by the module specified
  /// in `source_location`.
  final String entryPoint;

  /// The location of the function source code.
  final Source? source;

  /// Output only. A permanent fixed identifier for source.
  final SourceProvenance? sourceProvenance;

  /// Name of the Cloud Build Custom Worker Pool that should be used to build the
  /// function. The format of this field is
  /// `projects/{project}/locations/{region}/workerPools/{workerPool}` where
  /// {project} and {region} are the project id and region respectively where the
  /// worker pool is defined and {workerPool} is the short name of the worker
  /// pool.
  ///
  /// If the project id is not the same as the function, then the Cloud
  /// Functions Service Agent
  /// (service-<project_number>@gcf-admin-robot.iam.gserviceaccount.com) must be
  /// granted the role Cloud Build Custom Workers Builder
  /// (roles/cloudbuild.customworkers.builder) in the project.
  final String workerPool;

  /// User-provided build-time environment variables for the function
  final Map<String, String> environmentVariables;

  /// Docker Registry to use for this deployment. This configuration is only
  /// applicable to 1st Gen functions, 2nd Gen functions can only use Artifact
  /// Registry.
  /// Deprecated: As of March 2025, `CONTAINER_REGISTRY` option is no longer
  /// available in response to Container Registry's deprecation:
  /// https://cloud.google.com/artifact-registry/docs/transition/transition-from-gcr
  /// Please use Artifact Registry instead, which is the default choice.
  ///
  /// If unspecified, it defaults to `ARTIFACT_REGISTRY`.
  /// If `docker_repository` field is specified, this field should either be left
  /// unspecified or set to `ARTIFACT_REGISTRY`.
  final BuildConfig_DockerRegistry dockerRegistry;

  /// Repository in Artifact Registry to which the function docker image will be
  /// pushed after it is built by Cloud Build. If specified by user, it is
  /// created and managed by user with a customer managed encryption key.
  /// Otherwise, GCF will create and use a repository named 'gcf-artifacts'
  /// for every deployed region.
  ///
  /// It must match the pattern
  /// `projects/{project}/locations/{location}/repositories/{repository}`.
  /// Repository format must be 'DOCKER'.
  final String dockerRepository;

  /// Service account to be used for building the container. The format of this
  /// field is `projects/{projectId}/serviceAccounts/{serviceAccountEmail}`.
  final String serviceAccount;

  BuildConfig({
    this.automaticUpdatePolicy,
    this.onDeployUpdatePolicy,
    this.build = '',
    this.runtime = '',
    this.entryPoint = '',
    this.source,
    this.sourceProvenance,
    this.workerPool = '',
    this.environmentVariables = const {},
    this.dockerRegistry = BuildConfig_DockerRegistry.$default,
    this.dockerRepository = '',
    this.serviceAccount = '',
  }) : super(fullyQualifiedName);

  factory BuildConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BuildConfig(
      automaticUpdatePolicy: switch (json['automaticUpdatePolicy']) {
        null => null,
        Object $1 => AutomaticUpdatePolicy.fromJson($1),
      },
      onDeployUpdatePolicy: switch (json['onDeployUpdatePolicy']) {
        null => null,
        Object $1 => OnDeployUpdatePolicy.fromJson($1),
      },
      build: switch (json['build']) {
        null => '',
        Object $1 => decodeString($1),
      },
      runtime: switch (json['runtime']) {
        null => '',
        Object $1 => decodeString($1),
      },
      entryPoint: switch (json['entryPoint']) {
        null => '',
        Object $1 => decodeString($1),
      },
      source: switch (json['source']) {
        null => null,
        Object $1 => Source.fromJson($1),
      },
      sourceProvenance: switch (json['sourceProvenance']) {
        null => null,
        Object $1 => SourceProvenance.fromJson($1),
      },
      workerPool: switch (json['workerPool']) {
        null => '',
        Object $1 => decodeString($1),
      },
      environmentVariables: switch (json['environmentVariables']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException(
          '"environmentVariables" is not an object',
        ),
      },
      dockerRegistry: switch (json['dockerRegistry']) {
        null => BuildConfig_DockerRegistry.$default,
        Object $1 => BuildConfig_DockerRegistry.fromJson($1),
      },
      dockerRepository: switch (json['dockerRepository']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAccount: switch (json['serviceAccount']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (automaticUpdatePolicy != null)
      'automaticUpdatePolicy': automaticUpdatePolicy!.toJson(),
    if (onDeployUpdatePolicy != null)
      'onDeployUpdatePolicy': onDeployUpdatePolicy!.toJson(),
    if (build.isNotDefault) 'build': build,
    if (runtime.isNotDefault) 'runtime': runtime,
    if (entryPoint.isNotDefault) 'entryPoint': entryPoint,
    if (source != null) 'source': source!.toJson(),
    if (sourceProvenance != null)
      'sourceProvenance': sourceProvenance!.toJson(),
    if (workerPool.isNotDefault) 'workerPool': workerPool,
    if (environmentVariables.isNotDefault)
      'environmentVariables': environmentVariables,
    if (dockerRegistry.isNotDefault) 'dockerRegistry': dockerRegistry.toJson(),
    if (dockerRepository.isNotDefault) 'dockerRepository': dockerRepository,
    if (serviceAccount.isNotDefault) 'serviceAccount': serviceAccount,
  };

  @override
  String toString() {
    final contents = [
      'build=$build',
      'runtime=$runtime',
      'entryPoint=$entryPoint',
      'workerPool=$workerPool',
      'dockerRegistry=$dockerRegistry',
      'dockerRepository=$dockerRepository',
      'serviceAccount=$serviceAccount',
    ].join(',');
    return 'BuildConfig($contents)';
  }
}

/// Docker Registry to use for storing function Docker images.
final class BuildConfig_DockerRegistry extends ProtoEnum {
  /// Unspecified.
  static const dockerRegistryUnspecified = BuildConfig_DockerRegistry(
    'DOCKER_REGISTRY_UNSPECIFIED',
  );

  /// Docker images will be stored in multi-regional Container Registry
  /// repositories named `gcf`.
  static const containerRegistry = BuildConfig_DockerRegistry(
    'CONTAINER_REGISTRY',
  );

  /// Docker images will be stored in regional Artifact Registry repositories.
  /// By default, GCF will create and use repositories named `gcf-artifacts`
  /// in every region in which a function is deployed. But the repository to
  /// use can also be specified by the user using the `docker_repository`
  /// field.
  static const artifactRegistry = BuildConfig_DockerRegistry(
    'ARTIFACT_REGISTRY',
  );

  /// The default value for [BuildConfig_DockerRegistry].
  static const $default = dockerRegistryUnspecified;

  const BuildConfig_DockerRegistry(super.value);

  factory BuildConfig_DockerRegistry.fromJson(Object? json) =>
      BuildConfig_DockerRegistry(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DockerRegistry.$value';
}

/// Describes the Service being deployed.
/// Currently Supported : Cloud Run (fully managed).
final class ServiceConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ServiceConfig';

  /// Output only. Name of the service associated with a Function.
  /// The format of this field is
  /// `projects/{project}/locations/{region}/services/{service}`
  final String service;

  /// The function execution timeout. Execution is considered failed and
  /// can be terminated if the function is not completed at the end of the
  /// timeout period. Defaults to 60 seconds.
  final int timeoutSeconds;

  /// The amount of memory available for a function.
  /// Defaults to 256M. Supported units are k, M, G, Mi, Gi. If no unit is
  /// supplied the value is interpreted as bytes.
  /// See
  /// https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/apimachinery/pkg/api/resource/quantity.go
  /// a full description.
  final String availableMemory;

  /// The number of CPUs used in a single container instance.
  /// Default value is calculated from available memory.
  /// Supports the same values as Cloud Run, see
  /// https://cloud.google.com/run/docs/reference/rest/v1/Container#resourcerequirements
  /// Example: "1" indicates 1 vCPU
  final String availableCpu;

  /// Environment variables that shall be available during function execution.
  final Map<String, String> environmentVariables;

  /// The limit on the maximum number of function instances that may coexist at a
  /// given time.
  ///
  /// In some cases, such as rapid traffic surges, Cloud Functions may, for a
  /// short period of time, create more instances than the specified max
  /// instances limit. If your function cannot tolerate this temporary behavior,
  /// you may want to factor in a safety margin and set a lower max instances
  /// value than your function can tolerate.
  ///
  /// See the [Max
  /// Instances](https://cloud.google.com/functions/docs/max-instances) Guide for
  /// more details.
  final int maxInstanceCount;

  /// The limit on the minimum number of function instances that may coexist at a
  /// given time.
  ///
  /// Function instances are kept in idle state for a short period after they
  /// finished executing the request to reduce cold start time for subsequent
  /// requests. Setting a minimum instance count will ensure that the given
  /// number of instances are kept running in idle state always. This can help
  /// with cold start times when jump in incoming request count occurs after the
  /// idle instance would have been stopped in the default case.
  final int minInstanceCount;

  /// The Serverless VPC Access connector that this cloud function can connect
  /// to. The format of this field is `projects/*/locations/*/connectors/*`.
  final String vpcConnector;

  /// The egress settings for the connector, controlling what traffic is diverted
  /// through it.
  final ServiceConfig_VpcConnectorEgressSettings vpcConnectorEgressSettings;

  /// The ingress settings for the function, controlling what traffic can reach
  /// it.
  final ServiceConfig_IngressSettings ingressSettings;

  /// Output only. URI of the Service deployed.
  final String uri;

  /// The email of the service's service account. If empty, defaults to
  /// `{project_number}-compute@developer.gserviceaccount.com`.
  final String serviceAccountEmail;

  /// Whether 100% of traffic is routed to the latest revision.
  /// On CreateFunction and UpdateFunction, when set to true, the revision being
  /// deployed will serve 100% of traffic, ignoring any traffic split settings,
  /// if any. On GetFunction, true will be returned if the latest revision is
  /// serving 100% of traffic.
  final bool allTrafficOnLatestRevision;

  /// Secret environment variables configuration.
  final List<SecretEnvVar> secretEnvironmentVariables;

  /// Secret volumes configuration.
  final List<SecretVolume> secretVolumes;

  /// Output only. The name of service revision.
  final String revision;

  /// Sets the maximum number of concurrent requests that each instance
  /// can receive. Defaults to 1.
  final int maxInstanceRequestConcurrency;

  /// Security level configure whether the function only accepts https.
  /// This configuration is only applicable to 1st Gen functions with Http
  /// trigger. By default https is optional for 1st Gen functions; 2nd Gen
  /// functions are https ONLY.
  final ServiceConfig_SecurityLevel securityLevel;

  /// Optional. The binary authorization policy to be checked when deploying the
  /// Cloud Run service.
  final String binaryAuthorizationPolicy;

  ServiceConfig({
    this.service = '',
    this.timeoutSeconds = 0,
    this.availableMemory = '',
    this.availableCpu = '',
    this.environmentVariables = const {},
    this.maxInstanceCount = 0,
    this.minInstanceCount = 0,
    this.vpcConnector = '',
    this.vpcConnectorEgressSettings =
        ServiceConfig_VpcConnectorEgressSettings.$default,
    this.ingressSettings = ServiceConfig_IngressSettings.$default,
    this.uri = '',
    this.serviceAccountEmail = '',
    this.allTrafficOnLatestRevision = false,
    this.secretEnvironmentVariables = const [],
    this.secretVolumes = const [],
    this.revision = '',
    this.maxInstanceRequestConcurrency = 0,
    this.securityLevel = ServiceConfig_SecurityLevel.$default,
    this.binaryAuthorizationPolicy = '',
  }) : super(fullyQualifiedName);

  factory ServiceConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ServiceConfig(
      service: switch (json['service']) {
        null => '',
        Object $1 => decodeString($1),
      },
      timeoutSeconds: switch (json['timeoutSeconds']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      availableMemory: switch (json['availableMemory']) {
        null => '',
        Object $1 => decodeString($1),
      },
      availableCpu: switch (json['availableCpu']) {
        null => '',
        Object $1 => decodeString($1),
      },
      environmentVariables: switch (json['environmentVariables']) {
        null => {},
        Map<String, Object?> $1 => {
          for (final e in $1.entries)
            decodeString(e.key): decodeString(e.value),
        },
        _ => throw const FormatException(
          '"environmentVariables" is not an object',
        ),
      },
      maxInstanceCount: switch (json['maxInstanceCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      minInstanceCount: switch (json['minInstanceCount']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      vpcConnector: switch (json['vpcConnector']) {
        null => '',
        Object $1 => decodeString($1),
      },
      vpcConnectorEgressSettings: switch (json['vpcConnectorEgressSettings']) {
        null => ServiceConfig_VpcConnectorEgressSettings.$default,
        Object $1 => ServiceConfig_VpcConnectorEgressSettings.fromJson($1),
      },
      ingressSettings: switch (json['ingressSettings']) {
        null => ServiceConfig_IngressSettings.$default,
        Object $1 => ServiceConfig_IngressSettings.fromJson($1),
      },
      uri: switch (json['uri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAccountEmail: switch (json['serviceAccountEmail']) {
        null => '',
        Object $1 => decodeString($1),
      },
      allTrafficOnLatestRevision: switch (json['allTrafficOnLatestRevision']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      secretEnvironmentVariables: switch (json['secretEnvironmentVariables']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SecretEnvVar.fromJson(i)],
        _ => throw const FormatException(
          '"secretEnvironmentVariables" is not a list',
        ),
      },
      secretVolumes: switch (json['secretVolumes']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) SecretVolume.fromJson(i)],
        _ => throw const FormatException('"secretVolumes" is not a list'),
      },
      revision: switch (json['revision']) {
        null => '',
        Object $1 => decodeString($1),
      },
      maxInstanceRequestConcurrency:
          switch (json['maxInstanceRequestConcurrency']) {
            null => 0,
            Object $1 => decodeInt($1),
          },
      securityLevel: switch (json['securityLevel']) {
        null => ServiceConfig_SecurityLevel.$default,
        Object $1 => ServiceConfig_SecurityLevel.fromJson($1),
      },
      binaryAuthorizationPolicy: switch (json['binaryAuthorizationPolicy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (service.isNotDefault) 'service': service,
    if (timeoutSeconds.isNotDefault) 'timeoutSeconds': timeoutSeconds,
    if (availableMemory.isNotDefault) 'availableMemory': availableMemory,
    if (availableCpu.isNotDefault) 'availableCpu': availableCpu,
    if (environmentVariables.isNotDefault)
      'environmentVariables': environmentVariables,
    if (maxInstanceCount.isNotDefault) 'maxInstanceCount': maxInstanceCount,
    if (minInstanceCount.isNotDefault) 'minInstanceCount': minInstanceCount,
    if (vpcConnector.isNotDefault) 'vpcConnector': vpcConnector,
    if (vpcConnectorEgressSettings.isNotDefault)
      'vpcConnectorEgressSettings': vpcConnectorEgressSettings.toJson(),
    if (ingressSettings.isNotDefault)
      'ingressSettings': ingressSettings.toJson(),
    if (uri.isNotDefault) 'uri': uri,
    if (serviceAccountEmail.isNotDefault)
      'serviceAccountEmail': serviceAccountEmail,
    if (allTrafficOnLatestRevision.isNotDefault)
      'allTrafficOnLatestRevision': allTrafficOnLatestRevision,
    if (secretEnvironmentVariables.isNotDefault)
      'secretEnvironmentVariables': encodeList(secretEnvironmentVariables),
    if (secretVolumes.isNotDefault) 'secretVolumes': encodeList(secretVolumes),
    if (revision.isNotDefault) 'revision': revision,
    if (maxInstanceRequestConcurrency.isNotDefault)
      'maxInstanceRequestConcurrency': maxInstanceRequestConcurrency,
    if (securityLevel.isNotDefault) 'securityLevel': securityLevel.toJson(),
    if (binaryAuthorizationPolicy.isNotDefault)
      'binaryAuthorizationPolicy': binaryAuthorizationPolicy,
  };

  @override
  String toString() {
    final contents = [
      'service=$service',
      'timeoutSeconds=$timeoutSeconds',
      'availableMemory=$availableMemory',
      'availableCpu=$availableCpu',
      'maxInstanceCount=$maxInstanceCount',
      'minInstanceCount=$minInstanceCount',
      'vpcConnector=$vpcConnector',
      'vpcConnectorEgressSettings=$vpcConnectorEgressSettings',
      'ingressSettings=$ingressSettings',
      'uri=$uri',
      'serviceAccountEmail=$serviceAccountEmail',
      'allTrafficOnLatestRevision=$allTrafficOnLatestRevision',
      'revision=$revision',
      'maxInstanceRequestConcurrency=$maxInstanceRequestConcurrency',
      'securityLevel=$securityLevel',
      'binaryAuthorizationPolicy=$binaryAuthorizationPolicy',
    ].join(',');
    return 'ServiceConfig($contents)';
  }
}

/// Available egress settings.
///
/// This controls what traffic is diverted through the VPC Access Connector
/// resource. By default PRIVATE_RANGES_ONLY will be used.
final class ServiceConfig_VpcConnectorEgressSettings extends ProtoEnum {
  /// Unspecified.
  static const vpcConnectorEgressSettingsUnspecified =
      ServiceConfig_VpcConnectorEgressSettings(
        'VPC_CONNECTOR_EGRESS_SETTINGS_UNSPECIFIED',
      );

  /// Use the VPC Access Connector only for private IP space from RFC1918.
  static const privateRangesOnly = ServiceConfig_VpcConnectorEgressSettings(
    'PRIVATE_RANGES_ONLY',
  );

  /// Force the use of VPC Access Connector for all egress traffic from the
  /// function.
  static const allTraffic = ServiceConfig_VpcConnectorEgressSettings(
    'ALL_TRAFFIC',
  );

  /// The default value for [ServiceConfig_VpcConnectorEgressSettings].
  static const $default = vpcConnectorEgressSettingsUnspecified;

  const ServiceConfig_VpcConnectorEgressSettings(super.value);

  factory ServiceConfig_VpcConnectorEgressSettings.fromJson(Object? json) =>
      ServiceConfig_VpcConnectorEgressSettings(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'VpcConnectorEgressSettings.$value';
}

/// Available ingress settings.
///
/// This controls what traffic can reach the function.
///
/// If unspecified, ALLOW_ALL will be used.
final class ServiceConfig_IngressSettings extends ProtoEnum {
  /// Unspecified.
  static const ingressSettingsUnspecified = ServiceConfig_IngressSettings(
    'INGRESS_SETTINGS_UNSPECIFIED',
  );

  /// Allow HTTP traffic from public and private sources.
  static const allowAll = ServiceConfig_IngressSettings('ALLOW_ALL');

  /// Allow HTTP traffic from only private VPC sources.
  static const allowInternalOnly = ServiceConfig_IngressSettings(
    'ALLOW_INTERNAL_ONLY',
  );

  /// Allow HTTP traffic from private VPC sources and through GCLB.
  static const allowInternalAndGclb = ServiceConfig_IngressSettings(
    'ALLOW_INTERNAL_AND_GCLB',
  );

  /// The default value for [ServiceConfig_IngressSettings].
  static const $default = ingressSettingsUnspecified;

  const ServiceConfig_IngressSettings(super.value);

  factory ServiceConfig_IngressSettings.fromJson(Object? json) =>
      ServiceConfig_IngressSettings(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'IngressSettings.$value';
}

/// Available security level settings.
///
/// This enforces security protocol on function URL.
///
/// Security level is only configurable for 1st Gen functions, If unspecified,
/// SECURE_OPTIONAL will be used. 2nd Gen functions are SECURE_ALWAYS ONLY.
final class ServiceConfig_SecurityLevel extends ProtoEnum {
  /// Unspecified.
  static const securityLevelUnspecified = ServiceConfig_SecurityLevel(
    'SECURITY_LEVEL_UNSPECIFIED',
  );

  /// Requests for a URL that match this handler that do not use HTTPS are
  /// automatically redirected to the HTTPS URL with the same path. Query
  /// parameters are reserved for the redirect.
  static const secureAlways = ServiceConfig_SecurityLevel('SECURE_ALWAYS');

  /// Both HTTP and HTTPS requests with URLs that match the handler succeed
  /// without redirects. The application can examine the request to determine
  /// which protocol was used and respond accordingly.
  static const secureOptional = ServiceConfig_SecurityLevel('SECURE_OPTIONAL');

  /// The default value for [ServiceConfig_SecurityLevel].
  static const $default = securityLevelUnspecified;

  const ServiceConfig_SecurityLevel(super.value);

  factory ServiceConfig_SecurityLevel.fromJson(Object? json) =>
      ServiceConfig_SecurityLevel(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'SecurityLevel.$value';
}

/// Configuration for a secret environment variable. It has the information
/// necessary to fetch the secret value from secret manager and expose it as an
/// environment variable.
final class SecretEnvVar extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.SecretEnvVar';

  /// Name of the environment variable.
  final String key;

  /// Project identifier (preferably project number but can also be the
  /// project ID) of the project that contains the secret. If not set, it is
  /// assumed that the secret is in the same project as the function.
  final String projectId;

  /// Name of the secret in secret manager (not the full resource name).
  final String secret;

  /// Version of the secret (version number or the string 'latest'). It is
  /// recommended to use a numeric version for secret environment variables as
  /// any updates to the secret value is not reflected until new instances
  /// start.
  final String version;

  SecretEnvVar({
    this.key = '',
    this.projectId = '',
    this.secret = '',
    this.version = '',
  }) : super(fullyQualifiedName);

  factory SecretEnvVar.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SecretEnvVar(
      key: switch (json['key']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      secret: switch (json['secret']) {
        null => '',
        Object $1 => decodeString($1),
      },
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (key.isNotDefault) 'key': key,
    if (projectId.isNotDefault) 'projectId': projectId,
    if (secret.isNotDefault) 'secret': secret,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = [
      'key=$key',
      'projectId=$projectId',
      'secret=$secret',
      'version=$version',
    ].join(',');
    return 'SecretEnvVar($contents)';
  }
}

/// Configuration for a secret volume. It has the information necessary to fetch
/// the secret value from secret manager and make it available as files mounted
/// at the requested paths within the application container.
final class SecretVolume extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.SecretVolume';

  /// The path within the container to mount the secret volume. For example,
  /// setting the mount_path as `/etc/secrets` would mount the secret value files
  /// under the `/etc/secrets` directory. This directory will also be completely
  /// shadowed and unavailable to mount any other secrets.
  /// Recommended mount path: /etc/secrets
  final String mountPath;

  /// Project identifier (preferably project number but can also be the project
  /// ID) of the project that contains the secret. If not set, it is
  /// assumed that the secret is in the same project as the function.
  final String projectId;

  /// Name of the secret in secret manager (not the full resource name).
  final String secret;

  /// List of secret versions to mount for this secret. If empty, the `latest`
  /// version of the secret will be made available in a file named after the
  /// secret under the mount point.
  final List<SecretVolume_SecretVersion> versions;

  SecretVolume({
    this.mountPath = '',
    this.projectId = '',
    this.secret = '',
    this.versions = const [],
  }) : super(fullyQualifiedName);

  factory SecretVolume.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SecretVolume(
      mountPath: switch (json['mountPath']) {
        null => '',
        Object $1 => decodeString($1),
      },
      projectId: switch (json['projectId']) {
        null => '',
        Object $1 => decodeString($1),
      },
      secret: switch (json['secret']) {
        null => '',
        Object $1 => decodeString($1),
      },
      versions: switch (json['versions']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) SecretVolume_SecretVersion.fromJson(i),
        ],
        _ => throw const FormatException('"versions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (mountPath.isNotDefault) 'mountPath': mountPath,
    if (projectId.isNotDefault) 'projectId': projectId,
    if (secret.isNotDefault) 'secret': secret,
    if (versions.isNotDefault) 'versions': encodeList(versions),
  };

  @override
  String toString() {
    final contents = [
      'mountPath=$mountPath',
      'projectId=$projectId',
      'secret=$secret',
    ].join(',');
    return 'SecretVolume($contents)';
  }
}

/// Configuration for a single version.
final class SecretVolume_SecretVersion extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.SecretVolume.SecretVersion';

  /// Version of the secret (version number or the string 'latest'). It is
  /// preferable to use `latest` version with secret volumes as secret value
  /// changes are reflected immediately.
  final String version;

  /// Relative path of the file under the mount path where the secret value for
  /// this version will be fetched and made available. For example, setting the
  /// mount_path as '/etc/secrets' and path as `secret_foo` would mount the
  /// secret value file at `/etc/secrets/secret_foo`.
  final String path;

  SecretVolume_SecretVersion({this.version = '', this.path = ''})
    : super(fullyQualifiedName);

  factory SecretVolume_SecretVersion.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SecretVolume_SecretVersion(
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
      path: switch (json['path']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (version.isNotDefault) 'version': version,
    if (path.isNotDefault) 'path': path,
  };

  @override
  String toString() {
    final contents = ['version=$version', 'path=$path'].join(',');
    return 'SecretVersion($contents)';
  }
}

/// Describes EventTrigger, used to request events to be sent from another
/// service.
final class EventTrigger extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.EventTrigger';

  /// Output only. The resource name of the Eventarc trigger. The format of this
  /// field is `projects/{project}/locations/{region}/triggers/{trigger}`.
  final String trigger;

  /// The region that the trigger will be in. The trigger will only receive
  /// events originating in this region. It can be the same
  /// region as the function, a different region or multi-region, or the global
  /// region. If not provided, defaults to the same region as the function.
  final String triggerRegion;

  /// Required. The type of event to observe. For example:
  /// `google.cloud.audit.log.v1.written` or
  /// `google.cloud.pubsub.topic.v1.messagePublished`.
  final String eventType;

  /// Criteria used to filter events.
  final List<EventFilter> eventFilters;

  /// Optional. The name of a Pub/Sub topic in the same project that will be used
  /// as the transport topic for the event delivery. Format:
  /// `projects/{project}/topics/{topic}`.
  ///
  /// This is only valid for events of type
  /// `google.cloud.pubsub.topic.v1.messagePublished`. The topic provided here
  /// will not be deleted at function deletion.
  final String pubsubTopic;

  /// Optional. The email of the trigger's service account. The service account
  /// must have permission to invoke Cloud Run services, the permission is
  /// `run.routes.invoke`.
  /// If empty, defaults to the Compute Engine default service account:
  /// `{project_number}-compute@developer.gserviceaccount.com`.
  final String serviceAccountEmail;

  /// Optional. If unset, then defaults to ignoring failures (i.e. not retrying
  /// them).
  final EventTrigger_RetryPolicy retryPolicy;

  /// Optional. The name of the channel associated with the trigger in
  /// `projects/{project}/locations/{location}/channels/{channel}` format.
  /// You must provide a channel to receive events from Eventarc SaaS partners.
  final String channel;

  /// Optional. The hostname of the service that 1st Gen function should be
  /// observed.
  ///
  /// If no string is provided, the default service implementing the API will
  /// be used. For example, `storage.googleapis.com` is the default for all
  /// event types in the `google.storage` namespace.
  ///
  /// The field is only applicable to 1st Gen functions.
  final String service;

  EventTrigger({
    this.trigger = '',
    this.triggerRegion = '',
    required this.eventType,
    this.eventFilters = const [],
    this.pubsubTopic = '',
    this.serviceAccountEmail = '',
    this.retryPolicy = EventTrigger_RetryPolicy.$default,
    this.channel = '',
    this.service = '',
  }) : super(fullyQualifiedName);

  factory EventTrigger.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EventTrigger(
      trigger: switch (json['trigger']) {
        null => '',
        Object $1 => decodeString($1),
      },
      triggerRegion: switch (json['triggerRegion']) {
        null => '',
        Object $1 => decodeString($1),
      },
      eventType: switch (json['eventType']) {
        null => '',
        Object $1 => decodeString($1),
      },
      eventFilters: switch (json['eventFilters']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) EventFilter.fromJson(i)],
        _ => throw const FormatException('"eventFilters" is not a list'),
      },
      pubsubTopic: switch (json['pubsubTopic']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serviceAccountEmail: switch (json['serviceAccountEmail']) {
        null => '',
        Object $1 => decodeString($1),
      },
      retryPolicy: switch (json['retryPolicy']) {
        null => EventTrigger_RetryPolicy.$default,
        Object $1 => EventTrigger_RetryPolicy.fromJson($1),
      },
      channel: switch (json['channel']) {
        null => '',
        Object $1 => decodeString($1),
      },
      service: switch (json['service']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (trigger.isNotDefault) 'trigger': trigger,
    if (triggerRegion.isNotDefault) 'triggerRegion': triggerRegion,
    'eventType': eventType,
    if (eventFilters.isNotDefault) 'eventFilters': encodeList(eventFilters),
    if (pubsubTopic.isNotDefault) 'pubsubTopic': pubsubTopic,
    if (serviceAccountEmail.isNotDefault)
      'serviceAccountEmail': serviceAccountEmail,
    if (retryPolicy.isNotDefault) 'retryPolicy': retryPolicy.toJson(),
    if (channel.isNotDefault) 'channel': channel,
    if (service.isNotDefault) 'service': service,
  };

  @override
  String toString() {
    final contents = [
      'trigger=$trigger',
      'triggerRegion=$triggerRegion',
      'eventType=$eventType',
      'pubsubTopic=$pubsubTopic',
      'serviceAccountEmail=$serviceAccountEmail',
      'retryPolicy=$retryPolicy',
      'channel=$channel',
      'service=$service',
    ].join(',');
    return 'EventTrigger($contents)';
  }
}

/// Describes the retry policy in case of function's execution failure.
/// Retried execution is charged as any other execution.
final class EventTrigger_RetryPolicy extends ProtoEnum {
  /// Not specified.
  static const retryPolicyUnspecified = EventTrigger_RetryPolicy(
    'RETRY_POLICY_UNSPECIFIED',
  );

  /// Do not retry.
  static const retryPolicyDoNotRetry = EventTrigger_RetryPolicy(
    'RETRY_POLICY_DO_NOT_RETRY',
  );

  /// Retry on any failure, retry up to 7 days with an exponential backoff
  /// (capped at 10 seconds).
  static const retryPolicyRetry = EventTrigger_RetryPolicy(
    'RETRY_POLICY_RETRY',
  );

  /// The default value for [EventTrigger_RetryPolicy].
  static const $default = retryPolicyUnspecified;

  const EventTrigger_RetryPolicy(super.value);

  factory EventTrigger_RetryPolicy.fromJson(Object? json) =>
      EventTrigger_RetryPolicy(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'RetryPolicy.$value';
}

/// Filters events based on exact matches on the CloudEvents attributes.
final class EventFilter extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.EventFilter';

  /// Required. The name of a CloudEvents attribute.
  final String attribute;

  /// Required. The value for the attribute.
  final String value;

  /// Optional. The operator used for matching the events with the value of the
  /// filter. If not specified, only events that have an exact key-value pair
  /// specified in the filter are matched. The only allowed value is
  /// `match-path-pattern`.
  final String operator;

  EventFilter({
    required this.attribute,
    required this.value,
    this.operator = '',
  }) : super(fullyQualifiedName);

  factory EventFilter.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return EventFilter(
      attribute: switch (json['attribute']) {
        null => '',
        Object $1 => decodeString($1),
      },
      value: switch (json['value']) {
        null => '',
        Object $1 => decodeString($1),
      },
      operator: switch (json['operator']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'attribute': attribute,
    'value': value,
    if (operator.isNotDefault) 'operator': operator,
  };

  @override
  String toString() {
    final contents = [
      'attribute=$attribute',
      'value=$value',
      'operator=$operator',
    ].join(',');
    return 'EventFilter($contents)';
  }
}

/// Request for the `GetFunction` method.
final class GetFunctionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GetFunctionRequest';

  /// Required. The name of the function which details should be obtained.
  final String name;

  /// Optional. The optional version of the 1st gen function whose details should
  /// be obtained. The version of a 1st gen function is an integer that starts
  /// from 1 and gets incremented on redeployments. GCF may keep historical
  /// configs for old versions of 1st gen function. This field can be specified
  /// to fetch the historical configs. This field is valid only for GCF 1st gen
  /// function.
  final String revision;

  GetFunctionRequest({required this.name, this.revision = ''})
    : super(fullyQualifiedName);

  factory GetFunctionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetFunctionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      revision: switch (json['revision']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'name': name,
    if (revision.isNotDefault) 'revision': revision,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'revision=$revision'].join(',');
    return 'GetFunctionRequest($contents)';
  }
}

/// Request for the `ListFunctions` method.
final class ListFunctionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListFunctionsRequest';

  /// Required. The project and location from which the function should be
  /// listed, specified in the format `projects/*/locations/*` If you want to
  /// list functions in all locations, use "-" in place of a location. When
  /// listing functions in all locations, if one or more location(s) are
  /// unreachable, the response will contain functions from all reachable
  /// locations along with the names of any unreachable locations.
  final String parent;

  /// Maximum number of functions to return per call. The largest allowed
  /// page_size is 1,000, if the page_size is omitted or specified as greater
  /// than 1,000 then it will be replaced as 1,000. The size of the list
  /// response can be less than specified when used with filters.
  final int pageSize;

  /// The value returned by the last
  /// `ListFunctionsResponse`; indicates that
  /// this is a continuation of a prior `ListFunctions` call, and that the
  /// system should return the next page of data.
  final String pageToken;

  /// The filter for Functions that match the filter expression,
  /// following the syntax outlined in https://google.aip.dev/160.
  final String filter;

  /// The sorting order of the resources returned. Value should be a comma
  /// separated list of fields. The default sorting order is ascending.
  /// See https://google.aip.dev/132#ordering.
  final String orderBy;

  ListFunctionsRequest({
    required this.parent,
    this.pageSize = 0,
    this.pageToken = '',
    this.filter = '',
    this.orderBy = '',
  }) : super(fullyQualifiedName);

  factory ListFunctionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFunctionsRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      pageSize: switch (json['pageSize']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      pageToken: switch (json['pageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
      orderBy: switch (json['orderBy']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
    if (filter.isNotDefault) 'filter': filter,
    if (orderBy.isNotDefault) 'orderBy': orderBy,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
      'filter=$filter',
      'orderBy=$orderBy',
    ].join(',');
    return 'ListFunctionsRequest($contents)';
  }
}

/// Response for the `ListFunctions` method.
final class ListFunctionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListFunctionsResponse';

  /// The functions that match the request.
  final List<Function$> functions;

  /// A token, which can be sent as `page_token` to retrieve the next page.
  /// If this field is omitted, there are no subsequent pages.
  final String nextPageToken;

  /// Locations that could not be reached. The response does not include any
  /// functions from these locations.
  final List<String> unreachable;

  ListFunctionsResponse({
    this.functions = const [],
    this.nextPageToken = '',
    this.unreachable = const [],
  }) : super(fullyQualifiedName);

  factory ListFunctionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListFunctionsResponse(
      functions: switch (json['functions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Function$.fromJson(i)],
        _ => throw const FormatException('"functions" is not a list'),
      },
      nextPageToken: switch (json['nextPageToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      unreachable: switch (json['unreachable']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"unreachable" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (functions.isNotDefault) 'functions': encodeList(functions),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
    if (unreachable.isNotDefault) 'unreachable': unreachable,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListFunctionsResponse($contents)';
  }
}

/// Request for the `CreateFunction` method.
final class CreateFunctionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.CreateFunctionRequest';

  /// Required. The project and location in which the function should be created,
  /// specified in the format `projects/*/locations/*`
  final String parent;

  /// Required. Function to be created.
  final Function$? function;

  /// The ID to use for the function, which will become the final component of
  /// the function's resource name.
  ///
  /// This value should be 4-63 characters, and valid characters
  /// are /[a-z][0-9]-/.
  final String functionId;

  CreateFunctionRequest({
    required this.parent,
    required this.function,
    this.functionId = '',
  }) : super(fullyQualifiedName);

  factory CreateFunctionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return CreateFunctionRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      function: switch (json['function']) {
        null => null,
        Object $1 => Function$.fromJson($1),
      },
      functionId: switch (json['functionId']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (function != null) 'function': function!.toJson(),
    if (functionId.isNotDefault) 'functionId': functionId,
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'functionId=$functionId'].join(',');
    return 'CreateFunctionRequest($contents)';
  }
}

/// Request for the `UpdateFunction` method.
final class UpdateFunctionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.UpdateFunctionRequest';

  /// Required. New version of the function.
  final Function$? function;

  /// The list of fields to be updated.
  /// If no field mask is provided, all fields will be updated.
  final FieldMask? updateMask;

  UpdateFunctionRequest({required this.function, this.updateMask})
    : super(fullyQualifiedName);

  factory UpdateFunctionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return UpdateFunctionRequest(
      function: switch (json['function']) {
        null => null,
        Object $1 => Function$.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (function != null) 'function': function!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateFunctionRequest()';
}

/// Request for the `DeleteFunction` method.
final class DeleteFunctionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.DeleteFunctionRequest';

  /// Required. The name of the function which should be deleted.
  final String name;

  DeleteFunctionRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteFunctionRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DeleteFunctionRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteFunctionRequest($contents)';
  }
}

/// Request of `GenerateSourceUploadUrl` method.
final class GenerateUploadUrlRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GenerateUploadUrlRequest';

  /// Required. The project and location in which the Google Cloud Storage signed
  /// URL should be generated, specified in the format `projects/*/locations/*`.
  final String parent;

  /// Resource name of a KMS crypto key (managed by the user) used to
  /// encrypt/decrypt function source code objects in intermediate Cloud Storage
  /// buckets. When you generate an upload url and upload your source code, it
  /// gets copied to an intermediate Cloud Storage bucket. The source code is
  /// then copied to a versioned directory in the sources bucket in the consumer
  /// project during the function deployment.
  ///
  /// It must match the pattern
  /// `projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{crypto_key}`.
  ///
  /// The Google Cloud Functions service account
  /// (service-{project_number}@gcf-admin-robot.iam.gserviceaccount.com) must be
  /// granted the role 'Cloud KMS CryptoKey Encrypter/Decrypter
  /// (roles/cloudkms.cryptoKeyEncrypterDecrypter)' on the
  /// Key/KeyRing/Project/Organization (least access preferred).
  final String kmsKeyName;

  /// The function environment the generated upload url will be used for.
  /// The upload url for 2nd Gen functions can also be used for 1st gen
  /// functions, but not vice versa. If not specified, 2nd generation-style
  /// upload URLs are generated.
  final Environment environment;

  GenerateUploadUrlRequest({
    required this.parent,
    this.kmsKeyName = '',
    this.environment = Environment.$default,
  }) : super(fullyQualifiedName);

  factory GenerateUploadUrlRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateUploadUrlRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      kmsKeyName: switch (json['kmsKeyName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      environment: switch (json['environment']) {
        null => Environment.$default,
        Object $1 => Environment.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (kmsKeyName.isNotDefault) 'kmsKeyName': kmsKeyName,
    if (environment.isNotDefault) 'environment': environment.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'kmsKeyName=$kmsKeyName',
      'environment=$environment',
    ].join(',');
    return 'GenerateUploadUrlRequest($contents)';
  }
}

/// Response of `GenerateSourceUploadUrl` method.
final class GenerateUploadUrlResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GenerateUploadUrlResponse';

  /// The generated Google Cloud Storage signed URL that should be used for a
  /// function source code upload. The uploaded file should be a zip archive
  /// which contains a function.
  final String uploadUrl;

  /// The location of the source code in the upload bucket.
  ///
  /// Once the archive is uploaded using the `upload_url` use this field to
  /// set the `function.build_config.source.storage_source`
  /// during CreateFunction and UpdateFunction.
  ///
  /// Generation defaults to 0, as Cloud Storage provides a new generation only
  /// upon uploading a new object or version of an object.
  final StorageSource? storageSource;

  GenerateUploadUrlResponse({this.uploadUrl = '', this.storageSource})
    : super(fullyQualifiedName);

  factory GenerateUploadUrlResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateUploadUrlResponse(
      uploadUrl: switch (json['uploadUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
      storageSource: switch (json['storageSource']) {
        null => null,
        Object $1 => StorageSource.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (uploadUrl.isNotDefault) 'uploadUrl': uploadUrl,
    if (storageSource != null) 'storageSource': storageSource!.toJson(),
  };

  @override
  String toString() {
    final contents = ['uploadUrl=$uploadUrl'].join(',');
    return 'GenerateUploadUrlResponse($contents)';
  }
}

/// Request of `GenerateDownloadUrl` method.
final class GenerateDownloadUrlRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GenerateDownloadUrlRequest';

  /// Required. The name of function for which source code Google Cloud Storage
  /// signed URL should be generated.
  final String name;

  GenerateDownloadUrlRequest({required this.name}) : super(fullyQualifiedName);

  factory GenerateDownloadUrlRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateDownloadUrlRequest(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GenerateDownloadUrlRequest($contents)';
  }
}

/// Response of `GenerateDownloadUrl` method.
final class GenerateDownloadUrlResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.GenerateDownloadUrlResponse';

  /// The generated Google Cloud Storage signed URL that should be used for
  /// function source code download.
  final String downloadUrl;

  GenerateDownloadUrlResponse({this.downloadUrl = ''})
    : super(fullyQualifiedName);

  factory GenerateDownloadUrlResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GenerateDownloadUrlResponse(
      downloadUrl: switch (json['downloadUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (downloadUrl.isNotDefault) 'downloadUrl': downloadUrl};

  @override
  String toString() {
    final contents = ['downloadUrl=$downloadUrl'].join(',');
    return 'GenerateDownloadUrlResponse($contents)';
  }
}

/// Request for the `ListRuntimes` method.
final class ListRuntimesRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListRuntimesRequest';

  /// Required. The project and location from which the runtimes should be
  /// listed, specified in the format `projects/*/locations/*`
  final String parent;

  /// The filter for Runtimes that match the filter expression,
  /// following the syntax outlined in https://google.aip.dev/160.
  final String filter;

  ListRuntimesRequest({required this.parent, this.filter = ''})
    : super(fullyQualifiedName);

  factory ListRuntimesRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListRuntimesRequest(
      parent: switch (json['parent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      filter: switch (json['filter']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    'parent': parent,
    if (filter.isNotDefault) 'filter': filter,
  };

  @override
  String toString() {
    final contents = ['parent=$parent', 'filter=$filter'].join(',');
    return 'ListRuntimesRequest($contents)';
  }
}

/// Response for the `ListRuntimes` method.
final class ListRuntimesResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListRuntimesResponse';

  /// The runtimes that match the request.
  final List<ListRuntimesResponse_Runtime> runtimes;

  ListRuntimesResponse({this.runtimes = const []}) : super(fullyQualifiedName);

  factory ListRuntimesResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListRuntimesResponse(
      runtimes: switch (json['runtimes']) {
        null => [],
        List<Object?> $1 => [
          for (final i in $1) ListRuntimesResponse_Runtime.fromJson(i),
        ],
        _ => throw const FormatException('"runtimes" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (runtimes.isNotDefault) 'runtimes': encodeList(runtimes),
  };

  @override
  String toString() => 'ListRuntimesResponse()';
}

/// Describes a runtime and any special information (e.g., deprecation status)
/// related to it.
final class ListRuntimesResponse_Runtime extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.ListRuntimesResponse.Runtime';

  /// The name of the runtime, e.g., 'go113', 'nodejs12', etc.
  final String name;

  /// The user facing name, eg 'Go 1.13', 'Node.js 12', etc.
  final String displayName;

  /// The stage of life this runtime is in, e.g., BETA, GA, etc.
  final ListRuntimesResponse_RuntimeStage stage;

  /// Warning messages, e.g., a deprecation warning.
  final List<String> warnings;

  /// The environment for the runtime.
  final Environment environment;

  /// Deprecation date for the runtime.
  final Date? deprecationDate;

  /// Decommission date for the runtime.
  final Date? decommissionDate;

  ListRuntimesResponse_Runtime({
    this.name = '',
    this.displayName = '',
    this.stage = ListRuntimesResponse_RuntimeStage.$default,
    this.warnings = const [],
    this.environment = Environment.$default,
    this.deprecationDate,
    this.decommissionDate,
  }) : super(fullyQualifiedName);

  factory ListRuntimesResponse_Runtime.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ListRuntimesResponse_Runtime(
      name: switch (json['name']) {
        null => '',
        Object $1 => decodeString($1),
      },
      displayName: switch (json['displayName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      stage: switch (json['stage']) {
        null => ListRuntimesResponse_RuntimeStage.$default,
        Object $1 => ListRuntimesResponse_RuntimeStage.fromJson($1),
      },
      warnings: switch (json['warnings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"warnings" is not a list'),
      },
      environment: switch (json['environment']) {
        null => Environment.$default,
        Object $1 => Environment.fromJson($1),
      },
      deprecationDate: switch (json['deprecationDate']) {
        null => null,
        Object $1 => Date.fromJson($1),
      },
      decommissionDate: switch (json['decommissionDate']) {
        null => null,
        Object $1 => Date.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (displayName.isNotDefault) 'displayName': displayName,
    if (stage.isNotDefault) 'stage': stage.toJson(),
    if (warnings.isNotDefault) 'warnings': warnings,
    if (environment.isNotDefault) 'environment': environment.toJson(),
    if (deprecationDate != null) 'deprecationDate': deprecationDate!.toJson(),
    if (decommissionDate != null)
      'decommissionDate': decommissionDate!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'stage=$stage',
      'environment=$environment',
    ].join(',');
    return 'Runtime($contents)';
  }
}

/// The various stages that a runtime can be in.
final class ListRuntimesResponse_RuntimeStage extends ProtoEnum {
  /// Not specified.
  static const runtimeStageUnspecified = ListRuntimesResponse_RuntimeStage(
    'RUNTIME_STAGE_UNSPECIFIED',
  );

  /// The runtime is in development.
  static const development = ListRuntimesResponse_RuntimeStage('DEVELOPMENT');

  /// The runtime is in the Alpha stage.
  static const alpha = ListRuntimesResponse_RuntimeStage('ALPHA');

  /// The runtime is in the Beta stage.
  static const beta = ListRuntimesResponse_RuntimeStage('BETA');

  /// The runtime is generally available.
  static const ga = ListRuntimesResponse_RuntimeStage('GA');

  /// The runtime is deprecated.
  static const deprecated = ListRuntimesResponse_RuntimeStage('DEPRECATED');

  /// The runtime is no longer supported.
  static const decommissioned = ListRuntimesResponse_RuntimeStage(
    'DECOMMISSIONED',
  );

  /// The default value for [ListRuntimesResponse_RuntimeStage].
  static const $default = runtimeStageUnspecified;

  const ListRuntimesResponse_RuntimeStage(super.value);

  factory ListRuntimesResponse_RuntimeStage.fromJson(Object? json) =>
      ListRuntimesResponse_RuntimeStage(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'RuntimeStage.$value';
}

/// Security patches are applied automatically to the runtime without requiring
/// the function to be redeployed.
final class AutomaticUpdatePolicy extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.AutomaticUpdatePolicy';

  AutomaticUpdatePolicy() : super(fullyQualifiedName);

  factory AutomaticUpdatePolicy.fromJson(Object? j) => AutomaticUpdatePolicy();

  @override
  Object toJson() => {};

  @override
  String toString() => 'AutomaticUpdatePolicy()';
}

/// Security patches are only applied when a function is redeployed.
final class OnDeployUpdatePolicy extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.OnDeployUpdatePolicy';

  /// Output only. contains the runtime version which was used during latest
  /// function deployment.
  final String runtimeVersion;

  OnDeployUpdatePolicy({this.runtimeVersion = ''}) : super(fullyQualifiedName);

  factory OnDeployUpdatePolicy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return OnDeployUpdatePolicy(
      runtimeVersion: switch (json['runtimeVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (runtimeVersion.isNotDefault) 'runtimeVersion': runtimeVersion,
  };

  @override
  String toString() {
    final contents = ['runtimeVersion=$runtimeVersion'].join(',');
    return 'OnDeployUpdatePolicy($contents)';
  }
}

/// Represents the metadata of the long-running operation.
final class OperationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.OperationMetadata';

  /// The time the operation was created.
  final Timestamp? createTime;

  /// The time the operation finished running.
  final Timestamp? endTime;

  /// Server-defined resource path for the target of the operation.
  final String target;

  /// Name of the verb executed by the operation.
  final String verb;

  /// Human-readable status of the operation, if any.
  final String statusDetail;

  /// Identifies whether the user has requested cancellation
  /// of the operation. Operations that have successfully been cancelled
  /// have
  /// `google.longrunning.Operation.error`
  /// value with a `google.rpc.Status.code` of 1,
  /// corresponding to `Code.CANCELLED`.
  final bool cancelRequested;

  /// API version used to start the operation.
  final String apiVersion;

  /// The original request that started the operation.
  final Any? requestResource;

  /// Mechanism for reporting in-progress stages
  final List<Stage> stages;

  /// An identifier for Firebase function sources. Disclaimer: This field is only
  /// supported for Firebase function deployments.
  final String sourceToken;

  /// The build name of the function for create and update operations.
  final String buildName;

  /// The operation type.
  final OperationType operationType;

  OperationMetadata({
    this.createTime,
    this.endTime,
    this.target = '',
    this.verb = '',
    this.statusDetail = '',
    this.cancelRequested = false,
    this.apiVersion = '',
    this.requestResource,
    this.stages = const [],
    this.sourceToken = '',
    this.buildName = '',
    this.operationType = OperationType.$default,
  }) : super(fullyQualifiedName);

  factory OperationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return OperationMetadata(
      createTime: switch (json['createTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      target: switch (json['target']) {
        null => '',
        Object $1 => decodeString($1),
      },
      verb: switch (json['verb']) {
        null => '',
        Object $1 => decodeString($1),
      },
      statusDetail: switch (json['statusDetail']) {
        null => '',
        Object $1 => decodeString($1),
      },
      cancelRequested: switch (json['cancelRequested']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      apiVersion: switch (json['apiVersion']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requestResource: switch (json['requestResource']) {
        null => null,
        Object $1 => Any.fromJson($1),
      },
      stages: switch (json['stages']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Stage.fromJson(i)],
        _ => throw const FormatException('"stages" is not a list'),
      },
      sourceToken: switch (json['sourceToken']) {
        null => '',
        Object $1 => decodeString($1),
      },
      buildName: switch (json['buildName']) {
        null => '',
        Object $1 => decodeString($1),
      },
      operationType: switch (json['operationType']) {
        null => OperationType.$default,
        Object $1 => OperationType.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (target.isNotDefault) 'target': target,
    if (verb.isNotDefault) 'verb': verb,
    if (statusDetail.isNotDefault) 'statusDetail': statusDetail,
    if (cancelRequested.isNotDefault) 'cancelRequested': cancelRequested,
    if (apiVersion.isNotDefault) 'apiVersion': apiVersion,
    if (requestResource != null) 'requestResource': requestResource!.toJson(),
    if (stages.isNotDefault) 'stages': encodeList(stages),
    if (sourceToken.isNotDefault) 'sourceToken': sourceToken,
    if (buildName.isNotDefault) 'buildName': buildName,
    if (operationType.isNotDefault) 'operationType': operationType.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'target=$target',
      'verb=$verb',
      'statusDetail=$statusDetail',
      'cancelRequested=$cancelRequested',
      'apiVersion=$apiVersion',
      'sourceToken=$sourceToken',
      'buildName=$buildName',
      'operationType=$operationType',
    ].join(',');
    return 'OperationMetadata($contents)';
  }
}

/// Extra GCF specific location information.
final class LocationMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.cloud.functions.v2.LocationMetadata';

  /// The Cloud Function environments this location supports.
  final List<Environment> environments;

  LocationMetadata({this.environments = const []}) : super(fullyQualifiedName);

  factory LocationMetadata.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LocationMetadata(
      environments: switch (json['environments']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Environment.fromJson(i)],
        _ => throw const FormatException('"environments" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (environments.isNotDefault) 'environments': encodeList(environments),
  };

  @override
  String toString() => 'LocationMetadata()';
}

/// Each Stage of the deployment process
final class Stage extends ProtoMessage {
  static const String fullyQualifiedName = 'google.cloud.functions.v2.Stage';

  /// Name of the Stage. This will be unique for each Stage.
  final Stage_Name name;

  /// Message describing the Stage
  final String message;

  /// Current state of the Stage
  final Stage_State state;

  /// Resource of the Stage
  final String resource;

  /// Link to the current Stage resource
  final String resourceUri;

  /// State messages from the current Stage.
  final List<StateMessage> stateMessages;

  Stage({
    this.name = Stage_Name.$default,
    this.message = '',
    this.state = Stage_State.$default,
    this.resource = '',
    this.resourceUri = '',
    this.stateMessages = const [],
  }) : super(fullyQualifiedName);

  factory Stage.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Stage(
      name: switch (json['name']) {
        null => Stage_Name.$default,
        Object $1 => Stage_Name.fromJson($1),
      },
      message: switch (json['message']) {
        null => '',
        Object $1 => decodeString($1),
      },
      state: switch (json['state']) {
        null => Stage_State.$default,
        Object $1 => Stage_State.fromJson($1),
      },
      resource: switch (json['resource']) {
        null => '',
        Object $1 => decodeString($1),
      },
      resourceUri: switch (json['resourceUri']) {
        null => '',
        Object $1 => decodeString($1),
      },
      stateMessages: switch (json['stateMessages']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) StateMessage.fromJson(i)],
        _ => throw const FormatException('"stateMessages" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name.toJson(),
    if (message.isNotDefault) 'message': message,
    if (state.isNotDefault) 'state': state.toJson(),
    if (resource.isNotDefault) 'resource': resource,
    if (resourceUri.isNotDefault) 'resourceUri': resourceUri,
    if (stateMessages.isNotDefault) 'stateMessages': encodeList(stateMessages),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'message=$message',
      'state=$state',
      'resource=$resource',
      'resourceUri=$resourceUri',
    ].join(',');
    return 'Stage($contents)';
  }
}

/// Possible names for a Stage
final class Stage_Name extends ProtoEnum {
  /// Not specified. Invalid name.
  static const nameUnspecified = Stage_Name('NAME_UNSPECIFIED');

  /// Artifact Registry Stage
  static const artifactRegistry = Stage_Name('ARTIFACT_REGISTRY');

  /// Build Stage
  static const build = Stage_Name('BUILD');

  /// Service Stage
  static const service = Stage_Name('SERVICE');

  /// Trigger Stage
  static const trigger = Stage_Name('TRIGGER');

  /// Service Rollback Stage
  static const serviceRollback = Stage_Name('SERVICE_ROLLBACK');

  /// Trigger Rollback Stage
  static const triggerRollback = Stage_Name('TRIGGER_ROLLBACK');

  /// The default value for [Stage_Name].
  static const $default = nameUnspecified;

  const Stage_Name(super.value);

  factory Stage_Name.fromJson(Object? json) => Stage_Name(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Name.$value';
}

/// Possible states for a Stage
final class Stage_State extends ProtoEnum {
  /// Not specified. Invalid state.
  static const stateUnspecified = Stage_State('STATE_UNSPECIFIED');

  /// Stage has not started.
  static const notStarted = Stage_State('NOT_STARTED');

  /// Stage is in progress.
  static const inProgress = Stage_State('IN_PROGRESS');

  /// Stage has completed.
  static const complete = Stage_State('COMPLETE');

  /// The default value for [Stage_State].
  static const $default = stateUnspecified;

  const Stage_State(super.value);

  factory Stage_State.fromJson(Object? json) => Stage_State(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'State.$value';
}

/// The type of the long running operation.
final class OperationType extends ProtoEnum {
  /// Unspecified
  static const operationtypeUnspecified = OperationType(
    'OPERATIONTYPE_UNSPECIFIED',
  );

  /// CreateFunction
  static const createFunction = OperationType('CREATE_FUNCTION');

  /// UpdateFunction
  static const updateFunction = OperationType('UPDATE_FUNCTION');

  /// DeleteFunction
  static const deleteFunction = OperationType('DELETE_FUNCTION');

  /// The default value for [OperationType].
  static const $default = operationtypeUnspecified;

  const OperationType(super.value);

  factory OperationType.fromJson(Object? json) => OperationType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'OperationType.$value';
}

/// The environment the function is hosted on.
final class Environment extends ProtoEnum {
  /// Unspecified
  static const environmentUnspecified = Environment('ENVIRONMENT_UNSPECIFIED');

  /// Gen 1
  static const gen1 = Environment('GEN_1');

  /// Gen 2
  static const gen2 = Environment('GEN_2');

  /// The default value for [Environment].
  static const $default = environmentUnspecified;

  const Environment(super.value);

  factory Environment.fromJson(Object? json) => Environment(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Environment.$value';
}
