// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Common Types.
///
/// Defines common types for Google APIs.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';

/// Represents a color in the RGBA color space. This representation is designed
/// for simplicity of conversion to/from color representations in various
/// languages over compactness. For example, the fields of this representation
/// can be trivially provided to the constructor of `java.awt.Color` in Java; it
/// can also be trivially provided to UIColor's `+colorWithRed:green:blue:alpha`
/// method in iOS; and, with just a little work, it can be easily formatted into
/// a CSS `rgba()` string in JavaScript.
///
/// This reference page doesn't carry information about the absolute color
/// space
/// that should be used to interpret the RGB value (e.g. sRGB, Adobe RGB,
/// DCI-P3, BT.2020, etc.). By default, applications should assume the sRGB color
/// space.
///
/// When color equality needs to be decided, implementations, unless
/// documented otherwise, treat two colors as equal if all their red,
/// green, blue, and alpha values each differ by at most 1e-5.
///
/// Example (Java):
///
///      import com.google.type.Color;
///
///      // ...
///      public static java.awt.Color fromProto(Color protocolor) {
///        float alpha = protocolor.hasAlpha()
///            ? protocolor.getAlpha().getValue()
///            : 1.0;
///
///        return new java.awt.Color(
///            protocolor.getRed(),
///            protocolor.getGreen(),
///            protocolor.getBlue(),
///            alpha);
///      }
///
///      public static Color toProto(java.awt.Color color) {
///        float red = (float) color.getRed();
///        float green = (float) color.getGreen();
///        float blue = (float) color.getBlue();
///        float denominator = 255.0;
///        Color.Builder resultBuilder =
///            Color
///                .newBuilder()
///                .setRed(red / denominator)
///                .setGreen(green / denominator)
///                .setBlue(blue / denominator);
///        int alpha = color.getAlpha();
///        if (alpha != 255) {
///          result.setAlpha(
///              FloatValue
///                  .newBuilder()
///                  .setValue(((float) alpha) / denominator)
///                  .build());
///        }
///        return resultBuilder.build();
///      }
///      // ...
///
/// Example (iOS / Obj-C):
///
///      // ...
///      static UIColor* fromProto(Color* protocolor) {
///         float red = [protocolor red];
///         float green = [protocolor green];
///         float blue = [protocolor blue];
///         FloatValue* alpha_wrapper = [protocolor alpha];
///         float alpha = 1.0;
///         if (alpha_wrapper != nil) {
///           alpha = [alpha_wrapper value];
///         }
///         return [UIColor colorWithRed:red green:green blue:blue alpha:alpha];
///      }
///
///      static Color* toProto(UIColor* color) {
///          CGFloat red, green, blue, alpha;
///          if (![color getRed:&red green:&green blue:&blue alpha:&alpha]) {
///            return nil;
///          }
///          Color* result = [[Color alloc] init];
///          [result setRed:red];
///          [result setGreen:green];
///          [result setBlue:blue];
///          if (alpha <= 0.9999) {
///            [result setAlpha:floatWrapperWithValue(alpha)];
///          }
///          [result autorelease];
///          return result;
///     }
///     // ...
///
///  Example (JavaScript):
///
///     // ...
///
///     var protoToCssColor = function(rgb_color) {
///        var redFrac = rgb_color.red || 0.0;
///        var greenFrac = rgb_color.green || 0.0;
///        var blueFrac = rgb_color.blue || 0.0;
///        var red = Math.floor(redFrac * 255);
///        var green = Math.floor(greenFrac * 255);
///        var blue = Math.floor(blueFrac * 255);
///
///        if (!('alpha' in rgb_color)) {
///           return rgbToCssColor(red, green, blue);
///        }
///
///        var alphaFrac = rgb_color.alpha.value || 0.0;
///        var rgbParams = [red, green, blue].join(',');
///        return ['rgba(', rgbParams, ',', alphaFrac, ')'].join('');
///     };
///
///     var rgbToCssColor = function(red, green, blue) {
///       var rgbNumber = new Number((red << 16) | (green << 8) | blue);
///       var hexString = rgbNumber.toString(16);
///       var missingZeros = 6 - hexString.length;
///       var resultBuilder = ['#'];
///       for (var i = 0; i < missingZeros; i++) {
///          resultBuilder.push('0');
///       }
///       resultBuilder.push(hexString);
///       return resultBuilder.join('');
///     };
///
///     // ...
final class Color extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.Color';

  /// The amount of red in the color as a value in the interval [0, 1].
  final double red;

  /// The amount of green in the color as a value in the interval [0, 1].
  final double green;

  /// The amount of blue in the color as a value in the interval [0, 1].
  final double blue;

  /// The fraction of this color that should be applied to the pixel. That is,
  /// the final pixel color is defined by the equation:
  ///
  ///   `pixel color = alpha * (this color) + (1.0 - alpha) * (background color)`
  ///
  /// This means that a value of 1.0 corresponds to a solid color, whereas
  /// a value of 0.0 corresponds to a completely transparent color. This
  /// uses a wrapper message rather than a simple float scalar so that it is
  /// possible to distinguish between a default value and the value being unset.
  /// If omitted, this color object is rendered as a solid color
  /// (as if the alpha value had been explicitly given a value of 1.0).
  final FloatValue? alpha;

  Color({this.red = 0, this.green = 0, this.blue = 0, this.alpha})
    : super(fullyQualifiedName);

  factory Color.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Color(
      red: switch (json['red']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      green: switch (json['green']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      blue: switch (json['blue']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      alpha: switch (json['alpha']) {
        null => null,
        Object $1 => FloatValue.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (red.isNotDefault) 'red': encodeDouble(red),
    if (green.isNotDefault) 'green': encodeDouble(green),
    if (blue.isNotDefault) 'blue': encodeDouble(blue),
    if (alpha != null) 'alpha': alpha!.toJson(),
  };

  @override
  String toString() {
    final contents = ['red=$red', 'green=$green', 'blue=$blue'].join(',');
    return 'Color($contents)';
  }
}

/// Represents a whole or partial calendar date, such as a birthday. The time of
/// day and time zone are either specified elsewhere or are insignificant. The
/// date is relative to the Gregorian Calendar. This can represent one of the
/// following:
///
/// * A full date, with non-zero year, month, and day values
/// * A month and day value, with a zero year, such as an anniversary
/// * A year on its own, with zero month and day values
/// * A year and month value, with a zero day, such as a credit card expiration
/// date
///
/// Related types are `google.type.TimeOfDay` and
/// `google.protobuf.Timestamp`.
final class Date extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.Date';

  /// Year of the date. Must be from 1 to 9999, or 0 to specify a date without
  /// a year.
  final int year;

  /// Month of a year. Must be from 1 to 12, or 0 to specify a year without a
  /// month and day.
  final int month;

  /// Day of a month. Must be from 1 to 31 and valid for the year and month, or 0
  /// to specify a year by itself or a year and month where the day isn't
  /// significant.
  final int day;

  Date({this.year = 0, this.month = 0, this.day = 0})
    : super(fullyQualifiedName);

  factory Date.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Date(
      year: switch (json['year']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      month: switch (json['month']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      day: switch (json['day']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (year.isNotDefault) 'year': year,
    if (month.isNotDefault) 'month': month,
    if (day.isNotDefault) 'day': day,
  };

  @override
  String toString() {
    final contents = ['year=$year', 'month=$month', 'day=$day'].join(',');
    return 'Date($contents)';
  }
}

/// Represents civil time (or occasionally physical time).
///
/// This type can represent a civil time in one of a few possible ways:
///
///  * When utc_offset is set and time_zone is unset: a civil time on a calendar
///    day with a particular offset from UTC.
///  * When time_zone is set and utc_offset is unset: a civil time on a calendar
///    day in a particular time zone.
///  * When neither time_zone nor utc_offset is set: a civil time on a calendar
///    day in local time.
///
/// The date is relative to the Proleptic Gregorian Calendar.
///
/// If year is 0, the DateTime is considered not to have a specific year. month
/// and day must have valid, non-zero values.
///
/// This type may also be used to represent a physical time if all the date and
/// time fields are set and either case of the `time_offset` oneof is set.
/// Consider using `Timestamp` message for physical time instead. If your use
/// case also would like to store the user's timezone, that can be done in
/// another field.
///
/// This type is more flexible than some applications may want. Make sure to
/// document and validate your application's limitations.
final class DateTime extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.DateTime';

  /// Optional. Year of date. Must be from 1 to 9999, or 0 if specifying a
  /// datetime without a year.
  final int year;

  /// Required. Month of year. Must be from 1 to 12.
  final int month;

  /// Required. Day of month. Must be from 1 to 31 and valid for the year and
  /// month.
  final int day;

  /// Required. Hours of day in 24 hour format. Should be from 0 to 23. An API
  /// may choose to allow the value "24:00:00" for scenarios like business
  /// closing time.
  final int hours;

  /// Required. Minutes of hour of day. Must be from 0 to 59.
  final int minutes;

  /// Required. Seconds of minutes of the time. Must normally be from 0 to 59. An
  /// API may allow the value 60 if it allows leap-seconds.
  final int seconds;

  /// Required. Fractions of seconds in nanoseconds. Must be from 0 to
  /// 999,999,999.
  final int nanos;

  /// UTC offset. Must be whole seconds, between -18 hours and +18 hours.
  /// For example, a UTC offset of -4:00 would be represented as
  /// { seconds: -14400 }.
  final Duration? utcOffset;

  /// Time zone.
  final TimeZone? timeZone;

  DateTime({
    this.year = 0,
    this.month = 0,
    this.day = 0,
    this.hours = 0,
    this.minutes = 0,
    this.seconds = 0,
    this.nanos = 0,
    this.utcOffset,
    this.timeZone,
  }) : super(fullyQualifiedName);

  factory DateTime.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return DateTime(
      year: switch (json['year']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      month: switch (json['month']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      day: switch (json['day']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      hours: switch (json['hours']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      minutes: switch (json['minutes']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      seconds: switch (json['seconds']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      nanos: switch (json['nanos']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      utcOffset: switch (json['utcOffset']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      timeZone: switch (json['timeZone']) {
        null => null,
        Object $1 => TimeZone.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (year.isNotDefault) 'year': year,
    if (month.isNotDefault) 'month': month,
    if (day.isNotDefault) 'day': day,
    if (hours.isNotDefault) 'hours': hours,
    if (minutes.isNotDefault) 'minutes': minutes,
    if (seconds.isNotDefault) 'seconds': seconds,
    if (nanos.isNotDefault) 'nanos': nanos,
    if (utcOffset != null) 'utcOffset': utcOffset!.toJson(),
    if (timeZone != null) 'timeZone': timeZone!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'year=$year',
      'month=$month',
      'day=$day',
      'hours=$hours',
      'minutes=$minutes',
      'seconds=$seconds',
      'nanos=$nanos',
    ].join(',');
    return 'DateTime($contents)';
  }
}

/// Represents a time zone from the
/// [IANA Time Zone Database](https://www.iana.org/time-zones).
final class TimeZone extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.TimeZone';

  /// IANA Time Zone Database time zone, e.g. "America/New_York".
  final String id;

  /// Optional. IANA Time Zone Database version number, e.g. "2019a".
  final String version;

  TimeZone({this.id = '', this.version = ''}) : super(fullyQualifiedName);

  factory TimeZone.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TimeZone(
      id: switch (json['id']) {
        null => '',
        Object $1 => decodeString($1),
      },
      version: switch (json['version']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (id.isNotDefault) 'id': id,
    if (version.isNotDefault) 'version': version,
  };

  @override
  String toString() {
    final contents = ['id=$id', 'version=$version'].join(',');
    return 'TimeZone($contents)';
  }
}

/// A representation of a decimal value, such as 2.5. Clients may convert values
/// into language-native decimal formats, such as Java's `BigDecimal` or
/// Python's `decimal.Decimal`.
///
/// [BigDecimal]:
/// https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/math/BigDecimal.html
/// [decimal.Decimal]: https://docs.python.org/3/library/decimal.html
final class Decimal extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.Decimal';

  /// The decimal value, as a string.
  ///
  /// The string representation consists of an optional sign, `+` (`U+002B`)
  /// or `-` (`U+002D`), followed by a sequence of zero or more decimal digits
  /// ("the integer"), optionally followed by a fraction, optionally followed
  /// by an exponent.
  ///
  /// The fraction consists of a decimal point followed by zero or more decimal
  /// digits. The string must contain at least one digit in either the integer
  /// or the fraction. The number formed by the sign, the integer and the
  /// fraction is referred to as the significand.
  ///
  /// The exponent consists of the character `e` (`U+0065`) or `E` (`U+0045`)
  /// followed by one or more decimal digits.
  ///
  /// Services **should** normalize decimal values before storing them by:
  ///
  ///   - Removing an explicitly-provided `+` sign (`+2.5` -> `2.5`).
  ///   - Replacing a zero-length integer value with `0` (`.5` -> `0.5`).
  ///   - Coercing the exponent character to lower-case (`2.5E8` -> `2.5e8`).
  ///   - Removing an explicitly-provided zero exponent (`2.5e0` -> `2.5`).
  ///
  /// Services **may** perform additional normalization based on its own needs
  /// and the internal decimal implementation selected, such as shifting the
  /// decimal point and exponent value together (example: `2.5e-1` <-> `0.25`).
  /// Additionally, services **may** preserve trailing zeroes in the fraction
  /// to indicate increased precision, but are not required to do so.
  ///
  /// Note that only the `.` character is supported to divide the integer
  /// and the fraction; `,` **should not** be supported regardless of locale.
  /// Additionally, thousand separators **should not** be supported. If a
  /// service does support them, values **must** be normalized.
  ///
  /// The ENBF grammar is:
  ///
  ///     DecimalString =
  ///       [Sign] Significand [Exponent];
  ///
  ///     Sign = '+' | '-';
  ///
  ///     Significand =
  ///       Digits ['.'] [Digits] | [Digits] '.' Digits;
  ///
  ///     Exponent = ('e' | 'E') [Sign] Digits;
  ///
  ///     Digits = { '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' };
  ///
  /// Services **should** clearly document the range of supported values, the
  /// maximum supported precision (total number of digits), and, if applicable,
  /// the scale (number of digits after the decimal point), as well as how it
  /// behaves when receiving out-of-bounds values.
  ///
  /// Services **may** choose to accept values passed as input even when the
  /// value has a higher precision or scale than the service supports, and
  /// **should** round the value to fit the supported scale. Alternatively, the
  /// service **may** error with `400 Bad Request` (`INVALID_ARGUMENT` in gRPC)
  /// if precision would be lost.
  ///
  /// Services **should** error with `400 Bad Request` (`INVALID_ARGUMENT` in
  /// gRPC) if the service receives a value outside of the supported range.
  final String value;

  Decimal({this.value = ''}) : super(fullyQualifiedName);

  factory Decimal.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Decimal(
      value: switch (json['value']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {if (value.isNotDefault) 'value': value};

  @override
  String toString() {
    final contents = ['value=$value'].join(',');
    return 'Decimal($contents)';
  }
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax. CEL is a C-like expression language. The syntax and semantics of CEL
/// are documented at https://github.com/google/cel-spec.
///
/// Example (Comparison):
///
///     title: "Summary size limit"
///     description: "Determines if a summary is less than 100 chars"
///     expression: "document.summary.size() < 100"
///
/// Example (Equality):
///
///     title: "Requestor is owner"
///     description: "Determines if requestor is the document owner"
///     expression: "document.owner == request.auth.claims.email"
///
/// Example (Logic):
///
///     title: "Public documents"
///     description: "Determine whether the document should be publicly visible"
///     expression: "document.type != 'private' && document.type != 'internal'"
///
/// Example (Data Manipulation):
///
///     title: "Notification string"
///     description: "Create a notification string with a timestamp."
///     expression: "'New message received at ' + string(document.create_time)"
///
/// The exact variables and functions that may be referenced within an expression
/// are determined by the service that evaluates it. See the service
/// documentation for additional information.
final class Expr extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.Expr';

  /// Textual representation of an expression in Common Expression Language
  /// syntax.
  final String expression;

  /// Optional. Title for the expression, i.e. a short string describing
  /// its purpose. This can be used e.g. in UIs which allow to enter the
  /// expression.
  final String title;

  /// Optional. Description of the expression. This is a longer text which
  /// describes the expression, e.g. when hovered over it in a UI.
  final String description;

  /// Optional. String indicating the location of the expression for error
  /// reporting, e.g. a file name and a position in the file.
  final String location;

  Expr({
    this.expression = '',
    this.title = '',
    this.description = '',
    this.location = '',
  }) : super(fullyQualifiedName);

  factory Expr.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Expr(
      expression: switch (json['expression']) {
        null => '',
        Object $1 => decodeString($1),
      },
      title: switch (json['title']) {
        null => '',
        Object $1 => decodeString($1),
      },
      description: switch (json['description']) {
        null => '',
        Object $1 => decodeString($1),
      },
      location: switch (json['location']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (expression.isNotDefault) 'expression': expression,
    if (title.isNotDefault) 'title': title,
    if (description.isNotDefault) 'description': description,
    if (location.isNotDefault) 'location': location,
  };

  @override
  String toString() {
    final contents = [
      'expression=$expression',
      'title=$title',
      'description=$description',
      'location=$location',
    ].join(',');
    return 'Expr($contents)';
  }
}

/// Represents a fraction in terms of a numerator divided by a denominator.
final class Fraction extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.Fraction';

  /// The numerator in the fraction, e.g. 2 in 2/3.
  final int numerator;

  /// The value by which the numerator is divided, e.g. 3 in 2/3. Must be
  /// positive.
  final int denominator;

  Fraction({this.numerator = 0, this.denominator = 0})
    : super(fullyQualifiedName);

  factory Fraction.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Fraction(
      numerator: switch (json['numerator']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      denominator: switch (json['denominator']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (numerator.isNotDefault) 'numerator': encodeInt64(numerator),
    if (denominator.isNotDefault) 'denominator': encodeInt64(denominator),
  };

  @override
  String toString() {
    final contents = [
      'numerator=$numerator',
      'denominator=$denominator',
    ].join(',');
    return 'Fraction($contents)';
  }
}

/// Represents a time interval, encoded as a Timestamp start (inclusive) and a
/// Timestamp end (exclusive).
///
/// The start must be less than or equal to the end.
/// When the start equals the end, the interval is empty (matches no time).
/// When both start and end are unspecified, the interval matches any time.
final class Interval extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.Interval';

  /// Optional. Inclusive start of the interval.
  ///
  /// If specified, a Timestamp matching this interval will have to be the same
  /// or after the start.
  final Timestamp? startTime;

  /// Optional. Exclusive end of the interval.
  ///
  /// If specified, a Timestamp matching this interval will have to be before the
  /// end.
  final Timestamp? endTime;

  Interval({this.startTime, this.endTime}) : super(fullyQualifiedName);

  factory Interval.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Interval(
      startTime: switch (json['startTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
      endTime: switch (json['endTime']) {
        null => null,
        Object $1 => Timestamp.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (startTime != null) 'startTime': startTime!.toJson(),
    if (endTime != null) 'endTime': endTime!.toJson(),
  };

  @override
  String toString() => 'Interval()';
}

/// An object that represents a latitude/longitude pair. This is expressed as a
/// pair of doubles to represent degrees latitude and degrees longitude. Unless
/// specified otherwise, this must conform to the
/// <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
/// standard</a>. Values must be within normalized ranges.
final class LatLng extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.LatLng';

  /// The latitude in degrees. It must be in the range [-90.0, +90.0].
  final double latitude;

  /// The longitude in degrees. It must be in the range [-180.0, +180.0].
  final double longitude;

  LatLng({this.latitude = 0, this.longitude = 0}) : super(fullyQualifiedName);

  factory LatLng.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LatLng(
      latitude: switch (json['latitude']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      longitude: switch (json['longitude']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (latitude.isNotDefault) 'latitude': encodeDouble(latitude),
    if (longitude.isNotDefault) 'longitude': encodeDouble(longitude),
  };

  @override
  String toString() {
    final contents = ['latitude=$latitude', 'longitude=$longitude'].join(',');
    return 'LatLng($contents)';
  }
}

/// Localized variant of a text in a particular language.
final class LocalizedText extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.LocalizedText';

  /// Localized string in the language corresponding to `language_code' below.
  final String text;

  /// The text's BCP-47 language code, such as "en-US" or "sr-Latn".
  ///
  /// For more information, see
  /// http://www.unicode.org/reports/tr35/#Unicode_locale_identifier.
  final String languageCode;

  LocalizedText({this.text = '', this.languageCode = ''})
    : super(fullyQualifiedName);

  factory LocalizedText.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return LocalizedText(
      text: switch (json['text']) {
        null => '',
        Object $1 => decodeString($1),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (text.isNotDefault) 'text': text,
    if (languageCode.isNotDefault) 'languageCode': languageCode,
  };

  @override
  String toString() {
    final contents = ['text=$text', 'languageCode=$languageCode'].join(',');
    return 'LocalizedText($contents)';
  }
}

/// Represents an amount of money with its currency type.
final class Money extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.Money';

  /// The three-letter currency code defined in ISO 4217.
  final String currencyCode;

  /// The whole units of the amount.
  /// For example if `currencyCode` is `"USD"`, then 1 unit is one US dollar.
  final int units;

  /// Number of nano (10^-9) units of the amount.
  /// The value must be between -999,999,999 and +999,999,999 inclusive.
  /// If `units` is positive, `nanos` must be positive or zero.
  /// If `units` is zero, `nanos` can be positive, zero, or negative.
  /// If `units` is negative, `nanos` must be negative or zero.
  /// For example $-1.75 is represented as `units`=-1 and `nanos`=-750,000,000.
  final int nanos;

  Money({this.currencyCode = '', this.units = 0, this.nanos = 0})
    : super(fullyQualifiedName);

  factory Money.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Money(
      currencyCode: switch (json['currencyCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      units: switch (json['units']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      nanos: switch (json['nanos']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (currencyCode.isNotDefault) 'currencyCode': currencyCode,
    if (units.isNotDefault) 'units': encodeInt64(units),
    if (nanos.isNotDefault) 'nanos': nanos,
  };

  @override
  String toString() {
    final contents = [
      'currencyCode=$currencyCode',
      'units=$units',
      'nanos=$nanos',
    ].join(',');
    return 'Money($contents)';
  }
}

/// An object representing a phone number, suitable as an API wire format.
///
/// This representation:
///
///  - should not be used for locale-specific formatting of a phone number, such
///    as "+1 (650) 253-0000 ext. 123"
///
///  - is not designed for efficient storage
///  - may not be suitable for dialing - specialized libraries (see references)
///    should be used to parse the number for that purpose
///
/// To do something meaningful with this number, such as format it for various
/// use-cases, convert it to an `i18n.phonenumbers.PhoneNumber` object first.
///
/// For instance, in Java this would be:
///
///    com.google.type.PhoneNumber wireProto =
///        com.google.type.PhoneNumber.newBuilder().build();
///    com.google.i18n.phonenumbers.Phonenumber.PhoneNumber phoneNumber =
///        PhoneNumberUtil.getInstance().parse(wireProto.getE164Number(), "ZZ");
///    if (!wireProto.getExtension().isEmpty()) {
///      phoneNumber.setExtension(wireProto.getExtension());
///    }
///
///  Reference(s):
///   - https://github.com/google/libphonenumber
final class PhoneNumber extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.PhoneNumber';

  /// The phone number, represented as a leading plus sign ('+'), followed by a
  /// phone number that uses a relaxed ITU E.164 format consisting of the
  /// country calling code (1 to 3 digits) and the subscriber number, with no
  /// additional spaces or formatting, e.g.:
  ///  - correct: "+15552220123"
  ///  - incorrect: "+1 (555) 222-01234 x123".
  ///
  /// The ITU E.164 format limits the latter to 12 digits, but in practice not
  /// all countries respect that, so we relax that restriction here.
  /// National-only numbers are not allowed.
  ///
  /// References:
  ///  - https://www.itu.int/rec/T-REC-E.164-201011-I
  ///  - https://en.wikipedia.org/wiki/E.164.
  ///  - https://en.wikipedia.org/wiki/List_of_country_calling_codes
  final String? e164Number;

  /// A short code.
  ///
  /// Reference(s):
  ///  - https://en.wikipedia.org/wiki/Short_code
  final PhoneNumber_ShortCode? shortCode;

  /// The phone number's extension. The extension is not standardized in ITU
  /// recommendations, except for being defined as a series of numbers with a
  /// maximum length of 40 digits. Other than digits, some other dialing
  /// characters such as ',' (indicating a wait) or '#' may be stored here.
  ///
  /// Note that no regions currently use extensions with short codes, so this
  /// field is normally only set in conjunction with an E.164 number. It is held
  /// separately from the E.164 number to allow for short code extensions in the
  /// future.
  final String extension;

  PhoneNumber({this.e164Number, this.shortCode, this.extension = ''})
    : super(fullyQualifiedName);

  factory PhoneNumber.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PhoneNumber(
      e164Number: switch (json['e164Number']) {
        null => null,
        Object $1 => decodeString($1),
      },
      shortCode: switch (json['shortCode']) {
        null => null,
        Object $1 => PhoneNumber_ShortCode.fromJson($1),
      },
      extension: switch (json['extension']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (e164Number != null) 'e164Number': e164Number,
    if (shortCode != null) 'shortCode': shortCode!.toJson(),
    if (extension.isNotDefault) 'extension': extension,
  };

  @override
  String toString() {
    final contents = [
      if (e164Number != null) 'e164Number=$e164Number',
      'extension=$extension',
    ].join(',');
    return 'PhoneNumber($contents)';
  }
}

/// An object representing a short code, which is a phone number that is
/// typically much shorter than regular phone numbers and can be used to
/// address messages in MMS and SMS systems, as well as for abbreviated dialing
/// (e.g. "Text 611 to see how many minutes you have remaining on your plan.").
///
/// Short codes are restricted to a region and are not internationally
/// dialable, which means the same short code can exist in different regions,
/// with different usage and pricing, even if those regions share the same
/// country calling code (e.g. US and CA).
final class PhoneNumber_ShortCode extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.PhoneNumber.ShortCode';

  /// Required. The BCP-47 region code of the location where calls to this
  /// short code can be made, such as "US" and "BB".
  ///
  /// Reference(s):
  ///  - http://www.unicode.org/reports/tr35/#unicode_region_subtag
  final String regionCode;

  /// Required. The short code digits, without a leading plus ('+') or country
  /// calling code, e.g. "611".
  final String number;

  PhoneNumber_ShortCode({this.regionCode = '', this.number = ''})
    : super(fullyQualifiedName);

  factory PhoneNumber_ShortCode.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PhoneNumber_ShortCode(
      regionCode: switch (json['regionCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      number: switch (json['number']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (regionCode.isNotDefault) 'regionCode': regionCode,
    if (number.isNotDefault) 'number': number,
  };

  @override
  String toString() {
    final contents = ['regionCode=$regionCode', 'number=$number'].join(',');
    return 'ShortCode($contents)';
  }
}

/// Represents a postal address, e.g. for postal delivery or payments addresses.
/// Given a postal address, a postal service can deliver items to a premise, P.O.
/// Box or similar.
/// It is not intended to model geographical locations (roads, towns,
/// mountains).
///
/// In typical usage an address would be created via user input or from importing
/// existing data, depending on the type of process.
///
/// Advice on address input / editing:
///  - Use an i18n-ready address widget such as
///    https://github.com/google/libaddressinput)
/// - Users should not be presented with UI elements for input or editing of
///   fields outside countries where that field is used.
///
/// For more guidance on how to use this schema, please see:
/// https://support.google.com/business/answer/6397478
final class PostalAddress extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.PostalAddress';

  /// The schema revision of the `PostalAddress`. This must be set to 0, which is
  /// the latest revision.
  ///
  /// All new revisions **must** be backward compatible with old revisions.
  final int revision;

  /// Required. CLDR region code of the country/region of the address. This
  /// is never inferred and it is up to the user to ensure the value is
  /// correct. See http://cldr.unicode.org/ and
  /// http://www.unicode.org/cldr/charts/30/supplemental/territory_information.html
  /// for details. Example: "CH" for Switzerland.
  final String regionCode;

  /// Optional. BCP-47 language code of the contents of this address (if
  /// known). This is often the UI language of the input form or is expected
  /// to match one of the languages used in the address' country/region, or their
  /// transliterated equivalents.
  /// This can affect formatting in certain countries, but is not critical
  /// to the correctness of the data and will never affect any validation or
  /// other non-formatting related operations.
  ///
  /// If this value is not known, it should be omitted (rather than specifying a
  /// possibly incorrect default).
  ///
  /// Examples: "zh-Hant", "ja", "ja-Latn", "en".
  final String languageCode;

  /// Optional. Postal code of the address. Not all countries use or require
  /// postal codes to be present, but where they are used, they may trigger
  /// additional validation with other parts of the address (e.g. state/zip
  /// validation in the U.S.A.).
  final String postalCode;

  /// Optional. Additional, country-specific, sorting code. This is not used
  /// in most regions. Where it is used, the value is either a string like
  /// "CEDEX", optionally followed by a number (e.g. "CEDEX 7"), or just a number
  /// alone, representing the "sector code" (Jamaica), "delivery area indicator"
  /// (Malawi) or "post office indicator" (e.g. Côte d'Ivoire).
  final String sortingCode;

  /// Optional. Highest administrative subdivision which is used for postal
  /// addresses of a country or region.
  /// For example, this can be a state, a province, an oblast, or a prefecture.
  /// Specifically, for Spain this is the province and not the autonomous
  /// community (e.g. "Barcelona" and not "Catalonia").
  /// Many countries don't use an administrative area in postal addresses. E.g.
  /// in Switzerland this should be left unpopulated.
  final String administrativeArea;

  /// Optional. Generally refers to the city/town portion of the address.
  /// Examples: US city, IT comune, UK post town.
  /// In regions of the world where localities are not well defined or do not fit
  /// into this structure well, leave locality empty and use address_lines.
  final String locality;

  /// Optional. Sublocality of the address.
  /// For example, this can be neighborhoods, boroughs, districts.
  final String sublocality;

  /// Unstructured address lines describing the lower levels of an address.
  ///
  /// Because values in address_lines do not have type information and may
  /// sometimes contain multiple values in a single field (e.g.
  /// "Austin, TX"), it is important that the line order is clear. The order of
  /// address lines should be "envelope order" for the country/region of the
  /// address. In places where this can vary (e.g. Japan), address_language is
  /// used to make it explicit (e.g. "ja" for large-to-small ordering and
  /// "ja-Latn" or "en" for small-to-large). This way, the most specific line of
  /// an address can be selected based on the language.
  ///
  /// The minimum permitted structural representation of an address consists
  /// of a region_code with all remaining information placed in the
  /// address_lines. It would be possible to format such an address very
  /// approximately without geocoding, but no semantic reasoning could be
  /// made about any of the address components until it was at least
  /// partially resolved.
  ///
  /// Creating an address only containing a region_code and address_lines, and
  /// then geocoding is the recommended way to handle completely unstructured
  /// addresses (as opposed to guessing which parts of the address should be
  /// localities or administrative areas).
  final List<String> addressLines;

  /// Optional. The recipient at the address.
  /// This field may, under certain circumstances, contain multiline information.
  /// For example, it might contain "care of" information.
  final List<String> recipients;

  /// Optional. The name of the organization at the address.
  final String organization;

  PostalAddress({
    this.revision = 0,
    this.regionCode = '',
    this.languageCode = '',
    this.postalCode = '',
    this.sortingCode = '',
    this.administrativeArea = '',
    this.locality = '',
    this.sublocality = '',
    this.addressLines = const [],
    this.recipients = const [],
    this.organization = '',
  }) : super(fullyQualifiedName);

  factory PostalAddress.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PostalAddress(
      revision: switch (json['revision']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      regionCode: switch (json['regionCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      languageCode: switch (json['languageCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      postalCode: switch (json['postalCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sortingCode: switch (json['sortingCode']) {
        null => '',
        Object $1 => decodeString($1),
      },
      administrativeArea: switch (json['administrativeArea']) {
        null => '',
        Object $1 => decodeString($1),
      },
      locality: switch (json['locality']) {
        null => '',
        Object $1 => decodeString($1),
      },
      sublocality: switch (json['sublocality']) {
        null => '',
        Object $1 => decodeString($1),
      },
      addressLines: switch (json['addressLines']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"addressLines" is not a list'),
      },
      recipients: switch (json['recipients']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"recipients" is not a list'),
      },
      organization: switch (json['organization']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (revision.isNotDefault) 'revision': revision,
    if (regionCode.isNotDefault) 'regionCode': regionCode,
    if (languageCode.isNotDefault) 'languageCode': languageCode,
    if (postalCode.isNotDefault) 'postalCode': postalCode,
    if (sortingCode.isNotDefault) 'sortingCode': sortingCode,
    if (administrativeArea.isNotDefault)
      'administrativeArea': administrativeArea,
    if (locality.isNotDefault) 'locality': locality,
    if (sublocality.isNotDefault) 'sublocality': sublocality,
    if (addressLines.isNotDefault) 'addressLines': addressLines,
    if (recipients.isNotDefault) 'recipients': recipients,
    if (organization.isNotDefault) 'organization': organization,
  };

  @override
  String toString() {
    final contents = [
      'revision=$revision',
      'regionCode=$regionCode',
      'languageCode=$languageCode',
      'postalCode=$postalCode',
      'sortingCode=$sortingCode',
      'administrativeArea=$administrativeArea',
      'locality=$locality',
      'sublocality=$sublocality',
      'organization=$organization',
    ].join(',');
    return 'PostalAddress($contents)';
  }
}

/// A quaternion is defined as the quotient of two directed lines in a
/// three-dimensional space or equivalently as the quotient of two Euclidean
/// vectors (https://en.wikipedia.org/wiki/Quaternion).
///
/// Quaternions are often used in calculations involving three-dimensional
/// rotations (https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation),
/// as they provide greater mathematical robustness by avoiding the gimbal lock
/// problems that can be encountered when using Euler angles
/// (https://en.wikipedia.org/wiki/Gimbal_lock).
///
/// Quaternions are generally represented in this form:
///
///     w + xi + yj + zk
///
/// where x, y, z, and w are real numbers, and i, j, and k are three imaginary
/// numbers.
///
/// Our naming choice `(x, y, z, w)` comes from the desire to avoid confusion for
/// those interested in the geometric properties of the quaternion in the 3D
/// Cartesian space. Other texts often use alternative names or subscripts, such
/// as `(a, b, c, d)`, `(1, i, j, k)`, or `(0, 1, 2, 3)`, which are perhaps
/// better suited for mathematical interpretations.
///
/// To avoid any confusion, as well as to maintain compatibility with a large
/// number of software libraries, the quaternions represented using the protocol
/// buffer below *must* follow the Hamilton convention, which defines `ij = k`
/// (i.e. a right-handed algebra), and therefore:
///
///     i^2 = j^2 = k^2 = ijk = −1
///     ij = −ji = k
///     jk = −kj = i
///     ki = −ik = j
///
/// Please DO NOT use this to represent quaternions that follow the JPL
/// convention, or any of the other quaternion flavors out there.
///
/// Definitions:
///
///   - Quaternion norm (or magnitude): `sqrt(x^2 + y^2 + z^2 + w^2)`.
///   - Unit (or normalized) quaternion: a quaternion whose norm is 1.
///   - Pure quaternion: a quaternion whose scalar component (`w`) is 0.
///   - Rotation quaternion: a unit quaternion used to represent rotation.
///   - Orientation quaternion: a unit quaternion used to represent orientation.
///
/// A quaternion can be normalized by dividing it by its norm. The resulting
/// quaternion maintains the same direction, but has a norm of 1, i.e. it moves
/// on the unit sphere. This is generally necessary for rotation and orientation
/// quaternions, to avoid rounding errors:
/// https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions
///
/// Note that `(x, y, z, w)` and `(-x, -y, -z, -w)` represent the same rotation,
/// but normalization would be even more useful, e.g. for comparison purposes, if
/// it would produce a unique representation. It is thus recommended that `w` be
/// kept positive, which can be achieved by changing all the signs when `w` is
/// negative.
final class Quaternion extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.Quaternion';

  /// The x component.
  final double x;

  /// The y component.
  final double y;

  /// The z component.
  final double z;

  /// The scalar component.
  final double w;

  Quaternion({this.x = 0, this.y = 0, this.z = 0, this.w = 0})
    : super(fullyQualifiedName);

  factory Quaternion.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Quaternion(
      x: switch (json['x']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      y: switch (json['y']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      z: switch (json['z']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
      w: switch (json['w']) {
        null => 0,
        Object $1 => decodeDouble($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (x.isNotDefault) 'x': encodeDouble(x),
    if (y.isNotDefault) 'y': encodeDouble(y),
    if (z.isNotDefault) 'z': encodeDouble(z),
    if (w.isNotDefault) 'w': encodeDouble(w),
  };

  @override
  String toString() {
    final contents = ['x=$x', 'y=$y', 'z=$z', 'w=$w'].join(',');
    return 'Quaternion($contents)';
  }
}

/// Represents a time of day. The date and time zone are either not significant
/// or are specified elsewhere. An API may choose to allow leap seconds. Related
/// types are `google.type.Date` and
/// `google.protobuf.Timestamp`.
final class TimeOfDay extends ProtoMessage {
  static const String fullyQualifiedName = 'google.type.TimeOfDay';

  /// Hours of day in 24 hour format. Should be from 0 to 23. An API may choose
  /// to allow the value "24:00:00" for scenarios like business closing time.
  final int hours;

  /// Minutes of hour of day. Must be from 0 to 59.
  final int minutes;

  /// Seconds of minutes of the time. Must normally be from 0 to 59. An API may
  /// allow the value 60 if it allows leap-seconds.
  final int seconds;

  /// Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
  final int nanos;

  TimeOfDay({
    this.hours = 0,
    this.minutes = 0,
    this.seconds = 0,
    this.nanos = 0,
  }) : super(fullyQualifiedName);

  factory TimeOfDay.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TimeOfDay(
      hours: switch (json['hours']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      minutes: switch (json['minutes']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      seconds: switch (json['seconds']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      nanos: switch (json['nanos']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (hours.isNotDefault) 'hours': hours,
    if (minutes.isNotDefault) 'minutes': minutes,
    if (seconds.isNotDefault) 'seconds': seconds,
    if (nanos.isNotDefault) 'nanos': nanos,
  };

  @override
  String toString() {
    final contents = [
      'hours=$hours',
      'minutes=$minutes',
      'seconds=$seconds',
      'nanos=$nanos',
    ].join(',');
    return 'TimeOfDay($contents)';
  }
}

/// A `CalendarPeriod` represents the abstract concept of a time period that has
/// a canonical start. Grammatically, "the start of the current
/// `CalendarPeriod`." All calendar times begin at midnight UTC.
final class CalendarPeriod extends ProtoEnum {
  /// Undefined period, raises an error.
  static const calendarPeriodUnspecified = CalendarPeriod(
    'CALENDAR_PERIOD_UNSPECIFIED',
  );

  /// A day.
  static const day = CalendarPeriod('DAY');

  /// A week. Weeks begin on Monday, following
  /// [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date).
  static const week = CalendarPeriod('WEEK');

  /// A fortnight. The first calendar fortnight of the year begins at the start
  /// of week 1 according to
  /// [ISO 8601](https://en.wikipedia.org/wiki/ISO_week_date).
  static const fortnight = CalendarPeriod('FORTNIGHT');

  /// A month.
  static const month = CalendarPeriod('MONTH');

  /// A quarter. Quarters start on dates 1-Jan, 1-Apr, 1-Jul, and 1-Oct of each
  /// year.
  static const quarter = CalendarPeriod('QUARTER');

  /// A half-year. Half-years start on dates 1-Jan and 1-Jul.
  static const half = CalendarPeriod('HALF');

  /// A year.
  static const year = CalendarPeriod('YEAR');

  /// The default value for [CalendarPeriod].
  static const $default = calendarPeriodUnspecified;

  const CalendarPeriod(super.value);

  factory CalendarPeriod.fromJson(Object? json) =>
      CalendarPeriod(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'CalendarPeriod.$value';
}

/// Represents a day of the week.
final class DayOfWeek extends ProtoEnum {
  /// The day of the week is unspecified.
  static const dayOfWeekUnspecified = DayOfWeek('DAY_OF_WEEK_UNSPECIFIED');

  /// Monday
  static const monday = DayOfWeek('MONDAY');

  /// Tuesday
  static const tuesday = DayOfWeek('TUESDAY');

  /// Wednesday
  static const wednesday = DayOfWeek('WEDNESDAY');

  /// Thursday
  static const thursday = DayOfWeek('THURSDAY');

  /// Friday
  static const friday = DayOfWeek('FRIDAY');

  /// Saturday
  static const saturday = DayOfWeek('SATURDAY');

  /// Sunday
  static const sunday = DayOfWeek('SUNDAY');

  /// The default value for [DayOfWeek].
  static const $default = dayOfWeekUnspecified;

  const DayOfWeek(super.value);

  factory DayOfWeek.fromJson(Object? json) => DayOfWeek(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'DayOfWeek.$value';
}

/// Represents a month in the Gregorian calendar.
final class Month extends ProtoEnum {
  /// The unspecified month.
  static const monthUnspecified = Month('MONTH_UNSPECIFIED');

  /// The month of January.
  static const january = Month('JANUARY');

  /// The month of February.
  static const february = Month('FEBRUARY');

  /// The month of March.
  static const march = Month('MARCH');

  /// The month of April.
  static const april = Month('APRIL');

  /// The month of May.
  static const may = Month('MAY');

  /// The month of June.
  static const june = Month('JUNE');

  /// The month of July.
  static const july = Month('JULY');

  /// The month of August.
  static const august = Month('AUGUST');

  /// The month of September.
  static const september = Month('SEPTEMBER');

  /// The month of October.
  static const october = Month('OCTOBER');

  /// The month of November.
  static const november = Month('NOVEMBER');

  /// The month of December.
  static const december = Month('DECEMBER');

  /// The default value for [Month].
  static const $default = monthUnspecified;

  const Month(super.value);

  factory Month.fromJson(Object? json) => Month(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Month.$value';
}
