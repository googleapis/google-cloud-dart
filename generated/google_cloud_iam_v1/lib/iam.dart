// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the IAM Meta API.
///
/// Manages access control for Google Cloud Platform resources.
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:google_cloud_type/type.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// API Overview
///
/// Manages Identity and Access Management (IAM) policies.
///
/// Any implementation of an API that offers access control features
/// implements the google.iam.v1.IAMPolicy interface.
///
/// ## Data model
///
/// Access control is applied when a principal (user or service account), takes
/// some action on a resource exposed by a service. Resources, identified by
/// URI-like names, are the unit of access control specification. Service
/// implementations can choose the granularity of access control and the
/// supported permissions for their resources.
/// For example one database service may allow access control to be
/// specified only at the Table level, whereas another might allow access control
/// to also be specified at the Column level.
///
/// ## Policy Structure
///
/// See google.iam.v1.Policy
///
/// This is intentionally not a CRUD style API because access control policies
/// are created and deleted implicitly with the resources to which they are
/// attached.
final class IAMPolicy {
  static const _host = 'iam-meta-api.googleapis.com';

  final ServiceClient _client;

  /// Creates a `IAMPolicy` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `IAMPolicy`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  IAMPolicy({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `IAMPolicy` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory IAMPolicy.fromApiKey([String? apiKey]) =>
      IAMPolicy(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Sets the access control policy on the specified resource. Replaces any
  /// existing policy.
  ///
  /// Can return `NOT_FOUND`, `INVALID_ARGUMENT`, and `PERMISSION_DENIED` errors.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Gets the access control policy for a resource.
  /// Returns an empty policy if the resource exists and does not have a policy
  /// set.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1/${request.resource}:getIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Returns permissions that a caller has on the specified resource.
  /// If the resource does not exist, this will return an empty set of
  /// permissions, not a `NOT_FOUND` error.
  ///
  /// Note: This operation is designed to be used for building permission-aware
  /// UIs and command-line tools, not for authorization checking. This operation
  /// may "fail open" without warning.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1/${request.resource}:testIamPermissions');
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// Request message for `SetIamPolicy` method.
final class SetIamPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.SetIamPolicyRequest';

  /// REQUIRED: The resource for which the policy is being specified.
  /// See the operation documentation for the appropriate value for this field.
  final String resource;

  /// REQUIRED: The complete policy to be applied to the `resource`. The size of
  /// the policy is limited to a few 10s of KB. An empty policy is a
  /// valid policy but certain Cloud Platform services (such as Projects)
  /// might reject them.
  final Policy? policy;

  /// OPTIONAL: A FieldMask specifying which fields of the policy to modify. Only
  /// the fields in the mask will be modified. If no mask is provided, the
  /// following default mask is used:
  ///
  /// `paths: "bindings, etag"`
  final FieldMask? updateMask;

  SetIamPolicyRequest({
    required this.resource,
    required this.policy,
    this.updateMask,
  }) : super(fullyQualifiedName);

  factory SetIamPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return SetIamPolicyRequest(
      resource: switch (json['resource']) {
        null => '',
        Object $1 => decodeString($1),
      },
      policy: switch (json['policy']) {
        null => null,
        Object $1 => Policy.fromJson($1),
      },
      updateMask: switch (json['updateMask']) {
        null => null,
        Object $1 => FieldMask.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'resource': resource,
    if (policy != null) 'policy': policy!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() {
    final contents = ['resource=$resource'].join(',');
    return 'SetIamPolicyRequest($contents)';
  }
}

/// Request message for `GetIamPolicy` method.
final class GetIamPolicyRequest extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.GetIamPolicyRequest';

  /// REQUIRED: The resource for which the policy is being requested.
  /// See the operation documentation for the appropriate value for this field.
  final String resource;

  /// OPTIONAL: A `GetPolicyOptions` object for specifying options to
  /// `GetIamPolicy`.
  final GetPolicyOptions? options;

  GetIamPolicyRequest({required this.resource, this.options})
    : super(fullyQualifiedName);

  factory GetIamPolicyRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetIamPolicyRequest(
      resource: switch (json['resource']) {
        null => '',
        Object $1 => decodeString($1),
      },
      options: switch (json['options']) {
        null => null,
        Object $1 => GetPolicyOptions.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    'resource': resource,
    if (options != null) 'options': options!.toJson(),
  };

  @override
  String toString() {
    final contents = ['resource=$resource'].join(',');
    return 'GetIamPolicyRequest($contents)';
  }
}

/// Request message for `TestIamPermissions` method.
final class TestIamPermissionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.iam.v1.TestIamPermissionsRequest';

  /// REQUIRED: The resource for which the policy detail is being requested.
  /// See the operation documentation for the appropriate value for this field.
  final String resource;

  /// The set of permissions to check for the `resource`. Permissions with
  /// wildcards (such as '*' or 'storage.*') are not allowed. For more
  /// information see
  /// [IAM Overview](https://cloud.google.com/iam/docs/overview#permissions).
  final List<String> permissions;

  TestIamPermissionsRequest({required this.resource, required this.permissions})
    : super(fullyQualifiedName);

  factory TestIamPermissionsRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TestIamPermissionsRequest(
      resource: switch (json['resource']) {
        null => '',
        Object $1 => decodeString($1),
      },
      permissions: switch (json['permissions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"permissions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {'resource': resource, 'permissions': permissions};

  @override
  String toString() {
    final contents = ['resource=$resource'].join(',');
    return 'TestIamPermissionsRequest($contents)';
  }
}

/// Response message for `TestIamPermissions` method.
final class TestIamPermissionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.iam.v1.TestIamPermissionsResponse';

  /// A subset of `TestPermissionsRequest.permissions` that the caller is
  /// allowed.
  final List<String> permissions;

  TestIamPermissionsResponse({this.permissions = const []})
    : super(fullyQualifiedName);

  factory TestIamPermissionsResponse.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return TestIamPermissionsResponse(
      permissions: switch (json['permissions']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"permissions" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {if (permissions.isNotDefault) 'permissions': permissions};

  @override
  String toString() => 'TestIamPermissionsResponse()';
}

/// Encapsulates settings provided to GetIamPolicy.
final class GetPolicyOptions extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.GetPolicyOptions';

  /// Optional. The maximum policy version that will be used to format the
  /// policy.
  ///
  /// Valid values are 0, 1, and 3. Requests specifying an invalid value will be
  /// rejected.
  ///
  /// Requests for policies with any conditional role bindings must specify
  /// version 3. Policies with no conditional role bindings may specify any valid
  /// value or leave the field unset.
  ///
  /// The policy in the response might use the policy version that you specified,
  /// or it might use a lower policy version. For example, if you specify version
  /// 3, but the policy has no conditional role bindings, the response uses
  /// version 1.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  final int requestedPolicyVersion;

  GetPolicyOptions({this.requestedPolicyVersion = 0})
    : super(fullyQualifiedName);

  factory GetPolicyOptions.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return GetPolicyOptions(
      requestedPolicyVersion: switch (json['requestedPolicyVersion']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (requestedPolicyVersion.isNotDefault)
      'requestedPolicyVersion': requestedPolicyVersion,
  };

  @override
  String toString() {
    final contents = [
      'requestedPolicyVersion=$requestedPolicyVersion',
    ].join(',');
    return 'GetPolicyOptions($contents)';
  }
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members`, or principals, to a single `role`. Principals can be user
/// accounts, service accounts, Google groups, and domains (such as G Suite). A
/// `role` is a named list of permissions; each `role` can be an IAM predefined
/// role or a user-created custom role.
///
/// For some types of Google Cloud resources, a `binding` can also specify a
/// `condition`, which is a logical expression that allows access to a resource
/// only if the expression evaluates to `true`. A condition can add constraints
/// based on attributes of the request, the resource, or both. To learn which
/// resources support conditions in their IAM policies, see the
/// [IAM
/// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
///
/// **JSON example:**
///
/// ```
///     {
///       "bindings": [
///         {
///           "role": "roles/resourcemanager.organizationAdmin",
///           "members": [
///             "user:mike@example.com",
///             "group:admins@example.com",
///             "domain:google.com",
///             "serviceAccount:my-project-id@appspot.gserviceaccount.com"
///           ]
///         },
///         {
///           "role": "roles/resourcemanager.organizationViewer",
///           "members": [
///             "user:eve@example.com"
///           ],
///           "condition": {
///             "title": "expirable access",
///             "description": "Does not grant access after Sep 2020",
///             "expression": "request.time <
///             timestamp('2020-10-01T00:00:00.000Z')",
///           }
///         }
///       ],
///       "etag": "BwWWja0YfJA=",
///       "version": 3
///     }
/// ```
///
/// **YAML example:**
///
/// ```
///     bindings:
///     - members:
///       - user:mike@example.com
///       - group:admins@example.com
///       - domain:google.com
///       - serviceAccount:my-project-id@appspot.gserviceaccount.com
///       role: roles/resourcemanager.organizationAdmin
///     - members:
///       - user:eve@example.com
///       role: roles/resourcemanager.organizationViewer
///       condition:
///         title: expirable access
///         description: Does not grant access after Sep 2020
///         expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
///     etag: BwWWja0YfJA=
///     version: 3
/// ```
///
/// For a description of IAM and its features, see the
/// [IAM documentation](https://cloud.google.com/iam/docs/).
final class Policy extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.Policy';

  /// Specifies the format of the policy.
  ///
  /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
  /// are rejected.
  ///
  /// Any operation that affects conditional role bindings must specify version
  /// `3`. This requirement applies to the following operations:
  ///
  /// * Getting a policy that includes a conditional role binding
  /// * Adding a conditional role binding to a policy
  /// * Changing a conditional role binding in a policy
  /// * Removing any role binding, with or without a condition, from a policy
  ///   that includes conditions
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag` field
  /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
  /// you to overwrite a version `3` policy with a version `1` policy, and all of
  /// the conditions in the version `3` policy are lost.
  ///
  /// If a policy does not include any conditions, operations on that policy may
  /// specify any valid version or leave the field unset.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  final int version;

  /// Associates a list of `members`, or principals, with a `role`. Optionally,
  /// may specify a `condition` that determines how and when the `bindings` are
  /// applied. Each of the `bindings` must contain at least one principal.
  ///
  /// The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
  /// of these principals can be Google groups. Each occurrence of a principal
  /// counts towards these limits. For example, if the `bindings` grant 50
  /// different roles to `user:alice@example.com`, and not to any other
  /// principal, then you can add another 1,450 principals to the `bindings` in
  /// the `Policy`.
  final List<Binding> bindings;

  /// Specifies cloud audit logging configuration for this policy.
  final List<AuditConfig> auditConfigs;

  /// `etag` is used for optimistic concurrency control as a way to help
  /// prevent simultaneous updates of a policy from overwriting each other.
  /// It is strongly suggested that systems make use of the `etag` in the
  /// read-modify-write cycle to perform policy updates in order to avoid race
  /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
  /// systems are expected to put that etag in the request to `setIamPolicy` to
  /// ensure that their change will be applied to the same version of the policy.
  ///
  /// **Important:** If you use IAM Conditions, you must include the `etag` field
  /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
  /// you to overwrite a version `3` policy with a version `1` policy, and all of
  /// the conditions in the version `3` policy are lost.
  final Uint8List etag;

  Policy({
    this.version = 0,
    this.bindings = const [],
    this.auditConfigs = const [],
    Uint8List? etag,
  }) : etag = etag ?? Uint8List(0),
       super(fullyQualifiedName);

  factory Policy.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Policy(
      version: switch (json['version']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      bindings: switch (json['bindings']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) Binding.fromJson(i)],
        _ => throw const FormatException('"bindings" is not a list'),
      },
      auditConfigs: switch (json['auditConfigs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) AuditConfig.fromJson(i)],
        _ => throw const FormatException('"auditConfigs" is not a list'),
      },
      etag: switch (json['etag']) {
        null => Uint8List(0),
        Object $1 => decodeBytes($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (version.isNotDefault) 'version': version,
    if (bindings.isNotDefault) 'bindings': encodeList(bindings),
    if (auditConfigs.isNotDefault) 'auditConfigs': encodeList(auditConfigs),
    if (etag.isNotDefault) 'etag': encodeBytes(etag),
  };

  @override
  String toString() {
    final contents = ['version=$version', 'etag=$etag'].join(',');
    return 'Policy($contents)';
  }
}

/// Associates `members`, or principals, with a `role`.
final class Binding extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.Binding';

  /// Role that is assigned to the list of `members`, or principals.
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  final String role;

  /// Specifies the principals requesting access for a Google Cloud resource.
  /// `members` can have the following values:
  ///
  /// * `allUsers`: A special identifier that represents anyone who is
  ///    on the internet; with or without a Google account.
  ///
  /// * `allAuthenticatedUsers`: A special identifier that represents anyone
  ///    who is authenticated with a Google account or a service account.
  ///
  /// * `user:{emailid}`: An email address that represents a specific Google
  ///    account. For example, `alice@example.com` .
  ///
  ///
  /// * `serviceAccount:{emailid}`: An email address that represents a service
  ///    account. For example, `my-other-app@appspot.gserviceaccount.com`.
  ///
  /// * `group:{emailid}`: An email address that represents a Google group.
  ///    For example, `admins@example.com`.
  ///
  /// * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
  ///    identifier) representing a user that has been recently deleted. For
  ///    example, `alice@example.com?uid=123456789012345678901`. If the user is
  ///    recovered, this value reverts to `user:{emailid}` and the recovered user
  ///    retains the role in the binding.
  ///
  /// * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
  ///    unique identifier) representing a service account that has been recently
  ///    deleted. For example,
  ///    `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.
  ///    If the service account is undeleted, this value reverts to
  ///    `serviceAccount:{emailid}` and the undeleted service account retains the
  ///    role in the binding.
  ///
  /// * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
  ///    identifier) representing a Google group that has been recently
  ///    deleted. For example, `admins@example.com?uid=123456789012345678901`. If
  ///    the group is recovered, this value reverts to `group:{emailid}` and the
  ///    recovered group retains the role in the binding.
  ///
  ///
  /// * `domain:{domain}`: The G Suite domain (primary) that represents all the
  ///    users of that domain. For example, `google.com` or `example.com`.
  final List<String> members;

  /// The condition that is associated with this binding.
  ///
  /// If the condition evaluates to `true`, then this binding applies to the
  /// current request.
  ///
  /// If the condition evaluates to `false`, then this binding does not apply to
  /// the current request. However, a different role binding might grant the same
  /// role to one or more of the principals in this binding.
  ///
  /// To learn which resources support conditions in their IAM policies, see the
  /// [IAM
  /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
  final Expr? condition;

  Binding({this.role = '', this.members = const [], this.condition})
    : super(fullyQualifiedName);

  factory Binding.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return Binding(
      role: switch (json['role']) {
        null => '',
        Object $1 => decodeString($1),
      },
      members: switch (json['members']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"members" is not a list'),
      },
      condition: switch (json['condition']) {
        null => null,
        Object $1 => Expr.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (role.isNotDefault) 'role': role,
    if (members.isNotDefault) 'members': members,
    if (condition != null) 'condition': condition!.toJson(),
  };

  @override
  String toString() {
    final contents = ['role=$role'].join(',');
    return 'Binding($contents)';
  }
}

/// Specifies the audit configuration for a service.
/// The configuration determines which permission types are logged, and what
/// identities, if any, are exempted from logging.
/// An AuditConfig must have one or more AuditLogConfigs.
///
/// If there are AuditConfigs for both `allServices` and a specific service,
/// the union of the two AuditConfigs is used for that service: the log_types
/// specified in each AuditConfig are enabled, and the exempted_members in each
/// AuditLogConfig are exempted.
///
/// Example Policy with multiple AuditConfigs:
///
///     {
///       "audit_configs": [
///         {
///           "service": "allServices",
///           "audit_log_configs": [
///             {
///               "log_type": "DATA_READ",
///               "exempted_members": [
///                 "user:jose@example.com"
///               ]
///             },
///             {
///               "log_type": "DATA_WRITE"
///             },
///             {
///               "log_type": "ADMIN_READ"
///             }
///           ]
///         },
///         {
///           "service": "sampleservice.googleapis.com",
///           "audit_log_configs": [
///             {
///               "log_type": "DATA_READ"
///             },
///             {
///               "log_type": "DATA_WRITE",
///               "exempted_members": [
///                 "user:aliya@example.com"
///               ]
///             }
///           ]
///         }
///       ]
///     }
///
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts `jose@example.com` from DATA_READ logging, and
/// `aliya@example.com` from DATA_WRITE logging.
final class AuditConfig extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.AuditConfig';

  /// Specifies a service that will be enabled for audit logging.
  /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
  /// `allServices` is a special value that covers all services.
  final String service;

  /// The configuration for logging of each type of permission.
  final List<AuditLogConfig> auditLogConfigs;

  AuditConfig({this.service = '', this.auditLogConfigs = const []})
    : super(fullyQualifiedName);

  factory AuditConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuditConfig(
      service: switch (json['service']) {
        null => '',
        Object $1 => decodeString($1),
      },
      auditLogConfigs: switch (json['auditLogConfigs']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) AuditLogConfig.fromJson(i)],
        _ => throw const FormatException('"auditLogConfigs" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (service.isNotDefault) 'service': service,
    if (auditLogConfigs.isNotDefault)
      'auditLogConfigs': encodeList(auditLogConfigs),
  };

  @override
  String toString() {
    final contents = ['service=$service'].join(',');
    return 'AuditConfig($contents)';
  }
}

/// Provides the configuration for logging a type of permissions.
/// Example:
///
///     {
///       "audit_log_configs": [
///         {
///           "log_type": "DATA_READ",
///           "exempted_members": [
///             "user:jose@example.com"
///           ]
///         },
///         {
///           "log_type": "DATA_WRITE"
///         }
///       ]
///     }
///
/// This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
/// jose@example.com from DATA_READ logging.
final class AuditLogConfig extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.AuditLogConfig';

  /// The log type that this config enables.
  final AuditLogConfig_LogType logType;

  /// Specifies the identities that do not cause logging for this type of
  /// permission.
  /// Follows the same format of
  /// `Binding.members`.
  final List<String> exemptedMembers;

  AuditLogConfig({
    this.logType = AuditLogConfig_LogType.$default,
    this.exemptedMembers = const [],
  }) : super(fullyQualifiedName);

  factory AuditLogConfig.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuditLogConfig(
      logType: switch (json['logType']) {
        null => AuditLogConfig_LogType.$default,
        Object $1 => AuditLogConfig_LogType.fromJson($1),
      },
      exemptedMembers: switch (json['exemptedMembers']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) decodeString(i)],
        _ => throw const FormatException('"exemptedMembers" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (logType.isNotDefault) 'logType': logType.toJson(),
    if (exemptedMembers.isNotDefault) 'exemptedMembers': exemptedMembers,
  };

  @override
  String toString() {
    final contents = ['logType=$logType'].join(',');
    return 'AuditLogConfig($contents)';
  }
}

/// The list of valid permission types for which logging can be configured.
/// Admin writes are always logged, and are not configurable.
final class AuditLogConfig_LogType extends ProtoEnum {
  /// Default case. Should never be this.
  static const logTypeUnspecified = AuditLogConfig_LogType(
    'LOG_TYPE_UNSPECIFIED',
  );

  /// Admin reads. Example: CloudIAM getIamPolicy
  static const adminRead = AuditLogConfig_LogType('ADMIN_READ');

  /// Data writes. Example: CloudSQL Users create
  static const dataWrite = AuditLogConfig_LogType('DATA_WRITE');

  /// Data reads. Example: CloudSQL Users list
  static const dataRead = AuditLogConfig_LogType('DATA_READ');

  /// The default value for [AuditLogConfig_LogType].
  static const $default = logTypeUnspecified;

  const AuditLogConfig_LogType(super.value);

  factory AuditLogConfig_LogType.fromJson(Object? json) =>
      AuditLogConfig_LogType(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'LogType.$value';
}

/// The difference delta between two policies.
final class PolicyDelta extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.PolicyDelta';

  /// The delta for Bindings between two policies.
  final List<BindingDelta> bindingDeltas;

  /// The delta for AuditConfigs between two policies.
  final List<AuditConfigDelta> auditConfigDeltas;

  PolicyDelta({
    this.bindingDeltas = const [],
    this.auditConfigDeltas = const [],
  }) : super(fullyQualifiedName);

  factory PolicyDelta.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return PolicyDelta(
      bindingDeltas: switch (json['bindingDeltas']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) BindingDelta.fromJson(i)],
        _ => throw const FormatException('"bindingDeltas" is not a list'),
      },
      auditConfigDeltas: switch (json['auditConfigDeltas']) {
        null => [],
        List<Object?> $1 => [for (final i in $1) AuditConfigDelta.fromJson(i)],
        _ => throw const FormatException('"auditConfigDeltas" is not a list'),
      },
    );
  }

  @override
  Object toJson() => {
    if (bindingDeltas.isNotDefault) 'bindingDeltas': encodeList(bindingDeltas),
    if (auditConfigDeltas.isNotDefault)
      'auditConfigDeltas': encodeList(auditConfigDeltas),
  };

  @override
  String toString() => 'PolicyDelta()';
}

/// One delta entry for Binding. Each individual change (only one member in each
/// entry) to a binding will be a separate entry.
final class BindingDelta extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.BindingDelta';

  /// The action that was performed on a Binding.
  /// Required
  final BindingDelta_Action action;

  /// Role that is assigned to `members`.
  /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
  /// Required
  final String role;

  /// A single identity requesting access for a Google Cloud resource.
  /// Follows the same format of Binding.members.
  /// Required
  final String member;

  /// The condition that is associated with this binding.
  final Expr? condition;

  BindingDelta({
    this.action = BindingDelta_Action.$default,
    this.role = '',
    this.member = '',
    this.condition,
  }) : super(fullyQualifiedName);

  factory BindingDelta.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return BindingDelta(
      action: switch (json['action']) {
        null => BindingDelta_Action.$default,
        Object $1 => BindingDelta_Action.fromJson($1),
      },
      role: switch (json['role']) {
        null => '',
        Object $1 => decodeString($1),
      },
      member: switch (json['member']) {
        null => '',
        Object $1 => decodeString($1),
      },
      condition: switch (json['condition']) {
        null => null,
        Object $1 => Expr.fromJson($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (action.isNotDefault) 'action': action.toJson(),
    if (role.isNotDefault) 'role': role,
    if (member.isNotDefault) 'member': member,
    if (condition != null) 'condition': condition!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'action=$action',
      'role=$role',
      'member=$member',
    ].join(',');
    return 'BindingDelta($contents)';
  }
}

/// The type of action performed on a Binding in a policy.
final class BindingDelta_Action extends ProtoEnum {
  /// Unspecified.
  static const actionUnspecified = BindingDelta_Action('ACTION_UNSPECIFIED');

  /// Addition of a Binding.
  static const add = BindingDelta_Action('ADD');

  /// Removal of a Binding.
  static const remove = BindingDelta_Action('REMOVE');

  /// The default value for [BindingDelta_Action].
  static const $default = actionUnspecified;

  const BindingDelta_Action(super.value);

  factory BindingDelta_Action.fromJson(Object? json) =>
      BindingDelta_Action(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Action.$value';
}

/// One delta entry for AuditConfig. Each individual change (only one
/// exempted_member in each entry) to a AuditConfig will be a separate entry.
final class AuditConfigDelta extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.AuditConfigDelta';

  /// The action that was performed on an audit configuration in a policy.
  /// Required
  final AuditConfigDelta_Action action;

  /// Specifies a service that was configured for Cloud Audit Logging.
  /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
  /// `allServices` is a special value that covers all services.
  /// Required
  final String service;

  /// A single identity that is exempted from "data access" audit
  /// logging for the `service` specified above.
  /// Follows the same format of Binding.members.
  final String exemptedMember;

  /// Specifies the log_type that was be enabled. ADMIN_ACTIVITY is always
  /// enabled, and cannot be configured.
  /// Required
  final String logType;

  AuditConfigDelta({
    this.action = AuditConfigDelta_Action.$default,
    this.service = '',
    this.exemptedMember = '',
    this.logType = '',
  }) : super(fullyQualifiedName);

  factory AuditConfigDelta.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return AuditConfigDelta(
      action: switch (json['action']) {
        null => AuditConfigDelta_Action.$default,
        Object $1 => AuditConfigDelta_Action.fromJson($1),
      },
      service: switch (json['service']) {
        null => '',
        Object $1 => decodeString($1),
      },
      exemptedMember: switch (json['exemptedMember']) {
        null => '',
        Object $1 => decodeString($1),
      },
      logType: switch (json['logType']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (action.isNotDefault) 'action': action.toJson(),
    if (service.isNotDefault) 'service': service,
    if (exemptedMember.isNotDefault) 'exemptedMember': exemptedMember,
    if (logType.isNotDefault) 'logType': logType,
  };

  @override
  String toString() {
    final contents = [
      'action=$action',
      'service=$service',
      'exemptedMember=$exemptedMember',
      'logType=$logType',
    ].join(',');
    return 'AuditConfigDelta($contents)';
  }
}

/// The type of action performed on an audit configuration in a policy.
final class AuditConfigDelta_Action extends ProtoEnum {
  /// Unspecified.
  static const actionUnspecified = AuditConfigDelta_Action(
    'ACTION_UNSPECIFIED',
  );

  /// Addition of an audit configuration.
  static const add = AuditConfigDelta_Action('ADD');

  /// Removal of an audit configuration.
  static const remove = AuditConfigDelta_Action('REMOVE');

  /// The default value for [AuditConfigDelta_Action].
  static const $default = actionUnspecified;

  const AuditConfigDelta_Action(super.value);

  factory AuditConfigDelta_Action.fromJson(Object? json) =>
      AuditConfigDelta_Action(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Action.$value';
}

/// Output-only policy member strings of a Google Cloud resource's built-in
/// identity.
final class ResourcePolicyMember extends ProtoMessage {
  static const String fullyQualifiedName = 'google.iam.v1.ResourcePolicyMember';

  /// IAM policy binding member referring to a Google Cloud resource by
  /// user-assigned name (https://google.aip.dev/122). If a resource is deleted
  /// and recreated with the same name, the binding will be applicable to the new
  /// resource.
  ///
  /// Example:
  /// `principal://parametermanager.googleapis.com/projects/12345/name/locations/us-central1-a/parameters/my-parameter`
  final String iamPolicyNamePrincipal;

  /// IAM policy binding member referring to a Google Cloud resource by
  /// system-assigned unique identifier (https://google.aip.dev/148#uid). If a
  /// resource is deleted and recreated with the same name, the binding will not
  /// be applicable to the new resource
  ///
  /// Example:
  /// `principal://parametermanager.googleapis.com/projects/12345/uid/locations/us-central1-a/parameters/a918fed5`
  final String iamPolicyUidPrincipal;

  ResourcePolicyMember({
    this.iamPolicyNamePrincipal = '',
    this.iamPolicyUidPrincipal = '',
  }) : super(fullyQualifiedName);

  factory ResourcePolicyMember.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return ResourcePolicyMember(
      iamPolicyNamePrincipal: switch (json['iamPolicyNamePrincipal']) {
        null => '',
        Object $1 => decodeString($1),
      },
      iamPolicyUidPrincipal: switch (json['iamPolicyUidPrincipal']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (iamPolicyNamePrincipal.isNotDefault)
      'iamPolicyNamePrincipal': iamPolicyNamePrincipal,
    if (iamPolicyUidPrincipal.isNotDefault)
      'iamPolicyUidPrincipal': iamPolicyUidPrincipal,
  };

  @override
  String toString() {
    final contents = [
      'iamPolicyNamePrincipal=$iamPolicyNamePrincipal',
      'iamPolicyUidPrincipal=$iamPolicyUidPrincipal',
    ].join(',');
    return 'ResourcePolicyMember($contents)';
  }
}
