// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Client Libraries Showcase API.
///
/// Showcase represents both a model API and an integration testing surface for
/// client library generator consumption.
library;

// ignore_for_file: argument_type_not_assignable
// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_iam_v1/iam.dart';
import 'package:google_cloud_location/location.dart';
import 'package:google_cloud_longrunning/longrunning.dart';
import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';
import 'package:google_cloud_rpc/rpc.dart';
import 'package:google_cloud_rpc/service_client.dart';
import 'package:http/http.dart' as http;

const _apiKeys = ['GOOGLE_API_KEY'];

/// This service is used to test that GAPICs implement various REST-related features correctly. This mostly means transcoding proto3 requests to REST format
/// correctly for various types of HTTP annotations, but it also includes verifying that unknown (numeric) enums received by clients can be round-tripped
/// correctly.
final class Compliance {
  static const _host = 'localhost:7469';

  final ServiceClient _client;

  /// Creates a `Compliance` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `Compliance`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  Compliance({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `Compliance` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory Compliance.fromApiKey([String? apiKey]) =>
      Compliance(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// This method echoes the ComplianceData request. This method exercises
  /// sending the entire request object in the REST body.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RepeatResponse> repeatDataBody(RepeatRequest request) async {
    final url = Uri.https(_host, '/v1beta1/repeat:body');
    final response = await _client.post(url, body: request);
    return RepeatResponse.fromJson(response);
  }

  /// This method echoes the ComplianceData request. This method exercises
  /// sending the a message-type field in the REST body. Per AIP-127, only
  /// top-level, non-repeated fields can be sent this way.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RepeatResponse> repeatDataBodyInfo(RepeatRequest request) async {
    final url = Uri.https(_host, '/v1beta1/repeat:bodyinfo', {
      if (request.name case final $1 when $1.isNotDefault) 'name': $1,
      if (request.serverVerify case final $1 when $1.isNotDefault)
        'serverVerify': '${$1}',
      if (request.intendedBindingUri case final $1?) 'intendedBindingUri': $1,
      if (request.fInt32 case final $1 when $1.isNotDefault) 'fInt32': '${$1}',
      if (request.fInt64 case final $1 when $1.isNotDefault) 'fInt64': '${$1}',
      if (request.fDouble case final $1 when $1.isNotDefault)
        'fDouble': '${$1}',
      if (request.pInt32 case final $1?) 'pInt32': '${$1}',
      if (request.pInt64 case final $1?) 'pInt64': '${$1}',
      if (request.pDouble case final $1?) 'pDouble': '${$1}',
    });
    final response = await _client.post(url, body: request.info);
    return RepeatResponse.fromJson(response);
  }

  /// This method echoes the ComplianceData request. This method exercises
  /// sending all request fields as query parameters.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RepeatResponse> repeatDataQuery(RepeatRequest request) async {
    final url = Uri.https(_host, '/v1beta1/repeat:query', {
      if (request.name case final $1 when $1.isNotDefault) 'name': $1,
      if (request.info!.fString case final $1 when $1.isNotDefault)
        'info.fString': $1,
      if (request.info!.fInt32 case final $1 when $1.isNotDefault)
        'info.fInt32': '${$1}',
      if (request.info!.fSint32 case final $1 when $1.isNotDefault)
        'info.fSint32': '${$1}',
      if (request.info!.fSfixed32 case final $1 when $1.isNotDefault)
        'info.fSfixed32': '${$1}',
      if (request.info!.fUint32 case final $1 when $1.isNotDefault)
        'info.fUint32': '${$1}',
      if (request.info!.fFixed32 case final $1 when $1.isNotDefault)
        'info.fFixed32': '${$1}',
      if (request.info!.fInt64 case final $1 when $1.isNotDefault)
        'info.fInt64': '${$1}',
      if (request.info!.fSint64 case final $1 when $1.isNotDefault)
        'info.fSint64': '${$1}',
      if (request.info!.fSfixed64 case final $1 when $1.isNotDefault)
        'info.fSfixed64': '${$1}',
      if (request.info!.fUint64 case final $1 when $1.isNotDefault)
        'info.fUint64': '${$1}',
      if (request.info!.fFixed64 case final $1 when $1.isNotDefault)
        'info.fFixed64': '${$1}',
      if (request.info!.fDouble case final $1 when $1.isNotDefault)
        'info.fDouble': '${$1}',
      if (request.info!.fFloat case final $1 when $1.isNotDefault)
        'info.fFloat': '${$1}',
      if (request.info!.fBool case final $1 when $1.isNotDefault)
        'info.fBool': '${$1}',
      if (request.info!.fBytes case final $1 when $1.isNotDefault)
        'info.fBytes': encodeBytes($1)!,
      if (request.info!.fKingdom case final $1 when $1.isNotDefault)
        'info.fKingdom': $1.value,
      if (request.info!.fChild!.fString case final $1 when $1.isNotDefault)
        'info.fChild.fString': $1,
      if (request.info!.fChild!.fFloat case final $1 when $1.isNotDefault)
        'info.fChild.fFloat': '${$1}',
      if (request.info!.fChild!.fDouble case final $1 when $1.isNotDefault)
        'info.fChild.fDouble': '${$1}',
      if (request.info!.fChild!.fBool case final $1 when $1.isNotDefault)
        'info.fChild.fBool': '${$1}',
      if (request.info!.fChild!.fContinent case final $1 when $1.isNotDefault)
        'info.fChild.fContinent': $1.value,
      if (request.info!.fChild!.fChild!.fString case final $1
          when $1.isNotDefault)
        'info.fChild.fChild.fString': $1,
      if (request.info!.fChild!.fChild!.fDouble case final $1
          when $1.isNotDefault)
        'info.fChild.fChild.fDouble': '${$1}',
      if (request.info!.fChild!.fChild!.fBool case final $1
          when $1.isNotDefault)
        'info.fChild.fChild.fBool': '${$1}',
      if (request.info!.fChild!.pString case final $1?)
        'info.fChild.pString': $1,
      if (request.info!.fChild!.pFloat case final $1?)
        'info.fChild.pFloat': '${$1}',
      if (request.info!.fChild!.pDouble case final $1?)
        'info.fChild.pDouble': '${$1}',
      if (request.info!.fChild!.pBool case final $1?)
        'info.fChild.pBool': '${$1}',
      if (request.info!.fChild!.pContinent case final $1 when $1.isNotDefault)
        'info.fChild.pContinent': $1.value,
      if (request.info!.fChild!.pChild!.fString case final $1
          when $1.isNotDefault)
        'info.fChild.pChild.fString': $1,
      if (request.info!.fChild!.pChild!.fDouble case final $1
          when $1.isNotDefault)
        'info.fChild.pChild.fDouble': '${$1}',
      if (request.info!.fChild!.pChild!.fBool case final $1
          when $1.isNotDefault)
        'info.fChild.pChild.fBool': '${$1}',
      if (request.info!.pString case final $1?) 'info.pString': $1,
      if (request.info!.pInt32 case final $1?) 'info.pInt32': '${$1}',
      if (request.info!.pDouble case final $1?) 'info.pDouble': '${$1}',
      if (request.info!.pBool case final $1?) 'info.pBool': '${$1}',
      if (request.info!.pKingdom case final $1?) 'info.pKingdom': $1.value,
      if (request.info!.pChild!.fString case final $1 when $1.isNotDefault)
        'info.pChild.fString': $1,
      if (request.info!.pChild!.fFloat case final $1 when $1.isNotDefault)
        'info.pChild.fFloat': '${$1}',
      if (request.info!.pChild!.fDouble case final $1 when $1.isNotDefault)
        'info.pChild.fDouble': '${$1}',
      if (request.info!.pChild!.fBool case final $1 when $1.isNotDefault)
        'info.pChild.fBool': '${$1}',
      if (request.info!.pChild!.fContinent case final $1 when $1.isNotDefault)
        'info.pChild.fContinent': $1.value,
      if (request.info!.pChild!.fChild!.fString case final $1
          when $1.isNotDefault)
        'info.pChild.fChild.fString': $1,
      if (request.info!.pChild!.fChild!.fDouble case final $1
          when $1.isNotDefault)
        'info.pChild.fChild.fDouble': '${$1}',
      if (request.info!.pChild!.fChild!.fBool case final $1
          when $1.isNotDefault)
        'info.pChild.fChild.fBool': '${$1}',
      if (request.info!.pChild!.pString case final $1?)
        'info.pChild.pString': $1,
      if (request.info!.pChild!.pFloat case final $1?)
        'info.pChild.pFloat': '${$1}',
      if (request.info!.pChild!.pDouble case final $1?)
        'info.pChild.pDouble': '${$1}',
      if (request.info!.pChild!.pBool case final $1?)
        'info.pChild.pBool': '${$1}',
      if (request.info!.pChild!.pContinent case final $1 when $1.isNotDefault)
        'info.pChild.pContinent': $1.value,
      if (request.info!.pChild!.pChild!.fString case final $1
          when $1.isNotDefault)
        'info.pChild.pChild.fString': $1,
      if (request.info!.pChild!.pChild!.fDouble case final $1
          when $1.isNotDefault)
        'info.pChild.pChild.fDouble': '${$1}',
      if (request.info!.pChild!.pChild!.fBool case final $1
          when $1.isNotDefault)
        'info.pChild.pChild.fBool': '${$1}',
      if (request.serverVerify case final $1 when $1.isNotDefault)
        'serverVerify': '${$1}',
      if (request.intendedBindingUri case final $1?) 'intendedBindingUri': $1,
      if (request.fInt32 case final $1 when $1.isNotDefault) 'fInt32': '${$1}',
      if (request.fInt64 case final $1 when $1.isNotDefault) 'fInt64': '${$1}',
      if (request.fDouble case final $1 when $1.isNotDefault)
        'fDouble': '${$1}',
      if (request.pInt32 case final $1?) 'pInt32': '${$1}',
      if (request.pInt64 case final $1?) 'pInt64': '${$1}',
      if (request.pDouble case final $1?) 'pDouble': '${$1}',
    });
    final response = await _client.get(url);
    return RepeatResponse.fromJson(response);
  }

  /// This method echoes the ComplianceData request. This method exercises
  /// sending some parameters as "simple" path variables (i.e., of the form
  /// "/bar/{foo}" rather than "/{foo=bar/*}"), and the rest as query parameters.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RepeatResponse> repeatDataSimplePath(RepeatRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/repeat/${request.info!.fString}/${request.info!.fInt32}/${request.info!.fDouble}/${request.info!.fBool}/${request.info!.fKingdom}:simplepath',
      {
        if (request.name case final $1 when $1.isNotDefault) 'name': $1,
        if (request.info!.fString case final $1 when $1.isNotDefault)
          'info.fString': $1,
        if (request.info!.fInt32 case final $1 when $1.isNotDefault)
          'info.fInt32': '${$1}',
        if (request.info!.fSint32 case final $1 when $1.isNotDefault)
          'info.fSint32': '${$1}',
        if (request.info!.fSfixed32 case final $1 when $1.isNotDefault)
          'info.fSfixed32': '${$1}',
        if (request.info!.fUint32 case final $1 when $1.isNotDefault)
          'info.fUint32': '${$1}',
        if (request.info!.fFixed32 case final $1 when $1.isNotDefault)
          'info.fFixed32': '${$1}',
        if (request.info!.fInt64 case final $1 when $1.isNotDefault)
          'info.fInt64': '${$1}',
        if (request.info!.fSint64 case final $1 when $1.isNotDefault)
          'info.fSint64': '${$1}',
        if (request.info!.fSfixed64 case final $1 when $1.isNotDefault)
          'info.fSfixed64': '${$1}',
        if (request.info!.fUint64 case final $1 when $1.isNotDefault)
          'info.fUint64': '${$1}',
        if (request.info!.fFixed64 case final $1 when $1.isNotDefault)
          'info.fFixed64': '${$1}',
        if (request.info!.fDouble case final $1 when $1.isNotDefault)
          'info.fDouble': '${$1}',
        if (request.info!.fFloat case final $1 when $1.isNotDefault)
          'info.fFloat': '${$1}',
        if (request.info!.fBool case final $1 when $1.isNotDefault)
          'info.fBool': '${$1}',
        if (request.info!.fBytes case final $1 when $1.isNotDefault)
          'info.fBytes': encodeBytes($1)!,
        if (request.info!.fKingdom case final $1 when $1.isNotDefault)
          'info.fKingdom': $1.value,
        if (request.info!.fChild!.fString case final $1 when $1.isNotDefault)
          'info.fChild.fString': $1,
        if (request.info!.fChild!.fFloat case final $1 when $1.isNotDefault)
          'info.fChild.fFloat': '${$1}',
        if (request.info!.fChild!.fDouble case final $1 when $1.isNotDefault)
          'info.fChild.fDouble': '${$1}',
        if (request.info!.fChild!.fBool case final $1 when $1.isNotDefault)
          'info.fChild.fBool': '${$1}',
        if (request.info!.fChild!.fContinent case final $1 when $1.isNotDefault)
          'info.fChild.fContinent': $1.value,
        if (request.info!.fChild!.fChild!.fString case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fString': $1,
        if (request.info!.fChild!.fChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fDouble': '${$1}',
        if (request.info!.fChild!.fChild!.fBool case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fBool': '${$1}',
        if (request.info!.fChild!.pString case final $1?)
          'info.fChild.pString': $1,
        if (request.info!.fChild!.pFloat case final $1?)
          'info.fChild.pFloat': '${$1}',
        if (request.info!.fChild!.pDouble case final $1?)
          'info.fChild.pDouble': '${$1}',
        if (request.info!.fChild!.pBool case final $1?)
          'info.fChild.pBool': '${$1}',
        if (request.info!.fChild!.pContinent case final $1 when $1.isNotDefault)
          'info.fChild.pContinent': $1.value,
        if (request.info!.fChild!.pChild!.fString case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fString': $1,
        if (request.info!.fChild!.pChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fDouble': '${$1}',
        if (request.info!.fChild!.pChild!.fBool case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fBool': '${$1}',
        if (request.info!.pString case final $1?) 'info.pString': $1,
        if (request.info!.pInt32 case final $1?) 'info.pInt32': '${$1}',
        if (request.info!.pDouble case final $1?) 'info.pDouble': '${$1}',
        if (request.info!.pBool case final $1?) 'info.pBool': '${$1}',
        if (request.info!.pKingdom case final $1?) 'info.pKingdom': $1.value,
        if (request.info!.pChild!.fString case final $1 when $1.isNotDefault)
          'info.pChild.fString': $1,
        if (request.info!.pChild!.fFloat case final $1 when $1.isNotDefault)
          'info.pChild.fFloat': '${$1}',
        if (request.info!.pChild!.fDouble case final $1 when $1.isNotDefault)
          'info.pChild.fDouble': '${$1}',
        if (request.info!.pChild!.fBool case final $1 when $1.isNotDefault)
          'info.pChild.fBool': '${$1}',
        if (request.info!.pChild!.fContinent case final $1 when $1.isNotDefault)
          'info.pChild.fContinent': $1.value,
        if (request.info!.pChild!.fChild!.fString case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fString': $1,
        if (request.info!.pChild!.fChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fDouble': '${$1}',
        if (request.info!.pChild!.fChild!.fBool case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fBool': '${$1}',
        if (request.info!.pChild!.pString case final $1?)
          'info.pChild.pString': $1,
        if (request.info!.pChild!.pFloat case final $1?)
          'info.pChild.pFloat': '${$1}',
        if (request.info!.pChild!.pDouble case final $1?)
          'info.pChild.pDouble': '${$1}',
        if (request.info!.pChild!.pBool case final $1?)
          'info.pChild.pBool': '${$1}',
        if (request.info!.pChild!.pContinent case final $1 when $1.isNotDefault)
          'info.pChild.pContinent': $1.value,
        if (request.info!.pChild!.pChild!.fString case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fString': $1,
        if (request.info!.pChild!.pChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fDouble': '${$1}',
        if (request.info!.pChild!.pChild!.fBool case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fBool': '${$1}',
        if (request.serverVerify case final $1 when $1.isNotDefault)
          'serverVerify': '${$1}',
        if (request.intendedBindingUri case final $1?) 'intendedBindingUri': $1,
        if (request.fInt32 case final $1 when $1.isNotDefault)
          'fInt32': '${$1}',
        if (request.fInt64 case final $1 when $1.isNotDefault)
          'fInt64': '${$1}',
        if (request.fDouble case final $1 when $1.isNotDefault)
          'fDouble': '${$1}',
        if (request.pInt32 case final $1?) 'pInt32': '${$1}',
        if (request.pInt64 case final $1?) 'pInt64': '${$1}',
        if (request.pDouble case final $1?) 'pDouble': '${$1}',
      },
    );
    final response = await _client.get(url);
    return RepeatResponse.fromJson(response);
  }

  /// Same as RepeatDataSimplePath, but with a path resource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RepeatResponse> repeatDataPathResource(RepeatRequest request) async {
    final url = Uri.https(
      _host,
      '/v1beta1/repeat/${request.info!.fString}/${request.info!.fChild!.fString}/bool/${request.info!.fBool}:pathresource',
      {
        if (request.name case final $1 when $1.isNotDefault) 'name': $1,
        if (request.info!.fString case final $1 when $1.isNotDefault)
          'info.fString': $1,
        if (request.info!.fInt32 case final $1 when $1.isNotDefault)
          'info.fInt32': '${$1}',
        if (request.info!.fSint32 case final $1 when $1.isNotDefault)
          'info.fSint32': '${$1}',
        if (request.info!.fSfixed32 case final $1 when $1.isNotDefault)
          'info.fSfixed32': '${$1}',
        if (request.info!.fUint32 case final $1 when $1.isNotDefault)
          'info.fUint32': '${$1}',
        if (request.info!.fFixed32 case final $1 when $1.isNotDefault)
          'info.fFixed32': '${$1}',
        if (request.info!.fInt64 case final $1 when $1.isNotDefault)
          'info.fInt64': '${$1}',
        if (request.info!.fSint64 case final $1 when $1.isNotDefault)
          'info.fSint64': '${$1}',
        if (request.info!.fSfixed64 case final $1 when $1.isNotDefault)
          'info.fSfixed64': '${$1}',
        if (request.info!.fUint64 case final $1 when $1.isNotDefault)
          'info.fUint64': '${$1}',
        if (request.info!.fFixed64 case final $1 when $1.isNotDefault)
          'info.fFixed64': '${$1}',
        if (request.info!.fDouble case final $1 when $1.isNotDefault)
          'info.fDouble': '${$1}',
        if (request.info!.fFloat case final $1 when $1.isNotDefault)
          'info.fFloat': '${$1}',
        if (request.info!.fBool case final $1 when $1.isNotDefault)
          'info.fBool': '${$1}',
        if (request.info!.fBytes case final $1 when $1.isNotDefault)
          'info.fBytes': encodeBytes($1)!,
        if (request.info!.fKingdom case final $1 when $1.isNotDefault)
          'info.fKingdom': $1.value,
        if (request.info!.fChild!.fString case final $1 when $1.isNotDefault)
          'info.fChild.fString': $1,
        if (request.info!.fChild!.fFloat case final $1 when $1.isNotDefault)
          'info.fChild.fFloat': '${$1}',
        if (request.info!.fChild!.fDouble case final $1 when $1.isNotDefault)
          'info.fChild.fDouble': '${$1}',
        if (request.info!.fChild!.fBool case final $1 when $1.isNotDefault)
          'info.fChild.fBool': '${$1}',
        if (request.info!.fChild!.fContinent case final $1 when $1.isNotDefault)
          'info.fChild.fContinent': $1.value,
        if (request.info!.fChild!.fChild!.fString case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fString': $1,
        if (request.info!.fChild!.fChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fDouble': '${$1}',
        if (request.info!.fChild!.fChild!.fBool case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fBool': '${$1}',
        if (request.info!.fChild!.pString case final $1?)
          'info.fChild.pString': $1,
        if (request.info!.fChild!.pFloat case final $1?)
          'info.fChild.pFloat': '${$1}',
        if (request.info!.fChild!.pDouble case final $1?)
          'info.fChild.pDouble': '${$1}',
        if (request.info!.fChild!.pBool case final $1?)
          'info.fChild.pBool': '${$1}',
        if (request.info!.fChild!.pContinent case final $1 when $1.isNotDefault)
          'info.fChild.pContinent': $1.value,
        if (request.info!.fChild!.pChild!.fString case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fString': $1,
        if (request.info!.fChild!.pChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fDouble': '${$1}',
        if (request.info!.fChild!.pChild!.fBool case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fBool': '${$1}',
        if (request.info!.pString case final $1?) 'info.pString': $1,
        if (request.info!.pInt32 case final $1?) 'info.pInt32': '${$1}',
        if (request.info!.pDouble case final $1?) 'info.pDouble': '${$1}',
        if (request.info!.pBool case final $1?) 'info.pBool': '${$1}',
        if (request.info!.pKingdom case final $1?) 'info.pKingdom': $1.value,
        if (request.info!.pChild!.fString case final $1 when $1.isNotDefault)
          'info.pChild.fString': $1,
        if (request.info!.pChild!.fFloat case final $1 when $1.isNotDefault)
          'info.pChild.fFloat': '${$1}',
        if (request.info!.pChild!.fDouble case final $1 when $1.isNotDefault)
          'info.pChild.fDouble': '${$1}',
        if (request.info!.pChild!.fBool case final $1 when $1.isNotDefault)
          'info.pChild.fBool': '${$1}',
        if (request.info!.pChild!.fContinent case final $1 when $1.isNotDefault)
          'info.pChild.fContinent': $1.value,
        if (request.info!.pChild!.fChild!.fString case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fString': $1,
        if (request.info!.pChild!.fChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fDouble': '${$1}',
        if (request.info!.pChild!.fChild!.fBool case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fBool': '${$1}',
        if (request.info!.pChild!.pString case final $1?)
          'info.pChild.pString': $1,
        if (request.info!.pChild!.pFloat case final $1?)
          'info.pChild.pFloat': '${$1}',
        if (request.info!.pChild!.pDouble case final $1?)
          'info.pChild.pDouble': '${$1}',
        if (request.info!.pChild!.pBool case final $1?)
          'info.pChild.pBool': '${$1}',
        if (request.info!.pChild!.pContinent case final $1 when $1.isNotDefault)
          'info.pChild.pContinent': $1.value,
        if (request.info!.pChild!.pChild!.fString case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fString': $1,
        if (request.info!.pChild!.pChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fDouble': '${$1}',
        if (request.info!.pChild!.pChild!.fBool case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fBool': '${$1}',
        if (request.serverVerify case final $1 when $1.isNotDefault)
          'serverVerify': '${$1}',
        if (request.intendedBindingUri case final $1?) 'intendedBindingUri': $1,
        if (request.fInt32 case final $1 when $1.isNotDefault)
          'fInt32': '${$1}',
        if (request.fInt64 case final $1 when $1.isNotDefault)
          'fInt64': '${$1}',
        if (request.fDouble case final $1 when $1.isNotDefault)
          'fDouble': '${$1}',
        if (request.pInt32 case final $1?) 'pInt32': '${$1}',
        if (request.pInt64 case final $1?) 'pInt64': '${$1}',
        if (request.pDouble case final $1?) 'pDouble': '${$1}',
      },
    );
    final response = await _client.get(url);
    return RepeatResponse.fromJson(response);
  }

  /// Same as RepeatDataSimplePath, but with a trailing resource.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RepeatResponse> repeatDataPathTrailingResource(
    RepeatRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/repeat/${request.info!.fString}/${request.info!.fChild!.fString}:pathtrailingresource',
      {
        if (request.name case final $1 when $1.isNotDefault) 'name': $1,
        if (request.info!.fString case final $1 when $1.isNotDefault)
          'info.fString': $1,
        if (request.info!.fInt32 case final $1 when $1.isNotDefault)
          'info.fInt32': '${$1}',
        if (request.info!.fSint32 case final $1 when $1.isNotDefault)
          'info.fSint32': '${$1}',
        if (request.info!.fSfixed32 case final $1 when $1.isNotDefault)
          'info.fSfixed32': '${$1}',
        if (request.info!.fUint32 case final $1 when $1.isNotDefault)
          'info.fUint32': '${$1}',
        if (request.info!.fFixed32 case final $1 when $1.isNotDefault)
          'info.fFixed32': '${$1}',
        if (request.info!.fInt64 case final $1 when $1.isNotDefault)
          'info.fInt64': '${$1}',
        if (request.info!.fSint64 case final $1 when $1.isNotDefault)
          'info.fSint64': '${$1}',
        if (request.info!.fSfixed64 case final $1 when $1.isNotDefault)
          'info.fSfixed64': '${$1}',
        if (request.info!.fUint64 case final $1 when $1.isNotDefault)
          'info.fUint64': '${$1}',
        if (request.info!.fFixed64 case final $1 when $1.isNotDefault)
          'info.fFixed64': '${$1}',
        if (request.info!.fDouble case final $1 when $1.isNotDefault)
          'info.fDouble': '${$1}',
        if (request.info!.fFloat case final $1 when $1.isNotDefault)
          'info.fFloat': '${$1}',
        if (request.info!.fBool case final $1 when $1.isNotDefault)
          'info.fBool': '${$1}',
        if (request.info!.fBytes case final $1 when $1.isNotDefault)
          'info.fBytes': encodeBytes($1)!,
        if (request.info!.fKingdom case final $1 when $1.isNotDefault)
          'info.fKingdom': $1.value,
        if (request.info!.fChild!.fString case final $1 when $1.isNotDefault)
          'info.fChild.fString': $1,
        if (request.info!.fChild!.fFloat case final $1 when $1.isNotDefault)
          'info.fChild.fFloat': '${$1}',
        if (request.info!.fChild!.fDouble case final $1 when $1.isNotDefault)
          'info.fChild.fDouble': '${$1}',
        if (request.info!.fChild!.fBool case final $1 when $1.isNotDefault)
          'info.fChild.fBool': '${$1}',
        if (request.info!.fChild!.fContinent case final $1 when $1.isNotDefault)
          'info.fChild.fContinent': $1.value,
        if (request.info!.fChild!.fChild!.fString case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fString': $1,
        if (request.info!.fChild!.fChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fDouble': '${$1}',
        if (request.info!.fChild!.fChild!.fBool case final $1
            when $1.isNotDefault)
          'info.fChild.fChild.fBool': '${$1}',
        if (request.info!.fChild!.pString case final $1?)
          'info.fChild.pString': $1,
        if (request.info!.fChild!.pFloat case final $1?)
          'info.fChild.pFloat': '${$1}',
        if (request.info!.fChild!.pDouble case final $1?)
          'info.fChild.pDouble': '${$1}',
        if (request.info!.fChild!.pBool case final $1?)
          'info.fChild.pBool': '${$1}',
        if (request.info!.fChild!.pContinent case final $1 when $1.isNotDefault)
          'info.fChild.pContinent': $1.value,
        if (request.info!.fChild!.pChild!.fString case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fString': $1,
        if (request.info!.fChild!.pChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fDouble': '${$1}',
        if (request.info!.fChild!.pChild!.fBool case final $1
            when $1.isNotDefault)
          'info.fChild.pChild.fBool': '${$1}',
        if (request.info!.pString case final $1?) 'info.pString': $1,
        if (request.info!.pInt32 case final $1?) 'info.pInt32': '${$1}',
        if (request.info!.pDouble case final $1?) 'info.pDouble': '${$1}',
        if (request.info!.pBool case final $1?) 'info.pBool': '${$1}',
        if (request.info!.pKingdom case final $1?) 'info.pKingdom': $1.value,
        if (request.info!.pChild!.fString case final $1 when $1.isNotDefault)
          'info.pChild.fString': $1,
        if (request.info!.pChild!.fFloat case final $1 when $1.isNotDefault)
          'info.pChild.fFloat': '${$1}',
        if (request.info!.pChild!.fDouble case final $1 when $1.isNotDefault)
          'info.pChild.fDouble': '${$1}',
        if (request.info!.pChild!.fBool case final $1 when $1.isNotDefault)
          'info.pChild.fBool': '${$1}',
        if (request.info!.pChild!.fContinent case final $1 when $1.isNotDefault)
          'info.pChild.fContinent': $1.value,
        if (request.info!.pChild!.fChild!.fString case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fString': $1,
        if (request.info!.pChild!.fChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fDouble': '${$1}',
        if (request.info!.pChild!.fChild!.fBool case final $1
            when $1.isNotDefault)
          'info.pChild.fChild.fBool': '${$1}',
        if (request.info!.pChild!.pString case final $1?)
          'info.pChild.pString': $1,
        if (request.info!.pChild!.pFloat case final $1?)
          'info.pChild.pFloat': '${$1}',
        if (request.info!.pChild!.pDouble case final $1?)
          'info.pChild.pDouble': '${$1}',
        if (request.info!.pChild!.pBool case final $1?)
          'info.pChild.pBool': '${$1}',
        if (request.info!.pChild!.pContinent case final $1 when $1.isNotDefault)
          'info.pChild.pContinent': $1.value,
        if (request.info!.pChild!.pChild!.fString case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fString': $1,
        if (request.info!.pChild!.pChild!.fDouble case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fDouble': '${$1}',
        if (request.info!.pChild!.pChild!.fBool case final $1
            when $1.isNotDefault)
          'info.pChild.pChild.fBool': '${$1}',
        if (request.serverVerify case final $1 when $1.isNotDefault)
          'serverVerify': '${$1}',
        if (request.intendedBindingUri case final $1?) 'intendedBindingUri': $1,
        if (request.fInt32 case final $1 when $1.isNotDefault)
          'fInt32': '${$1}',
        if (request.fInt64 case final $1 when $1.isNotDefault)
          'fInt64': '${$1}',
        if (request.fDouble case final $1 when $1.isNotDefault)
          'fDouble': '${$1}',
        if (request.pInt32 case final $1?) 'pInt32': '${$1}',
        if (request.pInt64 case final $1?) 'pInt64': '${$1}',
        if (request.pDouble case final $1?) 'pDouble': '${$1}',
      },
    );
    final response = await _client.get(url);
    return RepeatResponse.fromJson(response);
  }

  /// This method echoes the ComplianceData request, using the HTTP PUT method.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RepeatResponse> repeatDataBodyPut(RepeatRequest request) async {
    final url = Uri.https(_host, '/v1beta1/repeat:bodyput');
    final response = await _client.put(url, body: request);
    return RepeatResponse.fromJson(response);
  }

  /// This method echoes the ComplianceData request, using the HTTP PATCH method.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<RepeatResponse> repeatDataBodyPatch(RepeatRequest request) async {
    final url = Uri.https(_host, '/v1beta1/repeat:bodypatch');
    final response = await _client.patch(url, body: request);
    return RepeatResponse.fromJson(response);
  }

  /// This method requests an enum value from the server. Depending on the contents of EnumRequest, the enum value returned will be a known enum declared in the
  /// .proto file, or a made-up enum value the is unknown to the client. To verify that clients can round-trip unknown enum values they receive, use the
  /// response from this RPC as the request to VerifyEnum()
  ///
  /// The values of enums sent by the server when a known or unknown value is requested will be the same within a single Showcase server run (this is needed for
  /// VerifyEnum() to work) but are not guaranteed to be the same across separate Showcase server runs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EnumResponse> getEnum(EnumRequest request) async {
    final url = Uri.https(_host, '/v1beta1/compliance/enum', {
      if (request.unknownEnum case final $1 when $1.isNotDefault)
        'unknownEnum': '${$1}',
    });
    final response = await _client.get(url);
    return EnumResponse.fromJson(response);
  }

  /// This method is used to verify that clients can round-trip enum values, which is particularly important for unknown enum values over REST. VerifyEnum()
  /// verifies that its request, which is presumably the response that the client previously got to a GetEnum(), contains the correct data. If so, it responds
  /// with the same EnumResponse; otherwise, the RPC errors.
  ///
  /// This works because the values of enums sent by the server when a known or unknown value is requested will be the same within a single Showcase server run,
  /// although they are not guaranteed to be the same across separate Showcase server runs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EnumResponse> verifyEnum(EnumResponse request) async {
    final url = Uri.https(_host, '/v1beta1/compliance/enum', {
      if (request.request!.unknownEnum case final $1 when $1.isNotDefault)
        'request.unknownEnum': '${$1}',
      if (request.continent case final $1 when $1.isNotDefault)
        'continent': $1.value,
    });
    final response = await _client.post(url);
    return EnumResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy', {
      if (request.options!.requestedPolicyVersion case final $1
          when $1.isNotDefault)
        'options.requestedPolicyVersion': '${$1}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/operations', {
      if (request.name case final $1 when $1.isNotDefault) 'name': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// This service is used showcase the four main types of rpcs - unary, server
/// side streaming, client side streaming, and bidirectional streaming. This
/// service also exposes methods that explicitly implement server delay, and
/// paginated calls. Set the 'showcase-trailer' metadata key on any method
/// to have the values echoed in the response trailers. Set the
/// 'x-goog-request-params' metadata key on any method to have the values
/// echoed in the response headers.
final class Echo {
  static const _host = 'localhost:7469';

  final ServiceClient _client;

  /// Creates a `Echo` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `Echo`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  Echo({required http.Client client}) : _client = ServiceClient(client: client);

  /// Creates a `Echo` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory Echo.fromApiKey([String? apiKey]) =>
      Echo(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// This method simply echoes the request. This method showcases unary RPCs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EchoResponse> echo(EchoRequest request) async {
    final url = Uri.https(_host, '/v1beta1/echo:echo');
    final response = await _client.post(url, body: request);
    return EchoResponse.fromJson(response);
  }

  /// This method returns error details in a repeated "google.protobuf.Any"
  /// field. This method showcases handling errors thus encoded, particularly
  /// over REST transport. Note that GAPICs only allow the type
  /// "google.protobuf.Any" for field paths ending in "error.details", and, at
  /// run-time, the actual types for these fields must be one of the types in
  /// google/rpc/error_details.proto.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<EchoErrorDetailsResponse> echoErrorDetails(
    EchoErrorDetailsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/echo:error-details');
    final response = await _client.post(url, body: request);
    return EchoErrorDetailsResponse.fromJson(response);
  }

  /// This method always fails with a gRPC "Aborted" error status that contains
  /// multiple error details.  These include one instance of each of the standard
  /// ones in error_details.proto
  /// (https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto)
  /// plus a custom, Showcase-defined PoetryError. The intent of this RPC is to
  /// verify that GAPICs can process these various error details and surface them
  /// to the user in an idiomatic form.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<FailEchoWithDetailsResponse> failEchoWithDetails(
    FailEchoWithDetailsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/echo:failWithDetails');
    final response = await _client.post(url, body: request);
    return FailEchoWithDetailsResponse.fromJson(response);
  }

  /// This method splits the given content into words and will pass each word back
  /// through the stream. This method showcases server-side streaming RPCs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<EchoResponse> expand(ExpandRequest request) {
    final url = Uri.https(_host, '/v1beta1/echo:expand');
    return _client.postStreaming(url, body: request).map(EchoResponse.fromJson);
  }

  /// This is similar to the Expand method but instead of returning a stream of
  /// expanded words, this method returns a paged list of expanded words.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PagedExpandResponse> pagedExpand(PagedExpandRequest request) async {
    final url = Uri.https(_host, '/v1beta1/echo:pagedExpand');
    final response = await _client.post(url, body: request);
    return PagedExpandResponse.fromJson(response);
  }

  /// This is similar to the PagedExpand except that it uses
  /// max_results instead of page_size, as some legacy APIs still
  /// do. New APIs should NOT use this pattern.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PagedExpandResponse> pagedExpandLegacy(
    PagedExpandLegacyRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/echo:pagedExpandLegacy');
    final response = await _client.post(url, body: request);
    return PagedExpandResponse.fromJson(response);
  }

  /// This method returns a map containing lists of words that appear in the input, keyed by their
  /// initial character. The only words returned are the ones included in the current page,
  /// as determined by page_token and page_size, which both refer to the word indices in the
  /// input. This paging result consisting of a map of lists is a pattern used by some legacy
  /// APIs. New APIs should NOT use this pattern.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<PagedExpandLegacyMappedResponse> pagedExpandLegacyMapped(
    PagedExpandRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/echo:pagedExpandLegacyMapped');
    final response = await _client.post(url, body: request);
    return PagedExpandLegacyMappedResponse.fromJson(response);
  }

  /// This method will wait for the requested amount of time and then return.
  /// This method showcases how a client handles a request timeout.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<WaitResponse, WaitMetadata>> wait(
    WaitRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/echo:wait');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(WaitResponse.fromJson, WaitMetadata.fromJson),
    );
  }

  /// This method will block (wait) for the requested amount of time
  /// and then return the response or error.
  /// This method showcases how a client handles delays or retries.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<BlockResponse> block(BlockRequest request) async {
    final url = Uri.https(_host, '/v1beta1/echo:block');
    final response = await _client.post(url, body: request);
    return BlockResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy', {
      if (request.options!.requestedPolicyVersion case final $1
          when $1.isNotDefault)
        'options.requestedPolicyVersion': '${$1}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/operations', {
      if (request.name case final $1 when $1.isNotDefault) 'name': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A simple identity service.
final class Identity {
  static const _host = 'localhost:7469';

  final ServiceClient _client;

  /// Creates a `Identity` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `Identity`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  Identity({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `Identity` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory Identity.fromApiKey([String? apiKey]) =>
      Identity(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a user.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<User> createUser(CreateUserRequest request) async {
    final url = Uri.https(_host, '/v1beta1/users');
    final response = await _client.post(url, body: request);
    return User.fromJson(response);
  }

  /// Retrieves the User with the given uri.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<User> getUser(GetUserRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return User.fromJson(response);
  }

  /// Updates a user.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<User> updateUser(UpdateUserRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.user!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.user);
    return User.fromJson(response);
  }

  /// Deletes a user, their profile, and all of their authored messages.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteUser(DeleteUserRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Lists all users.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListUsersResponse> listUsers(ListUsersRequest request) async {
    final url = Uri.https(_host, '/v1beta1/users', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListUsersResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy', {
      if (request.options!.requestedPolicyVersion case final $1
          when $1.isNotDefault)
        'options.requestedPolicyVersion': '${$1}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/operations', {
      if (request.name case final $1 when $1.isNotDefault) 'name': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A simple messaging service that implements chat rooms and profile posts.
///
/// This messaging service showcases the features that API clients
/// generated by gapic-generators implement.
final class Messaging {
  static const _host = 'localhost:7469';

  final ServiceClient _client;

  /// Creates a `Messaging` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `Messaging`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  Messaging({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `Messaging` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory Messaging.fromApiKey([String? apiKey]) =>
      Messaging(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a room.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Room> createRoom(CreateRoomRequest request) async {
    final url = Uri.https(_host, '/v1beta1/rooms');
    final response = await _client.post(url, body: request);
    return Room.fromJson(response);
  }

  /// Retrieves the Room with the given resource name.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Room> getRoom(GetRoomRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Room.fromJson(response);
  }

  /// Updates a room.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Room> updateRoom(UpdateRoomRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.room!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.room);
    return Room.fromJson(response);
  }

  /// Deletes a room and all of its blurbs.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteRoom(DeleteRoomRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Lists all chat rooms.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListRoomsResponse> listRooms(ListRoomsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/rooms', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListRoomsResponse.fromJson(response);
  }

  /// Creates a blurb. If the parent is a room, the blurb is understood to be a
  /// message in that room. If the parent is a profile, the blurb is understood
  /// to be a post on the profile.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Blurb> createBlurb(CreateBlurbRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/blurbs');
    final response = await _client.post(url, body: request);
    return Blurb.fromJson(response);
  }

  /// Retrieves the Blurb with the given resource name.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Blurb> getBlurb(GetBlurbRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Blurb.fromJson(response);
  }

  /// Updates a blurb.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Blurb> updateBlurb(UpdateBlurbRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.blurb!.name}', {
      if (request.updateMask case final $1?) 'updateMask': $1.toJson(),
    });
    final response = await _client.patch(url, body: request.blurb);
    return Blurb.fromJson(response);
  }

  /// Deletes a blurb.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteBlurb(DeleteBlurbRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Lists blurbs for a specific chat room or user profile depending on the
  /// parent resource name.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListBlurbsResponse> listBlurbs(ListBlurbsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/blurbs', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListBlurbsResponse.fromJson(response);
  }

  /// This method searches through all blurbs across all rooms and profiles
  /// for blurbs containing to words found in the query. Only posts that
  /// contain an exact match of a queried word will be returned.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// Returns an [Operation] representing the status of the long-running
  /// operation.
  ///
  /// When complete, [Operation.done] will be `true`. If successful,
  /// [Operation.responseAsMessage] will contain the operation's result.
  Future<Operation<SearchBlurbsResponse, SearchBlurbsMetadata>> searchBlurbs(
    SearchBlurbsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/blurbs:search');
    final response = await _client.post(url, body: request);
    return Operation.fromJson(
      response,
      OperationHelper(
        SearchBlurbsResponse.fromJson,
        SearchBlurbsMetadata.fromJson,
      ),
    );
  }

  /// This returns a stream that emits the blurbs that are created for a
  /// particular chat room or user profile.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<StreamBlurbsResponse> streamBlurbs(StreamBlurbsRequest request) {
    final url = Uri.https(_host, '/v1beta1/${request.name}/blurbs:stream');
    return _client
        .postStreaming(url, body: request)
        .map(StreamBlurbsResponse.fromJson);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy', {
      if (request.options!.requestedPolicyVersion case final $1
          when $1.isNotDefault)
        'options.requestedPolicyVersion': '${$1}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/operations', {
      if (request.name case final $1 when $1.isNotDefault) 'name': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

final class SequenceService {
  static const _host = 'localhost:7469';

  final ServiceClient _client;

  /// Creates a `SequenceService` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `SequenceService`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  SequenceService({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `SequenceService` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory SequenceService.fromApiKey([String? apiKey]) =>
      SequenceService(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a sequence.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Sequence> createSequence(CreateSequenceRequest request) async {
    final url = Uri.https(_host, '/v1beta1/sequences');
    final response = await _client.post(url, body: request.sequence);
    return Sequence.fromJson(response);
  }

  /// Creates a sequence.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<StreamingSequence> createStreamingSequence(
    CreateStreamingSequenceRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/streamingSequences');
    final response = await _client.post(url, body: request.streamingSequence);
    return StreamingSequence.fromJson(response);
  }

  /// Retrieves a sequence.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<SequenceReport> getSequenceReport(
    GetSequenceReportRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return SequenceReport.fromJson(response);
  }

  /// Retrieves a sequence.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<StreamingSequenceReport> getStreamingSequenceReport(
    GetStreamingSequenceReportRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return StreamingSequenceReport.fromJson(response);
  }

  /// Attempts a sequence.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> attemptSequence(AttemptSequenceRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.post(url, body: request);
  }

  /// Attempts a streaming sequence.
  /// May not function as expected in HTTP mode due to when http statuses are sent
  /// See https://github.com/googleapis/gapic-showcase/issues/1377 for more details
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Stream<AttemptStreamingSequenceResponse> attemptStreamingSequence(
    AttemptStreamingSequenceRequest request,
  ) {
    final url = Uri.https(_host, '/v1beta1/${request.name}:stream');
    return _client
        .postStreaming(url, body: request)
        .map(AttemptStreamingSequenceResponse.fromJson);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy', {
      if (request.options!.requestedPolicyVersion case final $1
          when $1.isNotDefault)
        'options.requestedPolicyVersion': '${$1}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/operations', {
      if (request.name case final $1 when $1.isNotDefault) 'name': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

/// A service to facilitate running discrete sets of tests
/// against Showcase.
/// Adding this comment with special characters for comment formatting tests:
/// 1. (abra->kadabra->alakazam)
/// 2) `Nonsense`: `pokemon/*/psychic/*`
final class Testing {
  static const _host = 'localhost:7469';

  final ServiceClient _client;

  /// Creates a `Testing` using [client] for transport.
  ///
  /// The provided [http.Client] must be configured to provide whatever
  /// authentication is required by `Testing`. You can do that using
  /// [`package:googleapis_auth`](https://pub.dev/packages/googleapis_auth).
  Testing({required http.Client client})
    : _client = ServiceClient(client: client);

  /// Creates a `Testing` that does authentication through an API key.
  ///
  /// If called without arguments, the API key is taken from these environment
  /// variables:
  ///
  /// - `GOOGLE_API_KEY`
  ///
  /// Throws [ConfigurationException] if called without arguments and none of
  /// the above environment variables are set. On the web,
  /// always throws [ConfigurationException] if called without arguments.
  ///
  /// See [API Keys Overview](https://cloud.google.com/api-keys/docs/overview).
  factory Testing.fromApiKey([String? apiKey]) =>
      Testing(client: httpClientFromApiKey(apiKey, _apiKeys));

  /// Creates a new testing session.
  /// Adding this comment with special characters for comment formatting tests:
  /// 1. (abra->kadabra->alakazam)
  /// 2) `Nonsense`: `pokemon/*/psychic/*`
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Session> createSession(CreateSessionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/sessions');
    final response = await _client.post(url, body: request.session);
    return Session.fromJson(response);
  }

  /// Gets a testing session.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Session> getSession(GetSessionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Session.fromJson(response);
  }

  /// Lists the current test sessions.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListSessionsResponse> listSessions(ListSessionsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/sessions', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListSessionsResponse.fromJson(response);
  }

  /// Delete a test session.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteSession(DeleteSessionRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Report on the status of a session.
  /// This generates a report detailing which tests have been completed,
  /// and an overall rollup.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ReportSessionResponse> reportSession(
    ReportSessionRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:report');
    final response = await _client.post(url);
    return ReportSessionResponse.fromJson(response);
  }

  /// List the tests of a sessesion.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListTestsResponse> listTests(ListTestsRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.parent}/tests', {
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListTestsResponse.fromJson(response);
  }

  /// Explicitly decline to implement a test.
  ///
  /// This removes the test from subsequent `ListTests` calls, and
  /// attempting to do the test will error.
  ///
  /// This method will error if attempting to delete a required test.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteTest(DeleteTestRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Register a response to a test.
  ///
  /// In cases where a test involves registering a final answer at the
  /// end of the test, this method provides the means to do so.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<VerifyTestResponse> verifyTest(VerifyTestRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:check', {
      if (request.answer case final $1 when $1.isNotDefault)
        'answer': encodeBytes($1)!,
      if (request.answers case final $1 when $1.isNotDefault)
        'answers': $1.map((e) => encodeBytes(e)!),
    });
    final response = await _client.post(url);
    return VerifyTestResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListLocationsResponse> listLocations(
    ListLocationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}/locations', {
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
    });
    final response = await _client.get(url);
    return ListLocationsResponse.fromJson(response);
  }

  /// Provides the `Locations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Location> getLocation(GetLocationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Location.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> setIamPolicy(SetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:setIamPolicy');
    final response = await _client.post(url, body: request);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<Policy> getIamPolicy(GetIamPolicyRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.resource}:getIamPolicy', {
      if (request.options!.requestedPolicyVersion case final $1
          when $1.isNotDefault)
        'options.requestedPolicyVersion': '${$1}',
    });
    final response = await _client.get(url);
    return Policy.fromJson(response);
  }

  /// Provides the `IAMPolicy` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<TestIamPermissionsResponse> testIamPermissions(
    TestIamPermissionsRequest request,
  ) async {
    final url = Uri.https(
      _host,
      '/v1beta1/${request.resource}:testIamPermissions',
    );
    final response = await _client.post(url, body: request);
    return TestIamPermissionsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<ListOperationsResponse> listOperations(
    ListOperationsRequest request,
  ) async {
    final url = Uri.https(_host, '/v1beta1/operations', {
      if (request.name case final $1 when $1.isNotDefault) 'name': $1,
      if (request.filter case final $1 when $1.isNotDefault) 'filter': $1,
      if (request.pageSize case final $1 when $1.isNotDefault)
        'pageSize': '${$1}',
      if (request.pageToken case final $1 when $1.isNotDefault) 'pageToken': $1,
      if (request.returnPartialSuccess case final $1 when $1.isNotDefault)
        'returnPartialSuccess': '${$1}',
    });
    final response = await _client.get(url);
    return ListOperationsResponse.fromJson(response);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  ///
  /// This method can be used to get the current status of a long-running
  /// operation.
  Future<Operation<T, S>> getOperation<
    T extends ProtoMessage,
    S extends ProtoMessage
  >(Operation<T, S> request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    final response = await _client.get(url);
    return Operation.fromJson(response, request.operationHelper);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> deleteOperation(DeleteOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}');
    await _client.delete(url);
  }

  /// Provides the `Operations` service functionality in this service.
  ///
  /// Throws a [http.ClientException] if there were problems communicating with
  /// the API service. Throws a [StatusException] if the API failed with a
  /// [Status] message. Throws a [ServiceException] for any other failure.
  Future<void> cancelOperation(CancelOperationRequest request) async {
    final url = Uri.https(_host, '/v1beta1/${request.name}:cancel');
    await _client.post(url);
  }

  /// Closes the client and cleans up any resources associated with it.
  ///
  /// Once [close] is called, no other methods should be called.
  void close() => _client.close();
}

final class RepeatRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.RepeatRequest';

  final String name;

  final ComplianceData? info;

  /// If true, the server will verify that the received request matches
  /// the request with the same name in the compliance test suite.
  final bool serverVerify;

  /// The URI template this request is expected to be bound to server-side.
  final String? intendedBindingUri;

  /// Some top level fields, to test that these are encoded correctly
  /// in query params.
  final int fInt32;

  final int fInt64;

  final double fDouble;

  final int? pInt32;

  final int? pInt64;

  final double? pDouble;

  RepeatRequest({
    String? name,
    this.info,
    bool? serverVerify,
    this.intendedBindingUri,
    int? fInt32,
    int? fInt64,
    double? fDouble,
    this.pInt32,
    this.pInt64,
    this.pDouble,
  }) : name = name ?? '',
       serverVerify = serverVerify ?? false,
       fInt32 = fInt32 ?? 0,
       fInt64 = fInt64 ?? 0,
       fDouble = fDouble ?? 0,
       super(fullyQualifiedName);

  factory RepeatRequest.fromJson(Map<String, dynamic> json) => RepeatRequest(
    name: json['name'] ?? '',
    info: decode(json['info'], ComplianceData.fromJson),
    serverVerify: json['serverVerify'] ?? false,
    intendedBindingUri: json['intendedBindingUri'],
    fInt32: json['fInt32'] ?? 0,
    fInt64: decodeInt64(json['fInt64']) ?? 0,
    fDouble: decodeDouble(json['fDouble']) ?? 0,
    pInt32: json['pInt32'],
    pInt64: decodeInt64(json['pInt64']),
    pDouble: decodeDouble(json['pDouble']),
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (info != null) 'info': info!.toJson(),
    if (serverVerify.isNotDefault) 'serverVerify': serverVerify,
    if (intendedBindingUri != null) 'intendedBindingUri': intendedBindingUri,
    if (fInt32.isNotDefault) 'fInt32': fInt32,
    if (fInt64.isNotDefault) 'fInt64': encodeInt64(fInt64),
    if (fDouble.isNotDefault) 'fDouble': encodeDouble(fDouble),
    if (pInt32 != null) 'pInt32': pInt32,
    if (pInt64 != null) 'pInt64': encodeInt64(pInt64),
    if (pDouble != null) 'pDouble': encodeDouble(pDouble),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'serverVerify=$serverVerify',
      if (intendedBindingUri != null) 'intendedBindingUri=$intendedBindingUri',
      'fInt32=$fInt32',
      'fInt64=$fInt64',
      'fDouble=$fDouble',
      if (pInt32 != null) 'pInt32=$pInt32',
      if (pInt64 != null) 'pInt64=$pInt64',
      if (pDouble != null) 'pDouble=$pDouble',
    ].join(',');
    return 'RepeatRequest($contents)';
  }
}

final class RepeatResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.RepeatResponse';

  final RepeatRequest? request;

  /// The URI template the request was bound to server-side.
  final String bindingUri;

  RepeatResponse({this.request, String? bindingUri})
    : bindingUri = bindingUri ?? '',
      super(fullyQualifiedName);

  factory RepeatResponse.fromJson(Map<String, dynamic> json) => RepeatResponse(
    request: decode(json['request'], RepeatRequest.fromJson),
    bindingUri: json['bindingUri'] ?? '',
  );

  @override
  Object toJson() => {
    if (request != null) 'request': request!.toJson(),
    if (bindingUri.isNotDefault) 'bindingUri': bindingUri,
  };

  @override
  String toString() {
    final contents = ['bindingUri=$bindingUri'].join(',');
    return 'RepeatResponse($contents)';
  }
}

/// ComplianceSuite contains a set of requests that microgenerators should issue
/// over REST to the Compliance service to test their gRPC-to-REST transcoding
/// implementation.
final class ComplianceSuite extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ComplianceSuite';

  final List<ComplianceGroup> group;

  ComplianceSuite({this.group = const []}) : super(fullyQualifiedName);

  factory ComplianceSuite.fromJson(Map<String, dynamic> json) =>
      ComplianceSuite(
        group: decodeListMessage(json['group'], ComplianceGroup.fromJson) ?? [],
      );

  @override
  Object toJson() => {if (group.isNotDefault) 'group': encodeList(group)};

  @override
  String toString() => 'ComplianceSuite()';
}

/// ComplianceGroups encapsulates a group of RPC requests to the Compliance
/// server: one request for each combination of elements of `rpcs` and of
/// `requests`.
final class ComplianceGroup extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ComplianceGroup';

  final String name;

  final List<String> rpcs;

  final List<RepeatRequest> requests;

  ComplianceGroup({
    String? name,
    this.rpcs = const [],
    this.requests = const [],
  }) : name = name ?? '',
       super(fullyQualifiedName);

  factory ComplianceGroup.fromJson(Map<String, dynamic> json) =>
      ComplianceGroup(
        name: json['name'] ?? '',
        rpcs: decodeList(json['rpcs']) ?? [],
        requests:
            decodeListMessage(json['requests'], RepeatRequest.fromJson) ?? [],
      );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (rpcs.isNotDefault) 'rpcs': rpcs,
    if (requests.isNotDefault) 'requests': encodeList(requests),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ComplianceGroup($contents)';
  }
}

/// ComplianceData is a message used for testing REST transcoding of
/// different data types.
final class ComplianceData extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ComplianceData';

  final String fString;

  final int fInt32;

  final int fSint32;

  final int fSfixed32;

  final int fUint32;

  final int fFixed32;

  final int fInt64;

  final int fSint64;

  final int fSfixed64;

  final int fUint64;

  final int fFixed64;

  final double fDouble;

  final double fFloat;

  final bool fBool;

  final Uint8List fBytes;

  final ComplianceData_LifeKingdom fKingdom;

  final ComplianceDataChild? fChild;

  final String? pString;

  final int? pInt32;

  final double? pDouble;

  final bool? pBool;

  final ComplianceData_LifeKingdom? pKingdom;

  final ComplianceDataChild? pChild;

  ComplianceData({
    String? fString,
    int? fInt32,
    int? fSint32,
    int? fSfixed32,
    int? fUint32,
    int? fFixed32,
    int? fInt64,
    int? fSint64,
    int? fSfixed64,
    int? fUint64,
    int? fFixed64,
    double? fDouble,
    double? fFloat,
    bool? fBool,
    this.fBytes = Uint8List(0),
    this.fKingdom = ComplianceData_LifeKingdom.$default,
    this.fChild,
    this.pString,
    this.pInt32,
    this.pDouble,
    this.pBool,
    this.pKingdom,
    this.pChild,
  }) : fString = fString ?? '',
       fInt32 = fInt32 ?? 0,
       fSint32 = fSint32 ?? 0,
       fSfixed32 = fSfixed32 ?? 0,
       fUint32 = fUint32 ?? 0,
       fFixed32 = fFixed32 ?? 0,
       fInt64 = fInt64 ?? 0,
       fSint64 = fSint64 ?? 0,
       fSfixed64 = fSfixed64 ?? 0,
       fUint64 = fUint64 ?? 0,
       fFixed64 = fFixed64 ?? 0,
       fDouble = fDouble ?? 0,
       fFloat = fFloat ?? 0,
       fBool = fBool ?? false,
       super(fullyQualifiedName);

  factory ComplianceData.fromJson(Map<String, dynamic> json) => ComplianceData(
    fString: json['fString'] ?? '',
    fInt32: json['fInt32'] ?? 0,
    fSint32: json['fSint32'] ?? 0,
    fSfixed32: json['fSfixed32'] ?? 0,
    fUint32: json['fUint32'] ?? 0,
    fFixed32: json['fFixed32'] ?? 0,
    fInt64: decodeInt64(json['fInt64']) ?? 0,
    fSint64: decodeInt64(json['fSint64']) ?? 0,
    fSfixed64: decodeInt64(json['fSfixed64']) ?? 0,
    fUint64: decodeInt64(json['fUint64']) ?? 0,
    fFixed64: decodeInt64(json['fFixed64']) ?? 0,
    fDouble: decodeDouble(json['fDouble']) ?? 0,
    fFloat: decodeDouble(json['fFloat']) ?? 0,
    fBool: json['fBool'] ?? false,
    fBytes: decodeBytes(json['fBytes']) ?? Uint8List(0),
    fKingdom:
        decodeEnum(json['fKingdom'], ComplianceData_LifeKingdom.fromJson) ??
        ComplianceData_LifeKingdom.$default,
    fChild: decode(json['fChild'], ComplianceDataChild.fromJson),
    pString: json['pString'],
    pInt32: json['pInt32'],
    pDouble: decodeDouble(json['pDouble']),
    pBool: json['pBool'],
    pKingdom: decodeEnum(json['pKingdom'], ComplianceData_LifeKingdom.fromJson),
    pChild: decode(json['pChild'], ComplianceDataChild.fromJson),
  );

  @override
  Object toJson() => {
    if (fString.isNotDefault) 'fString': fString,
    if (fInt32.isNotDefault) 'fInt32': fInt32,
    if (fSint32.isNotDefault) 'fSint32': fSint32,
    if (fSfixed32.isNotDefault) 'fSfixed32': fSfixed32,
    if (fUint32.isNotDefault) 'fUint32': fUint32,
    if (fFixed32.isNotDefault) 'fFixed32': fFixed32,
    if (fInt64.isNotDefault) 'fInt64': encodeInt64(fInt64),
    if (fSint64.isNotDefault) 'fSint64': encodeInt64(fSint64),
    if (fSfixed64.isNotDefault) 'fSfixed64': encodeInt64(fSfixed64),
    if (fUint64.isNotDefault) 'fUint64': encodeInt64(fUint64),
    if (fFixed64.isNotDefault) 'fFixed64': encodeInt64(fFixed64),
    if (fDouble.isNotDefault) 'fDouble': encodeDouble(fDouble),
    if (fFloat.isNotDefault) 'fFloat': encodeDouble(fFloat),
    if (fBool.isNotDefault) 'fBool': fBool,
    if (fBytes.isNotDefault) 'fBytes': encodeBytes(fBytes),
    if (fKingdom.isNotDefault) 'fKingdom': fKingdom.toJson(),
    if (fChild != null) 'fChild': fChild!.toJson(),
    if (pString != null) 'pString': pString,
    if (pInt32 != null) 'pInt32': pInt32,
    if (pDouble != null) 'pDouble': encodeDouble(pDouble),
    if (pBool != null) 'pBool': pBool,
    if (pKingdom != null) 'pKingdom': pKingdom!.toJson(),
    if (pChild != null) 'pChild': pChild!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'fString=$fString',
      'fInt32=$fInt32',
      'fSint32=$fSint32',
      'fSfixed32=$fSfixed32',
      'fUint32=$fUint32',
      'fFixed32=$fFixed32',
      'fInt64=$fInt64',
      'fSint64=$fSint64',
      'fSfixed64=$fSfixed64',
      'fUint64=$fUint64',
      'fFixed64=$fFixed64',
      'fDouble=$fDouble',
      'fFloat=$fFloat',
      'fBool=$fBool',
      'fBytes=$fBytes',
      'fKingdom=$fKingdom',
      if (pString != null) 'pString=$pString',
      if (pInt32 != null) 'pInt32=$pInt32',
      if (pDouble != null) 'pDouble=$pDouble',
      if (pBool != null) 'pBool=$pBool',
      if (pKingdom != null) 'pKingdom=$pKingdom',
    ].join(',');
    return 'ComplianceData($contents)';
  }
}

final class ComplianceData_LifeKingdom extends ProtoEnum {
  static const lifeKingdomUnspecified = ComplianceData_LifeKingdom(
    'LIFE_KINGDOM_UNSPECIFIED',
  );

  static const archaebacteria = ComplianceData_LifeKingdom('ARCHAEBACTERIA');

  static const eubacteria = ComplianceData_LifeKingdom('EUBACTERIA');

  static const protista = ComplianceData_LifeKingdom('PROTISTA');

  static const fungi = ComplianceData_LifeKingdom('FUNGI');

  static const plantae = ComplianceData_LifeKingdom('PLANTAE');

  static const animalia = ComplianceData_LifeKingdom('ANIMALIA');

  /// The default value for [ComplianceData_LifeKingdom].
  static const $default = lifeKingdomUnspecified;

  const ComplianceData_LifeKingdom(super.value);

  factory ComplianceData_LifeKingdom.fromJson(String json) =>
      ComplianceData_LifeKingdom(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'LifeKingdom.$value';
}

final class ComplianceDataChild extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ComplianceDataChild';

  final String fString;

  final double fFloat;

  final double fDouble;

  final bool fBool;

  final Continent fContinent;

  final ComplianceDataGrandchild? fChild;

  final String? pString;

  final double? pFloat;

  final double? pDouble;

  final bool? pBool;

  final Continent pContinent;

  final ComplianceDataGrandchild? pChild;

  ComplianceDataChild({
    String? fString,
    double? fFloat,
    double? fDouble,
    bool? fBool,
    this.fContinent = Continent.$default,
    this.fChild,
    this.pString,
    this.pFloat,
    this.pDouble,
    this.pBool,
    this.pContinent = Continent.$default,
    this.pChild,
  }) : fString = fString ?? '',
       fFloat = fFloat ?? 0,
       fDouble = fDouble ?? 0,
       fBool = fBool ?? false,
       super(fullyQualifiedName);

  factory ComplianceDataChild.fromJson(Map<String, dynamic> json) =>
      ComplianceDataChild(
        fString: json['fString'] ?? '',
        fFloat: decodeDouble(json['fFloat']) ?? 0,
        fDouble: decodeDouble(json['fDouble']) ?? 0,
        fBool: json['fBool'] ?? false,
        fContinent:
            decodeEnum(json['fContinent'], Continent.fromJson) ??
            Continent.$default,
        fChild: decode(json['fChild'], ComplianceDataGrandchild.fromJson),
        pString: json['pString'],
        pFloat: decodeDouble(json['pFloat']),
        pDouble: decodeDouble(json['pDouble']),
        pBool: json['pBool'],
        pContinent:
            decodeEnum(json['pContinent'], Continent.fromJson) ??
            Continent.$default,
        pChild: decode(json['pChild'], ComplianceDataGrandchild.fromJson),
      );

  @override
  Object toJson() => {
    if (fString.isNotDefault) 'fString': fString,
    if (fFloat.isNotDefault) 'fFloat': encodeDouble(fFloat),
    if (fDouble.isNotDefault) 'fDouble': encodeDouble(fDouble),
    if (fBool.isNotDefault) 'fBool': fBool,
    if (fContinent.isNotDefault) 'fContinent': fContinent.toJson(),
    if (fChild != null) 'fChild': fChild!.toJson(),
    if (pString != null) 'pString': pString,
    if (pFloat != null) 'pFloat': encodeDouble(pFloat),
    if (pDouble != null) 'pDouble': encodeDouble(pDouble),
    if (pBool != null) 'pBool': pBool,
    if (pContinent.isNotDefault) 'pContinent': pContinent.toJson(),
    if (pChild != null) 'pChild': pChild!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'fString=$fString',
      'fFloat=$fFloat',
      'fDouble=$fDouble',
      'fBool=$fBool',
      'fContinent=$fContinent',
      if (pString != null) 'pString=$pString',
      if (pFloat != null) 'pFloat=$pFloat',
      if (pDouble != null) 'pDouble=$pDouble',
      if (pBool != null) 'pBool=$pBool',
      'pContinent=$pContinent',
    ].join(',');
    return 'ComplianceDataChild($contents)';
  }
}

final class ComplianceDataGrandchild extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ComplianceDataGrandchild';

  final String fString;

  final double fDouble;

  final bool fBool;

  ComplianceDataGrandchild({String? fString, double? fDouble, bool? fBool})
    : fString = fString ?? '',
      fDouble = fDouble ?? 0,
      fBool = fBool ?? false,
      super(fullyQualifiedName);

  factory ComplianceDataGrandchild.fromJson(Map<String, dynamic> json) =>
      ComplianceDataGrandchild(
        fString: json['fString'] ?? '',
        fDouble: decodeDouble(json['fDouble']) ?? 0,
        fBool: json['fBool'] ?? false,
      );

  @override
  Object toJson() => {
    if (fString.isNotDefault) 'fString': fString,
    if (fDouble.isNotDefault) 'fDouble': encodeDouble(fDouble),
    if (fBool.isNotDefault) 'fBool': fBool,
  };

  @override
  String toString() {
    final contents = [
      'fString=$fString',
      'fDouble=$fDouble',
      'fBool=$fBool',
    ].join(',');
    return 'ComplianceDataGrandchild($contents)';
  }
}

final class EnumRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.EnumRequest';

  /// Whether the client is requesting a new, unknown enum value or a known enum value already declared in this proto file.
  final bool unknownEnum;

  EnumRequest({bool? unknownEnum})
    : unknownEnum = unknownEnum ?? false,
      super(fullyQualifiedName);

  factory EnumRequest.fromJson(Map<String, dynamic> json) =>
      EnumRequest(unknownEnum: json['unknownEnum'] ?? false);

  @override
  Object toJson() => {if (unknownEnum.isNotDefault) 'unknownEnum': unknownEnum};

  @override
  String toString() {
    final contents = ['unknownEnum=$unknownEnum'].join(',');
    return 'EnumRequest($contents)';
  }
}

final class EnumResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.EnumResponse';

  /// The original request for a known or unknown enum from the server.
  final EnumRequest? request;

  /// The actual enum the server provided.
  final Continent continent;

  EnumResponse({this.request, this.continent = Continent.$default})
    : super(fullyQualifiedName);

  factory EnumResponse.fromJson(Map<String, dynamic> json) => EnumResponse(
    request: decode(json['request'], EnumRequest.fromJson),
    continent:
        decodeEnum(json['continent'], Continent.fromJson) ?? Continent.$default,
  );

  @override
  Object toJson() => {
    if (request != null) 'request': request!.toJson(),
    if (continent.isNotDefault) 'continent': continent.toJson(),
  };

  @override
  String toString() {
    final contents = ['continent=$continent'].join(',');
    return 'EnumResponse($contents)';
  }
}

/// The request message used for the Echo, Collect and Chat methods.
/// If content or opt are set in this message then the request will succeed.
/// If status is set in this message then the status will be returned as an
/// error.
final class EchoRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.EchoRequest';

  /// The content to be echoed by the server.
  final String? content;

  /// The error to be thrown by the server.
  final Status? error;

  /// The severity to be echoed by the server.
  final Severity severity;

  /// Optional. This field can be set to test the routing annotation on the Echo method.
  final String header;

  /// Optional. This field can be set to test the routing annotation on the Echo method.
  final String otherHeader;

  /// To facilitate testing of https://google.aip.dev/client-libraries/4235
  final String requestId;

  /// To facilitate testing of https://google.aip.dev/client-libraries/4235
  final String? otherRequestId;

  EchoRequest({
    this.content,
    this.error,
    this.severity = Severity.$default,
    String? header,
    String? otherHeader,
    String? requestId,
    this.otherRequestId,
  }) : header = header ?? '',
       otherHeader = otherHeader ?? '',
       requestId = requestId ?? '',
       super(fullyQualifiedName);

  factory EchoRequest.fromJson(Map<String, dynamic> json) => EchoRequest(
    content: json['content'],
    error: decode(json['error'], Status.fromJson),
    severity:
        decodeEnum(json['severity'], Severity.fromJson) ?? Severity.$default,
    header: json['header'] ?? '',
    otherHeader: json['otherHeader'] ?? '',
    requestId: json['requestId'] ?? '',
    otherRequestId: json['otherRequestId'],
  );

  @override
  Object toJson() => {
    if (content != null) 'content': content,
    if (error != null) 'error': error!.toJson(),
    if (severity.isNotDefault) 'severity': severity.toJson(),
    if (header.isNotDefault) 'header': header,
    if (otherHeader.isNotDefault) 'otherHeader': otherHeader,
    if (requestId.isNotDefault) 'requestId': requestId,
    if (otherRequestId != null) 'otherRequestId': otherRequestId,
  };

  @override
  String toString() {
    final contents = [
      if (content != null) 'content=$content',
      'severity=$severity',
      'header=$header',
      'otherHeader=$otherHeader',
      'requestId=$requestId',
      if (otherRequestId != null) 'otherRequestId=$otherRequestId',
    ].join(',');
    return 'EchoRequest($contents)';
  }
}

/// The response message for the Echo methods.
final class EchoResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.EchoResponse';

  /// The content specified in the request.
  final String content;

  /// The severity specified in the request.
  final Severity severity;

  /// The request ID specified or autopopulated in the request.
  final String requestId;

  /// The other request ID specified or autopopulated in the request.
  final String otherRequestId;

  EchoResponse({
    String? content,
    this.severity = Severity.$default,
    String? requestId,
    String? otherRequestId,
  }) : content = content ?? '',
       requestId = requestId ?? '',
       otherRequestId = otherRequestId ?? '',
       super(fullyQualifiedName);

  factory EchoResponse.fromJson(Map<String, dynamic> json) => EchoResponse(
    content: json['content'] ?? '',
    severity:
        decodeEnum(json['severity'], Severity.fromJson) ?? Severity.$default,
    requestId: json['requestId'] ?? '',
    otherRequestId: json['otherRequestId'] ?? '',
  );

  @override
  Object toJson() => {
    if (content.isNotDefault) 'content': content,
    if (severity.isNotDefault) 'severity': severity.toJson(),
    if (requestId.isNotDefault) 'requestId': requestId,
    if (otherRequestId.isNotDefault) 'otherRequestId': otherRequestId,
  };

  @override
  String toString() {
    final contents = [
      'content=$content',
      'severity=$severity',
      'requestId=$requestId',
      'otherRequestId=$otherRequestId',
    ].join(',');
    return 'EchoResponse($contents)';
  }
}

/// The request message used for the EchoErrorDetails method.
final class EchoErrorDetailsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.EchoErrorDetailsRequest';

  /// Content to return in a singular `*.error.details` field of type
  /// `google.protobuf.Any`
  final String singleDetailText;

  /// Content to return in a repeated `*.error.details` field of type
  /// `google.protobuf.Any`
  final List<String> multiDetailText;

  EchoErrorDetailsRequest({
    String? singleDetailText,
    this.multiDetailText = const [],
  }) : singleDetailText = singleDetailText ?? '',
       super(fullyQualifiedName);

  factory EchoErrorDetailsRequest.fromJson(Map<String, dynamic> json) =>
      EchoErrorDetailsRequest(
        singleDetailText: json['singleDetailText'] ?? '',
        multiDetailText: decodeList(json['multiDetailText']) ?? [],
      );

  @override
  Object toJson() => {
    if (singleDetailText.isNotDefault) 'singleDetailText': singleDetailText,
    if (multiDetailText.isNotDefault) 'multiDetailText': multiDetailText,
  };

  @override
  String toString() {
    final contents = ['singleDetailText=$singleDetailText'].join(',');
    return 'EchoErrorDetailsRequest($contents)';
  }
}

/// The response message used for the EchoErrorDetails method.
final class EchoErrorDetailsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.EchoErrorDetailsResponse';

  final EchoErrorDetailsResponse_SingleDetail? singleDetail;

  final EchoErrorDetailsResponse_MultipleDetails? multipleDetails;

  EchoErrorDetailsResponse({this.singleDetail, this.multipleDetails})
    : super(fullyQualifiedName);

  factory EchoErrorDetailsResponse.fromJson(Map<String, dynamic> json) =>
      EchoErrorDetailsResponse(
        singleDetail: decode(
          json['singleDetail'],
          EchoErrorDetailsResponse_SingleDetail.fromJson,
        ),
        multipleDetails: decode(
          json['multipleDetails'],
          EchoErrorDetailsResponse_MultipleDetails.fromJson,
        ),
      );

  @override
  Object toJson() => {
    if (singleDetail != null) 'singleDetail': singleDetail!.toJson(),
    if (multipleDetails != null) 'multipleDetails': multipleDetails!.toJson(),
  };

  @override
  String toString() => 'EchoErrorDetailsResponse()';
}

final class EchoErrorDetailsResponse_SingleDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.EchoErrorDetailsResponse.SingleDetail';

  final ErrorWithSingleDetail? error;

  EchoErrorDetailsResponse_SingleDetail({this.error})
    : super(fullyQualifiedName);

  factory EchoErrorDetailsResponse_SingleDetail.fromJson(
    Map<String, dynamic> json,
  ) => EchoErrorDetailsResponse_SingleDetail(
    error: decode(json['error'], ErrorWithSingleDetail.fromJson),
  );

  @override
  Object toJson() => {if (error != null) 'error': error!.toJson()};

  @override
  String toString() => 'SingleDetail()';
}

final class EchoErrorDetailsResponse_MultipleDetails extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.EchoErrorDetailsResponse.MultipleDetails';

  final ErrorWithMultipleDetails? error;

  EchoErrorDetailsResponse_MultipleDetails({this.error})
    : super(fullyQualifiedName);

  factory EchoErrorDetailsResponse_MultipleDetails.fromJson(
    Map<String, dynamic> json,
  ) => EchoErrorDetailsResponse_MultipleDetails(
    error: decode(json['error'], ErrorWithMultipleDetails.fromJson),
  );

  @override
  Object toJson() => {if (error != null) 'error': error!.toJson()};

  @override
  String toString() => 'MultipleDetails()';
}

final class ErrorWithSingleDetail extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ErrorWithSingleDetail';

  final Any? details;

  ErrorWithSingleDetail({this.details}) : super(fullyQualifiedName);

  factory ErrorWithSingleDetail.fromJson(Map<String, dynamic> json) =>
      ErrorWithSingleDetail(details: decode(json['details'], Any.fromJson));

  @override
  Object toJson() => {if (details != null) 'details': details!.toJson()};

  @override
  String toString() => 'ErrorWithSingleDetail()';
}

final class ErrorWithMultipleDetails extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ErrorWithMultipleDetails';

  final List<Any> details;

  ErrorWithMultipleDetails({this.details = const []})
    : super(fullyQualifiedName);

  factory ErrorWithMultipleDetails.fromJson(Map<String, dynamic> json) =>
      ErrorWithMultipleDetails(
        details: decodeListMessage(json['details'], Any.fromJson) ?? [],
      );

  @override
  Object toJson() => {if (details.isNotDefault) 'details': encodeList(details)};

  @override
  String toString() => 'ErrorWithMultipleDetails()';
}

/// The custom error detail to be included in the error response from the
/// FailEchoWithDetails method. Client libraries should be able to
/// surface this custom error detail.
final class PoetryError extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.PoetryError';

  final String poem;

  PoetryError({String? poem}) : poem = poem ?? '', super(fullyQualifiedName);

  factory PoetryError.fromJson(Map<String, dynamic> json) =>
      PoetryError(poem: json['poem'] ?? '');

  @override
  Object toJson() => {if (poem.isNotDefault) 'poem': poem};

  @override
  String toString() {
    final contents = ['poem=$poem'].join(',');
    return 'PoetryError($contents)';
  }
}

/// The request message used for the FailEchoWithDetails method.
final class FailEchoWithDetailsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.FailEchoWithDetailsRequest';

  /// Optional message to echo back in the PoetryError. If empty, a value will be
  /// provided.
  final String message;

  FailEchoWithDetailsRequest({String? message})
    : message = message ?? '',
      super(fullyQualifiedName);

  factory FailEchoWithDetailsRequest.fromJson(Map<String, dynamic> json) =>
      FailEchoWithDetailsRequest(message: json['message'] ?? '');

  @override
  Object toJson() => {if (message.isNotDefault) 'message': message};

  @override
  String toString() {
    final contents = ['message=$message'].join(',');
    return 'FailEchoWithDetailsRequest($contents)';
  }
}

/// The response message declared (but never used) for the FailEchoWithDetails
/// method.
final class FailEchoWithDetailsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.FailEchoWithDetailsResponse';

  FailEchoWithDetailsResponse() : super(fullyQualifiedName);

  factory FailEchoWithDetailsResponse.fromJson(Map<String, dynamic> json) =>
      FailEchoWithDetailsResponse();

  @override
  Object toJson() => {};

  @override
  String toString() => 'FailEchoWithDetailsResponse()';
}

/// The request message for the Expand method.
final class ExpandRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ExpandRequest';

  /// The content that will be split into words and returned on the stream.
  final String content;

  /// The error that is thrown after all words are sent on the stream.
  final Status? error;

  /// The wait time between each server streaming messages
  final Duration? streamWaitTime;

  ExpandRequest({String? content, this.error, this.streamWaitTime})
    : content = content ?? '',
      super(fullyQualifiedName);

  factory ExpandRequest.fromJson(Map<String, dynamic> json) => ExpandRequest(
    content: json['content'] ?? '',
    error: decode(json['error'], Status.fromJson),
    streamWaitTime: decodeCustom(json['streamWaitTime'], Duration.fromJson),
  );

  @override
  Object toJson() => {
    if (content.isNotDefault) 'content': content,
    if (error != null) 'error': error!.toJson(),
    if (streamWaitTime != null) 'streamWaitTime': streamWaitTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['content=$content'].join(',');
    return 'ExpandRequest($contents)';
  }
}

/// The request for the PagedExpand method.
final class PagedExpandRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.PagedExpandRequest';

  /// The string to expand.
  final String content;

  /// The number of words to returned in each page.
  final int pageSize;

  /// The position of the page to be returned.
  final String pageToken;

  PagedExpandRequest({required this.content, int? pageSize, String? pageToken})
    : pageSize = pageSize ?? 0,
      pageToken = pageToken ?? '',
      super(fullyQualifiedName);

  factory PagedExpandRequest.fromJson(Map<String, dynamic> json) =>
      PagedExpandRequest(
        content: json['content'] ?? '',
        pageSize: json['pageSize'] ?? 0,
        pageToken: json['pageToken'] ?? '',
      );

  @override
  Object toJson() => {
    'content': content,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'content=$content',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'PagedExpandRequest($contents)';
  }
}

/// The request for the PagedExpandLegacy method.  This is a pattern used by some legacy APIs. New
/// APIs should NOT use this pattern, but rather something like PagedExpandRequest which conforms to
/// aip.dev/158.
final class PagedExpandLegacyRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.PagedExpandLegacyRequest';

  /// The string to expand.
  final String content;

  /// The number of words to returned in each page.
  /// (-- aip.dev/not-precedent: This is a legacy, non-standard pattern that
  ///     violates aip.dev/158. Ordinarily, this should be page_size. --)
  final int maxResults;

  /// The position of the page to be returned.
  final String pageToken;

  PagedExpandLegacyRequest({
    required this.content,
    int? maxResults,
    String? pageToken,
  }) : maxResults = maxResults ?? 0,
       pageToken = pageToken ?? '',
       super(fullyQualifiedName);

  factory PagedExpandLegacyRequest.fromJson(Map<String, dynamic> json) =>
      PagedExpandLegacyRequest(
        content: json['content'] ?? '',
        maxResults: json['maxResults'] ?? 0,
        pageToken: json['pageToken'] ?? '',
      );

  @override
  Object toJson() => {
    'content': content,
    if (maxResults.isNotDefault) 'maxResults': maxResults,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'content=$content',
      'maxResults=$maxResults',
      'pageToken=$pageToken',
    ].join(',');
    return 'PagedExpandLegacyRequest($contents)';
  }
}

/// The response for the PagedExpand method.
final class PagedExpandResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.PagedExpandResponse';

  /// The words that were expanded.
  final List<EchoResponse> responses;

  /// The next page token.
  final String nextPageToken;

  PagedExpandResponse({this.responses = const [], String? nextPageToken})
    : nextPageToken = nextPageToken ?? '',
      super(fullyQualifiedName);

  factory PagedExpandResponse.fromJson(Map<String, dynamic> json) =>
      PagedExpandResponse(
        responses:
            decodeListMessage(json['responses'], EchoResponse.fromJson) ?? [],
        nextPageToken: json['nextPageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (responses.isNotDefault) 'responses': encodeList(responses),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'PagedExpandResponse($contents)';
  }
}

/// A list of words.
final class PagedExpandResponseList extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.PagedExpandResponseList';

  final List<String> words;

  PagedExpandResponseList({this.words = const []}) : super(fullyQualifiedName);

  factory PagedExpandResponseList.fromJson(Map<String, dynamic> json) =>
      PagedExpandResponseList(words: decodeList(json['words']) ?? []);

  @override
  Object toJson() => {if (words.isNotDefault) 'words': words};

  @override
  String toString() => 'PagedExpandResponseList()';
}

final class PagedExpandLegacyMappedResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.PagedExpandLegacyMappedResponse';

  /// The words that were expanded, indexed by their initial character.
  /// (-- aip.dev/not-precedent: This is a legacy, non-standard pattern that violates
  ///     aip.dev/158. Ordinarily, this should be a `repeated` field, as in PagedExpandResponse. --)
  final Map<String, PagedExpandResponseList> alphabetized;

  /// The next page token.
  final String nextPageToken;

  PagedExpandLegacyMappedResponse({
    this.alphabetized = const {},
    String? nextPageToken,
  }) : nextPageToken = nextPageToken ?? '',
       super(fullyQualifiedName);

  factory PagedExpandLegacyMappedResponse.fromJson(Map<String, dynamic> json) =>
      PagedExpandLegacyMappedResponse(
        alphabetized:
            decodeMapMessage(
              json['alphabetized'],
              PagedExpandResponseList.fromJson,
            ) ??
            {},
        nextPageToken: json['nextPageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (alphabetized.isNotDefault) 'alphabetized': encodeMap(alphabetized),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'PagedExpandLegacyMappedResponse($contents)';
  }
}

/// The request for Wait method.
final class WaitRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.WaitRequest';

  /// The time that this operation will complete.
  final Timestamp? endTime;

  /// The duration of this operation.
  final Duration? ttl;

  /// The error that will be returned by the server. If this code is specified
  /// to be the OK rpc code, an empty response will be returned.
  final Status? error;

  /// The response to be returned on operation completion.
  final WaitResponse? success;

  WaitRequest({this.endTime, this.ttl, this.error, this.success})
    : super(fullyQualifiedName);

  factory WaitRequest.fromJson(Map<String, dynamic> json) => WaitRequest(
    endTime: decodeCustom(json['endTime'], Timestamp.fromJson),
    ttl: decodeCustom(json['ttl'], Duration.fromJson),
    error: decode(json['error'], Status.fromJson),
    success: decode(json['success'], WaitResponse.fromJson),
  );

  @override
  Object toJson() => {
    if (endTime != null) 'endTime': endTime!.toJson(),
    if (ttl != null) 'ttl': ttl!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (success != null) 'success': success!.toJson(),
  };

  @override
  String toString() => 'WaitRequest()';
}

/// The result of the Wait operation.
final class WaitResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.WaitResponse';

  /// This content of the result.
  final String content;

  WaitResponse({String? content})
    : content = content ?? '',
      super(fullyQualifiedName);

  factory WaitResponse.fromJson(Map<String, dynamic> json) =>
      WaitResponse(content: json['content'] ?? '');

  @override
  Object toJson() => {if (content.isNotDefault) 'content': content};

  @override
  String toString() {
    final contents = ['content=$content'].join(',');
    return 'WaitResponse($contents)';
  }
}

/// The metadata for Wait operation.
final class WaitMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.WaitMetadata';

  /// The time that this operation will complete.
  final Timestamp? endTime;

  WaitMetadata({this.endTime}) : super(fullyQualifiedName);

  factory WaitMetadata.fromJson(Map<String, dynamic> json) =>
      WaitMetadata(endTime: decodeCustom(json['endTime'], Timestamp.fromJson));

  @override
  Object toJson() => {if (endTime != null) 'endTime': endTime!.toJson()};

  @override
  String toString() => 'WaitMetadata()';
}

/// The request for Block method.
final class BlockRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.BlockRequest';

  /// The amount of time to block before returning a response.
  final Duration? responseDelay;

  /// The error that will be returned by the server. If this code is specified
  /// to be the OK rpc code, an empty response will be returned.
  final Status? error;

  /// The response to be returned that will signify successful method call.
  final BlockResponse? success;

  BlockRequest({this.responseDelay, this.error, this.success})
    : super(fullyQualifiedName);

  factory BlockRequest.fromJson(Map<String, dynamic> json) => BlockRequest(
    responseDelay: decodeCustom(json['responseDelay'], Duration.fromJson),
    error: decode(json['error'], Status.fromJson),
    success: decode(json['success'], BlockResponse.fromJson),
  );

  @override
  Object toJson() => {
    if (responseDelay != null) 'responseDelay': responseDelay!.toJson(),
    if (error != null) 'error': error!.toJson(),
    if (success != null) 'success': success!.toJson(),
  };

  @override
  String toString() => 'BlockRequest()';
}

/// The response for Block method.
final class BlockResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.BlockResponse';

  /// This content can contain anything, the server will not depend on a value
  /// here.
  final String content;

  BlockResponse({String? content})
    : content = content ?? '',
      super(fullyQualifiedName);

  factory BlockResponse.fromJson(Map<String, dynamic> json) =>
      BlockResponse(content: json['content'] ?? '');

  @override
  Object toJson() => {if (content.isNotDefault) 'content': content};

  @override
  String toString() {
    final contents = ['content=$content'].join(',');
    return 'BlockResponse($contents)';
  }
}

/// A user.
final class User extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.User';

  /// The resource name of the user.
  final String name;

  /// The display_name of the user.
  final String displayName;

  /// The email address of the user.
  final String email;

  /// The timestamp at which the user was created.
  final Timestamp? createTime;

  /// The latest timestamp at which the user was updated.
  final Timestamp? updateTime;

  /// The age of the user in years.
  final int? age;

  /// The height of the user in feet.
  final double? heightFeet;

  /// The nickname of the user.
  ///
  /// (-- aip.dev/not-precedent: An empty string is a valid nickname.
  ///     Ordinarily, proto3_optional should not be used on a `string` field. --)
  final String? nickname;

  /// Enables the receiving of notifications. The default is true if unset.
  ///
  /// (-- aip.dev/not-precedent: The default for the feature is true.
  ///     Ordinarily, the default for a `bool` field should be false. --)
  final bool? enableNotifications;

  User({
    String? name,
    required this.displayName,
    required this.email,
    this.createTime,
    this.updateTime,
    this.age,
    this.heightFeet,
    this.nickname,
    this.enableNotifications,
  }) : name = name ?? '',
       super(fullyQualifiedName);

  factory User.fromJson(Map<String, dynamic> json) => User(
    name: json['name'] ?? '',
    displayName: json['displayName'] ?? '',
    email: json['email'] ?? '',
    createTime: decodeCustom(json['createTime'], Timestamp.fromJson),
    updateTime: decodeCustom(json['updateTime'], Timestamp.fromJson),
    age: json['age'],
    heightFeet: decodeDouble(json['heightFeet']),
    nickname: json['nickname'],
    enableNotifications: json['enableNotifications'],
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    'email': email,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (age != null) 'age': age,
    if (heightFeet != null) 'heightFeet': encodeDouble(heightFeet),
    if (nickname != null) 'nickname': nickname,
    if (enableNotifications != null) 'enableNotifications': enableNotifications,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'email=$email',
      if (age != null) 'age=$age',
      if (heightFeet != null) 'heightFeet=$heightFeet',
      if (nickname != null) 'nickname=$nickname',
      if (enableNotifications != null)
        'enableNotifications=$enableNotifications',
    ].join(',');
    return 'User($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Identity\CreateUser
/// method.
final class CreateUserRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.CreateUserRequest';

  /// The user to create.
  final User? user;

  CreateUserRequest({this.user}) : super(fullyQualifiedName);

  factory CreateUserRequest.fromJson(Map<String, dynamic> json) =>
      CreateUserRequest(user: decode(json['user'], User.fromJson));

  @override
  Object toJson() => {if (user != null) 'user': user!.toJson()};

  @override
  String toString() => 'CreateUserRequest()';
}

/// The request message for the google.showcase.v1beta1.Identity\GetUser
/// method.
final class GetUserRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.GetUserRequest';

  /// The resource name of the requested user.
  final String name;

  GetUserRequest({required this.name}) : super(fullyQualifiedName);

  factory GetUserRequest.fromJson(Map<String, dynamic> json) =>
      GetUserRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetUserRequest($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Identity\UpdateUser
/// method.
final class UpdateUserRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.UpdateUserRequest';

  /// The user to update.
  final User? user;

  /// The field mask to determine which fields are to be updated. If empty, the
  /// server will assume all fields are to be updated.
  final FieldMask? updateMask;

  UpdateUserRequest({this.user, this.updateMask}) : super(fullyQualifiedName);

  factory UpdateUserRequest.fromJson(Map<String, dynamic> json) =>
      UpdateUserRequest(
        user: decode(json['user'], User.fromJson),
        updateMask: decodeCustom(json['updateMask'], FieldMask.fromJson),
      );

  @override
  Object toJson() => {
    if (user != null) 'user': user!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateUserRequest()';
}

/// The request message for the google.showcase.v1beta1.Identity\DeleteUser
/// method.
final class DeleteUserRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.DeleteUserRequest';

  /// The resource name of the user to delete.
  final String name;

  DeleteUserRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteUserRequest.fromJson(Map<String, dynamic> json) =>
      DeleteUserRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteUserRequest($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Identity\ListUsers
/// method.
final class ListUsersRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListUsersRequest';

  /// The maximum number of users to return. Server may return fewer users
  /// than requested. If unspecified, server will pick an appropriate default.
  final int pageSize;

  /// The value of google.showcase.v1beta1.ListUsersResponse.next_page_token
  /// returned from the previous call to
  /// `google.showcase.v1beta1.Identity\ListUsers` method.
  final String pageToken;

  ListUsersRequest({int? pageSize, String? pageToken})
    : pageSize = pageSize ?? 0,
      pageToken = pageToken ?? '',
      super(fullyQualifiedName);

  factory ListUsersRequest.fromJson(Map<String, dynamic> json) =>
      ListUsersRequest(
        pageSize: json['pageSize'] ?? 0,
        pageToken: json['pageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = ['pageSize=$pageSize', 'pageToken=$pageToken'].join(',');
    return 'ListUsersRequest($contents)';
  }
}

/// The response message for the google.showcase.v1beta1.Identity\ListUsers
/// method.
final class ListUsersResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListUsersResponse';

  /// The list of users.
  final List<User> users;

  /// A token to retrieve next page of results.
  /// Pass this value in ListUsersRequest.page_token field in the subsequent
  /// call to `google.showcase.v1beta1.Message\ListUsers` method to retrieve the
  /// next page of results.
  final String nextPageToken;

  ListUsersResponse({this.users = const [], String? nextPageToken})
    : nextPageToken = nextPageToken ?? '',
      super(fullyQualifiedName);

  factory ListUsersResponse.fromJson(Map<String, dynamic> json) =>
      ListUsersResponse(
        users: decodeListMessage(json['users'], User.fromJson) ?? [],
        nextPageToken: json['nextPageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (users.isNotDefault) 'users': encodeList(users),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListUsersResponse($contents)';
  }
}

/// A chat room.
final class Room extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.Room';

  /// The resource name of the chat room.
  final String name;

  /// The human readable name of the chat room.
  final String displayName;

  /// The description of the chat room.
  final String description;

  /// The timestamp at which the room was created.
  final Timestamp? createTime;

  /// The latest timestamp at which the room was updated.
  final Timestamp? updateTime;

  Room({
    String? name,
    required this.displayName,
    String? description,
    this.createTime,
    this.updateTime,
  }) : name = name ?? '',
       description = description ?? '',
       super(fullyQualifiedName);

  factory Room.fromJson(Map<String, dynamic> json) => Room(
    name: json['name'] ?? '',
    displayName: json['displayName'] ?? '',
    description: json['description'] ?? '',
    createTime: decodeCustom(json['createTime'], Timestamp.fromJson),
    updateTime: decodeCustom(json['updateTime'], Timestamp.fromJson),
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'displayName': displayName,
    if (description.isNotDefault) 'description': description,
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'displayName=$displayName',
      'description=$description',
    ].join(',');
    return 'Room($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\CreateRoom
/// method.
final class CreateRoomRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.CreateRoomRequest';

  /// The room to create.
  final Room? room;

  CreateRoomRequest({this.room}) : super(fullyQualifiedName);

  factory CreateRoomRequest.fromJson(Map<String, dynamic> json) =>
      CreateRoomRequest(room: decode(json['room'], Room.fromJson));

  @override
  Object toJson() => {if (room != null) 'room': room!.toJson()};

  @override
  String toString() => 'CreateRoomRequest()';
}

/// The request message for the google.showcase.v1beta1.Messaging\GetRoom
/// method.
final class GetRoomRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.GetRoomRequest';

  /// The resource name of the requested room.
  final String name;

  GetRoomRequest({required this.name}) : super(fullyQualifiedName);

  factory GetRoomRequest.fromJson(Map<String, dynamic> json) =>
      GetRoomRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetRoomRequest($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\UpdateRoom
/// method.
final class UpdateRoomRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.UpdateRoomRequest';

  /// The room to update.
  final Room? room;

  /// The field mask to determine which fields are to be updated. If empty, the
  /// server will assume all fields are to be updated.
  final FieldMask? updateMask;

  UpdateRoomRequest({this.room, this.updateMask}) : super(fullyQualifiedName);

  factory UpdateRoomRequest.fromJson(Map<String, dynamic> json) =>
      UpdateRoomRequest(
        room: decode(json['room'], Room.fromJson),
        updateMask: decodeCustom(json['updateMask'], FieldMask.fromJson),
      );

  @override
  Object toJson() => {
    if (room != null) 'room': room!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateRoomRequest()';
}

/// The request message for the google.showcase.v1beta1.Messaging\DeleteRoom
/// method.
final class DeleteRoomRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.DeleteRoomRequest';

  /// The resource name of the requested room.
  final String name;

  DeleteRoomRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteRoomRequest.fromJson(Map<String, dynamic> json) =>
      DeleteRoomRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteRoomRequest($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\ListRooms
/// method.
final class ListRoomsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListRoomsRequest';

  /// The maximum number of rooms return. Server may return fewer rooms
  /// than requested. If unspecified, server will pick an appropriate default.
  final int pageSize;

  /// The value of google.showcase.v1beta1.ListRoomsResponse.next_page_token
  /// returned from the previous call to
  /// `google.showcase.v1beta1.Messaging\ListRooms` method.
  final String pageToken;

  ListRoomsRequest({int? pageSize, String? pageToken})
    : pageSize = pageSize ?? 0,
      pageToken = pageToken ?? '',
      super(fullyQualifiedName);

  factory ListRoomsRequest.fromJson(Map<String, dynamic> json) =>
      ListRoomsRequest(
        pageSize: json['pageSize'] ?? 0,
        pageToken: json['pageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = ['pageSize=$pageSize', 'pageToken=$pageToken'].join(',');
    return 'ListRoomsRequest($contents)';
  }
}

/// The response message for the google.showcase.v1beta1.Messaging\ListRooms
/// method.
final class ListRoomsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListRoomsResponse';

  /// The list of rooms.
  final List<Room> rooms;

  /// A token to retrieve next page of results.
  /// Pass this value in ListRoomsRequest.page_token field in the subsequent
  /// call to `google.showcase.v1beta1.Messaging\ListRooms` method to retrieve
  /// the next page of results.
  final String nextPageToken;

  ListRoomsResponse({this.rooms = const [], String? nextPageToken})
    : nextPageToken = nextPageToken ?? '',
      super(fullyQualifiedName);

  factory ListRoomsResponse.fromJson(Map<String, dynamic> json) =>
      ListRoomsResponse(
        rooms: decodeListMessage(json['rooms'], Room.fromJson) ?? [],
        nextPageToken: json['nextPageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (rooms.isNotDefault) 'rooms': encodeList(rooms),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListRoomsResponse($contents)';
  }
}

/// This protocol buffer message represents a blurb sent to a chat room or
/// posted on a user profile.
final class Blurb extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.Blurb';

  /// The resource name of the chat room.
  final String name;

  /// The resource name of the blurb's author.
  final String user;

  /// The textual content of this blurb.
  final String? text;

  /// The image content of this blurb.
  final Uint8List? image;

  /// The timestamp at which the blurb was created.
  final Timestamp? createTime;

  /// The latest timestamp at which the blurb was updated.
  final Timestamp? updateTime;

  /// The legacy id of the room. This field is used to signal
  /// the use of the compound resource pattern
  /// `rooms/{room}/blurbs/legacy/{legacy_room}.{blurb}`
  final String? legacyRoomId;

  /// The legacy id of the user. This field is used to signal
  /// the use of the compound resource pattern
  /// `users/{user}/profile/blurbs/legacy/{legacy_user}~{blurb}`
  final String? legacyUserId;

  Blurb({
    String? name,
    required this.user,
    this.text,
    this.image,
    this.createTime,
    this.updateTime,
    this.legacyRoomId,
    this.legacyUserId,
  }) : name = name ?? '',
       super(fullyQualifiedName);

  factory Blurb.fromJson(Map<String, dynamic> json) => Blurb(
    name: json['name'] ?? '',
    user: json['user'] ?? '',
    text: json['text'],
    image: decodeBytes(json['image']),
    createTime: decodeCustom(json['createTime'], Timestamp.fromJson),
    updateTime: decodeCustom(json['updateTime'], Timestamp.fromJson),
    legacyRoomId: json['legacyRoomId'],
    legacyUserId: json['legacyUserId'],
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    'user': user,
    if (text != null) 'text': text,
    if (image != null) 'image': encodeBytes(image),
    if (createTime != null) 'createTime': createTime!.toJson(),
    if (updateTime != null) 'updateTime': updateTime!.toJson(),
    if (legacyRoomId != null) 'legacyRoomId': legacyRoomId,
    if (legacyUserId != null) 'legacyUserId': legacyUserId,
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'user=$user',
      if (text != null) 'text=$text',
      if (image != null) 'image=$image',
      if (legacyRoomId != null) 'legacyRoomId=$legacyRoomId',
      if (legacyUserId != null) 'legacyUserId=$legacyUserId',
    ].join(',');
    return 'Blurb($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\CreateBlurb
/// method.
final class CreateBlurbRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.CreateBlurbRequest';

  /// The resource name of the chat room or user profile that this blurb will
  /// be tied to.
  final String parent;

  /// The blurb to create.
  final Blurb? blurb;

  CreateBlurbRequest({required this.parent, this.blurb})
    : super(fullyQualifiedName);

  factory CreateBlurbRequest.fromJson(Map<String, dynamic> json) =>
      CreateBlurbRequest(
        parent: json['parent'] ?? '',
        blurb: decode(json['blurb'], Blurb.fromJson),
      );

  @override
  Object toJson() => {
    'parent': parent,
    if (blurb != null) 'blurb': blurb!.toJson(),
  };

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'CreateBlurbRequest($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\GetBlurb
/// method.
final class GetBlurbRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.GetBlurbRequest';

  /// The resource name of the requested blurb.
  final String name;

  GetBlurbRequest({required this.name}) : super(fullyQualifiedName);

  factory GetBlurbRequest.fromJson(Map<String, dynamic> json) =>
      GetBlurbRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetBlurbRequest($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\UpdateBlurb
/// method.
final class UpdateBlurbRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.UpdateBlurbRequest';

  /// The blurb to update.
  final Blurb? blurb;

  /// The field mask to determine which fields are to be updated. If empty, the
  /// server will assume all fields are to be updated.
  final FieldMask? updateMask;

  UpdateBlurbRequest({this.blurb, this.updateMask}) : super(fullyQualifiedName);

  factory UpdateBlurbRequest.fromJson(Map<String, dynamic> json) =>
      UpdateBlurbRequest(
        blurb: decode(json['blurb'], Blurb.fromJson),
        updateMask: decodeCustom(json['updateMask'], FieldMask.fromJson),
      );

  @override
  Object toJson() => {
    if (blurb != null) 'blurb': blurb!.toJson(),
    if (updateMask != null) 'updateMask': updateMask!.toJson(),
  };

  @override
  String toString() => 'UpdateBlurbRequest()';
}

/// The request message for the google.showcase.v1beta1.Messaging\DeleteBlurb
/// method.
final class DeleteBlurbRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.DeleteBlurbRequest';

  /// The resource name of the requested blurb.
  final String name;

  DeleteBlurbRequest({required this.name}) : super(fullyQualifiedName);

  factory DeleteBlurbRequest.fromJson(Map<String, dynamic> json) =>
      DeleteBlurbRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteBlurbRequest($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\ListBlurbs
/// method.
final class ListBlurbsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListBlurbsRequest';

  /// The resource name of the requested room or profile who blurbs to list.
  final String parent;

  /// The maximum number of blurbs to return. Server may return fewer
  /// blurbs than requested. If unspecified, server will pick an appropriate
  /// default.
  final int pageSize;

  /// The value of google.showcase.v1beta1.ListBlurbsResponse.next_page_token
  /// returned from the previous call to
  /// `google.showcase.v1beta1.Messaging\ListBlurbs` method.
  final String pageToken;

  ListBlurbsRequest({required this.parent, int? pageSize, String? pageToken})
    : pageSize = pageSize ?? 0,
      pageToken = pageToken ?? '',
      super(fullyQualifiedName);

  factory ListBlurbsRequest.fromJson(Map<String, dynamic> json) =>
      ListBlurbsRequest(
        parent: json['parent'] ?? '',
        pageSize: json['pageSize'] ?? 0,
        pageToken: json['pageToken'] ?? '',
      );

  @override
  Object toJson() => {
    'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListBlurbsRequest($contents)';
  }
}

/// The response message for the google.showcase.v1beta1.Messaging\ListBlurbs
/// method.
final class ListBlurbsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListBlurbsResponse';

  /// The list of blurbs.
  final List<Blurb> blurbs;

  /// A token to retrieve next page of results.
  /// Pass this value in ListBlurbsRequest.page_token field in the subsequent
  /// call to `google.showcase.v1beta1.Blurb\ListBlurbs` method to retrieve
  /// the next page of results.
  final String nextPageToken;

  ListBlurbsResponse({this.blurbs = const [], String? nextPageToken})
    : nextPageToken = nextPageToken ?? '',
      super(fullyQualifiedName);

  factory ListBlurbsResponse.fromJson(Map<String, dynamic> json) =>
      ListBlurbsResponse(
        blurbs: decodeListMessage(json['blurbs'], Blurb.fromJson) ?? [],
        nextPageToken: json['nextPageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (blurbs.isNotDefault) 'blurbs': encodeList(blurbs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListBlurbsResponse($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\SearchBlurbs
/// method.
final class SearchBlurbsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.SearchBlurbsRequest';

  /// The query used to search for blurbs containing to words of this string.
  /// Only posts that contain an exact match of a queried word will be returned.
  final String query;

  /// The rooms or profiles to search. If unset, `SearchBlurbs` will search all
  /// rooms and all profiles.
  final String parent;

  /// The maximum number of blurbs return. Server may return fewer
  /// blurbs than requested. If unspecified, server will pick an appropriate
  /// default.
  final int pageSize;

  /// The value of
  /// google.showcase.v1beta1.SearchBlurbsResponse.next_page_token
  /// returned from the previous call to
  /// `google.showcase.v1beta1.Messaging\SearchBlurbs` method.
  final String pageToken;

  SearchBlurbsRequest({
    required this.query,
    String? parent,
    int? pageSize,
    String? pageToken,
  }) : parent = parent ?? '',
       pageSize = pageSize ?? 0,
       pageToken = pageToken ?? '',
       super(fullyQualifiedName);

  factory SearchBlurbsRequest.fromJson(Map<String, dynamic> json) =>
      SearchBlurbsRequest(
        query: json['query'] ?? '',
        parent: json['parent'] ?? '',
        pageSize: json['pageSize'] ?? 0,
        pageToken: json['pageToken'] ?? '',
      );

  @override
  Object toJson() => {
    'query': query,
    if (parent.isNotDefault) 'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'query=$query',
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'SearchBlurbsRequest($contents)';
  }
}

/// The operation metadata message for the
/// google.showcase.v1beta1.Messaging\SearchBlurbs method.
final class SearchBlurbsMetadata extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.SearchBlurbsMetadata';

  /// This signals to the client when to next poll for response.
  final RetryInfo? retryInfo;

  SearchBlurbsMetadata({this.retryInfo}) : super(fullyQualifiedName);

  factory SearchBlurbsMetadata.fromJson(Map<String, dynamic> json) =>
      SearchBlurbsMetadata(
        retryInfo: decode(json['retryInfo'], RetryInfo.fromJson),
      );

  @override
  Object toJson() => {if (retryInfo != null) 'retryInfo': retryInfo!.toJson()};

  @override
  String toString() => 'SearchBlurbsMetadata()';
}

/// The operation response message for the
/// google.showcase.v1beta1.Messaging\SearchBlurbs method.
final class SearchBlurbsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.SearchBlurbsResponse';

  /// Blurbs that matched the search query.
  final List<Blurb> blurbs;

  /// A token to retrieve next page of results.
  /// Pass this value in SearchBlurbsRequest.page_token field in the subsequent
  /// call to `google.showcase.v1beta1.Blurb\SearchBlurbs` method to
  /// retrieve the next page of results.
  final String nextPageToken;

  SearchBlurbsResponse({this.blurbs = const [], String? nextPageToken})
    : nextPageToken = nextPageToken ?? '',
      super(fullyQualifiedName);

  factory SearchBlurbsResponse.fromJson(Map<String, dynamic> json) =>
      SearchBlurbsResponse(
        blurbs: decodeListMessage(json['blurbs'], Blurb.fromJson) ?? [],
        nextPageToken: json['nextPageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (blurbs.isNotDefault) 'blurbs': encodeList(blurbs),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'SearchBlurbsResponse($contents)';
  }
}

/// The request message for the google.showcase.v1beta1.Messaging\StreamBlurbs
/// method.
final class StreamBlurbsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.StreamBlurbsRequest';

  /// The resource name of a chat room or user profile whose blurbs to stream.
  final String name;

  /// The time at which this stream will close.
  final Timestamp? expireTime;

  StreamBlurbsRequest({required this.name, required this.expireTime})
    : super(fullyQualifiedName);

  factory StreamBlurbsRequest.fromJson(Map<String, dynamic> json) =>
      StreamBlurbsRequest(
        name: json['name'] ?? '',
        expireTime: decodeCustom(json['expireTime'], Timestamp.fromJson),
      );

  @override
  Object toJson() => {
    'name': name,
    if (expireTime != null) 'expireTime': expireTime!.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StreamBlurbsRequest($contents)';
  }
}

/// The response message for the google.showcase.v1beta1.Messaging\StreamBlurbs
/// method.
final class StreamBlurbsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.StreamBlurbsResponse';

  /// The blurb that was either created, updated, or deleted.
  final Blurb? blurb;

  /// The action that triggered the blurb to be returned.
  final StreamBlurbsResponse_Action action;

  StreamBlurbsResponse({
    this.blurb,
    this.action = StreamBlurbsResponse_Action.$default,
  }) : super(fullyQualifiedName);

  factory StreamBlurbsResponse.fromJson(Map<String, dynamic> json) =>
      StreamBlurbsResponse(
        blurb: decode(json['blurb'], Blurb.fromJson),
        action:
            decodeEnum(json['action'], StreamBlurbsResponse_Action.fromJson) ??
            StreamBlurbsResponse_Action.$default,
      );

  @override
  Object toJson() => {
    if (blurb != null) 'blurb': blurb!.toJson(),
    if (action.isNotDefault) 'action': action.toJson(),
  };

  @override
  String toString() {
    final contents = ['action=$action'].join(',');
    return 'StreamBlurbsResponse($contents)';
  }
}

/// The action that triggered the blurb to be returned.
final class StreamBlurbsResponse_Action extends ProtoEnum {
  static const actionUnspecified = StreamBlurbsResponse_Action(
    'ACTION_UNSPECIFIED',
  );

  /// Specifies that the blurb was created.
  static const create = StreamBlurbsResponse_Action('CREATE');

  /// Specifies that the blurb was updated.
  static const update = StreamBlurbsResponse_Action('UPDATE');

  /// Specifies that the blurb was deleted.
  static const delete = StreamBlurbsResponse_Action('DELETE');

  /// The default value for [StreamBlurbsResponse_Action].
  static const $default = actionUnspecified;

  const StreamBlurbsResponse_Action(super.value);

  factory StreamBlurbsResponse_Action.fromJson(String json) =>
      StreamBlurbsResponse_Action(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Action.$value';
}

/// The response message for the google.showcase.v1beta1.Messaging\SendBlurbs
/// method.
final class SendBlurbsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.SendBlurbsResponse';

  /// The names of successful blurb creations.
  final List<String> names;

  SendBlurbsResponse({this.names = const []}) : super(fullyQualifiedName);

  factory SendBlurbsResponse.fromJson(Map<String, dynamic> json) =>
      SendBlurbsResponse(names: decodeList(json['names']) ?? []);

  @override
  Object toJson() => {if (names.isNotDefault) 'names': names};

  @override
  String toString() => 'SendBlurbsResponse()';
}

/// The request message for the google.showcase.v1beta1.Messaging\Connect
/// method.
final class ConnectRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ConnectRequest';

  /// Provides information that specifies how to process subsequent requests.
  /// The first `ConnectRequest` message must contain a `config`  message.
  final ConnectRequest_ConnectConfig? config;

  /// The blurb to be created.
  final Blurb? blurb;

  ConnectRequest({this.config, this.blurb}) : super(fullyQualifiedName);

  factory ConnectRequest.fromJson(Map<String, dynamic> json) => ConnectRequest(
    config: decode(json['config'], ConnectRequest_ConnectConfig.fromJson),
    blurb: decode(json['blurb'], Blurb.fromJson),
  );

  @override
  Object toJson() => {
    if (config != null) 'config': config!.toJson(),
    if (blurb != null) 'blurb': blurb!.toJson(),
  };

  @override
  String toString() => 'ConnectRequest()';
}

final class ConnectRequest_ConnectConfig extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ConnectRequest.ConnectConfig';

  /// The room or profile to follow and create messages for.
  final String parent;

  ConnectRequest_ConnectConfig({String? parent})
    : parent = parent ?? '',
      super(fullyQualifiedName);

  factory ConnectRequest_ConnectConfig.fromJson(Map<String, dynamic> json) =>
      ConnectRequest_ConnectConfig(parent: json['parent'] ?? '');

  @override
  Object toJson() => {if (parent.isNotDefault) 'parent': parent};

  @override
  String toString() {
    final contents = ['parent=$parent'].join(',');
    return 'ConnectConfig($contents)';
  }
}

/// HTTP/JSON error representation as defined in
/// https://google.aip.dev/193#http11json-representation,
final class RestError extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.RestError';

  final RestError_Status? error;

  RestError({this.error}) : super(fullyQualifiedName);

  factory RestError.fromJson(Map<String, dynamic> json) =>
      RestError(error: decode(json['error'], RestError_Status.fromJson));

  @override
  Object toJson() => {if (error != null) 'error': error!.toJson()};

  @override
  String toString() => 'RestError()';
}

final class RestError_Status extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.RestError.Status';

  /// The HTTP status code that corresponds to `google.rpc.Status.code`.
  final int code;

  /// This corresponds to `google.rpc.Status.message`.
  final String message;

  /// This is the enum version for `google.rpc.Status.code`.
  final Code status;

  /// This corresponds to `google.rpc.Status.details`.
  final List<Any> details;

  RestError_Status({
    int? code,
    String? message,
    this.status = Code.$default,
    this.details = const [],
  }) : code = code ?? 0,
       message = message ?? '',
       super(fullyQualifiedName);

  factory RestError_Status.fromJson(Map<String, dynamic> json) =>
      RestError_Status(
        code: json['code'] ?? 0,
        message: json['message'] ?? '',
        status: decodeEnum(json['status'], Code.fromJson) ?? Code.$default,
        details: decodeListMessage(json['details'], Any.fromJson) ?? [],
      );

  @override
  Object toJson() => {
    if (code.isNotDefault) 'code': code,
    if (message.isNotDefault) 'message': message,
    if (status.isNotDefault) 'status': status.toJson(),
    if (details.isNotDefault) 'details': encodeList(details),
  };

  @override
  String toString() {
    final contents = [
      'code=$code',
      'message=$message',
      'status=$status',
    ].join(',');
    return 'Status($contents)';
  }
}

final class Sequence extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.Sequence';

  final String name;

  /// Sequence of responses to return in order for each attempt. If empty, the
  /// default response is an immediate OK.
  final List<Sequence_Response> responses;

  Sequence({String? name, this.responses = const []})
    : name = name ?? '',
      super(fullyQualifiedName);

  factory Sequence.fromJson(Map<String, dynamic> json) => Sequence(
    name: json['name'] ?? '',
    responses:
        decodeListMessage(json['responses'], Sequence_Response.fromJson) ?? [],
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (responses.isNotDefault) 'responses': encodeList(responses),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'Sequence($contents)';
  }
}

/// A server response to an RPC Attempt in a sequence.
final class Sequence_Response extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.Sequence.Response';

  /// The status to return for an individual attempt.
  final Status? status;

  /// The amount of time to delay sending the response.
  final Duration? delay;

  Sequence_Response({this.status, this.delay}) : super(fullyQualifiedName);

  factory Sequence_Response.fromJson(Map<String, dynamic> json) =>
      Sequence_Response(
        status: decode(json['status'], Status.fromJson),
        delay: decodeCustom(json['delay'], Duration.fromJson),
      );

  @override
  Object toJson() => {
    if (status != null) 'status': status!.toJson(),
    if (delay != null) 'delay': delay!.toJson(),
  };

  @override
  String toString() => 'Response()';
}

final class StreamingSequence extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.StreamingSequence';

  final String name;

  /// The Content that the stream will send
  final String content;

  /// Sequence of responses to return in order for each attempt. If empty, the
  /// default response is an immediate OK.
  final List<StreamingSequence_Response> responses;

  StreamingSequence({String? name, String? content, this.responses = const []})
    : name = name ?? '',
      content = content ?? '',
      super(fullyQualifiedName);

  factory StreamingSequence.fromJson(Map<String, dynamic> json) =>
      StreamingSequence(
        name: json['name'] ?? '',
        content: json['content'] ?? '',
        responses:
            decodeListMessage(
              json['responses'],
              StreamingSequence_Response.fromJson,
            ) ??
            [],
      );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (content.isNotDefault) 'content': content,
    if (responses.isNotDefault) 'responses': encodeList(responses),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'content=$content'].join(',');
    return 'StreamingSequence($contents)';
  }
}

/// A server response to an RPC Attempt in a sequence.
final class StreamingSequence_Response extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.StreamingSequence.Response';

  /// The status to return for an individual attempt.
  final Status? status;

  /// The amount of time to delay sending the response.
  final Duration? delay;

  /// The index that the status should be sent
  final int responseIndex;

  StreamingSequence_Response({this.status, this.delay, int? responseIndex})
    : responseIndex = responseIndex ?? 0,
      super(fullyQualifiedName);

  factory StreamingSequence_Response.fromJson(Map<String, dynamic> json) =>
      StreamingSequence_Response(
        status: decode(json['status'], Status.fromJson),
        delay: decodeCustom(json['delay'], Duration.fromJson),
        responseIndex: json['responseIndex'] ?? 0,
      );

  @override
  Object toJson() => {
    if (status != null) 'status': status!.toJson(),
    if (delay != null) 'delay': delay!.toJson(),
    if (responseIndex.isNotDefault) 'responseIndex': responseIndex,
  };

  @override
  String toString() {
    final contents = ['responseIndex=$responseIndex'].join(',');
    return 'Response($contents)';
  }
}

final class StreamingSequenceReport extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.StreamingSequenceReport';

  final String name;

  /// The set of RPC attempts received by the server for a Sequence.
  final List<StreamingSequenceReport_Attempt> attempts;

  StreamingSequenceReport({String? name, this.attempts = const []})
    : name = name ?? '',
      super(fullyQualifiedName);

  factory StreamingSequenceReport.fromJson(Map<String, dynamic> json) =>
      StreamingSequenceReport(
        name: json['name'] ?? '',
        attempts:
            decodeListMessage(
              json['attempts'],
              StreamingSequenceReport_Attempt.fromJson,
            ) ??
            [],
      );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (attempts.isNotDefault) 'attempts': encodeList(attempts),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'StreamingSequenceReport($contents)';
  }
}

/// Contains metrics on individual RPC Attempts in a sequence.
final class StreamingSequenceReport_Attempt extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.StreamingSequenceReport.Attempt';

  /// The attempt number - starting at 0.
  final int attemptNumber;

  /// The deadline dictated by the attempt to the server.
  final Timestamp? attemptDeadline;

  /// The time that the server responded to the RPC attempt. Used for
  /// calculating attempt_delay.
  final Timestamp? responseTime;

  /// The server perceived delay between sending the last response and
  /// receiving this attempt. Used for validating attempt delay backoff.
  final Duration? attemptDelay;

  /// The status returned to the attempt.
  final Status? status;

  StreamingSequenceReport_Attempt({
    int? attemptNumber,
    this.attemptDeadline,
    this.responseTime,
    this.attemptDelay,
    this.status,
  }) : attemptNumber = attemptNumber ?? 0,
       super(fullyQualifiedName);

  factory StreamingSequenceReport_Attempt.fromJson(Map<String, dynamic> json) =>
      StreamingSequenceReport_Attempt(
        attemptNumber: json['attemptNumber'] ?? 0,
        attemptDeadline: decodeCustom(
          json['attemptDeadline'],
          Timestamp.fromJson,
        ),
        responseTime: decodeCustom(json['responseTime'], Timestamp.fromJson),
        attemptDelay: decodeCustom(json['attemptDelay'], Duration.fromJson),
        status: decode(json['status'], Status.fromJson),
      );

  @override
  Object toJson() => {
    if (attemptNumber.isNotDefault) 'attemptNumber': attemptNumber,
    if (attemptDeadline != null) 'attemptDeadline': attemptDeadline!.toJson(),
    if (responseTime != null) 'responseTime': responseTime!.toJson(),
    if (attemptDelay != null) 'attemptDelay': attemptDelay!.toJson(),
    if (status != null) 'status': status!.toJson(),
  };

  @override
  String toString() {
    final contents = ['attemptNumber=$attemptNumber'].join(',');
    return 'Attempt($contents)';
  }
}

final class SequenceReport extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.SequenceReport';

  final String name;

  /// The set of RPC attempts received by the server for a Sequence.
  final List<SequenceReport_Attempt> attempts;

  SequenceReport({String? name, this.attempts = const []})
    : name = name ?? '',
      super(fullyQualifiedName);

  factory SequenceReport.fromJson(Map<String, dynamic> json) => SequenceReport(
    name: json['name'] ?? '',
    attempts:
        decodeListMessage(json['attempts'], SequenceReport_Attempt.fromJson) ??
        [],
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (attempts.isNotDefault) 'attempts': encodeList(attempts),
  };

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'SequenceReport($contents)';
  }
}

/// Contains metrics on individual RPC Attempts in a sequence.
final class SequenceReport_Attempt extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.SequenceReport.Attempt';

  /// The attempt number - starting at 0.
  final int attemptNumber;

  /// The deadline dictated by the attempt to the server.
  final Timestamp? attemptDeadline;

  /// The time that the server responded to the RPC attempt. Used for
  /// calculating attempt_delay.
  final Timestamp? responseTime;

  /// The server perceived delay between sending the last response and
  /// receiving this attempt. Used for validating attempt delay backoff.
  final Duration? attemptDelay;

  /// The status returned to the attempt.
  final Status? status;

  SequenceReport_Attempt({
    int? attemptNumber,
    this.attemptDeadline,
    this.responseTime,
    this.attemptDelay,
    this.status,
  }) : attemptNumber = attemptNumber ?? 0,
       super(fullyQualifiedName);

  factory SequenceReport_Attempt.fromJson(Map<String, dynamic> json) =>
      SequenceReport_Attempt(
        attemptNumber: json['attemptNumber'] ?? 0,
        attemptDeadline: decodeCustom(
          json['attemptDeadline'],
          Timestamp.fromJson,
        ),
        responseTime: decodeCustom(json['responseTime'], Timestamp.fromJson),
        attemptDelay: decodeCustom(json['attemptDelay'], Duration.fromJson),
        status: decode(json['status'], Status.fromJson),
      );

  @override
  Object toJson() => {
    if (attemptNumber.isNotDefault) 'attemptNumber': attemptNumber,
    if (attemptDeadline != null) 'attemptDeadline': attemptDeadline!.toJson(),
    if (responseTime != null) 'responseTime': responseTime!.toJson(),
    if (attemptDelay != null) 'attemptDelay': attemptDelay!.toJson(),
    if (status != null) 'status': status!.toJson(),
  };

  @override
  String toString() {
    final contents = ['attemptNumber=$attemptNumber'].join(',');
    return 'Attempt($contents)';
  }
}

final class CreateSequenceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.CreateSequenceRequest';

  final Sequence? sequence;

  CreateSequenceRequest({this.sequence}) : super(fullyQualifiedName);

  factory CreateSequenceRequest.fromJson(Map<String, dynamic> json) =>
      CreateSequenceRequest(
        sequence: decode(json['sequence'], Sequence.fromJson),
      );

  @override
  Object toJson() => {if (sequence != null) 'sequence': sequence!.toJson()};

  @override
  String toString() => 'CreateSequenceRequest()';
}

final class CreateStreamingSequenceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.CreateStreamingSequenceRequest';

  final StreamingSequence? streamingSequence;

  CreateStreamingSequenceRequest({this.streamingSequence})
    : super(fullyQualifiedName);

  factory CreateStreamingSequenceRequest.fromJson(Map<String, dynamic> json) =>
      CreateStreamingSequenceRequest(
        streamingSequence: decode(
          json['streamingSequence'],
          StreamingSequence.fromJson,
        ),
      );

  @override
  Object toJson() => {
    if (streamingSequence != null)
      'streamingSequence': streamingSequence!.toJson(),
  };

  @override
  String toString() => 'CreateStreamingSequenceRequest()';
}

final class AttemptSequenceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.AttemptSequenceRequest';

  final String name;

  AttemptSequenceRequest({required this.name}) : super(fullyQualifiedName);

  factory AttemptSequenceRequest.fromJson(Map<String, dynamic> json) =>
      AttemptSequenceRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'AttemptSequenceRequest($contents)';
  }
}

final class AttemptStreamingSequenceRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.AttemptStreamingSequenceRequest';

  final String name;

  /// used to send the index of the last failed message
  /// in the string "content" of an AttemptStreamingSequenceResponse
  /// needed for stream resumption logic testing
  final int lastFailIndex;

  AttemptStreamingSequenceRequest({required this.name, int? lastFailIndex})
    : lastFailIndex = lastFailIndex ?? 0,
      super(fullyQualifiedName);

  factory AttemptStreamingSequenceRequest.fromJson(Map<String, dynamic> json) =>
      AttemptStreamingSequenceRequest(
        name: json['name'] ?? '',
        lastFailIndex: json['lastFailIndex'] ?? 0,
      );

  @override
  Object toJson() => {
    'name': name,
    if (lastFailIndex.isNotDefault) 'lastFailIndex': lastFailIndex,
  };

  @override
  String toString() {
    final contents = ['name=$name', 'lastFailIndex=$lastFailIndex'].join(',');
    return 'AttemptStreamingSequenceRequest($contents)';
  }
}

/// The response message for the Echo methods.
final class AttemptStreamingSequenceResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.AttemptStreamingSequenceResponse';

  /// The content specified in the request.
  final String content;

  AttemptStreamingSequenceResponse({String? content})
    : content = content ?? '',
      super(fullyQualifiedName);

  factory AttemptStreamingSequenceResponse.fromJson(
    Map<String, dynamic> json,
  ) => AttemptStreamingSequenceResponse(content: json['content'] ?? '');

  @override
  Object toJson() => {if (content.isNotDefault) 'content': content};

  @override
  String toString() {
    final contents = ['content=$content'].join(',');
    return 'AttemptStreamingSequenceResponse($contents)';
  }
}

final class GetSequenceReportRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.GetSequenceReportRequest';

  final String name;

  GetSequenceReportRequest({required this.name}) : super(fullyQualifiedName);

  factory GetSequenceReportRequest.fromJson(Map<String, dynamic> json) =>
      GetSequenceReportRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetSequenceReportRequest($contents)';
  }
}

final class GetStreamingSequenceReportRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.GetStreamingSequenceReportRequest';

  final String name;

  GetStreamingSequenceReportRequest({required this.name})
    : super(fullyQualifiedName);

  factory GetStreamingSequenceReportRequest.fromJson(
    Map<String, dynamic> json,
  ) => GetStreamingSequenceReportRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetStreamingSequenceReportRequest($contents)';
  }
}

/// A session is a suite of tests, generally being made in the context
/// of testing code generation.
///
/// A session defines tests it may expect, based on which version of the
/// code generation spec is in use.
final class Session extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.Session';

  /// The name of the session. The ID must conform to ^[a-z]+$
  /// If this is not provided, Showcase chooses one at random.
  final String name;

  /// Required. The version this session is using.
  final Session_Version version;

  Session({String? name, this.version = Session_Version.$default})
    : name = name ?? '',
      super(fullyQualifiedName);

  factory Session.fromJson(Map<String, dynamic> json) => Session(
    name: json['name'] ?? '',
    version:
        decodeEnum(json['version'], Session_Version.fromJson) ??
        Session_Version.$default,
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (version.isNotDefault) 'version': version.toJson(),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'version=$version'].join(',');
    return 'Session($contents)';
  }
}

/// The specification versions understood by Showcase.
final class Session_Version extends ProtoEnum {
  /// Unspecified version. If passed on creation, the session will default
  /// to using the latest stable release.
  static const versionUnspecified = Session_Version('VERSION_UNSPECIFIED');

  /// The latest v1. Currently, this is v1.0.
  static const v1Latest = Session_Version('V1_LATEST');

  /// v1.0. (Until the spec is "GA", this will be a moving target.)
  static const v10 = Session_Version('V1_0');

  /// The default value for [Session_Version].
  static const $default = versionUnspecified;

  const Session_Version(super.value);

  factory Session_Version.fromJson(String json) => Session_Version(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Version.$value';
}

/// The request for the CreateSession method.
final class CreateSessionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.CreateSessionRequest';

  /// The session to be created.
  /// Sessions are immutable once they are created (although they can
  /// be deleted).
  final Session? session;

  CreateSessionRequest({this.session}) : super(fullyQualifiedName);

  factory CreateSessionRequest.fromJson(Map<String, dynamic> json) =>
      CreateSessionRequest(session: decode(json['session'], Session.fromJson));

  @override
  Object toJson() => {if (session != null) 'session': session!.toJson()};

  @override
  String toString() => 'CreateSessionRequest()';
}

/// The request for the GetSession method.
final class GetSessionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.GetSessionRequest';

  /// The session to be retrieved.
  final String name;

  GetSessionRequest({String? name})
    : name = name ?? '',
      super(fullyQualifiedName);

  factory GetSessionRequest.fromJson(Map<String, dynamic> json) =>
      GetSessionRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {if (name.isNotDefault) 'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'GetSessionRequest($contents)';
  }
}

/// The request for the ListSessions method.
final class ListSessionsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListSessionsRequest';

  /// The maximum number of sessions to return per page.
  final int pageSize;

  /// The page token, for retrieving subsequent pages.
  final String pageToken;

  ListSessionsRequest({int? pageSize, String? pageToken})
    : pageSize = pageSize ?? 0,
      pageToken = pageToken ?? '',
      super(fullyQualifiedName);

  factory ListSessionsRequest.fromJson(Map<String, dynamic> json) =>
      ListSessionsRequest(
        pageSize: json['pageSize'] ?? 0,
        pageToken: json['pageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = ['pageSize=$pageSize', 'pageToken=$pageToken'].join(',');
    return 'ListSessionsRequest($contents)';
  }
}

/// Response for the ListSessions method.
final class ListSessionsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListSessionsResponse';

  /// The sessions being returned.
  final List<Session> sessions;

  /// The next page token, if any.
  /// An empty value here means the last page has been reached.
  final String nextPageToken;

  ListSessionsResponse({this.sessions = const [], String? nextPageToken})
    : nextPageToken = nextPageToken ?? '',
      super(fullyQualifiedName);

  factory ListSessionsResponse.fromJson(Map<String, dynamic> json) =>
      ListSessionsResponse(
        sessions: decodeListMessage(json['sessions'], Session.fromJson) ?? [],
        nextPageToken: json['nextPageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (sessions.isNotDefault) 'sessions': encodeList(sessions),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListSessionsResponse($contents)';
  }
}

/// Request for the DeleteSession method.
final class DeleteSessionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.DeleteSessionRequest';

  /// The session to be deleted.
  final String name;

  DeleteSessionRequest({String? name})
    : name = name ?? '',
      super(fullyQualifiedName);

  factory DeleteSessionRequest.fromJson(Map<String, dynamic> json) =>
      DeleteSessionRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {if (name.isNotDefault) 'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteSessionRequest($contents)';
  }
}

/// Request message for reporting on a session.
final class ReportSessionRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ReportSessionRequest';

  /// The session to be reported on.
  final String name;

  ReportSessionRequest({String? name})
    : name = name ?? '',
      super(fullyQualifiedName);

  factory ReportSessionRequest.fromJson(Map<String, dynamic> json) =>
      ReportSessionRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {if (name.isNotDefault) 'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'ReportSessionRequest($contents)';
  }
}

/// Response message for reporting on a session.
final class ReportSessionResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ReportSessionResponse';

  /// The state of the report.
  final ReportSessionResponse_Result result;

  /// The test runs of this session.
  final List<TestRun> testRuns;

  ReportSessionResponse({
    this.result = ReportSessionResponse_Result.$default,
    this.testRuns = const [],
  }) : super(fullyQualifiedName);

  factory ReportSessionResponse.fromJson(Map<String, dynamic> json) =>
      ReportSessionResponse(
        result:
            decodeEnum(json['result'], ReportSessionResponse_Result.fromJson) ??
            ReportSessionResponse_Result.$default,
        testRuns: decodeListMessage(json['testRuns'], TestRun.fromJson) ?? [],
      );

  @override
  Object toJson() => {
    if (result.isNotDefault) 'result': result.toJson(),
    if (testRuns.isNotDefault) 'testRuns': encodeList(testRuns),
  };

  @override
  String toString() {
    final contents = ['result=$result'].join(',');
    return 'ReportSessionResponse($contents)';
  }
}

/// The topline state of the report.
final class ReportSessionResponse_Result extends ProtoEnum {
  static const resultUnspecified = ReportSessionResponse_Result(
    'RESULT_UNSPECIFIED',
  );

  /// The session is complete, and everything passed.
  static const passed = ReportSessionResponse_Result('PASSED');

  /// The session had an explicit failure.
  static const failed = ReportSessionResponse_Result('FAILED');

  /// The session is incomplete. This is a failure response.
  static const incomplete = ReportSessionResponse_Result('INCOMPLETE');

  /// The default value for [ReportSessionResponse_Result].
  static const $default = resultUnspecified;

  const ReportSessionResponse_Result(super.value);

  factory ReportSessionResponse_Result.fromJson(String json) =>
      ReportSessionResponse_Result(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Result.$value';
}

final class Test extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.Test';

  /// The name of the test.
  /// The tests/* portion of the names are hard-coded, and do not change
  /// from session to session.
  final String name;

  /// The expectation level for this test.
  final Test_ExpectationLevel expectationLevel;

  /// A description of the test.
  final String description;

  /// The blueprints that will satisfy this test. There may be multiple blueprints
  /// that can signal to the server that this test case is being exercised. Although
  /// multiple blueprints are specified, only a single blueprint needs to be run to
  /// signal that the test case was exercised.
  final List<Test_Blueprint> blueprints;

  Test({
    String? name,
    this.expectationLevel = Test_ExpectationLevel.$default,
    String? description,
    this.blueprints = const [],
  }) : name = name ?? '',
       description = description ?? '',
       super(fullyQualifiedName);

  factory Test.fromJson(Map<String, dynamic> json) => Test(
    name: json['name'] ?? '',
    expectationLevel:
        decodeEnum(json['expectationLevel'], Test_ExpectationLevel.fromJson) ??
        Test_ExpectationLevel.$default,
    description: json['description'] ?? '',
    blueprints:
        decodeListMessage(json['blueprints'], Test_Blueprint.fromJson) ?? [],
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (expectationLevel.isNotDefault)
      'expectationLevel': expectationLevel.toJson(),
    if (description.isNotDefault) 'description': description,
    if (blueprints.isNotDefault) 'blueprints': encodeList(blueprints),
  };

  @override
  String toString() {
    final contents = [
      'name=$name',
      'expectationLevel=$expectationLevel',
      'description=$description',
    ].join(',');
    return 'Test($contents)';
  }
}

/// A blueprint is an explicit definition of methods and requests that are needed
/// to be made to test this specific test case. Ideally this would be represented
/// by something more robust like CEL, but as of writing this, I am unsure if CEL
/// is ready.
final class Test_Blueprint extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.Test.Blueprint';

  /// The name of this blueprint.
  final String name;

  /// A description of this blueprint.
  final String description;

  /// The initial request to trigger this test.
  final Test_Blueprint_Invocation? request;

  /// An ordered list of method calls that can be called to trigger this test.
  final List<Test_Blueprint_Invocation> additionalRequests;

  Test_Blueprint({
    String? name,
    String? description,
    this.request,
    this.additionalRequests = const [],
  }) : name = name ?? '',
       description = description ?? '',
       super(fullyQualifiedName);

  factory Test_Blueprint.fromJson(Map<String, dynamic> json) => Test_Blueprint(
    name: json['name'] ?? '',
    description: json['description'] ?? '',
    request: decode(json['request'], Test_Blueprint_Invocation.fromJson),
    additionalRequests:
        decodeListMessage(
          json['additionalRequests'],
          Test_Blueprint_Invocation.fromJson,
        ) ??
        [],
  );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (description.isNotDefault) 'description': description,
    if (request != null) 'request': request!.toJson(),
    if (additionalRequests.isNotDefault)
      'additionalRequests': encodeList(additionalRequests),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'description=$description'].join(',');
    return 'Blueprint($contents)';
  }
}

/// A message representing a method invocation.
final class Test_Blueprint_Invocation extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.Test.Blueprint.Invocation';

  /// The fully qualified name of the showcase method to be invoked.
  final String method;

  /// The request to be made if a specific request is necessary.
  final Uint8List serializedRequest;

  Test_Blueprint_Invocation({
    String? method,
    this.serializedRequest = Uint8List(0),
  }) : method = method ?? '',
       super(fullyQualifiedName);

  factory Test_Blueprint_Invocation.fromJson(Map<String, dynamic> json) =>
      Test_Blueprint_Invocation(
        method: json['method'] ?? '',
        serializedRequest:
            decodeBytes(json['serializedRequest']) ?? Uint8List(0),
      );

  @override
  Object toJson() => {
    if (method.isNotDefault) 'method': method,
    if (serializedRequest.isNotDefault)
      'serializedRequest': encodeBytes(serializedRequest),
  };

  @override
  String toString() {
    final contents = [
      'method=$method',
      'serializedRequest=$serializedRequest',
    ].join(',');
    return 'Invocation($contents)';
  }
}

/// Whether or not a test is required, recommended, or optional.
final class Test_ExpectationLevel extends ProtoEnum {
  static const expectationLevelUnspecified = Test_ExpectationLevel(
    'EXPECTATION_LEVEL_UNSPECIFIED',
  );

  /// This test is strictly required.
  static const required = Test_ExpectationLevel('REQUIRED');

  /// This test is recommended.
  ///
  /// If a generator explicitly ignores a recommended test (see `DeleteTest`),
  /// then the report may still pass, but with a warning.
  ///
  /// If a generator skips a recommended test and does not explicitly
  /// express that intention, the report will fail.
  static const recommended = Test_ExpectationLevel('RECOMMENDED');

  /// This test is optional.
  ///
  /// If a generator explicitly ignores an optional test (see `DeleteTest`),
  /// then the report may still pass, and no warning will be issued.
  ///
  /// If a generator skips an optional test and does not explicitly
  /// express that intention, the report may still pass, but with a
  /// warning.
  static const optional = Test_ExpectationLevel('OPTIONAL');

  /// The default value for [Test_ExpectationLevel].
  static const $default = expectationLevelUnspecified;

  const Test_ExpectationLevel(super.value);

  factory Test_ExpectationLevel.fromJson(String json) =>
      Test_ExpectationLevel(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'ExpectationLevel.$value';
}

/// An issue found in the test.
final class Issue extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.Issue';

  /// The type of the issue.
  final Issue_Type type;

  /// The severity of the issue.
  final Issue_Severity severity;

  /// A description of the issue.
  final String description;

  Issue({
    this.type = Issue_Type.$default,
    this.severity = Issue_Severity.$default,
    String? description,
  }) : description = description ?? '',
       super(fullyQualifiedName);

  factory Issue.fromJson(Map<String, dynamic> json) => Issue(
    type: decodeEnum(json['type'], Issue_Type.fromJson) ?? Issue_Type.$default,
    severity:
        decodeEnum(json['severity'], Issue_Severity.fromJson) ??
        Issue_Severity.$default,
    description: json['description'] ?? '',
  );

  @override
  Object toJson() => {
    if (type.isNotDefault) 'type': type.toJson(),
    if (severity.isNotDefault) 'severity': severity.toJson(),
    if (description.isNotDefault) 'description': description,
  };

  @override
  String toString() {
    final contents = [
      'type=$type',
      'severity=$severity',
      'description=$description',
    ].join(',');
    return 'Issue($contents)';
  }
}

/// The different potential types of issues.
final class Issue_Type extends ProtoEnum {
  static const typeUnspecified = Issue_Type('TYPE_UNSPECIFIED');

  /// The test was never instrumented.
  static const skipped = Issue_Type('SKIPPED');

  /// The test was started but never confirmed.
  static const pending = Issue_Type('PENDING');

  /// The test was instrumented, but Showcase got an unexpected
  /// value when the generator tried to confirm success.
  static const incorrectConfirmation = Issue_Type('INCORRECT_CONFIRMATION');

  /// The default value for [Issue_Type].
  static const $default = typeUnspecified;

  const Issue_Type(super.value);

  factory Issue_Type.fromJson(String json) => Issue_Type(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Type.$value';
}

/// Severity levels.
final class Issue_Severity extends ProtoEnum {
  static const severityUnspecified = Issue_Severity('SEVERITY_UNSPECIFIED');

  /// Errors.
  static const error = Issue_Severity('ERROR');

  /// Warnings.
  static const warning = Issue_Severity('WARNING');

  /// The default value for [Issue_Severity].
  static const $default = severityUnspecified;

  const Issue_Severity(super.value);

  factory Issue_Severity.fromJson(String json) => Issue_Severity(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Severity.$value';
}

/// The request for the ListTests method.
final class ListTestsRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListTestsRequest';

  /// The session.
  final String parent;

  /// The maximum number of tests to return per page.
  final int pageSize;

  /// The page token, for retrieving subsequent pages.
  final String pageToken;

  ListTestsRequest({String? parent, int? pageSize, String? pageToken})
    : parent = parent ?? '',
      pageSize = pageSize ?? 0,
      pageToken = pageToken ?? '',
      super(fullyQualifiedName);

  factory ListTestsRequest.fromJson(Map<String, dynamic> json) =>
      ListTestsRequest(
        parent: json['parent'] ?? '',
        pageSize: json['pageSize'] ?? 0,
        pageToken: json['pageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (parent.isNotDefault) 'parent': parent,
    if (pageSize.isNotDefault) 'pageSize': pageSize,
    if (pageToken.isNotDefault) 'pageToken': pageToken,
  };

  @override
  String toString() {
    final contents = [
      'parent=$parent',
      'pageSize=$pageSize',
      'pageToken=$pageToken',
    ].join(',');
    return 'ListTestsRequest($contents)';
  }
}

/// The response for the ListTests method.
final class ListTestsResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.ListTestsResponse';

  /// The tests being returned.
  final List<Test> tests;

  /// The next page token, if any.
  /// An empty value here means the last page has been reached.
  final String nextPageToken;

  ListTestsResponse({this.tests = const [], String? nextPageToken})
    : nextPageToken = nextPageToken ?? '',
      super(fullyQualifiedName);

  factory ListTestsResponse.fromJson(Map<String, dynamic> json) =>
      ListTestsResponse(
        tests: decodeListMessage(json['tests'], Test.fromJson) ?? [],
        nextPageToken: json['nextPageToken'] ?? '',
      );

  @override
  Object toJson() => {
    if (tests.isNotDefault) 'tests': encodeList(tests),
    if (nextPageToken.isNotDefault) 'nextPageToken': nextPageToken,
  };

  @override
  String toString() {
    final contents = ['nextPageToken=$nextPageToken'].join(',');
    return 'ListTestsResponse($contents)';
  }
}

/// A TestRun is the result of running a Test.
final class TestRun extends ProtoMessage {
  static const String fullyQualifiedName = 'google.showcase.v1beta1.TestRun';

  /// The name of the test.
  /// The tests/* portion of the names are hard-coded, and do not change
  /// from session to session.
  final String test;

  /// An issue found with the test run. If empty, this test run was successful.
  final Issue? issue;

  TestRun({String? test, this.issue})
    : test = test ?? '',
      super(fullyQualifiedName);

  factory TestRun.fromJson(Map<String, dynamic> json) => TestRun(
    test: json['test'] ?? '',
    issue: decode(json['issue'], Issue.fromJson),
  );

  @override
  Object toJson() => {
    if (test.isNotDefault) 'test': test,
    if (issue != null) 'issue': issue!.toJson(),
  };

  @override
  String toString() {
    final contents = ['test=$test'].join(',');
    return 'TestRun($contents)';
  }
}

/// Request message for deleting a test.
final class DeleteTestRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.DeleteTestRequest';

  /// The test to be deleted.
  final String name;

  DeleteTestRequest({String? name})
    : name = name ?? '',
      super(fullyQualifiedName);

  factory DeleteTestRequest.fromJson(Map<String, dynamic> json) =>
      DeleteTestRequest(name: json['name'] ?? '');

  @override
  Object toJson() => {if (name.isNotDefault) 'name': name};

  @override
  String toString() {
    final contents = ['name=$name'].join(',');
    return 'DeleteTestRequest($contents)';
  }
}

final class VerifyTestRequest extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.VerifyTestRequest';

  /// The test to have an answer registered to it.
  final String name;

  /// The answer from the test.
  final Uint8List answer;

  /// The answers from the test if multiple are to be checked
  final List<Uint8List> answers;

  VerifyTestRequest({
    String? name,
    this.answer = Uint8List(0),
    this.answers = const [],
  }) : name = name ?? '',
       super(fullyQualifiedName);

  factory VerifyTestRequest.fromJson(Map<String, dynamic> json) =>
      VerifyTestRequest(
        name: json['name'] ?? '',
        answer: decodeBytes(json['answer']) ?? Uint8List(0),
        answers: decodeListBytes(json['answers']) ?? [],
      );

  @override
  Object toJson() => {
    if (name.isNotDefault) 'name': name,
    if (answer.isNotDefault) 'answer': encodeBytes(answer),
    if (answers.isNotDefault) 'answers': encodeListBytes(answers),
  };

  @override
  String toString() {
    final contents = ['name=$name', 'answer=$answer'].join(',');
    return 'VerifyTestRequest($contents)';
  }
}

final class VerifyTestResponse extends ProtoMessage {
  static const String fullyQualifiedName =
      'google.showcase.v1beta1.VerifyTestResponse';

  /// An issue if check answer was unsuccessful. This will be empty if the check answer succeeded.
  final Issue? issue;

  VerifyTestResponse({this.issue}) : super(fullyQualifiedName);

  factory VerifyTestResponse.fromJson(Map<String, dynamic> json) =>
      VerifyTestResponse(issue: decode(json['issue'], Issue.fromJson));

  @override
  Object toJson() => {if (issue != null) 'issue': issue!.toJson()};

  @override
  String toString() => 'VerifyTestResponse()';
}

final class Continent extends ProtoEnum {
  static const continentUnspecified = Continent('CONTINENT_UNSPECIFIED');

  static const africa = Continent('AFRICA');

  static const america = Continent('AMERICA');

  static const antartica = Continent('ANTARTICA');

  static const australia = Continent('AUSTRALIA');

  static const europe = Continent('EUROPE');

  /// The default value for [Continent].
  static const $default = continentUnspecified;

  const Continent(super.value);

  factory Continent.fromJson(String json) => Continent(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Continent.$value';
}

/// A severity enum used to test enum capabilities in GAPIC surfaces.
final class Severity extends ProtoEnum {
  static const unnecessary = Severity('UNNECESSARY');

  static const necessary = Severity('NECESSARY');

  static const urgent = Severity('URGENT');

  static const critical = Severity('CRITICAL');

  /// The default value for [Severity].
  static const $default = unnecessary;

  const Severity(super.value);

  factory Severity.fromJson(String json) => Severity(json);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'Severity.$value';
}
