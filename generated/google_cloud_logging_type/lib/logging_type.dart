// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

/// The Google Cloud client for the Logging types.
///
library;

// ignore_for_file: avoid_unused_constructor_parameters
// ignore_for_file: camel_case_types
// ignore_for_file: comment_references
// ignore_for_file: implementation_imports
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: unintended_html_in_doc_comment

import 'package:google_cloud_protobuf/protobuf.dart';
import 'package:google_cloud_protobuf/src/encoding.dart';

/// A common proto for logging HTTP requests. Only contains semantics
/// defined by the HTTP specification. Product-specific logging
/// information MUST be defined in a separate message.
final class HttpRequest extends ProtoMessage {
  static const String fullyQualifiedName = 'google.logging.type.HttpRequest';

  /// The request method. Examples: `"GET"`, `"HEAD"`, `"PUT"`, `"POST"`.
  final String requestMethod;

  /// The scheme (http, https), the host name, the path and the query
  /// portion of the URL that was requested.
  /// Example: `"http://example.com/some/info?color=red"`.
  final String requestUrl;

  /// The size of the HTTP request message in bytes, including the request
  /// headers and the request body.
  final int requestSize;

  /// The response code indicating the status of response.
  /// Examples: 200, 404.
  final int status;

  /// The size of the HTTP response message sent back to the client, in bytes,
  /// including the response headers and the response body.
  final int responseSize;

  /// The user agent sent by the client. Example:
  /// `"Mozilla/4.0 (compatible; MSIE 6.0; Windows 98; Q312461; .NET
  /// CLR 1.0.3705)"`.
  final String userAgent;

  /// The IP address (IPv4 or IPv6) of the client that issued the HTTP
  /// request. This field can include port information. Examples:
  /// `"192.168.1.1"`, `"10.0.0.1:80"`, `"FE80::0202:B3FF:FE1E:8329"`.
  final String remoteIp;

  /// The IP address (IPv4 or IPv6) of the origin server that the request was
  /// sent to. This field can include port information. Examples:
  /// `"192.168.1.1"`, `"10.0.0.1:80"`, `"FE80::0202:B3FF:FE1E:8329"`.
  final String serverIp;

  /// The referer URL of the request, as defined in
  /// [HTTP/1.1 Header Field
  /// Definitions](https://datatracker.ietf.org/doc/html/rfc2616#section-14.36).
  final String referer;

  /// The request processing latency on the server, from the time the request was
  /// received until the response was sent.
  final Duration? latency;

  /// Whether or not a cache lookup was attempted.
  final bool cacheLookup;

  /// Whether or not an entity was served from cache
  /// (with or without validation).
  final bool cacheHit;

  /// Whether or not the response was validated with the origin server before
  /// being served from cache. This field is only meaningful if `cache_hit` is
  /// True.
  final bool cacheValidatedWithOriginServer;

  /// The number of HTTP response bytes inserted into cache. Set only when a
  /// cache fill was attempted.
  final int cacheFillBytes;

  /// Protocol used for the request. Examples: "HTTP/1.1", "HTTP/2", "websocket"
  final String protocol;

  HttpRequest({
    this.requestMethod = '',
    this.requestUrl = '',
    this.requestSize = 0,
    this.status = 0,
    this.responseSize = 0,
    this.userAgent = '',
    this.remoteIp = '',
    this.serverIp = '',
    this.referer = '',
    this.latency,
    this.cacheLookup = false,
    this.cacheHit = false,
    this.cacheValidatedWithOriginServer = false,
    this.cacheFillBytes = 0,
    this.protocol = '',
  }) : super(fullyQualifiedName);

  factory HttpRequest.fromJson(Object? j) {
    final json = j as Map<String, Object?>;
    return HttpRequest(
      requestMethod: switch (json['requestMethod']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requestUrl: switch (json['requestUrl']) {
        null => '',
        Object $1 => decodeString($1),
      },
      requestSize: switch (json['requestSize']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      status: switch (json['status']) {
        null => 0,
        Object $1 => decodeInt($1),
      },
      responseSize: switch (json['responseSize']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      userAgent: switch (json['userAgent']) {
        null => '',
        Object $1 => decodeString($1),
      },
      remoteIp: switch (json['remoteIp']) {
        null => '',
        Object $1 => decodeString($1),
      },
      serverIp: switch (json['serverIp']) {
        null => '',
        Object $1 => decodeString($1),
      },
      referer: switch (json['referer']) {
        null => '',
        Object $1 => decodeString($1),
      },
      latency: switch (json['latency']) {
        null => null,
        Object $1 => Duration.fromJson($1),
      },
      cacheLookup: switch (json['cacheLookup']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      cacheHit: switch (json['cacheHit']) {
        null => false,
        Object $1 => decodeBool($1),
      },
      cacheValidatedWithOriginServer:
          switch (json['cacheValidatedWithOriginServer']) {
            null => false,
            Object $1 => decodeBool($1),
          },
      cacheFillBytes: switch (json['cacheFillBytes']) {
        null => 0,
        Object $1 => decodeInt64($1),
      },
      protocol: switch (json['protocol']) {
        null => '',
        Object $1 => decodeString($1),
      },
    );
  }

  @override
  Object toJson() => {
    if (requestMethod.isNotDefault) 'requestMethod': requestMethod,
    if (requestUrl.isNotDefault) 'requestUrl': requestUrl,
    if (requestSize.isNotDefault) 'requestSize': encodeInt64(requestSize),
    if (status.isNotDefault) 'status': status,
    if (responseSize.isNotDefault) 'responseSize': encodeInt64(responseSize),
    if (userAgent.isNotDefault) 'userAgent': userAgent,
    if (remoteIp.isNotDefault) 'remoteIp': remoteIp,
    if (serverIp.isNotDefault) 'serverIp': serverIp,
    if (referer.isNotDefault) 'referer': referer,
    if (latency != null) 'latency': latency!.toJson(),
    if (cacheLookup.isNotDefault) 'cacheLookup': cacheLookup,
    if (cacheHit.isNotDefault) 'cacheHit': cacheHit,
    if (cacheValidatedWithOriginServer.isNotDefault)
      'cacheValidatedWithOriginServer': cacheValidatedWithOriginServer,
    if (cacheFillBytes.isNotDefault)
      'cacheFillBytes': encodeInt64(cacheFillBytes),
    if (protocol.isNotDefault) 'protocol': protocol,
  };

  @override
  String toString() {
    final contents = [
      'requestMethod=$requestMethod',
      'requestUrl=$requestUrl',
      'requestSize=$requestSize',
      'status=$status',
      'responseSize=$responseSize',
      'userAgent=$userAgent',
      'remoteIp=$remoteIp',
      'serverIp=$serverIp',
      'referer=$referer',
      'cacheLookup=$cacheLookup',
      'cacheHit=$cacheHit',
      'cacheValidatedWithOriginServer=$cacheValidatedWithOriginServer',
      'cacheFillBytes=$cacheFillBytes',
      'protocol=$protocol',
    ].join(',');
    return 'HttpRequest($contents)';
  }
}

/// The severity of the event described in a log entry, expressed as one of the
/// standard severity levels listed below.  For your reference, the levels are
/// assigned the listed numeric values. The effect of using numeric values other
/// than those listed is undefined.
///
/// You can filter for log entries by severity.  For example, the following
/// filter expression will match log entries with severities `INFO`, `NOTICE`,
/// and `WARNING`:
///
///     severity > DEBUG AND severity <= WARNING
///
/// If you are writing log entries, you should map other severity encodings to
/// one of these standard levels. For example, you might map all of Java's FINE,
/// FINER, and FINEST levels to `LogSeverity.DEBUG`. You can preserve the
/// original severity level in the log entry payload if you wish.
final class LogSeverity extends ProtoEnum {
  /// (0) The log entry has no assigned severity level.
  static const default$ = LogSeverity('DEFAULT');

  /// (100) Debug or trace information.
  static const debug = LogSeverity('DEBUG');

  /// (200) Routine information, such as ongoing status or performance.
  static const info = LogSeverity('INFO');

  /// (300) Normal but significant events, such as start up, shut down, or
  /// a configuration change.
  static const notice = LogSeverity('NOTICE');

  /// (400) Warning events might cause problems.
  static const warning = LogSeverity('WARNING');

  /// (500) Error events are likely to cause problems.
  static const error = LogSeverity('ERROR');

  /// (600) Critical events cause more severe problems or outages.
  static const critical = LogSeverity('CRITICAL');

  /// (700) A person must take an action immediately.
  static const alert = LogSeverity('ALERT');

  /// (800) One or more systems are unusable.
  static const emergency = LogSeverity('EMERGENCY');

  /// The default value for [LogSeverity].
  static const $default = default$;

  const LogSeverity(super.value);

  factory LogSeverity.fromJson(Object? json) => LogSeverity(json as String);

  bool get isNotDefault => this != $default;

  @override
  String toString() => 'LogSeverity.$value';
}
